using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis.PooledObjects;
using Microsoft.CodeAnalysis.RuntimeMembers;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis.VisualBasic.Emit.NoPia;
using Microsoft.CodeAnalysis.VisualBasic.Symbols;
using Microsoft.CodeAnalysis.VisualBasic.Syntax;
using Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax;
using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using Roslyn.Utilities;

namespace Microsoft.CodeAnalysis.VisualBasic
{
	internal abstract class Binder
	{
		internal class AnonymousTypeCreationBinder : Binder
		{
			private readonly AnonymousTypeField[] _fields;

			private readonly Dictionary<string, int> _fieldName2index;

			private ArrayBuilder<BoundAnonymousTypePropertyAccess> _fieldDeclarations;

			private readonly LocalSymbol[] _locals;

			private readonly PropertySymbol[] _propertySymbols;

			private bool _freeze;

			internal static BoundExpression BindAnonymousObjectInitializer(Binder containingBinder, VisualBasicSyntaxNode owningSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax initializerSyntax, SyntaxToken typeLocationToken, BindingDiagnosticBag diagnostics)
			{
				if (initializerSyntax.Initializers.Count == 0)
				{
					return BadExpression(owningSyntax, ImmutableArray<BoundExpression>.Empty, ErrorTypeSymbol.UnknownResultType);
				}
				return new AnonymousTypeCreationBinder(containingBinder, initializerSyntax, diagnostics).BindInitializersAndCreateBoundNode(owningSyntax, initializerSyntax, diagnostics, typeLocationToken);
			}

			private AnonymousTypeCreationBinder(Binder containingBinder, Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax initializerSyntax, BindingDiagnosticBag diagnostics)
				: base(containingBinder)
			{
				TypeSymbol specialType = GetSpecialType(SpecialType.System_Object, initializerSyntax, diagnostics);
				SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax> initializers = initializerSyntax.Initializers;
				int count = initializers.Count;
				_fieldName2index = new Dictionary<string, int>(count, CaseInsensitiveComparison.Comparer);
				_fields = new AnonymousTypeField[count - 1 + 1];
				_fieldDeclarations = null;
				_locals = new LocalSymbol[count - 1 + 1];
				_propertySymbols = new PropertySymbol[count - 1 + 1];
				int num = count - 1;
				for (int i = 0; i <= num; i++)
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax fieldInitializerSyntax = initializers[i];
					string text = null;
					VisualBasicSyntaxNode visualBasicSyntaxNode = null;
					bool flag = false;
					if (fieldInitializerSyntax.Kind() == SyntaxKind.InferredFieldInitializer)
					{
						Microsoft.CodeAnalysis.VisualBasic.Syntax.InferredFieldInitializerSyntax inferredFieldInitializerSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.InferredFieldInitializerSyntax)fieldInitializerSyntax;
						Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression = inferredFieldInitializerSyntax.Expression;
						Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax failedToInferFromXmlName = null;
						SyntaxToken token = SyntaxNodeExtensions.ExtractAnonymousTypeMemberName(expression, out failedToInferFromXmlName);
						if (VisualBasicExtensions.Kind(token) == SyntaxKind.None)
						{
							text = null;
							visualBasicSyntaxNode = inferredFieldInitializerSyntax.Expression;
							flag = false;
						}
						else
						{
							text = token.ValueText;
							visualBasicSyntaxNode = (VisualBasicSyntaxNode)token.Parent;
							flag = VisualBasicExtensions.Kind(inferredFieldInitializerSyntax.KeyKeyword) == SyntaxKind.KeyKeyword;
						}
					}
					else
					{
						Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax obj = (Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax)fieldInitializerSyntax;
						visualBasicSyntaxNode = obj.Name;
						flag = VisualBasicExtensions.Kind(obj.KeyKeyword) == SyntaxKind.KeyKeyword;
						text = obj.Name.Identifier.ValueText;
					}
					if (ExtractTypeCharacter(visualBasicSyntaxNode) != 0)
					{
						ReportDiagnostic(diagnostics, fieldInitializerSyntax, ERRID.ERR_AnonymousTypeDisallowsTypeChar);
					}
					if (string.IsNullOrEmpty(text))
					{
						text = "$" + i;
					}
					else if (specialType.GetMembers(text).Any() || _fieldName2index.ContainsKey(text))
					{
						ReportDiagnostic(diagnostics, fieldInitializerSyntax, ErrorFactory.ErrorInfo(ERRID.ERR_DuplicateAnonTypeMemberName1, text));
					}
					_fields[i] = new AnonymousTypeField(text, visualBasicSyntaxNode.GetLocation(), flag);
					_fieldName2index[text] = i;
				}
			}

			private BoundExpression BindInitializersAndCreateBoundNode(VisualBasicSyntaxNode owningSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax initializerSyntax, BindingDiagnosticBag diagnostics, SyntaxToken typeLocationToken)
			{
				int num = _fields.Length;
				BoundExpression[] array = new BoundExpression[num - 1 + 1];
				int num2 = num - 1;
				for (int i = 0; i <= num2; i++)
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax fieldInitializerSyntax = initializerSyntax.Initializers[i];
					Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax namedFieldInitializerSyntax = null;
					Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expressionSyntax = null;
					if (fieldInitializerSyntax.Kind() == SyntaxKind.InferredFieldInitializer)
					{
						expressionSyntax = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.InferredFieldInitializerSyntax)fieldInitializerSyntax).Expression;
					}
					else
					{
						namedFieldInitializerSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax)fieldInitializerSyntax;
						expressionSyntax = namedFieldInitializerSyntax.Expression;
					}
					AnonymousTypeFieldInitializerBinder anonymousTypeFieldInitializerBinder = new AnonymousTypeFieldInitializerBinder(this, i);
					BoundExpression boundExpression = anonymousTypeFieldInitializerBinder.BindRValue(expressionSyntax, diagnostics);
					TypeSymbol type = (array[i] = BoundNodeExtensions.MakeCompilerGenerated(new BoundAnonymousTypeFieldInitializer(fieldInitializerSyntax, anonymousTypeFieldInitializerBinder, boundExpression, boundExpression.Type))).Type;
					TypeSymbol restrictedType = null;
					if (TypeSymbolExtensions.IsRestrictedTypeOrArrayType(type, out restrictedType))
					{
						ReportDiagnostic(diagnostics, expressionSyntax, ERRID.ERR_RestrictedType1, restrictedType);
					}
					_fields[i].AssignFieldType(type);
					if (namedFieldInitializerSyntax != null)
					{
						if (_fieldDeclarations == null)
						{
							_fieldDeclarations = ArrayBuilder<BoundAnonymousTypePropertyAccess>.GetInstance();
						}
						_fieldDeclarations.Add(new BoundAnonymousTypePropertyAccess(namedFieldInitializerSyntax.Name, this, i, type));
					}
				}
				BoundExpression result = CreateAnonymousObjectCreationExpression(owningSyntax, new AnonymousTypeDescriptor(_fields.AsImmutableOrNull(), typeLocationToken.GetLocation(), isImplicitlyDeclared: false), array.AsImmutableOrNull());
				_freeze = true;
				return result;
			}

			protected override BoundAnonymousTypeCreationExpression CreateAnonymousObjectCreationExpression(VisualBasicSyntaxNode node, AnonymousTypeManager.AnonymousTypePublicSymbol anonymousType, ImmutableArray<BoundExpression> initExpressions, bool hasErrors = false)
			{
				int num = _fields.Length - 1;
				for (int i = 0; i <= num; i++)
				{
					if (_fields[i].Name[0] != '$')
					{
						_propertySymbols[i] = anonymousType.Properties[i];
					}
				}
				return new BoundAnonymousTypeCreationExpression(node, this, (_fieldDeclarations == null) ? ImmutableArray<BoundAnonymousTypePropertyAccess>.Empty : _fieldDeclarations.ToImmutableAndFree(), initExpressions, anonymousType, hasErrors);
			}

			internal PropertySymbol GetAnonymousTypePropertySymbol(int index)
			{
				return _propertySymbols[index];
			}

			internal LocalSymbol GetAnonymousTypePropertyLocal(int index)
			{
				return _locals[index];
			}

			internal bool TryGetField(string name, out AnonymousTypeField field, out int fieldIndex)
			{
				if (_fieldName2index.TryGetValue(name, out fieldIndex))
				{
					field = _fields[fieldIndex];
					return true;
				}
				field = default(AnonymousTypeField);
				return false;
			}

			internal void RegisterFieldReference(int fieldIndex)
			{
				if (!_freeze)
				{
					LocalSymbol localSymbol = _locals[fieldIndex];
					if ((object)localSymbol == null)
					{
						localSymbol = new SynthesizedLocal(ContainingMember, _fields[fieldIndex].Type, SynthesizedLocalKind.LoweringTemp);
						_locals[fieldIndex] = localSymbol;
					}
				}
			}
		}

		internal class AnonymousTypeFieldInitializerBinder : Binder
		{
			private readonly int _initializerOrdinal;

			public AnonymousTypeFieldInitializerBinder(AnonymousTypeCreationBinder creationBinder, int initializerOrdinal)
				: base(creationBinder)
			{
				_initializerOrdinal = initializerOrdinal;
			}

			protected internal override BoundExpression TryBindOmittedLeftForMemberAccess(Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax node, BindingDiagnosticBag diagnostics, Binder accessingBinder, out bool wholeMemberAccessExpressionBound)
			{
				wholeMemberAccessExpressionBound = true;
				AnonymousTypeCreationBinder anonymousTypeCreationBinder = (AnonymousTypeCreationBinder)base.ContainingBinder;
				if (node.ContainsDiagnostics)
				{
					return BadExpression(node, ErrorTypeSymbol.UnknownResultType);
				}
				Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax name = node.Name;
				string valueText = name.Identifier.ValueText;
				int fieldIndex = 0;
				AnonymousTypeField field = default(AnonymousTypeField);
				if (anonymousTypeCreationBinder.TryGetField(valueText, out field, out fieldIndex))
				{
					bool flag = false;
					if (name.Kind() == SyntaxKind.GenericName)
					{
						ReportDiagnostic(diagnostics, ((Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax)name).TypeArgumentList, ERRID.ERR_TypeOrMemberNotGeneric1, string.Format("Public {0}Property {1} As T{2}", field.IsKey ? "Readonly " : "", valueText, fieldIndex));
						flag = true;
					}
					if (fieldIndex >= _initializerOrdinal)
					{
						if (!flag)
						{
							ReportDiagnostic(diagnostics, node, ERRID.ERR_AnonymousTypePropertyOutOfOrder1, valueText);
						}
						return BadExpression(node, ErrorTypeSymbol.UnknownResultType);
					}
					anonymousTypeCreationBinder.RegisterFieldReference(fieldIndex);
					if ((object)ContainingMember != accessingBinder.ContainingMember)
					{
						ReportDiagnostic(diagnostics, node, ERRID.ERR_CannotLiftAnonymousType1, node.Name.Identifier.ValueText);
						flag = true;
					}
					return new BoundAnonymousTypePropertyAccess(node, anonymousTypeCreationBinder, fieldIndex, field.Type, flag);
				}
				ReportDiagnostic(diagnostics, node, ERRID.ERR_NameNotMemberOfAnonymousType2, valueText, "<anonymous type>");
				return BadExpression(node, ErrorTypeSymbol.UnknownResultType);
			}

			protected override BoundExpression TryBindOmittedLeftForDictionaryAccess(Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax node, Binder accessingBinder, BindingDiagnosticBag diagnostics)
			{
				ReportDiagnostic(diagnostics, node, ERRID.ERR_NoDefaultNotExtend1, "<anonymous type>");
				return BadExpression(node, ErrorTypeSymbol.UnknownResultType);
			}

			protected override BoundExpression TryBindOmittedLeftForConditionalAccess(Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax node, Binder accessingBinder, BindingDiagnosticBag diagnostics)
			{
				return null;
			}
		}

		internal struct AttributeExpressionVisitor
		{
			private readonly Binder _binder;

			private bool _hasErrors;

			public bool HasErrors => _hasErrors;

			public AttributeExpressionVisitor(Binder binder, bool hasErrors)
			{
				this = default(AttributeExpressionVisitor);
				_binder = binder;
				_hasErrors = hasErrors;
			}

			public ImmutableArray<TypedConstant> VisitPositionalArguments(ImmutableArray<BoundExpression> arguments, BindingDiagnosticBag diag)
			{
				return VisitArguments(arguments, diag);
			}

			private ImmutableArray<TypedConstant> VisitArguments(ImmutableArray<BoundExpression> arguments, BindingDiagnosticBag diag)
			{
				ArrayBuilder<TypedConstant> arrayBuilder = null;
				ImmutableArray<BoundExpression>.Enumerator enumerator = arguments.GetEnumerator();
				while (enumerator.MoveNext())
				{
					BoundExpression current = enumerator.Current;
					if (arrayBuilder == null)
					{
						arrayBuilder = ArrayBuilder<TypedConstant>.GetInstance();
					}
					arrayBuilder.Add(VisitExpression(current, diag));
				}
				return arrayBuilder?.ToImmutableAndFree() ?? ImmutableArray<TypedConstant>.Empty;
			}

			public ImmutableArray<KeyValuePair<string, TypedConstant>> VisitNamedArguments(ImmutableArray<BoundExpression> arguments, BindingDiagnosticBag diag)
			{
				ArrayBuilder<KeyValuePair<string, TypedConstant>> arrayBuilder = null;
				ImmutableArray<BoundExpression>.Enumerator enumerator = arguments.GetEnumerator();
				while (enumerator.MoveNext())
				{
					BoundExpression current = enumerator.Current;
					KeyValuePair<string, TypedConstant>? keyValuePair = VisitNamedArgument(current, diag);
					if (keyValuePair.HasValue)
					{
						if (arrayBuilder == null)
						{
							arrayBuilder = ArrayBuilder<KeyValuePair<string, TypedConstant>>.GetInstance();
						}
						arrayBuilder.Add(keyValuePair.Value);
					}
				}
				return arrayBuilder?.ToImmutableAndFree() ?? ImmutableArray<KeyValuePair<string, TypedConstant>>.Empty;
			}

			private KeyValuePair<string, TypedConstant>? VisitNamedArgument(BoundExpression argument, BindingDiagnosticBag diag)
			{
				BoundKind kind = argument.Kind;
				if (kind != BoundKind.AssignmentOperator)
				{
					goto IL_0096;
				}
				BoundAssignmentOperator boundAssignmentOperator = (BoundAssignmentOperator)argument;
				BoundKind kind2 = boundAssignmentOperator.Left.Kind;
				KeyValuePair<string, TypedConstant>? result;
				if (kind2 != BoundKind.FieldAccess)
				{
					if (kind2 != BoundKind.PropertyAccess)
					{
						goto IL_0096;
					}
					BoundPropertyAccess boundPropertyAccess = (BoundPropertyAccess)boundAssignmentOperator.Left;
					result = new KeyValuePair<string, TypedConstant>(boundPropertyAccess.PropertySymbol.Name, VisitExpression(boundAssignmentOperator.Right, diag));
				}
				else
				{
					BoundFieldAccess boundFieldAccess = (BoundFieldAccess)boundAssignmentOperator.Left;
					result = new KeyValuePair<string, TypedConstant>(boundFieldAccess.FieldSymbol.Name, VisitExpression(boundAssignmentOperator.Right, diag));
				}
				goto IL_009e;
				IL_009e:
				return result;
				IL_0096:
				result = null;
				goto IL_009e;
			}

			public TypedConstant VisitExpression(BoundExpression node, BindingDiagnosticBag diagBag)
			{
				while (!node.IsConstant)
				{
					switch (node.Kind)
					{
					case BoundKind.GetType:
						return VisitGetType((BoundGetType)node, diagBag);
					case BoundKind.ArrayCreation:
						return VisitArrayCreation((BoundArrayCreation)node, diagBag);
					case BoundKind.DirectCast:
					{
						BoundDirectCast boundDirectCast = (BoundDirectCast)node;
						if (boundDirectCast.HasErrors || !Conversions.IsWideningConversion(boundDirectCast.ConversionKind) || !_binder.IsValidTypeForAttributeArgument(boundDirectCast.Operand.Type))
						{
							if (!boundDirectCast.HasErrors)
							{
								ReportDiagnostic(diagBag, boundDirectCast.Operand.Syntax, ERRID.ERR_RequiredAttributeConstConversion2, boundDirectCast.Operand.Type, boundDirectCast.Type);
							}
							return CreateErrorTypedConstant(node.Type);
						}
						node = boundDirectCast.Operand;
						break;
					}
					case BoundKind.TryCast:
					{
						BoundTryCast boundTryCast = (BoundTryCast)node;
						if (boundTryCast.HasErrors || !Conversions.IsWideningConversion(boundTryCast.ConversionKind) || !_binder.IsValidTypeForAttributeArgument(boundTryCast.Operand.Type))
						{
							if (!boundTryCast.HasErrors)
							{
								ReportDiagnostic(diagBag, boundTryCast.Operand.Syntax, ERRID.ERR_RequiredAttributeConstConversion2, boundTryCast.Operand.Type, boundTryCast.Type);
							}
							return CreateErrorTypedConstant(node.Type);
						}
						node = boundTryCast.Operand;
						break;
					}
					case BoundKind.Conversion:
					{
						BoundConversion boundConversion = (BoundConversion)node;
						if (boundConversion.HasErrors || !Conversions.IsWideningConversion(boundConversion.ConversionKind) || !_binder.IsValidTypeForAttributeArgument(boundConversion.Operand.Type))
						{
							if (!boundConversion.HasErrors)
							{
								ReportDiagnostic(diagBag, boundConversion.Operand.Syntax, ERRID.ERR_RequiredAttributeConstConversion2, boundConversion.Operand.Type, boundConversion.Type);
							}
							return CreateErrorTypedConstant(node.Type);
						}
						if (VisualBasicExtensions.Kind(node.Syntax) == SyntaxKind.PredefinedCastExpression)
						{
							Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax predefinedCastExpressionSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax)node.Syntax;
							if (VisualBasicExtensions.Kind(predefinedCastExpressionSyntax.Keyword) == SyntaxKind.CObjKeyword)
							{
								Parser.CheckFeatureAvailability(diagBag, predefinedCastExpressionSyntax.Keyword.GetLocation(), ((VisualBasicSyntaxTree)predefinedCastExpressionSyntax.SyntaxTree).Options.LanguageVersion, Feature.CObjInAttributeArguments);
							}
						}
						node = boundConversion.Operand;
						break;
					}
					case BoundKind.Parenthesized:
						node = ((BoundParenthesized)node).Expression;
						break;
					case BoundKind.BadExpression:
						return CreateErrorTypedConstant(node.Type);
					default:
						ReportDiagnostic(diagBag, node.Syntax, ERRID.ERR_RequiredConstExpr);
						return CreateErrorTypedConstant(node.Type);
					}
				}
				if (_binder.IsValidTypeForAttributeArgument(node.Type))
				{
					return CreateTypedConstant(node.Type, RuntimeHelpers.GetObjectValue(node.ConstantValueOpt.Value));
				}
				return CreateErrorTypedConstant(node.Type);
			}

			private TypedConstant VisitGetType(BoundGetType node, BindingDiagnosticBag diagBag)
			{
				BoundTypeExpression sourceType = node.SourceType;
				TypeSymbol type = sourceType.Type;
				if ((object)type != null && !TypeSymbolExtensions.IsUnboundGenericType(type) && TypeSymbolExtensions.IsOrRefersToTypeParameter(type))
				{
					BadSymbolDiagnostic info = new BadSymbolDiagnostic(type, ERRID.ERR_OpenTypeDisallowed);
					ReportDiagnostic(diagBag, sourceType.Syntax, info);
					return CreateErrorTypedConstant(node.Type);
				}
				return CreateTypedConstant(node.Type, type);
			}

			private TypedConstant VisitArrayCreation(BoundArrayCreation node, BindingDiagnosticBag diag)
			{
				ArrayTypeSymbol type = (ArrayTypeSymbol)node.Type;
				ImmutableArray<TypedConstant> array = default(ImmutableArray<TypedConstant>);
				BoundArrayInitialization initializerOpt = node.InitializerOpt;
				if ((initializerOpt == null || initializerOpt.Initializers.Length == 0) && node.Bounds.Length == 1)
				{
					BoundExpression boundExpression = node.Bounds[0];
					if (boundExpression.IsConstant && !boundExpression.ConstantValueOpt.IsDefaultValue)
					{
						ReportDiagnostic(diag, initializerOpt.Syntax, ERRID.ERR_MissingValuesForArraysInApplAttrs);
						_hasErrors = true;
					}
				}
				if (initializerOpt != null)
				{
					array = VisitArguments(initializerOpt.Initializers, diag);
				}
				return CreateTypedConstant(type, array);
			}

			private static TypedConstant CreateTypedConstant(ArrayTypeSymbol type, ImmutableArray<TypedConstant> array)
			{
				return new TypedConstant(type, array);
			}

			private TypedConstant CreateTypedConstant(TypeSymbol type, object value)
			{
				TypedConstantKind typedConstantKind = TypedConstant.GetTypedConstantKind(type, _binder.Compilation);
				TypedConstant result = ((typedConstantKind != TypedConstantKind.Array) ? new TypedConstant(type, typedConstantKind, RuntimeHelpers.GetObjectValue(value)) : new TypedConstant(type, default(ImmutableArray<TypedConstant>)));
				return result;
			}

			private TypedConstant CreateErrorTypedConstant(TypeSymbol type)
			{
				_hasErrors = true;
				return new TypedConstant(type, TypedConstantKind.Error, null);
			}
		}

		private struct AnalyzedAttributeArguments
		{
			public ImmutableArray<BoundExpression> positionalArguments;

			public ImmutableArray<BoundExpression> namedArguments;

			public AnalyzedAttributeArguments(ImmutableArray<BoundExpression> positionalArguments, ImmutableArray<BoundExpression> namedArguments)
			{
				this = default(AnalyzedAttributeArguments);
				this.positionalArguments = positionalArguments;
				this.namedArguments = namedArguments;
			}
		}

		private struct VarianceSuggestionTypeParameterInfo
		{
			private bool _isViable;

			private TypeParameterSymbol _typeParameter;

			private TypeSymbol _derivedArgument;

			private TypeSymbol _baseArgument;

			public bool IsViable => _isViable;

			public TypeParameterSymbol TypeParameter => _typeParameter;

			public TypeSymbol DerivedArgument => _derivedArgument;

			public TypeSymbol BaseArgument => _baseArgument;

			public void Set(TypeParameterSymbol parameter, TypeSymbol derived, TypeSymbol @base)
			{
				_typeParameter = parameter;
				_derivedArgument = derived;
				_baseArgument = @base;
				_isViable = true;
			}
		}

		internal struct DelegateResolutionResult
		{
			public readonly ConversionKind DelegateConversions;

			public readonly MethodSymbol Target;

			public readonly MethodConversionKind MethodConversions;

			public readonly ImmutableBindingDiagnostic<AssemblySymbol> Diagnostics;

			public DelegateResolutionResult(ConversionKind DelegateConversions, MethodSymbol Target, MethodConversionKind MethodConversions, ImmutableBindingDiagnostic<AssemblySymbol> Diagnostics)
			{
				this = default(DelegateResolutionResult);
				this.DelegateConversions = DelegateConversions;
				this.Target = Target;
				this.Diagnostics = Diagnostics;
				this.MethodConversions = MethodConversions;
			}
		}

		private class DefaultInstancePropertyBinder : Binder
		{
			public override bool ImplicitVariableDeclarationAllowed => false;

			internal override bool IsDefaultInstancePropertyAllowed => false;

			internal override bool SuppressCallerInfo => true;

			public DefaultInstancePropertyBinder(Binder containingBinder)
				: base(containingBinder)
			{
			}
		}

		private struct DimensionSize
		{
			public enum SizeKind : byte
			{
				Unknown,
				Constant,
				NotConstant
			}

			public readonly SizeKind Kind;

			public readonly int Size;

			private DimensionSize(int size, SizeKind kind)
			{
				this = default(DimensionSize);
				Size = size;
				Kind = kind;
			}

			public static DimensionSize ConstantSize(int size)
			{
				return new DimensionSize(size, SizeKind.Constant);
			}

			public static DimensionSize VariableSize()
			{
				return new DimensionSize(0, SizeKind.NotConstant);
			}
		}

		private class ImportsBinder
		{
			public static void BindImportClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsClauseSyntax importClauseSyntax, Binder binder, ImportData data, DiagnosticBag diagBag)
			{
				switch (importClauseSyntax.Kind())
				{
				case SyntaxKind.SimpleImportsClause:
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax simpleImportsClauseSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax)importClauseSyntax;
					if (simpleImportsClauseSyntax.Alias == null)
					{
						BindMembersImportsClause(simpleImportsClauseSyntax, binder, data, diagBag);
					}
					else
					{
						BindAliasImportsClause(simpleImportsClauseSyntax, binder, data, diagBag);
					}
					break;
				}
				case SyntaxKind.XmlNamespaceImportsClause:
					BindXmlNamespaceImportsClause((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNamespaceImportsClauseSyntax)importClauseSyntax, binder, data, diagBag);
					break;
				}
			}

			private static void BindAliasImportsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax aliasImportSyntax, Binder binder, ImportData data, DiagnosticBag diagnostics)
			{
				PooledHashSet<AssemblySymbol> instance = PooledHashSet<AssemblySymbol>.GetInstance();
				BindingDiagnosticBag bindingDiagnosticBag = new BindingDiagnosticBag(diagnostics, instance);
				Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax name = aliasImportSyntax.Name;
				NamespaceOrTypeSymbol namespaceOrTypeSymbol = binder.BindNamespaceOrTypeSyntax(name, bindingDiagnosticBag);
				if (namespaceOrTypeSymbol.Kind != SymbolKind.Namespace && (!(namespaceOrTypeSymbol is TypeSymbol type) || TypeSymbolExtensions.IsDelegateType(type)))
				{
					ReportDiagnostic(bindingDiagnosticBag, aliasImportSyntax, ERRID.ERR_InvalidTypeForAliasesImport2, namespaceOrTypeSymbol, namespaceOrTypeSymbol.Name);
				}
				SyntaxToken identifier = aliasImportSyntax.Alias.Identifier;
				string valueText = identifier.ValueText;
				if (data.Aliases.ContainsKey(valueText))
				{
					ReportDiagnostic(bindingDiagnosticBag, identifier, ERRID.ERR_DuplicateNamedImportAlias1, valueText);
				}
				else
				{
					ImmutableArray<Symbol> members = binder.Compilation.GlobalNamespace.GetMembers(valueText);
					if (!members.IsEmpty)
					{
						ReportDiagnostic(bindingDiagnosticBag, aliasImportSyntax, ERRID.ERR_ImportAliasConflictsWithType2, valueText, members[0]);
					}
					else
					{
						if (namespaceOrTypeSymbol.Kind != SymbolKind.ErrorType)
						{
							UseSiteInfo<AssemblySymbol> useSiteInfo = namespaceOrTypeSymbol.GetUseSiteInfo();
							if (ShouldReportUseSiteErrorForAlias(useSiteInfo.DiagnosticInfo))
							{
								ReportUseSite(bindingDiagnosticBag, aliasImportSyntax, useSiteInfo);
							}
							else
							{
								bindingDiagnosticBag.AddDependencies(useSiteInfo);
							}
						}
						else
						{
							instance.Clear();
						}
						AliasSymbol alias = new AliasSymbol(binder.Compilation, binder.ContainingNamespaceOrType, valueText, namespaceOrTypeSymbol, (binder.BindingLocation == BindingLocation.ProjectImportsDeclaration) ? NoLocation.Singleton : identifier.GetLocation());
						data.AddAlias(binder.GetSyntaxReference(aliasImportSyntax), valueText, alias, aliasImportSyntax.SpanStart, instance);
					}
				}
				instance.Free();
			}

			private static bool ShouldReportUseSiteErrorForAlias(DiagnosticInfo useSiteErrorInfo)
			{
				if (useSiteErrorInfo != null && useSiteErrorInfo.Code != 36924)
				{
					return useSiteErrorInfo.Code != 36925;
				}
				return false;
			}

			private static void BindMembersImportsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax membersImportsSyntax, Binder binder, ImportData data, DiagnosticBag diagnostics)
			{
				PooledHashSet<AssemblySymbol> instance = PooledHashSet<AssemblySymbol>.GetInstance();
				BindingDiagnosticBag diagBag = new BindingDiagnosticBag(diagnostics, instance);
				Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax name = membersImportsSyntax.Name;
				NamespaceOrTypeSymbol namespaceOrTypeSymbol = binder.BindNamespaceOrTypeSyntax(name, diagBag);
				if (namespaceOrTypeSymbol.Kind != SymbolKind.Namespace && (!(namespaceOrTypeSymbol is TypeSymbol type) || TypeSymbolExtensions.IsDelegateType(type) || TypeSymbolExtensions.IsInterfaceType(type)))
				{
					ReportDiagnostic(diagBag, membersImportsSyntax, ERRID.ERR_NonNamespaceOrClassOnImport2, namespaceOrTypeSymbol, namespaceOrTypeSymbol.Name);
				}
				if (namespaceOrTypeSymbol.Kind != SymbolKind.ErrorType)
				{
					if (data.Members.Contains(namespaceOrTypeSymbol))
					{
						ReportDiagnostic(diagBag, name, ERRID.ERR_DuplicateImport1, namespaceOrTypeSymbol);
					}
					else
					{
						bool flag = true;
						if (namespaceOrTypeSymbol.Kind == SymbolKind.NamedType)
						{
							NamedTypeSymbol namedTypeSymbol = (NamedTypeSymbol)namespaceOrTypeSymbol;
							if (namedTypeSymbol.IsGenericType)
							{
								namedTypeSymbol = namedTypeSymbol.OriginalDefinition;
								foreach (NamespaceOrTypeSymbol member in data.Members)
								{
									if ((object)member.OriginalDefinition == namedTypeSymbol)
									{
										flag = false;
										ReportDiagnostic(diagBag, name, ERRID.ERR_DuplicateRawGenericTypeImport1, namedTypeSymbol);
										break;
									}
								}
							}
						}
						if (flag)
						{
							data.AddMember(binder.GetSyntaxReference(name), namespaceOrTypeSymbol, membersImportsSyntax.SpanStart, instance);
						}
					}
				}
				instance.Free();
			}

			private static void BindXmlNamespaceImportsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNamespaceImportsClauseSyntax syntax, Binder binder, ImportData data, DiagnosticBag diagnostics)
			{
				BindingDiagnosticBag bindingDiagnosticBag = new BindingDiagnosticBag(diagnostics);
				string prefix = null;
				string namespaceName = null;
				BoundExpression @namespace = null;
				bool hasErrors = false;
				if (binder.TryGetXmlnsAttribute(syntax.XmlNamespace, out prefix, out namespaceName, out @namespace, out hasErrors, fromImport: true, bindingDiagnosticBag) && !hasErrors)
				{
					if (data.XmlNamespaces.ContainsKey(prefix))
					{
						ReportDiagnostic(bindingDiagnosticBag, syntax, ERRID.ERR_DuplicatePrefix, prefix);
					}
					else
					{
						data.XmlNamespaces.Add(prefix, new XmlNamespaceAndImportsClausePosition(namespaceName, syntax.SpanStart));
					}
				}
			}
		}

		internal sealed class ProcessedFieldOrPropertyInitializers
		{
			internal readonly ImmutableArray<BoundInitializer> BoundInitializers;

			internal readonly bool HasAnyErrors;

			private ImmutableArray<BoundStatement> _loweredInitializers;

			internal static readonly ProcessedFieldOrPropertyInitializers Empty = new ProcessedFieldOrPropertyInitializers();

			private bool _analyzed;

			internal ImmutableArray<BoundStatement> InitializerStatements
			{
				get
				{
					return _loweredInitializers;
				}
				set
				{
					_loweredInitializers = value;
				}
			}

			private ProcessedFieldOrPropertyInitializers()
			{
				_analyzed = false;
				BoundInitializers = ImmutableArray<BoundInitializer>.Empty;
				HasAnyErrors = false;
				_loweredInitializers = ImmutableArray<BoundStatement>.Empty;
			}

			internal ProcessedFieldOrPropertyInitializers(ImmutableArray<BoundInitializer> boundInitializers)
			{
				_analyzed = false;
				BoundInitializers = boundInitializers;
				HasAnyErrors = boundInitializers.Any((BoundInitializer i) => i.HasErrors);
			}

			internal void EnsureInitializersAnalyzed(MethodSymbol method, DiagnosticBag diagnostics)
			{
				if (!_analyzed)
				{
					if (!BoundInitializers.IsEmpty)
					{
						BoundBlock boundBlock = new BoundBlock(BoundInitializers[0].Syntax, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), ImmutableArray<LocalSymbol>.Empty, StaticCast<BoundStatement>.From(BoundInitializers));
						Analyzer.AnalyzeMethodBody(method, boundBlock, diagnostics);
						DiagnosticsPass.IssueDiagnostics(boundBlock, diagnostics, method);
					}
					_analyzed = true;
				}
			}
		}

		internal class ConstructorCallArgumentsBinder : Binder
		{
			protected override bool IsInsideChainedConstructorCallArguments => true;

			public ConstructorCallArgumentsBinder(Binder containingBinder)
				: base(containingBinder)
			{
			}
		}

		private class LambdaRelaxationVisitor : StatementWalker
		{
			private readonly LambdaSymbol _lambdaSymbol;

			private readonly bool _isIterator;

			private ConversionKind _delegateRelaxationLevel;

			private bool _seenReturnWithAValue;

			private CompoundUseSiteInfo<AssemblySymbol> _useSiteDiagnostics;

			private LambdaRelaxationVisitor(LambdaSymbol lambdaSymbol, bool isIterator)
			{
				_delegateRelaxationLevel = ConversionKind.DelegateRelaxationLevelNone;
				_lambdaSymbol = lambdaSymbol;
				_isIterator = isIterator;
			}

			public static ConversionKind DetermineDelegateRelaxationLevel(LambdaSymbol lambdaSymbol, bool isIterator, BoundBlock lambdaBlock, out bool seenReturnWithAValue, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				LambdaRelaxationVisitor lambdaRelaxationVisitor = new LambdaRelaxationVisitor(lambdaSymbol, isIterator);
				lambdaRelaxationVisitor._useSiteDiagnostics = useSiteInfo;
				lambdaRelaxationVisitor.VisitBlock(lambdaBlock);
				seenReturnWithAValue = lambdaRelaxationVisitor._seenReturnWithAValue;
				useSiteInfo = lambdaRelaxationVisitor._useSiteDiagnostics;
				return lambdaRelaxationVisitor._delegateRelaxationLevel;
			}

			public override BoundNode Visit(BoundNode node)
			{
				if (node == null || node is BoundExpression)
				{
					return null;
				}
				return base.Visit(node);
			}

			public override BoundNode VisitLambda(BoundLambda node)
			{
				throw ExceptionUtilities.Unreachable;
			}

			public override BoundNode VisitReturnStatement(BoundReturnStatement node)
			{
				if (_isIterator)
				{
					return null;
				}
				if (node.ExpressionOpt != null)
				{
					if (node.ExpressionOpt.Kind == BoundKind.Local)
					{
						LocalSymbol localSymbol = ((BoundLocal)node.ExpressionOpt).LocalSymbol;
						if (localSymbol.IsFunctionValue && (object)localSymbol.ContainingSymbol == _lambdaSymbol)
						{
							return null;
						}
					}
					_seenReturnWithAValue = true;
				}
				ConversionKind conversionKind = Conversions.DetermineDelegateRelaxationLevelForLambdaReturn(node.ExpressionOpt, ref _useSiteDiagnostics);
				if (conversionKind > _delegateRelaxationLevel)
				{
					_delegateRelaxationLevel = conversionKind;
				}
				return null;
			}

			public override BoundNode VisitYieldStatement(BoundYieldStatement node)
			{
				if (_isIterator)
				{
					ConversionKind conversionKind = Conversions.DetermineDelegateRelaxationLevelForLambdaReturn(node.Expression, ref _useSiteDiagnostics);
					if (conversionKind > _delegateRelaxationLevel)
					{
						_delegateRelaxationLevel = conversionKind;
					}
				}
				return null;
			}
		}

		private class CheckAwaitWalker : BoundTreeWalkerWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator
		{
			private readonly Binder _binder;

			private readonly BindingDiagnosticBag _diagnostics;

			private bool _isInCatchFinallyOrSyncLock;

			private bool _containsAwait;

			private CheckAwaitWalker(Binder binder, BindingDiagnosticBag diagnostics)
			{
				_diagnostics = diagnostics;
				_binder = binder;
			}

			public static bool VisitBlock(Binder binder, BoundBlock block, BindingDiagnosticBag diagnostics)
			{
				try
				{
					CheckAwaitWalker checkAwaitWalker = new CheckAwaitWalker(binder, diagnostics);
					checkAwaitWalker.Visit(block);
					return checkAwaitWalker._containsAwait;
				}
				catch (CancelledByStackGuardException ex)
				{
					ProjectData.SetProjectError(ex);
					CancelledByStackGuardException ex2 = ex;
					ex2.AddAnError(diagnostics);
					bool result = true;
					ProjectData.ClearProjectError();
					return result;
				}
			}

			public override BoundNode VisitTryStatement(BoundTryStatement node)
			{
				Visit(node.TryBlock);
				bool isInCatchFinallyOrSyncLock = _isInCatchFinallyOrSyncLock;
				_isInCatchFinallyOrSyncLock = true;
				VisitList(node.CatchBlocks);
				Visit(node.FinallyBlockOpt);
				_isInCatchFinallyOrSyncLock = isInCatchFinallyOrSyncLock;
				return null;
			}

			public override BoundNode VisitSyncLockStatement(BoundSyncLockStatement node)
			{
				bool isInCatchFinallyOrSyncLock = _isInCatchFinallyOrSyncLock;
				_isInCatchFinallyOrSyncLock = true;
				base.VisitSyncLockStatement(node);
				_isInCatchFinallyOrSyncLock = isInCatchFinallyOrSyncLock;
				return null;
			}

			public override BoundNode VisitAwaitOperator(BoundAwaitOperator node)
			{
				_containsAwait = true;
				if (_isInCatchFinallyOrSyncLock)
				{
					ReportDiagnostic(_diagnostics, node.Syntax, ERRID.ERR_BadAwaitInTryHandler);
				}
				return base.VisitAwaitOperator(node);
			}

			public override BoundNode VisitLambda(BoundLambda node)
			{
				return null;
			}
		}

		private class LambdaReturnStatementsVisitor : StatementWalker
		{
			private readonly ArrayBuilder<BoundExpression> _builder;

			private readonly bool _isIterator;

			private LambdaReturnStatementsVisitor(ArrayBuilder<BoundExpression> builder, bool isIterator)
			{
				_builder = builder;
				_isIterator = isIterator;
			}

			public static void CollectReturnExpressions(BoundBlock lambdaBlock, ArrayBuilder<BoundExpression> arrayToFill, bool isIterator)
			{
				new LambdaReturnStatementsVisitor(arrayToFill, isIterator).VisitBlock(lambdaBlock);
			}

			public override BoundNode Visit(BoundNode node)
			{
				if (node == null || node is BoundExpression)
				{
					return null;
				}
				return base.Visit(node);
			}

			public override BoundNode VisitLambda(BoundLambda node)
			{
				throw ExceptionUtilities.Unreachable;
			}

			public override BoundNode VisitReturnStatement(BoundReturnStatement node)
			{
				if (_isIterator)
				{
					return null;
				}
				BoundExpression expressionOpt = node.ExpressionOpt;
				if (expressionOpt == null || (object)expressionOpt.Type == LambdaSymbol.ReturnTypeIsBeingInferred)
				{
					return null;
				}
				_builder.Add(expressionOpt);
				return null;
			}

			public override BoundNode VisitYieldStatement(BoundYieldStatement node)
			{
				if (_isIterator)
				{
					_builder.Add(node.Expression);
				}
				return null;
			}
		}

		private class MemberLookup
		{
			public delegate void WinRTLookupDelegate(NamedTypeSymbol iface, Binder binder, LookupResult result, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo);

			private struct InterfaceInfo : IEquatable<InterfaceInfo>
			{
				public readonly NamedTypeSymbol InterfaceType;

				public readonly bool InComInterfaceContext;

				public readonly ImmutableHashSet<NamedTypeSymbol> DescendantDefinitions;

				public InterfaceInfo(NamedTypeSymbol interfaceType, bool inComInterfaceContext, ImmutableHashSet<NamedTypeSymbol> descendantDefinitions = null)
				{
					this = default(InterfaceInfo);
					InterfaceType = interfaceType;
					InComInterfaceContext = inComInterfaceContext;
					DescendantDefinitions = descendantDefinitions;
				}

				public override int GetHashCode()
				{
					return Hash.Combine(InterfaceType.GetHashCode(), InComInterfaceContext.GetHashCode());
				}

				public override bool Equals(object obj)
				{
					if (obj is InterfaceInfo)
					{
						return Equals((InterfaceInfo)obj);
					}
					return false;
				}

				public bool Equals(InterfaceInfo other)
				{
					if (InterfaceType.Equals(other.InterfaceType))
					{
						return InComInterfaceContext == other.InComInterfaceContext;
					}
					return false;
				}

				bool IEquatable<InterfaceInfo>.Equals(InterfaceInfo other)
				{
					//ILSpy generated this explicit interface implementation from .override directive in Equals
					return this.Equals(other);
				}
			}

			private static readonly Func<ImmutableArray<Symbol>, AmbiguousSymbolDiagnostic> s_ambiguousInModuleError = delegate(ImmutableArray<Symbol> syms)
			{
				string name = syms[0].Name;
				FormattedSymbolList formattedSymbolList = new FormattedSymbolList(syms.Select((Symbol sym) => sym.ContainingType));
				return new AmbiguousSymbolDiagnostic(ERRID.ERR_AmbiguousInModules2, syms, name, formattedSymbolList);
			};

			public static void Lookup(LookupResult lookupResult, NamespaceOrTypeSymbol container, string name, int arity, LookupOptions options, Binder binder, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				if (container.IsNamespace)
				{
					Lookup(lookupResult, (NamespaceSymbol)container, name, arity, options, binder, ref useSiteInfo);
					return;
				}
				LookupResult instance = LookupResult.GetInstance();
				Lookup(lookupResult, (TypeSymbol)container, name, arity, options, binder, instance, ref useSiteInfo);
				instance.Free();
			}

			public static void AddLookupSymbolsInfo(LookupSymbolsInfo nameSet, NamespaceOrTypeSymbol container, LookupOptions options, Binder binder)
			{
				if (container.IsNamespace)
				{
					AddLookupSymbolsInfo(nameSet, (NamespaceSymbol)container, options, binder);
				}
				else
				{
					AddLookupSymbolsInfo(nameSet, (TypeSymbol)container, options, binder);
				}
			}

			public static void Lookup(LookupResult lookupResult, NamespaceSymbol container, string name, int arity, LookupOptions options, Binder binder, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				LookupImmediate(lookupResult, container, name, arity, options, binder, ref useSiteInfo);
				if (!lookupResult.StopFurtherLookup)
				{
					LookupResult instance = LookupResult.GetInstance();
					LookupInModules(instance, container, name, arity, options, binder, ref useSiteInfo);
					lookupResult.MergeAmbiguous(instance, s_ambiguousInModuleError);
					instance.Free();
				}
			}

			public static void LookupImmediate(LookupResult lookupResult, NamespaceSymbol container, string name, int arity, LookupOptions options, Binder binder, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				ModuleSymbol sourceModule = binder.Compilation.SourceModule;
				if ((options & LookupOptions.AllowIntrinsicAliases) != 0 && arity == 0)
				{
					NamespaceSymbol containingNamespace = container.ContainingNamespace;
					if ((object)containingNamespace != null && containingNamespace.IsGlobalNamespace && CaseInsensitiveComparison.Equals(container.Name, "System"))
					{
						SpecialType typeForIntrinsicAlias = GetTypeForIntrinsicAlias(name);
						if (typeForIntrinsicAlias != 0)
						{
							NamedTypeSymbol specialType = binder.Compilation.GetSpecialType(typeForIntrinsicAlias);
							if (!TypeSymbolExtensions.IsErrorType(specialType))
							{
								lookupResult.MergeMembersOfTheSameNamespace(binder.CheckViability(specialType, arity, options, null, ref useSiteInfo), sourceModule, options);
							}
						}
					}
				}
				ImmutableArray<Symbol>.Enumerator enumerator = container.GetMembers(name).GetEnumerator();
				while (enumerator.MoveNext())
				{
					Symbol current = enumerator.Current;
					SingleLookupResult other = binder.CheckViability(current, arity, options, null, ref useSiteInfo);
					lookupResult.MergeMembersOfTheSameNamespace(other, sourceModule, options);
				}
			}

			public static SpecialType GetTypeForIntrinsicAlias(string possibleAlias)
			{
				return SyntaxFacts.GetKeywordKind(possibleAlias) switch
				{
					SyntaxKind.DateKeyword => SpecialType.System_DateTime, 
					SyntaxKind.UShortKeyword => SpecialType.System_UInt16, 
					SyntaxKind.ShortKeyword => SpecialType.System_Int16, 
					SyntaxKind.UIntegerKeyword => SpecialType.System_UInt32, 
					SyntaxKind.IntegerKeyword => SpecialType.System_Int32, 
					SyntaxKind.ULongKeyword => SpecialType.System_UInt64, 
					SyntaxKind.LongKeyword => SpecialType.System_Int64, 
					_ => SpecialType.None, 
				};
			}

			public static void LookupInModules(LookupResult lookupResult, NamespaceSymbol container, string name, int arity, LookupOptions options, Binder binder, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				bool flag = true;
				ModuleSymbol sourceModule = binder.Compilation.SourceModule;
				options = options | LookupOptions.IgnoreExtensionMethods | LookupOptions.NoBaseClassLookup;
				LookupResult lookupResult2 = null;
				LookupResult instance = LookupResult.GetInstance();
				ImmutableArray<NamedTypeSymbol>.Enumerator enumerator = container.GetModuleMembers().GetEnumerator();
				while (enumerator.MoveNext())
				{
					NamedTypeSymbol current = enumerator.Current;
					if (flag)
					{
						Lookup(lookupResult, current, name, arity, options, binder, instance, ref useSiteInfo);
						flag = false;
						continue;
					}
					if (lookupResult2 == null)
					{
						lookupResult2 = LookupResult.GetInstance();
					}
					else
					{
						lookupResult2.Clear();
					}
					Lookup(lookupResult2, current, name, arity, options, binder, instance, ref useSiteInfo);
					if (lookupResult2.StopFurtherLookup && lookupResult2.Symbols.Count > 0 && lookupResult.StopFurtherLookup && lookupResult.Symbols.Count > 0)
					{
						bool num = (object)lookupResult2.Symbols[0].ContainingModule == sourceModule;
						bool flag2 = (object)lookupResult.Symbols[0].ContainingModule == sourceModule;
						if (num)
						{
							if (!flag2)
							{
								lookupResult.SetFrom(lookupResult2);
								continue;
							}
						}
						else if (flag2)
						{
							continue;
						}
					}
					lookupResult.MergeAmbiguous(lookupResult2, s_ambiguousInModuleError);
				}
				instance.Free();
				lookupResult2?.Free();
			}

			private static void AddLookupSymbolsInfo(LookupSymbolsInfo nameSet, NamespaceSymbol container, LookupOptions options, Binder binder)
			{
				ImmutableArray<Symbol>.Enumerator enumerator = container.GetMembersUnordered().GetEnumerator();
				while (enumerator.MoveNext())
				{
					Symbol current = enumerator.Current;
					if (binder.CanAddLookupSymbolInfo(current, options, nameSet, null))
					{
						nameSet.AddSymbol(current, current.Name, SymbolExtensions.GetArity(current));
					}
				}
				ImmutableArray<NamedTypeSymbol>.Enumerator enumerator2 = container.GetModuleMembers().GetEnumerator();
				while (enumerator2.MoveNext())
				{
					NamedTypeSymbol current2 = enumerator2.Current;
					AddLookupSymbolsInfo(nameSet, current2, options, binder);
				}
			}

			internal static void Lookup(LookupResult lookupResult, TypeSymbol type, string name, int arity, LookupOptions options, Binder binder, LookupResult tempResult, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				switch (type.TypeKind)
				{
				case TypeKind.Array:
				case TypeKind.Class:
				case TypeKind.Delegate:
				case TypeKind.Enum:
				case TypeKind.Module:
				case TypeKind.Struct:
					LookupInClass(lookupResult, type, name, arity, options, type, binder, tempResult, ref useSiteInfo);
					break;
				case TypeKind.Submission:
					LookupInSubmissions(lookupResult, type, name, arity, options, binder, ref useSiteInfo);
					break;
				case TypeKind.Interface:
					LookupInInterface(lookupResult, (NamedTypeSymbol)type, name, arity, options, binder, tempResult, ref useSiteInfo);
					break;
				case TypeKind.TypeParameter:
					LookupInTypeParameter(lookupResult, (TypeParameterSymbol)type, name, arity, options, binder, tempResult, ref useSiteInfo);
					break;
				default:
					throw ExceptionUtilities.UnexpectedValue(type.TypeKind);
				case TypeKind.Error:
					break;
				}
			}

			private static void AddLookupSymbolsInfo(LookupSymbolsInfo nameSet, TypeSymbol container, LookupOptions options, Binder binder)
			{
				switch (container.TypeKind)
				{
				case TypeKind.Array:
				case TypeKind.Class:
				case TypeKind.Delegate:
				case TypeKind.Enum:
				case TypeKind.Struct:
					AddLookupSymbolsInfoInClass(nameSet, container, options, binder);
					break;
				case TypeKind.Module:
					AddLookupSymbolsInfoInClass(nameSet, container, options | LookupOptions.NoBaseClassLookup, binder);
					break;
				case TypeKind.Submission:
					AddLookupSymbolsInfoInSubmissions(nameSet, container, options, binder);
					break;
				case TypeKind.Interface:
					AddLookupSymbolsInfoInInterface(nameSet, (NamedTypeSymbol)container, options, binder);
					break;
				case TypeKind.TypeParameter:
					AddLookupSymbolsInfoInTypeParameter(nameSet, (TypeParameterSymbol)container, options, binder);
					break;
				default:
					throw ExceptionUtilities.UnexpectedValue(container.TypeKind);
				case TypeKind.Error:
					break;
				}
			}

			private static void LookupInClass(LookupResult result, TypeSymbol container, string name, int arity, LookupOptions options, TypeSymbol accessThroughType, Binder binder, LookupResult tempResult, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				bool flag = CheckAndClearMethodsOnlyOption(ref options);
				TypeSymbol typeSymbol = container;
				while (true)
				{
					tempResult.Clear();
					bool flag2 = false;
					LookupWithoutInheritance(tempResult, typeSymbol, name, arity, options, accessThroughType, binder, ref useSiteInfo);
					if (result.IsGoodOrAmbiguous && tempResult.IsGoodOrAmbiguous && !LookupResult.CanOverload(result.Symbols[0], tempResult.Symbols[0]))
					{
						flag2 = true;
					}
					result.MergeOverloadedOrPrioritized(tempResult, checkIfCurrentHasOverloads: true);
					if (typeSymbol is NamedTypeSymbol namedTypeSymbol && namedTypeSymbol.ShouldAddWinRTMembers)
					{
						FindWinRTMembers(result, namedTypeSymbol, binder, tempResult, ref useSiteInfo, lookupMembersNotDefaultProperties: true, name, arity, options);
					}
					if (!flag2)
					{
						if (result.StopFurtherLookup && result.HasSymbol && !SymbolExtensions.IsOverloadable(result.Symbols.First()))
						{
							if (!flag)
							{
								break;
							}
						}
						else
						{
							typeSymbol = (((options & LookupOptions.NoBaseClassLookup) == 0 && !binder.IgnoreBaseClassesInLookup) ? typeSymbol.GetDirectBaseTypeWithDefinitionUseSiteDiagnostics(binder.BasesBeingResolved(), ref useSiteInfo) : null);
							if ((object)typeSymbol != null)
							{
								continue;
							}
						}
					}
					ClearLookupResultIfNotMethods(flag, result);
					LookupForExtensionMethodsIfNeedTo(result, container, name, arity, options, binder, tempResult, ref useSiteInfo);
					break;
				}
			}

			private static void FindWinRTMembers(LookupResult result, NamedTypeSymbol type, Binder binder, LookupResult tempResult, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, bool lookupMembersNotDefaultProperties, string name = null, int arity = -1, LookupOptions options = LookupOptions.Default)
			{
				MemberSignatureComparer winRTComparer = MemberSignatureComparer.WinRTComparer;
				HashSet<Symbol> hashSet = new HashSet<Symbol>(winRTComparer);
				HashSet<Symbol> hashSet2 = new HashSet<Symbol>(winRTComparer);
				if (result.IsGood)
				{
					ArrayBuilder<Symbol>.Enumerator enumerator = result.Symbols.GetEnumerator();
					while (enumerator.MoveNext())
					{
						Symbol current = enumerator.Current;
						if (current.Kind != SymbolKind.Field)
						{
							hashSet.Add(current);
						}
					}
				}
				LookupResult instance = LookupResult.GetInstance();
				ImmutableArray<NamedTypeSymbol>.Enumerator enumerator2 = type.AllInterfacesWithDefinitionUseSiteDiagnostics(ref useSiteInfo).GetEnumerator();
				while (enumerator2.MoveNext())
				{
					NamedTypeSymbol current2 = enumerator2.Current;
					if (!IsWinRTProjectedInterface(current2, binder.Compilation))
					{
						continue;
					}
					if (lookupMembersNotDefaultProperties)
					{
						LookupWithoutInheritance(instance, current2, name, arity, options, current2, binder, ref useSiteInfo);
					}
					else
					{
						LookupDefaultPropertyInSingleType(instance, current2, current2, binder, tempResult, ref useSiteInfo);
					}
					if (instance.IsGood)
					{
						ArrayBuilder<Symbol>.Enumerator enumerator3 = instance.Symbols.GetEnumerator();
						while (enumerator3.MoveNext())
						{
							Symbol current3 = enumerator3.Current;
							if (!hashSet.Add(current3))
							{
								hashSet2.Add(current3);
							}
						}
					}
					instance.Clear();
				}
				instance.Free();
				if (result.IsGood)
				{
					ArrayBuilder<Symbol>.Enumerator enumerator4 = result.Symbols.GetEnumerator();
					while (enumerator4.MoveNext())
					{
						Symbol current4 = enumerator4.Current;
						if (current4.Kind != SymbolKind.Field)
						{
							hashSet.Remove(current4);
							hashSet2.Remove(current4);
						}
					}
				}
				foreach (Symbol item in hashSet)
				{
					if (!hashSet2.Contains(item))
					{
						result.MergeOverloadedOrPrioritized(new SingleLookupResult(LookupResultKind.Good, item, null), checkIfCurrentHasOverloads: false);
					}
				}
			}

			private static bool IsWinRTProjectedInterface(NamedTypeSymbol iFace, VisualBasicCompilation compilation)
			{
				NamedTypeSymbol wellKnownType = compilation.GetWellKnownType(WellKnownType.System_Collections_Generic_IDictionary_KV);
				NamedTypeSymbol wellKnownType2 = compilation.GetWellKnownType(WellKnownType.System_Collections_Generic_IReadOnlyDictionary_KV);
				NamedTypeSymbol wellKnownType3 = compilation.GetWellKnownType(WellKnownType.System_Collections_IList);
				NamedTypeSymbol wellKnownType4 = compilation.GetWellKnownType(WellKnownType.System_Collections_ICollection);
				NamedTypeSymbol wellKnownType5 = compilation.GetWellKnownType(WellKnownType.System_Collections_Specialized_INotifyCollectionChanged);
				NamedTypeSymbol wellKnownType6 = compilation.GetWellKnownType(WellKnownType.System_ComponentModel_INotifyPropertyChanged);
				NamedTypeSymbol originalDefinition = iFace.OriginalDefinition;
				SpecialType specialType = originalDefinition.SpecialType;
				if (specialType != SpecialType.System_Collections_Generic_IEnumerable_T && specialType != SpecialType.System_Collections_Generic_IList_T && specialType != SpecialType.System_Collections_Generic_ICollection_T && !TypeSymbol.Equals(originalDefinition, wellKnownType, TypeCompareKind.ConsiderEverything) && specialType != SpecialType.System_Collections_Generic_IReadOnlyList_T && specialType != SpecialType.System_Collections_Generic_IReadOnlyCollection_T && !TypeSymbol.Equals(originalDefinition, wellKnownType2, TypeCompareKind.ConsiderEverything) && specialType != SpecialType.System_Collections_IEnumerable && !TypeSymbol.Equals(originalDefinition, wellKnownType3, TypeCompareKind.ConsiderEverything) && !TypeSymbol.Equals(originalDefinition, wellKnownType4, TypeCompareKind.ConsiderEverything) && !TypeSymbol.Equals(originalDefinition, wellKnownType5, TypeCompareKind.ConsiderEverything))
				{
					return TypeSymbol.Equals(originalDefinition, wellKnownType6, TypeCompareKind.ConsiderEverything);
				}
				return true;
			}

			private static void LookupInSubmissions(LookupResult result, TypeSymbol submissionClass, string name, int arity, LookupOptions options, Binder binder, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				LookupResult instance = LookupResult.GetInstance();
				LookupResult instance2 = LookupResult.GetInstance();
				SymbolKind? symbolKind = null;
				VisualBasicCompilation visualBasicCompilation = binder.Compilation;
				do
				{
					instance.Clear();
					if ((object)visualBasicCompilation.ScriptClass != null)
					{
						LookupWithoutInheritance(instance, visualBasicCompilation.ScriptClass, name, arity, options, submissionClass, binder, ref useSiteInfo);
					}
					if (!symbolKind.HasValue)
					{
						if (!instance.IsGoodOrAmbiguous)
						{
							instance2.MergePrioritized(instance);
							visualBasicCompilation = visualBasicCompilation.PreviousSubmission;
							continue;
						}
						result.MergeOverloadedOrPrioritized(instance, checkIfCurrentHasOverloads: false);
						Symbol symbol = instance.Symbols.First();
						if (!SymbolExtensions.IsOverloadable(symbol))
						{
							break;
						}
						options &= ~LookupOptions.NamespacesOrTypesOnly;
						symbolKind = symbol.Kind;
					}
					else
					{
						if (instance.HasSymbol && instance.Symbols.First().Kind != symbolKind.Value)
						{
							break;
						}
						if (instance.IsGoodOrAmbiguous)
						{
							result.MergeOverloadedOrPrioritized(instance, checkIfCurrentHasOverloads: false);
						}
					}
					visualBasicCompilation = visualBasicCompilation.PreviousSubmission;
				}
				while (visualBasicCompilation != null);
				if (!result.HasSymbol)
				{
					result.SetFrom(instance2);
				}
				instance.Free();
				instance2.Free();
			}

			public static void LookupDefaultProperty(LookupResult result, TypeSymbol container, Binder binder, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				switch (container.TypeKind)
				{
				case TypeKind.Class:
				case TypeKind.Module:
				case TypeKind.Struct:
				{
					LookupResult instance3 = LookupResult.GetInstance();
					LookupDefaultPropertyInClass(result, (NamedTypeSymbol)container, binder, instance3, ref useSiteInfo);
					instance3.Free();
					break;
				}
				case TypeKind.Interface:
				{
					LookupResult instance2 = LookupResult.GetInstance();
					LookupDefaultPropertyInInterface(result, (NamedTypeSymbol)container, binder, instance2, ref useSiteInfo);
					instance2.Free();
					break;
				}
				case TypeKind.TypeParameter:
				{
					LookupResult instance = LookupResult.GetInstance();
					LookupDefaultPropertyInTypeParameter(result, (TypeParameterSymbol)container, binder, instance, ref useSiteInfo);
					instance.Free();
					break;
				}
				}
			}

			private static void LookupDefaultPropertyInClass(LookupResult result, NamedTypeSymbol type, Binder binder, LookupResult tempResult, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				NamedTypeSymbol accessThroughType = type;
				while ((object)type != null && !LookupDefaultPropertyInSingleType(result, type, accessThroughType, binder, tempResult, ref useSiteInfo))
				{
					if (type.ShouldAddWinRTMembers)
					{
						FindWinRTMembers(result, type, binder, tempResult, ref useSiteInfo, lookupMembersNotDefaultProperties: false);
						if (result.IsGood)
						{
							break;
						}
					}
					type = type.BaseTypeWithDefinitionUseSiteDiagnostics(ref useSiteInfo);
				}
			}

			private static void LookupDefaultPropertyInInterface(LookupResult result, NamedTypeSymbol @interface, Binder binder, LookupResult tempResult, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				if (LookupDefaultPropertyInSingleType(result, @interface, @interface, binder, tempResult, ref useSiteInfo))
				{
					return;
				}
				ImmutableArray<NamedTypeSymbol>.Enumerator enumerator = @interface.InterfacesNoUseSiteDiagnostics.GetEnumerator();
				while (enumerator.MoveNext())
				{
					NamedTypeSymbol current = enumerator.Current;
					TypeSymbolExtensions.AddUseSiteInfo(current.OriginalDefinition, ref useSiteInfo);
					LookupDefaultPropertyInBaseInterface(result, current, binder, tempResult, ref useSiteInfo);
					if (result.HasDiagnostic)
					{
						break;
					}
				}
			}

			private static void LookupDefaultPropertyInTypeParameter(LookupResult result, TypeParameterSymbol typeParameter, Binder binder, LookupResult tempResult, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				NamedTypeSymbol classConstraint = ConstraintsHelper.GetClassConstraint(typeParameter, ref useSiteInfo);
				if ((object)classConstraint != null)
				{
					LookupDefaultPropertyInClass(result, classConstraint, binder, tempResult, ref useSiteInfo);
					if (!result.IsClear)
					{
						return;
					}
				}
				Queue<InterfaceInfo> allInterfaces = null;
				HashSet<InterfaceInfo> processedInterfaces = null;
				AddInterfaceConstraints(typeParameter, ref allInterfaces, ref processedInterfaces, ref useSiteInfo);
				if (allInterfaces == null)
				{
					return;
				}
				foreach (InterfaceInfo item in allInterfaces)
				{
					LookupDefaultPropertyInBaseInterface(result, item.InterfaceType, binder, tempResult, ref useSiteInfo);
					if (result.HasDiagnostic)
					{
						break;
					}
				}
			}

			private static void LookupDefaultPropertyInBaseInterface(LookupResult result, NamedTypeSymbol type, Binder binder, LookupResult tempResult, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				if (TypeSymbolExtensions.IsErrorType(type))
				{
					return;
				}
				LookupResult instance = LookupResult.GetInstance();
				try
				{
					LookupDefaultPropertyInInterface(instance, type, binder, tempResult, ref useSiteInfo);
					if (!instance.HasSymbol)
					{
						return;
					}
					if (instance.HasDiagnostic || !result.HasSymbol)
					{
						result.SetFrom(instance);
						return;
					}
					Symbol symbol = result.Symbols[0];
					Symbol symbol2 = instance.Symbols[0];
					if (symbol.ContainingSymbol != symbol2.ContainingSymbol)
					{
						result.MergeAmbiguous(instance, GenerateAmbiguousDefaultPropertyDiagnostic);
					}
				}
				finally
				{
					instance.Free();
				}
			}

			private static bool LookupDefaultPropertyInSingleType(LookupResult result, NamedTypeSymbol type, TypeSymbol accessThroughType, Binder binder, LookupResult tempResult, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				string defaultPropertyName = type.DefaultPropertyName;
				if (string.IsNullOrEmpty(defaultPropertyName))
				{
					return false;
				}
				switch (type.TypeKind)
				{
				case TypeKind.Class:
				case TypeKind.Module:
				case TypeKind.Struct:
					LookupInClass(result, type, defaultPropertyName, 0, LookupOptions.Default, accessThroughType, binder, tempResult, ref useSiteInfo);
					break;
				case TypeKind.Interface:
					LookupInInterface(result, type, defaultPropertyName, 0, LookupOptions.Default, binder, tempResult, ref useSiteInfo);
					break;
				case TypeKind.TypeParameter:
					throw ExceptionUtilities.UnexpectedValue(type.TypeKind);
				}
				return result.HasSymbol;
			}

			private static AmbiguousSymbolDiagnostic GenerateAmbiguousDefaultPropertyDiagnostic(ImmutableArray<Symbol> symbols)
			{
				Symbol symbol = symbols[0];
				Symbol containingSymbol = symbol.ContainingSymbol;
				int num = symbols.Length - 1;
				for (int i = 1; i <= num; i++)
				{
					Symbol symbol2 = symbols[i];
					Symbol containingSymbol2 = symbol2.ContainingSymbol;
					if (containingSymbol != containingSymbol2)
					{
						return new AmbiguousSymbolDiagnostic(ERRID.ERR_DefaultPropertyAmbiguousAcrossInterfaces4, symbols, symbol, containingSymbol, symbol2, containingSymbol2);
					}
				}
				throw ExceptionUtilities.Unreachable;
			}

			private static void LookupForExtensionMethodsIfNeedTo(LookupResult result, TypeSymbol container, string name, int arity, LookupOptions options, Binder binder, LookupResult tempResult, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				if (!result.IsGood || ((options & LookupOptions.EagerlyLookupExtensionMethods) != 0 && result.Symbols[0].Kind == SymbolKind.Method))
				{
					tempResult.Clear();
					LookupForExtensionMethods(tempResult, container, name, arity, options, binder, ref useSiteInfo);
					MergeInternalXmlHelperValueIfNecessary(tempResult, container, name, arity, options, binder, ref useSiteInfo);
					result.MergeOverloadedOrPrioritized(tempResult, checkIfCurrentHasOverloads: false);
				}
			}

			private static bool ShouldLookupExtensionMethods(LookupOptions options, TypeSymbol container)
			{
				if (LookupOptionExtensions.ShouldLookupExtensionMethods(options) && !TypeSymbolExtensions.IsObjectType(container) && !container.IsShared)
				{
					return !TypeSymbolExtensions.IsModuleType(container);
				}
				return false;
			}

			public static void LookupForExtensionMethods(LookupResult lookupResult, TypeSymbol container, string name, int arity, LookupOptions options, Binder binder, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				if (!ShouldLookupExtensionMethods(options, container))
				{
					lookupResult.SetFrom(SingleLookupResult.Empty);
					return;
				}
				Binder binder2 = binder;
				ArrayBuilder<MethodSymbol> instance = ArrayBuilder<MethodSymbol>.GetInstance();
				int num = 0;
				HashSet<NamedTypeSymbol> hashSet = new HashSet<NamedTypeSymbol>();
				do
				{
					instance.Clear();
					binder2.CollectProbableExtensionMethodsInSingleBinder(name, instance, binder);
					int num2 = 0;
					int count = instance.Count;
					while (num2 < count)
					{
						NamedTypeSymbol containingType = instance[num2].ContainingType;
						if (hashSet.Add(containingType) && ((options & LookupOptions.IgnoreAccessibility) != 0 || AccessCheck.IsSymbolAccessible(containingType, binder.Compilation.Assembly, ref useSiteInfo)))
						{
							do
							{
								MethodSymbol methodSymbol = instance[num2].ReduceExtensionMethod(container, num, ref useSiteInfo);
								if ((object)methodSymbol != null)
								{
									lookupResult.MergeOverloadedOrPrioritizedExtensionMethods(binder.CheckViability(methodSymbol, arity, options, methodSymbol.ContainingType, ref useSiteInfo));
								}
								num2++;
							}
							while (num2 < count && (object)containingType == instance[num2].ContainingSymbol);
						}
						else
						{
							do
							{
								num2++;
							}
							while (num2 < count && (object)containingType == instance[num2].ContainingSymbol);
						}
					}
					num++;
					binder2 = binder2.m_containingBinder;
				}
				while (binder2 != null);
				instance.Free();
			}

			private static void MergeInternalXmlHelperValueIfNecessary(LookupResult lookupResult, TypeSymbol container, string name, int arity, LookupOptions options, Binder binder, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				if (arity != 0 || !CaseInsensitiveComparison.Equals(name, "Value"))
				{
					return;
				}
				VisualBasicCompilation compilation = binder.Compilation;
				if ((options & LookupOptions.NamespacesOrTypesOnly) == 0 && TypeSymbolExtensions.IsOrImplementsIEnumerableOfXElement(container, compilation, ref useSiteInfo))
				{
					PropertySymbol internalXmlHelperValueExtensionProperty = binder.GetInternalXmlHelperValueExtensionProperty();
					SingleLookupResult other;
					if ((object)internalXmlHelperValueExtensionProperty == null)
					{
						DiagnosticInfo diagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_XmlFeaturesNotAvailable);
						other = new SingleLookupResult(LookupResultKind.NotReferencable, GetErrorSymbol(name, diagnosticInfo), diagnosticInfo);
					}
					else
					{
						ReducedExtensionPropertySymbol reducedExtensionPropertySymbol = new ReducedExtensionPropertySymbol(internalXmlHelperValueExtensionProperty);
						other = binder.CheckViability(reducedExtensionPropertySymbol, arity, options, reducedExtensionPropertySymbol.ContainingType, ref useSiteInfo);
					}
					lookupResult.MergePrioritized(other);
				}
			}

			private static void AddLookupSymbolsInfoOfExtensionMethods(LookupSymbolsInfo nameSet, TypeSymbol container, LookupSymbolsInfo newInfo, Binder binder)
			{
				LookupResult instance = LookupResult.GetInstance();
				foreach (string name in newInfo.Names)
				{
					instance.Clear();
					CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
					LookupForExtensionMethods(instance, container, name, 0, LookupOptions.IgnoreAccessibility | LookupOptions.AllMethodsOfAnyArity, binder, ref useSiteInfo);
					if (instance.IsGood)
					{
						ArrayBuilder<Symbol>.Enumerator enumerator2 = instance.Symbols.GetEnumerator();
						while (enumerator2.MoveNext())
						{
							MethodSymbol methodSymbol = (MethodSymbol)enumerator2.Current;
							nameSet.AddSymbol(methodSymbol, methodSymbol.Name, methodSymbol.Arity);
						}
					}
				}
				instance.Free();
			}

			public static void AddExtensionMethodLookupSymbolsInfo(LookupSymbolsInfo nameSet, TypeSymbol container, LookupOptions options, Binder binder)
			{
				if (ShouldLookupExtensionMethods(options, container))
				{
					options &= ~LookupOptions.MustBeInstance;
					Binder binder2 = binder;
					LookupSymbolsInfo instance = LookupSymbolsInfo.GetInstance();
					do
					{
						binder2.AddExtensionMethodLookupSymbolsInfoInSingleBinder(instance, options, binder);
						binder2 = binder2.m_containingBinder;
					}
					while (binder2 != null);
					AddLookupSymbolsInfoOfExtensionMethods(nameSet, container, instance, binder);
					instance.Free();
					VisualBasicCompilation compilation = binder.Compilation;
					CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.DiscardedDependencies;
					if (TypeSymbolExtensions.IsOrImplementsIEnumerableOfXElement(container, compilation, ref useSiteInfo) && useSiteInfo.Diagnostics.IsNullOrEmpty())
					{
						nameSet.AddSymbol(null, "Value", 0);
					}
				}
			}

			private static bool IsDerivedInterface(NamedTypeSymbol @base, NamedTypeSymbol derived, BasesBeingResolved basesBeingResolved, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				if (TypeSymbol.Equals(derived.OriginalDefinition, @base.OriginalDefinition, TypeCompareKind.ConsiderEverything))
				{
					return false;
				}
				if (basesBeingResolved.InheritsBeingResolvedOpt == null)
				{
					ImmutableArray<NamedTypeSymbol>.Enumerator enumerator = derived.AllInterfacesWithDefinitionUseSiteDiagnostics(ref useSiteInfo).GetEnumerator();
					while (enumerator.MoveNext())
					{
						if (TypeSymbol.Equals(enumerator.Current, @base, TypeCompareKind.ConsiderEverything))
						{
							return true;
						}
					}
					return false;
				}
				return IsDerivedInterface(@base, derived, basesBeingResolved, new HashSet<Symbol>(), ref useSiteInfo);
			}

			private static bool IsDerivedInterface(NamedTypeSymbol @base, NamedTypeSymbol derived, BasesBeingResolved basesBeingResolved, HashSet<Symbol> verified, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				verified.Add(derived);
				ImmutableArray<NamedTypeSymbol> declaredInterfacesWithDefinitionUseSiteDiagnostics = derived.GetDeclaredInterfacesWithDefinitionUseSiteDiagnostics(basesBeingResolved, ref useSiteInfo);
				if (!declaredInterfacesWithDefinitionUseSiteDiagnostics.IsDefaultOrEmpty)
				{
					ImmutableArray<NamedTypeSymbol>.Enumerator enumerator = declaredInterfacesWithDefinitionUseSiteDiagnostics.GetEnumerator();
					while (enumerator.MoveNext())
					{
						NamedTypeSymbol current = enumerator.Current;
						if (TypeSymbol.Equals(current, @base, TypeCompareKind.ConsiderEverything))
						{
							return true;
						}
						if (!verified.Contains(current) && IsDerivedInterface(@base, current, basesBeingResolved, verified, ref useSiteInfo))
						{
							return true;
						}
					}
				}
				return false;
			}

			private static void LookupInInterface(LookupResult lookupResult, NamedTypeSymbol container, string name, int arity, LookupOptions options, Binder binder, LookupResult tempResult, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				bool methodsOnly = CheckAndClearMethodsOnlyOption(ref options);
				InterfaceInfo item = new InterfaceInfo(container, inComInterfaceContext: false);
				Queue<InterfaceInfo> queue = new Queue<InterfaceInfo>();
				queue.Enqueue(item);
				HashSet<InterfaceInfo> hashSet = new HashSet<InterfaceInfo>();
				hashSet.Add(item);
				LookupInInterfaces(lookupResult, container, queue, hashSet, name, arity, options, binder, methodsOnly, ref useSiteInfo);
				if (!lookupResult.IsGoodOrAmbiguous && (options & LookupOptions.NoSystemObjectLookupForInterfaces) == 0)
				{
					LookupResult instance = LookupResult.GetInstance();
					NamedTypeSymbol specialType = binder.SourceModule.ContainingAssembly.GetSpecialType(SpecialType.System_Object);
					LookupInClass(instance, specialType, name, arity, options | LookupOptions.IgnoreExtensionMethods, specialType, binder, tempResult, ref useSiteInfo);
					if (instance.IsGood)
					{
						lookupResult.SetFrom(instance);
					}
					instance.Free();
				}
				ClearLookupResultIfNotMethods(methodsOnly, lookupResult);
				LookupForExtensionMethodsIfNeedTo(lookupResult, container, name, arity, options, binder, tempResult, ref useSiteInfo);
			}

			private static void LookupInInterfaces(LookupResult lookupResult, TypeSymbol container, Queue<InterfaceInfo> lookIn, HashSet<InterfaceInfo> processed, string name, int arity, LookupOptions options, Binder binder, bool methodsOnly, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				BasesBeingResolved basesBeingResolved = binder.BasesBeingResolved();
				bool value = (options & LookupOptions.EventsOnly) != 0;
				LookupResult instance = LookupResult.GetInstance();
				do
				{
					InterfaceInfo currentInfo = lookIn.Dequeue();
					LookupWithoutInheritance(instance, currentInfo.InterfaceType, name, arity, options, container, binder, ref useSiteInfo);
					if ((!instance.StopFurtherLookup || !AnyShadows(instance)) && (options & LookupOptions.NoBaseClassLookup) == 0 && !binder.IgnoreBaseClassesInLookup)
					{
						AddBaseInterfacesToTheSearch(binder, currentInfo, lookIn, processed, ref useSiteInfo);
					}
					bool? leaveEventsOnly = null;
					if (currentInfo.InComInterfaceContext)
					{
						leaveEventsOnly = value;
					}
					if (lookupResult.IsGood && instance.IsGood)
					{
						MergeInterfaceLookupResults(lookupResult, instance, basesBeingResolved, leaveEventsOnly, ref useSiteInfo);
					}
					else
					{
						if (instance.IsGood && leaveEventsOnly.HasValue)
						{
							FilterSymbolsInLookupResult(instance, SymbolKind.Event, leaveEventsOnly.Value);
						}
						lookupResult.MergePrioritized(instance);
					}
					instance.Clear();
				}
				while (lookIn.Count != 0);
				instance.Free();
				if (methodsOnly && lookupResult.IsGood)
				{
					FilterSymbolsInLookupResult(lookupResult, SymbolKind.Method, leaveInsteadOfRemoving: true);
				}
				if (!lookupResult.IsGood)
				{
					return;
				}
				AmbiguousSymbolDiagnostic ambiguousSymbolDiagnostic = null;
				ArrayBuilder<Symbol> symbols = lookupResult.Symbols;
				int num = symbols.Count - 2;
				for (int i = 0; i <= num; i++)
				{
					_ = symbols[i].ContainingType;
					int num2 = i + 1;
					int num3 = symbols.Count - 1;
					int num4 = num2;
					while (num4 <= num3)
					{
						if (LookupResult.CanOverload(symbols[i], symbols[num4]))
						{
							num4++;
							continue;
						}
						goto IL_0150;
					}
					continue;
					IL_0150:
					ambiguousSymbolDiagnostic = new AmbiguousSymbolDiagnostic(ERRID.ERR_AmbiguousAcrossInterfaces3, symbols.ToImmutable(), name, CustomSymbolDisplayFormatter.DefaultErrorFormat(symbols[i].ContainingType), CustomSymbolDisplayFormatter.DefaultErrorFormat(symbols[num4].ContainingType));
					break;
				}
				if (ambiguousSymbolDiagnostic != null)
				{
					lookupResult.SetFrom(new SingleLookupResult(LookupResultKind.Ambiguous, symbols.First(), ambiguousSymbolDiagnostic));
				}
			}

			private static void FilterSymbolsInLookupResult(LookupResult result, SymbolKind kind, bool leaveInsteadOfRemoving)
			{
				ArrayBuilder<Symbol> symbols = result.Symbols;
				int num = 0;
				for (int i = 0; i < symbols.Count; i++)
				{
					if (symbols[i].Kind == kind == leaveInsteadOfRemoving)
					{
						symbols[num] = symbols[i];
						num++;
					}
				}
				symbols.Clip(num);
				if (num == 0)
				{
					result.Clear();
				}
			}

			private static void LookupInTypeParameter(LookupResult lookupResult, TypeParameterSymbol typeParameter, string name, int arity, LookupOptions options, Binder binder, LookupResult tempResult, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				bool methodsOnly = CheckAndClearMethodsOnlyOption(ref options);
				LookupInTypeParameterNoExtensionMethods(lookupResult, typeParameter, name, arity, options, binder, tempResult, ref useSiteInfo);
				ClearLookupResultIfNotMethods(methodsOnly, lookupResult);
				LookupForExtensionMethodsIfNeedTo(lookupResult, typeParameter, name, arity, options, binder, tempResult, ref useSiteInfo);
			}

			private static void LookupInTypeParameterNoExtensionMethods(LookupResult result, TypeParameterSymbol typeParameter, string name, int arity, LookupOptions options, Binder binder, LookupResult tempResult, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				options |= LookupOptions.IgnoreExtensionMethods;
				NamedTypeSymbol classConstraint = ConstraintsHelper.GetClassConstraint(typeParameter, ref useSiteInfo);
				if ((object)classConstraint != null)
				{
					LookupInClass(result, classConstraint, name, arity, options, classConstraint, binder, tempResult, ref useSiteInfo);
					if (result.StopFurtherLookup)
					{
						return;
					}
				}
				Queue<InterfaceInfo> allInterfaces = null;
				HashSet<InterfaceInfo> processedInterfaces = null;
				AddInterfaceConstraints(typeParameter, ref allInterfaces, ref processedInterfaces, ref useSiteInfo);
				if (allInterfaces != null)
				{
					LookupResult instance = LookupResult.GetInstance();
					LookupInInterfaces(instance, typeParameter, allInterfaces, processedInterfaces, name, arity, options, binder, methodsOnly: false, ref useSiteInfo);
					result.MergePrioritized(instance);
					instance.Free();
					if (!result.IsClear)
					{
						return;
					}
				}
				if ((object)classConstraint == null)
				{
					NamedTypeSymbol typeParameterBaseType = GetTypeParameterBaseType(typeParameter);
					LookupInClass(result, typeParameterBaseType, name, arity, options, typeParameterBaseType, binder, tempResult, ref useSiteInfo);
				}
			}

			private static bool CheckAndClearMethodsOnlyOption(ref LookupOptions options)
			{
				if ((options & LookupOptions.MethodsOnly) != 0)
				{
					options &= ~LookupOptions.MethodsOnly;
					return true;
				}
				return false;
			}

			private static void ClearLookupResultIfNotMethods(bool methodsOnly, LookupResult lookupResult)
			{
				if (methodsOnly && lookupResult.HasSymbol && lookupResult.Symbols[0].Kind != SymbolKind.Method)
				{
					lookupResult.Clear();
				}
			}

			private static void AddInterfaceConstraints(TypeParameterSymbol typeParameter, ref Queue<InterfaceInfo> allInterfaces, ref HashSet<InterfaceInfo> processedInterfaces, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				ImmutableArray<TypeSymbol>.Enumerator enumerator = typeParameter.ConstraintTypesWithDefinitionUseSiteDiagnostics(ref useSiteInfo).GetEnumerator();
				while (enumerator.MoveNext())
				{
					TypeSymbol current = enumerator.Current;
					switch (current.TypeKind)
					{
					case TypeKind.Interface:
					{
						InterfaceInfo item = new InterfaceInfo((NamedTypeSymbol)current, inComInterfaceContext: false);
						if (processedInterfaces == null || !processedInterfaces.Contains(item))
						{
							if (processedInterfaces == null)
							{
								allInterfaces = new Queue<InterfaceInfo>();
								processedInterfaces = new HashSet<InterfaceInfo>();
							}
							allInterfaces.Enqueue(item);
							processedInterfaces.Add(item);
						}
						break;
					}
					case TypeKind.TypeParameter:
						AddInterfaceConstraints((TypeParameterSymbol)current, ref allInterfaces, ref processedInterfaces, ref useSiteInfo);
						break;
					}
				}
			}

			private static void MergeInterfaceLookupResults(LookupResult knownResult, LookupResult newResult, BasesBeingResolved BasesBeingResolved, bool? leaveEventsOnly, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				ArrayBuilder<Symbol> symbols = knownResult.Symbols;
				ArrayBuilder<Symbol> symbols2 = newResult.Symbols;
				NamedTypeSymbol containingType = symbols2.First().ContainingType;
				int num = symbols.Count - 1;
				for (int i = 0; i <= num; i++)
				{
					Symbol symbol = symbols[i];
					if ((object)symbol == null)
					{
						continue;
					}
					NamedTypeSymbol containingType2 = symbol.ContainingType;
					int num2 = symbols2.Count - 1;
					for (int j = 0; j <= num2; j++)
					{
						Symbol symbol2 = symbols2[j];
						if ((object)symbol2 == null)
						{
							continue;
						}
						if (leaveEventsOnly.HasValue && symbol2.Kind == SymbolKind.Event != leaveEventsOnly.Value)
						{
							symbols2[j] = null;
							continue;
						}
						if (symbol == symbol2)
						{
							symbols2[j] = null;
							continue;
						}
						bool flag = !LookupResult.CanOverload(symbol, symbol2);
						if (IsDerivedInterface(containingType, containingType2, BasesBeingResolved, ref useSiteInfo))
						{
							if (SymbolExtensions.IsShadows(symbol) || flag)
							{
								newResult.Clear();
								return;
							}
						}
						else
						{
							if (!IsDerivedInterface(containingType2, containingType, BasesBeingResolved, ref useSiteInfo) || (!SymbolExtensions.IsShadows(symbol2) && !flag))
							{
								continue;
							}
							symbols[i] = null;
							int num3 = i + 1;
							int num4 = symbols.Count - 1;
							for (int k = num3; k <= num4; k++)
							{
								Symbol symbol3 = symbols[k];
								if ((object)symbol3 != null && TypeSymbol.Equals(symbol3.ContainingType, containingType2, TypeCompareKind.ConsiderEverything))
								{
									symbols[k] = null;
								}
							}
						}
					}
				}
				CompactAndAppend(symbols, symbols2);
				newResult.Clear();
			}

			private static void CompactAndAppend(ArrayBuilder<Symbol> first, ArrayBuilder<Symbol> second)
			{
				int i;
				for (i = 0; i < first.Count && (object)first[i] != null; i++)
				{
				}
				for (int j = i + 1; j < first.Count; j++)
				{
					Symbol symbol = first[j];
					if ((object)symbol != null)
					{
						first[i] = symbol;
						i++;
					}
				}
				first.Clip(i);
				for (i = 0; i < second.Count; i++)
				{
					Symbol symbol2 = second[i];
					if ((object)symbol2 != null)
					{
						first.Add(symbol2);
					}
				}
			}

			private static void AddBaseInterfacesToTheSearch(Binder binder, InterfaceInfo currentInfo, Queue<InterfaceInfo> lookIn, HashSet<InterfaceInfo> processed, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				ImmutableArray<NamedTypeSymbol> directBaseInterfacesNoUseSiteDiagnostics = currentInfo.InterfaceType.GetDirectBaseInterfacesNoUseSiteDiagnostics(binder.BasesBeingResolved());
				if (directBaseInterfacesNoUseSiteDiagnostics.IsDefaultOrEmpty)
				{
					return;
				}
				bool inComInterfaceContext = currentInfo.InComInterfaceContext || (object)currentInfo.InterfaceType.CoClassType != null;
				ImmutableHashSet<NamedTypeSymbol> immutableHashSet = ((binder.BasesBeingResolved().InheritsBeingResolvedOpt == null) ? null : ((currentInfo.DescendantDefinitions != null) ? currentInfo.DescendantDefinitions.Add(currentInfo.InterfaceType.OriginalDefinition) : ImmutableHashSet.Create(currentInfo.InterfaceType.OriginalDefinition)));
				ImmutableArray<NamedTypeSymbol>.Enumerator enumerator = directBaseInterfacesNoUseSiteDiagnostics.GetEnumerator();
				while (enumerator.MoveNext())
				{
					NamedTypeSymbol current = enumerator.Current;
					if (immutableHashSet == null || !immutableHashSet.Contains(current.OriginalDefinition))
					{
						TypeSymbolExtensions.AddUseSiteInfo(current.OriginalDefinition, ref useSiteInfo);
						InterfaceInfo item = new InterfaceInfo(current, inComInterfaceContext, immutableHashSet);
						if (processed.Add(item))
						{
							lookIn.Enqueue(item);
						}
					}
				}
			}

			private static bool AnyShadows(LookupResult result)
			{
				ArrayBuilder<Symbol>.Enumerator enumerator = result.Symbols.GetEnumerator();
				while (enumerator.MoveNext())
				{
					if (SymbolExtensions.IsShadows(enumerator.Current))
					{
						return true;
					}
				}
				return false;
			}

			private static void AddLookupSymbolsInfoInClass(LookupSymbolsInfo nameSet, TypeSymbol container, LookupOptions options, Binder binder)
			{
				if (((object)container != null) & (container.SpecialType == SpecialType.System_Void))
				{
					return;
				}
				TypeSymbol typeSymbol = container;
				do
				{
					AddLookupSymbolsInfoWithoutInheritance(nameSet, typeSymbol, options, container, binder);
					if (typeSymbol is NamedTypeSymbol namedTypeSymbol && namedTypeSymbol.ShouldAddWinRTMembers)
					{
						AddWinRTMembersLookupSymbolsInfo(nameSet, namedTypeSymbol, options, container, binder);
					}
					typeSymbol = (((options & LookupOptions.NoBaseClassLookup) == 0 && !binder.IgnoreBaseClassesInLookup) ? typeSymbol.GetDirectBaseTypeNoUseSiteDiagnostics(binder.BasesBeingResolved()) : null);
				}
				while ((object)typeSymbol != null);
				AddExtensionMethodLookupSymbolsInfo(nameSet, container, options, binder);
				if (binder.ContainingMember is MethodSymbol methodSymbol && methodSymbol.MethodKind == MethodKind.Constructor && (container.TypeKind == TypeKind.Class || container.TypeKind == TypeKind.Struct) && (TypeSymbol.Equals(methodSymbol.ContainingType, container, TypeCompareKind.ConsiderEverything) || TypeSymbol.Equals(methodSymbol.ContainingType.BaseTypeNoUseSiteDiagnostics, container, TypeCompareKind.ConsiderEverything)))
				{
					nameSet.AddSymbol(null, ".ctor", 0);
				}
			}

			private static void AddLookupSymbolsInfoInSubmissions(LookupSymbolsInfo nameSet, TypeSymbol submissionClass, LookupOptions options, Binder binder)
			{
				VisualBasicCompilation visualBasicCompilation = binder.Compilation;
				do
				{
					if ((object)visualBasicCompilation.ScriptClass != null)
					{
						AddLookupSymbolsInfoWithoutInheritance(nameSet, visualBasicCompilation.ScriptClass, options, submissionClass, binder);
					}
					visualBasicCompilation = visualBasicCompilation.PreviousSubmission;
				}
				while (visualBasicCompilation != null);
			}

			private static void AddLookupSymbolsInfoInInterface(LookupSymbolsInfo nameSet, NamedTypeSymbol container, LookupOptions options, Binder binder)
			{
				InterfaceInfo item = new InterfaceInfo(container, inComInterfaceContext: false);
				Queue<InterfaceInfo> queue = new Queue<InterfaceInfo>();
				queue.Enqueue(item);
				HashSet<InterfaceInfo> hashSet = new HashSet<InterfaceInfo>();
				hashSet.Add(item);
				AddLookupSymbolsInfoInInterfaces(nameSet, container, queue, hashSet, options, binder);
				AddLookupSymbolsInfoInClass(nameSet, binder.SourceModule.ContainingAssembly.GetSpecialType(SpecialType.System_Object), options | LookupOptions.IgnoreExtensionMethods, binder);
				AddExtensionMethodLookupSymbolsInfo(nameSet, container, options, binder);
			}

			private static void AddLookupSymbolsInfoInInterfaces(LookupSymbolsInfo nameSet, TypeSymbol container, Queue<InterfaceInfo> lookIn, HashSet<InterfaceInfo> processed, LookupOptions options, Binder binder)
			{
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
				do
				{
					InterfaceInfo currentInfo = lookIn.Dequeue();
					AddLookupSymbolsInfoWithoutInheritance(nameSet, currentInfo.InterfaceType, options, container, binder);
					if ((options & LookupOptions.NoBaseClassLookup) == 0 && !binder.IgnoreBaseClassesInLookup)
					{
						AddBaseInterfacesToTheSearch(binder, currentInfo, lookIn, processed, ref useSiteInfo);
					}
				}
				while (lookIn.Count != 0);
			}

			private static void AddLookupSymbolsInfoInTypeParameter(LookupSymbolsInfo nameSet, TypeParameterSymbol typeParameter, LookupOptions options, Binder binder)
			{
				if (typeParameter.TypeParameterKind != TypeParameterKind.Cref)
				{
					AddLookupSymbolsInfoInTypeParameterNoExtensionMethods(nameSet, typeParameter, options, binder);
					AddExtensionMethodLookupSymbolsInfo(nameSet, typeParameter, options, binder);
				}
			}

			private static void AddLookupSymbolsInfoInTypeParameterNoExtensionMethods(LookupSymbolsInfo nameSet, TypeParameterSymbol typeParameter, LookupOptions options, Binder binder)
			{
				options |= LookupOptions.IgnoreExtensionMethods;
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
				NamedTypeSymbol classConstraint = ConstraintsHelper.GetClassConstraint(typeParameter, ref useSiteInfo);
				if ((object)classConstraint != null)
				{
					AddLookupSymbolsInfoInClass(nameSet, classConstraint, options, binder);
				}
				Queue<InterfaceInfo> allInterfaces = null;
				HashSet<InterfaceInfo> processedInterfaces = null;
				useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
				AddInterfaceConstraints(typeParameter, ref allInterfaces, ref processedInterfaces, ref useSiteInfo);
				if (allInterfaces != null)
				{
					AddLookupSymbolsInfoInInterfaces(nameSet, typeParameter, allInterfaces, processedInterfaces, options, binder);
				}
				if ((object)classConstraint == null)
				{
					NamedTypeSymbol typeParameterBaseType = GetTypeParameterBaseType(typeParameter);
					AddLookupSymbolsInfoInClass(nameSet, typeParameterBaseType, options, binder);
				}
			}

			private static void LookupWithoutInheritance(LookupResult lookupResult, TypeSymbol container, string name, int arity, LookupOptions options, TypeSymbol accessThroughType, Binder binder, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				ImmutableArray<Symbol> immutableArray = ImmutableArray<Symbol>.Empty;
				if ((options & (LookupOptions.NamespacesOrTypesOnly | LookupOptions.LabelsOnly)) == LookupOptions.NamespacesOrTypesOnly)
				{
					if (container is NamedTypeSymbol)
					{
						immutableArray = ImmutableArray<Symbol>.CastUp(container.GetTypeMembers(name));
					}
				}
				else if ((options & LookupOptions.LabelsOnly) == 0)
				{
					immutableArray = container.GetMembers(name);
				}
				if (!immutableArray.IsDefaultOrEmpty)
				{
					bool imported = (object)container.ContainingModule != binder.SourceModule;
					ImmutableArray<Symbol>.Enumerator enumerator = immutableArray.GetEnumerator();
					while (enumerator.MoveNext())
					{
						Symbol current = enumerator.Current;
						lookupResult.MergeMembersOfTheSameType(binder.CheckViability(current, arity, options, accessThroughType, ref useSiteInfo), imported);
					}
				}
			}

			private static void AddLookupSymbolsInfoWithoutInheritance(LookupSymbolsInfo nameSet, TypeSymbol container, LookupOptions options, TypeSymbol accessThroughType, Binder binder)
			{
				if ((options & (LookupOptions.NamespacesOrTypesOnly | LookupOptions.LabelsOnly)) == LookupOptions.NamespacesOrTypesOnly)
				{
					if (!(container is NamedTypeSymbol))
					{
						return;
					}
					ImmutableArray<NamedTypeSymbol>.Enumerator enumerator = container.GetTypeMembersUnordered().GetEnumerator();
					while (enumerator.MoveNext())
					{
						NamedTypeSymbol current = enumerator.Current;
						if (binder.CanAddLookupSymbolInfo(current, options, nameSet, accessThroughType))
						{
							nameSet.AddSymbol(current, current.Name, current.Arity);
						}
					}
				}
				else
				{
					if ((options & LookupOptions.LabelsOnly) != 0)
					{
						return;
					}
					ImmutableArray<Symbol>.Enumerator enumerator2 = container.GetMembersUnordered().GetEnumerator();
					while (enumerator2.MoveNext())
					{
						Symbol current2 = enumerator2.Current;
						if (binder.CanAddLookupSymbolInfo(current2, options, nameSet, accessThroughType))
						{
							nameSet.AddSymbol(current2, current2.Name, SymbolExtensions.GetArity(current2));
						}
					}
				}
			}

			private static void AddWinRTMembersLookupSymbolsInfo(LookupSymbolsInfo nameSet, NamedTypeSymbol type, LookupOptions options, TypeSymbol accessThroughType, Binder binder)
			{
				ImmutableArray<NamedTypeSymbol>.Enumerator enumerator = type.AllInterfacesNoUseSiteDiagnostics.GetEnumerator();
				while (enumerator.MoveNext())
				{
					NamedTypeSymbol current = enumerator.Current;
					if (IsWinRTProjectedInterface(current, binder.Compilation))
					{
						AddLookupSymbolsInfoWithoutInheritance(nameSet, current, options, accessThroughType, binder);
					}
				}
			}

			private static NamedTypeSymbol GetTypeParameterBaseType(TypeParameterSymbol typeParameter)
			{
				return typeParameter.ContainingAssembly.GetSpecialType((!typeParameter.HasValueTypeConstraint) ? SpecialType.System_Object : SpecialType.System_ValueType);
			}
		}

		private sealed class QueryLambdaBinder : BlockBaseBinder<RangeVariableSymbol>
		{
			private class JoinConditionSideDeterminationVisitor : BoundTreeWalkerWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator
			{
				[Flags]
				public enum Result
				{
					None = 0,
					Outer = 1,
					Inner = 2,
					Both = 3
				}

				private readonly ImmutableArray<object> _outerRangeVariables;

				private readonly ImmutableArray<object> _innerRangeVariables;

				private Result _side;

				public JoinConditionSideDeterminationVisitor(ImmutableArray<RangeVariableSymbol> outerRangeVariables, ImmutableArray<RangeVariableSymbol> innerRangeVariables)
				{
					_outerRangeVariables = StaticCast<object>.From(outerRangeVariables);
					_innerRangeVariables = StaticCast<object>.From(innerRangeVariables);
				}

				public Result DetermineTheSide(BoundExpression node, BindingDiagnosticBag diagnostics)
				{
					_side = Result.None;
					try
					{
						Visit(node);
					}
					catch (CancelledByStackGuardException ex)
					{
						ProjectData.SetProjectError(ex);
						CancelledByStackGuardException ex2 = ex;
						ex2.AddAnError(diagnostics);
						ProjectData.ClearProjectError();
					}
					return _side;
				}

				public override BoundNode VisitRangeVariable(BoundRangeVariable node)
				{
					RangeVariableSymbol rangeVariable = node.RangeVariable;
					if (_outerRangeVariables.IndexOf(rangeVariable, ReferenceEqualityComparer.Instance) >= 0)
					{
						_side |= Result.Outer;
					}
					else if (_innerRangeVariables.IndexOf(rangeVariable, ReferenceEqualityComparer.Instance) >= 0)
					{
						_side |= Result.Inner;
					}
					return node;
				}
			}

			private class EqualsOperandIsBadErrorVisitor : BoundTreeWalkerWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator
			{
				private readonly Binder _binder;

				private readonly DiagnosticInfo _errorInfo;

				private readonly BindingDiagnosticBag _diagnostics;

				private readonly ImmutableArray<object> _badRangeVariables;

				private EqualsOperandIsBadErrorVisitor(Binder binder, DiagnosticInfo errorInfo, ImmutableArray<RangeVariableSymbol> badRangeVariables, BindingDiagnosticBag diagnostics)
				{
					_badRangeVariables = StaticCast<object>.From(badRangeVariables);
					_binder = binder;
					_diagnostics = diagnostics;
					_errorInfo = errorInfo;
				}

				public static void Report(Binder binder, DiagnosticInfo errorInfo, ImmutableArray<RangeVariableSymbol> badRangeVariables, BoundExpression node, BindingDiagnosticBag diagnostics)
				{
					EqualsOperandIsBadErrorVisitor equalsOperandIsBadErrorVisitor = new EqualsOperandIsBadErrorVisitor(binder, errorInfo, badRangeVariables, diagnostics);
					try
					{
						equalsOperandIsBadErrorVisitor.Visit(node);
					}
					catch (CancelledByStackGuardException ex)
					{
						ProjectData.SetProjectError(ex);
						CancelledByStackGuardException ex2 = ex;
						ex2.AddAnError(diagnostics);
						ProjectData.ClearProjectError();
					}
				}

				public override BoundNode VisitRangeVariable(BoundRangeVariable node)
				{
					RangeVariableSymbol rangeVariable = node.RangeVariable;
					if (_badRangeVariables.IndexOf(rangeVariable, ReferenceEqualityComparer.Instance) >= 0)
					{
						ReportDiagnostic(_diagnostics, node.Syntax, _errorInfo);
					}
					return node;
				}
			}

			private readonly LambdaSymbol _lambdaSymbol;

			private readonly ImmutableArray<RangeVariableSymbol> _rangeVariables;

			internal override ImmutableArray<RangeVariableSymbol> Locals => _rangeVariables;

			public ImmutableArray<RangeVariableSymbol> RangeVariables => _rangeVariables;

			public override Symbol ContainingMember => _lambdaSymbol;

			public override ImmutableArray<Symbol> AdditionalContainingMembers => ImmutableArray<Symbol>.Empty;

			public LambdaSymbol LambdaSymbol => _lambdaSymbol;

			public override bool IsInQuery => true;

			public QueryLambdaBinder(LambdaSymbol lambdaSymbol, ImmutableArray<RangeVariableSymbol> rangeVariables)
				: base(lambdaSymbol.ContainingBinder)
			{
				_lambdaSymbol = lambdaSymbol;
				_rangeVariables = rangeVariables;
			}

			public BoundExpression BindSelectClauseSelector(Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax select, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator operatorsEnumerator, out ImmutableArray<RangeVariableSymbol> declaredRangeVariables, BindingDiagnosticBag diagnostics)
			{
				SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax> variables = select.Variables;
				bool requireRangeVariable;
				if (variables.Count == 1)
				{
					requireRangeVariable = false;
					while (operatorsEnumerator.MoveNext())
					{
						switch (operatorsEnumerator.Current.Kind())
						{
						case SyntaxKind.SimpleJoinClause:
						case SyntaxKind.GroupJoinClause:
							requireRangeVariable = true;
							break;
						default:
							continue;
						case SyntaxKind.FromClause:
						case SyntaxKind.LetClause:
						case SyntaxKind.AggregateClause:
						case SyntaxKind.GroupByClause:
						case SyntaxKind.SelectClause:
							break;
						}
						break;
					}
				}
				else
				{
					requireRangeVariable = true;
				}
				return BindExpressionRangeVariables(variables, requireRangeVariable, select, out declaredRangeVariables, diagnostics);
			}

			public BoundExpression BindExpressionRangeVariables(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax> selectVariables, bool requireRangeVariable, Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax selectorSyntax, out ImmutableArray<RangeVariableSymbol> declaredRangeVariables, BindingDiagnosticBag diagnostics)
			{
				BoundExpression selector;
				if (selectVariables.Count == 1)
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax item = selectVariables[0];
					selector = null;
					RangeVariableSymbol rangeVariableSymbol = BindExpressionRangeVariable(item, requireRangeVariable, base.ContainingBinder, null, out selector, diagnostics);
					if ((object)rangeVariableSymbol != null)
					{
						declaredRangeVariables = ImmutableArray.Create(rangeVariableSymbol);
					}
					else
					{
						declaredRangeVariables = ImmutableArray<RangeVariableSymbol>.Empty;
					}
				}
				else if (selectVariables.Count == 0)
				{
					selector = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(selectorSyntax, ErrorTypeSymbol.UnknownResultType));
					declaredRangeVariables = ImmutableArray.Create(RangeVariableSymbol.CreateForErrorRecovery(this, selectorSyntax, selector.Type));
				}
				else
				{
					BoundExpression[] array = new BoundExpression[selectVariables.Count - 1 + 1];
					HashSet<string> declaredNames = CreateSetOfDeclaredNames();
					RangeVariableSymbol[] array2 = new RangeVariableSymbol[selectVariables.Count - 1 + 1];
					int num = selectVariables.Count - 1;
					for (int i = 0; i <= num; i++)
					{
						RangeVariableSymbol rangeVariableSymbol2 = (array2[i] = BindExpressionRangeVariable(selectVariables[i], requireRangeVariable: true, base.ContainingBinder, declaredNames, out array[i], diagnostics));
					}
					AnonymousTypeField[] array3 = new AnonymousTypeField[selectVariables.Count - 1 + 1];
					int num2 = array2.Length - 1;
					for (int j = 0; j <= num2; j++)
					{
						RangeVariableSymbol rangeVariableSymbol3 = array2[j];
						array3[j] = new AnonymousTypeField(rangeVariableSymbol3.Name, rangeVariableSymbol3.Type, rangeVariableSymbol3.Syntax.GetLocation(), isKeyOrByRef: true);
					}
					selector = BoundNodeExtensions.MakeCompilerGenerated(BindAnonymousObjectCreationExpression(selectorSyntax, new AnonymousTypeDescriptor(array3.AsImmutableOrNull(), SyntaxNodeExtensions.QueryClauseKeywordOrRangeVariableIdentifier(selectorSyntax).GetLocation(), isImplicitlyDeclared: true), array.AsImmutableOrNull(), diagnostics));
					declaredRangeVariables = array2.AsImmutableOrNull();
				}
				return selector;
			}

			private RangeVariableSymbol BindExpressionRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax item, bool requireRangeVariable, Binder shadowingCheckBinder, HashSet<string> declaredNames, out BoundExpression selector, BindingDiagnosticBag diagnostics)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax nameEquals = item.NameEquals;
				string text = null;
				SyntaxToken syntaxToken = default(SyntaxToken);
				TypeSymbol typeSymbol = null;
				if (nameEquals != null)
				{
					syntaxToken = nameEquals.Identifier.Identifier;
					text = syntaxToken.ValueText;
					if (nameEquals.AsClause != null)
					{
						typeSymbol = DecodeModifiedIdentifierType(nameEquals.Identifier, nameEquals.AsClause, null, null, diagnostics, ModifiedIdentifierTypeDecoderContext.LocalType | ModifiedIdentifierTypeDecoderContext.QueryRangeVariableType);
					}
					else if (nameEquals.Identifier.Nullable.Node != null)
					{
						ReportDiagnostic(diagnostics, nameEquals.Identifier.Nullable, ERRID.ERR_NullableTypeInferenceNotSupported);
					}
				}
				else
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax failedToInferFromXmlName = null;
					SyntaxToken syntaxToken2 = SyntaxNodeExtensions.ExtractAnonymousTypeMemberName(item.Expression, out failedToInferFromXmlName);
					if (VisualBasicExtensions.Kind(syntaxToken2) != 0)
					{
						syntaxToken = syntaxToken2;
						text = syntaxToken.ValueText;
					}
					else if (requireRangeVariable)
					{
						if (failedToInferFromXmlName != null)
						{
							ReportDiagnostic(diagnostics, failedToInferFromXmlName.LocalName, ERRID.ERR_QueryAnonTypeFieldXMLNameInference);
						}
						else
						{
							ReportDiagnostic(diagnostics, item.Expression, ERRID.ERR_QueryAnonymousTypeFieldNameInference);
						}
					}
				}
				if (text != null && text.Length == 0)
				{
					text = null;
				}
				selector = BindValue(item.Expression, diagnostics);
				if ((object)typeSymbol == null)
				{
					selector = MakeRValue(selector, diagnostics);
				}
				else
				{
					selector = ApplyImplicitConversion(item.Expression, typeSymbol, selector, diagnostics);
				}
				RangeVariableSymbol rangeVariableSymbol = null;
				if (text != null)
				{
					rangeVariableSymbol = RangeVariableSymbol.Create(this, syntaxToken, selector.Type);
					selector = new BoundRangeVariableAssignment(item, rangeVariableSymbol, selector, selector.Type);
					bool flag = false;
					if (declaredNames != null && !declaredNames.Add(text))
					{
						ReportDiagnostic(diagnostics, syntaxToken, ERRID.ERR_QueryDuplicateAnonTypeMemberName1, text);
						flag = true;
					}
					else
					{
						shadowingCheckBinder.VerifyRangeVariableName(rangeVariableSymbol, syntaxToken, diagnostics);
						if (item.Parent.Kind() == SyntaxKind.LetClause && ShadowsRangeVariableInTheChildScope(shadowingCheckBinder, rangeVariableSymbol))
						{
							flag = true;
						}
					}
					if (flag)
					{
						rangeVariableSymbol = ((!requireRangeVariable) ? null : RangeVariableSymbol.CreateForErrorRecovery(this, rangeVariableSymbol.Syntax, selector.Type));
					}
				}
				else if (requireRangeVariable)
				{
					rangeVariableSymbol = RangeVariableSymbol.CreateForErrorRecovery(this, item, selector.Type);
				}
				return rangeVariableSymbol;
			}

			public BoundExpression BindLetClauseVariableSelector(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax variable, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator operatorsEnumerator, out ImmutableArray<RangeVariableSymbol> declaredRangeVariables, BindingDiagnosticBag diagnostics)
			{
				BoundExpression selector = null;
				RangeVariableSymbol rangeVariableSymbol = BindExpressionRangeVariable(variable, requireRangeVariable: true, this, null, out selector, diagnostics);
				declaredRangeVariables = ImmutableArray.Create(rangeVariableSymbol);
				if (_rangeVariables.Length > 0)
				{
					selector = BuildJoinSelector(variable, variable == ((Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax)operatorsEnumerator.Current).Variables.Last() && MustProduceFlatCompoundVariable(operatorsEnumerator), diagnostics, rangeVariableSymbol, selector);
				}
				return selector;
			}

			public BoundExpression BindAggregateClauseFirstSelector(Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax aggregate, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator operatorsEnumerator, ImmutableArray<RangeVariableSymbol> rangeVariablesPart1, ImmutableArray<RangeVariableSymbol> rangeVariablesPart2, out ImmutableArray<RangeVariableSymbol> declaredRangeVariables, out BoundQueryClauseBase group, out IntoClauseDisallowGroupReferenceBinder intoBinder, BindingDiagnosticBag diagnostics)
			{
				SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator operatorsEnumerator2 = aggregate.AdditionalQueryOperators.GetEnumerator();
				group = BindCollectionRangeVariables(aggregate, null, aggregate.Variables, ref operatorsEnumerator2, diagnostics);
				group = BindSubsequentQueryOperators(group, operatorsEnumerator2, diagnostics);
				SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax> aggregationVariables = aggregate.AggregationVariables;
				RangeVariableSymbol rangeVariableSymbol = null;
				BoundExpression result;
				switch (aggregationVariables.Count)
				{
				case 0:
					declaredRangeVariables = ImmutableArray.Create(RangeVariableSymbol.CreateForErrorRecovery(this, aggregate, ErrorTypeSymbol.UnknownResultType));
					result = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(aggregate, group, ErrorTypeSymbol.UnknownResultType));
					intoBinder = new IntoClauseDisallowGroupReferenceBinder(new QueryLambdaBinder(_lambdaSymbol, ImmutableArray<RangeVariableSymbol>.Empty), group, group.RangeVariables, group.CompoundVariableType, _rangeVariables.Concat(group.RangeVariables));
					break;
				case 1:
				{
					intoBinder = new IntoClauseDisallowGroupReferenceBinder(new QueryLambdaBinder(_lambdaSymbol, ImmutableArray<RangeVariableSymbol>.Empty), group, group.RangeVariables, group.CompoundVariableType, _rangeVariables.Concat(group.RangeVariables));
					BoundExpression compoundKeyReferencePart;
					ImmutableArray<RangeVariableSymbol> keysRangeVariablesPart;
					BoundExpression compoundKeyReferencePart2;
					ImmutableArray<RangeVariableSymbol> keysRangeVariablesPart2;
					if (rangeVariablesPart1.Length > 0)
					{
						BoundLambdaParameterSymbol boundLambdaParameterSymbol = (BoundLambdaParameterSymbol)_lambdaSymbol.Parameters[0];
						compoundKeyReferencePart = BoundNodeExtensions.MakeCompilerGenerated(new BoundParameter(boundLambdaParameterSymbol.Syntax, boundLambdaParameterSymbol, isLValue: false, boundLambdaParameterSymbol.Type));
						keysRangeVariablesPart = rangeVariablesPart1;
						if (rangeVariablesPart2.Length > 0)
						{
							boundLambdaParameterSymbol = (BoundLambdaParameterSymbol)_lambdaSymbol.Parameters[1];
							compoundKeyReferencePart2 = BoundNodeExtensions.MakeCompilerGenerated(new BoundParameter(boundLambdaParameterSymbol.Syntax, boundLambdaParameterSymbol, isLValue: false, boundLambdaParameterSymbol.Type));
							keysRangeVariablesPart2 = rangeVariablesPart2;
						}
						else
						{
							compoundKeyReferencePart2 = null;
							keysRangeVariablesPart2 = ImmutableArray<RangeVariableSymbol>.Empty;
						}
					}
					else if (rangeVariablesPart2.Length > 0)
					{
						BoundLambdaParameterSymbol boundLambdaParameterSymbol = (BoundLambdaParameterSymbol)_lambdaSymbol.Parameters[1];
						compoundKeyReferencePart = BoundNodeExtensions.MakeCompilerGenerated(new BoundParameter(boundLambdaParameterSymbol.Syntax, boundLambdaParameterSymbol, isLValue: false, boundLambdaParameterSymbol.Type));
						keysRangeVariablesPart = rangeVariablesPart2;
						compoundKeyReferencePart2 = null;
						keysRangeVariablesPart2 = ImmutableArray<RangeVariableSymbol>.Empty;
					}
					else
					{
						compoundKeyReferencePart = null;
						keysRangeVariablesPart = ImmutableArray<RangeVariableSymbol>.Empty;
						compoundKeyReferencePart2 = null;
						keysRangeVariablesPart2 = ImmutableArray<RangeVariableSymbol>.Empty;
					}
					result = intoBinder.BindIntoSelector(aggregate, _rangeVariables, compoundKeyReferencePart, keysRangeVariablesPart, compoundKeyReferencePart2, keysRangeVariablesPart2, null, aggregationVariables, MustProduceFlatCompoundVariable(operatorsEnumerator), out declaredRangeVariables, diagnostics);
					break;
				}
				default:
					rangeVariableSymbol = RangeVariableSymbol.CreateCompilerGenerated(this, aggregate, "$VB$Group", group.Type);
					result = ((_rangeVariables.Length != 0) ? BuildJoinSelector(aggregate, mustProduceFlatCompoundVariable: false, diagnostics, rangeVariableSymbol, group) : group);
					declaredRangeVariables = ImmutableArray.Create(rangeVariableSymbol);
					intoBinder = null;
					break;
				}
				return result;
			}

			public BoundExpression BindAbsorbingJoinSelector(Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax absorbNextOperator, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator operatorsEnumerator, ImmutableArray<RangeVariableSymbol> leftRangeVariables, ImmutableArray<RangeVariableSymbol> rightRangeVariables, out ImmutableArray<RangeVariableSymbol> joinSelectorDeclaredRangeVariables, out BoundQueryClauseBase group, out IntoClauseDisallowGroupReferenceBinder intoBinder, BindingDiagnosticBag diagnostics)
			{
				group = null;
				intoBinder = null;
				switch (absorbNextOperator.Kind())
				{
				case SyntaxKind.SelectClause:
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax select = (Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax)absorbNextOperator;
					return BindSelectClauseSelector(select, operatorsEnumerator, out joinSelectorDeclaredRangeVariables, diagnostics);
				}
				case SyntaxKind.LetClause:
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax letClauseSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax)absorbNextOperator;
					return BindLetClauseVariableSelector(letClauseSyntax.Variables.First(), operatorsEnumerator, out joinSelectorDeclaredRangeVariables, diagnostics);
				}
				case SyntaxKind.AggregateClause:
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax aggregate = (Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax)absorbNextOperator;
					return BindAggregateClauseFirstSelector(aggregate, operatorsEnumerator, leftRangeVariables, rightRangeVariables, out joinSelectorDeclaredRangeVariables, out group, out intoBinder, diagnostics);
				}
				default:
					throw ExceptionUtilities.UnexpectedValue(absorbNextOperator.Kind());
				}
			}

			public BoundExpression BuildJoinSelector(VisualBasicSyntaxNode syntax, bool mustProduceFlatCompoundVariable, BindingDiagnosticBag diagnostics, RangeVariableSymbol rangeVarOpt = null, BoundExpression rangeVarValueOpt = null)
			{
				int num = (((object)rangeVarOpt != null) ? 1 : 0);
				int num2;
				BoundExpression[] array;
				AnonymousTypeField[] array2;
				if (_rangeVariables.Length == 1 || mustProduceFlatCompoundVariable)
				{
					num2 = _rangeVariables.Length + num - 1;
					array = new BoundExpression[num2 + 1];
					array2 = new AnonymousTypeField[num2 + 1];
					int num3 = _rangeVariables.Length - 1;
					for (int i = 0; i <= num3; i++)
					{
						RangeVariableSymbol rangeVariableSymbol = _rangeVariables[i];
						array[i] = BoundNodeExtensions.MakeCompilerGenerated(new BoundRangeVariable(rangeVariableSymbol.Syntax, rangeVariableSymbol, rangeVariableSymbol.Type));
						array2[i] = new AnonymousTypeField(rangeVariableSymbol.Name, rangeVariableSymbol.Type, rangeVariableSymbol.Syntax.GetLocation(), isKeyOrByRef: true);
					}
				}
				else
				{
					ImmutableArray<BoundLambdaParameterSymbol> immutableArray = _lambdaSymbol.Parameters.As<BoundLambdaParameterSymbol>();
					num2 = immutableArray.Length + num - 1;
					array = new BoundExpression[num2 + 1];
					array2 = new AnonymousTypeField[num2 + 1];
					int num4 = immutableArray.Length - 1;
					for (int j = 0; j <= num4; j++)
					{
						BoundLambdaParameterSymbol boundLambdaParameterSymbol = immutableArray[j];
						array[j] = BoundNodeExtensions.MakeCompilerGenerated(new BoundParameter(boundLambdaParameterSymbol.Syntax, boundLambdaParameterSymbol, isLValue: false, boundLambdaParameterSymbol.Type));
						array2[j] = new AnonymousTypeField(boundLambdaParameterSymbol.Name, boundLambdaParameterSymbol.Type, boundLambdaParameterSymbol.Syntax.GetLocation(), isKeyOrByRef: true);
					}
				}
				if ((object)rangeVarOpt != null)
				{
					array[num2] = rangeVarValueOpt;
					array2[num2] = new AnonymousTypeField(rangeVarOpt.Name, rangeVarOpt.Type, rangeVarOpt.Syntax.GetLocation(), isKeyOrByRef: true);
				}
				return BoundNodeExtensions.MakeCompilerGenerated(BindAnonymousObjectCreationExpression(syntax, new AnonymousTypeDescriptor(array2.AsImmutableOrNull(), SyntaxNodeExtensions.QueryClauseKeywordOrRangeVariableIdentifier(syntax).GetLocation(), isImplicitlyDeclared: true), array.AsImmutableOrNull(), diagnostics));
			}

			public static void BindJoinKeys(Binder parentBinder, Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax join, BoundQueryClauseBase outer, BoundQueryClauseBase inner, ImmutableArray<RangeVariableSymbol> joinSelectorRangeVariables, out BoundQueryLambda outerKeyLambda, out QueryLambdaBinder outerKeyBinder, out BoundQueryLambda innerKeyLambda, out QueryLambdaBinder innerKeyBinder, BindingDiagnosticBag diagnostics)
			{
				BoundLambdaParameterSymbol item = parentBinder.CreateQueryLambdaParameterSymbol(GetQueryLambdaParameterName(outer.RangeVariables), 0, outer.CompoundVariableType, join, outer.RangeVariables);
				SynthesizedLambdaSymbol synthesizedLambdaSymbol = parentBinder.CreateQueryLambdaSymbol(LambdaUtilities.GetJoinLeftLambdaBody(join), SynthesizedLambdaKind.JoinLeftQueryLambda, ImmutableArray.Create(item));
				outerKeyBinder = new QueryLambdaBinder(synthesizedLambdaSymbol, joinSelectorRangeVariables);
				BoundLambdaParameterSymbol item2 = parentBinder.CreateQueryLambdaParameterSymbol(GetQueryLambdaParameterName(inner.RangeVariables), 0, inner.CompoundVariableType, join, inner.RangeVariables);
				SynthesizedLambdaSymbol synthesizedLambdaSymbol2 = parentBinder.CreateQueryLambdaSymbol(LambdaUtilities.GetJoinRightLambdaBody(join), SynthesizedLambdaKind.JoinRightQueryLambda, ImmutableArray.Create(item2));
				innerKeyBinder = new QueryLambdaBinder(synthesizedLambdaSymbol2, joinSelectorRangeVariables);
				JoinConditionSideDeterminationVisitor sideDeterminator = new JoinConditionSideDeterminationVisitor(outer.RangeVariables, inner.RangeVariables);
				SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax> joinConditions = join.JoinConditions;
				BoundExpression outerKey;
				BoundExpression innerKey;
				if (joinConditions.Count == 0)
				{
					outerKey = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(join, ErrorTypeSymbol.UnknownResultType));
					innerKey = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(join, ErrorTypeSymbol.UnknownResultType));
					bool flag = false;
				}
				else if (joinConditions.Count == 1)
				{
					outerKey = null;
					innerKey = null;
					if (!BindJoinCondition(joinConditions[0], outerKeyBinder, outer.RangeVariables, out outerKey, innerKeyBinder, inner.RangeVariables, out innerKey, sideDeterminator, diagnostics))
					{
						if ((object)outerKey.Type != ErrorTypeSymbol.UnknownResultType)
						{
							outerKey = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(outerKey.Syntax, outerKey, ErrorTypeSymbol.UnknownResultType));
						}
						if ((object)innerKey.Type != ErrorTypeSymbol.UnknownResultType)
						{
							innerKey = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(innerKey.Syntax, innerKey, ErrorTypeSymbol.UnknownResultType));
						}
					}
				}
				else
				{
					BoundExpression[] array = new BoundExpression[joinConditions.Count - 1 + 1];
					BoundExpression[] array2 = new BoundExpression[joinConditions.Count - 1 + 1];
					bool flag = true;
					int num = joinConditions.Count - 1;
					for (int i = 0; i <= num; i++)
					{
						if (!BindJoinCondition(joinConditions[i], outerKeyBinder, outer.RangeVariables, out array[i], innerKeyBinder, inner.RangeVariables, out array2[i], sideDeterminator, diagnostics))
						{
							flag = false;
						}
					}
					if (flag)
					{
						AnonymousTypeField[] array3 = new AnonymousTypeField[joinConditions.Count - 1 + 1];
						int num2 = joinConditions.Count - 1;
						for (int j = 0; j <= num2; j++)
						{
							array3[j] = new AnonymousTypeField("Key" + j, array[j].Type, joinConditions[j].GetLocation(), isKeyOrByRef: true);
						}
						AnonymousTypeDescriptor typeDescr = new AnonymousTypeDescriptor(array3.AsImmutableOrNull(), join.OnKeyword.GetLocation(), isImplicitlyDeclared: true);
						outerKey = outerKeyBinder.BindAnonymousObjectCreationExpression(join, typeDescr, array.AsImmutableOrNull(), diagnostics);
						innerKey = innerKeyBinder.BindAnonymousObjectCreationExpression(join, typeDescr, array2.AsImmutableOrNull(), diagnostics);
					}
					else
					{
						outerKey = BadExpression(join, array.AsImmutableOrNull(), ErrorTypeSymbol.UnknownResultType);
						innerKey = BadExpression(join, array2.AsImmutableOrNull(), ErrorTypeSymbol.UnknownResultType);
					}
					BoundNodeExtensions.MakeCompilerGenerated(outerKey);
					BoundNodeExtensions.MakeCompilerGenerated(innerKey);
				}
				outerKeyLambda = CreateBoundQueryLambda(synthesizedLambdaSymbol, outer.RangeVariables, outerKey, exprIsOperandOfConditionalBranch: false);
				outerKeyLambda.SetWasCompilerGenerated();
				innerKeyLambda = CreateBoundQueryLambda(synthesizedLambdaSymbol2, inner.RangeVariables, innerKey, exprIsOperandOfConditionalBranch: false);
				innerKeyLambda.SetWasCompilerGenerated();
			}

			private static bool BindJoinCondition(Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax joinCondition, QueryLambdaBinder outerKeyBinder, ImmutableArray<RangeVariableSymbol> outerRangeVariables, out BoundExpression outerKey, QueryLambdaBinder innerKeyBinder, ImmutableArray<RangeVariableSymbol> innerRangeVariables, out BoundExpression innerKey, JoinConditionSideDeterminationVisitor sideDeterminator, BindingDiagnosticBag diagnostics)
			{
				BoundExpression boundExpression = outerKeyBinder.BindRValue(joinCondition.Left, diagnostics);
				JoinConditionSideDeterminationVisitor.Result result = sideDeterminator.DetermineTheSide(boundExpression, diagnostics);
				bool flag;
				switch (result)
				{
				case JoinConditionSideDeterminationVisitor.Result.Outer:
					outerKey = boundExpression;
					innerKey = innerKeyBinder.BindRValue(joinCondition.Right, diagnostics);
					flag = innerKeyBinder.VerifyJoinKeys(outerKey, outerRangeVariables, result, innerKey, innerRangeVariables, sideDeterminator.DetermineTheSide(innerKey, diagnostics), diagnostics);
					break;
				case JoinConditionSideDeterminationVisitor.Result.Inner:
					innerKey = innerKeyBinder.BindRValue(joinCondition.Left, BindingDiagnosticBag.Discarded);
					outerKey = outerKeyBinder.BindRValue(joinCondition.Right, diagnostics);
					flag = innerKeyBinder.VerifyJoinKeys(outerKey, outerRangeVariables, sideDeterminator.DetermineTheSide(outerKey, diagnostics), innerKey, innerRangeVariables, result, diagnostics);
					break;
				default:
				{
					BoundExpression boundExpression2 = innerKeyBinder.BindRValue(joinCondition.Right, diagnostics);
					JoinConditionSideDeterminationVisitor.Result result2 = sideDeterminator.DetermineTheSide(boundExpression2, diagnostics);
					if (result2 == JoinConditionSideDeterminationVisitor.Result.Outer)
					{
						outerKey = outerKeyBinder.BindRValue(joinCondition.Right, BindingDiagnosticBag.Discarded);
						innerKey = innerKeyBinder.BindRValue(joinCondition.Left, BindingDiagnosticBag.Discarded);
						flag = innerKeyBinder.VerifyJoinKeys(outerKey, outerRangeVariables, result2, innerKey, innerRangeVariables, result, diagnostics);
					}
					else
					{
						outerKey = boundExpression;
						innerKey = boundExpression2;
						flag = innerKeyBinder.VerifyJoinKeys(outerKey, outerRangeVariables, result, innerKey, innerRangeVariables, result2, diagnostics);
					}
					break;
				}
				}
				if (flag)
				{
					flag = !TypeSymbolExtensions.IsErrorType(outerKey.Type) && !TypeSymbolExtensions.IsErrorType(innerKey.Type);
				}
				if (flag && !TypeSymbolExtensions.IsSameTypeIgnoringAll(outerKey.Type, innerKey.Type))
				{
					TypeSymbol typeSymbol = null;
					SpecialType intrinsicOperatorType = SpecialType.None;
					CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = outerKeyBinder.GetNewCompoundUseSiteInfo(diagnostics);
					BoundExpression left = outerKey;
					BoundExpression right = innerKey;
					OverloadResolution.OverloadResolutionResult userDefinedOperator = default(OverloadResolution.OverloadResolutionResult);
					BinaryOperatorKind binaryOperatorKind = OverloadResolution.ResolveBinaryOperator(BinaryOperatorKind.Equals, left, right, innerKeyBinder, considerUserDefinedOrLateBound: false, out intrinsicOperatorType, out userDefinedOperator, ref useSiteInfo);
					if ((binaryOperatorKind & BinaryOperatorKind.Equals) != 0 && (binaryOperatorKind & ~(BinaryOperatorKind.Equals | BinaryOperatorKind.Lifted)) == 0 && intrinsicOperatorType != 0)
					{
						diagnostics.AddDependencies(useSiteInfo);
						typeSymbol = innerKeyBinder.GetSpecialTypeForBinaryOperator(joinCondition, outerKey.Type, innerKey.Type, intrinsicOperatorType, (binaryOperatorKind & BinaryOperatorKind.Lifted) != 0, diagnostics);
					}
					else
					{
						TypeInferenceCollection typeInferenceCollection = new TypeInferenceCollection();
						typeInferenceCollection.AddType(outerKey.Type, RequiredConversion.Any, outerKey);
						typeInferenceCollection.AddType(innerKey.Type, RequiredConversion.Any, innerKey);
						ArrayBuilder<DominantTypeData> instance = ArrayBuilder<DominantTypeData>.GetInstance();
						InferenceErrorReasons inferenceErrorReasons = InferenceErrorReasons.Other;
						typeInferenceCollection.FindDominantType(instance, ref inferenceErrorReasons, ref useSiteInfo);
						if (((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)joinCondition, useSiteInfo))
						{
							diagnostics = BindingDiagnosticBag.Discarded;
						}
						if (instance.Count == 1)
						{
							typeSymbol = instance[0].ResultType;
						}
						instance.Free();
					}
					if ((object)typeSymbol == null)
					{
						ReportDiagnostic(diagnostics, joinCondition, ERRID.ERR_EqualsTypeMismatch, outerKey.Type, innerKey.Type);
						flag = false;
					}
					else
					{
						outerKey = outerKeyBinder.ApplyImplicitConversion(outerKey.Syntax, typeSymbol, outerKey, diagnostics);
						innerKey = innerKeyBinder.ApplyImplicitConversion(innerKey.Syntax, typeSymbol, innerKey, diagnostics);
					}
				}
				return flag;
			}

			private bool VerifyJoinKeys(BoundExpression outerKey, ImmutableArray<RangeVariableSymbol> outerRangeVariables, JoinConditionSideDeterminationVisitor.Result outerSide, BoundExpression innerKey, ImmutableArray<RangeVariableSymbol> innerRangeVariables, JoinConditionSideDeterminationVisitor.Result innerSide, BindingDiagnosticBag diagnostics)
			{
				if (outerSide == JoinConditionSideDeterminationVisitor.Result.Outer && innerSide == JoinConditionSideDeterminationVisitor.Result.Inner)
				{
					return true;
				}
				if (outerKey.HasErrors || innerKey.HasErrors)
				{
					return false;
				}
				PooledStringBuilder instance = PooledStringBuilder.GetInstance();
				string text = BuildEqualsOperandIsBadErrorArgument(instance.Builder, outerRangeVariables);
				string text2 = BuildEqualsOperandIsBadErrorArgument(instance.Builder, innerRangeVariables);
				instance.Free();
				if (text == null || text2 == null)
				{
					return false;
				}
				DiagnosticInfo diagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_EqualsOperandIsBad, text, text2);
				switch (outerSide)
				{
				case JoinConditionSideDeterminationVisitor.Result.Inner:
				case JoinConditionSideDeterminationVisitor.Result.Both:
					EqualsOperandIsBadErrorVisitor.Report(this, diagnosticInfo, innerRangeVariables, outerKey, diagnostics);
					break;
				case JoinConditionSideDeterminationVisitor.Result.None:
					ReportDiagnostic(diagnostics, outerKey.Syntax, diagnosticInfo);
					break;
				default:
					throw ExceptionUtilities.UnexpectedValue(outerSide);
				case JoinConditionSideDeterminationVisitor.Result.Outer:
					break;
				}
				switch (innerSide)
				{
				case JoinConditionSideDeterminationVisitor.Result.Outer:
				case JoinConditionSideDeterminationVisitor.Result.Both:
					EqualsOperandIsBadErrorVisitor.Report(this, diagnosticInfo, outerRangeVariables, innerKey, diagnostics);
					break;
				case JoinConditionSideDeterminationVisitor.Result.None:
					ReportDiagnostic(diagnostics, innerKey.Syntax, diagnosticInfo);
					break;
				default:
					throw ExceptionUtilities.UnexpectedValue(innerSide);
				case JoinConditionSideDeterminationVisitor.Result.Inner:
					break;
				}
				return false;
			}

			private static string BuildEqualsOperandIsBadErrorArgument(StringBuilder builder, ImmutableArray<RangeVariableSymbol> rangeVariables)
			{
				builder.Clear();
				int num = rangeVariables.Length - 1;
				int i;
				for (i = 0; i <= num; i++)
				{
					if (!rangeVariables[i].Name.StartsWith("$", StringComparison.Ordinal))
					{
						builder.Append('\'');
						builder.Append(rangeVariables[i].Name);
						builder.Append('\'');
						i++;
						break;
					}
				}
				int num2 = i;
				int num3 = rangeVariables.Length - 1;
				for (i = num2; i <= num3; i++)
				{
					if (!rangeVariables[i].Name.StartsWith("$", StringComparison.Ordinal))
					{
						builder.Append(',');
						builder.Append(' ');
						builder.Append('\'');
						builder.Append(rangeVariables[i].Name);
						builder.Append('\'');
					}
				}
				if (builder.Length == 0)
				{
					return null;
				}
				return builder.ToString();
			}
		}

		private class IntoClauseBinder : Binder
		{
			protected readonly BoundExpression m_GroupReference;

			private readonly ImmutableArray<RangeVariableSymbol> _groupRangeVariables;

			private readonly TypeSymbol _groupCompoundVariableType;

			private readonly ImmutableArray<RangeVariableSymbol> _aggregationArgumentRangeVariables;

			public IntoClauseBinder(Binder parent, BoundExpression groupReference, ImmutableArray<RangeVariableSymbol> groupRangeVariables, TypeSymbol groupCompoundVariableType, ImmutableArray<RangeVariableSymbol> aggregationArgumentRangeVariables)
				: base(parent)
			{
				m_GroupReference = groupReference;
				_groupRangeVariables = groupRangeVariables;
				_groupCompoundVariableType = groupCompoundVariableType;
				_aggregationArgumentRangeVariables = aggregationArgumentRangeVariables;
			}

			internal override BoundExpression BindGroupAggregationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupAggregationSyntax group, BindingDiagnosticBag diagnostics)
			{
				return new BoundGroupAggregation(group, m_GroupReference, m_GroupReference.Type);
			}

			public BoundExpression BindIntoSelector(Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax syntaxNode, ImmutableArray<RangeVariableSymbol> keysRangeVariables, BoundExpression compoundKeyReferencePart1, ImmutableArray<RangeVariableSymbol> keysRangeVariablesPart1, BoundExpression compoundKeyReferencePart2, ImmutableArray<RangeVariableSymbol> keysRangeVariablesPart2, HashSet<string> declaredNames, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax> aggregationVariables, bool mustProduceFlatCompoundVariable, out ImmutableArray<RangeVariableSymbol> declaredRangeVariables, BindingDiagnosticBag diagnostics)
			{
				int num = keysRangeVariables.Length;
				if (declaredNames == null)
				{
					declaredNames = CreateSetOfDeclaredNames(keysRangeVariables);
				}
				int num2 = Math.Max(aggregationVariables.Count, 1);
				RangeVariableSymbol[] array3;
				BoundExpression selector2;
				if (num + num2 > 1)
				{
					BoundExpression[] array;
					AnonymousTypeField[] array2;
					if (num > 1 && !mustProduceFlatCompoundVariable)
					{
						if (compoundKeyReferencePart2 == null)
						{
							array = new BoundExpression[num2 + 1 - 1 + 1];
							array2 = new AnonymousTypeField[array.Length - 1 + 1];
							array2[0] = new AnonymousTypeField(GetQueryLambdaParameterName(keysRangeVariablesPart1), compoundKeyReferencePart1.Type, keysRangeVariables[0].Syntax.GetLocation(), isKeyOrByRef: true);
							array[0] = compoundKeyReferencePart1;
							num = 1;
						}
						else
						{
							array = new BoundExpression[num2 + 2 - 1 + 1];
							array2 = new AnonymousTypeField[array.Length - 1 + 1];
							array2[0] = new AnonymousTypeField(GetQueryLambdaParameterNameLeft(keysRangeVariablesPart1), compoundKeyReferencePart1.Type, keysRangeVariablesPart1[0].Syntax.GetLocation(), isKeyOrByRef: true);
							array[0] = compoundKeyReferencePart1;
							array2[1] = new AnonymousTypeField(GetQueryLambdaParameterNameRight(keysRangeVariablesPart2), compoundKeyReferencePart2.Type, keysRangeVariablesPart2[0].Syntax.GetLocation(), isKeyOrByRef: true);
							array[1] = compoundKeyReferencePart2;
							num = 2;
						}
					}
					else
					{
						array = new BoundExpression[num + num2 - 1 + 1];
						array2 = new AnonymousTypeField[array.Length - 1 + 1];
						int num3 = num - 1;
						for (int i = 0; i <= num3; i++)
						{
							RangeVariableSymbol rangeVariableSymbol = keysRangeVariables[i];
							array2[i] = new AnonymousTypeField(rangeVariableSymbol.Name, rangeVariableSymbol.Type, rangeVariableSymbol.Syntax.GetLocation(), isKeyOrByRef: true);
							array[i] = BoundNodeExtensions.MakeCompilerGenerated(new BoundRangeVariable(rangeVariableSymbol.Syntax, rangeVariableSymbol, rangeVariableSymbol.Type));
						}
					}
					array3 = new RangeVariableSymbol[num2 - 1 + 1];
					if (aggregationVariables.Count == 0)
					{
						RangeVariableSymbol rangeVariableSymbol2 = (array3[0] = RangeVariableSymbol.CreateForErrorRecovery(this, syntaxNode, ErrorTypeSymbol.UnknownResultType));
						array[num] = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(syntaxNode, m_GroupReference, ErrorTypeSymbol.UnknownResultType));
						array2[num] = new AnonymousTypeField(rangeVariableSymbol2.Name, rangeVariableSymbol2.Type, rangeVariableSymbol2.Syntax.GetLocation(), isKeyOrByRef: true);
					}
					else
					{
						int num4 = aggregationVariables.Count - 1;
						for (int j = 0; j <= num4; j++)
						{
							BoundExpression selector = null;
							RangeVariableSymbol rangeVariableSymbol3 = (array3[j] = BindAggregationRangeVariable(aggregationVariables[j], declaredNames, out selector, diagnostics));
							array[num + j] = selector;
							array2[num + j] = new AnonymousTypeField(rangeVariableSymbol3.Name, rangeVariableSymbol3.Type, rangeVariableSymbol3.Syntax.GetLocation(), isKeyOrByRef: true);
						}
					}
					selector2 = BoundNodeExtensions.MakeCompilerGenerated(BindAnonymousObjectCreationExpression(syntaxNode, new AnonymousTypeDescriptor(array2.AsImmutableOrNull(), SyntaxNodeExtensions.QueryClauseKeywordOrRangeVariableIdentifier(syntaxNode).GetLocation(), isImplicitlyDeclared: true), array.AsImmutableOrNull(), diagnostics));
				}
				else
				{
					RangeVariableSymbol rangeVariableSymbol4;
					if (aggregationVariables.Count == 0)
					{
						rangeVariableSymbol4 = RangeVariableSymbol.CreateForErrorRecovery(this, syntaxNode, ErrorTypeSymbol.UnknownResultType);
						selector2 = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(syntaxNode, m_GroupReference, ErrorTypeSymbol.UnknownResultType));
					}
					else
					{
						selector2 = null;
						rangeVariableSymbol4 = BindAggregationRangeVariable(aggregationVariables[0], declaredNames, out selector2, diagnostics);
					}
					array3 = new RangeVariableSymbol[1] { rangeVariableSymbol4 };
				}
				declaredRangeVariables = array3.AsImmutableOrNull();
				return selector2;
			}

			internal override BoundExpression BindFunctionAggregationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax functionAggregationSyntax, BindingDiagnosticBag diagnostics)
			{
				if (VisualBasicExtensions.GetTypeCharacter(functionAggregationSyntax.FunctionName) != 0)
				{
					ReportDiagnostic(diagnostics, functionAggregationSyntax.FunctionName, ERRID.ERR_TypeCharOnAggregation);
				}
				BoundLambdaParameterSymbol item = CreateQueryLambdaParameterSymbol(GetQueryLambdaParameterName(_groupRangeVariables), 0, _groupCompoundVariableType, functionAggregationSyntax.Argument ?? functionAggregationSyntax, _groupRangeVariables);
				SynthesizedLambdaSymbol synthesizedLambdaSymbol = base.ContainingBinder.CreateQueryLambdaSymbol(LambdaUtilities.GetAggregationLambdaBody(functionAggregationSyntax) ?? functionAggregationSyntax, SynthesizedLambdaKind.AggregationQueryLambda, ImmutableArray.Create(item));
				QueryLambdaBinder queryLambdaBinder = new QueryLambdaBinder(synthesizedLambdaSymbol, _aggregationArgumentRangeVariables);
				BoundQueryLambda boundQueryLambda = null;
				ImmutableArray<BoundExpression> immutableArray;
				if (functionAggregationSyntax.Argument == null)
				{
					immutableArray = ImmutableArray<BoundExpression>.Empty;
				}
				else
				{
					BoundExpression expression = queryLambdaBinder.BindValue(functionAggregationSyntax.Argument, diagnostics);
					boundQueryLambda = CreateBoundQueryLambda(synthesizedLambdaSymbol, _groupRangeVariables, expression, exprIsOperandOfConditionalBranch: false);
					boundQueryLambda.SetWasCompilerGenerated();
					immutableArray = ImmutableArray.Create((BoundExpression)boundQueryLambda);
				}
				BoundExpression boundExpression;
				if (TypeSymbolExtensions.IsErrorType(m_GroupReference.Type) || string.IsNullOrEmpty(functionAggregationSyntax.FunctionName.ValueText))
				{
					boundExpression = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(functionAggregationSyntax, ImmutableArray.Create(m_GroupReference).AddRange(immutableArray), ErrorTypeSymbol.UnknownResultType));
				}
				else
				{
					BindingDiagnosticBag diagnostics2 = diagnostics;
					if (boundQueryLambda != null && ShouldSuppressDiagnostics(boundQueryLambda))
					{
						diagnostics2 = BindingDiagnosticBag.Discarded;
					}
					boundExpression = BindQueryOperatorCall(functionAggregationSyntax, m_GroupReference, functionAggregationSyntax.FunctionName.ValueText, immutableArray, functionAggregationSyntax.FunctionName.Span, diagnostics2);
				}
				return new BoundQueryClause(functionAggregationSyntax, boundExpression, ImmutableArray<RangeVariableSymbol>.Empty, boundExpression.Type, ImmutableArray.Create((Binder)queryLambdaBinder), boundExpression.Type);
			}

			public override void AddLookupSymbolsInfo(LookupSymbolsInfo nameSet, LookupOptions options)
			{
				if ((options & (LookupOptions.NamespacesOrTypesOnly | LookupOptions.LabelsOnly | LookupOptions.MustNotBeInstance)) == 0)
				{
					AddMemberLookupSymbolsInfo(nameSet, m_GroupReference.Type, options | (LookupOptions.MustBeInstance | LookupOptions.MethodsOnly));
				}
			}

			public override void Lookup(LookupResult lookupResult, string name, int arity, LookupOptions options, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
			{
				if ((options & (LookupOptions.NamespacesOrTypesOnly | LookupOptions.LabelsOnly | LookupOptions.MustNotBeInstance)) == 0)
				{
					LookupMember(lookupResult, m_GroupReference.Type, name, arity, options | (LookupOptions.MustBeInstance | LookupOptions.MethodsOnly), ref useSiteInfo);
				}
			}

			public RangeVariableSymbol BindAggregationRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax item, HashSet<string> declaredNames, out BoundExpression selector, BindingDiagnosticBag diagnostics)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax nameEquals = item.NameEquals;
				string text = null;
				SyntaxToken syntaxToken = default(SyntaxToken);
				if (nameEquals != null)
				{
					syntaxToken = nameEquals.Identifier.Identifier;
					text = syntaxToken.ValueText;
				}
				else
				{
					switch (item.Aggregation.Kind())
					{
					case SyntaxKind.GroupAggregation:
						if (item.Parent.Kind() != SyntaxKind.AggregateClause)
						{
							syntaxToken = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupAggregationSyntax)item.Aggregation).GroupKeyword;
							text = syntaxToken.ValueText;
						}
						break;
					case SyntaxKind.FunctionAggregation:
						syntaxToken = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax)item.Aggregation).FunctionName;
						text = syntaxToken.ValueText;
						break;
					default:
						throw ExceptionUtilities.UnexpectedValue(item.Aggregation.Kind());
					}
				}
				selector = BindRValue(item.Aggregation, diagnostics);
				if (text != null && text.Length == 0)
				{
					text = null;
				}
				RangeVariableSymbol rangeVariableSymbol = null;
				if (text != null)
				{
					rangeVariableSymbol = RangeVariableSymbol.Create(this, syntaxToken, selector.Type);
					selector = new BoundRangeVariableAssignment(item, rangeVariableSymbol, selector, selector.Type);
					bool flag = false;
					if (declaredNames != null && !declaredNames.Add(text))
					{
						ReportDiagnostic(diagnostics, syntaxToken, ERRID.ERR_QueryDuplicateAnonTypeMemberName1, text);
						flag = true;
					}
					else
					{
						VerifyRangeVariableName(rangeVariableSymbol, syntaxToken, diagnostics);
					}
					if (flag)
					{
						rangeVariableSymbol = RangeVariableSymbol.CreateForErrorRecovery(this, rangeVariableSymbol.Syntax, selector.Type);
					}
				}
				else
				{
					rangeVariableSymbol = RangeVariableSymbol.CreateForErrorRecovery(this, item, selector.Type);
				}
				return rangeVariableSymbol;
			}
		}

		private class IntoClauseDisallowGroupReferenceBinder : IntoClauseBinder
		{
			public IntoClauseDisallowGroupReferenceBinder(Binder parent, BoundExpression groupReference, ImmutableArray<RangeVariableSymbol> groupRangeVariables, TypeSymbol groupCompoundVariableType, ImmutableArray<RangeVariableSymbol> aggregationArgumentRangeVariables)
				: base(parent, groupReference, groupRangeVariables, groupCompoundVariableType, aggregationArgumentRangeVariables)
			{
			}

			internal override BoundExpression BindGroupAggregationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupAggregationSyntax group, BindingDiagnosticBag diagnostics)
			{
				return BadExpression(group, m_GroupReference, ErrorTypeSymbol.UnknownResultType);
			}
		}

		private class CheckOnErrorAndAwaitWalker : BoundTreeWalkerWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator
		{
			private readonly Binder _binder;

			private readonly BindingDiagnosticBag _diagnostics;

			private bool _containsOnError;

			private bool _containsTry;

			private bool _containsResume;

			private Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax _resumeWithoutLabel;

			private bool _containsLineNumberLabel;

			private bool _containsCatch;

			private bool _reportedAnError;

			private BoundStatement _enclosingSyncLockOrUsing;

			private bool _isInCatchFinallyOrSyncLock;

			private bool _containsAwait;

			private readonly ArrayBuilder<BoundStatement> _tryOnErrorResume;

			private CheckOnErrorAndAwaitWalker(Binder binder, BindingDiagnosticBag diagnostics)
			{
				_tryOnErrorResume = new ArrayBuilder<BoundStatement>();
				_diagnostics = diagnostics;
				_binder = binder;
			}

			public static void VisitBlock(Binder binder, BoundBlock block, BindingDiagnosticBag diagnostics, out bool containsAwait, out bool containsOnError, out bool containsResume, out Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax resumeWithoutLabel, out bool containsLineNumberLabel, out bool containsCatch, out bool reportedAnError)
			{
				CheckOnErrorAndAwaitWalker checkOnErrorAndAwaitWalker = new CheckOnErrorAndAwaitWalker(binder, diagnostics);
				try
				{
					checkOnErrorAndAwaitWalker.Visit(block);
				}
				catch (CancelledByStackGuardException ex)
				{
					ProjectData.SetProjectError(ex);
					CancelledByStackGuardException ex2 = ex;
					ex2.AddAnError(diagnostics);
					reportedAnError = true;
					ProjectData.ClearProjectError();
				}
				containsAwait = checkOnErrorAndAwaitWalker._containsAwait;
				containsOnError = checkOnErrorAndAwaitWalker._containsOnError;
				containsResume = checkOnErrorAndAwaitWalker._containsResume;
				reportedAnError = checkOnErrorAndAwaitWalker._reportedAnError;
				resumeWithoutLabel = checkOnErrorAndAwaitWalker._resumeWithoutLabel;
				containsLineNumberLabel = checkOnErrorAndAwaitWalker._containsLineNumberLabel;
				containsCatch = checkOnErrorAndAwaitWalker._containsCatch;
				if ((containsOnError || containsResume) && checkOnErrorAndAwaitWalker._containsTry)
				{
					ArrayBuilder<BoundStatement>.Enumerator enumerator = checkOnErrorAndAwaitWalker._tryOnErrorResume.GetEnumerator();
					while (enumerator.MoveNext())
					{
						BoundStatement current = enumerator.Current;
						ReportDiagnostic(diagnostics, current.Syntax, ERRID.ERR_TryAndOnErrorDoNotMix);
					}
					reportedAnError = true;
				}
			}

			public override BoundNode Visit(BoundNode node)
			{
				if (!_binder.IsInAsyncContext() && node is BoundExpression)
				{
					return null;
				}
				return base.Visit(node);
			}

			public override BoundNode VisitTryStatement(BoundTryStatement node)
			{
				_containsTry = true;
				_tryOnErrorResume.Add(node);
				Visit(node.TryBlock);
				bool isInCatchFinallyOrSyncLock = _isInCatchFinallyOrSyncLock;
				_isInCatchFinallyOrSyncLock = true;
				VisitList(node.CatchBlocks);
				Visit(node.FinallyBlockOpt);
				_isInCatchFinallyOrSyncLock = isInCatchFinallyOrSyncLock;
				return null;
			}

			public override BoundNode VisitOnErrorStatement(BoundOnErrorStatement node)
			{
				_containsOnError = true;
				_tryOnErrorResume.Add(node);
				if (node.OnErrorKind == OnErrorStatementKind.ResumeNext)
				{
					_containsResume = true;
					if (_resumeWithoutLabel == null)
					{
						_resumeWithoutLabel = (Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)node.Syntax;
					}
				}
				if (_enclosingSyncLockOrUsing != null)
				{
					ReportDiagnostic(_diagnostics, node.Syntax, (_enclosingSyncLockOrUsing.Kind == BoundKind.UsingStatement) ? ERRID.ERR_OnErrorInUsing : ERRID.ERR_OnErrorInSyncLock);
					_reportedAnError = true;
				}
				return null;
			}

			public override BoundNode VisitResumeStatement(BoundResumeStatement node)
			{
				_containsResume = true;
				if (node.ResumeKind != ResumeStatementKind.Label && _resumeWithoutLabel == null)
				{
					_resumeWithoutLabel = (Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)node.Syntax;
				}
				_tryOnErrorResume.Add(node);
				return null;
			}

			public override BoundNode VisitSyncLockStatement(BoundSyncLockStatement node)
			{
				BoundStatement enclosingSyncLockOrUsing = _enclosingSyncLockOrUsing;
				bool isInCatchFinallyOrSyncLock = _isInCatchFinallyOrSyncLock;
				_enclosingSyncLockOrUsing = node;
				_isInCatchFinallyOrSyncLock = true;
				base.VisitSyncLockStatement(node);
				_enclosingSyncLockOrUsing = enclosingSyncLockOrUsing;
				_isInCatchFinallyOrSyncLock = isInCatchFinallyOrSyncLock;
				return null;
			}

			public override BoundNode VisitUsingStatement(BoundUsingStatement node)
			{
				BoundStatement enclosingSyncLockOrUsing = _enclosingSyncLockOrUsing;
				_enclosingSyncLockOrUsing = node;
				base.VisitUsingStatement(node);
				_enclosingSyncLockOrUsing = enclosingSyncLockOrUsing;
				return null;
			}

			public override BoundNode VisitAwaitOperator(BoundAwaitOperator node)
			{
				_containsAwait = true;
				if (_isInCatchFinallyOrSyncLock)
				{
					ReportDiagnostic(_diagnostics, node.Syntax, ERRID.ERR_BadAwaitInTryHandler);
					_reportedAnError = true;
				}
				return base.VisitAwaitOperator(node);
			}

			public override BoundNode VisitLambda(BoundLambda node)
			{
				return null;
			}

			public override BoundNode VisitCatchBlock(BoundCatchBlock node)
			{
				_containsCatch = true;
				return base.VisitCatchBlock(node);
			}

			public override BoundNode VisitLabelStatement(BoundLabelStatement node)
			{
				if (!node.WasCompilerGenerated && VisualBasicExtensions.Kind(node.Syntax) == SyntaxKind.LabelStatement && VisualBasicExtensions.Kind(((Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax)node.Syntax).LabelToken) == SyntaxKind.IntegerLiteralToken)
				{
					_containsLineNumberLabel = true;
				}
				return base.VisitLabelStatement(node);
			}
		}

		private class SeenAwaitVisitor : BoundTreeWalkerWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator
		{
			private bool _seenAwait;

			private SeenAwaitVisitor()
			{
			}

			public static bool SeenAwaitIn(BoundNode node, BindingDiagnosticBag diagnostics)
			{
				SeenAwaitVisitor seenAwaitVisitor = new SeenAwaitVisitor();
				try
				{
					seenAwaitVisitor.Visit(node);
				}
				catch (CancelledByStackGuardException ex)
				{
					ProjectData.SetProjectError(ex);
					CancelledByStackGuardException ex2 = ex;
					ex2.AddAnError(diagnostics);
					ProjectData.ClearProjectError();
				}
				return seenAwaitVisitor._seenAwait;
			}

			public override BoundNode Visit(BoundNode node)
			{
				if (_seenAwait)
				{
					return null;
				}
				return base.Visit(node);
			}

			public override BoundNode VisitLambda(BoundLambda node)
			{
				return null;
			}

			public override BoundNode VisitAwaitOperator(BoundAwaitOperator node)
			{
				_seenAwait = true;
				return null;
			}
		}

		private class TypeBinder
		{
			public static TypeSymbol BindTypeSyntax(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax typeSyntax, Binder binder, BindingDiagnosticBag diagBag, bool suppressUseSiteError, bool resolvingBaseType)
			{
				Symbol symbol = BindTypeOrAliasSyntax(typeSyntax, binder, diagBag, suppressUseSiteError, inGetTypeContext: false, resolvingBaseType);
				if ((object)symbol != null && symbol.Kind == SymbolKind.Alias)
				{
					symbol = ((AliasSymbol)symbol).Target;
				}
				return (TypeSymbol)symbol;
			}

			internal static Symbol BindTypeOrAliasSyntax(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax typeSyntax, Binder binder, BindingDiagnosticBag diagBag, bool suppressUseSiteError, bool inGetTypeContext, bool resolvingBaseType)
			{
				LookupResult instance = LookupResult.GetInstance();
				try
				{
					bool reportedAnError = false;
					LookupTypeOrNamespaceSyntax(instance, typeSyntax, binder, diagBag, ref reportedAnError, unwrapAliases: false, suppressUseSiteError, inGetTypeContext, resolvingBaseType);
					DiagnosticInfo diagnosticInfo = null;
					if (!instance.HasSymbol)
					{
						string baseNamesForDiagnostic = GetBaseNamesForDiagnostic(typeSyntax);
						diagnosticInfo = NotFound(typeSyntax, baseNamesForDiagnostic, binder, reportedAnError ? null : diagBag);
						return GetErrorSymbol(baseNamesForDiagnostic, diagnosticInfo);
					}
					if (instance.HasDiagnostic)
					{
						string baseNamesForDiagnostic2 = GetBaseNamesForDiagnostic(typeSyntax);
						diagnosticInfo = instance.Diagnostic;
						if (!reportedAnError)
						{
							ReportDiagnostic(diagBag, typeSyntax, instance.Diagnostic);
						}
						return ErrorTypeFromLookupResult(baseNamesForDiagnostic2, instance, binder);
					}
					Symbol singleSymbol = instance.SingleSymbol;
					TypeSymbol typeSymbol = null;
					typeSymbol = ((singleSymbol.Kind != 0) ? (singleSymbol as TypeSymbol) : (((AliasSymbol)singleSymbol).Target as TypeSymbol));
					if ((object)typeSymbol == null)
					{
						diagnosticInfo = new BadSymbolDiagnostic(instance.SingleSymbol, ERRID.ERR_UnrecognizedType);
						if (!reportedAnError)
						{
							ReportDiagnostic(diagBag, typeSyntax, diagnosticInfo);
						}
						return GetErrorSymbol(GetBaseNamesForDiagnostic(typeSyntax), diagnosticInfo, ImmutableArray.Create(singleSymbol), LookupResultKind.NotATypeOrNamespace);
					}
					if (!reportedAnError && !suppressUseSiteError && !TypeSymbolExtensions.IsArrayType(typeSymbol) && !typeSymbol.IsTupleType && typeSymbol.IsDefinition)
					{
						ReportUseSite(diagBag, typeSyntax, typeSymbol);
					}
					else if ((object)typeSymbol == singleSymbol)
					{
						binder.AddTypesAssemblyAsDependency(typeSymbol as NamedTypeSymbol, diagBag);
					}
					if (diagBag.AccumulatesDiagnostics && typeSymbol.Kind == SymbolKind.NamedType && binder.SourceModule.AnyReferencedAssembliesAreLinked)
					{
						EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)typeSymbol, typeSyntax, diagBag.DiagnosticBag);
					}
					binder.ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagBag, singleSymbol, typeSyntax);
					return singleSymbol;
				}
				finally
				{
					instance.Free();
				}
			}

			private static DiagnosticInfo NotFound(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax typeSyntax, string diagName, Binder binder, BindingDiagnosticBag diagBag)
			{
				if (EmbeddedOperators.CompareString(diagName, "Any", TextCompare: false) == 0 && IsParameterTypeOfDeclareMethod(typeSyntax))
				{
					DiagnosticInfo diagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_ObsoleteAsAny, diagName);
					if (diagBag != null)
					{
						ReportDiagnostic(diagBag, typeSyntax, diagnosticInfo);
					}
					return diagnosticInfo;
				}
				AssemblySymbol forwardedToAssembly = null;
				if (diagName.Length > 0)
				{
					CheckForForwardedType(binder.Compilation.Assembly, ref typeSyntax, ref diagName, ref forwardedToAssembly, diagBag);
					DiagnosticInfo diagnosticInfo = (((object)forwardedToAssembly != null) ? ErrorFactory.ErrorInfo(ERRID.ERR_ForwardedTypeUnavailable3, diagName, binder.Compilation.Assembly, forwardedToAssembly) : ErrorFactory.ErrorInfo(ERRID.ERR_UndefinedType1, diagName));
					if (diagBag != null)
					{
						ReportDiagnostic(diagBag, typeSyntax, diagnosticInfo);
					}
					return diagnosticInfo;
				}
				return null;
			}

			private static void CheckForForwardedType(AssemblySymbol containingAssembly, ref Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax typeSyntax, ref string diagName, ref AssemblySymbol forwardedToAssembly, BindingDiagnosticBag diagBag)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax typeSyntax2 = typeSyntax;
				string text = diagName;
				while (true)
				{
					bool flag = typeSyntax2.Kind() == SyntaxKind.QualifiedName;
					int arity = 0;
					string fullName = text;
					Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax typeSyntax3 = (flag ? ((Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax)typeSyntax2).Right : typeSyntax2);
					if (typeSyntax3.Kind() == SyntaxKind.GenericName)
					{
						arity = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax)typeSyntax3).Arity;
						fullName = MetadataHelpers.ComposeAritySuffixedMetadataName(text, arity);
					}
					forwardedToAssembly = GetForwardedToAssembly(containingAssembly, fullName, arity, typeSyntax, diagBag);
					if ((object)forwardedToAssembly != null)
					{
						typeSyntax = typeSyntax2;
						diagName = text;
						break;
					}
					if (flag)
					{
						typeSyntax2 = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax)typeSyntax2).Left;
						text = text.Substring(0, text.LastIndexOf('.'));
						continue;
					}
					break;
				}
			}

			private static AssemblySymbol GetForwardedToAssembly(AssemblySymbol containingAssembly, string fullName, int arity, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax typeSyntax, BindingDiagnosticBag diagBag)
			{
				MetadataTypeName emittedName = MetadataTypeName.FromFullName(fullName, useCLSCompliantNameArityEncoding: true, arity);
				NamedTypeSymbol namedTypeSymbol = null;
				ImmutableArray<AssemblySymbol>.Enumerator enumerator = containingAssembly.Modules[0].GetReferencedAssemblySymbols().GetEnumerator();
				while (enumerator.MoveNext())
				{
					namedTypeSymbol = enumerator.Current.TryLookupForwardedMetadataType(ref emittedName, ignoreCase: true);
					if ((object)namedTypeSymbol != null)
					{
						break;
					}
				}
				if ((object)namedTypeSymbol != null)
				{
					if (diagBag != null && TypeSymbolExtensions.IsErrorType(namedTypeSymbol))
					{
						DiagnosticInfo errorInfo = ((ErrorTypeSymbol)namedTypeSymbol).ErrorInfo;
						if (errorInfo.Code == 31425)
						{
							ReportDiagnostic(diagBag, typeSyntax, ERRID.ERR_TypeFwdCycle2, fullName, namedTypeSymbol.ContainingAssembly);
						}
						else if (errorInfo.Code == 37208)
						{
							ReportDiagnostic(diagBag, typeSyntax, errorInfo);
							return null;
						}
					}
					return namedTypeSymbol.ContainingAssembly;
				}
				return null;
			}

			private static bool IsParameterTypeOfDeclareMethod(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax typeSyntax)
			{
				VisualBasicSyntaxNode parent = typeSyntax.Parent;
				if (parent != null && parent.Kind() == SyntaxKind.SimpleAsClause)
				{
					parent = parent.Parent;
					if (parent.Kind() == SyntaxKind.Parameter)
					{
						parent = parent.Parent;
						if (parent.Kind() == SyntaxKind.ParameterList)
						{
							parent = parent.Parent;
							return parent.Kind() == SyntaxKind.DeclareFunctionStatement || parent.Kind() == SyntaxKind.DeclareSubStatement;
						}
					}
				}
				return false;
			}

			public static NamespaceOrTypeSymbol BindNamespaceOrTypeSyntax(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax typeSyntax, Binder binder, BindingDiagnosticBag diagBag, bool suppressUseSiteError)
			{
				return (NamespaceOrTypeSymbol)BindNamespaceOrTypeSyntax(typeSyntax, binder, diagBag, unwrapAliases: true, suppressUseSiteError);
			}

			public static Symbol BindNamespaceOrTypeOrAliasSyntax(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax typeSyntax, Binder binder, BindingDiagnosticBag diagBag, bool suppressUseSiteError)
			{
				return BindNamespaceOrTypeSyntax(typeSyntax, binder, diagBag, unwrapAliases: false, suppressUseSiteError);
			}

			private static Symbol BindNamespaceOrTypeSyntax(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax typeSyntax, Binder binder, BindingDiagnosticBag diagBag, bool unwrapAliases, bool suppressUseSiteError)
			{
				LookupResult instance = LookupResult.GetInstance();
				try
				{
					bool reportedAnError = false;
					LookupTypeOrNamespaceSyntax(instance, typeSyntax, binder, diagBag, ref reportedAnError, unwrapAliases, suppressUseSiteError, inGetTypeContext: false, resolvingBaseType: false);
					if (!instance.HasSymbol)
					{
						DiagnosticInfo diagnosticInfo = null;
						string baseNamesForDiagnostic = GetBaseNamesForDiagnostic(typeSyntax);
						diagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_UndefinedTypeOrNamespace1, baseNamesForDiagnostic);
						bool reportErrorWhenReferenced = false;
						VisualBasicSyntaxNode parent = typeSyntax.Parent;
						if (parent != null && parent.Kind() == SyntaxKind.SimpleImportsClause)
						{
							if (((Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax)typeSyntax.Parent).Alias != null)
							{
								reportErrorWhenReferenced = true;
							}
							if (!reportedAnError)
							{
								ReportDiagnostic(diagBag, typeSyntax, ErrorFactory.ErrorInfo(ERRID.WRN_UndefinedOrEmptyNamespaceOrClass1, baseNamesForDiagnostic));
								reportedAnError = true;
							}
						}
						if (!reportedAnError)
						{
							ReportDiagnostic(diagBag, typeSyntax, diagnosticInfo);
						}
						return GetErrorSymbol(baseNamesForDiagnostic, diagnosticInfo, reportErrorWhenReferenced);
					}
					if (instance.HasDiagnostic)
					{
						if (!reportedAnError)
						{
							ReportDiagnostic(diagBag, typeSyntax, instance.Diagnostic);
						}
						return ErrorTypeFromLookupResult(instance.SingleSymbol.Name, instance, binder);
					}
					Symbol singleSymbol = instance.SingleSymbol;
					binder.ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagBag, singleSymbol, typeSyntax);
					binder.AddTypesAssemblyAsDependency(singleSymbol as NamedTypeSymbol, diagBag);
					return singleSymbol;
				}
				finally
				{
					instance.Free();
				}
			}

			private static void LookupTypeOrNamespaceSyntax(LookupResult lookupResult, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax typeSyntax, Binder binder, BindingDiagnosticBag diagBag, ref bool reportedAnError, bool unwrapAliases, bool suppressUseSiteError, bool inGetTypeContext, bool resolvingBaseType)
			{
				switch (typeSyntax.Kind())
				{
				case SyntaxKind.IdentifierName:
					LookupBasicName(lookupResult, (Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)typeSyntax, binder, diagBag, ref reportedAnError);
					if (unwrapAliases && lookupResult.IsGood && lookupResult.SingleSymbol.Kind == SymbolKind.Alias)
					{
						lookupResult.ReplaceSymbol(((AliasSymbol)lookupResult.SingleSymbol).Target);
					}
					break;
				case SyntaxKind.GenericName:
					LookupGenericName(lookupResult, (Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax)typeSyntax, binder, diagBag, ref reportedAnError, suppressUseSiteError);
					break;
				case SyntaxKind.QualifiedName:
					LookupDottedName(lookupResult, (Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax)typeSyntax, binder, diagBag, ref reportedAnError, suppressUseSiteError, resolvingBaseType);
					break;
				case SyntaxKind.GlobalName:
					lookupResult.SetFrom(LookupGlobalName((Microsoft.CodeAnalysis.VisualBasic.Syntax.GlobalNameSyntax)typeSyntax, binder));
					break;
				case SyntaxKind.PredefinedType:
					lookupResult.SetFrom(LookupPredefinedTypeName((Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedTypeSyntax)typeSyntax, binder, diagBag, ref reportedAnError, suppressUseSiteError));
					break;
				case SyntaxKind.ArrayType:
					lookupResult.SetFrom(LookupArrayType((Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayTypeSyntax)typeSyntax, binder, diagBag, suppressUseSiteError, inGetTypeContext));
					break;
				case SyntaxKind.NullableType:
					lookupResult.SetFrom(LookupNullableType((Microsoft.CodeAnalysis.VisualBasic.Syntax.NullableTypeSyntax)typeSyntax, binder, diagBag, suppressUseSiteError));
					break;
				case SyntaxKind.TupleType:
					lookupResult.SetFrom(LookupTupleType((Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleTypeSyntax)typeSyntax, binder, diagBag, suppressUseSiteError, inGetTypeContext, resolvingBaseType));
					break;
				default:
					throw ExceptionUtilities.UnexpectedValue(typeSyntax.Kind());
				}
				if (resolvingBaseType && lookupResult.IsGood)
				{
					AnalyzeLookupResultForIllegalBaseTypeReferences(lookupResult, typeSyntax, binder, diagBag, ref reportedAnError);
				}
			}

			private static TypeSymbol LookupTupleType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleTypeSyntax syntax, Binder binder, BindingDiagnosticBag diagnostics, bool suppressUseSiteError, bool inGetTypeContext, bool resolvingBaseType)
			{
				int count = syntax.Elements.Count;
				ArrayBuilder<TypeSymbol> instance = ArrayBuilder<TypeSymbol>.GetInstance(count);
				ArrayBuilder<Location> instance2 = ArrayBuilder<Location>.GetInstance(count);
				ArrayBuilder<string> elementNames = null;
				HashSet<string> uniqueFieldNames = new HashSet<string>(CaseInsensitiveComparison.Comparer);
				bool flag = false;
				int num = count - 1;
				for (int i = 0; i <= num; i++)
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleElementSyntax tupleElementSyntax = syntax.Elements[i];
					TypeSymbol typeSymbol = null;
					string name = null;
					SyntaxToken syntaxToken = default(SyntaxToken);
					if (tupleElementSyntax.Kind() == SyntaxKind.TypedTupleElement)
					{
						Microsoft.CodeAnalysis.VisualBasic.Syntax.TypedTupleElementSyntax typedTupleElementSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.TypedTupleElementSyntax)tupleElementSyntax;
						typeSymbol = binder.BindTypeSyntax(typedTupleElementSyntax.Type, diagnostics, suppressUseSiteError, inGetTypeContext, resolvingBaseType);
					}
					else
					{
						Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedTupleElementSyntax namedTupleElementSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedTupleElementSyntax)tupleElementSyntax;
						syntaxToken = namedTupleElementSyntax.Identifier;
						name = VisualBasicExtensions.GetIdentifierText(syntaxToken);
						typeSymbol = binder.DecodeIdentifierType(syntaxToken, namedTupleElementSyntax.AsClause, null, diagnostics);
					}
					instance.Add(typeSymbol);
					if (VisualBasicExtensions.Kind(syntaxToken) == SyntaxKind.IdentifierToken)
					{
						flag = true;
						CheckTupleMemberName(name, i, syntaxToken, diagnostics, uniqueFieldNames);
						instance2.Add(syntaxToken.GetLocation());
					}
					else
					{
						instance2.Add(tupleElementSyntax.GetLocation());
					}
					CollectTupleFieldMemberName(name, i, count, ref elementNames);
				}
				if (flag)
				{
					if (!(binder.Compilation.GetWellKnownTypeMember(WellKnownMember.System_Runtime_CompilerServices_TupleElementNamesAttribute__ctorTransformNames) is MethodSymbol memberSymbol))
					{
						ReportDiagnostic(diagnostics, syntax, ERRID.ERR_TupleElementNamesAttributeMissing, AttributeDescription.TupleElementNamesAttribute.FullName);
					}
					else
					{
						diagnostics.Add(GetUseSiteInfoForWellKnownTypeMember(memberSymbol, WellKnownMember.System_Runtime_CompilerServices_TupleElementNamesAttribute__ctorTransformNames, embedVBRuntimeUsed: false), syntax);
					}
				}
				ImmutableArray<TypeSymbol> elementTypes = instance.ToImmutableAndFree();
				ImmutableArray<Location> elementLocations = instance2.ToImmutableAndFree();
				if (elementTypes.Length < 2)
				{
					throw ExceptionUtilities.UnexpectedValue(elementTypes.Length);
				}
				return TupleTypeSymbol.Create(syntax.GetLocation(), elementTypes, elementLocations, elementNames?.ToImmutableAndFree() ?? default(ImmutableArray<string>), binder.Compilation, binder.ShouldCheckConstraints, default(ImmutableArray<bool>), syntax, diagnostics);
			}

			private static void AnalyzeLookupResultForIllegalBaseTypeReferences(LookupResult lookupResult, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax typeSyntax, Binder binder, BindingDiagnosticBag diagBag, ref bool reportedAnError)
			{
				NamedTypeSymbol containingType = binder.ContainingType;
				Symbol symbol = lookupResult.SingleSymbol;
				while ((object)symbol != null && symbol.Kind == SymbolKind.NamedType)
				{
					if (containingType.Equals(symbol.OriginalDefinition))
					{
						if ((object)symbol == lookupResult.SingleSymbol)
						{
							ReportDiagnostic(diagBag, typeSyntax, ERRID.ERR_TypeInItsInheritsClause1, containingType);
						}
						else
						{
							ReportDiagnostic(diagBag, typeSyntax, ERRID.ERR_NestedTypeInInheritsClause2, containingType, lookupResult.SingleSymbol);
						}
						lookupResult.Clear();
						reportedAnError = true;
						break;
					}
					symbol = symbol.ContainingSymbol;
				}
			}

			private static ErrorTypeSymbol ErrorTypeFromLookupResult(string name, LookupResult result, Binder binder)
			{
				if (result.Kind == LookupResultKind.Ambiguous && result.HasSingleSymbol && result.Diagnostic is AmbiguousSymbolDiagnostic)
				{
					return GetErrorSymbol(name, result.Diagnostic, ((AmbiguousSymbolDiagnostic)result.Diagnostic).AmbiguousSymbols, result.Kind);
				}
				return GetErrorSymbol(name, result.Diagnostic, result.Symbols.ToImmutable(), result.Kind);
			}

			private static TypeSymbol CheckSymbolIsType(NamespaceOrTypeSymbol sym, VisualBasicSyntaxNode syntax, Binder binder, BindingDiagnosticBag diagBag)
			{
				if (sym.IsNamespace)
				{
					BadSymbolDiagnostic badSymbolDiagnostic = new BadSymbolDiagnostic(sym, ERRID.ERR_UnrecognizedType);
					ReportDiagnostic(diagBag, syntax, badSymbolDiagnostic);
					return GetErrorSymbol(sym.Name, badSymbolDiagnostic, ImmutableArray.Create((Symbol)sym), LookupResultKind.NotATypeOrNamespace);
				}
				return (TypeSymbol)sym;
			}

			private static SingleLookupResult LookupPredefinedTypeName(Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedTypeSyntax predefinedTypeSyntax, Binder binder, BindingDiagnosticBag diagBag, ref bool reportedAnError, bool suppressUseSiteError)
			{
				return LookupPredefinedTypeName(predefinedTypeSyntax, VisualBasicExtensions.Kind(predefinedTypeSyntax.Keyword), binder, diagBag, ref reportedAnError, suppressUseSiteError);
			}

			public static SingleLookupResult LookupPredefinedTypeName(VisualBasicSyntaxNode node, SyntaxKind predefinedType, Binder binder, BindingDiagnosticBag diagBag, ref bool reportedAnError, bool suppressUseSiteError)
			{
				return SingleLookupResult.Good(binder.GetSpecialType(predefinedType switch
				{
					SyntaxKind.ObjectKeyword => SpecialType.System_Object, 
					SyntaxKind.BooleanKeyword => SpecialType.System_Boolean, 
					SyntaxKind.DateKeyword => SpecialType.System_DateTime, 
					SyntaxKind.CharKeyword => SpecialType.System_Char, 
					SyntaxKind.StringKeyword => SpecialType.System_String, 
					SyntaxKind.DecimalKeyword => SpecialType.System_Decimal, 
					SyntaxKind.ByteKeyword => SpecialType.System_Byte, 
					SyntaxKind.SByteKeyword => SpecialType.System_SByte, 
					SyntaxKind.UShortKeyword => SpecialType.System_UInt16, 
					SyntaxKind.ShortKeyword => SpecialType.System_Int16, 
					SyntaxKind.UIntegerKeyword => SpecialType.System_UInt32, 
					SyntaxKind.IntegerKeyword => SpecialType.System_Int32, 
					SyntaxKind.ULongKeyword => SpecialType.System_UInt64, 
					SyntaxKind.LongKeyword => SpecialType.System_Int64, 
					SyntaxKind.SingleKeyword => SpecialType.System_Single, 
					SyntaxKind.DoubleKeyword => SpecialType.System_Double, 
					_ => throw ExceptionUtilities.UnexpectedValue(predefinedType), 
				}, node, diagBag, ref reportedAnError, suppressUseSiteError));
			}

			private static SingleLookupResult LookupArrayType(Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayTypeSyntax arrayTypeSyntax, Binder binder, BindingDiagnosticBag diagBag, bool suppressUseSiteError, bool inGetTypeContext)
			{
				TypeSymbol elementType = binder.BindTypeSyntax(arrayTypeSyntax.ElementType, diagBag, suppressUseSiteError, inGetTypeContext);
				return SingleLookupResult.Good(binder.ApplyArrayRankSpecifiersToType(elementType, arrayTypeSyntax.RankSpecifiers, diagBag));
			}

			private static SingleLookupResult LookupNullableType(Microsoft.CodeAnalysis.VisualBasic.Syntax.NullableTypeSyntax nullableTypeSyntax, Binder binder, BindingDiagnosticBag diagBag, bool suppressUseSiteError)
			{
				TypeSymbol typeArgument = binder.BindTypeSyntax(nullableTypeSyntax.ElementType, diagBag, suppressUseSiteError);
				return SingleLookupResult.Good(binder.CreateNullableOf(typeArgument, nullableTypeSyntax, nullableTypeSyntax.ElementType, diagBag));
			}

			private static void LookupBasicName(LookupResult lookupResult, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax basicNameSyntax, Binder binder, BindingDiagnosticBag diagBag, ref bool reportedAnError)
			{
				SyntaxToken identifier = basicNameSyntax.Identifier;
				string valueText = identifier.ValueText;
				DisallowTypeCharacter(identifier, diagBag);
				if (string.IsNullOrEmpty(valueText))
				{
					reportedAnError = true;
					return;
				}
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = binder.GetNewCompoundUseSiteInfo(diagBag);
				if (SyntaxFacts.IsAttributeName(basicNameSyntax))
				{
					binder.LookupAttributeType(lookupResult, null, valueText, LookupOptions.AttributeTypeOnly, ref useSiteInfo);
				}
				else
				{
					binder.Lookup(lookupResult, valueText, 0, LookupOptions.NamespacesOrTypesOnly, ref useSiteInfo);
				}
				((BindingDiagnosticBag<AssemblySymbol>)diagBag).Add((SyntaxNode)basicNameSyntax, useSiteInfo);
			}

			private static void LookupGenericName(LookupResult lookupResult, Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax genericNameSyntax, Binder binder, BindingDiagnosticBag diagBag, ref bool reportedAnError, bool suppressUseSiteError)
			{
				SyntaxToken identifier = genericNameSyntax.Identifier;
				string valueText = identifier.ValueText;
				DisallowTypeCharacter(identifier, diagBag);
				Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax typeArgumentList = genericNameSyntax.TypeArgumentList;
				int count = typeArgumentList.Arguments.Count;
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = binder.GetNewCompoundUseSiteInfo(diagBag);
				binder.Lookup(lookupResult, valueText, count, LookupOptions.NamespacesOrTypesOnly, ref useSiteInfo);
				((BindingDiagnosticBag<AssemblySymbol>)diagBag).Add((SyntaxNode)genericNameSyntax, useSiteInfo);
				ImmutableArray<TypeSymbol> typeArguments = BindTypeArguments(typeArgumentList, binder, diagBag, suppressUseSiteError);
				if (lookupResult.Kind == LookupResultKind.Empty)
				{
					return;
				}
				if (!(lookupResult.SingleSymbol is NamedTypeSymbol namedTypeSymbol) || !namedTypeSymbol.IsGenericType || !namedTypeSymbol.CanConstruct)
				{
					if (lookupResult.IsGood)
					{
						lookupResult.SetFrom(SingleLookupResult.WrongArity(lookupResult.SingleSymbol, new BadSymbolDiagnostic(lookupResult.SingleSymbol, ERRID.ERR_TypeOrMemberNotGeneric1, lookupResult.SingleSymbol)));
					}
					return;
				}
				if (!suppressUseSiteError && ReportUseSite(diagBag, genericNameSyntax, namedTypeSymbol))
				{
					reportedAnError = true;
				}
				NamedTypeSymbol newSym = binder.ConstructAndValidateConstraints(namedTypeSymbol, typeArguments, genericNameSyntax, typeArgumentList.Arguments, diagBag);
				lookupResult.ReplaceSymbol(newSym);
			}

			private static void LookupDottedName(LookupResult lookupResult, Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax dottedNameSyntax, Binder binder, BindingDiagnosticBag diagBag, ref bool reportedAnError, bool suppressUseSiteError, bool resolvingBaseType)
			{
				if (dottedNameSyntax.Right is Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax)
				{
					LookupGenericDottedName(lookupResult, dottedNameSyntax, binder, diagBag, ref reportedAnError, suppressUseSiteError, resolvingBaseType);
					return;
				}
				Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax right = dottedNameSyntax.Right;
				SyntaxToken identifier = right.Identifier;
				Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax left = dottedNameSyntax.Left;
				DisallowTypeCharacter(identifier, diagBag);
				LookupTypeOrNamespaceSyntax(lookupResult, left, binder, diagBag, ref reportedAnError, unwrapAliases: true, suppressUseSiteError, inGetTypeContext: false, resolvingBaseType);
				if (!lookupResult.HasSymbol)
				{
					return;
				}
				if (lookupResult.HasDiagnostic && !reportedAnError)
				{
					ReportDiagnostic(diagBag, left, lookupResult.Diagnostic);
					reportedAnError = lookupResult.Diagnostic.Severity == DiagnosticSeverity.Error;
				}
				NamespaceOrTypeSymbol namespaceOrTypeSymbol = (NamespaceOrTypeSymbol)lookupResult.SingleSymbol;
				binder.ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagBag, namespaceOrTypeSymbol, left);
				binder.AddTypesAssemblyAsDependency(namespaceOrTypeSymbol, diagBag);
				lookupResult.Clear();
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = binder.GetNewCompoundUseSiteInfo(diagBag);
				if (SyntaxFacts.IsAttributeName(right))
				{
					binder.LookupAttributeType(lookupResult, namespaceOrTypeSymbol, identifier.ValueText, LookupOptions.AttributeTypeOnly, ref useSiteInfo);
				}
				else
				{
					bool flag = namespaceOrTypeSymbol.Kind == SymbolKind.NamedType && ((NamedTypeSymbol)namespaceOrTypeSymbol).IsUnboundGenericType;
					if (flag)
					{
						namespaceOrTypeSymbol = ((NamedTypeSymbol)namespaceOrTypeSymbol).OriginalDefinition;
					}
					binder.LookupMember(lookupResult, namespaceOrTypeSymbol, identifier.ValueText, 0, LookupOptions.NamespacesOrTypesOnly, ref useSiteInfo);
					if (lookupResult.HasSingleSymbol && lookupResult.SingleSymbol.Kind == SymbolKind.NamedType)
					{
						NamedTypeSymbol namedTypeSymbol = (NamedTypeSymbol)lookupResult.SingleSymbol;
						if (flag && namedTypeSymbol.IsGenericType)
						{
							lookupResult.ReplaceSymbol(NamedTypeSymbolExtensions.AsUnboundGenericType(namedTypeSymbol));
						}
						else if (namedTypeSymbol.Arity > 0 && !namedTypeSymbol.IsDefinition && (object)namedTypeSymbol == namedTypeSymbol.ConstructedFrom)
						{
							lookupResult.ReplaceSymbol(namedTypeSymbol.Construct(StaticCast<TypeSymbol>.From(namedTypeSymbol.OriginalDefinition.TypeParameters)));
						}
					}
				}
				((BindingDiagnosticBag<AssemblySymbol>)diagBag).Add((SyntaxNode)left, useSiteInfo);
			}

			private static void LookupGenericDottedName(LookupResult lookupResult, Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax genDottedNameSyntax, Binder binder, BindingDiagnosticBag diagBag, ref bool reportedAnError, bool suppressUseSiteError, bool resolvingBaseType)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax obj = (Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax)genDottedNameSyntax.Right;
				SyntaxToken identifier = obj.Identifier;
				Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax left = genDottedNameSyntax.Left;
				DisallowTypeCharacter(identifier, diagBag);
				Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax typeArgumentList = obj.TypeArgumentList;
				int count = typeArgumentList.Arguments.Count;
				LookupTypeOrNamespaceSyntax(lookupResult, left, binder, diagBag, ref reportedAnError, unwrapAliases: true, suppressUseSiteError, inGetTypeContext: false, resolvingBaseType);
				ImmutableArray<TypeSymbol> typeArguments = BindTypeArguments(typeArgumentList, binder, diagBag, suppressUseSiteError);
				if (!lookupResult.HasSymbol)
				{
					return;
				}
				if (lookupResult.HasDiagnostic && !reportedAnError)
				{
					ReportDiagnostic(diagBag, left, lookupResult.Diagnostic);
					reportedAnError = lookupResult.Diagnostic.Severity == DiagnosticSeverity.Error;
				}
				NamespaceOrTypeSymbol namespaceOrTypeSymbol = (NamespaceOrTypeSymbol)lookupResult.SingleSymbol;
				bool flag = namespaceOrTypeSymbol.Kind == SymbolKind.NamedType && ((NamedTypeSymbol)namespaceOrTypeSymbol).IsUnboundGenericType;
				if (flag)
				{
					namespaceOrTypeSymbol = ((NamedTypeSymbol)namespaceOrTypeSymbol).OriginalDefinition;
				}
				binder.ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagBag, namespaceOrTypeSymbol, left);
				binder.AddTypesAssemblyAsDependency(namespaceOrTypeSymbol, diagBag);
				lookupResult.Clear();
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = binder.GetNewCompoundUseSiteInfo(diagBag);
				binder.LookupMember(lookupResult, namespaceOrTypeSymbol, identifier.ValueText, count, LookupOptions.NamespacesOrTypesOnly, ref useSiteInfo);
				((BindingDiagnosticBag<AssemblySymbol>)diagBag).Add((SyntaxNode)left, useSiteInfo);
				if (lookupResult.Kind != 0 && lookupResult.SingleSymbol is NamedTypeSymbol namedTypeSymbol)
				{
					if (flag && namedTypeSymbol.IsGenericType)
					{
						lookupResult.ReplaceSymbol(NamedTypeSymbolExtensions.AsUnboundGenericType(namedTypeSymbol));
						return;
					}
					NamedTypeSymbol newSym = binder.ConstructAndValidateConstraints(namedTypeSymbol, typeArguments, genDottedNameSyntax, typeArgumentList.Arguments, diagBag);
					lookupResult.ReplaceSymbol(newSym);
				}
			}

			private static SingleLookupResult LookupGlobalName(Microsoft.CodeAnalysis.VisualBasic.Syntax.GlobalNameSyntax syntax, Binder binder)
			{
				return SingleLookupResult.Good(binder.Compilation.GlobalNamespace);
			}

			private static ImmutableArray<TypeSymbol> BindTypeArguments(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax typeArgumentsSyntax, Binder binder, BindingDiagnosticBag diagBag, bool suppressUseSiteError)
			{
				int count = typeArgumentsSyntax.Arguments.Count;
				TypeSymbol[] array = new TypeSymbol[count - 1 + 1];
				int num = count - 1;
				for (int i = 0; i <= num; i++)
				{
					array[i] = binder.BindTypeSyntax(typeArgumentsSyntax.Arguments[i], diagBag, suppressUseSiteError);
				}
				return array.AsImmutableOrNull();
			}

			private static string GetBaseNamesForDiagnostic(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax typeSyntax)
			{
				switch (typeSyntax.Kind())
				{
				case SyntaxKind.IdentifierName:
					return ((Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)typeSyntax).Identifier.ValueText;
				case SyntaxKind.TupleType:
					return typeSyntax.ToString();
				case SyntaxKind.GenericName:
					return ((Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax)typeSyntax).Identifier.ValueText;
				case SyntaxKind.QualifiedName:
					return GetBaseNamesForDiagnostic(((Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax)typeSyntax).Left) + "." + ((Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax)typeSyntax).Right.Identifier.ValueText;
				case SyntaxKind.ArrayType:
					return GetBaseNamesForDiagnostic(((Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayTypeSyntax)typeSyntax).ElementType);
				case SyntaxKind.NullableType:
					return GetBaseNamesForDiagnostic(((Microsoft.CodeAnalysis.VisualBasic.Syntax.NullableTypeSyntax)typeSyntax).ElementType);
				case SyntaxKind.PredefinedType:
				case SyntaxKind.GlobalName:
					return typeSyntax.ToString();
				default:
					throw ExceptionUtilities.UnexpectedValue(typeSyntax.Kind());
				}
			}
		}

		[Flags]
		public enum ModifiedIdentifierTypeDecoderContext
		{
			None = 0,
			LambdaType = 2,
			LocalType = 4,
			FieldType = 8,
			ParameterType = 0x10,
			QueryRangeVariableType = 0x20,
			LocalOrFieldType = 0xC,
			LambdaParameterType = 0x12,
			StaticLocalType = 0x40
		}

		internal delegate SourceParameterFlags CheckParameterModifierDelegate(Symbol container, SyntaxToken token, SourceParameterFlags flag, BindingDiagnosticBag diagnostics);

		public enum ConstantContext
		{
			Default,
			ParameterDefaultValue
		}

		private struct XmlName
		{
			public readonly string LocalName;

			public readonly string XmlNamespace;

			public XmlName(string localName, string @namespace)
			{
				this = default(XmlName);
				LocalName = localName;
				XmlNamespace = @namespace;
			}
		}

		private sealed class XmlNameComparer : IEqualityComparer<XmlName>
		{
			public static readonly XmlNameComparer Instance = new XmlNameComparer();

			private bool IEqualityComparer_Equals(XmlName x, XmlName y)
			{
				if (string.Equals(x.LocalName, y.LocalName, StringComparison.Ordinal))
				{
					return string.Equals(x.XmlNamespace, y.XmlNamespace, StringComparison.Ordinal);
				}
				return false;
			}

			bool IEqualityComparer<XmlName>.Equals(XmlName x, XmlName y)
			{
				//ILSpy generated this explicit interface implementation from .override directive in IEqualityComparer_Equals
				return this.IEqualityComparer_Equals(x, y);
			}

			private int IEqualityComparer_GetHashCode(XmlName obj)
			{
				int num = obj.LocalName.GetHashCode();
				if (obj.XmlNamespace != null)
				{
					num = Hash.Combine(num, obj.XmlNamespace.GetHashCode());
				}
				return num;
			}

			int IEqualityComparer<XmlName>.GetHashCode(XmlName obj)
			{
				//ILSpy generated this explicit interface implementation from .override directive in IEqualityComparer_GetHashCode
				return this.IEqualityComparer_GetHashCode(obj);
			}
		}

		private sealed class XmlElementRootInfo
		{
			private readonly Binder _binder;

			private readonly Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax _syntax;

			private readonly ArrayBuilder<KeyValuePair<string, string>> _importedNamespaces;

			private BoundRValuePlaceholder _xmlnsAttributesPlaceholder;

			private BoundMethodOrPropertyGroup _removeNamespacesGroup;

			public Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax Syntax => _syntax;

			public ArrayBuilder<KeyValuePair<string, string>> ImportedNamespaces => _importedNamespaces;

			public BoundRValuePlaceholder XmlnsAttributesPlaceholder => _xmlnsAttributesPlaceholder;

			public XmlElementRootInfo(Binder binder, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax syntax, ArrayBuilder<KeyValuePair<string, string>> importedNamespaces)
			{
				_binder = binder;
				_syntax = syntax;
				_importedNamespaces = importedNamespaces;
			}

			public BoundExpression BindRemoveNamespaceAttributesInvocation(BoundExpression expr, BoundRValuePlaceholder prefixes, BoundRValuePlaceholder namespaces, BindingDiagnosticBag diagnostics)
			{
				return _binder.BindRemoveNamespaceAttributesInvocation(_syntax, expr, prefixes, namespaces, out _xmlnsAttributesPlaceholder, out _removeNamespacesGroup, diagnostics);
			}
		}

		private class OptionStrictOffBinder : Binder
		{
			public override OptionStrict OptionStrict => OptionStrict.Off;

			public OptionStrictOffBinder(Binder containingBinder)
				: base(containingBinder)
			{
			}
		}

		private static readonly ImmutableArray<BoundExpression> s_noArguments = ImmutableArray<BoundExpression>.Empty;

		protected readonly Binder m_containingBinder;

		private readonly SyntaxTree _syntaxTree;

		private readonly VisualBasicCompilation _compilation;

		private readonly SourceModuleSymbol _sourceModule;

		private readonly bool _isEarlyAttributeBinder;

		private readonly bool _ignoreBaseClassesInLookup;

		private readonly BasesBeingResolved _basesBeingResolved;

		private static readonly CheckParameterModifierDelegate s_checkDelegateParameterModifierCallback = CheckDelegateParameterModifier;

		public const int ArrayRankLimit = 32;

		private static readonly Func<Symbol, bool> s_isFunctionWithoutArguments = delegate(Symbol sym)
		{
			if (sym.Kind == SymbolKind.Method)
			{
				MethodSymbol methodSymbol = (MethodSymbol)sym;
				return !methodSymbol.IsSub && !methodSymbol.IsGenericMethod && MethodSymbolExtensions.CanBeCalledWithNoParameters(methodSymbol);
			}
			return false;
		};

		private static readonly Func<Symbol, bool> s_isReadablePropertyWithoutArguments = delegate(Symbol sym)
		{
			if (sym.Kind == SymbolKind.Property)
			{
				PropertySymbol propertySymbol = (PropertySymbol)sym;
				return propertySymbol.IsReadable && !propertySymbol.GetMostDerivedGetMethod().IsGenericMethod && PropertySymbolExtensions.GetCanBeCalledWithNoParameters(propertySymbol);
			}
			return false;
		};

		private static readonly SyntaxKind[] s_friendKeyword = new SyntaxKind[1] { SyntaxKind.FriendKeyword };

		private static readonly CheckParameterModifierDelegate s_checkOperatorParameterModifierCallback = CheckOperatorParameterModifier;

		private static readonly CheckParameterModifierDelegate s_checkPropertyParameterModifierCallback = CheckPropertyParameterModifier;

		private static readonly SyntaxKind[] s_notInheritableKeyword = new SyntaxKind[1] { SyntaxKind.NotInheritableKeyword };

		public Binder ContainingBinder => m_containingBinder;

		internal bool IgnoresAccessibility => (BinderSpecificLookupOptions(LookupOptions.Default) & LookupOptions.IgnoreAccessibility) == LookupOptions.IgnoreAccessibility;

		public virtual Symbol ContainingMember => m_containingBinder.ContainingMember;

		public virtual ImmutableArray<Symbol> AdditionalContainingMembers => m_containingBinder.AdditionalContainingMembers;

		internal ModuleSymbol ContainingModule
		{
			get
			{
				Symbol containingMember = ContainingMember;
				return (containingMember as ModuleSymbol) ?? containingMember?.ContainingModule ?? Compilation.SourceModule;
			}
		}

		public virtual bool IsInQuery => m_containingBinder.IsInQuery;

		internal bool IsInLambda => ContainingMember.IsLambdaMethod;

		public virtual ConsList<LocalSymbol> ImplicitlyTypedLocalsBeingBound => m_containingBinder.ImplicitlyTypedLocalsBeingBound;

		public virtual NamedTypeSymbol ContainingType => m_containingBinder.ContainingType;

		internal bool BindingTopLevelScriptCode
		{
			get
			{
				Symbol containingMember = ContainingMember;
				return containingMember.Kind switch
				{
					SymbolKind.Method => ((MethodSymbol)containingMember).IsScriptConstructor, 
					SymbolKind.NamedType => ((NamedTypeSymbol)containingMember).IsScriptClass, 
					_ => false, 
				};
			}
		}

		public virtual NamespaceOrTypeSymbol ContainingNamespaceOrType => m_containingBinder.ContainingNamespaceOrType;

		public SourceModuleSymbol SourceModule => _sourceModule;

		public VisualBasicCompilation Compilation => _compilation;

		public SyntaxTree SyntaxTree => _syntaxTree;

		internal virtual ConstantFieldsInProgress ConstantFieldsInProgress => m_containingBinder.ConstantFieldsInProgress;

		internal virtual SymbolsInProgress<ParameterSymbol> DefaultParametersInProgress => m_containingBinder.DefaultParametersInProgress;

		public bool IgnoreBaseClassesInLookup => _ignoreBaseClassesInLookup;

		public virtual OptionStrict OptionStrict => m_containingBinder.OptionStrict;

		public virtual bool OptionInfer => m_containingBinder.OptionInfer;

		public virtual bool OptionExplicit => m_containingBinder.OptionExplicit;

		public virtual bool OptionCompareText => m_containingBinder.OptionCompareText;

		public virtual bool CheckOverflow => m_containingBinder.CheckOverflow;

		public virtual bool AllImplicitVariableDeclarationsAreHandled => m_containingBinder.AllImplicitVariableDeclarationsAreHandled;

		public virtual bool ImplicitVariableDeclarationAllowed => m_containingBinder.ImplicitVariableDeclarationAllowed;

		public virtual ImmutableArray<LocalSymbol> ImplicitlyDeclaredVariables => m_containingBinder.ImplicitlyDeclaredVariables;

		internal virtual bool SuppressObsoleteDiagnostics => m_containingBinder.SuppressObsoleteDiagnostics;

		public virtual BindingLocation BindingLocation => m_containingBinder.BindingLocation;

		public bool IsEarlyAttributeBinder => _isEarlyAttributeBinder;

		internal bool ShouldCheckConstraints
		{
			get
			{
				BindingLocation bindingLocation = BindingLocation;
				if ((uint)(bindingLocation - 1) <= 4u)
				{
					return false;
				}
				return true;
			}
		}

		internal virtual bool HasImportedXmlNamespaces => m_containingBinder.HasImportedXmlNamespaces;

		public virtual bool IsSemanticModelBinder => m_containingBinder.IsSemanticModelBinder;

		public virtual QuickAttributeChecker QuickAttributeChecker => m_containingBinder.QuickAttributeChecker;

		internal virtual bool IsDefaultInstancePropertyAllowed => m_containingBinder.IsDefaultInstancePropertyAllowed;

		internal virtual bool SuppressCallerInfo => m_containingBinder.SuppressCallerInfo;

		protected virtual bool IsInsideChainedConstructorCallArguments => ContainingBinder.IsInsideChainedConstructorCallArguments;

		protected Binder(Binder containingBinder)
		{
			m_containingBinder = containingBinder;
			if (containingBinder != null)
			{
				_syntaxTree = containingBinder.SyntaxTree;
				_compilation = containingBinder.Compilation;
				_sourceModule = containingBinder.SourceModule;
				_isEarlyAttributeBinder = containingBinder.IsEarlyAttributeBinder;
				_ignoreBaseClassesInLookup = containingBinder.IgnoreBaseClassesInLookup;
				_basesBeingResolved = containingBinder.BasesBeingResolved();
			}
		}

		protected Binder(Binder containingBinder, SyntaxTree syntaxTree)
			: this(containingBinder)
		{
			_syntaxTree = syntaxTree;
		}

		protected Binder(Binder containingBinder, SourceModuleSymbol sourceModule, VisualBasicCompilation compilation)
			: this(containingBinder)
		{
			_sourceModule = sourceModule;
			_compilation = compilation;
		}

		protected Binder(Binder containingBinder, bool? isEarlyAttributeBinder = null, bool? ignoreBaseClassesInLookup = null)
			: this(containingBinder)
		{
			if (isEarlyAttributeBinder.HasValue)
			{
				_isEarlyAttributeBinder = isEarlyAttributeBinder.Value;
			}
			if (ignoreBaseClassesInLookup.HasValue)
			{
				_ignoreBaseClassesInLookup = ignoreBaseClassesInLookup.Value;
			}
		}

		protected Binder(Binder containingBinder, BasesBeingResolved basesBeingResolved)
			: this(containingBinder)
		{
			_basesBeingResolved = basesBeingResolved;
		}

		internal virtual LookupOptions BinderSpecificLookupOptions(LookupOptions options)
		{
			return m_containingBinder.BinderSpecificLookupOptions(options);
		}

		public virtual void Lookup(LookupResult lookupResult, string name, int arity, LookupOptions options, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			Binder binder = this;
			options = BinderSpecificLookupOptions(options);
			LookupResult instance = LookupResult.GetInstance();
			do
			{
				instance.Clear();
				binder.LookupInSingleBinder(instance, name, arity, options, this, ref useSiteInfo);
				lookupResult.MergePrioritized(instance);
				if (lookupResult.StopFurtherLookup)
				{
					instance.Free();
					return;
				}
				if (instance.IsWrongArity && binder is ImportAliasesBinder)
				{
					if (binder.m_containingBinder is ImportedTypesAndNamespacesMembersBinder)
					{
						binder = binder.m_containingBinder.m_containingBinder;
					}
				}
				else if ((options & LookupOptions.IgnoreExtensionMethods) == 0 && binder is NamedTypeBinder)
				{
					options |= LookupOptions.IgnoreExtensionMethods;
				}
				binder = binder.m_containingBinder;
			}
			while (binder != null);
			instance.Free();
		}

		internal virtual void LookupInSingleBinder(LookupResult lookupResult, string name, int arity, LookupOptions options, Binder originalBinder, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			lookupResult.Clear();
		}

		protected virtual void CollectProbableExtensionMethodsInSingleBinder(string name, ArrayBuilder<MethodSymbol> methods, Binder originalBinder)
		{
		}

		protected virtual void AddExtensionMethodLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder)
		{
		}

		internal virtual LabelSymbol LookupLabelByNameToken(SyntaxToken labelName)
		{
			return ContainingBinder.LookupLabelByNameToken(labelName);
		}

		public virtual void AddLookupSymbolsInfo(LookupSymbolsInfo nameSet, LookupOptions options)
		{
			Binder binder = this;
			do
			{
				binder.AddLookupSymbolsInfoInSingleBinder(nameSet, options, this);
				if ((options & LookupOptions.IgnoreExtensionMethods) == 0 && binder is NamedTypeBinder)
				{
					options |= LookupOptions.IgnoreExtensionMethods;
				}
				binder = binder.m_containingBinder;
			}
			while (binder != null);
		}

		internal virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder)
		{
		}

		public virtual AccessCheckResult CheckAccessibility(Symbol sym, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, TypeSymbol accessThroughType = null, BasesBeingResolved basesBeingResolved = default(BasesBeingResolved))
		{
			return m_containingBinder.CheckAccessibility(sym, ref useSiteInfo, accessThroughType, basesBeingResolved);
		}

		public bool IsAccessible(Symbol sym, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, TypeSymbol accessThroughType = null, BasesBeingResolved basesBeingResolved = default(BasesBeingResolved))
		{
			return CheckAccessibility(sym, ref useSiteInfo, accessThroughType, basesBeingResolved) == AccessCheckResult.Accessible;
		}

		public virtual Binder GetBinder(SyntaxNode node)
		{
			return m_containingBinder.GetBinder(node);
		}

		public virtual Binder GetBinder(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> stmtList)
		{
			return m_containingBinder.GetBinder(stmtList);
		}

		public virtual bool IsUnboundTypeAllowed(Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax syntax)
		{
			return m_containingBinder.IsUnboundTypeAllowed(syntax);
		}

		public NamedTypeSymbol GetSpecialType(SpecialType typeId, SyntaxNodeOrToken node, BindingDiagnosticBag diagBag)
		{
			bool reportedAnError = false;
			return GetSpecialType(Compilation, typeId, node, diagBag, ref reportedAnError, suppressUseSiteError: false);
		}

		public static NamedTypeSymbol GetSpecialType(VisualBasicCompilation compilation, SpecialType typeId, SyntaxNodeOrToken node, BindingDiagnosticBag diagBag)
		{
			bool reportedAnError = false;
			return GetSpecialType(compilation, typeId, node, diagBag, ref reportedAnError, suppressUseSiteError: false);
		}

		public NamedTypeSymbol GetSpecialType(SpecialType typeId, SyntaxNodeOrToken node, BindingDiagnosticBag diagBag, ref bool reportedAnError, bool suppressUseSiteError)
		{
			return GetSpecialType(Compilation, typeId, node, diagBag, ref reportedAnError, suppressUseSiteError);
		}

		public static NamedTypeSymbol GetSpecialType(VisualBasicCompilation compilation, SpecialType typeId, SyntaxNodeOrToken node, BindingDiagnosticBag diagBag, ref bool reportedAnError, bool suppressUseSiteError)
		{
			NamedTypeSymbol specialType = compilation.GetSpecialType(typeId);
			if (diagBag != null)
			{
				UseSiteInfo<AssemblySymbol> useSiteInfoForSpecialType = GetUseSiteInfoForSpecialType(specialType, suppressUseSiteError);
				if (ReportUseSite(diagBag, node, useSiteInfoForSpecialType))
				{
					reportedAnError = true;
				}
			}
			return specialType;
		}

		internal static UseSiteInfo<AssemblySymbol> GetUseSiteInfoForSpecialType(TypeSymbol type, bool suppressUseSiteInfo = false)
		{
			UseSiteInfo<AssemblySymbol> result = default(UseSiteInfo<AssemblySymbol>);
			if (type.TypeKind == TypeKind.Error && type is MissingMetadataTypeSymbol.TopLevel)
			{
				MissingMetadataTypeSymbol.TopLevel topLevel = (MissingMetadataTypeSymbol.TopLevel)type;
				result = new UseSiteInfo<AssemblySymbol>(ErrorFactory.ErrorInfo(ERRID.ERR_UndefinedType1, MetadataHelpers.BuildQualifiedName(topLevel.NamespaceName, topLevel.Name)));
			}
			else if (!suppressUseSiteInfo)
			{
				return type.GetUseSiteInfo();
			}
			return result;
		}

		internal NamedTypeSymbol GetWellKnownType(WellKnownType type, SyntaxNode syntax, BindingDiagnosticBag diagBag)
		{
			return GetWellKnownType(Compilation, type, syntax, diagBag);
		}

		internal static NamedTypeSymbol GetWellKnownType(VisualBasicCompilation compilation, WellKnownType type, SyntaxNode syntax, BindingDiagnosticBag diagBag)
		{
			NamedTypeSymbol wellKnownType = compilation.GetWellKnownType(type);
			ReportUseSite(useSiteInfo: GetUseSiteInfoForWellKnownType(wellKnownType), diagBag: diagBag, syntax: syntax);
			return wellKnownType;
		}

		internal static UseSiteInfo<AssemblySymbol> GetUseSiteInfoForWellKnownType(TypeSymbol type)
		{
			return type.GetUseSiteInfo();
		}

		private NamedTypeSymbol GetInternalXmlHelperType(VisualBasicSyntaxNode syntax, BindingDiagnosticBag diagBag)
		{
			NamedTypeSymbol internalXmlHelperType = GetInternalXmlHelperType();
			ReportUseSite(useSiteInfo: GetUseSiteInfoForWellKnownType(internalXmlHelperType), diagBag: diagBag, syntax: syntax);
			return internalXmlHelperType;
		}

		private NamedTypeSymbol GetInternalXmlHelperType()
		{
			string text = "My.InternalXmlHelper";
			string rootNamespace = Compilation.Options.RootNamespace;
			if (!string.IsNullOrEmpty(rootNamespace))
			{
				text = $"{rootNamespace}.{text}";
			}
			MetadataTypeName emittedName = MetadataTypeName.FromFullName(text, useCLSCompliantNameArityEncoding: true);
			return ContainingModule.LookupTopLevelMetadataType(ref emittedName);
		}

		private PropertySymbol GetInternalXmlHelperValueExtensionProperty()
		{
			ImmutableArray<Symbol>.Enumerator enumerator = GetInternalXmlHelperType().GetMembers("Value").GetEnumerator();
			while (enumerator.MoveNext())
			{
				Symbol current = enumerator.Current;
				if (!current.IsShared || current.Kind != SymbolKind.Property)
				{
					continue;
				}
				PropertySymbol propertySymbol = (PropertySymbol)current;
				if (propertySymbol.Type.SpecialType != SpecialType.System_String || propertySymbol.RefCustomModifiers.Length > 0 || propertySymbol.TypeCustomModifiers.Length > 0 || propertySymbol.ParameterCount != 1)
				{
					continue;
				}
				ParameterSymbol parameterSymbol = propertySymbol.Parameters[0];
				if (parameterSymbol.CustomModifiers.Length <= 0 && parameterSymbol.RefCustomModifiers.Length <= 0)
				{
					TypeSymbol type = parameterSymbol.Type;
					if (type.OriginalDefinition.SpecialType == SpecialType.System_Collections_Generic_IEnumerable_T && TypeSymbol.Equals(((NamedTypeSymbol)type).TypeArgumentsNoUseSiteDiagnostics[0], Compilation.GetWellKnownType(WellKnownType.System_Xml_Linq_XElement), TypeCompareKind.ConsiderEverything))
					{
						return propertySymbol;
					}
				}
			}
			return null;
		}

		internal Symbol GetSpecialTypeMember(SpecialMember member, SyntaxNode syntax, BindingDiagnosticBag diagnostics)
		{
			return GetSpecialTypeMember(ContainingMember.ContainingAssembly, member, syntax, diagnostics);
		}

		internal static Symbol GetSpecialTypeMember(AssemblySymbol assembly, SpecialMember member, SyntaxNode syntax, BindingDiagnosticBag diagnostics)
		{
			UseSiteInfo<AssemblySymbol> useSiteInfo = default(UseSiteInfo<AssemblySymbol>);
			Symbol specialTypeMember = GetSpecialTypeMember(assembly, member, out useSiteInfo);
			ReportUseSite(diagnostics, syntax, useSiteInfo);
			return specialTypeMember;
		}

		internal static Symbol GetSpecialTypeMember(AssemblySymbol assembly, SpecialMember member, out UseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			Symbol specialTypeMember = assembly.GetSpecialTypeMember(member);
			if ((object)specialTypeMember == null)
			{
				MemberDescriptor descriptor = SpecialMembers.GetDescriptor(member);
				useSiteInfo = new UseSiteInfo<AssemblySymbol>(ErrorFactory.ErrorInfo(ERRID.ERR_MissingRuntimeHelper, descriptor.DeclaringTypeMetadataName + "." + descriptor.Name));
			}
			else
			{
				useSiteInfo = GetUseSiteInfoForMemberAndContainingType(specialTypeMember);
			}
			return specialTypeMember;
		}

		internal static UseSiteInfo<AssemblySymbol> GetUseSiteInfoForMemberAndContainingType(Symbol member)
		{
			UseSiteInfo<AssemblySymbol> result = member.GetUseSiteInfo();
			if (result.DiagnosticInfo == null)
			{
				Symbol.MergeUseSiteInfo(ref result, member.ContainingType.GetUseSiteInfo(), 0);
			}
			return result;
		}

		internal Symbol GetWellKnownTypeMember(WellKnownMember member, SyntaxNode syntax, BindingDiagnosticBag diagBag)
		{
			return GetWellKnownTypeMember(Compilation, member, syntax, diagBag);
		}

		internal static Symbol GetWellKnownTypeMember(VisualBasicCompilation compilation, WellKnownMember member, SyntaxNode syntax, BindingDiagnosticBag diagBag)
		{
			UseSiteInfo<AssemblySymbol> useSiteInfo = default(UseSiteInfo<AssemblySymbol>);
			Symbol wellKnownTypeMember = GetWellKnownTypeMember(compilation, member, out useSiteInfo);
			ReportUseSite(diagBag, syntax, useSiteInfo);
			return wellKnownTypeMember;
		}

		internal static Symbol GetWellKnownTypeMember(VisualBasicCompilation compilation, WellKnownMember member, out UseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			Symbol wellKnownTypeMember = compilation.GetWellKnownTypeMember(member);
			useSiteInfo = GetUseSiteInfoForWellKnownTypeMember(wellKnownTypeMember, member, compilation.Options.EmbedVbCoreRuntime);
			return wellKnownTypeMember;
		}

		internal static UseSiteInfo<AssemblySymbol> GetUseSiteInfoForWellKnownTypeMember(Symbol memberSymbol, WellKnownMember member, bool embedVBRuntimeUsed)
		{
			if ((object)memberSymbol == null)
			{
				MemberDescriptor descriptor = WellKnownMembers.GetDescriptor(member);
				return new UseSiteInfo<AssemblySymbol>(MissingRuntimeMemberDiagnosticHelper.GetDiagnosticForMissingRuntimeHelper(descriptor.DeclaringTypeMetadataName, descriptor.Name, embedVBRuntimeUsed));
			}
			return GetUseSiteInfoForMemberAndContainingType(memberSymbol);
		}

		public static ErrorTypeSymbol GetErrorSymbol(string name, DiagnosticInfo errorInfo, ImmutableArray<Symbol> candidateSymbols, LookupResultKind resultKind, bool reportErrorWhenReferenced = false)
		{
			return new ExtendedErrorTypeSymbol(errorInfo, name, 0, candidateSymbols, resultKind, reportErrorWhenReferenced);
		}

		public static ErrorTypeSymbol GetErrorSymbol(string name, DiagnosticInfo errorInfo, bool reportErrorWhenReferenced = false)
		{
			return GetErrorSymbol(name, errorInfo, ImmutableArray<Symbol>.Empty, LookupResultKind.Empty, reportErrorWhenReferenced);
		}

		public Location GetLocation(TextSpan span)
		{
			return SyntaxTree.GetLocation(span);
		}

		public virtual SyntaxReference GetSyntaxReference(VisualBasicSyntaxNode node)
		{
			return m_containingBinder.GetSyntaxReference(node);
		}

		public BasesBeingResolved BasesBeingResolved()
		{
			return _basesBeingResolved;
		}

		public virtual LocalSymbol DeclareImplicitLocalVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax nameSyntax, BindingDiagnosticBag diagnostics)
		{
			return m_containingBinder.DeclareImplicitLocalVariable(nameSyntax, diagnostics);
		}

		public virtual void DisallowFurtherImplicitVariableDeclaration(BindingDiagnosticBag diagnostics)
		{
			m_containingBinder.DisallowFurtherImplicitVariableDeclaration(diagnostics);
		}

		public virtual LabelSymbol GetExitLabel(SyntaxKind exitSyntaxKind)
		{
			return m_containingBinder.GetExitLabel(exitSyntaxKind);
		}

		public virtual LabelSymbol GetContinueLabel(SyntaxKind continueSyntaxKind)
		{
			return m_containingBinder.GetContinueLabel(continueSyntaxKind);
		}

		public virtual LabelSymbol GetReturnLabel()
		{
			return m_containingBinder.GetReturnLabel();
		}

		public virtual LocalSymbol GetLocalForFunctionValue()
		{
			return m_containingBinder.GetLocalForFunctionValue();
		}

		public static void ReportDiagnostic(DiagnosticBag diagBag, SyntaxNodeOrToken syntax, ERRID id)
		{
			ReportDiagnostic(diagBag, syntax, ErrorFactory.ErrorInfo(id));
		}

		public static void ReportDiagnostic(DiagnosticBag diagBag, SyntaxNodeOrToken syntax, ERRID id, params object[] args)
		{
			ReportDiagnostic(diagBag, syntax, ErrorFactory.ErrorInfo(id, args));
		}

		public static void ReportDiagnostic(DiagnosticBag diagBag, SyntaxNodeOrToken syntax, DiagnosticInfo info)
		{
			VBDiagnostic diag = new VBDiagnostic(info, syntax.GetLocation());
			ReportDiagnostic(diagBag, diag);
		}

		public static void ReportDiagnostic(DiagnosticBag diagBag, Location location, ERRID id)
		{
			ReportDiagnostic(diagBag, location, ErrorFactory.ErrorInfo(id));
		}

		public static void ReportDiagnostic(DiagnosticBag diagBag, Location location, ERRID id, params object[] args)
		{
			ReportDiagnostic(diagBag, location, ErrorFactory.ErrorInfo(id, args));
		}

		public static void ReportDiagnostic(DiagnosticBag diagBag, Location location, DiagnosticInfo info)
		{
			VBDiagnostic diag = new VBDiagnostic(info, location);
			ReportDiagnostic(diagBag, diag);
		}

		public static void ReportDiagnostic(DiagnosticBag diagBag, Diagnostic diag)
		{
			diagBag.Add(diag);
		}

		public static void ReportDiagnostic(BindingDiagnosticBag diagBag, SyntaxNodeOrToken syntax, ERRID id)
		{
			ReportDiagnostic(diagBag, syntax, ErrorFactory.ErrorInfo(id));
		}

		public static void ReportDiagnostic(BindingDiagnosticBag diagBag, SyntaxNodeOrToken syntax, ERRID id, params object[] args)
		{
			ReportDiagnostic(diagBag, syntax, ErrorFactory.ErrorInfo(id, args));
		}

		public static void ReportDiagnostic(BindingDiagnosticBag diagBag, SyntaxNodeOrToken syntax, DiagnosticInfo info)
		{
			VBDiagnostic diag = new VBDiagnostic(info, syntax.GetLocation());
			ReportDiagnostic(diagBag, diag);
		}

		public static void ReportDiagnostic(BindingDiagnosticBag diagBag, Location location, ERRID id)
		{
			ReportDiagnostic(diagBag, location, ErrorFactory.ErrorInfo(id));
		}

		public static void ReportDiagnostic(BindingDiagnosticBag diagBag, Location location, ERRID id, params object[] args)
		{
			ReportDiagnostic(diagBag, location, ErrorFactory.ErrorInfo(id, args));
		}

		public static void ReportDiagnostic(BindingDiagnosticBag diagBag, Location location, DiagnosticInfo info)
		{
			VBDiagnostic diag = new VBDiagnostic(info, location);
			ReportDiagnostic(diagBag, diag);
		}

		public static void ReportDiagnostic(BindingDiagnosticBag diagBag, Diagnostic diag)
		{
			diagBag.Add(diag);
		}

		public static bool ReportUseSite(BindingDiagnosticBag diagBag, SyntaxNodeOrToken syntax, UseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			return diagBag.Add(useSiteInfo, syntax.GetLocation());
		}

		public static bool ReportUseSite(BindingDiagnosticBag diagBag, Location location, UseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			return diagBag.Add(useSiteInfo, location);
		}

		public void AddTypesAssemblyAsDependency(NamespaceOrTypeSymbol namespaceOrType, BindingDiagnosticBag diagBag)
		{
			AssemblySymbol assemblySymbol = (namespaceOrType as NamedTypeSymbol)?.ContainingAssembly;
			if ((object)assemblySymbol != null && assemblySymbol != Compilation.Assembly && assemblySymbol != Compilation.Assembly.CorLibrary)
			{
				diagBag.AddDependency(assemblySymbol);
			}
		}

		internal void ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(BindingDiagnosticBag diagnostics, Symbol symbol, SyntaxNode node)
		{
			if (!SuppressObsoleteDiagnostics)
			{
				ReportDiagnosticsIfObsolete(diagnostics, ContainingMember, symbol, node);
			}
			if (symbol.Kind == SymbolKind.Property || (object)Compilation.SourceModule == symbol.ContainingModule)
			{
				return;
			}
			NamedTypeSymbol containingType = symbol.ContainingType;
			if ((object)containingType == null || !containingType.IsInterface || Compilation.Assembly.RuntimeSupportsDefaultInterfaceImplementation)
			{
				return;
			}
			if (!symbol.IsShared && !(symbol is TypeSymbol) && !SymbolExtensions.RequiresImplementation(symbol))
			{
				ReportDiagnostic(diagnostics, node, ERRID.ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation);
				return;
			}
			Accessibility declaredAccessibility = symbol.DeclaredAccessibility;
			if ((uint)(declaredAccessibility - 2) <= 1u || declaredAccessibility == Accessibility.ProtectedOrInternal)
			{
				ReportDiagnostic(diagnostics, node, ERRID.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);
			}
		}

		internal static void ReportDiagnosticsIfObsolete(BindingDiagnosticBag diagnostics, Symbol context, Symbol symbol, SyntaxNode node)
		{
			ObsoleteDiagnosticKind obsoleteDiagnosticKind = ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(context, symbol);
			DiagnosticInfo diagnosticInfo = null;
			switch (obsoleteDiagnosticKind)
			{
			case ObsoleteDiagnosticKind.Diagnostic:
				diagnosticInfo = ObsoleteAttributeHelpers.CreateObsoleteDiagnostic(symbol);
				break;
			case ObsoleteDiagnosticKind.Lazy:
			case ObsoleteDiagnosticKind.LazyPotentiallySuppressed:
				diagnosticInfo = new LazyObsoleteDiagnosticInfo(symbol, context);
				break;
			}
			if (diagnosticInfo != null)
			{
				diagnostics.Add(diagnosticInfo, node.GetLocation());
			}
		}

		internal virtual void GetInScopeXmlNamespaces(ArrayBuilder<KeyValuePair<string, string>> builder)
		{
			m_containingBinder.GetInScopeXmlNamespaces(builder);
		}

		internal virtual bool LookupXmlNamespace(string prefix, bool ignoreXmlNodes, out string @namespace, out bool fromImports)
		{
			return m_containingBinder.LookupXmlNamespace(prefix, ignoreXmlNodes, out @namespace, out fromImports);
		}

		internal bool ReportUseSiteInfoForSynthesizedAttribute(WellKnownMember attributeCtor, VisualBasicSyntaxNode syntax, BindingDiagnosticBag diagnostics)
		{
			UseSiteInfo<AssemblySymbol> useSiteInfo = default(UseSiteInfo<AssemblySymbol>);
			GetWellKnownTypeMember(Compilation, attributeCtor, out useSiteInfo);
			if (!WellKnownMembers.IsSynthesizedAttributeOptional(attributeCtor))
			{
				if (ReportUseSite(diagnostics, syntax, useSiteInfo))
				{
					return true;
				}
			}
			else
			{
				diagnostics.AddDependencies(useSiteInfo);
			}
			return false;
		}

		internal static bool ReportUseSiteInfoForSynthesizedAttribute(WellKnownMember attributeCtor, VisualBasicCompilation compilation, Location location, BindingDiagnosticBag diagnostics)
		{
			UseSiteInfo<AssemblySymbol> useSiteInfoForWellKnownTypeMember = GetUseSiteInfoForWellKnownTypeMember(compilation.GetWellKnownTypeMember(attributeCtor), attributeCtor, compilation.Options.EmbedVbCoreRuntime);
			if (!WellKnownMembers.IsSynthesizedAttributeOptional(attributeCtor))
			{
				if (diagnostics.Add(useSiteInfoForWellKnownTypeMember, location))
				{
					return true;
				}
			}
			else
			{
				diagnostics.AddDependencies(useSiteInfoForWellKnownTypeMember);
			}
			return false;
		}

		internal virtual BoundExpression GetWithStatementPlaceholderSubstitute(BoundValuePlaceholderBase placeholder)
		{
			return m_containingBinder.GetWithStatementPlaceholderSubstitute(placeholder);
		}

		private BoundExpression BindAnonymousObjectCreationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			return AnonymousTypeCreationBinder.BindAnonymousObjectInitializer(this, node, node.Initializer, node.NewKeyword, diagnostics);
		}

		private BoundExpression BindAnonymousObjectCreationExpression(VisualBasicSyntaxNode node, AnonymousTypeDescriptor typeDescr, ImmutableArray<BoundExpression> initExpressions, BindingDiagnosticBag diagnostics)
		{
			ImmutableArray<AnonymousTypeField>.Enumerator enumerator = typeDescr.Fields.GetEnumerator();
			while (enumerator.MoveNext())
			{
				AnonymousTypeField current = enumerator.Current;
				TypeSymbol restrictedType = null;
				if (TypeSymbolExtensions.IsRestrictedTypeOrArrayType(current.Type, out restrictedType))
				{
					ReportDiagnostic(diagnostics, current.Location, ERRID.ERR_RestrictedType1, restrictedType);
				}
			}
			return CreateAnonymousObjectCreationExpression(node, typeDescr, initExpressions);
		}

		private BoundExpression CreateAnonymousObjectCreationExpression(VisualBasicSyntaxNode node, AnonymousTypeDescriptor typeDescr, ImmutableArray<BoundExpression> initExpressions, bool hasErrors = false)
		{
			AnonymousTypeManager.AnonymousTypePublicSymbol anonymousTypePublicSymbol = Compilation.AnonymousTypeManager.ConstructAnonymousTypeSymbol(typeDescr);
			anonymousTypePublicSymbol.InstanceConstructors.First();
			return CreateAnonymousObjectCreationExpression(node, anonymousTypePublicSymbol, initExpressions, hasErrors);
		}

		protected virtual BoundAnonymousTypeCreationExpression CreateAnonymousObjectCreationExpression(VisualBasicSyntaxNode node, AnonymousTypeManager.AnonymousTypePublicSymbol anonymousType, ImmutableArray<BoundExpression> initExpressions, bool hasErrors = false)
		{
			return new BoundAnonymousTypeCreationExpression(node, null, ImmutableArray<BoundAnonymousTypePropertyAccess>.Empty, initExpressions, anonymousType, hasErrors);
		}

		internal static ImmutableArray<NamedTypeSymbol> BindAttributeTypes(ImmutableArray<Binder> binders, ImmutableArray<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax> attributesToBind, Symbol ownerSymbol, BindingDiagnosticBag diagnostics)
		{
			int length = attributesToBind.Length;
			NamedTypeSymbol[] array = new NamedTypeSymbol[length - 1 + 1];
			int num = length - 1;
			for (int i = 0; i <= num; i++)
			{
				array[i] = BindAttributeType(binders[i], attributesToBind[i], ownerSymbol, diagnostics);
			}
			return array.AsImmutableOrNull();
		}

		internal static NamedTypeSymbol BindAttributeType(Binder binder, Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax attribute, Symbol ownerSymbol, BindingDiagnosticBag diagnostics)
		{
			binder = new LocationSpecificBinder(BindingLocation.Attribute, ownerSymbol, binder);
			return (NamedTypeSymbol)binder.BindTypeSyntax(attribute.Name, diagnostics);
		}

		internal static void GetAttributes(ImmutableArray<Binder> binders, ImmutableArray<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax> attributesToBind, ImmutableArray<NamedTypeSymbol> boundAttributeTypes, VisualBasicAttributeData[] attributeBuilder, Symbol ownerSymbol, BindingDiagnosticBag diagnostics)
		{
			int num = attributesToBind.Length - 1;
			for (int i = 0; i <= num; i++)
			{
				if (attributeBuilder[i] == null)
				{
					Binder containingBinder = binders[i];
					containingBinder = new LocationSpecificBinder(BindingLocation.Attribute, ownerSymbol, containingBinder);
					attributeBuilder[i] = containingBinder.GetAttribute(attributesToBind[i], boundAttributeTypes[i], diagnostics);
				}
			}
		}

		internal SourceAttributeData GetAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax node, NamedTypeSymbol boundAttributeType, BindingDiagnosticBag diagnostics)
		{
			BoundAttribute boundAttribute = BindAttribute(node, boundAttributeType, diagnostics);
			AttributeExpressionVisitor attributeExpressionVisitor = new AttributeExpressionVisitor(this, boundAttribute.HasErrors);
			ImmutableArray<TypedConstant> constructorArgs = attributeExpressionVisitor.VisitPositionalArguments(boundAttribute.ConstructorArguments, diagnostics);
			ImmutableArray<KeyValuePair<string, TypedConstant>> namedArgs = attributeExpressionVisitor.VisitNamedArguments(boundAttribute.NamedArguments, diagnostics);
			bool isConditionallyOmitted = !attributeExpressionVisitor.HasErrors && IsAttributeConditionallyOmitted(boundAttributeType, node, boundAttribute.SyntaxTree);
			return new SourceAttributeData(node.GetReference(), (NamedTypeSymbol)boundAttribute.Type, boundAttribute.Constructor, constructorArgs, namedArgs, isConditionallyOmitted, attributeExpressionVisitor.HasErrors);
		}

		protected bool IsAttributeConditionallyOmitted(NamedTypeSymbol attributeType, Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax node, SyntaxTree syntaxTree)
		{
			if (IsEarlyAttributeBinder)
			{
				return false;
			}
			if (attributeType.IsConditional)
			{
				IEnumerable<string> conditionalSymbolNames = attributeType.GetAppliedConditionalSymbols();
				if (VisualBasicExtensions.IsAnyPreprocessorSymbolDefined(syntaxTree, conditionalSymbolNames, node))
				{
					return false;
				}
				return true;
			}
			return false;
		}

		internal BoundAttribute BindAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax node, BindingDiagnosticBag diagnostics)
		{
			NamedTypeSymbol type = (NamedTypeSymbol)BindTypeSyntax(node.Name, diagnostics);
			return BindAttribute(node, type, diagnostics);
		}

		internal void LookupAttributeType(LookupResult lookupResult, NamespaceOrTypeSymbol container, string name, LookupOptions options, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			options |= LookupOptions.IgnoreExtensionMethods;
			Lookup(lookupResult, container, name + "Attribute", options, ref useSiteInfo);
			if (lookupResult.IsClear || lookupResult.IsWrongArity)
			{
				lookupResult.Clear();
				Lookup(lookupResult, container, name, options, ref useSiteInfo);
			}
			if (lookupResult.IsGood)
			{
				CheckAttributeTypeViability(lookupResult, ref useSiteInfo);
			}
		}

		private void Lookup(LookupResult lookupResult, NamespaceOrTypeSymbol container, string name, LookupOptions options, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			if ((object)container != null)
			{
				LookupMember(lookupResult, container, name, 0, options, ref useSiteInfo);
			}
			else
			{
				Lookup(lookupResult, name, 0, options, ref useSiteInfo);
			}
		}

		private void CheckAttributeTypeViability(LookupResult lookupResult, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			Symbol symbol = SymbolExtensions.UnwrapAlias(lookupResult.SingleSymbol);
			DiagnosticInfo diagnosticInfo = null;
			ERRID errid;
			if (symbol.Kind == SymbolKind.Namespace)
			{
				errid = ERRID.ERR_UnrecognizedType;
			}
			else if (symbol.Kind == SymbolKind.TypeParameter)
			{
				errid = ERRID.ERR_AttrCannotBeGenerics;
			}
			else if (symbol.Kind != SymbolKind.NamedType)
			{
				errid = ERRID.ERR_UnrecognizedType;
			}
			else
			{
				NamedTypeSymbol namedTypeSymbol = (NamedTypeSymbol)symbol;
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo2 = (useSiteInfo.AccumulatesDependencies ? new CompoundUseSiteInfo<AssemblySymbol>(Compilation.Assembly) : CompoundUseSiteInfo<AssemblySymbol>.DiscardedDependencies);
				if (namedTypeSymbol.IsGenericType)
				{
					errid = ERRID.ERR_AttrCannotBeGenerics;
				}
				else if (TypeSymbolExtensions.IsStructureType(namedTypeSymbol))
				{
					errid = ERRID.ERR_AttributeMustBeClassNotStruct1;
				}
				else if (!TypeSymbolExtensions.IsBaseTypeOf(Compilation.GetWellKnownType(WellKnownType.System_Attribute), namedTypeSymbol, ref useSiteInfo2))
				{
					errid = ERRID.ERR_AttributeMustInheritSysAttr;
					if (!useSiteInfo2.Diagnostics.IsNullOrEmpty())
					{
						diagnosticInfo = useSiteInfo2.Diagnostics.First();
					}
				}
				else
				{
					if (!namedTypeSymbol.IsMustInherit)
					{
						useSiteInfo.MergeAndClear(ref useSiteInfo2);
						return;
					}
					errid = ERRID.ERR_AttributeCannotBeAbstract;
				}
			}
			if (diagnosticInfo == null)
			{
				diagnosticInfo = new BadSymbolDiagnostic(symbol, errid);
			}
			lookupResult.Clear();
			lookupResult.SetFrom(SingleLookupResult.NotAnAttributeType(symbol, diagnosticInfo));
		}

		internal BoundAttribute BindAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax node, NamedTypeSymbol type, BindingDiagnosticBag diagnostics)
		{
			NamedTypeSymbol namedTypeSymbol = type;
			LookupResultKind lookupResultKind = LookupResultKind.Good;
			if (TypeSymbolExtensions.IsErrorType(type))
			{
				ErrorTypeSymbol errorTypeSymbol = (ErrorTypeSymbol)type;
				lookupResultKind = errorTypeSymbol.ResultKind;
				if (errorTypeSymbol.CandidateSymbols.Length == 1 && errorTypeSymbol.CandidateSymbols[0].Kind == SymbolKind.NamedType)
				{
					namedTypeSymbol = (NamedTypeSymbol)errorTypeSymbol.CandidateSymbols[0];
				}
			}
			Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax argumentList = node.ArgumentList;
			MethodSymbol methodSymbol = null;
			AnalyzedAttributeArguments analyzedAttributeArguments = BindAttributeArguments(namedTypeSymbol, argumentList, diagnostics);
			ImmutableArray<BoundExpression> immutableArray = analyzedAttributeArguments.positionalArguments;
			ImmutableArray<BoundExpression> namedArguments = analyzedAttributeArguments.namedArguments;
			if (!TypeSymbolExtensions.IsErrorType(namedTypeSymbol))
			{
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
				ImmutableArray<MethodSymbol> accessibleConstructors = GetAccessibleConstructors(namedTypeSymbol, ref useSiteInfo);
				if (accessibleConstructors.Length == 0)
				{
					((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)node, useSiteInfo);
					if (!TypeSymbolExtensions.IsErrorType(type))
					{
						ReportDiagnostic(diagnostics, node, ErrorFactory.ErrorInfo(ERRID.ERR_NoViableOverloadCandidates1, "New"));
					}
					lookupResultKind = ((!namedTypeSymbol.InstanceConstructors.IsEmpty) ? LookupResult.WorseResultKind(lookupResultKind, LookupResultKind.Inaccessible) : LookupResult.WorseResultKind(lookupResultKind, LookupResultKind.Empty));
				}
				else
				{
					BoundMethodGroup boundMethodGroup = new BoundMethodGroup(node.Name, null, accessibleConstructors, LookupResultKind.Good, null, QualificationKind.QualifiedViaTypeName);
					OverloadResolution.OverloadResolutionResult results = OverloadResolution.MethodInvocationOverloadResolution(boundMethodGroup, immutableArray, default(ImmutableArray<string>), this, node.Name, ref useSiteInfo);
					if (((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)node.Name, useSiteInfo))
					{
						diagnostics = BindingDiagnosticBag.Discarded;
					}
					if (!results.BestResult.HasValue)
					{
						lookupResultKind = LookupResult.WorseResultKind(lookupResultKind, LookupResultKind.OverloadResolutionFailure);
						if (!TypeSymbolExtensions.IsErrorType(type))
						{
							if (results.Candidates.Length == 0)
							{
								ImmutableArray<BoundExpression> arguments = immutableArray;
								Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax name = node.Name;
								CompoundUseSiteInfo<AssemblySymbol> useSiteInfo2 = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
								results = OverloadResolution.MethodInvocationOverloadResolution(boundMethodGroup, arguments, default(ImmutableArray<string>), this, name, ref useSiteInfo2, includeEliminatedCandidates: true);
							}
							ReportOverloadResolutionFailureAndProduceBoundNode(node, boundMethodGroup, immutableArray, default(ImmutableArray<string>), ref results, diagnostics, node.Name);
						}
					}
					else
					{
						OverloadResolution.CandidateAnalysisResult candidate = results.BestResult.Value;
						methodSymbol = (MethodSymbol)candidate.Candidate.UnderlyingSymbol;
						bool flag = false;
						ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagnostics, methodSymbol, node);
						ImmutableArray<ParameterSymbol>.Enumerator enumerator = methodSymbol.Parameters.GetEnumerator();
						while (enumerator.MoveNext())
						{
							ParameterSymbol current = enumerator.Current;
							if (!IsValidTypeForAttributeArgument(current.Type))
							{
								flag = true;
								ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_BadAttributeConstructor1, current.Type);
							}
							else if (current.IsByRef)
							{
								flag = true;
								ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_BadAttributeConstructor2, current.Type);
							}
							if (TypeSymbolExtensions.DigThroughArrayType(current.Type).DeclaredAccessibility != Accessibility.Public)
							{
								flag = true;
								ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_BadAttributeNonPublicType1, current.Type);
								continue;
							}
							NamedTypeSymbol containingType = current.Type.ContainingType;
							while ((object)containingType != null)
							{
								if (TypeSymbolExtensions.DigThroughArrayType(containingType).DeclaredAccessibility != Accessibility.Public)
								{
									flag = true;
									ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_BadAttributeNonPublicContType2, current.Type, containingType);
								}
								containingType = containingType.ContainingType;
							}
						}
						if (!flag)
						{
							immutableArray = PassArguments(node.Name, ref candidate, immutableArray, diagnostics).Arguments;
							if (methodSymbol.DeclaredAccessibility != Accessibility.Public)
							{
								ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_BadAttributeNonPublicConstructor);
							}
						}
					}
				}
			}
			return new BoundAttribute(node, methodSymbol, immutableArray, namedArguments, lookupResultKind, type, lookupResultKind != LookupResultKind.Good);
		}

		private AnalyzedAttributeArguments BindAttributeArguments(NamedTypeSymbol type, Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax argumentListOpt, BindingDiagnosticBag diagnostics)
		{
			ImmutableArray<BoundExpression> positionalArguments;
			ImmutableArray<BoundExpression> namedArguments;
			if (argumentListOpt == null)
			{
				positionalArguments = s_noArguments;
				namedArguments = s_noArguments;
			}
			else
			{
				SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax> arguments = argumentListOpt.Arguments;
				ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
				ArrayBuilder<BoundExpression> arrayBuilder = null;
				int num = 0;
				try
				{
					SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax>.Enumerator enumerator = arguments.GetEnumerator();
					while (enumerator.MoveNext())
					{
						Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax current = enumerator.Current;
						switch (current.Kind())
						{
						case SyntaxKind.SimpleArgument:
						{
							Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax simpleArgumentSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax)current;
							if (!simpleArgumentSyntax.IsNamed)
							{
								BoundExpression boundExpression = BindValue(simpleArgumentSyntax.Expression, diagnostics);
								MarkEmbeddedTypeReferenceIfNeeded(boundExpression);
								instance.Add(boundExpression);
								break;
							}
							if (arrayBuilder == null)
							{
								arrayBuilder = ArrayBuilder<BoundExpression>.GetInstance();
							}
							arrayBuilder.Add(BindAttributeNamedArgument(type, simpleArgumentSyntax, diagnostics));
							break;
						}
						case SyntaxKind.OmittedArgument:
							instance.Add(new BoundOmittedArgument(current, null));
							break;
						}
						num++;
					}
				}
				finally
				{
					positionalArguments = instance.ToImmutableAndFree();
					namedArguments = arrayBuilder?.ToImmutableAndFree() ?? s_noArguments;
				}
			}
			return new AnalyzedAttributeArguments(positionalArguments, namedArguments);
		}

		private BoundExpression BindAttributeNamedArgument(TypeSymbol container, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax namedArg, BindingDiagnosticBag diagnostics)
		{
			LookupResult instance = LookupResult.GetInstance();
			Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax name = namedArg.NameColonEquals.Name;
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
			LookupMember(instance, container, name.Identifier.ValueText, 0, LookupOptions.IgnoreExtensionMethods, ref useSiteInfo);
			BoundExpression boundExpression = BindValue(namedArg.Expression, diagnostics);
			MarkEmbeddedTypeReferenceIfNeeded(boundExpression);
			BoundExpression boundExpression2 = null;
			if (instance.IsGood)
			{
				Symbol bestAttributeFieldOrProperty = GetBestAttributeFieldOrProperty(instance);
				FieldSymbol fieldSymbol = null;
				PropertySymbol propertySymbol = null;
				TypeSymbol typeSymbol = null;
				bool flag = false;
				bool hasErrors = false;
				ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagnostics, bestAttributeFieldOrProperty, namedArg);
				switch (bestAttributeFieldOrProperty.Kind)
				{
				case SymbolKind.Field:
					fieldSymbol = (FieldSymbol)bestAttributeFieldOrProperty;
					typeSymbol = fieldSymbol.Type;
					flag = fieldSymbol.IsReadOnly;
					ReportUseSite(diagnostics, name.Identifier, bestAttributeFieldOrProperty);
					break;
				case SymbolKind.Property:
				{
					propertySymbol = (PropertySymbol)bestAttributeFieldOrProperty;
					typeSymbol = PropertySymbolExtensions.GetTypeFromSetMethod(propertySymbol);
					MethodSymbol setMethod = propertySymbol.SetMethod;
					flag = (object)setMethod == null;
					if ((object)setMethod != null)
					{
						ReportUseSite(diagnostics, name.Identifier, setMethod);
						if (setMethod.ParameterCount != 1)
						{
							ReportDiagnostic(diagnostics, name, ERRID.ERR_NoNonIndexProperty1, bestAttributeFieldOrProperty.Name);
							hasErrors = true;
						}
						if (!IsAccessible(setMethod, ref useSiteInfo))
						{
							ReportDiagnostic(diagnostics, name, ERRID.ERR_InaccessibleMember3, propertySymbol.ContainingSymbol, propertySymbol, AccessCheck.GetAccessibilityForErrorMessage(setMethod, Compilation.Assembly));
							hasErrors = true;
						}
						if (setMethod.IsInitOnly)
						{
							Parser.CheckFeatureAvailability(diagnostics, name.Location, ((VisualBasicParseOptions)name.SyntaxTree.Options).LanguageVersion, Feature.InitOnlySettersUsage);
						}
					}
					break;
				}
				default:
					ReportDiagnostic(diagnostics, name, ERRID.ERR_AttrAssignmentNotFieldOrProp1, name.Identifier.ValueText);
					hasErrors = true;
					break;
				}
				if (bestAttributeFieldOrProperty.DeclaredAccessibility != Accessibility.Public)
				{
					ReportDiagnostic(diagnostics, name, ERRID.ERR_BadAttributeNonPublicProperty1, bestAttributeFieldOrProperty.Name);
					hasErrors = true;
				}
				if (bestAttributeFieldOrProperty.IsShared)
				{
					ReportDiagnostic(diagnostics, name, ERRID.ERR_BadAttributeSharedProperty1, bestAttributeFieldOrProperty.Name);
					hasErrors = true;
				}
				if (flag)
				{
					ReportDiagnostic(diagnostics, name, ERRID.ERR_BadAttributeReadOnlyProperty1, bestAttributeFieldOrProperty.Name);
					hasErrors = true;
				}
				if ((object)typeSymbol != null)
				{
					if (!IsValidTypeForAttributeArgument(typeSymbol))
					{
						ReportDiagnostic(diagnostics, name, ERRID.ERR_BadAttributePropertyType1, bestAttributeFieldOrProperty.Name);
						hasErrors = true;
					}
					boundExpression = ApplyImplicitConversion(namedArg.Expression, typeSymbol, boundExpression, diagnostics);
				}
				else
				{
					boundExpression = MakeRValue(boundExpression, diagnostics);
				}
				boundExpression2 = (((object)propertySymbol != null) ? new BoundPropertyAccess(name, propertySymbol, null, PropertyAccessKind.Set, !flag, null, ImmutableArray<BoundExpression>.Empty, BitVector.Null, hasErrors) : (((object)fieldSymbol == null) ? ((BoundExpression)BadExpression(name, ErrorTypeSymbol.UnknownResultType)) : ((BoundExpression)new BoundFieldAccess(name, null, fieldSymbol, isLValue: true, typeSymbol, hasErrors))));
			}
			else
			{
				if (instance.HasDiagnostic)
				{
					ReportDiagnostic(diagnostics, name, instance.Diagnostic);
				}
				else
				{
					ReportDiagnostic(diagnostics, name, ERRID.ERR_PropertyOrFieldNotDefined1, name.Identifier.ValueText);
				}
				boundExpression2 = BadExpression(name, ErrorTypeSymbol.UnknownResultType);
				boundExpression = MakeRValue(boundExpression, diagnostics);
			}
			((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)namedArg, useSiteInfo);
			instance.Free();
			return new BoundAssignmentOperator(namedArg, boundExpression2, boundExpression, suppressObjectClone: true);
		}

		private void MarkEmbeddedTypeReferenceIfNeeded(BoundExpression expression)
		{
			if (Compilation.EmbeddedSymbolManager.Embedded == EmbeddedSymbolKind.None || expression.HasErrors || expression.Syntax.SyntaxTree == null || !Compilation.ContainsSyntaxTree(expression.Syntax.SyntaxTree))
			{
				return;
			}
			if (expression.Kind == BoundKind.GetType)
			{
				MarkEmbeddedTypeReferencedFromGetTypeExpression((BoundGetType)expression);
			}
			else
			{
				if (expression.Kind != BoundKind.ArrayCreation)
				{
					return;
				}
				BoundArrayInitialization initializerOpt = ((BoundArrayCreation)expression).InitializerOpt;
				if (initializerOpt != null)
				{
					ImmutableArray<BoundExpression>.Enumerator enumerator = initializerOpt.Initializers.GetEnumerator();
					while (enumerator.MoveNext())
					{
						BoundExpression current = enumerator.Current;
						MarkEmbeddedTypeReferenceIfNeeded(current);
					}
				}
			}
		}

		private void MarkEmbeddedTypeReferencedFromGetTypeExpression(BoundGetType expression)
		{
			TypeSymbol type = expression.SourceType.Type;
			if (type.IsEmbedded)
			{
				Compilation.EmbeddedSymbolManager.MarkSymbolAsReferenced(type);
			}
		}

		private static Symbol GetBestAttributeFieldOrProperty(LookupResult result)
		{
			if (result.HasSingleSymbol)
			{
				return result.SingleSymbol;
			}
			Symbol symbol = null;
			ArrayBuilder<Symbol> symbols = result.Symbols;
			ArrayBuilder<Symbol>.Enumerator enumerator = symbols.GetEnumerator();
			while (enumerator.MoveNext())
			{
				Symbol current = enumerator.Current;
				switch (current.Kind)
				{
				case SymbolKind.Field:
					return current;
				case SymbolKind.Property:
				{
					symbol = current;
					PropertySymbol propertySymbol = (PropertySymbol)current;
					MethodSymbol mostDerivedSetMethod = propertySymbol.GetMostDerivedSetMethod();
					if ((object)mostDerivedSetMethod != null && mostDerivedSetMethod.ParameterCount == 1)
					{
						return propertySymbol;
					}
					break;
				}
				}
			}
			if ((object)symbol == null)
			{
				return symbols[0];
			}
			return symbol;
		}

		private bool IsValidTypeForAttributeArgument(TypeSymbol type)
		{
			return TypeSymbolExtensions.IsValidTypeForAttributeArgument(type, Compilation);
		}

		private BoundExpression BindConditionalAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			BoundRValuePlaceholder placeholder = null;
			BoundExpression receiver = BindConditionalAccessReceiver(node, diagnostics, out placeholder);
			BoundExpression accessExpression = new ConditionalAccessBinder(this, node, placeholder).BindExpression(node.WhenNotNull, diagnostics);
			return new BoundConditionalAccess(node, receiver, placeholder, accessExpression, null);
		}

		private BoundExpression BindConditionalAccessReceiver(Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax node, BindingDiagnosticBag diagnostics, out BoundRValuePlaceholder placeholder)
		{
			BoundExpression boundExpression;
			if (node.Expression == null)
			{
				boundExpression = TryBindOmittedLeftForConditionalAccess(node, this, diagnostics);
				if (boundExpression == null)
				{
					boundExpression = BoundNodeExtensions.MakeCompilerGenerated(ReportDiagnosticAndProduceBadExpression(diagnostics, node, ERRID.ERR_BadConditionalWithRef));
				}
			}
			else
			{
				boundExpression = BindValue(node.Expression, diagnostics);
				if (!boundExpression.IsLValue)
				{
					boundExpression = MakeRValue(boundExpression, diagnostics);
				}
			}
			TypeSymbol type = boundExpression.Type;
			TypeSymbol type2 = type;
			if (type.IsValueType)
			{
				if (TypeSymbolExtensions.IsNullableType(type))
				{
					type2 = TypeSymbolExtensions.GetNullableUnderlyingType(type);
				}
				else
				{
					ReportDiagnostic(diagnostics, node.QuestionMarkToken, ERRID.ERR_UnaryOperand2, node.QuestionMarkToken.ValueText, type);
				}
			}
			placeholder = new BoundRValuePlaceholder(node, type2);
			placeholder.SetWasCompilerGenerated();
			return boundExpression;
		}

		protected virtual BoundExpression TryBindOmittedLeftForConditionalAccess(Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax node, Binder accessingBinder, BindingDiagnosticBag diagnostics)
		{
			return ContainingBinder.TryBindOmittedLeftForConditionalAccess(node, accessingBinder, diagnostics);
		}

		protected BoundExpression GetConditionalAccessReceiver(Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax node)
		{
			BoundExpression boundExpression = TryGetConditionalAccessReceiver(node);
			if (boundExpression == null)
			{
				BoundRValuePlaceholder placeholder = null;
				BindConditionalAccessReceiver(node, BindingDiagnosticBag.Discarded, out placeholder);
				return placeholder;
			}
			return boundExpression;
		}

		protected virtual BoundExpression TryGetConditionalAccessReceiver(Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax node)
		{
			return ContainingBinder.TryGetConditionalAccessReceiver(node);
		}

		internal ImmutableArray<TypeParameterConstraint> BindTypeParameterConstraintClause(Symbol containingSymbol, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterConstraintClauseSyntax clause, BindingDiagnosticBag diagnostics)
		{
			if (clause == null)
			{
				return ImmutableArray<TypeParameterConstraint>.Empty;
			}
			TypeParameterConstraintKind constraints = TypeParameterConstraintKind.None;
			ArrayBuilder<TypeParameterConstraint> instance = ArrayBuilder<TypeParameterConstraint>.GetInstance();
			switch (clause.Kind())
			{
			case SyntaxKind.TypeParameterSingleConstraintClause:
				BindTypeParameterConstraint(containingSymbol, ((Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSingleConstraintClauseSyntax)clause).Constraint, ref constraints, instance, diagnostics);
				break;
			case SyntaxKind.TypeParameterMultipleConstraintClause:
			{
				SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax>.Enumerator enumerator = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterMultipleConstraintClauseSyntax)clause).Constraints.GetEnumerator();
				while (enumerator.MoveNext())
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax current = enumerator.Current;
					BindTypeParameterConstraint(containingSymbol, current, ref constraints, instance, diagnostics);
				}
				break;
			}
			default:
				throw ExceptionUtilities.UnexpectedValue(clause.Kind());
			}
			return instance.ToImmutableAndFree();
		}

		private void BindTypeParameterConstraint(Symbol containingSymbol, Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax syntax, ref TypeParameterConstraintKind constraints, ArrayBuilder<TypeParameterConstraint> constraintsBuilder, BindingDiagnosticBag diagnostics)
		{
			switch (syntax.Kind())
			{
			case SyntaxKind.NewConstraint:
				if ((constraints & TypeParameterConstraintKind.Constructor) != 0)
				{
					ReportDiagnostic(diagnostics, syntax, ERRID.ERR_MultipleNewConstraints);
					break;
				}
				if ((constraints & TypeParameterConstraintKind.ValueType) != 0)
				{
					ReportDiagnostic(diagnostics, syntax, ERRID.ERR_NewAndValueConstraintsCombined);
					break;
				}
				constraints |= TypeParameterConstraintKind.Constructor;
				constraintsBuilder.Add(new TypeParameterConstraint(TypeParameterConstraintKind.Constructor, syntax.GetLocation()));
				break;
			case SyntaxKind.ClassConstraint:
				if ((constraints & TypeParameterConstraintKind.ReferenceType) != 0)
				{
					ReportDiagnostic(diagnostics, syntax, ERRID.ERR_MultipleReferenceConstraints);
					break;
				}
				if ((constraints & TypeParameterConstraintKind.ValueType) != 0)
				{
					ReportDiagnostic(diagnostics, syntax, ERRID.ERR_RefAndValueConstraintsCombined);
					break;
				}
				constraints |= TypeParameterConstraintKind.ReferenceType;
				constraintsBuilder.Add(new TypeParameterConstraint(TypeParameterConstraintKind.ReferenceType, syntax.GetLocation()));
				break;
			case SyntaxKind.StructureConstraint:
				if ((constraints & TypeParameterConstraintKind.ValueType) != 0)
				{
					ReportDiagnostic(diagnostics, syntax, ERRID.ERR_MultipleValueConstraints);
					break;
				}
				if ((constraints & TypeParameterConstraintKind.Constructor) != 0)
				{
					ReportDiagnostic(diagnostics, syntax, ERRID.ERR_NewAndValueConstraintsCombined);
					break;
				}
				if ((constraints & TypeParameterConstraintKind.ReferenceType) != 0)
				{
					ReportDiagnostic(diagnostics, syntax, ERRID.ERR_RefAndValueConstraintsCombined);
					break;
				}
				constraints |= TypeParameterConstraintKind.ValueType;
				constraintsBuilder.Add(new TypeParameterConstraint(TypeParameterConstraintKind.ValueType, syntax.GetLocation()));
				break;
			case SyntaxKind.TypeConstraint:
				if (!(SymbolExtensions.UnwrapAlias(BindTypeOrAliasSyntax(((Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeConstraintSyntax)syntax).Type, diagnostics)) is TypeSymbol typeSymbol))
				{
					ReportDiagnostic(diagnostics, syntax, ERRID.ERR_UnrecognizedType);
					break;
				}
				constraintsBuilder.Add(new TypeParameterConstraint(typeSymbol, syntax.GetLocation()));
				AccessCheck.VerifyAccessExposureForMemberType(containingSymbol, syntax, typeSymbol, diagnostics);
				break;
			default:
				throw ExceptionUtilities.UnexpectedValue(syntax.Kind());
			}
		}

		private BoundExpression BindCastExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			return VisualBasicExtensions.Kind(node.Keyword) switch
			{
				SyntaxKind.CTypeKeyword => BindCTypeExpression(node, diagnostics), 
				SyntaxKind.DirectCastKeyword => BindDirectCastExpression(node, diagnostics), 
				SyntaxKind.TryCastKeyword => BindTryCastExpression(node, diagnostics), 
				_ => throw ExceptionUtilities.UnexpectedValue(VisualBasicExtensions.Kind(node.Keyword)), 
			};
		}

		private BoundExpression BindCTypeExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			BoundExpression argument = BindValue(node.Expression, diagnostics);
			TypeSymbol targetType = BindTypeSyntax(node.Type, diagnostics);
			return ApplyConversion(node, targetType, argument, isExplicit: true, diagnostics);
		}

		private BoundExpression BindDirectCastExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			BoundExpression argument = BindValue(node.Expression, diagnostics);
			TypeSymbol targetType = BindTypeSyntax(node.Type, diagnostics);
			return ApplyDirectCastConversion(node, argument, targetType, diagnostics);
		}

		private BoundExpression ApplyDirectCastConversion(SyntaxNode node, BoundExpression argument, TypeSymbol targetType, BindingDiagnosticBag diagnostics)
		{
			if (argument.HasErrors || TypeSymbolExtensions.IsErrorType(targetType))
			{
				argument = MakeRValue(argument, diagnostics);
				return new BoundDirectCast(node, argument, ConversionKind.DelegateRelaxationLevelNone, targetType, hasErrors: true);
			}
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
			ConversionKind conversionKind = Conversions.ClassifyDirectCastConversion(argument, targetType, this, ref useSiteInfo);
			if (((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(node, useSiteInfo))
			{
				diagnostics = BindingDiagnosticBag.Discarded;
			}
			if (ReclassifyExpression(ref argument, SyntaxKind.DirectCastKeyword, node, conversionKind, isExplicit: true, targetType, diagnostics))
			{
				if (argument.Syntax != node)
				{
					argument = new BoundDirectCast(node, argument, ConversionKind.Identity, targetType);
				}
				return argument;
			}
			argument = MakeRValue(argument, diagnostics);
			if (argument.HasErrors)
			{
				return new BoundDirectCast(node, argument, conversionKind, targetType, hasErrors: true);
			}
			TypeSymbol type = argument.Type;
			if ((object)type != null && TypeSymbolExtensions.IsErrorType(type))
			{
				return new BoundDirectCast(node, argument, conversionKind, targetType, hasErrors: true);
			}
			if (Conversions.NoConversion(conversionKind) && type.IsValueType && TypeSymbolExtensions.IsRestrictedType(type) && (TypeSymbolExtensions.IsObjectType(targetType) || targetType.SpecialType == SpecialType.System_ValueType))
			{
				ReportDiagnostic(diagnostics, argument.Syntax, ERRID.ERR_RestrictedConversion1, type);
				return new BoundDirectCast(node, argument, conversionKind, targetType, hasErrors: true);
			}
			WarnOnNarrowingConversionBetweenSealedClassAndAnInterface(conversionKind, argument.Syntax, type, targetType, diagnostics);
			if (Conversions.NoConversion(conversionKind))
			{
				ReportNoConversionError(argument.Syntax, type, targetType, diagnostics);
				return new BoundDirectCast(node, argument, conversionKind, targetType, hasErrors: true);
			}
			if (Conversions.IsIdentityConversion(conversionKind))
			{
				if (TypeSymbolExtensions.IsFloatingType(targetType))
				{
					ReportDiagnostic(diagnostics, argument.Syntax, ERRID.ERR_IdentityDirectCastForFloat);
				}
				else if (targetType.IsValueType)
				{
					ReportDiagnostic(diagnostics, argument.Syntax, ERRID.WRN_ObsoleteIdentityDirectCastForValueType);
				}
			}
			bool integerOverflow = false;
			ConstantValue constantValue = Conversions.TryFoldConstantConversion(argument, targetType, ref integerOverflow);
			if ((object)constantValue == null)
			{
				constantValue = Conversions.TryFoldNothingReferenceConversion(argument, conversionKind, targetType);
			}
			return new BoundDirectCast(node, argument, conversionKind, constantValue, targetType);
		}

		private BoundExpression BindTryCastExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			BoundExpression argument = BindValue(node.Expression, diagnostics);
			TypeSymbol targetType = BindTypeSyntax(node.Type, diagnostics);
			return ApplyTryCastConversion(node, argument, targetType, diagnostics);
		}

		private BoundExpression ApplyTryCastConversion(SyntaxNode node, BoundExpression argument, TypeSymbol targetType, BindingDiagnosticBag diagnostics)
		{
			if (argument.HasErrors || TypeSymbolExtensions.IsErrorType(targetType))
			{
				argument = MakeRValue(argument, diagnostics);
				return new BoundTryCast(node, argument, ConversionKind.DelegateRelaxationLevelNone, targetType, hasErrors: true);
			}
			ConversionKind conversionKind;
			if (targetType.IsReferenceType)
			{
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
				conversionKind = Conversions.ClassifyTryCastConversion(argument, targetType, this, ref useSiteInfo);
				if (((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(node, useSiteInfo))
				{
					diagnostics = BindingDiagnosticBag.Discarded;
				}
			}
			else
			{
				conversionKind = ConversionKind.DelegateRelaxationLevelNone;
			}
			if (ReclassifyExpression(ref argument, SyntaxKind.TryCastKeyword, node, conversionKind, isExplicit: true, targetType, diagnostics))
			{
				if (argument.Syntax != node)
				{
					argument = new BoundTryCast(node, argument, ConversionKind.Identity, targetType);
				}
				return argument;
			}
			argument = MakeRValue(argument, diagnostics);
			if (argument.HasErrors)
			{
				return new BoundTryCast(node, argument, conversionKind, targetType, hasErrors: true);
			}
			TypeSymbol type = argument.Type;
			if ((object)type != null && TypeSymbolExtensions.IsErrorType(type))
			{
				return new BoundTryCast(node, argument, conversionKind, targetType, hasErrors: true);
			}
			if (Conversions.NoConversion(conversionKind))
			{
				if (targetType.IsValueType)
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax castExpressionSyntax = node as Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax;
					ReportDiagnostic(diagnostics, (castExpressionSyntax != null) ? castExpressionSyntax.Type : node, ERRID.ERR_TryCastOfValueType1, targetType);
					return new BoundTryCast(node, argument, conversionKind, targetType, hasErrors: true);
				}
				if (TypeSymbolExtensions.IsTypeParameter(targetType) && !targetType.IsReferenceType)
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax castExpressionSyntax2 = node as Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax;
					ReportDiagnostic(diagnostics, (castExpressionSyntax2 != null) ? castExpressionSyntax2.Type : node, ERRID.ERR_TryCastOfUnconstrainedTypeParam1, targetType);
					return new BoundTryCast(node, argument, conversionKind, targetType, hasErrors: true);
				}
				if (type.IsValueType && TypeSymbolExtensions.IsRestrictedType(type) && (TypeSymbolExtensions.IsObjectType(targetType) || targetType.SpecialType == SpecialType.System_ValueType))
				{
					ReportDiagnostic(diagnostics, argument.Syntax, ERRID.ERR_RestrictedConversion1, type);
					return new BoundTryCast(node, argument, conversionKind, targetType, hasErrors: true);
				}
			}
			WarnOnNarrowingConversionBetweenSealedClassAndAnInterface(conversionKind, argument.Syntax, type, targetType, diagnostics);
			if (Conversions.NoConversion(conversionKind))
			{
				ReportNoConversionError(argument.Syntax, type, targetType, diagnostics);
				return new BoundTryCast(node, argument, conversionKind, targetType, hasErrors: true);
			}
			ConstantValue constantValueOpt = Conversions.TryFoldNothingReferenceConversion(argument, conversionKind, targetType);
			return new BoundTryCast(node, argument, conversionKind, constantValueOpt, targetType);
		}

		private BoundExpression BindPredefinedCastExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			return ApplyConversion(node, GetSpecialType(VisualBasicExtensions.Kind(node.Keyword) switch
			{
				SyntaxKind.CBoolKeyword => SpecialType.System_Boolean, 
				SyntaxKind.CByteKeyword => SpecialType.System_Byte, 
				SyntaxKind.CCharKeyword => SpecialType.System_Char, 
				SyntaxKind.CDateKeyword => SpecialType.System_DateTime, 
				SyntaxKind.CDecKeyword => SpecialType.System_Decimal, 
				SyntaxKind.CDblKeyword => SpecialType.System_Double, 
				SyntaxKind.CIntKeyword => SpecialType.System_Int32, 
				SyntaxKind.CLngKeyword => SpecialType.System_Int64, 
				SyntaxKind.CObjKeyword => SpecialType.System_Object, 
				SyntaxKind.CSByteKeyword => SpecialType.System_SByte, 
				SyntaxKind.CShortKeyword => SpecialType.System_Int16, 
				SyntaxKind.CSngKeyword => SpecialType.System_Single, 
				SyntaxKind.CStrKeyword => SpecialType.System_String, 
				SyntaxKind.CUIntKeyword => SpecialType.System_UInt32, 
				SyntaxKind.CULngKeyword => SpecialType.System_UInt64, 
				SyntaxKind.CUShortKeyword => SpecialType.System_UInt16, 
				_ => throw ExceptionUtilities.UnexpectedValue(VisualBasicExtensions.Kind(node.Keyword)), 
			}, node.Keyword, diagnostics), BindValue(node.Expression, diagnostics), isExplicit: true, diagnostics);
		}

		internal BoundExpression ApplyImplicitConversion(SyntaxNode node, TypeSymbol targetType, BoundExpression expression, BindingDiagnosticBag diagnostics, bool isOperandOfConditionalBranch = false)
		{
			return ApplyConversion(node, targetType, expression, isExplicit: false, diagnostics, isOperandOfConditionalBranch);
		}

		private BoundExpression ApplyConversion(SyntaxNode node, TypeSymbol targetType, BoundExpression argument, bool isExplicit, BindingDiagnosticBag diagnostics, bool isOperandOfConditionalBranch = false, bool explicitSemanticForConcatArgument = false)
		{
			if (TypeSymbolExtensions.IsErrorType(targetType))
			{
				argument = MakeRValueAndIgnoreDiagnostics(argument);
				if (!isExplicit && TypeSymbolExtensions.IsSameTypeIgnoringAll(argument.Type, targetType))
				{
					return argument;
				}
				return new BoundConversion(node, argument, ConversionKind.DelegateRelaxationLevelNone, CheckOverflow, isExplicit, targetType, hasErrors: true);
			}
			if (argument.HasErrors)
			{
				diagnostics = BindingDiagnosticBag.Discarded;
			}
			bool applyNullableIsTrueOperator = false;
			OverloadResolution.OverloadResolutionResult isTrueOperator = default(OverloadResolution.OverloadResolutionResult);
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
			BoundExpression boundExpression;
			if (isOperandOfConditionalBranch && TypeSymbolExtensions.IsBooleanType(targetType))
			{
				KeyValuePair<ConversionKind, MethodSymbol> convKind = Conversions.ClassifyConversionOfOperandOfConditionalBranch(argument, targetType, this, out applyNullableIsTrueOperator, out isTrueOperator, ref useSiteInfo);
				if (((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(node, useSiteInfo))
				{
					diagnostics = BindingDiagnosticBag.Discarded;
				}
				if (isTrueOperator.BestResult.HasValue)
				{
					BoundUserDefinedUnaryOperator boundUserDefinedUnaryOperator = BindUserDefinedUnaryOperator(node, UnaryOperatorKind.IsTrue, argument, ref isTrueOperator, diagnostics);
					boundUserDefinedUnaryOperator.SetWasCompilerGenerated();
					boundUserDefinedUnaryOperator.UnderlyingExpression.SetWasCompilerGenerated();
					boundExpression = boundUserDefinedUnaryOperator;
				}
				else
				{
					TypeSymbol targetType2;
					if (applyNullableIsTrueOperator)
					{
						Compilation.GetSpecialType(SpecialType.System_Nullable_T);
						targetType2 = Compilation.GetSpecialType(SpecialType.System_Nullable_T).Construct(ImmutableArray.Create(targetType));
					}
					else
					{
						targetType2 = targetType;
					}
					boundExpression = CreateConversionAndReportDiagnostic(node, argument, convKind, isExplicit, targetType2, diagnostics);
				}
				if (applyNullableIsTrueOperator)
				{
					boundExpression = ApplyNullableIsTrueOperator(boundExpression, targetType);
				}
			}
			else
			{
				KeyValuePair<ConversionKind, MethodSymbol> convKind = Conversions.ClassifyConversion(argument, targetType, this, ref useSiteInfo);
				if (((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(node, useSiteInfo))
				{
					diagnostics = BindingDiagnosticBag.Discarded;
				}
				boundExpression = CreateConversionAndReportDiagnostic(node, argument, convKind, isExplicit, targetType, diagnostics, null, explicitSemanticForConcatArgument);
			}
			return boundExpression;
		}

		private static BoundNullableIsTrueOperator ApplyNullableIsTrueOperator(BoundExpression argument, TypeSymbol booleanType)
		{
			return BoundNodeExtensions.MakeCompilerGenerated(new BoundNullableIsTrueOperator(argument.Syntax, argument, booleanType));
		}

		private BoundExpression CreateConversionAndReportDiagnostic(SyntaxNode tree, BoundExpression argument, KeyValuePair<ConversionKind, MethodSymbol> convKind, bool isExplicit, TypeSymbol targetType, BindingDiagnosticBag diagnostics, string copybackConversionParamName = null, bool explicitSemanticForConcatArgument = false)
		{
			if ((!isExplicit || explicitSemanticForConcatArgument) && Conversions.IsIdentityConversion(convKind.Key))
			{
				return MakeRValue(argument, diagnostics);
			}
			if ((convKind.Key & ConversionKind.UserDefined) == 0 && ReclassifyExpression(ref argument, SyntaxKind.CTypeKeyword, tree, convKind.Key, isExplicit, targetType, diagnostics))
			{
				argument = MakeRValue(argument, diagnostics);
				if (isExplicit && argument.Syntax != tree)
				{
					argument = new BoundConversion(tree, argument, ConversionKind.Identity, CheckOverflow, isExplicit, targetType);
				}
				return argument;
			}
			if (!BoundExpressionExtensions.IsNothingLiteral(argument) && argument.Kind != BoundKind.ArrayLiteral)
			{
				argument = MakeRValue(argument, diagnostics);
			}
			TypeSymbol type = argument.Type;
			bool flag = false;
			if (argument.Kind == BoundKind.ArrayLiteral)
			{
				type = convKind.Value.Parameters[0].Type;
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
				flag = !isExplicit && Conversions.IsNarrowingConversion(convKind.Key) && Conversions.IsNarrowingConversion(Conversions.ClassifyArrayLiteralConversion((BoundArrayLiteral)argument, type, this, ref useSiteInfo));
				((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(argument.Syntax, useSiteInfo);
				if (flag)
				{
					goto IL_0481;
				}
			}
			if (!argument.HasErrors && ((object)type == null || !TypeSymbolExtensions.IsErrorType(type)))
			{
				if (Conversions.NoConversion(convKind.Key) && type.IsValueType && TypeSymbolExtensions.IsRestrictedType(type) && (TypeSymbolExtensions.IsObjectType(targetType) || targetType.SpecialType == SpecialType.System_ValueType))
				{
					ReportDiagnostic(diagnostics, argument.Syntax, ERRID.ERR_RestrictedConversion1, type);
					return new BoundConversion(tree, argument, convKind.Key, CheckOverflow, isExplicit, targetType, hasErrors: true);
				}
				WarnOnNarrowingConversionBetweenSealedClassAndAnInterface(convKind.Key, argument.Syntax, type, targetType, diagnostics);
				if (!isExplicit && Conversions.IsNarrowingConversion(convKind.Key) && (convKind.Key & ConversionKind.InvolvesNarrowingFromNumericConstant) == 0)
				{
					if (copybackConversionParamName != null)
					{
						if (OptionStrict == OptionStrict.On)
						{
							ReportDiagnostic(diagnostics, argument.Syntax, ERRID.ERR_StrictArgumentCopyBackNarrowing3, copybackConversionParamName, type, targetType);
						}
						else if (OptionStrict == OptionStrict.Custom)
						{
							ReportDiagnostic(diagnostics, argument.Syntax, ERRID.WRN_ImplicitConversionCopyBack, copybackConversionParamName, type, targetType);
						}
					}
					else if (OptionStrict == OptionStrict.On)
					{
						if (!MakeVarianceConversionSuggestion(convKind.Key, argument.Syntax, type, targetType, diagnostics, justWarn: false))
						{
							ERRID id = ERRID.ERR_NarrowingConversionDisallowed2;
							if ((convKind.Key & ConversionKind.VarianceConversionAmbiguity) != 0)
							{
								id = ERRID.ERR_AmbiguousCastConversion2;
							}
							else if ((TypeSymbolExtensions.IsMicrosoftVisualBasicCollection(type) && string.Equals(targetType.Name, "_Collection", StringComparison.Ordinal)) || (string.Equals(type.Name, "_Collection", StringComparison.Ordinal) && TypeSymbolExtensions.IsMicrosoftVisualBasicCollection(targetType)))
							{
								id = ERRID.ERR_NarrowingConversionCollection2;
							}
							ReportDiagnostic(diagnostics, argument.Syntax, id, type, targetType);
						}
					}
					else if (OptionStrict == OptionStrict.Custom && ((convKind.Key & ConversionKind.AnonymousDelegate) == 0 || (convKind.Key & ConversionKind.DelegateRelaxationLevelMask) != ConversionKind.DelegateRelaxationLevelWideningDropReturnOrArgs) && !MakeVarianceConversionSuggestion(convKind.Key, argument.Syntax, type, targetType, diagnostics, justWarn: true))
					{
						ERRID id2 = ERRID.WRN_ImplicitConversionSubst1;
						ERRID id3 = ERRID.WRN_ImplicitConversion2;
						if ((convKind.Key & ConversionKind.VarianceConversionAmbiguity) != 0)
						{
							id3 = ERRID.WRN_AmbiguousCastConversion2;
						}
						ReportDiagnostic(diagnostics, argument.Syntax, id2, ErrorFactory.ErrorInfo(id3, type, targetType));
					}
				}
				if (Conversions.NoConversion(convKind.Key))
				{
					if (Conversions.FailedDueToNumericOverflow(convKind.Key))
					{
						TypeSymbol typeSymbol = (((convKind.Key & ConversionKind.UserDefined) == 0 || (object)convKind.Value == null) ? targetType : convKind.Value.Parameters[0].Type);
						ReportDiagnostic(diagnostics, argument.Syntax, ERRID.ERR_ExpressionOverflow1, typeSymbol);
					}
					else if (isExplicit || !MakeVarianceConversionSuggestion(convKind.Key, argument.Syntax, type, targetType, diagnostics, justWarn: false))
					{
						ReportNoConversionError(argument.Syntax, type, targetType, diagnostics, copybackConversionParamName);
					}
					return new BoundConversion(tree, argument, convKind.Key & ~ConversionKind.UserDefined, CheckOverflow, isExplicit, targetType, hasErrors: true);
				}
			}
			goto IL_0481;
			IL_0481:
			if ((convKind.Key & ConversionKind.UserDefined) != 0)
			{
				return CreateUserDefinedConversion(tree, argument, convKind, isExplicit, targetType, flag, diagnostics);
			}
			if (argument.HasErrors || ((object)type != null && TypeSymbolExtensions.IsErrorType(type)))
			{
				return new BoundConversion(tree, argument, convKind.Key, CheckOverflow, isExplicit, targetType, hasErrors: true);
			}
			return CreatePredefinedConversion(tree, argument, convKind.Key, isExplicit, targetType, diagnostics);
		}

		private bool MakeVarianceConversionSuggestion(ConversionKind convKind, SyntaxNode location, TypeSymbol sourceType, TypeSymbol targetType, BindingDiagnosticBag diagnostics, bool justWarn)
		{
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
			bool result = MakeVarianceConversionSuggestion(convKind, location, sourceType, targetType, diagnostics, ref useSiteInfo, justWarn);
			diagnostics.AddDependencies(useSiteInfo);
			return result;
		}

		private bool MakeVarianceConversionSuggestion(ConversionKind convKind, SyntaxNode location, TypeSymbol sourceType, TypeSymbol targetType, BindingDiagnosticBag diagnostics, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, bool justWarn)
		{
			if ((convKind & ConversionKind.UserDefined) != 0)
			{
				return false;
			}
			if (targetType.Kind != SymbolKind.NamedType)
			{
				return false;
			}
			NamedTypeSymbol namedTypeSymbol = (NamedTypeSymbol)targetType;
			if (!namedTypeSymbol.IsGenericType)
			{
				return false;
			}
			NamedTypeSymbol originalDefinition = namedTypeSymbol.OriginalDefinition;
			if (originalDefinition.SpecialType == SpecialType.System_Collections_Generic_IList_T || originalDefinition.SpecialType == SpecialType.System_Collections_Generic_ICollection_T || originalDefinition.SpecialType == SpecialType.System_Collections_Generic_IReadOnlyList_T || originalDefinition.SpecialType == SpecialType.System_Collections_Generic_IReadOnlyCollection_T || (object)originalDefinition == Compilation.GetWellKnownType(WellKnownType.System_Collections_Generic_List_T) || (object)originalDefinition == Compilation.GetWellKnownType(WellKnownType.System_Collections_ObjectModel_Collection_T) || (object)originalDefinition == Compilation.GetWellKnownType(WellKnownType.System_Collections_ObjectModel_ReadOnlyCollection_T))
			{
				TypeSymbol typeSymbol = null;
				if (TypeSymbolExtensions.IsInterfaceType(originalDefinition))
				{
					HashSet<NamedTypeSymbol> hashSet = new HashSet<NamedTypeSymbol>();
					if (IsOrInheritsFromOrImplementsInterface(sourceType, originalDefinition, ref useSiteInfo, hashSet) && hashSet.Count == 1)
					{
						typeSymbol = hashSet.ElementAtOrDefault(0).TypeArgumentsNoUseSiteDiagnostics[0];
					}
				}
				else
				{
					TypeSymbol typeSymbol2 = sourceType;
					do
					{
						if ((object)typeSymbol2.OriginalDefinition == originalDefinition)
						{
							typeSymbol = ((NamedTypeSymbol)typeSymbol2).TypeArgumentsNoUseSiteDiagnostics[0];
							break;
						}
						typeSymbol2 = typeSymbol2.BaseTypeNoUseSiteDiagnostics;
					}
					while ((object)typeSymbol2 != null);
				}
				if ((object)typeSymbol != null && Conversions.IsWideningConversion(Conversions.Classify_Reference_Array_TypeParameterConversion(typeSymbol, namedTypeSymbol.TypeArgumentsNoUseSiteDiagnostics[0], 0, ref useSiteInfo)))
				{
					NamedTypeSymbol specialType = Compilation.GetSpecialType(SpecialType.System_Collections_Generic_IEnumerable_T);
					if (!TypeSymbolExtensions.IsErrorType(specialType))
					{
						NamedTypeSymbol namedTypeSymbol2 = specialType.Construct(namedTypeSymbol.TypeArgumentsNoUseSiteDiagnostics[0]);
						if (justWarn)
						{
							ReportDiagnostic(diagnostics, location, ERRID.WRN_ImplicitConversionSubst1, ErrorFactory.ErrorInfo(ERRID.WRN_VarianceIEnumerableSuggestion3, sourceType, targetType, namedTypeSymbol2));
						}
						else
						{
							ReportDiagnostic(diagnostics, location, ERRID.ERR_VarianceIEnumerableSuggestion3, sourceType, targetType, namedTypeSymbol2);
						}
						return true;
					}
				}
			}
			NamedTypeSymbol namedTypeSymbol3;
			switch (originalDefinition.TypeKind)
			{
			case TypeKind.Delegate:
				if ((object)sourceType.OriginalDefinition == originalDefinition)
				{
					namedTypeSymbol3 = (NamedTypeSymbol)sourceType;
					break;
				}
				return false;
			case TypeKind.Interface:
			{
				HashSet<NamedTypeSymbol> hashSet2 = new HashSet<NamedTypeSymbol>();
				if (IsOrInheritsFromOrImplementsInterface(sourceType, originalDefinition, ref useSiteInfo, hashSet2) && hashSet2.Count == 1)
				{
					namedTypeSymbol3 = hashSet2.ElementAtOrDefault(0);
					break;
				}
				return false;
			}
			default:
				return false;
			}
			NamedTypeSymbol namedTypeSymbol4 = namedTypeSymbol3;
			NamedTypeSymbol namedTypeSymbol5 = namedTypeSymbol;
			VarianceSuggestionTypeParameterInfo varianceSuggestionTypeParameterInfo = default(VarianceSuggestionTypeParameterInfo);
			TypeParameterSymbol typeParameterSymbol = null;
			TypeParameterSymbol typeParameterSymbol2 = null;
			do
			{
				ImmutableArray<TypeParameterSymbol> typeParameters = namedTypeSymbol4.TypeParameters;
				ImmutableArray<TypeSymbol> typeArgumentsNoUseSiteDiagnostics = namedTypeSymbol4.TypeArgumentsNoUseSiteDiagnostics;
				ImmutableArray<TypeSymbol> typeArgumentsNoUseSiteDiagnostics2 = namedTypeSymbol5.TypeArgumentsNoUseSiteDiagnostics;
				int num = typeParameters.Length - 1;
				for (int i = 0; i <= num; i++)
				{
					TypeSymbol typeSymbol3 = typeArgumentsNoUseSiteDiagnostics[i];
					TypeSymbol typeSymbol4 = typeArgumentsNoUseSiteDiagnostics2[i];
					if (TypeSymbolExtensions.IsSameTypeIgnoringAll(typeSymbol3, typeSymbol4) || TypeSymbolExtensions.IsErrorType(typeSymbol3) || TypeSymbolExtensions.IsErrorType(typeSymbol4))
					{
						continue;
					}
					ConversionKind conversionKind = ConversionKind.DelegateRelaxationLevelNone;
					switch (typeParameters[i].Variance)
					{
					case VarianceKind.Out:
						if (typeSymbol3.IsValueType || typeSymbol4.IsValueType)
						{
							varianceSuggestionTypeParameterInfo.Set(typeParameters[i], typeSymbol3, typeSymbol4);
							continue;
						}
						conversionKind = Conversions.Classify_Reference_Array_TypeParameterConversion(typeSymbol3, typeSymbol4, 0, ref useSiteInfo);
						if (!Conversions.IsWideningConversion(conversionKind) && (!Conversions.IsNarrowingConversion(conversionKind) || (conversionKind & ConversionKind.VarianceConversionAmbiguity) == 0))
						{
							varianceSuggestionTypeParameterInfo.Set(typeParameters[i], typeSymbol3, typeSymbol4);
						}
						continue;
					case VarianceKind.In:
						if (typeSymbol3.IsValueType || typeSymbol4.IsValueType)
						{
							varianceSuggestionTypeParameterInfo.Set(typeParameters[i], typeSymbol4, typeSymbol3);
							continue;
						}
						conversionKind = Conversions.Classify_Reference_Array_TypeParameterConversion(typeSymbol4, typeSymbol3, 0, ref useSiteInfo);
						if (!Conversions.IsWideningConversion(conversionKind) && ((TypeSymbolExtensions.IsDelegateType(namedTypeSymbol) && typeSymbol4.IsReferenceType && typeSymbol3.IsReferenceType) || !Conversions.IsNarrowingConversion(conversionKind) || (conversionKind & ConversionKind.VarianceConversionAmbiguity) == 0))
						{
							varianceSuggestionTypeParameterInfo.Set(typeParameters[i], typeSymbol4, typeSymbol3);
						}
						continue;
					}
					conversionKind = Conversions.ClassifyDirectCastConversion(typeSymbol3, typeSymbol4, ref useSiteInfo);
					if (Conversions.IsWideningConversion(conversionKind))
					{
						typeParameterSymbol = typeParameters[i];
						continue;
					}
					conversionKind = Conversions.ClassifyDirectCastConversion(typeSymbol4, typeSymbol3, ref useSiteInfo);
					if (Conversions.IsWideningConversion(conversionKind))
					{
						typeParameterSymbol2 = typeParameters[i];
						continue;
					}
					return false;
				}
				namedTypeSymbol4 = namedTypeSymbol4.ContainingType;
				namedTypeSymbol5 = namedTypeSymbol5.ContainingType;
			}
			while ((object)namedTypeSymbol4 != null);
			if (varianceSuggestionTypeParameterInfo.IsViable && (object)typeParameterSymbol == null && (object)typeParameterSymbol2 == null)
			{
				FormattedSymbol formattedSymbol = ((!TypeSymbolExtensions.IsDelegateType(varianceSuggestionTypeParameterInfo.TypeParameter.ContainingType)) ? CustomSymbolDisplayFormatter.ErrorNameWithKind(varianceSuggestionTypeParameterInfo.TypeParameter.ContainingSymbol) : CustomSymbolDisplayFormatter.DelegateSignature(varianceSuggestionTypeParameterInfo.TypeParameter.ContainingSymbol));
				if (justWarn)
				{
					ReportDiagnostic(diagnostics, location, ERRID.WRN_ImplicitConversionSubst1, ErrorFactory.ErrorInfo((varianceSuggestionTypeParameterInfo.TypeParameter.Variance == VarianceKind.Out) ? ERRID.WRN_VarianceConversionFailedOut6 : ERRID.WRN_VarianceConversionFailedIn6, varianceSuggestionTypeParameterInfo.DerivedArgument, varianceSuggestionTypeParameterInfo.BaseArgument, varianceSuggestionTypeParameterInfo.TypeParameter.Name, formattedSymbol, sourceType, targetType));
				}
				else
				{
					ReportDiagnostic(diagnostics, location, (varianceSuggestionTypeParameterInfo.TypeParameter.Variance == VarianceKind.Out) ? ERRID.ERR_VarianceConversionFailedOut6 : ERRID.ERR_VarianceConversionFailedIn6, varianceSuggestionTypeParameterInfo.DerivedArgument, varianceSuggestionTypeParameterInfo.BaseArgument, varianceSuggestionTypeParameterInfo.TypeParameter.Name, formattedSymbol, sourceType, targetType);
				}
				return true;
			}
			if (((object)typeParameterSymbol != null || (object)typeParameterSymbol2 != null) && (object)targetType.ContainingModule == Compilation.SourceModule)
			{
				TypeParameterSymbol typeParameterSymbol3 = (((object)typeParameterSymbol == null) ? typeParameterSymbol2 : typeParameterSymbol);
				FormattedSymbol formattedSymbol2 = ((!TypeSymbolExtensions.IsDelegateType(typeParameterSymbol3.ContainingType)) ? CustomSymbolDisplayFormatter.ErrorNameWithKind(typeParameterSymbol3.ContainingSymbol) : CustomSymbolDisplayFormatter.DelegateSignature(typeParameterSymbol3.ContainingSymbol));
				if (justWarn)
				{
					ReportDiagnostic(diagnostics, location, ERRID.WRN_ImplicitConversionSubst1, ErrorFactory.ErrorInfo(((object)typeParameterSymbol != null) ? ERRID.WRN_VarianceConversionFailedTryOut4 : ERRID.WRN_VarianceConversionFailedTryIn4, sourceType, targetType, typeParameterSymbol3.Name, formattedSymbol2));
				}
				else
				{
					ReportDiagnostic(diagnostics, location, ((object)typeParameterSymbol != null) ? ERRID.ERR_VarianceConversionFailedTryOut4 : ERRID.ERR_VarianceConversionFailedTryIn4, sourceType, targetType, typeParameterSymbol3.Name, formattedSymbol2);
				}
				return true;
			}
			return false;
		}

		private BoundConversion CreatePredefinedConversion(SyntaxNode tree, BoundExpression argument, ConversionKind convKind, bool isExplicit, TypeSymbol targetType, BindingDiagnosticBag diagnostics)
		{
			TypeSymbol type = argument.Type;
			if ((convKind & ConversionKind.AnonymousDelegate) != 0 && (isExplicit || OptionStrict != OptionStrict.On || Conversions.IsWideningConversion(convKind)))
			{
				BoundLambda boundLambda = null;
				BoundRValuePlaceholder relaxationReceiverPlaceholder = null;
				MethodSymbol delegateInvokeMethod = ((NamedTypeSymbol)type).DelegateInvokeMethod;
				if ((convKind & ConversionKind.NeedAStub) != 0)
				{
					Binder binder = ((!isExplicit || OptionStrict == OptionStrict.Off) ? this : new OptionStrictOffBinder(this));
					boundLambda = binder.BuildDelegateRelaxationLambda(tree, tree, argument, delegateInvokeMethod, null, QualificationKind.QualifiedViaValue, ((NamedTypeSymbol)targetType).DelegateInvokeMethod, convKind & ConversionKind.DelegateRelaxationLevelMask, isZeroArgumentKnownToBeUsed: false, warnIfResultOfAsyncMethodIsDroppedDueToRelaxation: false, diagnostics, out relaxationReceiverPlaceholder);
				}
				return new BoundConversion(tree, argument, convKind, @checked: false, isExplicit, null, (boundLambda == null) ? null : BoundNodeExtensions.MakeCompilerGenerated(new BoundRelaxationLambda(tree, boundLambda, relaxationReceiverPlaceholder)), targetType);
			}
			bool integerOverflow = false;
			ConstantValue constantValue = Conversions.TryFoldConstantConversion(argument, targetType, ref integerOverflow);
			if ((object)constantValue == null)
			{
				constantValue = Conversions.TryFoldNothingReferenceConversion(argument, convKind, targetType);
			}
			BoundConvertedTupleElements extendedInfoOpt = CreateConversionForTupleElements(tree, type, targetType, convKind, isExplicit);
			return new BoundConversion(tree, argument, convKind, CheckOverflow, isExplicit, constantValue, extendedInfoOpt, targetType);
		}

		private BoundConvertedTupleElements CreateConversionForTupleElements(SyntaxNode tree, TypeSymbol sourceType, TypeSymbol targetType, ConversionKind convKind, bool isExplicit)
		{
			if ((convKind & ConversionKind.Tuple) != 0)
			{
				ImmutableArray<TypeSymbol> elementTypesOfTupleOrCompatible = TypeSymbolExtensions.GetElementTypesOfTupleOrCompatible(TypeSymbolExtensions.GetNullableUnderlyingTypeOrSelf(sourceType));
				ImmutableArray<TypeSymbol> elementTypesOfTupleOrCompatible2 = TypeSymbolExtensions.GetElementTypesOfTupleOrCompatible(TypeSymbolExtensions.GetNullableUnderlyingTypeOrSelf(targetType));
				ArrayBuilder<BoundRValuePlaceholder> instance = ArrayBuilder<BoundRValuePlaceholder>.GetInstance(elementTypesOfTupleOrCompatible.Length);
				ArrayBuilder<BoundExpression> instance2 = ArrayBuilder<BoundExpression>.GetInstance(elementTypesOfTupleOrCompatible.Length);
				int num = elementTypesOfTupleOrCompatible.Length - 1;
				for (int i = 0; i <= num; i++)
				{
					BoundRValuePlaceholder boundRValuePlaceholder = BoundNodeExtensions.MakeCompilerGenerated(new BoundRValuePlaceholder(tree, elementTypesOfTupleOrCompatible[i]));
					instance.Add(boundRValuePlaceholder);
					instance2.Add(ApplyConversion(tree, elementTypesOfTupleOrCompatible2[i], boundRValuePlaceholder, isExplicit, BindingDiagnosticBag.Discarded));
				}
				return BoundNodeExtensions.MakeCompilerGenerated(new BoundConvertedTupleElements(tree, instance.ToImmutableAndFree(), instance2.ToImmutableAndFree()));
			}
			return null;
		}

		private BoundConversion CreateUserDefinedConversion(SyntaxNode tree, BoundExpression argument, KeyValuePair<ConversionKind, MethodSymbol> convKind, bool isExplicit, TypeSymbol targetType, bool reportArrayLiteralElementNarrowingConversion, BindingDiagnosticBag diagnostics)
		{
			OptionStrictOffBinder optionStrictOffBinder = new OptionStrictOffBinder(this);
			SyntaxNode syntax = argument.Syntax;
			TypeSymbol type = argument.Type;
			TypeSymbol type2 = convKind.Value.Parameters[0].Type;
			TypeSymbol returnType = convKind.Value.ReturnType;
			byte b = 0;
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
			ConversionKind conv;
			if (argument.Kind == BoundKind.ArrayLiteral)
			{
				BoundArrayLiteral boundArrayLiteral = (BoundArrayLiteral)argument;
				Binder binder = (reportArrayLiteralElementNarrowingConversion ? this : optionStrictOffBinder);
				conv = Conversions.ClassifyArrayLiteralConversion(boundArrayLiteral, type2, binder, ref useSiteInfo);
				argument = binder.ReclassifyArrayLiteralExpression(SyntaxKind.CTypeKeyword, tree, conv, isExplicit, boundArrayLiteral, type2, diagnostics);
				type = type2;
			}
			else
			{
				conv = Conversions.ClassifyPredefinedConversion(argument, type2, optionStrictOffBinder, ref useSiteInfo);
				if (!Conversions.IsIdentityConversion(conv))
				{
					argument = BoundNodeExtensions.MakeCompilerGenerated(optionStrictOffBinder.CreatePredefinedConversion(tree, argument, conv, isExplicit, type2, diagnostics));
					b = 1;
				}
			}
			ReportUseSite(diagnostics, tree, convKind.Value);
			ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagnostics, convKind.Value, tree);
			if ((object)ContainingMember == convKind.Value)
			{
				ReportDiagnostic(diagnostics, syntax, ERRID.WRN_RecursiveOperatorCall, convKind.Value);
			}
			argument = BoundNodeExtensions.MakeCompilerGenerated(new BoundCall(tree, convKind.Value, null, null, ImmutableArray.Create(argument), null, returnType, suppressObjectClone: true));
			conv = Conversions.ClassifyPredefinedConversion(argument, targetType, optionStrictOffBinder, ref useSiteInfo);
			if (!Conversions.IsIdentityConversion(conv))
			{
				argument = BoundNodeExtensions.MakeCompilerGenerated(optionStrictOffBinder.CreatePredefinedConversion(tree, argument, conv, isExplicit, targetType, diagnostics));
				b = (byte)(b | 2);
			}
			argument = BoundNodeExtensions.MakeCompilerGenerated(new BoundUserDefinedConversion(tree, argument, b, type));
			((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(tree, useSiteInfo);
			return new BoundConversion(tree, argument, convKind.Key, CheckOverflow, isExplicit, null, targetType);
		}

		private bool ReclassifyExpression(ref BoundExpression argument, SyntaxKind conversionSemantics, SyntaxNode tree, ConversionKind convKind, bool isExplicit, TypeSymbol targetType, BindingDiagnosticBag diagnostics)
		{
			switch (argument.Kind)
			{
			case BoundKind.Parenthesized:
				if ((object)argument.Type == null && !BoundExpressionExtensions.IsNothingLiteral(argument))
				{
					BoundParenthesized boundParenthesized = (BoundParenthesized)argument;
					BoundExpression argument2 = boundParenthesized.Expression;
					if (ReclassifyExpression(ref argument2, conversionSemantics, argument2.Syntax, convKind, isExplicit, targetType, diagnostics))
					{
						argument = boundParenthesized.Update(argument2, argument2.Type);
						return true;
					}
				}
				break;
			case BoundKind.UnboundLambda:
				argument = ReclassifyUnboundLambdaExpression((UnboundLambda)argument, conversionSemantics, tree, convKind, isExplicit, targetType, diagnostics);
				return true;
			case BoundKind.QueryLambda:
				argument = ReclassifyQueryLambdaExpression((BoundQueryLambda)argument, conversionSemantics, tree, convKind, isExplicit, targetType, diagnostics);
				return true;
			case BoundKind.LateAddressOfOperator:
			{
				BoundLateAddressOfOperator boundLateAddressOfOperator = (BoundLateAddressOfOperator)argument;
				if (targetType.TypeKind != TypeKind.Delegate && targetType.TypeKind != TypeKind.Error)
				{
					ReportDiagnostic(diagnostics, boundLateAddressOfOperator.Syntax, ERRID.ERR_AddressOfNotDelegate1, targetType);
				}
				argument = boundLateAddressOfOperator.Update(boundLateAddressOfOperator.Binder, boundLateAddressOfOperator.MemberAccess, targetType);
				return true;
			}
			case BoundKind.AddressOfOperator:
			{
				DelegateResolutionResult delegateResolutionResult = default(DelegateResolutionResult);
				BoundAddressOfOperator boundAddressOfOperator = (BoundAddressOfOperator)argument;
				if (!boundAddressOfOperator.GetDelegateResolutionResult(targetType, ref delegateResolutionResult))
				{
					break;
				}
				diagnostics.AddRange(delegateResolutionResult.Diagnostics);
				bool hasErrors = true;
				if (Conversions.ConversionExists(delegateResolutionResult.DelegateConversions))
				{
					Binder binder = ((!isExplicit || OptionStrict == OptionStrict.Off) ? this : new OptionStrictOffBinder(this));
					argument = binder.ReclassifyAddressOf(boundAddressOfOperator, ref delegateResolutionResult, targetType, diagnostics, isForHandles: false, !isExplicit && VisualBasicExtensions.Kind(tree) != SyntaxKind.ObjectCreationExpression);
					hasErrors = argument.HasErrors;
				}
				if (argument.Kind != BoundKind.DelegateCreationExpression)
				{
					switch (conversionSemantics)
					{
					case SyntaxKind.CTypeKeyword:
						argument = new BoundConversion(tree, argument, convKind, @checked: false, isExplicit, targetType, hasErrors);
						break;
					case SyntaxKind.DirectCastKeyword:
						argument = new BoundDirectCast(tree, argument, convKind, targetType, hasErrors);
						break;
					case SyntaxKind.TryCastKeyword:
						argument = new BoundTryCast(tree, argument, convKind, targetType, hasErrors);
						break;
					default:
						throw ExceptionUtilities.UnexpectedValue(conversionSemantics);
					}
				}
				return true;
			}
			case BoundKind.ArrayLiteral:
				argument = ReclassifyArrayLiteralExpression(conversionSemantics, tree, convKind, isExplicit, (BoundArrayLiteral)argument, targetType, diagnostics);
				return true;
			case BoundKind.InterpolatedStringExpression:
				argument = ReclassifyInterpolatedStringExpression(conversionSemantics, tree, convKind, isExplicit, (BoundInterpolatedStringExpression)argument, targetType, diagnostics);
				return argument.Kind == BoundKind.Conversion;
			case BoundKind.TupleLiteral:
			{
				BoundTupleLiteral boundTupleLiteral = (BoundTupleLiteral)argument;
				argument = ReclassifyTupleLiteral(convKind, tree, isExplicit, boundTupleLiteral, targetType, diagnostics);
				return argument != boundTupleLiteral;
			}
			}
			return false;
		}

		private BoundExpression ReclassifyUnboundLambdaExpression(UnboundLambda unboundLambda, SyntaxKind conversionSemantics, SyntaxNode tree, ConversionKind convKind, bool isExplicit, TypeSymbol targetType, BindingDiagnosticBag diagnostics)
		{
			if (TypeSymbolExtensions.IsStrictSupertypeOfConcreteDelegate(targetType))
			{
				BoundExpression argument = ReclassifyUnboundLambdaExpression(unboundLambda, diagnostics);
				return conversionSemantics switch
				{
					SyntaxKind.CTypeKeyword => ApplyConversion(tree, targetType, argument, isExplicit, diagnostics), 
					SyntaxKind.DirectCastKeyword => ApplyDirectCastConversion(tree, argument, targetType, diagnostics), 
					SyntaxKind.TryCastKeyword => ApplyTryCastConversion(tree, argument, targetType, diagnostics), 
					_ => throw ExceptionUtilities.UnexpectedValue(conversionSemantics), 
				};
			}
			NamedTypeSymbol namedTypeSymbol = TypeSymbolExtensions.DelegateOrExpressionDelegate(targetType, this);
			MethodSymbol methodSymbol;
			if ((object)namedTypeSymbol == null)
			{
				ReportDiagnostic(diagnostics, unboundLambda.Syntax, ERRID.ERR_LambdaNotDelegate1, targetType);
				methodSymbol = null;
			}
			else
			{
				methodSymbol = namedTypeSymbol.DelegateInvokeMethod;
				if ((object)methodSymbol == null)
				{
					ReportDiagnostic(diagnostics, unboundLambda.Syntax, ERRID.ERR_LambdaNotDelegate1, namedTypeSymbol);
					methodSymbol = null;
				}
				else if (ReportDelegateInvokeUseSite(diagnostics, unboundLambda.Syntax, namedTypeSymbol, methodSymbol))
				{
					methodSymbol = null;
				}
				else if (unboundLambda.IsInferredDelegateForThisLambda(methodSymbol.ContainingType))
				{
					ImmutableBindingDiagnostic<AssemblySymbol> value = unboundLambda.InferredAnonymousDelegate.Value;
					diagnostics.AddRange(value);
					if (!value.Diagnostics.IsDefaultOrEmpty && value.Diagnostics.HasAnyErrors())
					{
						methodSymbol = null;
					}
				}
			}
			BoundLambda boundLambda = null;
			if ((object)methodSymbol != null)
			{
				boundLambda = unboundLambda.GetBoundLambda(new UnboundLambda.TargetSignature(methodSymbol));
				if (boundLambda == null)
				{
					ReportDiagnostic(diagnostics, unboundLambda.Syntax, unboundLambda.IsFunctionLambda ? ERRID.ERR_LambdaBindingMismatch1 : ERRID.ERR_LambdaBindingMismatch2, (namedTypeSymbol.TypeKind == TypeKind.Delegate && namedTypeSymbol.IsFromCompilation(Compilation)) ? ((IFormattable)CustomSymbolDisplayFormatter.DelegateSignature(namedTypeSymbol)) : ((IFormattable)namedTypeSymbol));
				}
			}
			if (boundLambda == null)
			{
				BoundLambda operand = unboundLambda.BindForErrorRecovery();
				return conversionSemantics switch
				{
					SyntaxKind.CTypeKeyword => new BoundConversion(tree, operand, convKind, @checked: false, isExplicit, targetType, hasErrors: true), 
					SyntaxKind.DirectCastKeyword => new BoundDirectCast(tree, operand, convKind, targetType, hasErrors: true), 
					SyntaxKind.TryCastKeyword => new BoundTryCast(tree, operand, convKind, targetType, hasErrors: true), 
					_ => throw ExceptionUtilities.UnexpectedValue(conversionSemantics), 
				};
			}
			ImmutableBindingDiagnostic<AssemblySymbol> diagnostics2 = boundLambda.Diagnostics;
			bool flag = diagnostics2.Diagnostics.HasAnyErrors();
			diagnostics.AddRange(diagnostics2);
			BoundLambda boundLambda2 = null;
			if ((convKind & ConversionKind.DelegateRelaxationLevelMask) == ConversionKind.DelegateRelaxationLevelInvalid && !flag && !boundLambda.HasErrors)
			{
				if ((object)unboundLambda.ReturnType != null || unboundLambda.Flags != (SourceMemberFlags.Async | SourceMemberFlags.Iterator))
				{
					ReportDiagnostic(id: (!unboundLambda.IsFunctionLambda) ? ERRID.ERR_LambdaBindingMismatch2 : ERRID.ERR_LambdaBindingMismatch1, diagBag: diagnostics, syntax: unboundLambda.Syntax, args: new object[1] { (namedTypeSymbol.TypeKind == TypeKind.Delegate && namedTypeSymbol.IsFromCompilation(Compilation)) ? ((IFormattable)CustomSymbolDisplayFormatter.DelegateSignature(namedTypeSymbol)) : ((IFormattable)namedTypeSymbol) });
				}
			}
			else if (Conversions.IsStubRequiredForMethodConversion(boundLambda.MethodConversionKind))
			{
				LambdaSymbol lambdaSymbol = boundLambda.LambdaSymbol;
				NamedTypeSymbol namedTypeSymbol2 = ConstructAnonymousDelegateSymbol(unboundLambda, lambdaSymbol.Parameters.As<BoundLambdaParameterSymbol>(), lambdaSymbol.ReturnType, diagnostics);
				BoundConversion boundConversion = new BoundConversion(tree, boundLambda, ConversionKind.Widening | ConversionKind.Lambda, @checked: false, explicitCastInCode: false, namedTypeSymbol2);
				boundConversion.SetWasCompilerGenerated();
				BoundMethodGroup boundMethodGroup = new BoundMethodGroup(unboundLambda.Syntax, null, ImmutableArray.Create(namedTypeSymbol2.DelegateInvokeMethod), LookupResultKind.Good, boundConversion, QualificationKind.QualifiedViaValue);
				boundMethodGroup.SetWasCompilerGenerated();
				Binder binder = ((!isExplicit || OptionStrict == OptionStrict.Off) ? this : new OptionStrictOffBinder(this));
				boundLambda2 = binder.BuildDelegateRelaxationLambda(unboundLambda.Syntax, methodSymbol, boundMethodGroup, boundLambda.DelegateRelaxation, isZeroArgumentKnownToBeUsed: false, !isExplicit && VisualBasicExtensions.Kind(tree) != SyntaxKind.ObjectCreationExpression, diagnostics);
			}
			return conversionSemantics switch
			{
				SyntaxKind.CTypeKeyword => new BoundConversion(tree, boundLambda, convKind, @checked: false, isExplicit, null, (boundLambda2 == null) ? null : BoundNodeExtensions.MakeCompilerGenerated(new BoundRelaxationLambda(tree, boundLambda2, null)), targetType), 
				SyntaxKind.DirectCastKeyword => new BoundDirectCast(tree, boundLambda, convKind, boundLambda2, targetType), 
				SyntaxKind.TryCastKeyword => new BoundTryCast(tree, boundLambda, convKind, boundLambda2, targetType), 
				_ => throw ExceptionUtilities.UnexpectedValue(conversionSemantics), 
			};
		}

		private BoundExpression ReclassifyQueryLambdaExpression(BoundQueryLambda lambda, SyntaxKind conversionSemantics, SyntaxNode tree, ConversionKind convKind, bool isExplicit, TypeSymbol targetType, BindingDiagnosticBag diagnostics)
		{
			NamedTypeSymbol namedTypeSymbol = TypeSymbolExtensions.DelegateOrExpressionDelegate(targetType, this);
			if (Conversions.NoConversion(convKind))
			{
				if (TypeSymbolExtensions.IsStrictSupertypeOfConcreteDelegate(targetType) && !TypeSymbolExtensions.IsObjectType(targetType))
				{
					ReportDiagnostic(diagnostics, lambda.Syntax, ERRID.ERR_LambdaNotCreatableDelegate1, targetType);
				}
				else if ((object)namedTypeSymbol == null)
				{
					ReportDiagnostic(diagnostics, lambda.Syntax, ERRID.ERR_LambdaNotDelegate1, targetType);
				}
				else
				{
					MethodSymbol delegateInvokeMethod = namedTypeSymbol.DelegateInvokeMethod;
					if ((object)delegateInvokeMethod == null)
					{
						ReportDiagnostic(diagnostics, lambda.Syntax, ERRID.ERR_LambdaNotDelegate1, namedTypeSymbol);
					}
					else if (!ReportDelegateInvokeUseSite(diagnostics, lambda.Syntax, namedTypeSymbol, delegateInvokeMethod))
					{
						if ((object)lambda.LambdaSymbol.ReturnType == LambdaSymbol.ReturnTypePendingDelegate && !delegateInvokeMethod.IsSub && Conversions.FailedDueToQueryLambdaBodyMismatch(convKind))
						{
							lambda = lambda.Update(lambda.LambdaSymbol, lambda.RangeVariables, ApplyImplicitConversion(lambda.Expression.Syntax, delegateInvokeMethod.ReturnType, lambda.Expression, diagnostics, TypeSymbolExtensions.IsBooleanType(delegateInvokeMethod.ReturnType) && lambda.ExprIsOperandOfConditionalBranch), exprIsOperandOfConditionalBranch: false);
						}
						else
						{
							ReportDiagnostic(diagnostics, lambda.Syntax, ERRID.ERR_LambdaBindingMismatch1, namedTypeSymbol);
						}
					}
				}
				return conversionSemantics switch
				{
					SyntaxKind.CTypeKeyword => BoundNodeExtensions.MakeCompilerGenerated(new BoundConversion(tree, lambda, convKind, @checked: false, isExplicit, targetType, hasErrors: true)), 
					SyntaxKind.DirectCastKeyword => BoundNodeExtensions.MakeCompilerGenerated(new BoundDirectCast(tree, lambda, convKind, targetType, hasErrors: true)), 
					SyntaxKind.TryCastKeyword => BoundNodeExtensions.MakeCompilerGenerated(new BoundTryCast(tree, lambda, convKind, targetType, hasErrors: true)), 
					_ => throw ExceptionUtilities.UnexpectedValue(conversionSemantics), 
				};
			}
			MethodSymbol delegateInvokeMethod2 = namedTypeSymbol.DelegateInvokeMethod;
			ImmutableArray<ParameterSymbol>.Enumerator enumerator = delegateInvokeMethod2.Parameters.GetEnumerator();
			while (enumerator.MoveNext())
			{
				ParameterSymbol current = enumerator.Current;
				if (current.IsByRef || TypeSymbolExtensions.IsTypeParameter(current.OriginalDefinition.Type))
				{
					TypeSymbol restrictedType = null;
					if (TypeSymbolExtensions.IsRestrictedTypeOrArrayType(current.Type, out restrictedType))
					{
						ReportDiagnostic(diagnostics, lambda.LambdaSymbol.Parameters[current.Ordinal].Locations[0], ERRID.ERR_RestrictedType1, restrictedType);
					}
				}
			}
			TypeSymbol returnType = delegateInvokeMethod2.ReturnType;
			if (TypeSymbolExtensions.IsTypeParameter(delegateInvokeMethod2.OriginalDefinition.ReturnType))
			{
				TypeSymbol restrictedType2 = null;
				if (TypeSymbolExtensions.IsRestrictedTypeOrArrayType(returnType, out restrictedType2))
				{
					SyntaxNode syntaxNode = ((lambda.Expression.Kind != BoundKind.RangeVariableAssignment) ? lambda.Expression.Syntax : ((BoundRangeVariableAssignment)lambda.Expression).Value.Syntax);
					ReportDiagnostic(diagnostics, syntaxNode, ERRID.ERR_RestrictedType1, restrictedType2);
				}
			}
			lambda = (((object)lambda.LambdaSymbol.ReturnType != LambdaSymbol.ReturnTypePendingDelegate) ? lambda.Update(lambda.LambdaSymbol, lambda.RangeVariables, lambda.Expression, exprIsOperandOfConditionalBranch: false) : lambda.Update(lambda.LambdaSymbol, lambda.RangeVariables, ApplyImplicitConversion(lambda.Expression.Syntax, returnType, lambda.Expression, diagnostics, TypeSymbolExtensions.IsBooleanType(returnType) && lambda.ExprIsOperandOfConditionalBranch), exprIsOperandOfConditionalBranch: false));
			return conversionSemantics switch
			{
				SyntaxKind.CTypeKeyword => BoundNodeExtensions.MakeCompilerGenerated(new BoundConversion(tree, lambda, convKind, @checked: false, isExplicit, targetType)), 
				SyntaxKind.DirectCastKeyword => BoundNodeExtensions.MakeCompilerGenerated(new BoundDirectCast(tree, lambda, convKind, targetType)), 
				SyntaxKind.TryCastKeyword => BoundNodeExtensions.MakeCompilerGenerated(new BoundTryCast(tree, lambda, convKind, targetType)), 
				_ => throw ExceptionUtilities.UnexpectedValue(conversionSemantics), 
			};
		}

		private BoundExpression ReclassifyInterpolatedStringExpression(SyntaxKind conversionSemantics, SyntaxNode tree, ConversionKind convKind, bool isExplicit, BoundInterpolatedStringExpression node, TypeSymbol targetType, BindingDiagnosticBag diagnostics)
		{
			if ((convKind & ConversionKind.InterpolatedString) == ConversionKind.InterpolatedString)
			{
				return new BoundConversion(tree, node, ConversionKind.InterpolatedString, @checked: false, isExplicit, targetType);
			}
			return node;
		}

		private BoundExpression ReclassifyTupleLiteral(ConversionKind convKind, SyntaxNode tree, bool isExplicit, BoundTupleLiteral sourceTuple, TypeSymbol destination, BindingDiagnosticBag diagnostics)
		{
			bool num = (convKind & ConversionKind.Nullable) != 0;
			TypeSymbol typeSymbol = destination;
			if (num)
			{
				typeSymbol = TypeSymbolExtensions.GetNullableUnderlyingType(destination);
			}
			ImmutableArray<BoundExpression> arguments = sourceTuple.Arguments;
			if (!typeSymbol.IsTupleOrCompatibleWithTupleOfCardinality(arguments.Length))
			{
				return sourceTuple;
			}
			if (typeSymbol.IsTupleType)
			{
				TupleTypeSymbol obj = (TupleTypeSymbol)typeSymbol;
				TupleTypeSymbol.ReportNamesMismatchesIfAny(typeSymbol, sourceTuple, diagnostics);
				typeSymbol = obj.WithElementNames(sourceTuple.ArgumentNamesOpt);
			}
			ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance(arguments.Length);
			ImmutableArray<TypeSymbol> elementTypesOfTupleOrCompatible = TypeSymbolExtensions.GetElementTypesOfTupleOrCompatible(typeSymbol);
			int num2 = arguments.Length - 1;
			for (int i = 0; i <= num2; i++)
			{
				BoundExpression boundExpression = arguments[i];
				TypeSymbol targetType = elementTypesOfTupleOrCompatible[i];
				instance.Add(ApplyConversion(boundExpression.Syntax, targetType, boundExpression, isExplicit, diagnostics));
			}
			BoundExpression boundExpression2 = new BoundConvertedTupleLiteral(sourceTuple.Syntax, sourceTuple.Type, instance.ToImmutableAndFree(), typeSymbol);
			if (!TypeSymbol.Equals(sourceTuple.Type, destination, TypeCompareKind.ConsiderEverything) && convKind != 0)
			{
				boundExpression2 = new BoundConversion(sourceTuple.Syntax, boundExpression2, convKind, @checked: false, isExplicit, destination);
			}
			if (isExplicit)
			{
				boundExpression2 = new BoundConversion(tree, boundExpression2, ConversionKind.Identity, @checked: false, isExplicit, destination);
			}
			return boundExpression2;
		}

		private void WarnOnNarrowingConversionBetweenSealedClassAndAnInterface(ConversionKind convKind, SyntaxNode location, TypeSymbol sourceType, TypeSymbol targetType, BindingDiagnosticBag diagnostics)
		{
			if (!Conversions.IsNarrowingConversion(convKind))
			{
				return;
			}
			TypeSymbol typeSymbol = null;
			NamedTypeSymbol namedTypeSymbol = null;
			if (TypeSymbolExtensions.IsInterfaceType(sourceType))
			{
				if (TypeSymbolExtensions.IsClassType(targetType))
				{
					typeSymbol = sourceType;
					namedTypeSymbol = (NamedTypeSymbol)targetType;
				}
			}
			else if (TypeSymbolExtensions.IsClassType(sourceType) && TypeSymbolExtensions.IsInterfaceType(targetType))
			{
				typeSymbol = targetType;
				namedTypeSymbol = (NamedTypeSymbol)sourceType;
			}
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
			if ((object)namedTypeSymbol != null && (object)typeSymbol != null && namedTypeSymbol.IsNotInheritable && !namedTypeSymbol.IsComImport && !Conversions.IsWideningConversion(Conversions.ClassifyDirectCastConversion(namedTypeSymbol, typeSymbol, ref useSiteInfo)))
			{
				if (targetType.SpecialType == SpecialType.System_String && IsIEnumerableOfXElement(sourceType, ref useSiteInfo))
				{
					ReportDiagnostic(diagnostics, location, ERRID.WRN_UseValueForXmlExpression3, sourceType, targetType, sourceType);
				}
				else
				{
					ReportDiagnostic(diagnostics, location, ERRID.WRN_InterfaceConversion2, sourceType, targetType);
				}
			}
			diagnostics.AddDependencies(useSiteInfo);
		}

		private bool IsIEnumerableOfXElement(TypeSymbol type, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			return TypeSymbolExtensions.IsOrImplementsIEnumerableOfXElement(type, Compilation, ref useSiteInfo);
		}

		private void ReportNoConversionError(SyntaxNode location, TypeSymbol sourceType, TypeSymbol targetType, BindingDiagnosticBag diagnostics, string copybackConversionParamName = null)
		{
			if (TypeSymbolExtensions.IsArrayType(sourceType) && TypeSymbolExtensions.IsArrayType(targetType))
			{
				ArrayTypeSymbol arrayTypeSymbol = (ArrayTypeSymbol)sourceType;
				ArrayTypeSymbol arrayTypeSymbol2 = (ArrayTypeSymbol)targetType;
				TypeSymbol elementType = arrayTypeSymbol.ElementType;
				TypeSymbol elementType2 = arrayTypeSymbol2.ElementType;
				if (arrayTypeSymbol.Rank != arrayTypeSymbol2.Rank)
				{
					ReportDiagnostic(diagnostics, location, ERRID.ERR_ConvertArrayRankMismatch2, sourceType, targetType);
				}
				else if (arrayTypeSymbol.IsSZArray != arrayTypeSymbol2.IsSZArray)
				{
					ReportDiagnostic(diagnostics, location, ERRID.ERR_TypeMismatch2, sourceType, targetType);
				}
				else if (!TypeSymbolExtensions.IsErrorType(elementType) && !TypeSymbolExtensions.IsErrorType(elementType2))
				{
					CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
					ConversionKind conversionKind = Conversions.ClassifyDirectCastConversion(elementType, elementType2, ref useSiteInfo);
					if (!Conversions.IsIdentityConversion(conversionKind) && (TypeSymbolExtensions.IsObjectType(elementType2) || elementType2.SpecialType == SpecialType.System_ValueType) && !elementType.IsReferenceType)
					{
						ReportDiagnostic(diagnostics, location, ERRID.ERR_ConvertObjectArrayMismatch3, sourceType, targetType, elementType);
					}
					else if (!Conversions.IsIdentityConversion(conversionKind) && (!Conversions.IsWideningConversion(conversionKind) || (conversionKind & (ConversionKind.Reference | ConversionKind.TypeParameter | ConversionKind.Value)) == 0))
					{
						ReportDiagnostic(diagnostics, location, ERRID.ERR_ConvertArrayMismatch4, sourceType, targetType, elementType, elementType2);
					}
					else
					{
						ReportDiagnostic(diagnostics, location, ERRID.ERR_TypeMismatch2, sourceType, targetType);
					}
				}
				return;
			}
			if (TypeSymbolExtensions.IsDateTimeType(sourceType) && TypeSymbolExtensions.IsDoubleType(targetType))
			{
				ReportDiagnostic(diagnostics, location, ERRID.ERR_DateToDoubleConversion);
				return;
			}
			if (TypeSymbolExtensions.IsDateTimeType(targetType) && TypeSymbolExtensions.IsDoubleType(sourceType))
			{
				ReportDiagnostic(diagnostics, location, ERRID.ERR_DoubleToDateConversion);
				return;
			}
			if (TypeSymbolExtensions.IsCharType(targetType) && TypeSymbolExtensions.IsIntegralType(sourceType))
			{
				ReportDiagnostic(diagnostics, location, ERRID.ERR_IntegralToCharTypeMismatch1, sourceType);
				return;
			}
			if (TypeSymbolExtensions.IsCharType(sourceType) && TypeSymbolExtensions.IsIntegralType(targetType))
			{
				ReportDiagnostic(diagnostics, location, ERRID.ERR_CharToIntegralTypeMismatch1, targetType);
				return;
			}
			if (copybackConversionParamName != null)
			{
				ReportDiagnostic(diagnostics, location, ERRID.ERR_CopyBackTypeMismatch3, copybackConversionParamName, sourceType, targetType);
				return;
			}
			if (TypeSymbolExtensions.IsInterfaceType(sourceType) && targetType.IsValueType)
			{
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
				if (IsIEnumerableOfXElement(sourceType, ref useSiteInfo))
				{
					ReportDiagnostic(diagnostics, location, ERRID.ERR_TypeMismatchForXml3, sourceType, targetType, sourceType);
					return;
				}
			}
			ReportDiagnostic(diagnostics, location, ERRID.ERR_TypeMismatch2, sourceType, targetType);
		}

		private BoundExpression BindAddressOfExpression(VisualBasicSyntaxNode node, BindingDiagnosticBag diagnostics)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax unaryExpressionSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax)node;
			BoundExpression boundExpression = BindExpression(unaryExpressionSyntax.Operand, isInvocationOrAddressOf: true, isOperandOfConditionalBranch: false, eventContext: false, diagnostics);
			if (boundExpression.Kind == BoundKind.LateMemberAccess)
			{
				return new BoundLateAddressOfOperator(node, this, (BoundLateMemberAccess)boundExpression, boundExpression.Type);
			}
			if (boundExpression.Kind != BoundKind.MethodGroup)
			{
				if (!boundExpression.HasErrors)
				{
					ReportDiagnostic(diagnostics, unaryExpressionSyntax.Operand, ERRID.ERR_AddressOfOperandNotMethod);
				}
				return BadExpression(unaryExpressionSyntax, boundExpression, LookupResultKind.NotAValue, ErrorTypeSymbol.UnknownResultType);
			}
			bool hasErrors = false;
			BoundMethodGroup boundMethodGroup = (BoundMethodGroup)boundExpression;
			if (IsGroupOfConstructors(boundMethodGroup))
			{
				ReportDiagnostic(diagnostics, unaryExpressionSyntax.Operand, ERRID.ERR_InvalidConstructorCall);
				hasErrors = true;
			}
			return new BoundAddressOfOperator(node, this, diagnostics.AccumulatesDependencies, boundMethodGroup, hasErrors);
		}

		private BoundExpression BindDelegateCreationExpression(TypeSymbol delegateType, Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax argumentListOpt, VisualBasicSyntaxNode node, BindingDiagnosticBag diagnostics)
		{
			BoundExpression boundExpression = null;
			int num = 0;
			if (argumentListOpt != null)
			{
				num = argumentListOpt.Arguments.Count;
			}
			bool flag = false;
			if (num > 0)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax argumentSyntax = argumentListOpt.Arguments[0];
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expressionSyntax = null;
				if (argumentSyntax.Kind() == SyntaxKind.SimpleArgument)
				{
					expressionSyntax = argumentSyntax.GetExpression();
				}
				if (expressionSyntax != null)
				{
					if (expressionSyntax.Kind() == SyntaxKind.AddressOfExpression)
					{
						boundExpression = BindAddressOfExpression(expressionSyntax, diagnostics);
					}
					else if (SyntaxNodeExtensions.IsLambdaExpressionSyntax(expressionSyntax))
					{
						boundExpression = BindExpression(expressionSyntax, diagnostics);
					}
					if (boundExpression != null)
					{
						flag = boundExpression.HasErrors;
						if (num == 1)
						{
							boundExpression = ApplyImplicitConversion(node, delegateType, boundExpression, diagnostics);
							if (boundExpression.Syntax != node)
							{
								boundExpression = new BoundConversion(node, boundExpression, ConversionKind.Identity, CheckOverflow, explicitCastInCode: true, delegateType);
							}
							else if (boundExpression.Kind == BoundKind.Conversion)
							{
								BoundConversion boundConversion = (BoundConversion)boundExpression;
								boundExpression = boundConversion.Update(boundConversion.Operand, boundConversion.ConversionKind, boundConversion.Checked, explicitCastInCode: true, boundConversion.ConstantValueOpt, boundConversion.ExtendedInfoOpt, boundConversion.Type);
							}
							return boundExpression;
						}
					}
				}
				else
				{
					boundExpression = new BoundBadExpression(argumentSyntax, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, ImmutableArray<BoundExpression>.Empty, ErrorTypeSymbol.UnknownResultType, hasErrors: true);
				}
			}
			BoundExpression[] array = new BoundExpression[num - 1 + 1];
			if (boundExpression != null)
			{
				boundExpression = (array[0] = MakeRValueAndIgnoreDiagnostics(boundExpression));
			}
			bool num2 = boundExpression != null;
			int num3 = num - 1;
			for (int i = (num2 ? 1 : 0); i <= num3; i++)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expressionSyntax2 = null;
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax argumentSyntax2 = argumentListOpt.Arguments[i];
				if (argumentSyntax2.Kind() == SyntaxKind.SimpleArgument)
				{
					expressionSyntax2 = argumentSyntax2.GetExpression();
				}
				if (expressionSyntax2 != null)
				{
					array[i] = BindValue(expressionSyntax2, BindingDiagnosticBag.Discarded);
				}
				else
				{
					array[i] = new BoundBadExpression(argumentSyntax2, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, ImmutableArray<BoundExpression>.Empty, ErrorTypeSymbol.UnknownResultType, hasErrors: true);
				}
			}
			if (!flag || num != 1)
			{
				ReportDiagnostic(diagnostics, argumentListOpt ?? node, ERRID.ERR_NoDirectDelegateConstruction1, delegateType);
			}
			return BadExpression(node, ImmutableArray.Create(array), delegateType);
		}

		internal static DelegateResolutionResult InterpretDelegateBinding(BoundAddressOfOperator addressOfExpression, TypeSymbol targetType, bool isForHandles)
		{
			BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(withDiagnostics: true, addressOfExpression.WithDependencies);
			MethodSymbol methodSymbol = null;
			SyntaxNode syntax = addressOfExpression.Syntax;
			MethodConversionKind methodConversionKind = MethodConversionKind.Identity;
			if (targetType.SpecialType == SpecialType.System_Delegate || targetType.SpecialType == SpecialType.System_MulticastDelegate)
			{
				ReportDiagnostic(instance, syntax, ERRID.ERR_AddressOfNotCreatableDelegate1, targetType);
				methodConversionKind |= MethodConversionKind.Error_Unspecified;
			}
			else if (targetType.TypeKind != TypeKind.Delegate)
			{
				if (targetType.TypeKind != TypeKind.Error)
				{
					ReportDiagnostic(instance, syntax, ERRID.ERR_AddressOfNotDelegate1, targetType);
				}
				methodConversionKind |= MethodConversionKind.Error_Unspecified;
			}
			else
			{
				MethodSymbol delegateInvokeMethod = ((NamedTypeSymbol)targetType).DelegateInvokeMethod;
				if ((object)delegateInvokeMethod != null)
				{
					if (ReportDelegateInvokeUseSite(instance, syntax, targetType, delegateInvokeMethod))
					{
						methodConversionKind |= MethodConversionKind.Error_Unspecified;
					}
					else
					{
						KeyValuePair<MethodSymbol, MethodConversionKind> keyValuePair = ResolveMethodForDelegateInvokeFullAndRelaxed(addressOfExpression, delegateInvokeMethod, ignoreMethodReturnType: false, instance);
						methodSymbol = keyValuePair.Key;
						methodConversionKind = keyValuePair.Value;
					}
				}
				else
				{
					ReportDiagnostic(instance, syntax, ERRID.ERR_UnsupportedMethod1, targetType);
					methodConversionKind |= MethodConversionKind.Error_Unspecified;
				}
			}
			if ((object)methodSymbol != null)
			{
				Binder binder = addressOfExpression.Binder;
				SyntaxNode syntax2 = addressOfExpression.Syntax;
				bool isShared = methodSymbol.IsShared;
				BoundExpression receiver = addressOfExpression.MethodGroup.ReceiverOpt;
				if (binder.CheckSharedSymbolAccess(syntax2, isShared, ref receiver, addressOfExpression.MethodGroup.QualificationKind, instance))
				{
					methodConversionKind |= MethodConversionKind.Error_Unspecified;
				}
			}
			BoundExpression receiverOpt = addressOfExpression.MethodGroup.ReceiverOpt;
			if ((object)methodSymbol != null)
			{
				if (methodSymbol.IsMustOverride && receiverOpt != null && (BoundExpressionExtensions.IsMyBaseReference(receiverOpt) || BoundExpressionExtensions.IsMyClassReference(receiverOpt)))
				{
					ReportDiagnostic(instance, addressOfExpression.MethodGroup.Syntax, BoundExpressionExtensions.IsMyBaseReference(receiverOpt) ? ERRID.ERR_MyBaseAbstractCall1 : ERRID.ERR_MyClassAbstractCall1, methodSymbol);
					methodConversionKind |= MethodConversionKind.Error_Unspecified;
				}
				if (!methodSymbol.IsShared && TypeSymbolExtensions.IsNullableType(methodSymbol.ContainingType) && !methodSymbol.IsOverrides)
				{
					SyntaxNode syntaxNode = addressOfExpression.Syntax;
					Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax unaryExpressionSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax)addressOfExpression.Syntax;
					if (unaryExpressionSyntax != null)
					{
						syntaxNode = unaryExpressionSyntax.Operand;
					}
					ReportDiagnostic(instance, syntaxNode, ERRID.ERR_AddressOfNullableMethod, methodSymbol.ContainingType, SyntaxFacts.GetText(SyntaxKind.AddressOfKeyword));
					methodConversionKind |= MethodConversionKind.Error_Unspecified;
				}
				addressOfExpression.Binder.ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(instance, methodSymbol, addressOfExpression.MethodGroup.Syntax);
			}
			ConversionKind conversionKind = Conversions.DetermineDelegateRelaxationLevel(methodConversionKind);
			if ((conversionKind & ConversionKind.DelegateRelaxationLevelInvalid) != ConversionKind.DelegateRelaxationLevelInvalid)
			{
				conversionKind = ((!Conversions.IsNarrowingMethodConversion(methodConversionKind, !isForHandles)) ? (conversionKind | ConversionKind.Widening) : (conversionKind | ConversionKind.Narrowing));
			}
			return new DelegateResolutionResult(conversionKind, methodSymbol, methodConversionKind, instance.ToReadOnlyAndFree());
		}

		internal static bool ReportDelegateInvokeUseSite(BindingDiagnosticBag diagBag, SyntaxNode syntax, TypeSymbol delegateType, MethodSymbol invoke)
		{
			UseSiteInfo<AssemblySymbol> useSiteInfo = invoke.GetUseSiteInfo();
			DiagnosticInfo? diagnosticInfo = useSiteInfo.DiagnosticInfo;
			if (diagnosticInfo != null && diagnosticInfo!.Code == 30657)
			{
				useSiteInfo = new UseSiteInfo<AssemblySymbol>(ErrorFactory.ErrorInfo(ERRID.ERR_UnsupportedMethod1, delegateType));
			}
			return diagBag.Add(useSiteInfo, syntax);
		}

		internal static KeyValuePair<MethodSymbol, MethodConversionKind> ResolveMethodForDelegateInvokeFullAndRelaxed(BoundAddressOfOperator addressOfExpression, MethodSymbol toMethod, bool ignoreMethodReturnType, BindingDiagnosticBag diagnostics)
		{
			BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(diagnostics);
			bool couldTryZeroArgumentRelaxation = true;
			KeyValuePair<MethodSymbol, MethodConversionKind> keyValuePair = ResolveMethodForDelegateInvokeFullOrRelaxed(addressOfExpression, toMethod, ignoreMethodReturnType, instance, useZeroArgumentRelaxation: false, ref couldTryZeroArgumentRelaxation);
			if ((object)keyValuePair.Key == null && couldTryZeroArgumentRelaxation)
			{
				BindingDiagnosticBag instance2 = BindingDiagnosticBag.GetInstance(diagnostics);
				KeyValuePair<MethodSymbol, MethodConversionKind> keyValuePair2 = keyValuePair;
				keyValuePair = ResolveMethodForDelegateInvokeFullOrRelaxed(addressOfExpression, toMethod, ignoreMethodReturnType, instance2, useZeroArgumentRelaxation: true, ref couldTryZeroArgumentRelaxation);
				if ((object)keyValuePair.Key == null)
				{
					diagnostics.AddRange(instance);
					keyValuePair = keyValuePair2;
				}
				else
				{
					diagnostics.AddRange(instance2);
				}
				instance2.Free();
			}
			else
			{
				diagnostics.AddRange(instance);
			}
			instance.Free();
			return keyValuePair;
		}

		private static KeyValuePair<MethodSymbol, MethodConversionKind> ResolveMethodForDelegateInvokeFullOrRelaxed(BoundAddressOfOperator addressOfExpression, MethodSymbol toMethod, bool ignoreMethodReturnType, BindingDiagnosticBag diagnostics, bool useZeroArgumentRelaxation, ref bool couldTryZeroArgumentRelaxation)
		{
			ImmutableArray<BoundExpression> immutableArray = ImmutableArray<BoundExpression>.Empty;
			if (!useZeroArgumentRelaxation)
			{
				ImmutableArray<ParameterSymbol> parameters = toMethod.Parameters;
				int length = parameters.Length;
				if (length > 0)
				{
					BoundExpression[] array = new BoundExpression[length - 1 + 1];
					int num = 0;
					SyntaxNode syntax = addressOfExpression.Syntax;
					_ = addressOfExpression.Binder.SyntaxTree;
					ImmutableArray<ParameterSymbol>.Enumerator enumerator = parameters.GetEnumerator();
					while (enumerator.MoveNext())
					{
						ParameterSymbol current = enumerator.Current;
						TypeSymbol type = current.Type;
						SynthesizedLocal localSymbol = new SynthesizedLocal(toMethod, type, SynthesizedLocalKind.LoweringTemp);
						BoundExpression boundExpression = new BoundLocal(syntax, localSymbol, type);
						if (!current.IsByRef)
						{
							boundExpression = boundExpression.MakeRValue();
						}
						array[num] = boundExpression;
						num++;
					}
					immutableArray = array.AsImmutableOrNull();
				}
				else
				{
					couldTryZeroArgumentRelaxation = false;
				}
			}
			TypeSymbol delegateReturnType;
			BoundNode delegateReturnTypeReferenceBoundNode;
			if (ignoreMethodReturnType)
			{
				delegateReturnType = null;
				delegateReturnTypeReferenceBoundNode = null;
			}
			else
			{
				delegateReturnType = toMethod.ReturnType;
				delegateReturnTypeReferenceBoundNode = addressOfExpression;
			}
			Binder binder = ((addressOfExpression.Binder.OptionStrict == OptionStrict.Off) ? addressOfExpression.Binder : new OptionStrictOffBinder(addressOfExpression.Binder));
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = addressOfExpression.Binder.GetNewCompoundUseSiteInfo(diagnostics);
			OverloadResolution.OverloadResolutionResult results = OverloadResolution.MethodInvocationOverloadResolution(addressOfExpression.MethodGroup, immutableArray, default(ImmutableArray<string>), binder, null, ref useSiteInfo, includeEliminatedCandidates: false, delegateReturnType, delegateReturnTypeReferenceBoundNode, lateBindingIsAllowed: false);
			if (diagnostics.Add(addressOfExpression.MethodGroup, useSiteInfo))
			{
				couldTryZeroArgumentRelaxation = false;
				if (addressOfExpression.MethodGroup.ResultKind != LookupResultKind.Inaccessible)
				{
					diagnostics = BindingDiagnosticBag.Discarded;
				}
			}
			BoundMethodGroup methodGroup = addressOfExpression.MethodGroup;
			if (results.BestResult.HasValue)
			{
				return ValidateMethodForDelegateInvoke(addressOfExpression, results.BestResult.Value, toMethod, ignoreMethodReturnType, useZeroArgumentRelaxation, diagnostics);
			}
			if (results.Candidates.Length == 0)
			{
				results = OverloadResolution.MethodInvocationOverloadResolution(methodGroup, immutableArray, default(ImmutableArray<string>), binder, null, ref useSiteInfo, includeEliminatedCandidates: true, delegateReturnType, delegateReturnTypeReferenceBoundNode, lateBindingIsAllowed: false);
			}
			ArrayBuilder<OverloadResolution.CandidateAnalysisResult> instance = ArrayBuilder<OverloadResolution.CandidateAnalysisResult>.GetInstance();
			ImmutableArray<Symbol> bestSymbols = ImmutableArray<Symbol>.Empty;
			TypeSymbol setOfTheBestCandidates = GetSetOfTheBestCandidates(ref results, instance, ref bestSymbols);
			OverloadResolution.CandidateAnalysisResultState state = instance[0].State;
			if (state == OverloadResolution.CandidateAnalysisResultState.Applicable && !instance[0].RequiresNarrowingConversion)
			{
				couldTryZeroArgumentRelaxation = false;
			}
			if (bestSymbols.Length == 1 && (state == OverloadResolution.CandidateAnalysisResultState.ArgumentCountMismatch || state == OverloadResolution.CandidateAnalysisResultState.ArgumentMismatch))
			{
				SyntaxNode syntaxNode = addressOfExpression.Syntax;
				if (VisualBasicExtensions.Kind(syntaxNode) == SyntaxKind.AddressOfExpression)
				{
					syntaxNode = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax)syntaxNode).Operand;
				}
				if (addressOfExpression.MethodGroup.ResultKind == LookupResultKind.Inaccessible)
				{
					ReportDiagnostic(diagnostics, syntaxNode, addressOfExpression.Binder.GetInaccessibleErrorInfo(bestSymbols[0]));
				}
				ReportDelegateBindingIncompatible(syntaxNode, toMethod.ContainingType, (MethodSymbol)bestSymbols[0], diagnostics);
			}
			else
			{
				if (state == OverloadResolution.CandidateAnalysisResultState.HasUseSiteError || state == OverloadResolution.CandidateAnalysisResultState.HasUnsupportedMetadata || state == OverloadResolution.CandidateAnalysisResultState.Ambiguous)
				{
					couldTryZeroArgumentRelaxation = false;
				}
				binder.ReportOverloadResolutionFailureAndProduceBoundNode(addressOfExpression.MethodGroup.Syntax, methodGroup, instance, bestSymbols, setOfTheBestCandidates, immutableArray, default(ImmutableArray<string>), diagnostics, null, toMethod.ContainingType);
			}
			instance.Free();
			return new KeyValuePair<MethodSymbol, MethodConversionKind>(null, MethodConversionKind.Error_OverloadResolution);
		}

		private static KeyValuePair<MethodSymbol, MethodConversionKind> ValidateMethodForDelegateInvoke(BoundAddressOfOperator addressOfExpression, OverloadResolution.CandidateAnalysisResult analysisResult, MethodSymbol toMethod, bool ignoreMethodReturnType, bool useZeroArgumentRelaxation, BindingDiagnosticBag diagnostics)
		{
			MethodConversionKind methodConversionKind = MethodConversionKind.Identity;
			SyntaxNode syntaxNode = addressOfExpression.Syntax;
			if (VisualBasicExtensions.Kind(syntaxNode) == SyntaxKind.AddressOfExpression)
			{
				syntaxNode = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax)syntaxNode).Operand;
			}
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = addressOfExpression.Binder.GetNewCompoundUseSiteInfo(diagnostics);
			MethodSymbol methodSymbol = (MethodSymbol)analysisResult.Candidate.UnderlyingSymbol;
			if (!ignoreMethodReturnType)
			{
				methodConversionKind |= Conversions.ClassifyMethodConversionBasedOnReturn(methodSymbol.ReturnType, methodSymbol.ReturnsByRef, toMethod.ReturnType, toMethod.ReturnsByRef, ref useSiteInfo);
				if (((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(syntaxNode, useSiteInfo))
				{
					diagnostics = BindingDiagnosticBag.Discarded;
				}
			}
			if (useZeroArgumentRelaxation)
			{
				methodConversionKind = ((methodSymbol.ParameterCount != 0) ? (methodConversionKind | MethodConversionKind.Error_IllegalToIgnoreAllArguments) : (methodConversionKind | MethodConversionKind.AllArgumentsIgnored));
			}
			else
			{
				methodConversionKind |= GetDelegateMethodConversionBasedOnArguments(analysisResult, toMethod, ref useSiteInfo);
				if (((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(syntaxNode, useSiteInfo))
				{
					diagnostics = BindingDiagnosticBag.Discarded;
				}
			}
			if (!ignoreMethodReturnType && methodSymbol.ReturnsByRef && Conversions.IsDelegateRelaxationSupportedFor(methodConversionKind) && Conversions.IsStubRequiredForMethodConversion(methodConversionKind))
			{
				methodConversionKind |= MethodConversionKind.Error_StubNotSupported;
			}
			KeyValuePair<MethodSymbol, MethodConversionKind> result;
			if (Conversions.IsDelegateRelaxationSupportedFor(methodConversionKind))
			{
				BindingDiagnosticBag typeArgumentInferenceDiagnosticsOpt = analysisResult.TypeArgumentInferenceDiagnosticsOpt;
				if (typeArgumentInferenceDiagnosticsOpt != null)
				{
					diagnostics.AddRange(typeArgumentInferenceDiagnosticsOpt);
				}
				if (addressOfExpression.MethodGroup.ResultKind == LookupResultKind.Good)
				{
					addressOfExpression.Binder.CheckMemberTypeAccessibility(diagnostics, syntaxNode, methodSymbol);
					result = new KeyValuePair<MethodSymbol, MethodConversionKind>(methodSymbol, methodConversionKind);
					goto IL_017b;
				}
				methodConversionKind |= MethodConversionKind.Error_Unspecified;
			}
			else
			{
				ReportDelegateBindingIncompatible(syntaxNode, toMethod.ContainingType, methodSymbol, diagnostics);
			}
			if (addressOfExpression.MethodGroup.ResultKind == LookupResultKind.Inaccessible)
			{
				ReportDiagnostic(diagnostics, syntaxNode, addressOfExpression.Binder.GetInaccessibleErrorInfo(analysisResult.Candidate.UnderlyingSymbol));
			}
			result = new KeyValuePair<MethodSymbol, MethodConversionKind>(null, methodConversionKind);
			goto IL_017b;
			IL_017b:
			return result;
		}

		private static void ReportDelegateBindingMismatchStrictOff(SyntaxNode syntax, NamedTypeSymbol delegateType, MethodSymbol targetMethodSymbol, BindingDiagnosticBag diagnostics)
		{
			if ((object)targetMethodSymbol.ReducedFrom == null)
			{
				ReportDiagnostic(diagnostics, syntax, ERRID.ERR_DelegateBindingMismatchStrictOff2, targetMethodSymbol, CustomSymbolDisplayFormatter.DelegateSignature(delegateType));
			}
			else
			{
				ReportDiagnostic(diagnostics, syntax, ERRID.ERR_DelegateBindingMismatchStrictOff3, targetMethodSymbol, CustomSymbolDisplayFormatter.DelegateSignature(delegateType), targetMethodSymbol.ContainingType);
			}
		}

		private static void ReportDelegateBindingIncompatible(SyntaxNode syntax, NamedTypeSymbol delegateType, MethodSymbol targetMethodSymbol, BindingDiagnosticBag diagnostics)
		{
			if ((object)targetMethodSymbol.ReducedFrom == null)
			{
				ReportDiagnostic(diagnostics, syntax, ERRID.ERR_DelegateBindingIncompatible2, targetMethodSymbol, CustomSymbolDisplayFormatter.DelegateSignature(delegateType));
			}
			else
			{
				ReportDiagnostic(diagnostics, syntax, ERRID.ERR_DelegateBindingIncompatible3, targetMethodSymbol, CustomSymbolDisplayFormatter.DelegateSignature(delegateType), targetMethodSymbol.ContainingType);
			}
		}

		private static MethodConversionKind GetDelegateMethodConversionBasedOnArguments(OverloadResolution.CandidateAnalysisResult bestResult, MethodSymbol delegateInvoke, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			MethodConversionKind methodConversionKind = MethodConversionKind.Identity;
			OverloadResolution.Candidate candidate = bestResult.Candidate;
			int parameterCount = candidate.ParameterCount;
			int index = parameterCount - 1;
			int parameterCount2 = delegateInvoke.ParameterCount;
			int num = Math.Min(parameterCount, parameterCount2) - 1;
			if (bestResult.IsExpandedParamArrayForm)
			{
				methodConversionKind |= MethodConversionKind.ExcessOptionalArgumentsOnTarget;
			}
			else if (parameterCount > parameterCount2)
			{
				methodConversionKind |= MethodConversionKind.ExcessOptionalArgumentsOnTarget;
			}
			else if (num >= 0 && candidate.Parameters(num).IsParamArray && delegateInvoke.Parameters[num].IsByRef && candidate.Parameters(num).IsByRef && !bestResult.ConversionsOpt.IsDefaultOrEmpty && !Conversions.IsIdentityConversion(bestResult.ConversionsOpt[num].Key))
			{
				methodConversionKind |= Conversions.ClassifyMethodConversionBasedOnArgumentConversion(Conversions.ClassifyConversion(candidate.Parameters(num).Type, delegateInvoke.Parameters[num].Type, ref useSiteInfo).Key, delegateInvoke.Parameters[num].Type);
			}
			int num2 = num;
			for (int i = 0; i <= num2; i++)
			{
				if (delegateInvoke.Parameters[i].IsByRef != candidate.Parameters(i).IsByRef)
				{
					methodConversionKind |= MethodConversionKind.Error_ByRefByValMismatch;
					break;
				}
			}
			if (bestResult.IsExpandedParamArrayForm && (methodConversionKind & MethodConversionKind.Error_ByRefByValMismatch) != MethodConversionKind.Error_ByRefByValMismatch)
			{
				bool isByRef = candidate.Parameters(index).IsByRef;
				int num3 = num + 1;
				int num4 = parameterCount2 - 1;
				for (int j = num3; j <= num4; j++)
				{
					if (delegateInvoke.Parameters[j].IsByRef != isByRef)
					{
						methodConversionKind |= MethodConversionKind.Error_ByRefByValMismatch;
						break;
					}
				}
			}
			if (!bestResult.ConversionsOpt.IsDefaultOrEmpty)
			{
				int num5 = bestResult.ConversionsOpt.Length - 1;
				for (int k = 0; k <= num5; k++)
				{
					KeyValuePair<ConversionKind, MethodSymbol> keyValuePair = bestResult.ConversionsOpt[k];
					TypeSymbol type = delegateInvoke.Parameters[k].Type;
					methodConversionKind |= Conversions.ClassifyMethodConversionBasedOnArgumentConversion(keyValuePair.Key, type);
				}
			}
			if (!bestResult.ConversionsBackOpt.IsDefaultOrEmpty)
			{
				int num6 = bestResult.ConversionsBackOpt.Length - 1;
				for (int l = 0; l <= num6; l++)
				{
					KeyValuePair<ConversionKind, MethodSymbol> keyValuePair2 = bestResult.ConversionsBackOpt[l];
					if (!Conversions.IsIdentityConversion(keyValuePair2.Key))
					{
						TypeSymbol type2 = candidate.Parameters(l).Type;
						methodConversionKind |= Conversions.ClassifyMethodConversionBasedOnArgumentConversion(keyValuePair2.Key, type2);
					}
				}
			}
			return methodConversionKind;
		}

		internal static ConversionKind ClassifyAddressOfConversion(BoundAddressOfOperator source, TypeSymbol destination)
		{
			return source.GetConversionClassification(destination);
		}

		private static SourceParameterFlags CheckDelegateParameterModifier(Symbol container, SyntaxToken token, SourceParameterFlags flag, BindingDiagnosticBag diagnostics)
		{
			if ((flag & SourceParameterFlags.ParamArray) == SourceParameterFlags.ParamArray)
			{
				Location location = token.GetLocation();
				diagnostics.Add(ERRID.ERR_ParamArrayIllegal1, location, GetDelegateOrEventKeywordText(container));
				flag &= (SourceParameterFlags)247;
			}
			if ((flag & SourceParameterFlags.Optional) == SourceParameterFlags.Optional)
			{
				Location location2 = token.GetLocation();
				diagnostics.Add(ERRID.ERR_OptionalIllegal1, location2, GetDelegateOrEventKeywordText(container));
				flag &= (SourceParameterFlags)251;
			}
			return flag;
		}

		private static string GetDelegateOrEventKeywordText(Symbol sym)
		{
			SyntaxKind kind = ((sym.Kind == SymbolKind.Event) ? SyntaxKind.EventKeyword : ((!(sym.ContainingType is SynthesizedEventDelegateSymbol)) ? SyntaxKind.DelegateKeyword : SyntaxKind.EventKeyword));
			return SyntaxFacts.GetText(kind);
		}

		internal BoundExpression ReclassifyAddressOf(BoundAddressOfOperator addressOfExpression, ref DelegateResolutionResult delegateResolutionResult, TypeSymbol targetType, BindingDiagnosticBag diagnostics, bool isForHandles, bool warnIfResultOfAsyncMethodIsDroppedDueToRelaxation)
		{
			if (addressOfExpression.HasErrors)
			{
				return addressOfExpression;
			}
			BoundLambda relaxationLambdaOpt = null;
			BoundRValuePlaceholder relaxationReceiverPlaceholder = null;
			SyntaxNode syntax = addressOfExpression.Syntax;
			MethodSymbol target = delegateResolutionResult.Target;
			MethodSymbol reducedFrom = target.ReducedFrom;
			BoundMethodGroup methodGroup = addressOfExpression.MethodGroup;
			BoundExpression boundExpression = methodGroup.ReceiverOpt;
			BoundExpression resolvedTypeOrValueExpression = null;
			if (boundExpression != null && !addressOfExpression.HasErrors)
			{
				ImmutableBindingDiagnostic<AssemblySymbol> diagnostics2 = delegateResolutionResult.Diagnostics;
				if (!diagnostics2.Diagnostics.HasAnyErrors())
				{
					boundExpression = AdjustReceiverTypeOrValue(boundExpression, boundExpression.Syntax, target.IsShared, diagnostics, ref resolvedTypeOrValueExpression);
				}
			}
			if (OptionStrict == OptionStrict.On && Conversions.IsNarrowingConversion(delegateResolutionResult.DelegateConversions))
			{
				SyntaxNode syntaxNode = addressOfExpression.Syntax;
				if (VisualBasicExtensions.Kind(syntaxNode) == SyntaxKind.AddressOfExpression)
				{
					syntaxNode = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax)syntaxNode).Operand;
				}
				ReportDelegateBindingMismatchStrictOff(syntaxNode, (NamedTypeSymbol)targetType, target, diagnostics);
			}
			else if (Conversions.IsStubRequiredForMethodConversion(delegateResolutionResult.MethodConversions) || ((object)reducedFrom != null && (reducedFrom.Parameters[0].IsByRef || TypeSymbolExtensions.IsTypeParameter(target.ReceiverType) || target.ReceiverType.IsValueType)))
			{
				relaxationLambdaOpt = BuildDelegateRelaxationLambda(syntax, methodGroup.Syntax, boundExpression, target, methodGroup.TypeArgumentsOpt, methodGroup.QualificationKind, ((NamedTypeSymbol)targetType).DelegateInvokeMethod, delegateResolutionResult.DelegateConversions & ConversionKind.DelegateRelaxationLevelMask, (delegateResolutionResult.MethodConversions & MethodConversionKind.AllArgumentsIgnored) != 0, warnIfResultOfAsyncMethodIsDroppedDueToRelaxation, diagnostics, out relaxationReceiverPlaceholder);
			}
			MethodSymbol target2 = delegateResolutionResult.Target;
			if (!isForHandles && MethodSymbolExtensions.IsPartialWithoutImplementation(target2))
			{
				ReportDiagnostic(diagnostics, addressOfExpression.MethodGroup.Syntax, ERRID.ERR_NoPartialMethodInAddressOf1, target2);
			}
			BoundExpression receiverOpt;
			if (boundExpression != null)
			{
				if (BoundExpressionExtensions.IsPropertyOrXmlPropertyAccess(boundExpression))
				{
					boundExpression = MakeRValue(boundExpression, diagnostics);
				}
				receiverOpt = null;
			}
			else
			{
				receiverOpt = resolvedTypeOrValueExpression ?? methodGroup.ReceiverOpt;
			}
			methodGroup = methodGroup.Update(methodGroup.TypeArgumentsOpt, methodGroup.Methods, methodGroup.PendingExtensionMethodsOpt, methodGroup.ResultKind, receiverOpt, methodGroup.QualificationKind);
			return new BoundDelegateCreationExpression(syntax, boundExpression, target2, relaxationLambdaOpt, relaxationReceiverPlaceholder, methodGroup, targetType);
		}

		private BoundLambda BuildDelegateRelaxationLambda(SyntaxNode syntaxNode, SyntaxNode methodGroupSyntax, BoundExpression receiver, MethodSymbol targetMethod, BoundTypeArguments typeArgumentsOpt, QualificationKind qualificationKind, MethodSymbol delegateInvoke, ConversionKind delegateRelaxation, bool isZeroArgumentKnownToBeUsed, bool warnIfResultOfAsyncMethodIsDroppedDueToRelaxation, BindingDiagnosticBag diagnostics, out BoundRValuePlaceholder relaxationReceiverPlaceholder)
		{
			relaxationReceiverPlaceholder = null;
			MethodSymbol constructedFrom = targetMethod.ConstructedFrom;
			if (typeArgumentsOpt == null && constructedFrom.IsGenericMethod)
			{
				typeArgumentsOpt = new BoundTypeArguments(methodGroupSyntax, targetMethod.TypeArguments);
				typeArgumentsOpt.SetWasCompilerGenerated();
			}
			BoundExpression boundExpression = receiver;
			if (boundExpression != null && BoundExpressionExtensions.IsValue(boundExpression) && !boundExpression.HasErrors && (!BoundExpressionExtensions.IsInstanceReference(boundExpression) || !targetMethod.ReceiverType.IsReferenceType))
			{
				relaxationReceiverPlaceholder = new BoundRValuePlaceholder(boundExpression.Syntax, boundExpression.Type);
				boundExpression = relaxationReceiverPlaceholder;
			}
			BoundMethodGroup boundMethodGroup = new BoundMethodGroup(methodGroupSyntax, typeArgumentsOpt, ImmutableArray.Create(constructedFrom), LookupResultKind.Good, boundExpression, qualificationKind);
			boundMethodGroup.SetWasCompilerGenerated();
			return BuildDelegateRelaxationLambda(syntaxNode, delegateInvoke, boundMethodGroup, delegateRelaxation, isZeroArgumentKnownToBeUsed, warnIfResultOfAsyncMethodIsDroppedDueToRelaxation, diagnostics);
		}

		private BoundLambda BuildDelegateRelaxationLambda(SyntaxNode syntaxNode, MethodSymbol delegateInvoke, BoundMethodGroup methodGroup, ConversionKind delegateRelaxation, bool isZeroArgumentKnownToBeUsed, bool warnIfResultOfAsyncMethodIsDroppedDueToRelaxation, BindingDiagnosticBag diagnostics)
		{
			TypeSymbol returnType = delegateInvoke.ReturnType;
			ImmutableArray<ParameterSymbol> parameters = delegateInvoke.Parameters;
			int length = parameters.Length;
			BoundLambdaParameterSymbol[] array = new BoundLambdaParameterSymbol[length - 1 + 1];
			Location location = syntaxNode.GetLocation();
			int num = length - 1;
			for (int i = 0; i <= num; i++)
			{
				ParameterSymbol parameterSymbol = parameters[i];
				array[i] = new BoundLambdaParameterSymbol(GeneratedNames.MakeDelegateRelaxationParameterName(i), parameterSymbol.Ordinal, parameterSymbol.Type, parameterSymbol.IsByRef, syntaxNode, location);
			}
			SynthesizedLambdaSymbol synthesizedLambdaSymbol = new SynthesizedLambdaSymbol(SynthesizedLambdaKind.DelegateRelaxationStub, syntaxNode, array.AsImmutable(), returnType, this);
			MethodSymbol methodSymbol = methodGroup.Methods[0];
			int num2;
			int num3;
			if (!isZeroArgumentKnownToBeUsed)
			{
				if (length > 0)
				{
					num2 = ((methodSymbol.ParameterCount == 0) ? 1 : 0);
					if (num2 != 0)
					{
						goto IL_00b3;
					}
				}
				else
				{
					num2 = 0;
				}
				num3 = length;
				goto IL_00b4;
			}
			num2 = 1;
			goto IL_00b3;
			IL_00b4:
			BoundExpression[] array2 = new BoundExpression[num3 - 1 + 1];
			if (num2 == 0)
			{
				int num4 = array.Length - 1;
				for (int j = 0; j <= num4; j++)
				{
					BoundLambdaParameterSymbol boundLambdaParameterSymbol = array[j];
					BoundParameter boundParameter = new BoundParameter(syntaxNode, boundLambdaParameterSymbol, boundLambdaParameterSymbol.Type);
					boundParameter.SetWasCompilerGenerated();
					array2[j] = boundParameter;
				}
			}
			LambdaBodyBinder lambdaBodyBinder = new LambdaBodyBinder(synthesizedLambdaSymbol, this);
			BoundExpression boundExpression = lambdaBodyBinder.BindInvocationExpression(syntaxNode, syntaxNode, TypeCharacter.None, methodGroup, array2.AsImmutable(), default(ImmutableArray<string>), diagnostics, null, allowConstructorCall: false, suppressAbstractCallDiagnostics: true);
			boundExpression.SetWasCompilerGenerated();
			ImmutableArray<BoundStatement> immutableArray = default(ImmutableArray<BoundStatement>);
			if (synthesizedLambdaSymbol.IsSub)
			{
				BoundStatement[] array3 = new BoundStatement[2];
				BoundStatement boundStatement = new BoundExpressionStatement(syntaxNode, boundExpression);
				boundStatement.SetWasCompilerGenerated();
				array3[0] = boundStatement;
				boundStatement = new BoundReturnStatement(syntaxNode, null, null, null);
				boundStatement.SetWasCompilerGenerated();
				array3[1] = boundStatement;
				immutableArray = array3.AsImmutableOrNull();
				if (warnIfResultOfAsyncMethodIsDroppedDueToRelaxation && !methodSymbol.IsSub)
				{
					if (!methodSymbol.IsAsync)
					{
						warnIfResultOfAsyncMethodIsDroppedDueToRelaxation = false;
						if (methodSymbol.MethodKind == MethodKind.DelegateInvoke && methodGroup.ReceiverOpt != null && methodGroup.ReceiverOpt.Kind == BoundKind.Conversion)
						{
							BoundConversion boundConversion = (BoundConversion)methodGroup.ReceiverOpt;
							if (!boundConversion.ExplicitCastInCode && boundConversion.Operand.Kind == BoundKind.Lambda && ((BoundLambda)boundConversion.Operand).LambdaSymbol.IsAsync && TypeSymbolExtensions.IsDelegateType(boundConversion.Type) && boundConversion.Type.IsAnonymousType)
							{
								warnIfResultOfAsyncMethodIsDroppedDueToRelaxation = true;
							}
						}
					}
					else
					{
						warnIfResultOfAsyncMethodIsDroppedDueToRelaxation = (object)methodSymbol.ContainingAssembly == Compilation.Assembly;
					}
					if (warnIfResultOfAsyncMethodIsDroppedDueToRelaxation)
					{
						ReportDiagnostic(diagnostics, syntaxNode, ERRID.WRN_UnobservedAwaitableDelegate);
					}
				}
			}
			else
			{
				boundExpression = lambdaBodyBinder.ApplyImplicitConversion(syntaxNode, returnType, boundExpression, diagnostics);
				BoundReturnStatement boundReturnStatement = new BoundReturnStatement(syntaxNode, boundExpression, null, null);
				boundReturnStatement.SetWasCompilerGenerated();
				immutableArray = ImmutableArray.Create((BoundStatement)boundReturnStatement);
			}
			BoundBlock boundBlock = new BoundBlock(syntaxNode, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), ImmutableArray<LocalSymbol>.Empty, immutableArray);
			boundBlock.SetWasCompilerGenerated();
			BoundLambda boundLambda = new BoundLambda(syntaxNode, synthesizedLambdaSymbol, boundBlock, ImmutableBindingDiagnostic<AssemblySymbol>.Empty, null, delegateRelaxation, MethodConversionKind.Identity);
			boundLambda.SetWasCompilerGenerated();
			return boundLambda;
			IL_00b3:
			num3 = 0;
			goto IL_00b4;
		}

		public static BoundExpression ReportDiagnosticAndProduceBadExpression(BindingDiagnosticBag diagBag, VisualBasicSyntaxNode syntax, ERRID id)
		{
			return ReportDiagnosticAndProduceBadExpression(diagBag, syntax, ErrorFactory.ErrorInfo(id));
		}

		public static BoundExpression ReportDiagnosticAndProduceBadExpression(BindingDiagnosticBag diagBag, VisualBasicSyntaxNode syntax, ERRID id, params object[] args)
		{
			return ReportDiagnosticAndProduceBadExpression(diagBag, syntax, ErrorFactory.ErrorInfo(id, args));
		}

		public static BoundExpression ReportDiagnosticAndProduceBadExpression(BindingDiagnosticBag diagBag, VisualBasicSyntaxNode syntax, DiagnosticInfo info, params BoundExpression[] nodes)
		{
			return BadExpression(syntax, nodes.IsEmpty() ? ImmutableArray<BoundExpression>.Empty : ImmutableArray.Create(nodes), ReportDiagnosticAndProduceErrorTypeSymbol(diagBag, syntax, info));
		}

		public static ErrorTypeSymbol ReportDiagnosticAndProduceErrorTypeSymbol(BindingDiagnosticBag diagBag, VisualBasicSyntaxNode syntax, ERRID id, params object[] args)
		{
			return ReportDiagnosticAndProduceErrorTypeSymbol(diagBag, syntax, ErrorFactory.ErrorInfo(id, args));
		}

		public static ErrorTypeSymbol ReportDiagnosticAndProduceErrorTypeSymbol(BindingDiagnosticBag diagBag, VisualBasicSyntaxNode syntax, DiagnosticInfo info)
		{
			ReportDiagnostic(diagBag, syntax, info);
			return ErrorTypeSymbol.UnknownResultType;
		}

		internal virtual ImmutableArray<Symbol> BindInsideCrefAttributeValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax name, bool preserveAliases, BindingDiagnosticBag diagnosticBag, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			return ContainingBinder.BindInsideCrefAttributeValue(name, preserveAliases, diagnosticBag, ref useSiteInfo);
		}

		internal virtual ImmutableArray<Symbol> BindInsideCrefAttributeValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax reference, bool preserveAliases, BindingDiagnosticBag diagnosticBag, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			return ContainingBinder.BindInsideCrefAttributeValue(reference, preserveAliases, diagnosticBag, ref useSiteInfo);
		}

		internal virtual ImmutableArray<Symbol> BindXmlNameAttributeValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax identifier, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			return ContainingBinder.BindXmlNameAttributeValue(identifier, ref useSiteInfo);
		}

		public BoundExpression BindExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			return BindExpression(node, isInvocationOrAddressOf: false, isOperandOfConditionalBranch: false, eventContext: false, diagnostics);
		}

		public BoundExpression BindExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax node, bool isInvocationOrAddressOf, bool isOperandOfConditionalBranch, bool eventContext, BindingDiagnosticBag diagnostics)
		{
			if (IsEarlyAttributeBinder && !EarlyWellKnownAttributeBinder.CanBeValidAttributeArgument(node, this))
			{
				return BadExpression(node, ErrorTypeSymbol.UnknownResultType);
			}
			switch (node.Kind())
			{
			case SyntaxKind.MeExpression:
				return BindMeExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.MeExpressionSyntax)node, diagnostics);
			case SyntaxKind.MyBaseExpression:
				return BindMyBaseExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.MyBaseExpressionSyntax)node, diagnostics);
			case SyntaxKind.MyClassExpression:
				return BindMyClassExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.MyClassExpressionSyntax)node, diagnostics);
			case SyntaxKind.IdentifierName:
			case SyntaxKind.GenericName:
				return BindSimpleName((Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax)node, isInvocationOrAddressOf, diagnostics);
			case SyntaxKind.NullableType:
			case SyntaxKind.PredefinedType:
				return BindNamespaceOrTypeExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)node, diagnostics);
			case SyntaxKind.SimpleMemberAccessExpression:
				return BindMemberAccess((Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax)node, eventContext, diagnostics);
			case SyntaxKind.DictionaryAccessExpression:
				return BindDictionaryAccess((Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax)node, diagnostics);
			case SyntaxKind.InvocationExpression:
				return BindInvocationExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax)node, diagnostics);
			case SyntaxKind.CollectionInitializer:
				return BindArrayLiteralExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax)node, diagnostics);
			case SyntaxKind.AnonymousObjectCreationExpression:
				return BindAnonymousObjectCreationExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax)node, diagnostics);
			case SyntaxKind.ArrayCreationExpression:
				return BindArrayCreationExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax)node, diagnostics);
			case SyntaxKind.ObjectCreationExpression:
				return BindObjectCreationExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax)node, diagnostics);
			case SyntaxKind.CharacterLiteralExpression:
			case SyntaxKind.TrueLiteralExpression:
			case SyntaxKind.FalseLiteralExpression:
			case SyntaxKind.NumericLiteralExpression:
			case SyntaxKind.DateLiteralExpression:
			case SyntaxKind.StringLiteralExpression:
			case SyntaxKind.NothingLiteralExpression:
				return BindLiteralConstant((Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax)node, diagnostics);
			case SyntaxKind.ParenthesizedExpression:
			{
				BoundExpression boundExpression = BindExpression(((Microsoft.CodeAnalysis.VisualBasic.Syntax.ParenthesizedExpressionSyntax)node).Expression, isInvocationOrAddressOf: false, isOperandOfConditionalBranch, eventContext, diagnostics);
				if (boundExpression.Kind == BoundKind.TypeExpression)
				{
					BoundTypeExpression boundTypeExpression = (BoundTypeExpression)boundExpression;
					return new BoundTypeExpression(node, boundTypeExpression.UnevaluatedReceiverOpt, boundTypeExpression.AliasOpt, boundExpression.Type, boundExpression.HasErrors);
				}
				if (boundExpression.Kind == BoundKind.ArrayLiteral)
				{
					BoundArrayLiteral boundArrayLiteral = (BoundArrayLiteral)boundExpression;
					BoundExpression boundExpression2 = ReclassifyArrayLiteralExpression(SyntaxKind.CTypeKeyword, boundArrayLiteral.Syntax, ConversionKind.Widening, isExplicit: false, boundArrayLiteral, boundArrayLiteral.InferredType, diagnostics);
					return new BoundParenthesized(node, boundExpression2, boundExpression2.Type);
				}
				return new BoundParenthesized(node, boundExpression, boundExpression.Type);
			}
			case SyntaxKind.UnaryPlusExpression:
			case SyntaxKind.UnaryMinusExpression:
			case SyntaxKind.NotExpression:
				return BindUnaryOperator((Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax)node, diagnostics);
			case SyntaxKind.AddExpression:
			case SyntaxKind.SubtractExpression:
			case SyntaxKind.MultiplyExpression:
			case SyntaxKind.DivideExpression:
			case SyntaxKind.IntegerDivideExpression:
			case SyntaxKind.ExponentiateExpression:
			case SyntaxKind.LeftShiftExpression:
			case SyntaxKind.RightShiftExpression:
			case SyntaxKind.ConcatenateExpression:
			case SyntaxKind.ModuloExpression:
			case SyntaxKind.EqualsExpression:
			case SyntaxKind.NotEqualsExpression:
			case SyntaxKind.LessThanExpression:
			case SyntaxKind.LessThanOrEqualExpression:
			case SyntaxKind.GreaterThanOrEqualExpression:
			case SyntaxKind.GreaterThanExpression:
			case SyntaxKind.LikeExpression:
			case SyntaxKind.OrExpression:
			case SyntaxKind.ExclusiveOrExpression:
			case SyntaxKind.AndExpression:
			case SyntaxKind.OrElseExpression:
			case SyntaxKind.AndAlsoExpression:
				return BindBinaryOperator((Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax)node, isOperandOfConditionalBranch, diagnostics);
			case SyntaxKind.IsExpression:
			case SyntaxKind.IsNotExpression:
				return BindIsExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax)node, diagnostics);
			case SyntaxKind.GetTypeExpression:
				return BindGetTypeExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.GetTypeExpressionSyntax)node, diagnostics);
			case SyntaxKind.NameOfExpression:
				return BindNameOfExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.NameOfExpressionSyntax)node, diagnostics);
			case SyntaxKind.AddressOfExpression:
				return BindAddressOfExpression(node, diagnostics);
			case SyntaxKind.CTypeExpression:
			case SyntaxKind.DirectCastExpression:
			case SyntaxKind.TryCastExpression:
				return BindCastExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax)node, diagnostics);
			case SyntaxKind.PredefinedCastExpression:
				return BindPredefinedCastExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax)node, diagnostics);
			case SyntaxKind.TypeOfIsExpression:
			case SyntaxKind.TypeOfIsNotExpression:
				return BindTypeOfExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax)node, diagnostics);
			case SyntaxKind.BinaryConditionalExpression:
				return BindBinaryConditionalExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax)node, diagnostics);
			case SyntaxKind.TernaryConditionalExpression:
				return BindTernaryConditionalExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax)node, diagnostics);
			case SyntaxKind.SingleLineFunctionLambdaExpression:
			case SyntaxKind.SingleLineSubLambdaExpression:
			case SyntaxKind.MultiLineFunctionLambdaExpression:
			case SyntaxKind.MultiLineSubLambdaExpression:
				return BindLambdaExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaExpressionSyntax)node, diagnostics);
			case SyntaxKind.GlobalName:
				return new BoundNamespaceExpression(node, null, Compilation.GlobalNamespace);
			case SyntaxKind.QueryExpression:
				return BindQueryExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax)node, diagnostics);
			case SyntaxKind.GroupAggregation:
				return BindGroupAggregationExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupAggregationSyntax)node, diagnostics);
			case SyntaxKind.FunctionAggregation:
				return BindFunctionAggregationExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax)node, diagnostics);
			case SyntaxKind.IdentifierLabel:
			case SyntaxKind.NumericLabel:
			case SyntaxKind.NextLabel:
				return BindLabel((Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax)node, diagnostics);
			case SyntaxKind.QualifiedName:
				return BindQualifiedName((Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax)node, diagnostics);
			case SyntaxKind.GetXmlNamespaceExpression:
				return BindGetXmlNamespace((Microsoft.CodeAnalysis.VisualBasic.Syntax.GetXmlNamespaceExpressionSyntax)node, diagnostics);
			case SyntaxKind.XmlComment:
				return BindXmlComment((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCommentSyntax)node, null, diagnostics);
			case SyntaxKind.XmlDocument:
				return BindXmlDocument((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDocumentSyntax)node, diagnostics);
			case SyntaxKind.XmlProcessingInstruction:
				return BindXmlProcessingInstruction((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlProcessingInstructionSyntax)node, diagnostics);
			case SyntaxKind.XmlEmptyElement:
				return BindXmlEmptyElement((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax)node, null, diagnostics);
			case SyntaxKind.XmlElement:
				return BindXmlElement((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax)node, null, diagnostics);
			case SyntaxKind.XmlEmbeddedExpression:
				return BindXmlEmbeddedExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax)node, diagnostics);
			case SyntaxKind.XmlCDataSection:
				return BindXmlCData((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCDataSectionSyntax)node, null, diagnostics);
			case SyntaxKind.XmlElementAccessExpression:
				return BindXmlElementAccess((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax)node, diagnostics);
			case SyntaxKind.XmlAttributeAccessExpression:
				return BindXmlAttributeAccess((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax)node, diagnostics);
			case SyntaxKind.XmlDescendantAccessExpression:
				return BindXmlDescendantAccess((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax)node, diagnostics);
			case SyntaxKind.AwaitExpression:
				return BindAwait((Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax)node, diagnostics);
			case SyntaxKind.ConditionalAccessExpression:
				return BindConditionalAccessExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax)node, diagnostics);
			case SyntaxKind.InterpolatedStringExpression:
				return BindInterpolatedStringExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringExpressionSyntax)node, diagnostics);
			case SyntaxKind.TupleExpression:
				return BindTupleExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleExpressionSyntax)node, diagnostics);
			default:
				return BadExpression(node, ImmutableArray<BoundExpression>.Empty, ErrorTypeSymbol.UnknownResultType);
			}
		}

		protected static BoundBadExpression BadExpression(SyntaxNode node, TypeSymbol resultType)
		{
			return new BoundBadExpression(node, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, ImmutableArray<BoundExpression>.Empty, resultType, hasErrors: true);
		}

		private static BoundBadExpression BadExpression(SyntaxNode node, BoundExpression expr, TypeSymbol resultType)
		{
			return new BoundBadExpression(node, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, ImmutableArray.Create(expr), resultType, hasErrors: true);
		}

		private static BoundBadExpression BadExpression(SyntaxNode node, BoundExpression expr, LookupResultKind resultKind, TypeSymbol resultType)
		{
			return new BoundBadExpression(node, resultKind, ImmutableArray<Symbol>.Empty, ImmutableArray.Create(expr), resultType, hasErrors: true);
		}

		private static BoundBadExpression BadExpression(SyntaxNode node, ImmutableArray<BoundExpression> exprs, TypeSymbol resultType)
		{
			return new BoundBadExpression(node, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, exprs, resultType, hasErrors: true);
		}

		private static BoundBadExpression BadExpression(BoundExpression expr)
		{
			return BadExpression(LookupResultKind.Empty, expr);
		}

		private static BoundBadExpression BadExpression(LookupResultKind resultKind, BoundExpression wrappedExpression)
		{
			if (wrappedExpression is BoundBadExpression boundBadExpression)
			{
				return new BoundBadExpression(boundBadExpression.Syntax, resultKind, boundBadExpression.Symbols, boundBadExpression.ChildBoundNodes, boundBadExpression.Type, hasErrors: true);
			}
			return new BoundBadExpression(wrappedExpression.Syntax, resultKind, ImmutableArray<Symbol>.Empty, ImmutableArray.Create(wrappedExpression), wrappedExpression.Type, hasErrors: true);
		}

		private BoundExpression BindTupleExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax> arguments = node.Arguments;
			int count = arguments.Count;
			if (count < 2)
			{
				ImmutableArray<BoundExpression> exprs = ((count == 1) ? ImmutableArray.Create(BindRValue(arguments[0].Expression, diagnostics)) : ImmutableArray<BoundExpression>.Empty);
				return BadExpression(node, exprs, ErrorTypeSymbol.UnknownResultType);
			}
			bool hasNaturalType = true;
			bool flag = true;
			ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance(arguments.Count);
			ArrayBuilder<TypeSymbol> instance2 = ArrayBuilder<TypeSymbol>.GetInstance(arguments.Count);
			ArrayBuilder<Location> instance3 = ArrayBuilder<Location>.GetInstance(arguments.Count);
			(ImmutableArray<string> elementNames, ImmutableArray<bool> inferredPositions, bool hasErrors) tuple = ExtractTupleElementNames(arguments, diagnostics);
			ImmutableArray<string> item = tuple.elementNames;
			ImmutableArray<bool> item2 = tuple.inferredPositions;
			bool item3 = tuple.hasErrors;
			int num = count - 1;
			for (int i = 0; i <= num; i++)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax simpleArgumentSyntax = arguments[i];
				Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax identifierNameSyntax = simpleArgumentSyntax.NameColonEquals?.Name;
				if (identifierNameSyntax != null)
				{
					instance3.Add(identifierNameSyntax.GetLocation());
					if (VisualBasicExtensions.GetTypeCharacter(identifierNameSyntax.Identifier) != 0)
					{
						ReportDiagnostic(diagnostics, identifierNameSyntax, ERRID.ERR_TupleLiteralDisallowsTypeChar);
					}
				}
				else
				{
					instance3.Add(simpleArgumentSyntax.GetLocation());
				}
				BoundExpression boundExpression = BindValue(simpleArgumentSyntax.Expression, diagnostics);
				TypeSymbol tupleFieldType = GetTupleFieldType(boundExpression, simpleArgumentSyntax, diagnostics, ref hasNaturalType);
				if ((object)tupleFieldType == null)
				{
					flag = false;
				}
				if ((object)boundExpression.Type != null)
				{
					boundExpression = MakeRValue(boundExpression, diagnostics);
				}
				instance.Add(boundExpression);
				instance2.Add(tupleFieldType);
			}
			ImmutableArray<TypeSymbol> elementTypes = instance2.ToImmutableAndFree();
			ImmutableArray<Location> elementLocations = instance3.ToImmutableAndFree();
			TupleTypeSymbol tupleTypeSymbol = null;
			if (flag)
			{
				bool flag2 = LanguageVersionFacts.DisallowInferredTupleElementNames(Compilation.LanguageVersion);
				tupleTypeSymbol = TupleTypeSymbol.Create(node.GetLocation(), elementTypes, elementLocations, item, Compilation, shouldCheckConstraints: true, flag2 ? item2 : default(ImmutableArray<bool>), node, diagnostics);
			}
			NamedTypeSymbol type = (hasNaturalType ? tupleTypeSymbol : null);
			return new BoundTupleLiteral(node, tupleTypeSymbol, item, item2, instance.ToImmutableAndFree(), type, item3);
		}

		private static (ImmutableArray<string> elementNames, ImmutableArray<bool> inferredPositions, bool hasErrors) ExtractTupleElementNames(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax> arguments, BindingDiagnosticBag diagnostics)
		{
			bool item = false;
			HashSet<string> uniqueFieldNames = new HashSet<string>(CaseInsensitiveComparison.Comparer);
			ArrayBuilder<string> elementNames = null;
			ArrayBuilder<string> inferredElementNames = null;
			int count = arguments.Count;
			int num = count - 1;
			for (int i = 0; i <= num; i++)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax simpleArgumentSyntax = arguments[i];
				string name = null;
				string name2 = null;
				Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax identifierNameSyntax = simpleArgumentSyntax.NameColonEquals?.Name;
				if (identifierNameSyntax != null)
				{
					name = identifierNameSyntax.Identifier.ValueText;
					if (!CheckTupleMemberName(name, i, simpleArgumentSyntax.NameColonEquals.Name, diagnostics, uniqueFieldNames))
					{
						item = true;
					}
				}
				else
				{
					name2 = InferTupleElementName(simpleArgumentSyntax.Expression);
				}
				CollectTupleFieldMemberName(name, i, count, ref elementNames);
				CollectTupleFieldMemberName(name2, i, count, ref inferredElementNames);
			}
			RemoveDuplicateInferredTupleNamesAndFreeIfEmptied(ref inferredElementNames, uniqueFieldNames);
			(ImmutableArray<string>, ImmutableArray<bool>) tuple = MergeTupleElementNames(elementNames, inferredElementNames);
			elementNames?.Free();
			inferredElementNames?.Free();
			return (tuple.Item1, tuple.Item2, item);
		}

		private static (ImmutableArray<string> names, ImmutableArray<bool> inferred) MergeTupleElementNames(ArrayBuilder<string> elementNames, ArrayBuilder<string> inferredElementNames)
		{
			(ImmutableArray<string>, ImmutableArray<bool>) result;
			if (elementNames == null)
			{
				if (inferredElementNames == null)
				{
					result = (default(ImmutableArray<string>), default(ImmutableArray<bool>));
				}
				else
				{
					ImmutableArray<string> immutableArray = inferredElementNames.ToImmutable();
					result = (immutableArray, immutableArray.SelectAsArray((string n) => n != null));
				}
			}
			else if (inferredElementNames == null)
			{
				result = (elementNames.ToImmutable(), default(ImmutableArray<bool>));
			}
			else
			{
				ArrayBuilder<bool> instance = ArrayBuilder<bool>.GetInstance(elementNames.Count);
				int num = elementNames.Count - 1;
				for (int i = 0; i <= num; i++)
				{
					string text = inferredElementNames[i];
					if (elementNames[i] == null && text != null)
					{
						elementNames[i] = text;
						instance.Add(item: true);
					}
					else
					{
						instance.Add(item: false);
					}
				}
				result = (elementNames.ToImmutable(), instance.ToImmutableAndFree());
			}
			return result;
		}

		private static void RemoveDuplicateInferredTupleNamesAndFreeIfEmptied(ref ArrayBuilder<string> inferredElementNames, HashSet<string> uniqueFieldNames)
		{
			if (inferredElementNames == null)
			{
				return;
			}
			HashSet<string> hashSet = new HashSet<string>(CaseInsensitiveComparison.Comparer);
			ArrayBuilder<string>.Enumerator enumerator = inferredElementNames.GetEnumerator();
			while (enumerator.MoveNext())
			{
				string current = enumerator.Current;
				if (current != null && !uniqueFieldNames.Add(current))
				{
					hashSet.Add(current);
				}
			}
			int num = inferredElementNames.Count - 1;
			for (int i = 0; i <= num; i++)
			{
				string text = inferredElementNames[i];
				if (text != null && hashSet.Contains(text))
				{
					inferredElementNames[i] = null;
				}
			}
			if (inferredElementNames.All((string n) => n == null))
			{
				inferredElementNames.Free();
				inferredElementNames = null;
			}
		}

		private static string InferTupleElementName(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax element)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax failedToInferFromXmlName = null;
			SyntaxToken token = SyntaxNodeExtensions.ExtractAnonymousTypeMemberName(element, out failedToInferFromXmlName);
			if (VisualBasicExtensions.Kind(token) == SyntaxKind.IdentifierToken)
			{
				string valueText = token.ValueText;
				if (TupleTypeSymbol.IsElementNameReserved(valueText) == -1)
				{
					return valueText;
				}
			}
			return null;
		}

		private TypeSymbol GetTupleFieldType(BoundExpression expression, VisualBasicSyntaxNode errorSyntax, BindingDiagnosticBag diagnostics, ref bool hasNaturalType)
		{
			TypeSymbol typeSymbol = expression.Type;
			if ((object)typeSymbol == null)
			{
				hasNaturalType = false;
				if (!BoundExpressionExtensions.IsNothingLiteral(expression))
				{
					expression = BoundExpressionExtensions.GetMostEnclosedParenthesizedExpression(expression);
				}
				switch (expression.Kind)
				{
				case BoundKind.UnboundLambda:
					typeSymbol = ((UnboundLambda)expression).InferredAnonymousDelegate.Key;
					break;
				case BoundKind.TupleLiteral:
					typeSymbol = ((BoundTupleLiteral)expression).InferredType;
					break;
				case BoundKind.ArrayLiteral:
					typeSymbol = ((BoundArrayLiteral)expression).InferredType;
					break;
				default:
					if (BoundExpressionExtensions.IsNothingLiteral(expression))
					{
						typeSymbol = GetSpecialType(SpecialType.System_Object, expression.Syntax, diagnostics);
					}
					break;
				}
			}
			return typeSymbol;
		}

		private static void CollectTupleFieldMemberName(string name, int elementIndex, int tupleSize, ref ArrayBuilder<string> elementNames)
		{
			if (elementNames != null)
			{
				elementNames.Add(name);
			}
			else if (name != null)
			{
				elementNames = ArrayBuilder<string>.GetInstance(tupleSize);
				for (int i = 1; i <= elementIndex; i++)
				{
					elementNames.Add(null);
				}
				elementNames.Add(name);
			}
		}

		private static bool CheckTupleMemberName(string name, int index, SyntaxNodeOrToken syntax, BindingDiagnosticBag diagnostics, HashSet<string> uniqueFieldNames)
		{
			int num = TupleTypeSymbol.IsElementNameReserved(name);
			if (num == 0)
			{
				ReportDiagnostic(diagnostics, syntax, ERRID.ERR_TupleReservedElementNameAnyPosition, name);
				return false;
			}
			if (num > 0 && num != index + 1)
			{
				ReportDiagnostic(diagnostics, syntax, ERRID.ERR_TupleReservedElementName, name, num);
				return false;
			}
			if (!uniqueFieldNames.Add(name))
			{
				ReportDiagnostic(diagnostics, syntax, ERRID.ERR_TupleDuplicateElementName);
				return false;
			}
			return true;
		}

		public BoundExpression BindNamespaceOrTypeExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax node, BindingDiagnosticBag diagnostics)
		{
			Symbol symbol = BindNamespaceOrTypeOrAliasSyntax(node, diagnostics);
			AliasSymbol aliasSymbol = symbol as AliasSymbol;
			if ((object)aliasSymbol != null)
			{
				symbol = aliasSymbol.Target;
				ReportUseSite(diagnostics, node, symbol);
			}
			if (symbol is TypeSymbol type)
			{
				return new BoundTypeExpression(node, null, aliasSymbol, type);
			}
			if (symbol is NamespaceSymbol namespaceSymbol)
			{
				return new BoundNamespaceExpression(node, null, aliasSymbol, namespaceSymbol);
			}
			throw ExceptionUtilities.Unreachable;
		}

		public BoundExpression BindNamespaceOrTypeOrExpressionSyntaxForSemanticModel(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			if (node.Kind() == SyntaxKind.PredefinedType || ((node is Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax || node.Kind() == SyntaxKind.ArrayType || node.Kind() == SyntaxKind.TupleType) && SyntaxFacts.IsInNamespaceOrTypeContext(node)))
			{
				BoundExpression boundExpression = BindNamespaceOrTypeExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)node, diagnostics);
				if (node.Parent != null && node.Parent.Kind() == SyntaxKind.QualifiedName && ((Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax)node.Parent).Left == node && boundExpression.Kind == BoundKind.NamespaceExpression)
				{
					BoundNamespaceExpression boundNamespaceExpression = (BoundNamespaceExpression)boundExpression;
					if (boundNamespaceExpression.NamespaceSymbol.NamespaceKind == (NamespaceKind)0)
					{
						BoundExpression expression = BindNamespaceOrTypeOrExpressionSyntaxForSemanticModel((Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax)node.Parent, BindingDiagnosticBag.Discarded);
						ArrayBuilder<Symbol> instance = ArrayBuilder<Symbol>.GetInstance();
						BindNamespaceOrTypeSyntaxForSemanticModelGetExpressionSymbols(expression, instance);
						if (instance.Count == 0)
						{
							BindNamespaceOrTypeSyntaxForSemanticModelGetExpressionSymbols(BindExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax)node.Parent, BindingDiagnosticBag.Discarded), instance);
						}
						boundExpression = AdjustReceiverNamespace(boundNamespaceExpression, instance);
						instance.Free();
					}
				}
				return boundExpression;
			}
			return BindExpression(node, SyntaxFacts.IsInvocationOrAddressOfOperand(node), isOperandOfConditionalBranch: false, eventContext: false, diagnostics);
		}

		private static void BindNamespaceOrTypeSyntaxForSemanticModelGetExpressionSymbols(BoundExpression expression, ArrayBuilder<Symbol> symbols)
		{
			BoundExpressionExtensions.GetExpressionSymbols(expression, symbols);
			if (symbols.Count == 1 && symbols[0].Kind == SymbolKind.ErrorType)
			{
				ErrorTypeSymbol obj = (ErrorTypeSymbol)symbols[0];
				symbols.Clear();
				if (obj.ErrorInfo is IDiagnosticInfoWithSymbols diagnosticInfoWithSymbols)
				{
					diagnosticInfoWithSymbols.GetAssociatedSymbols(symbols);
				}
			}
		}

		private BoundExpression BindQualifiedName(Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax name, BindingDiagnosticBag diagnostics)
		{
			return BindMemberAccess(name, BindExpression(name.Left, diagnostics), name.Right, eventContext: false, diagnostics);
		}

		private BoundExpression BindGetTypeExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.GetTypeExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			GetTypeBinder binder = new GetTypeBinder(node.Type, this);
			Symbol symbol = TypeBinder.BindTypeOrAliasSyntax(node.Type, binder, diagnostics, suppressUseSiteError: false, inGetTypeContext: true, resolvingBaseType: false);
			AliasSymbol aliasSymbol = symbol as AliasSymbol;
			TypeSymbol typeSymbol = (TypeSymbol)(((object)aliasSymbol != null) ? aliasSymbol.Target : symbol);
			BoundTypeExpression sourceType = new BoundTypeExpression(node.Type, null, aliasSymbol, typeSymbol, TypeSymbolExtensions.IsErrorType(typeSymbol));
			if (TypeSymbolExtensions.IsArrayType(typeSymbol) && ((ArrayTypeSymbol)typeSymbol).ElementType.SpecialType == SpecialType.System_Void)
			{
				ReportDiagnostic(diagnostics, node.Type, ErrorFactory.ErrorInfo(ERRID.ERR_VoidArrayDisallowed));
			}
			return new BoundGetType(node, sourceType, GetWellKnownType(WellKnownType.System_Type, node, diagnostics));
		}

		private BoundExpression BindNameOfExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.NameOfExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			if (node.Argument.HasErrors)
			{
				diagnostics = BindingDiagnosticBag.Discarded;
			}
			string value = null;
			switch (node.Argument.Kind())
			{
			case SyntaxKind.SimpleMemberAccessExpression:
				value = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax)node.Argument).Name.Identifier.ValueText;
				break;
			case SyntaxKind.IdentifierName:
			case SyntaxKind.GenericName:
				value = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax)node.Argument).Identifier.ValueText;
				break;
			}
			BoundExpression boundExpression = BindExpression(node.Argument, diagnostics);
			switch (boundExpression.Kind)
			{
			case BoundKind.MethodGroup:
			{
				BoundMethodGroup boundMethodGroup = (BoundMethodGroup)boundExpression;
				if (boundMethodGroup.ResultKind == LookupResultKind.Inaccessible)
				{
					ReportDiagnostic(diagnostics, (node.Argument.Kind() == SyntaxKind.SimpleMemberAccessExpression) ? ((Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax)node.Argument).Name : node.Argument, GetInaccessibleErrorInfo(boundMethodGroup.Methods.First()));
					break;
				}
				if (boundMethodGroup.ResultKind == LookupResultKind.Good && boundMethodGroup.TypeArgumentsOpt != null)
				{
					ReportDiagnostic(diagnostics, boundMethodGroup.TypeArgumentsOpt.Syntax, ERRID.ERR_MethodTypeArgsUnexpected);
					break;
				}
				ImmutableArray<MethodSymbol>.Enumerator enumerator2 = boundMethodGroup.Methods.GetEnumerator();
				while (enumerator2.MoveNext())
				{
					MethodSymbol current2 = enumerator2.Current;
					diagnostics.AddDependency(current2.ContainingAssembly);
				}
				break;
			}
			case BoundKind.PropertyGroup:
			{
				BoundPropertyGroup boundPropertyGroup = (BoundPropertyGroup)boundExpression;
				if (boundPropertyGroup.ResultKind == LookupResultKind.Inaccessible)
				{
					ReportDiagnostic(diagnostics, (node.Argument.Kind() == SyntaxKind.SimpleMemberAccessExpression) ? ((Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax)node.Argument).Name : node.Argument, GetInaccessibleErrorInfo(boundPropertyGroup.Properties.First()));
					break;
				}
				ImmutableArray<PropertySymbol>.Enumerator enumerator = boundPropertyGroup.Properties.GetEnumerator();
				while (enumerator.MoveNext())
				{
					PropertySymbol current = enumerator.Current;
					diagnostics.AddDependency(current.ContainingAssembly);
				}
				break;
			}
			case BoundKind.NamespaceExpression:
				diagnostics.AddAssembliesUsedByNamespaceReference(((BoundNamespaceExpression)boundExpression).NamespaceSymbol);
				break;
			}
			return new BoundNameOfOperator(node, boundExpression, ConstantValue.Create(value), GetSpecialType(SpecialType.System_String, node, diagnostics));
		}

		private static void VerifyNameOfLookupResult(NamespaceOrTypeSymbol container, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax member, LookupResult lookupResult, BindingDiagnosticBag diagnostics)
		{
			if (lookupResult.HasDiagnostic)
			{
				if (!lookupResult.IsAmbiguous)
				{
					ReportDiagnostic(diagnostics, member, lookupResult.Diagnostic);
				}
			}
			else if (!lookupResult.HasSymbol)
			{
				if ((object)container != null)
				{
					ReportDiagnostic(diagnostics, member, ErrorFactory.ErrorInfo(ERRID.ERR_NameNotMember2, member.Identifier.ValueText, container));
				}
				else
				{
					ReportDiagnostic(diagnostics, member, ErrorFactory.ErrorInfo(ERRID.ERR_NameNotDeclared1, member.Identifier.ValueText));
				}
			}
		}

		private BoundExpression BindTypeOfExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			BoundExpression boundExpression = BindRValue(node.Expression, diagnostics);
			TypeSymbol type = boundExpression.Type;
			bool isTypeOfIsNotExpression = node.Kind() == SyntaxKind.TypeOfIsNotExpression;
			Symbol symbol = BindTypeOrAliasSyntax(node.Type, diagnostics);
			TypeSymbol typeSymbol = (TypeSymbol)((symbol as TypeSymbol) ?? ((AliasSymbol)symbol).Target);
			TypeSymbol specialType = GetSpecialType(SpecialType.System_Boolean, node, diagnostics);
			if (boundExpression.HasErrors || TypeSymbolExtensions.IsErrorType(type) || TypeSymbolExtensions.IsErrorType(typeSymbol))
			{
				return new BoundTypeOf(node, boundExpression, isTypeOfIsNotExpression, typeSymbol, specialType);
			}
			if (!type.IsReferenceType && !TypeSymbolExtensions.IsTypeParameter(type))
			{
				ReportDiagnostic(diagnostics, node.Expression, ERRID.ERR_TypeOfRequiresReferenceType1, type);
			}
			else
			{
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
				ConversionKind conv = Conversions.ClassifyTryCastConversion(type, typeSymbol, ref useSiteInfo);
				if (((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)node, useSiteInfo))
				{
					diagnostics = BindingDiagnosticBag.Discarded;
				}
				else if (!Conversions.ConversionExists(conv))
				{
					ReportDiagnostic(diagnostics, node, ERRID.ERR_TypeOfExprAlwaysFalse2, type, typeSymbol);
				}
			}
			if (TypeSymbolExtensions.IsTypeParameter(type))
			{
				boundExpression = ApplyImplicitConversion(node, GetSpecialType(SpecialType.System_Object, node.Expression, diagnostics), boundExpression, diagnostics);
			}
			return new BoundTypeOf(node, boundExpression, isTypeOfIsNotExpression, typeSymbol, specialType);
		}

		internal BoundExpression BindValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax node, BindingDiagnosticBag diagnostics, bool isOperandOfConditionalBranch = false)
		{
			BoundExpression expr = BindExpression(node, isInvocationOrAddressOf: false, isOperandOfConditionalBranch, eventContext: false, diagnostics);
			return MakeValue(expr, diagnostics);
		}

		private BoundExpression AdjustReceiverTypeOrValue(BoundExpression receiver, SyntaxNode node, bool isShared, BindingDiagnosticBag diagnostics, ref BoundExpression resolvedTypeOrValueExpression)
		{
			QualificationKind qualKind = default(QualificationKind);
			return AdjustReceiverTypeOrValue(receiver, node, isShared, clearIfShared: true, diagnostics, ref qualKind, ref resolvedTypeOrValueExpression);
		}

		private BoundExpression AdjustReceiverTypeOrValue(BoundExpression receiver, SyntaxNode node, bool isShared, BindingDiagnosticBag diagnostics, ref QualificationKind qualKind)
		{
			BoundExpression resolvedTypeOrValueExpression = null;
			return AdjustReceiverTypeOrValue(receiver, node, isShared, clearIfShared: false, diagnostics, ref qualKind, ref resolvedTypeOrValueExpression);
		}

		private BoundExpression AdjustReceiverTypeOrValue(BoundExpression receiver, SyntaxNode node, bool isShared, bool clearIfShared, BindingDiagnosticBag diagnostics, ref QualificationKind qualKind, ref BoundExpression resolvedTypeOrValueExpression)
		{
			if (receiver == null)
			{
				return receiver;
			}
			if (isShared)
			{
				if (receiver.Kind == BoundKind.TypeOrValueExpression)
				{
					BoundTypeOrValueExpression boundTypeOrValueExpression = (BoundTypeOrValueExpression)receiver;
					diagnostics.AddRange(boundTypeOrValueExpression.Data.TypeDiagnostics);
					receiver = boundTypeOrValueExpression.Data.TypeExpression;
					qualKind = QualificationKind.QualifiedViaTypeName;
					resolvedTypeOrValueExpression = receiver;
				}
				if (clearIfShared)
				{
					receiver = null;
				}
			}
			else
			{
				if (receiver.Kind == BoundKind.TypeOrValueExpression)
				{
					BoundTypeOrValueExpression boundTypeOrValueExpression2 = (BoundTypeOrValueExpression)receiver;
					diagnostics.AddRange(boundTypeOrValueExpression2.Data.ValueDiagnostics);
					receiver = MakeValue(boundTypeOrValueExpression2.Data.ValueExpression, diagnostics);
					qualKind = QualificationKind.QualifiedViaValue;
					resolvedTypeOrValueExpression = receiver;
				}
				receiver = AdjustReceiverValue(receiver, node, diagnostics);
			}
			return receiver;
		}

		private static BoundExpression AdjustReceiverAmbiguousTypeOrValue(BoundExpression receiver, BindingDiagnosticBag diagnostics)
		{
			if (receiver != null && receiver.Kind == BoundKind.TypeOrValueExpression)
			{
				BoundTypeOrValueExpression boundTypeOrValueExpression = (BoundTypeOrValueExpression)receiver;
				diagnostics.AddRange(boundTypeOrValueExpression.Data.ValueDiagnostics);
				receiver = boundTypeOrValueExpression.Data.ValueExpression;
			}
			return receiver;
		}

		private static BoundExpression AdjustReceiverAmbiguousTypeOrValue(ref BoundMethodOrPropertyGroup group, BindingDiagnosticBag diagnostics)
		{
			BoundExpression boundExpression = group.ReceiverOpt;
			if (boundExpression != null && boundExpression.Kind == BoundKind.TypeOrValueExpression)
			{
				boundExpression = AdjustReceiverAmbiguousTypeOrValue(boundExpression, diagnostics);
				switch (group.Kind)
				{
				case BoundKind.MethodGroup:
				{
					BoundMethodGroup boundMethodGroup = (BoundMethodGroup)group;
					group = boundMethodGroup.Update(boundMethodGroup.TypeArgumentsOpt, boundMethodGroup.Methods, boundMethodGroup.PendingExtensionMethodsOpt, boundMethodGroup.ResultKind, boundExpression, boundMethodGroup.QualificationKind);
					break;
				}
				case BoundKind.PropertyGroup:
				{
					BoundPropertyGroup boundPropertyGroup = (BoundPropertyGroup)group;
					group = boundPropertyGroup.Update(boundPropertyGroup.Properties, boundPropertyGroup.ResultKind, boundExpression, boundPropertyGroup.QualificationKind);
					break;
				}
				default:
					throw ExceptionUtilities.UnexpectedValue(group.Kind);
				}
			}
			return boundExpression;
		}

		private BoundExpression AdjustReceiverValue(BoundExpression receiver, SyntaxNode node, BindingDiagnosticBag diagnostics)
		{
			if (!BoundExpressionExtensions.IsValue(receiver))
			{
				receiver = MakeValue(receiver, diagnostics);
			}
			if (!receiver.IsLValue && !BoundExpressionExtensions.IsPropertyOrXmlPropertyAccess(receiver))
			{
				receiver = MakeRValue(receiver, diagnostics);
			}
			TypeSymbol type = receiver.Type;
			if ((object)type == null || TypeSymbolExtensions.IsErrorType(type))
			{
				return BadExpression(node, receiver, LookupResultKind.NotAValue, ErrorTypeSymbol.UnknownResultType);
			}
			return receiver;
		}

		internal BoundExpression ReclassifyAsValue(BoundExpression expr, BindingDiagnosticBag diagnostics)
		{
			if (expr.Kind == BoundKind.ConditionalAccess && (object)expr.Type == null)
			{
				BoundConditionalAccess boundConditionalAccess = (BoundConditionalAccess)expr;
				BoundExpression boundExpression = MakeRValue(boundConditionalAccess.AccessExpression, diagnostics);
				TypeSymbol typeSymbol = boundExpression.Type;
				if (!TypeSymbolExtensions.IsErrorType(typeSymbol))
				{
					if (typeSymbol.IsValueType && !TypeSymbolExtensions.IsRestrictedType(typeSymbol))
					{
						if (!TypeSymbolExtensions.IsNullableType(typeSymbol))
						{
							typeSymbol = GetSpecialType(SpecialType.System_Nullable_T, expr.Syntax, diagnostics).Construct(typeSymbol);
						}
					}
					else if (!typeSymbol.IsReferenceType)
					{
						ReportDiagnostic(diagnostics, boundExpression.Syntax, ERRID.ERR_CannotBeMadeNullable1, typeSymbol);
						typeSymbol = ErrorTypeSymbol.UnknownResultType;
					}
				}
				return boundConditionalAccess.Update(boundConditionalAccess.Receiver, boundConditionalAccess.Placeholder, boundExpression, typeSymbol);
			}
			if (expr.HasErrors)
			{
				return expr;
			}
			switch (expr.Kind)
			{
			case BoundKind.Parenthesized:
				if (!BoundExpressionExtensions.IsNothingLiteral(expr))
				{
					return MakeRValue(expr, diagnostics);
				}
				break;
			case BoundKind.MethodGroup:
			case BoundKind.PropertyGroup:
			{
				BoundMethodOrPropertyGroup boundMethodOrPropertyGroup = (BoundMethodOrPropertyGroup)expr;
				if (IsGroupOfConstructors(boundMethodOrPropertyGroup))
				{
					ReportDiagnostic(diagnostics, boundMethodOrPropertyGroup.Syntax, ERRID.ERR_InvalidConstructorCall);
					return new BoundBadVariable(expr.Syntax, expr, ErrorTypeSymbol.UnknownResultType, hasErrors: true);
				}
				expr = BindInvocationExpression(expr.Syntax, expr.Syntax, ExtractTypeCharacter(expr.Syntax), boundMethodOrPropertyGroup, s_noArguments, default(ImmutableArray<string>), diagnostics, expr.Syntax);
				break;
			}
			case BoundKind.TypeExpression:
			{
				BoundExpression boundExpression2 = TryDefaultInstanceProperty((BoundTypeExpression)expr, diagnostics);
				if (boundExpression2 == null)
				{
					TypeSymbol type = expr.Type;
					ReportDiagnostic(diagnostics, expr.Syntax, GetTypeNotExpressionErrorId(type), type);
					return new BoundBadVariable(expr.Syntax, expr, ErrorTypeSymbol.UnknownResultType, hasErrors: true);
				}
				expr = boundExpression2;
				break;
			}
			case BoundKind.EventAccess:
				ReportDiagnostic(diagnostics, expr.Syntax, ERRID.ERR_CannotCallEvent1, ((BoundEventAccess)expr).EventSymbol);
				return new BoundBadVariable(expr.Syntax, expr, ErrorTypeSymbol.UnknownResultType, hasErrors: true);
			case BoundKind.NamespaceExpression:
				ReportDiagnostic(diagnostics, expr.Syntax, ERRID.ERR_NamespaceNotExpression1, ((BoundNamespaceExpression)expr).NamespaceSymbol);
				return new BoundBadVariable(expr.Syntax, expr, ErrorTypeSymbol.UnknownResultType, hasErrors: true);
			case BoundKind.Label:
				ReportDiagnostic(diagnostics, expr.Syntax, ERRID.ERR_VoidValue, ((BoundLabel)expr).Label.Name);
				return new BoundBadVariable(expr.Syntax, expr, ErrorTypeSymbol.UnknownResultType, hasErrors: true);
			}
			return expr;
		}

		internal BoundExpression TryDefaultInstanceProperty(BoundTypeExpression typeExpr, BindingDiagnosticBag diagnostics)
		{
			if (!IsDefaultInstancePropertyAllowed)
			{
				return null;
			}
			TypeSymbol type = typeExpr.Type;
			if (TypeSymbolExtensions.IsErrorType(type) || (object)SourceModule != type.ContainingModule || type.TypeKind != TypeKind.Class)
			{
				return null;
			}
			NamedTypeSymbol namedTypeSymbol = (NamedTypeSymbol)type;
			if (namedTypeSymbol.IsGenericType)
			{
				return null;
			}
			SynthesizedMyGroupCollectionPropertySymbol myGroupCollectionPropertyWithDefaultInstanceAlias = SourceModule.GetMyGroupCollectionPropertyWithDefaultInstanceAlias(namedTypeSymbol);
			if ((object)myGroupCollectionPropertyWithDefaultInstanceAlias == null)
			{
				return null;
			}
			SyntaxTree syntaxTree = VisualBasicSyntaxTree.ParseText("Class DefaultInstanceAlias\r\nFunction DefaultInstanceAlias()\r\nReturn " + myGroupCollectionPropertyWithDefaultInstanceAlias.DefaultInstanceAlias + "." + myGroupCollectionPropertyWithDefaultInstanceAlias.Name + "\r\nEnd Function\r\nEnd Class\r\n");
			Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax compilationUnitRoot = VisualBasicExtensions.GetCompilationUnitRoot(syntaxTree);
			foreach (Diagnostic diagnostic in syntaxTree.GetDiagnostics(compilationUnitRoot))
			{
				if (diagnostic.Severity == DiagnosticSeverity.Error)
				{
					return null;
				}
			}
			Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax methodBlockSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax)((Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassBlockSyntax)compilationUnitRoot.Members[0]).Members[0];
			if (methodBlockSyntax.Statements.Count > 1)
			{
				return null;
			}
			Microsoft.CodeAnalysis.VisualBasic.Syntax.ReturnStatementSyntax returnStatementSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.ReturnStatementSyntax)methodBlockSyntax.Statements[0];
			BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(withDiagnostics: true, diagnostics.AccumulatesDependencies);
			BoundExpression boundExpression = new DefaultInstancePropertyBinder(this).BindValue(returnStatementSyntax.Expression, instance);
			if (boundExpression.HasErrors || instance.HasAnyErrors())
			{
				instance.Free();
				return null;
			}
			diagnostics.AddDependencies(instance);
			instance.Free();
			if ((object)boundExpression.Type != namedTypeSymbol)
			{
				return null;
			}
			if ((object)ContainingType == namedTypeSymbol && !ContainingMember.IsShared)
			{
				ReportDiagnostic(diagnostics, typeExpr.Syntax, ERRID.ERR_CantReferToMyGroupInsideGroupType1, namedTypeSymbol);
			}
			switch (boundExpression.Kind)
			{
			case BoundKind.PropertyAccess:
			{
				BoundPropertyAccess boundPropertyAccess = (BoundPropertyAccess)boundExpression;
				boundExpression = new BoundPropertyAccess(typeExpr.Syntax, boundPropertyAccess.PropertySymbol, boundPropertyAccess.PropertyGroupOpt, boundPropertyAccess.AccessKind, boundPropertyAccess.IsWriteable, isLValue: false, boundPropertyAccess.ReceiverOpt, boundPropertyAccess.Arguments, boundPropertyAccess.DefaultArguments, boundPropertyAccess.Type, boundPropertyAccess.HasErrors);
				break;
			}
			case BoundKind.FieldAccess:
			{
				BoundFieldAccess boundFieldAccess = (BoundFieldAccess)boundExpression;
				boundExpression = new BoundFieldAccess(typeExpr.Syntax, boundFieldAccess.ReceiverOpt, boundFieldAccess.FieldSymbol, boundFieldAccess.IsLValue, boundFieldAccess.SuppressVirtualCalls, boundFieldAccess.ConstantsInProgressOpt, boundFieldAccess.Type, boundFieldAccess.HasErrors);
				break;
			}
			case BoundKind.Call:
			{
				BoundCall boundCall = (BoundCall)boundExpression;
				boundExpression = new BoundCall(typeExpr.Syntax, boundCall.Method, boundCall.MethodGroupOpt, boundCall.ReceiverOpt, boundCall.Arguments, boundCall.DefaultArguments, boundCall.ConstantValueOpt, isLValue: false, boundCall.SuppressObjectClone, boundCall.Type, boundCall.HasErrors);
				break;
			}
			default:
				throw ExceptionUtilities.UnexpectedValue(boundExpression.Kind);
			}
			return boundExpression;
		}

		private static ERRID GetTypeNotExpressionErrorId(TypeSymbol type)
		{
			return type.TypeKind switch
			{
				TypeKind.Class => ERRID.ERR_ClassNotExpression1, 
				TypeKind.Interface => ERRID.ERR_InterfaceNotExpression1, 
				TypeKind.Enum => ERRID.ERR_EnumNotExpression1, 
				TypeKind.Struct => ERRID.ERR_StructureNotExpression1, 
				_ => ERRID.ERR_TypeNotExpression1, 
			};
		}

		private BoundExpression MakeValue(BoundExpression expr, BindingDiagnosticBag diagnostics)
		{
			if (expr.Kind == BoundKind.Parenthesized && !BoundExpressionExtensions.IsNothingLiteral(expr))
			{
				BoundParenthesized boundParenthesized = (BoundParenthesized)expr;
				BoundExpression boundExpression = MakeValue(boundParenthesized.Expression, diagnostics);
				return boundParenthesized.Update(boundExpression, boundExpression.Type);
			}
			expr = ReclassifyAsValue(expr, diagnostics);
			if (expr.HasErrors)
			{
				if (!BoundExpressionExtensions.IsValue(expr) || (object)expr.Type == null || TypeSymbolExtensions.IsVoidType(expr.Type))
				{
					return BoundNodeExtensions.MakeCompilerGenerated(BadExpression(expr.Syntax, expr, ErrorTypeSymbol.UnknownResultType));
				}
				return expr;
			}
			TypeSymbol type = expr.Type;
			SyntaxNode syntax = expr.Syntax;
			if (!BoundExpressionExtensions.IsValue(expr) || ((object)type != null && type.SpecialType == SpecialType.System_Void))
			{
				ReportDiagnostic(diagnostics, syntax, ERRID.ERR_VoidValue);
				return BadExpression(syntax, expr, LookupResultKind.NotAValue, ErrorTypeSymbol.UnknownResultType);
			}
			if (expr.Kind == BoundKind.PropertyAccess)
			{
				BoundPropertyAccess boundPropertyAccess = (BoundPropertyAccess)expr;
				switch (boundPropertyAccess.AccessKind)
				{
				case PropertyAccessKind.Set:
					ReportDiagnostic(diagnostics, syntax, ERRID.ERR_VoidValue);
					return BadExpression(syntax, expr, LookupResultKind.NotAValue, ErrorTypeSymbol.UnknownResultType);
				case PropertyAccessKind.Unknown:
				{
					bool flag = true;
					PropertySymbol propertySymbol = boundPropertyAccess.PropertySymbol;
					if (!propertySymbol.IsReadable)
					{
						ReportDiagnostic(diagnostics, syntax, ERRID.ERR_NoGetProperty1, CustomSymbolDisplayFormatter.ShortErrorName(propertySymbol));
					}
					else
					{
						MethodSymbol mostDerivedGetMethod = propertySymbol.GetMostDerivedGetMethod();
						if (!ReportUseSite(diagnostics, syntax, mostDerivedGetMethod))
						{
							TypeSymbol accessThroughType = GetAccessThroughType(boundPropertyAccess.ReceiverOpt);
							CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
							if (IsAccessible(mostDerivedGetMethod, ref useSiteInfo, accessThroughType) || !IsAccessible(propertySymbol, ref useSiteInfo, accessThroughType))
							{
								flag = false;
							}
							else
							{
								ReportDiagnostic(diagnostics, syntax, ERRID.ERR_NoAccessibleGet, CustomSymbolDisplayFormatter.ShortErrorName(propertySymbol));
							}
							((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(syntax, useSiteInfo);
						}
					}
					if (flag)
					{
						return BadExpression(syntax, expr, LookupResultKind.NotAValue, propertySymbol.Type);
					}
					break;
				}
				}
			}
			else
			{
				if (!BoundExpressionExtensions.IsLateBound(expr))
				{
					_ = expr.Kind;
					_ = 35;
					return expr;
				}
				if ((BoundExpressionExtensions.GetLateBoundAccessKind(expr) & (LateBoundAccessKind.Set | LateBoundAccessKind.Call)) != 0)
				{
					ReportDiagnostic(diagnostics, syntax, ERRID.ERR_VoidValue);
					return BadExpression(syntax, expr, LookupResultKind.NotAValue, ErrorTypeSymbol.UnknownResultType);
				}
			}
			return expr;
		}

		private TypeSymbol GetAccessThroughType(BoundExpression receiverOpt)
		{
			if (receiverOpt == null || receiverOpt.Kind == BoundKind.MyBaseReference)
			{
				return ContainingType;
			}
			return receiverOpt.Type;
		}

		private BoundExpression BindRValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax node, BindingDiagnosticBag diagnostics, bool isOperandOfConditionalBranch = false)
		{
			BoundExpression expr = BindExpression(node, isInvocationOrAddressOf: false, isOperandOfConditionalBranch, eventContext: false, diagnostics);
			return MakeRValue(expr, diagnostics);
		}

		internal BoundExpression MakeRValue(BoundExpression expr, BindingDiagnosticBag diagnostics)
		{
			if (expr.Kind == BoundKind.Parenthesized && !BoundExpressionExtensions.IsNothingLiteral(expr))
			{
				BoundParenthesized boundParenthesized = (BoundParenthesized)expr;
				BoundExpression boundExpression = MakeRValue(boundParenthesized.Expression, diagnostics);
				return boundParenthesized.Update(boundExpression, boundExpression.Type);
			}
			if (expr.Kind == BoundKind.XmlMemberAccess)
			{
				BoundXmlMemberAccess boundXmlMemberAccess = (BoundXmlMemberAccess)expr;
				BoundExpression memberAccess = MakeRValue(boundXmlMemberAccess.MemberAccess, diagnostics);
				return BoundExpressionExtensions.Update(boundXmlMemberAccess, memberAccess);
			}
			expr = MakeValue(expr, diagnostics);
			if (expr.HasErrors)
			{
				return expr.MakeRValue();
			}
			if ((object)expr.Type == null)
			{
				return ReclassifyExpression(expr, diagnostics);
			}
			if (expr.IsLValue)
			{
				expr = expr.MakeRValue();
			}
			else if (expr.Kind == BoundKind.PropertyAccess)
			{
				BoundPropertyAccess boundPropertyAccess = (BoundPropertyAccess)expr;
				MethodSymbol mostDerivedGetMethod = boundPropertyAccess.PropertySymbol.GetMostDerivedGetMethod();
				ReportUseSite(diagnostics, expr.Syntax, mostDerivedGetMethod);
				ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagnostics, mostDerivedGetMethod, expr.Syntax);
				switch (boundPropertyAccess.AccessKind)
				{
				case PropertyAccessKind.Unknown:
					WarnOnRecursiveAccess(boundPropertyAccess, PropertyAccessKind.Get, diagnostics);
					expr = boundPropertyAccess.SetAccessKind(PropertyAccessKind.Get);
					break;
				default:
					throw ExceptionUtilities.UnexpectedValue(boundPropertyAccess.AccessKind);
				case PropertyAccessKind.Get:
					break;
				}
			}
			else if (BoundExpressionExtensions.IsLateBound(expr))
			{
				switch (BoundExpressionExtensions.GetLateBoundAccessKind(expr))
				{
				case LateBoundAccessKind.Unknown:
					expr = BoundExpressionExtensions.SetLateBoundAccessKind(expr, LateBoundAccessKind.Get);
					break;
				default:
					throw ExceptionUtilities.UnexpectedValue(BoundExpressionExtensions.GetLateBoundAccessKind(expr));
				case LateBoundAccessKind.Get:
					break;
				}
			}
			return expr;
		}

		private BoundExpression MakeRValueAndIgnoreDiagnostics(BoundExpression expr)
		{
			expr = MakeRValue(expr, BindingDiagnosticBag.Discarded);
			return expr;
		}

		internal BoundExpression ReclassifyExpression(BoundExpression expr, BindingDiagnosticBag diagnostics)
		{
			if (BoundExpressionExtensions.IsNothingLiteral(expr))
			{
				return new BoundConversion(expr.Syntax, expr, ConversionKind.WideningNothingLiteral, @checked: false, explicitCastInCode: false, expr.ConstantValueOpt, GetSpecialType(SpecialType.System_Object, expr.Syntax, diagnostics));
			}
			switch (expr.Kind)
			{
			case BoundKind.Parenthesized:
			{
				BoundParenthesized boundParenthesized = (BoundParenthesized)expr;
				BoundExpression boundExpression = ReclassifyExpression(boundParenthesized.Expression, diagnostics);
				return boundParenthesized.Update(boundExpression, boundExpression.Type);
			}
			case BoundKind.UnboundLambda:
				return ReclassifyUnboundLambdaExpression((UnboundLambda)expr, diagnostics);
			case BoundKind.AddressOfOperator:
			{
				BoundAddressOfOperator boundAddressOfOperator = (BoundAddressOfOperator)expr;
				if (boundAddressOfOperator.MethodGroup.ResultKind == LookupResultKind.Inaccessible)
				{
					if (boundAddressOfOperator.MethodGroup.Methods.Length == 1)
					{
						ReportDiagnostic(diagnostics, boundAddressOfOperator.MethodGroup.Syntax, GetInaccessibleErrorInfo(boundAddressOfOperator.MethodGroup.Methods[0]));
						break;
					}
					ReportDiagnostic(diagnostics, boundAddressOfOperator.MethodGroup.Syntax, ERRID.ERR_NoViableOverloadCandidates1, boundAddressOfOperator.MethodGroup.Methods[0].Name);
				}
				break;
			}
			case BoundKind.ArrayLiteral:
				return ReclassifyArrayLiteralExpression((BoundArrayLiteral)expr, diagnostics);
			case BoundKind.TupleLiteral:
			{
				BoundTupleLiteral boundTupleLiteral = (BoundTupleLiteral)expr;
				if ((object)boundTupleLiteral.InferredType != null)
				{
					return ReclassifyTupleLiteralExpression(boundTupleLiteral, diagnostics);
				}
				break;
			}
			}
			ReportDiagnostic(diagnostics, expr.Syntax, ERRID.ERR_VoidValue);
			return BadExpression(expr.Syntax, expr, ErrorTypeSymbol.UnknownResultType);
		}

		private BoundExpression ReclassifyArrayLiteralExpression(SyntaxKind conversionSemantics, SyntaxNode tree, ConversionKind conv, bool isExplicit, BoundArrayLiteral arrayLiteral, TypeSymbol destination, BindingDiagnosticBag diagnostics)
		{
			if (Conversions.NoConversion(conv) && (conv & ConversionKind.FailedDueToArrayLiteralElementConversion) == 0)
			{
				if (!arrayLiteral.HasDominantType)
				{
					ReportDiagnostic(diagnostics, arrayLiteral.Syntax, ERRID.ERR_ArrayInitNoType);
				}
				else
				{
					ReportNoConversionError(arrayLiteral.Syntax, arrayLiteral.InferredType, destination, diagnostics);
				}
				BoundExpression operand = ApplyImplicitConversion(arrayLiteral.Syntax, arrayLiteral.InferredType, arrayLiteral, BindingDiagnosticBag.Discarded);
				return conversionSemantics switch
				{
					SyntaxKind.CTypeKeyword => new BoundConversion(tree, operand, conv, @checked: false, isExplicit, destination), 
					SyntaxKind.DirectCastKeyword => new BoundDirectCast(tree, operand, conv, destination), 
					SyntaxKind.TryCastKeyword => new BoundTryCast(tree, operand, conv, destination), 
					_ => throw ExceptionUtilities.UnexpectedValue(conversionSemantics), 
				};
			}
			ArrayTypeSymbol arrayTypeSymbol = arrayLiteral.InferredType;
			NamedTypeSymbol namedTypeSymbol = destination as NamedTypeSymbol;
			NamedTypeSymbol namedTypeSymbol2 = namedTypeSymbol?.OriginalDefinition;
			ArrayTypeSymbol arrayTypeSymbol2 = destination as ArrayTypeSymbol;
			TypeSymbol typeSymbol = null;
			if ((object)arrayTypeSymbol2 != null && (arrayTypeSymbol.Rank == arrayTypeSymbol2.Rank || arrayLiteral.IsEmptyArrayLiteral))
			{
				typeSymbol = arrayTypeSymbol2.ElementType;
				arrayTypeSymbol = arrayTypeSymbol2;
			}
			else if ((arrayTypeSymbol.Rank == 1 || arrayLiteral.IsEmptyArrayLiteral) && (object)namedTypeSymbol2 != null && (namedTypeSymbol2.SpecialType == SpecialType.System_Collections_Generic_IEnumerable_T || namedTypeSymbol2.SpecialType == SpecialType.System_Collections_Generic_IList_T || namedTypeSymbol2.SpecialType == SpecialType.System_Collections_Generic_ICollection_T || namedTypeSymbol2.SpecialType == SpecialType.System_Collections_Generic_IReadOnlyList_T || namedTypeSymbol2.SpecialType == SpecialType.System_Collections_Generic_IReadOnlyCollection_T))
			{
				typeSymbol = namedTypeSymbol.TypeArgumentsNoUseSiteDiagnostics[0];
				arrayTypeSymbol = ArrayTypeSymbol.CreateVBArray(typeSymbol, default(ImmutableArray<CustomModifier>), 1, Compilation);
			}
			else
			{
				arrayTypeSymbol2 = arrayTypeSymbol;
				typeSymbol = arrayTypeSymbol.ElementType;
			}
			ReportArrayLiteralDiagnostics(arrayLiteral, arrayTypeSymbol2, diagnostics);
			BoundArrayInitialization boundArrayInitialization;
			ImmutableArray<BoundExpression> bounds;
			if (arrayLiteral.IsEmptyArrayLiteral)
			{
				DimensionSize[] knownSizes = new DimensionSize[arrayTypeSymbol.Rank - 1 + 1];
				boundArrayInitialization = ReclassifyEmptyArrayInitialization(arrayLiteral, arrayTypeSymbol.Rank);
				bounds = CreateArrayBounds(arrayLiteral.Syntax, knownSizes, diagnostics);
			}
			else
			{
				boundArrayInitialization = ReclassifyArrayInitialization(arrayLiteral.Initializer, typeSymbol, diagnostics);
				bounds = arrayLiteral.Bounds;
			}
			boundArrayInitialization.SetWasCompilerGenerated();
			BoundArrayCreation boundArrayCreation = new BoundArrayCreation(arrayLiteral.Syntax, bounds, boundArrayInitialization, arrayLiteral, conv, arrayTypeSymbol);
			if (conversionSemantics == SyntaxKind.CTypeKeyword)
			{
				return ApplyConversion(tree, destination, boundArrayCreation, isExplicit, diagnostics);
			}
			BoundExpression argument = boundArrayCreation;
			conv = Conversions.ClassifyStringConversion(arrayTypeSymbol, destination);
			if (Conversions.IsWideningConversion(conv))
			{
				argument = CreatePredefinedConversion(arrayLiteral.Syntax, boundArrayCreation, conv, isExplicit, destination, diagnostics);
			}
			return conversionSemantics switch
			{
				SyntaxKind.DirectCastKeyword => ApplyDirectCastConversion(tree, argument, destination, diagnostics), 
				SyntaxKind.TryCastKeyword => ApplyTryCastConversion(tree, argument, destination, diagnostics), 
				_ => throw ExceptionUtilities.UnexpectedValue(conversionSemantics), 
			};
		}

		private void ReportArrayLiteralDiagnostics(BoundArrayLiteral arrayLiteral, ArrayTypeSymbol targetArrayType, BindingDiagnosticBag diagnostics)
		{
			if ((object)targetArrayType == arrayLiteral.InferredType)
			{
				ReportArrayLiteralInferredTypeDiagnostics(arrayLiteral, diagnostics);
			}
		}

		private void ReportArrayLiteralInferredTypeDiagnostics(BoundArrayLiteral arrayLiteral, BindingDiagnosticBag diagnostics)
		{
			TypeSymbol elementType = arrayLiteral.InferredType.ElementType;
			if (TypeSymbolExtensions.IsRestrictedType(elementType))
			{
				ReportDiagnostic(diagnostics, arrayLiteral.Syntax, ERRID.ERR_RestrictedType1, elementType);
				return;
			}
			if (!arrayLiteral.HasDominantType)
			{
				ReportDiagnostic(diagnostics, arrayLiteral.Syntax, ERRID.ERR_ArrayInitNoType);
				return;
			}
			switch (OptionStrict)
			{
			case OptionStrict.On:
				if (arrayLiteral.NumberOfCandidates == 0)
				{
					ReportDiagnostic(diagnostics, arrayLiteral.Syntax, ERRID.ERR_ArrayInitNoTypeObjectDisallowed);
				}
				else if (arrayLiteral.NumberOfCandidates > 1)
				{
					ReportDiagnostic(diagnostics, arrayLiteral.Syntax, ERRID.ERR_ArrayInitTooManyTypesObjectDisallowed);
				}
				break;
			case OptionStrict.Custom:
				if (arrayLiteral.NumberOfCandidates == 0)
				{
					ReportDiagnostic(diagnostics, arrayLiteral.Syntax, ErrorFactory.ErrorInfo(ERRID.WRN_ObjectAssumed1, ErrorFactory.ErrorInfo(ERRID.WRN_ArrayInitNoTypeObjectAssumed)));
				}
				else if (arrayLiteral.NumberOfCandidates > 1)
				{
					ReportDiagnostic(diagnostics, arrayLiteral.Syntax, ErrorFactory.ErrorInfo(ERRID.WRN_ObjectAssumed1, ErrorFactory.ErrorInfo(ERRID.WRN_ArrayInitTooManyTypesObjectAssumed)));
				}
				break;
			}
		}

		private BoundArrayInitialization ReclassifyArrayInitialization(BoundArrayInitialization arrayInitialization, TypeSymbol elementType, BindingDiagnosticBag diagnostics)
		{
			ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
			ImmutableArray<BoundExpression>.Enumerator enumerator = arrayInitialization.Initializers.GetEnumerator();
			while (enumerator.MoveNext())
			{
				BoundExpression current = enumerator.Current;
				current = ((current.Kind != BoundKind.ArrayInitialization) ? ApplyImplicitConversion(current.Syntax, elementType, current, diagnostics) : ReclassifyArrayInitialization((BoundArrayInitialization)current, elementType, diagnostics));
				instance.Add(current);
			}
			arrayInitialization = new BoundArrayInitialization(arrayInitialization.Syntax, instance.ToImmutableAndFree(), null);
			return arrayInitialization;
		}

		private BoundArrayInitialization ReclassifyEmptyArrayInitialization(BoundArrayLiteral arrayLiteral, int rank)
		{
			BoundArrayInitialization boundArrayInitialization = arrayLiteral.Initializer;
			if (rank == 1)
			{
				return boundArrayInitialization;
			}
			ImmutableArray<BoundExpression> initializers = ImmutableArray<BoundExpression>.Empty;
			int num = rank - 1;
			for (int i = 1; i <= num; i++)
			{
				boundArrayInitialization = BoundNodeExtensions.MakeCompilerGenerated(new BoundArrayInitialization(boundArrayInitialization.Syntax, initializers, null));
				initializers = ImmutableArray.Create((BoundExpression)boundArrayInitialization);
			}
			return new BoundArrayInitialization(boundArrayInitialization.Syntax, initializers, null);
		}

		private BoundExpression ReclassifyTupleLiteralExpression(BoundTupleLiteral tupleLiteral, BindingDiagnosticBag diagnostics)
		{
			return ApplyImplicitConversion(tupleLiteral.Syntax, tupleLiteral.InferredType, tupleLiteral, diagnostics);
		}

		private BoundExpression ReclassifyArrayLiteralExpression(BoundArrayLiteral arrayLiteral, BindingDiagnosticBag diagnostics)
		{
			return ApplyImplicitConversion(arrayLiteral.Syntax, arrayLiteral.InferredType, arrayLiteral, diagnostics);
		}

		private BoundExpression ReclassifyUnboundLambdaExpression(UnboundLambda lambda, BindingDiagnosticBag diagnostics)
		{
			return ApplyImplicitConversion(lambda.Syntax, lambda.InferredAnonymousDelegate.Key, lambda, diagnostics);
		}

		private BoundExpression BindAssignmentTarget(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			BoundExpression expression = BindExpression(node, diagnostics);
			return BindAssignmentTarget(node, expression, diagnostics);
		}

		private BoundExpression BindAssignmentTarget(SyntaxNode node, BoundExpression expression, BindingDiagnosticBag diagnostics)
		{
			expression = ReclassifyAsValue(expression, diagnostics);
			if (!IsValidAssignmentTarget(expression))
			{
				if (!expression.HasErrors)
				{
					ReportAssignmentToRValue(expression, diagnostics);
				}
				expression = BadExpression(node, expression, LookupResultKind.NotAVariable, ErrorTypeSymbol.UnknownResultType);
			}
			else if (expression.Kind == BoundKind.LateInvocation)
			{
				BoundLateInvocation boundLateInvocation = (BoundLateInvocation)expression;
				if (!boundLateInvocation.ArgumentsOpt.IsEmpty)
				{
					BoundExpression[] array = new BoundExpression[boundLateInvocation.ArgumentsOpt.Length - 1 + 1];
					int num = array.Length - 1;
					for (int i = 0; i <= num; i++)
					{
						array[i] = MakeRValue(boundLateInvocation.ArgumentsOpt[i], diagnostics);
					}
					expression = boundLateInvocation.Update(boundLateInvocation.Member, array.AsImmutableOrNull(), boundLateInvocation.ArgumentNamesOpt, boundLateInvocation.AccessKind, boundLateInvocation.MethodOrPropertyGroupOpt, boundLateInvocation.Type);
				}
			}
			return expression;
		}

		internal static bool IsValidAssignmentTarget(BoundExpression expression)
		{
			switch (expression.Kind)
			{
			case BoundKind.PropertyAccess:
			{
				BoundPropertyAccess obj = (BoundPropertyAccess)expression;
				PropertySymbol propertySymbol = obj.PropertySymbol;
				BoundExpression receiverOpt = obj.ReceiverOpt;
				return obj.AccessKind != PropertyAccessKind.Get && (propertySymbol.IsShared || receiverOpt == null || receiverOpt.IsLValue || BoundExpressionExtensions.IsMeReference(receiverOpt) || BoundExpressionExtensions.IsMyClassReference(receiverOpt) || !receiverOpt.Type.IsValueType);
			}
			case BoundKind.XmlMemberAccess:
				return IsValidAssignmentTarget(((BoundXmlMemberAccess)expression).MemberAccess);
			case BoundKind.Call:
				return ((BoundCall)expression).IsLValue;
			case BoundKind.LateInvocation:
			{
				BoundLateInvocation boundLateInvocation = (BoundLateInvocation)expression;
				return boundLateInvocation.AccessKind != LateBoundAccessKind.Get && boundLateInvocation.AccessKind != LateBoundAccessKind.Call;
			}
			case BoundKind.LateMemberAccess:
			{
				BoundLateMemberAccess boundLateMemberAccess = (BoundLateMemberAccess)expression;
				return boundLateMemberAccess.AccessKind != LateBoundAccessKind.Get && boundLateMemberAccess.AccessKind != LateBoundAccessKind.Call;
			}
			default:
				return expression.IsLValue;
			}
		}

		private static void ReportAssignmentToRValue(BoundExpression expr, BindingDiagnosticBag diagnostics)
		{
			ReportDiagnostic(id: expr.IsConstant ? ERRID.ERR_CantAssignToConst : ((!ExpressionRefersToReadonlyVariable(expr)) ? ERRID.ERR_LValueRequired : ERRID.ERR_ReadOnlyAssignment), diagBag: diagnostics, syntax: expr.Syntax);
		}

		public static bool ExpressionRefersToReadonlyVariable(BoundExpression node, bool digThroughProperty = true)
		{
			if (node.Kind == BoundKind.FieldAccess)
			{
				BoundFieldAccess boundFieldAccess = (BoundFieldAccess)node;
				if (boundFieldAccess.FieldSymbol.IsReadOnly)
				{
					return true;
				}
				BoundExpression receiverOpt = boundFieldAccess.ReceiverOpt;
				if (receiverOpt != null && BoundExpressionExtensions.IsValue(receiverOpt) && receiverOpt.Type.IsValueType)
				{
					return ExpressionRefersToReadonlyVariable(receiverOpt, digThroughProperty: false);
				}
			}
			else if (node.Kind == BoundKind.Local)
			{
				return ((BoundLocal)node).LocalSymbol.IsReadOnly;
			}
			return false;
		}

		internal bool IsLValueFieldAccess(FieldSymbol field, BoundExpression receiver)
		{
			if (field.IsConst)
			{
				return false;
			}
			if (!field.IsShared && receiver != null && BoundExpressionExtensions.IsValue(receiver))
			{
				TypeSymbol type = receiver.Type;
				if (!TypeSymbolExtensions.IsTypeParameter(type) && type.IsValueType && !receiver.IsLValue && !BoundExpressionExtensions.IsMeReference(receiver) && !BoundExpressionExtensions.IsMyClassReference(receiver))
				{
					return false;
				}
			}
			if (!field.IsReadOnly)
			{
				return true;
			}
			switch (KindOfContainingMethodAtRunTime())
			{
			case MethodKind.Constructor:
				if (field.IsShared || receiver == null || !BoundExpressionExtensions.IsInstanceReference(receiver))
				{
					return false;
				}
				break;
			case MethodKind.StaticConstructor:
				if (!field.IsShared)
				{
					return false;
				}
				break;
			default:
				return false;
			}
			return Compilation.FeatureStrictEnabled ? ((object)ContainingMember.ContainingSymbol == field.ContainingSymbol) : ((object)ContainingMember.ContainingSymbol.OriginalDefinition == field.ContainingSymbol.OriginalDefinition);
		}

		private MethodKind KindOfContainingMethodAtRunTime()
		{
			Symbol containingMember = ContainingMember;
			if ((object)containingMember != null)
			{
				switch (containingMember.Kind)
				{
				case SymbolKind.Method:
					return ((MethodSymbol)containingMember).MethodKind;
				case SymbolKind.Field:
				case SymbolKind.Property:
					if (containingMember.IsShared)
					{
						return MethodKind.StaticConstructor;
					}
					return MethodKind.Constructor;
				default:
					throw ExceptionUtilities.UnexpectedValue(containingMember.Kind);
				case SymbolKind.NamedType:
				case SymbolKind.Namespace:
				case SymbolKind.Parameter:
					break;
				}
			}
			return MethodKind.Ordinary;
		}

		private BoundExpression BindTernaryConditionalExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			BoundExpression boundExpression = BindBooleanExpression(node.Condition, diagnostics);
			BoundExpression boundExpression2 = BindValue(node.WhenTrue, diagnostics);
			BoundExpression boundExpression3 = BindValue(node.WhenFalse, diagnostics);
			bool flag = boundExpression.HasErrors || boundExpression2.HasErrors || boundExpression3.HasErrors;
			TypeSymbol typeSymbol;
			if (BoundExpressionExtensions.IsNothingLiteral(boundExpression2) && BoundExpressionExtensions.IsNothingLiteral(boundExpression3))
			{
				typeSymbol = GetSpecialType(SpecialType.System_Object, node, diagnostics);
			}
			else
			{
				int numCandidates = 0;
				ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance(2);
				instance.Add(boundExpression2);
				instance.Add(boundExpression3);
				InferenceErrorReasons errorReasons = InferenceErrorReasons.Other;
				typeSymbol = InferDominantTypeOfExpressions(node, instance, diagnostics, ref numCandidates, ref errorReasons);
				instance.Free();
				if (!flag)
				{
					flag = GenerateDiagnosticsForDominantTypeInferenceInIfExpression(typeSymbol, numCandidates, node, diagnostics);
				}
			}
			if (!flag || (object)typeSymbol != null)
			{
				boundExpression2 = ApplyImplicitConversion(node.WhenTrue, typeSymbol, boundExpression2, diagnostics);
				boundExpression3 = ApplyImplicitConversion(node.WhenFalse, typeSymbol, boundExpression3, diagnostics);
				flag = flag || boundExpression2.HasErrors || boundExpression3.HasErrors;
			}
			else
			{
				boundExpression2 = MakeRValueAndIgnoreDiagnostics(boundExpression2);
				boundExpression3 = MakeRValueAndIgnoreDiagnostics(boundExpression3);
			}
			ConstantValue constantValueOpt = null;
			if (!flag && IsConstantAllowingCompileTimeFolding(boundExpression2) && IsConstantAllowingCompileTimeFolding(boundExpression3) && IsConstantAllowingCompileTimeFolding(boundExpression))
			{
				constantValueOpt = (boundExpression.ConstantValueOpt.BooleanValue ? boundExpression2.ConstantValueOpt : boundExpression3.ConstantValueOpt);
			}
			return new BoundTernaryConditionalExpression(node, boundExpression, boundExpression2, boundExpression3, constantValueOpt, typeSymbol ?? ErrorTypeSymbol.UnknownResultType, flag);
		}

		private static bool IsConstantAllowingCompileTimeFolding(BoundExpression candidate)
		{
			if (candidate.IsConstant && !candidate.ConstantValueOpt.IsBad)
			{
				if (!BoundExpressionExtensions.IsNothingLiteral(candidate))
				{
					if ((object)candidate.Type != null)
					{
						return TypeSymbolExtensions.AllowsCompileTimeOperations(candidate.Type);
					}
					return false;
				}
				return true;
			}
			return false;
		}

		private BoundExpression BindBinaryConditionalExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			BoundExpression boundExpression = BindValue(node.FirstExpression, diagnostics);
			BoundExpression boundExpression2 = BindValue(node.SecondExpression, diagnostics);
			bool flag = boundExpression.HasErrors || boundExpression2.HasErrors || node.ContainsDiagnostics;
			TypeSymbol typeSymbol;
			if (BoundExpressionExtensions.IsNothingLiteral(boundExpression) && BoundExpressionExtensions.IsNothingLiteral(boundExpression2))
			{
				typeSymbol = boundExpression.Type ?? boundExpression2.Type ?? GetSpecialType(SpecialType.System_Object, node, diagnostics);
			}
			else if ((object)boundExpression.Type != null && TypeSymbolExtensions.IsNullableType(boundExpression.Type) && BoundExpressionExtensions.IsNothingLiteral(boundExpression2))
			{
				typeSymbol = boundExpression.Type;
			}
			else
			{
				int numCandidates = 0;
				ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance(2);
				if ((object)boundExpression.Type != null && TypeSymbolExtensions.IsNullableType(boundExpression.Type) && ((object)boundExpression2.Type == null || !TypeSymbolExtensions.IsNullableType(boundExpression2.Type)))
				{
					TypeSymbol nullableUnderlyingType = TypeSymbolExtensions.GetNullableUnderlyingType(boundExpression.Type);
					instance.Add(new BoundRValuePlaceholder(node.FirstExpression, nullableUnderlyingType));
				}
				else
				{
					instance.Add(boundExpression);
				}
				instance.Add(boundExpression2);
				InferenceErrorReasons errorReasons = InferenceErrorReasons.Other;
				typeSymbol = InferDominantTypeOfExpressions(node, instance, diagnostics, ref numCandidates, ref errorReasons);
				instance.Free();
				if (!flag)
				{
					flag = GenerateDiagnosticsForDominantTypeInferenceInIfExpression(typeSymbol, numCandidates, node, diagnostics);
				}
			}
			if (!flag && IsConstantAllowingCompileTimeFolding(boundExpression) && IsConstantAllowingCompileTimeFolding(boundExpression2) && (BoundExpressionExtensions.IsNothingLiteral(boundExpression) || boundExpression.ConstantValueOpt.IsString))
			{
				ConstantValue constantValueOpt;
				if (BoundExpressionExtensions.IsNothingLiteral(boundExpression))
				{
					constantValueOpt = boundExpression2.ConstantValueOpt;
					if (!BoundExpressionExtensions.IsNothingLiteral(boundExpression2))
					{
						typeSymbol = boundExpression2.Type;
					}
				}
				else
				{
					constantValueOpt = boundExpression.ConstantValueOpt;
					typeSymbol = boundExpression.Type;
				}
				return AnalyzeConversionAndCreateBinaryConditionalExpression(node, boundExpression, boundExpression2, constantValueOpt, typeSymbol, hasErrors: false, diagnostics);
			}
			if (!flag && (object)boundExpression.Type == null && !BoundExpressionExtensions.IsNothingLiteral(boundExpression))
			{
				boundExpression = ApplyImplicitConversion(node.FirstExpression, typeSymbol, boundExpression, diagnostics);
				flag = boundExpression.HasErrors;
			}
			if (!BoundExpressionExtensions.IsNothingLiteral(boundExpression))
			{
				if (!flag)
				{
					boundExpression = MakeRValue(boundExpression, diagnostics);
					flag = boundExpression.HasErrors;
				}
				else
				{
					boundExpression = MakeRValueAndIgnoreDiagnostics(boundExpression);
				}
			}
			BoundExpression boundExpression3 = boundExpression2;
			if (!flag)
			{
				boundExpression3 = ApplyImplicitConversion(node.SecondExpression, typeSymbol, boundExpression2, diagnostics);
				flag = boundExpression3.HasErrors;
			}
			else
			{
				boundExpression3 = MakeRValueAndIgnoreDiagnostics(boundExpression2);
			}
			if (!flag && !BoundExpressionExtensions.IsNothingLiteral(boundExpression) && !TypeSymbolExtensions.IsNullableType(boundExpression.Type) && !boundExpression.Type.IsReferenceType)
			{
				if (!boundExpression.Type.IsValueType)
				{
					Parser.CheckFeatureAvailability(diagnostics, node.Location, ((VisualBasicParseOptions)node.SyntaxTree.Options).LanguageVersion, Feature.UnconstrainedTypeParameterInConditional);
				}
				else
				{
					ReportDiagnostic(diagnostics, node.FirstExpression, ERRID.ERR_IllegalCondTypeInIIF);
					flag = true;
				}
			}
			return AnalyzeConversionAndCreateBinaryConditionalExpression(node, boundExpression, boundExpression3, null, typeSymbol ?? ErrorTypeSymbol.UnknownResultType, flag, diagnostics);
		}

		private BoundExpression AnalyzeConversionAndCreateBinaryConditionalExpression(SyntaxNode syntax, BoundExpression testExpression, BoundExpression elseExpression, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors, BindingDiagnosticBag diagnostics, bool explicitConversion = false)
		{
			BoundExpression boundExpression = null;
			BoundRValuePlaceholder boundRValuePlaceholder = null;
			if (!hasErrors)
			{
				if (!testExpression.IsConstant)
				{
					boundRValuePlaceholder = new BoundRValuePlaceholder(testExpression.Syntax, TypeSymbolExtensions.GetNullableUnderlyingTypeOrSelf(testExpression.Type));
				}
				boundExpression = ApplyConversion(testExpression.Syntax, type, boundRValuePlaceholder ?? testExpression, explicitConversion, diagnostics);
				if (boundExpression == (boundRValuePlaceholder ?? testExpression))
				{
					boundExpression = null;
					boundRValuePlaceholder = null;
				}
			}
			return new BoundBinaryConditionalExpression(syntax, testExpression, boundExpression, boundRValuePlaceholder, elseExpression, constantValueOpt, type, hasErrors);
		}

		private bool GenerateDiagnosticsForDominantTypeInferenceInIfExpression(TypeSymbol dominantType, int numCandidates, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			bool result = false;
			if ((object)dominantType == null)
			{
				ReportDiagnostic(diagnostics, node, ERRID.ERR_IfNoType);
				result = true;
			}
			else if (numCandidates == 0)
			{
				if (OptionStrict == OptionStrict.On)
				{
					ReportDiagnostic(diagnostics, node, ERRID.ERR_IfNoTypeObjectDisallowed);
					result = true;
				}
				else if (OptionStrict == OptionStrict.Custom)
				{
					ReportDiagnostic(diagnostics, node, ErrorFactory.ErrorInfo(ERRID.WRN_ObjectAssumed1, ErrorFactory.ErrorInfo(ERRID.WRN_IfNoTypeObjectAssumed)));
				}
			}
			else if (numCandidates > 1)
			{
				if (OptionStrict == OptionStrict.On)
				{
					ReportDiagnostic(diagnostics, node, ERRID.ERR_IfTooManyTypesObjectDisallowed);
					result = true;
				}
				else if (OptionStrict == OptionStrict.Custom)
				{
					ReportDiagnostic(diagnostics, node, ErrorFactory.ErrorInfo(ERRID.WRN_ObjectAssumed1, ErrorFactory.ErrorInfo(ERRID.WRN_IfTooManyTypesObjectAssumed)));
				}
			}
			return result;
		}

		private bool IsMeOrMyBaseOrMyClassInSharedContext()
		{
			if (BindingLocation == BindingLocation.Attribute)
			{
				return true;
			}
			Symbol containingMember = ContainingMember;
			if ((object)containingMember != null)
			{
				switch (containingMember.Kind)
				{
				case SymbolKind.Method:
				case SymbolKind.Property:
					return containingMember.IsShared || TypeSymbolExtensions.IsModuleType(ContainingType);
				case SymbolKind.Field:
					return containingMember.IsShared || TypeSymbolExtensions.IsModuleType(ContainingType) || ((FieldSymbol)containingMember).IsConst;
				}
			}
			return true;
		}

		private bool CheckMeOrMyBaseOrMyClassInSharedOrDisallowedContext(bool implicitReference, out ERRID errorId)
		{
			errorId = ERRID.ERR_None;
			NamedTypeSymbol containingType = ContainingType;
			if ((object)containingType != null && containingType.IsScriptClass)
			{
				if (implicitReference)
				{
					return true;
				}
				errorId = ERRID.ERR_KeywordNotAllowedInScript;
				return false;
			}
			if (IsMeOrMyBaseOrMyClassInSharedContext())
			{
				errorId = (implicitReference ? ERRID.ERR_BadInstanceMemberAccess : (((object)containingType != null && TypeSymbolExtensions.IsModuleType(containingType)) ? ERRID.ERR_UseOfKeywordFromModule1 : ERRID.ERR_UseOfKeywordNotInInstanceMethod1));
				return false;
			}
			if (IsInsideChainedConstructorCallArguments)
			{
				errorId = (implicitReference ? ERRID.ERR_InvalidImplicitMeReference : ERRID.ERR_InvalidMeReference);
				return false;
			}
			return true;
		}

		private bool CanAccessMyBase(bool implicitReference, out ERRID errorId)
		{
			errorId = ERRID.ERR_None;
			if (!CheckMeOrMyBaseOrMyClassInSharedOrDisallowedContext(implicitReference, out errorId))
			{
				return false;
			}
			if (TypeSymbolExtensions.IsStructureType(ContainingType))
			{
				errorId = ERRID.ERR_UseOfKeywordFromStructure1;
				return false;
			}
			return true;
		}

		private bool CanAccessMeOrMyClass(bool implicitReference, out ERRID errorId)
		{
			errorId = ERRID.ERR_None;
			return CheckMeOrMyBaseOrMyClassInSharedOrDisallowedContext(implicitReference, out errorId);
		}

		internal bool CanAccessMe(bool implicitReference, out ERRID errorId)
		{
			errorId = ERRID.ERR_None;
			return CanAccessMeOrMyClass(implicitReference, out errorId);
		}

		private bool CanAccessMyClass(bool implicitReference, out ERRID errorId)
		{
			errorId = ERRID.ERR_None;
			if ((object)ContainingType != null && TypeSymbolExtensions.IsModuleType(ContainingType))
			{
				errorId = ERRID.ERR_MyClassNotInClass;
				return false;
			}
			return CanAccessMeOrMyClass(implicitReference, out errorId);
		}

		private BoundMeReference BindMeExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.MeExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			ERRID errorId = ERRID.ERR_None;
			if (!CanAccessMe(implicitReference: false, out errorId))
			{
				ReportDiagnostic(diagnostics, node, errorId, SyntaxFacts.GetText(VisualBasicExtensions.Kind(node.Keyword)));
				return new BoundMeReference(node, ContainingType ?? ErrorTypeSymbol.UnknownResultType, hasErrors: true);
			}
			return CreateMeReference(node);
		}

		private BoundMeReference CreateMeReference(SyntaxNode node, bool isSynthetic = false)
		{
			_ = ContainingMember;
			BoundMeReference boundMeReference = new BoundMeReference(node, ContainingType ?? ErrorTypeSymbol.UnknownResultType);
			if (isSynthetic)
			{
				boundMeReference.SetWasCompilerGenerated();
			}
			return boundMeReference;
		}

		private BoundMyBaseReference BindMyBaseExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.MyBaseExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			ERRID errorId = ERRID.ERR_None;
			if (!CanAccessMyBase(implicitReference: false, out errorId))
			{
				ReportDiagnostic(diagnostics, node, errorId, SyntaxFacts.GetText(VisualBasicExtensions.Kind(node.Keyword)));
				return new BoundMyBaseReference(node, ((object)ContainingType != null) ? ContainingType.BaseTypeNoUseSiteDiagnostics : ErrorTypeSymbol.UnknownResultType, hasErrors: true);
			}
			_ = ContainingMember;
			return new BoundMyBaseReference(node, ((object)ContainingType != null) ? ContainingType.BaseTypeNoUseSiteDiagnostics : ErrorTypeSymbol.UnknownResultType);
		}

		private BoundMyClassReference BindMyClassExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.MyClassExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			ERRID errorId = ERRID.ERR_None;
			if (!CanAccessMyClass(implicitReference: false, out errorId))
			{
				ReportDiagnostic(diagnostics, node, errorId, SyntaxFacts.GetText(VisualBasicExtensions.Kind(node.Keyword)));
				return new BoundMyClassReference(node, ContainingType ?? ErrorTypeSymbol.UnknownResultType, hasErrors: true);
			}
			_ = ContainingMember;
			return new BoundMyClassReference(node, ContainingType ?? ErrorTypeSymbol.UnknownResultType);
		}

		private static bool CanBeImplicitVariableDeclaration(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax nameSyntax)
		{
			if (nameSyntax.Kind() != SyntaxKind.IdentifierName)
			{
				return false;
			}
			VisualBasicSyntaxNode parent = nameSyntax.Parent;
			if (parent != null)
			{
				switch (parent.Kind())
				{
				case SyntaxKind.SimpleMemberAccessExpression:
					if (((Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax)parent).Expression == nameSyntax)
					{
						return false;
					}
					break;
				case SyntaxKind.InvocationExpression:
					if (((Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax)parent).Expression == nameSyntax)
					{
						return false;
					}
					break;
				case SyntaxKind.ConditionalAccessExpression:
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax conditionalAccessExpressionSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax)parent;
					if (conditionalAccessExpressionSyntax.Expression == nameSyntax)
					{
						Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax leafAccess = SyntaxNodeExtensions.GetLeafAccess(conditionalAccessExpressionSyntax);
						if (leafAccess != null && (leafAccess.Kind() == SyntaxKind.SimpleMemberAccessExpression || leafAccess.Kind() == SyntaxKind.InvocationExpression))
						{
							return false;
						}
					}
					break;
				}
				case SyntaxKind.CatchStatement:
					if (((Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax)parent).IdentifierName == nameSyntax)
					{
						return false;
					}
					break;
				}
			}
			string left = SyntaxFacts.MakeHalfWidthIdentifier(nameSyntax.Identifier.ValueText);
			if (CaseInsensitiveComparison.Equals(left, "Null") || CaseInsensitiveComparison.Equals(left, "Empty") || CaseInsensitiveComparison.Equals(left, "RND"))
			{
				return false;
			}
			return true;
		}

		private BoundExpression BindSimpleName(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax node, bool isInvocationOrAddressOf, BindingDiagnosticBag diagnostics, bool skipLocalsAndParameters = false)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax typeArgumentListSyntax;
			string valueText;
			if (node.Kind() == SyntaxKind.GenericName)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax obj = (Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax)node;
				typeArgumentListSyntax = obj.TypeArgumentList;
				valueText = obj.Identifier.ValueText;
			}
			else
			{
				typeArgumentListSyntax = null;
				valueText = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)node).Identifier.ValueText;
			}
			if (string.IsNullOrEmpty(valueText))
			{
				return BadExpression(node, ErrorTypeSymbol.UnknownResultType);
			}
			LookupOptions lookupOptions = LookupOptions.AllMethodsOfAnyArity;
			if (isInvocationOrAddressOf)
			{
				lookupOptions |= LookupOptions.MustNotBeReturnValueVariable;
			}
			if (skipLocalsAndParameters)
			{
				lookupOptions |= LookupOptions.MustNotBeLocalOrParameter;
			}
			if (node.Kind() == SyntaxKind.IdentifierName && VisualBasicExtensions.IsBracketed(((Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)node).Identifier) && MemberLookup.GetTypeForIntrinsicAlias(valueText) != 0)
			{
				lookupOptions |= LookupOptions.AllowIntrinsicAliases;
			}
			int arity = typeArgumentListSyntax?.Arguments.Count ?? 0;
			LookupResult instance = LookupResult.GetInstance();
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
			Lookup(instance, valueText, arity, lookupOptions, ref useSiteInfo);
			((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)node, useSiteInfo);
			if (!instance.IsGoodOrAmbiguous && ImplicitVariableDeclarationAllowed && !AllImplicitVariableDeclarationsAreHandled && CanBeImplicitVariableDeclaration(node))
			{
				LocalSymbol from = DeclareImplicitLocalVariable((Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)node, diagnostics);
				instance.SetFrom(from);
			}
			if (!instance.HasSymbol)
			{
				instance.Free();
				string @namespace = null;
				bool fromImports = false;
				if (LookupXmlNamespace(valueText, ignoreXmlNodes: true, out @namespace, out fromImports))
				{
					return ReportDiagnosticAndProduceBadExpression(diagnostics, node, ERRID.ERR_XmlPrefixNotExpression, valueText);
				}
				DiagnosticInfo diagnosticInfo = null;
				if (node.Kind() == SyntaxKind.IdentifierName)
				{
					SyntaxKind syntaxKind = KeywordTable.TokenOfString(valueText);
					if (syntaxKind == SyntaxKind.AwaitKeyword)
					{
						diagnosticInfo = GetAwaitInNonAsyncError();
					}
				}
				if (diagnosticInfo == null)
				{
					diagnosticInfo = ((!CaseInsensitiveComparison.Equals("My", valueText) || !Compilation.Options.EmbedVbCoreRuntime) ? ErrorFactory.ErrorInfo(IsInQuery ? ERRID.ERR_QueryNameNotDeclared : ERRID.ERR_NameNotDeclared1, valueText) : ErrorFactory.ErrorInfo(ERRID.ERR_PlatformDoesntSupport, "My"));
				}
				return ReportDiagnosticAndProduceBadExpression(diagnostics, node, diagnosticInfo);
			}
			BoundExpression result = BindSimpleName(instance, node, lookupOptions, typeArgumentListSyntax, diagnostics);
			instance.Free();
			return result;
		}

		private BoundExpression BindSimpleName(LookupResult result, VisualBasicSyntaxNode node, LookupOptions options, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax typeArguments, BindingDiagnosticBag diagnostics)
		{
			BoundExpression boundExpression = null;
			NamedTypeSymbol containingType = ContainingType;
			if ((object)containingType != null)
			{
				if (containingType.IsScriptClass)
				{
					NamedTypeSymbol containingType2 = result.Symbols[0].ContainingType;
					if ((object)containingType2 != null)
					{
						boundExpression = TryBindInteractiveReceiver(node, ContainingMember, containingType, containingType2);
					}
				}
				if (boundExpression == null)
				{
					Symbol symbol = result.Symbols[0];
					if (SymbolExtensions.IsReducedExtensionMethod(symbol) || BindSimpleNameIsMemberOfType(symbol, containingType))
					{
						boundExpression = CreateMeReference(node, isSynthetic: true);
					}
				}
			}
			return BindSymbolAccess(node, result, options, boundExpression, typeArguments, QualificationKind.Unqualified, diagnostics);
		}

		private static bool BindSimpleNameIsMemberOfType(Symbol member, NamedTypeSymbol type)
		{
			SymbolKind kind = member.Kind;
			if ((uint)(kind - 5) <= 1u || kind == SymbolKind.Method || kind == SymbolKind.Property)
			{
				NamedTypeSymbol containingType = member.ContainingType;
				if ((object)containingType == null)
				{
					return false;
				}
				NamedTypeSymbol namedTypeSymbol = type;
				while ((object)namedTypeSymbol != null)
				{
					if (containingType.Equals(namedTypeSymbol))
					{
						return true;
					}
					namedTypeSymbol = namedTypeSymbol.BaseTypeNoUseSiteDiagnostics;
				}
			}
			return false;
		}

		private BoundExpression TryBindInteractiveReceiver(VisualBasicSyntaxNode syntax, Symbol currentMember, NamedTypeSymbol currentType, NamedTypeSymbol memberDeclaringType)
		{
			if (currentType.TypeKind == TypeKind.Submission && !currentMember.IsShared && memberDeclaringType.TypeKind == TypeKind.Submission)
			{
				return new BoundPreviousSubmissionReference(syntax, currentType, memberDeclaringType);
			}
			return null;
		}

		private BoundExpression BindMemberAccess(Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax node, bool eventContext, BindingDiagnosticBag diagnostics)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression = node.Expression;
			BoundExpression boundExpression = null;
			Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax name = node.Name;
			if (expression == null)
			{
				bool wholeMemberAccessExpressionBound = false;
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax correspondingConditionalAccessExpression = SyntaxNodeExtensions.GetCorrespondingConditionalAccessExpression(node);
				boundExpression = ((correspondingConditionalAccessExpression == null) ? TryBindOmittedLeftForMemberAccess(node, diagnostics, this, out wholeMemberAccessExpressionBound) : GetConditionalAccessReceiver(correspondingConditionalAccessExpression));
				if (boundExpression == null)
				{
					return ReportDiagnosticAndProduceBadExpression(diagnostics, node, ERRID.ERR_BadWithRef);
				}
				if (wholeMemberAccessExpressionBound)
				{
					return boundExpression;
				}
			}
			else
			{
				boundExpression = BindLeftOfPotentialColorColorMemberAccess(node, expression, diagnostics);
			}
			return BindMemberAccess(node, boundExpression, name, eventContext, diagnostics);
		}

		private BoundExpression BindLeftOfPotentialColorColorMemberAccess(Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax parentNode, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax leftOpt, BindingDiagnosticBag diagnostics)
		{
			if (leftOpt.Kind() == SyntaxKind.IdentifierName)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax simpleNameSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax)leftOpt;
				BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(diagnostics);
				BoundExpression boundExpression = BindSimpleName(simpleNameSyntax, isInvocationOrAddressOf: false, instance);
				BoundExpression boundExpression2 = boundExpression;
				BindingDiagnosticBag bindingDiagnosticBag = null;
				if (boundExpression.Kind == BoundKind.PropertyGroup)
				{
					bindingDiagnosticBag = BindingDiagnosticBag.GetInstance(diagnostics);
					boundExpression2 = AdjustReceiverValue(boundExpression, simpleNameSyntax, bindingDiagnosticBag);
				}
				Symbol expressionSymbol = boundExpression2.ExpressionSymbol;
				if ((object)expressionSymbol != null)
				{
					TypeSymbol typeSymbol;
					bool flag;
					switch (expressionSymbol.Kind)
					{
					case SymbolKind.Field:
					case SymbolKind.Property:
						typeSymbol = boundExpression2.Type;
						flag = !expressionSymbol.IsShared;
						break;
					case SymbolKind.Local:
					case SymbolKind.Parameter:
					case SymbolKind.RangeVariable:
						typeSymbol = boundExpression2.Type;
						flag = false;
						break;
					default:
						typeSymbol = null;
						flag = false;
						break;
					}
					if ((object)typeSymbol != null)
					{
						string valueText = simpleNameSyntax.Identifier.ValueText;
						if (CaseInsensitiveComparison.Equals(typeSymbol.Name, valueText) && typeSymbol.TypeKind != TypeKind.TypeParameter)
						{
							BindingDiagnosticBag bindingDiagnosticBag2 = BindingDiagnosticBag.Create(diagnostics);
							BoundExpression boundExpression3 = BindNamespaceOrTypeExpression(simpleNameSyntax, bindingDiagnosticBag2);
							if (TypeSymbol.Equals(boundExpression3.Type, typeSymbol, TypeCompareKind.ConsiderEverything))
							{
								ERRID errorId = ERRID.ERR_None;
								if (flag && (!CanAccessMe(implicitReference: true, out errorId) || !BindSimpleNameIsMemberOfType(expressionSymbol, ContainingType)))
								{
									diagnostics.AddRange(bindingDiagnosticBag2);
									instance.Free();
									return boundExpression3;
								}
								BindingDiagnosticBag bindingDiagnosticBag3 = BindingDiagnosticBag.Create(diagnostics);
								bindingDiagnosticBag3.AddRangeAndFree(instance);
								if (bindingDiagnosticBag != null)
								{
									bindingDiagnosticBag3.AddRangeAndFree(bindingDiagnosticBag);
								}
								return new BoundTypeOrValueExpression(leftOpt, new BoundTypeOrValueData(boundExpression2, bindingDiagnosticBag3, boundExpression3, bindingDiagnosticBag2), typeSymbol);
							}
						}
					}
				}
				bindingDiagnosticBag?.Free();
				diagnostics.AddRangeAndFree(instance);
				return boundExpression;
			}
			if (leftOpt.Kind() == SyntaxKind.SimpleMemberAccessExpression)
			{
				return BindMemberAccess((Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax)leftOpt, eventContext: false, diagnostics);
			}
			return BindExpression(leftOpt, diagnostics);
		}

		protected BoundExpression BindMemberAccess(VisualBasicSyntaxNode node, BoundExpression left, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax right, bool eventContext, BindingDiagnosticBag diagnostics)
		{
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
			TypeSymbol type = left.Type;
			if ((object)type != null && (right.Kind() == SyntaxKind.IdentifierName || right.Kind() == SyntaxKind.GenericName))
			{
				SyntaxToken token = ((right.Kind() == SyntaxKind.IdentifierName) ? ((Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)right).Identifier : ((Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax)right).Identifier);
				if (!VisualBasicExtensions.IsBracketed(token) && CaseInsensitiveComparison.Equals(token.ValueText, SyntaxFacts.GetText(SyntaxKind.NewKeyword)))
				{
					if (TypeSymbolExtensions.IsArrayType(type))
					{
						if (left.HasErrors)
						{
							return BadExpression(node, left, ErrorTypeSymbol.UnknownResultType);
						}
						return ReportDiagnosticAndProduceBadExpression(diagnostics, node, ErrorFactory.ErrorInfo(ERRID.ERR_ConstructorNotFound1, type), left);
					}
					TypeKind typeKind = type.TypeKind;
					if (typeKind == TypeKind.Class || typeKind == TypeKind.Struct || typeKind == TypeKind.Module)
					{
						NamedTypeSymbol namedTypeSymbol = (NamedTypeSymbol)type;
						ImmutableArray<MethodSymbol> accessibleConstructors = GetAccessibleConstructors(namedTypeSymbol, ref useSiteInfo);
						((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)node, useSiteInfo);
						useSiteInfo = new CompoundUseSiteInfo<AssemblySymbol>(useSiteInfo);
						if (accessibleConstructors.IsEmpty)
						{
							if (left.HasErrors)
							{
								return BadExpression(node, left, ErrorTypeSymbol.UnknownResultType);
							}
							return ReportDiagnosticAndProduceBadExpression(diagnostics, node, ErrorFactory.ErrorInfo(ERRID.ERR_ConstructorNotFound1, namedTypeSymbol), left);
						}
						bool flag = left.HasErrors;
						if (!flag && right.Kind() == SyntaxKind.GenericName)
						{
							ReportDiagnostic(diagnostics, node, ERRID.ERR_InvalidConstructorCall);
							flag = true;
						}
						return new BoundMethodGroup(node, null, accessibleConstructors, LookupResultKind.Good, left, (left.Kind != BoundKind.TypeExpression) ? QualificationKind.QualifiedViaValue : QualificationKind.QualifiedViaTypeName, flag);
					}
				}
			}
			Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax typeArgumentListSyntax;
			string valueText;
			if (right.Kind() == SyntaxKind.GenericName)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax obj = (Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax)right;
				typeArgumentListSyntax = obj.TypeArgumentList;
				valueText = obj.Identifier.ValueText;
			}
			else
			{
				typeArgumentListSyntax = null;
				valueText = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)right).Identifier.ValueText;
			}
			int arity = typeArgumentListSyntax?.Arguments.Count ?? 0;
			LookupResult instance = LookupResult.GetInstance();
			LookupOptions lookupOptions = LookupOptions.AllMethodsOfAnyArity;
			try
			{
				if (left.Kind == BoundKind.NamespaceExpression)
				{
					if (string.IsNullOrEmpty(valueText))
					{
						return BadExpression(node, left, ErrorTypeSymbol.UnknownResultType);
					}
					NamespaceSymbol namespaceSymbol = ((BoundNamespaceExpression)left).NamespaceSymbol;
					if (right.Kind() == SyntaxKind.IdentifierName && node.Kind() == SyntaxKind.SimpleMemberAccessExpression)
					{
						lookupOptions |= LookupOptions.AllowIntrinsicAliases;
					}
					MemberLookup.Lookup(instance, namespaceSymbol, valueText, arity, lookupOptions, this, ref useSiteInfo);
					if (instance.HasSymbol)
					{
						return BindSymbolAccess(node, instance, lookupOptions, left, typeArgumentListSyntax, QualificationKind.QualifiedViaNamespace, diagnostics);
					}
					return ReportDiagnosticAndProduceBadExpression(diagnostics, node, ErrorFactory.ErrorInfo(ERRID.ERR_NameNotMember2, valueText, namespaceSymbol), left);
				}
				TypeSymbol type2;
				if (left.Kind == BoundKind.TypeExpression)
				{
					type2 = ((BoundTypeExpression)left).Type;
					if (type2.TypeKind == TypeKind.TypeParameter)
					{
						return ReportDiagnosticAndProduceBadExpression(diagnostics, node, ErrorFactory.ErrorInfo(ERRID.ERR_TypeParamQualifierDisallowed), left);
					}
					if (string.IsNullOrEmpty(valueText))
					{
						return BadExpression(node, left, ErrorTypeSymbol.UnknownResultType);
					}
					LookupMember(instance, type2, valueText, arity, lookupOptions, ref useSiteInfo);
					if (instance.HasSymbol)
					{
						return BindSymbolAccess(node, instance, lookupOptions, left, typeArgumentListSyntax, QualificationKind.QualifiedViaTypeName, diagnostics);
					}
					return ReportDiagnosticAndProduceBadExpression(diagnostics, node, ErrorFactory.ErrorInfo(ERRID.ERR_NameNotMember2, valueText, type2), left);
				}
				left = AdjustReceiverValue(left, node, diagnostics);
				type2 = left.Type;
				if ((object)type2 == null || TypeSymbolExtensions.IsErrorType(type2))
				{
					return BadExpression(node, left, ErrorTypeSymbol.UnknownResultType);
				}
				if (string.IsNullOrEmpty(valueText))
				{
					return BadExpression(node, left, ErrorTypeSymbol.UnknownResultType);
				}
				LookupOptions lookupOptions2 = ((left.Kind != BoundKind.MyBaseReference) ? lookupOptions : (lookupOptions | LookupOptions.UseBaseReferenceAccessibility));
				if (eventContext)
				{
					lookupOptions2 |= LookupOptions.EventsOnly;
				}
				LookupMember(instance, type2, valueText, arity, lookupOptions2, ref useSiteInfo);
				if (instance.HasSymbol)
				{
					return BindSymbolAccess(node, instance, lookupOptions2, left, typeArgumentListSyntax, QualificationKind.QualifiedViaValue, diagnostics);
				}
				if ((TypeSymbolExtensions.IsObjectType(type2) && !BoundExpressionExtensions.IsMyBaseReference(left)) || TypeSymbolExtensions.IsExtensibleInterfaceNoUseSiteDiagnostics(type2))
				{
					return BindLateBoundMemberAccess(node, valueText, typeArgumentListSyntax, left, type2, diagnostics);
				}
				if (left.HasErrors)
				{
					return BadExpression(node, left, ErrorTypeSymbol.UnknownResultType);
				}
				if (TypeSymbolExtensions.IsInterfaceType(type2))
				{
					type2.AllInterfacesWithDefinitionUseSiteDiagnostics(ref useSiteInfo);
				}
				return ReportDiagnosticAndProduceBadExpression(diagnostics, node, ErrorFactory.ErrorInfo(ERRID.ERR_NameNotMember2, valueText, type2), left);
			}
			finally
			{
				((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)node, useSiteInfo);
				instance.Free();
			}
		}

		protected internal virtual BoundExpression TryBindOmittedLeftForMemberAccess(Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax node, BindingDiagnosticBag diagnostics, Binder accessingBinder, out bool wholeMemberAccessExpressionBound)
		{
			return ContainingBinder.TryBindOmittedLeftForMemberAccess(node, diagnostics, accessingBinder, out wholeMemberAccessExpressionBound);
		}

		protected internal virtual BoundExpression TryBindOmittedLeftForXmlMemberAccess(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax node, BindingDiagnosticBag diagnostics, Binder accessingBinder)
		{
			return ContainingBinder.TryBindOmittedLeftForXmlMemberAccess(node, diagnostics, accessingBinder);
		}

		private bool IsBindingImplicitlyTypedLocal(LocalSymbol symbol)
		{
			foreach (LocalSymbol item in ImplicitlyTypedLocalsBeingBound)
			{
				if (item == symbol)
				{
					return true;
				}
			}
			return false;
		}

		private TypeSymbol GetLocalSymbolType(LocalSymbol localSymbol, VisualBasicSyntaxNode node, BindingDiagnosticBag diagnostics = null)
		{
			TypeSymbol typeSymbol = null;
			if (node != null && node.SpanStart < localSymbol.IdentifierToken.SpanStart)
			{
				Location identifierLocation = localSymbol.IdentifierLocation;
				Location location = node.GetLocation();
				if (!localSymbol.IsImplicitlyDeclared && identifierLocation.IsInSource && (object)location != null && location.IsInSource && identifierLocation.SourceTree == location.SourceTree)
				{
					typeSymbol = LocalSymbol.UseBeforeDeclarationResultType;
					if (diagnostics != null)
					{
						ReportDiagnostic(diagnostics, node, ERRID.ERR_UseOfLocalBeforeDeclaration1, localSymbol);
					}
				}
			}
			else if (IsBindingImplicitlyTypedLocal(localSymbol))
			{
				if (localSymbol.IsConst && localSymbol.ConstHasType)
				{
					return localSymbol.Type;
				}
				if (diagnostics != null)
				{
					if (localSymbol.IsConst)
					{
						ReportDiagnostic(diagnostics, node, ERRID.ERR_CircularEvaluation1, localSymbol);
					}
					else
					{
						ReportDiagnostic(diagnostics, node, ERRID.ERR_CircularInference1, localSymbol);
					}
				}
				typeSymbol = ErrorTypeSymbol.UnknownResultType;
			}
			if ((object)typeSymbol == null)
			{
				typeSymbol = localSymbol.Type;
			}
			return typeSymbol;
		}

		private BoundExpression BindSymbolAccess(VisualBasicSyntaxNode node, LookupResult lookupResult, LookupOptions lookupOptionsUsed, BoundExpression receiver, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax typeArgumentsOpt, QualificationKind qualKind, BindingDiagnosticBag diagnostics)
		{
			bool flag = false;
			if (receiver != null)
			{
				flag = receiver.HasErrors;
				receiver = AdjustReceiverNamespace(lookupResult, receiver);
			}
			bool flag2 = false;
			LookupResultKind kind = lookupResult.Kind;
			if (lookupResult.HasDiagnostic && ((lookupResult.Symbols[0].Kind != SymbolKind.Method && lookupResult.Symbols[0].Kind != SymbolKind.Property) || kind != LookupResultKind.Inaccessible))
			{
				DiagnosticInfo diagnostic = lookupResult.Diagnostic;
				if (!flag)
				{
					if (typeArgumentsOpt != null && (lookupResult.Kind == LookupResultKind.WrongArity || lookupResult.Kind == LookupResultKind.WrongArityAndStopLookup))
					{
						ReportDiagnostic(diagnostics, typeArgumentsOpt, diagnostic);
					}
					else
					{
						ReportDiagnostic(diagnostics, node, diagnostic);
					}
					if (diagnostic.Severity == DiagnosticSeverity.Error)
					{
						flag = true;
						flag2 = true;
					}
				}
				ImmutableArray<Symbol> symbols = ((!(diagnostic is AmbiguousSymbolDiagnostic)) ? lookupResult.Symbols.ToImmutable() : ((AmbiguousSymbolDiagnostic)diagnostic).AmbiguousSymbols);
				return new BoundBadExpression(node, lookupResult.Kind, symbols, (receiver != null) ? ImmutableArray.Create(receiver) : ImmutableArray<BoundExpression>.Empty, GetCommonExpressionTypeForErrorRecovery(node, symbols, ConstantFieldsInProgress), hasErrors: true);
			}
			switch (lookupResult.Symbols[0].Kind)
			{
			case SymbolKind.Method:
				return CreateBoundMethodGroup(node, lookupResult, lookupOptionsUsed, diagnostics.AccumulatesDependencies, receiver, BindTypeArguments(typeArgumentsOpt, diagnostics), qualKind, flag);
			case SymbolKind.Property:
				return new BoundPropertyGroup(node, lookupResult.Symbols.ToDowncastedImmutable<PropertySymbol>(), lookupResult.Kind, receiver, qualKind, flag);
			case SymbolKind.Event:
			{
				EventSymbol eventSymbol = (EventSymbol)lookupResult.SingleSymbol;
				if (eventSymbol.IsShared && qualKind == QualificationKind.Unqualified)
				{
					receiver = null;
				}
				if (!flag2)
				{
					ReportUseSite(diagnostics, node, eventSymbol);
				}
				if (!flag)
				{
					if (receiver != null && receiver.Kind == BoundKind.TypeOrValueExpression)
					{
						receiver = AdjustReceiverTypeOrValue(receiver, node, eventSymbol.IsShared, diagnostics, ref qualKind);
					}
					flag = CheckSharedSymbolAccess(node, eventSymbol.IsShared, ref receiver, qualKind, diagnostics);
				}
				ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagnostics, eventSymbol, node);
				if (receiver != null && BoundExpressionExtensions.IsPropertyOrXmlPropertyAccess(receiver))
				{
					receiver = MakeRValue(receiver, diagnostics);
				}
				return new BoundEventAccess(node, receiver, eventSymbol, eventSymbol.Type, flag);
			}
			case SymbolKind.Field:
			{
				FieldSymbol fieldSymbol = (FieldSymbol)lookupResult.SingleSymbol;
				if (fieldSymbol.IsShared && qualKind == QualificationKind.Unqualified)
				{
					receiver = null;
				}
				if (!flag)
				{
					if (receiver != null && receiver.Kind == BoundKind.TypeOrValueExpression)
					{
						receiver = AdjustReceiverTypeOrValue(receiver, node, fieldSymbol.IsShared, diagnostics, ref qualKind);
					}
					flag = CheckSharedSymbolAccess(node, fieldSymbol.IsShared, ref receiver, qualKind, diagnostics);
				}
				if (!flag2 && !ReportUseSite(diagnostics, node, fieldSymbol))
				{
					CheckMemberTypeAccessibility(diagnostics, node, fieldSymbol);
				}
				ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagnostics, fieldSymbol, node);
				TypeSymbol inferredType = fieldSymbol.GetInferredType(ConstantFieldsInProgress);
				if (node is Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax memberAccessExpressionSyntax && !TypeSymbolExtensions.IsErrorType(inferredType))
				{
					VerifyTypeCharacterConsistency(memberAccessExpressionSyntax.Name, TypeSymbolExtensions.GetEnumUnderlyingTypeOrSelf(inferredType), diagnostics);
				}
				if (receiver != null && BoundExpressionExtensions.IsPropertyOrXmlPropertyAccess(receiver))
				{
					receiver = MakeRValue(receiver, diagnostics);
				}
				return new BoundFieldAccess(node, receiver, fieldSymbol, IsLValueFieldAccess(fieldSymbol, receiver), suppressVirtualCalls: false, ConstantFieldsInProgress, inferredType, flag || TypeSymbolExtensions.IsErrorType(inferredType));
			}
			case SymbolKind.Local:
			{
				LocalSymbol localSymbol = (LocalSymbol)lookupResult.SingleSymbol;
				if (localSymbol.IsFunctionValue && !IsNameOfArgument(node))
				{
					MethodSymbol methodSymbol = (MethodSymbol)localSymbol.ContainingSymbol;
					if (methodSymbol.IsAsync || methodSymbol.IsIterator)
					{
						ReportDiagnostic(diagnostics, node, ERRID.ERR_BadResumableAccessReturnVariable);
						return BadExpression(node, ErrorTypeSymbol.UnknownResultType);
					}
				}
				TypeSymbol localSymbolType = GetLocalSymbolType(localSymbol, node, diagnostics);
				if (node is Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax name3 && !TypeSymbolExtensions.IsErrorType(localSymbolType))
				{
					VerifyTypeCharacterConsistency(name3, TypeSymbolExtensions.GetEnumUnderlyingTypeOrSelf(localSymbolType), diagnostics);
				}
				if (localSymbol.IsFor)
				{
					Symbol containingSymbol = localSymbol.ContainingSymbol;
					if ((object)ContainingMember != containingSymbol)
					{
						if (IsTopMostEnclosingLambdaAQueryLambda(ContainingMember, containingSymbol))
						{
							ReportDiagnostic(diagnostics, node, ERRID.WRN_LiftControlVariableQuery, localSymbol.Name);
						}
						else
						{
							ReportDiagnostic(diagnostics, node, ERRID.WRN_LiftControlVariableLambda, localSymbol.Name);
						}
					}
				}
				return new BoundLocal(node, localSymbol, localSymbolType, flag);
			}
			case SymbolKind.RangeVariable:
			{
				RangeVariableSymbol rangeVariableSymbol = (RangeVariableSymbol)lookupResult.SingleSymbol;
				return new BoundRangeVariable(node, rangeVariableSymbol, rangeVariableSymbol.Type, flag);
			}
			case SymbolKind.Parameter:
			{
				ParameterSymbol parameterSymbol = (ParameterSymbol)lookupResult.SingleSymbol;
				TypeSymbol type2 = parameterSymbol.Type;
				if (node is Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax name2 && !TypeSymbolExtensions.IsErrorType(type2))
				{
					VerifyTypeCharacterConsistency(name2, TypeSymbolExtensions.GetEnumUnderlyingTypeOrSelf(type2), diagnostics);
				}
				return new BoundParameter(node, parameterSymbol, type2, flag);
			}
			case SymbolKind.ErrorType:
			case SymbolKind.NamedType:
			{
				BoundTypeArguments boundTypeArguments = null;
				if (typeArgumentsOpt != null)
				{
					boundTypeArguments = BindTypeArguments(typeArgumentsOpt, diagnostics);
				}
				NamedTypeSymbol namedTypeSymbol = lookupResult.SingleSymbol as NamedTypeSymbol;
				if ((object)namedTypeSymbol != null && boundTypeArguments != null)
				{
					NamedTypeSymbol newSym = ConstructAndValidateConstraints(namedTypeSymbol, boundTypeArguments.Arguments, node, typeArgumentsOpt.Arguments, diagnostics);
					lookupResult.ReplaceSymbol(newSym);
				}
				ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagnostics, namedTypeSymbol, node);
				if (!flag)
				{
					receiver = AdjustReceiverTypeOrValue(receiver, node, isShared: true, diagnostics, ref qualKind);
					flag = CheckSharedSymbolAccess(node, isShared: true, ref receiver, qualKind, diagnostics);
				}
				if (!flag2)
				{
					ReportUseSite(diagnostics, node, namedTypeSymbol ?? lookupResult.SingleSymbol);
				}
				TypeSymbol type = (TypeSymbol)lookupResult.SingleSymbol;
				if (node is Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax name && !TypeSymbolExtensions.IsErrorType(type))
				{
					VerifyTypeCharacterConsistency(name, TypeSymbolExtensions.GetEnumUnderlyingTypeOrSelf(type), diagnostics);
				}
				return new BoundTypeExpression(node, receiver, null, type, flag);
			}
			case SymbolKind.TypeParameter:
				return new BoundTypeExpression(node, (TypeSymbol)lookupResult.SingleSymbol, flag);
			case SymbolKind.Namespace:
				return new BoundNamespaceExpression(node, receiver, (NamespaceSymbol)lookupResult.SingleSymbol, flag);
			case SymbolKind.Alias:
			{
				AliasSymbol aliasSymbol = (AliasSymbol)lookupResult.SingleSymbol;
				NamespaceOrTypeSymbol target = aliasSymbol.Target;
				switch (target.Kind)
				{
				case SymbolKind.ErrorType:
				case SymbolKind.NamedType:
					if (!flag2)
					{
						ReportUseSite(diagnostics, node, target);
					}
					return new BoundTypeExpression(node, null, aliasSymbol, (TypeSymbol)target, flag);
				case SymbolKind.Namespace:
					return new BoundNamespaceExpression(node, null, aliasSymbol, (NamespaceSymbol)target, flag);
				default:
					throw ExceptionUtilities.UnexpectedValue(target.Kind);
				}
			}
			default:
				throw ExceptionUtilities.UnexpectedValue(lookupResult.Symbols[0].Kind);
			}
		}

		private BoundExpression AdjustReceiverNamespace(LookupResult lookupResult, BoundExpression receiver)
		{
			if (receiver.Kind == BoundKind.NamespaceExpression)
			{
				BoundNamespaceExpression boundNamespaceExpression = (BoundNamespaceExpression)receiver;
				if (boundNamespaceExpression.NamespaceSymbol.NamespaceKind == (NamespaceKind)0)
				{
					ArrayBuilder<Symbol> arrayBuilder = lookupResult.Symbols;
					if (lookupResult.HasDiagnostic)
					{
						DiagnosticInfo diagnostic = lookupResult.Diagnostic;
						if (diagnostic is AmbiguousSymbolDiagnostic)
						{
							ImmutableArray<Symbol> ambiguousSymbols = ((AmbiguousSymbolDiagnostic)diagnostic).AmbiguousSymbols;
							arrayBuilder = ArrayBuilder<Symbol>.GetInstance();
							arrayBuilder.AddRange(ambiguousSymbols);
						}
					}
					receiver = AdjustReceiverNamespace(boundNamespaceExpression, arrayBuilder);
					if (arrayBuilder != lookupResult.Symbols)
					{
						arrayBuilder.Free();
					}
				}
			}
			return receiver;
		}

		private BoundNamespaceExpression AdjustReceiverNamespace(BoundNamespaceExpression namespaceReceiver, ArrayBuilder<Symbol> symbols)
		{
			if (symbols.Count > 0)
			{
				SmallDictionary<NamespaceSymbol, bool> smallDictionary = new SmallDictionary<NamespaceSymbol, bool>();
				ArrayBuilder<Symbol>.Enumerator enumerator = symbols.GetEnumerator();
				while (enumerator.MoveNext())
				{
					Symbol current = enumerator.Current;
					if (!AddReceiverNamespaces(smallDictionary, current, Compilation))
					{
						smallDictionary = null;
						break;
					}
				}
				if (smallDictionary != null && smallDictionary.Count() < namespaceReceiver.NamespaceSymbol.ConstituentNamespaces.Length)
				{
					return AdjustReceiverNamespace(namespaceReceiver, ((MergedNamespaceSymbol)namespaceReceiver.NamespaceSymbol).Shrink(smallDictionary.Keys));
				}
			}
			return namespaceReceiver;
		}

		internal static bool AddReceiverNamespaces(SmallDictionary<NamespaceSymbol, bool> namespaces, Symbol candidate, VisualBasicCompilation compilation)
		{
			if (candidate.Kind == SymbolKind.Namespace && ((NamespaceSymbol)candidate).NamespaceKind == (NamespaceKind)0)
			{
				ImmutableArray<NamespaceSymbol>.Enumerator enumerator = ((NamespaceSymbol)candidate).ConstituentNamespaces.GetEnumerator();
				while (enumerator.MoveNext())
				{
					NamespaceSymbol current = enumerator.Current;
					if (!AddContainingNamespaces(namespaces, current, compilation))
					{
						return false;
					}
				}
				return true;
			}
			return AddContainingNamespaces(namespaces, candidate, compilation);
		}

		private static bool AddContainingNamespaces(SmallDictionary<NamespaceSymbol, bool> namespaces, Symbol candidate, VisualBasicCompilation compilation)
		{
			if ((object)candidate == null || candidate.Kind == SymbolKind.ErrorType)
			{
				return false;
			}
			NamespaceSymbol containingNamespace = candidate.ContainingNamespace;
			if ((object)containingNamespace != null)
			{
				namespaces[compilation.GetCompilationNamespace(containingNamespace)] = false;
				return true;
			}
			return false;
		}

		private BoundNamespaceExpression AdjustReceiverNamespace(BoundNamespaceExpression namespaceReceiver, NamespaceSymbol adjustedNamespace)
		{
			if ((object)adjustedNamespace != namespaceReceiver.NamespaceSymbol)
			{
				BoundExpression boundExpression = namespaceReceiver.UnevaluatedReceiverOpt;
				if (boundExpression != null && boundExpression.Kind == BoundKind.NamespaceExpression)
				{
					BoundNamespaceExpression boundNamespaceExpression = (BoundNamespaceExpression)boundExpression;
					if (boundNamespaceExpression.NamespaceSymbol.NamespaceKind == (NamespaceKind)0 && IsNamespaceGroupIncludesButNotEquivalentTo(boundNamespaceExpression.NamespaceSymbol, adjustedNamespace.ContainingNamespace))
					{
						boundExpression = AdjustReceiverNamespace(boundNamespaceExpression, adjustedNamespace.ContainingNamespace);
					}
				}
				return namespaceReceiver.Update(boundExpression, namespaceReceiver.AliasOpt, adjustedNamespace);
			}
			return namespaceReceiver;
		}

		private static bool IsNamespaceGroupIncludesButNotEquivalentTo(NamespaceSymbol namespaceGroup, NamespaceSymbol other)
		{
			bool result;
			if (other.NamespaceKind != 0)
			{
				result = namespaceGroup.ConstituentNamespaces.Contains(other);
			}
			else
			{
				ImmutableArray<NamespaceSymbol> constituentNamespaces = namespaceGroup.ConstituentNamespaces;
				ImmutableArray<NamespaceSymbol> constituentNamespaces2 = other.ConstituentNamespaces;
				if (constituentNamespaces.Length > constituentNamespaces2.Length)
				{
					result = true;
					SmallDictionary<NamespaceSymbol, bool> smallDictionary = new SmallDictionary<NamespaceSymbol, bool>();
					ImmutableArray<NamespaceSymbol>.Enumerator enumerator = constituentNamespaces.GetEnumerator();
					while (enumerator.MoveNext())
					{
						NamespaceSymbol current = enumerator.Current;
						smallDictionary[current] = false;
					}
					ImmutableArray<NamespaceSymbol>.Enumerator enumerator2 = constituentNamespaces2.GetEnumerator();
					while (enumerator2.MoveNext())
					{
						NamespaceSymbol current2 = enumerator2.Current;
						bool value = false;
						if (!smallDictionary.TryGetValue(current2, out value))
						{
							result = false;
							break;
						}
					}
				}
				else
				{
					result = false;
				}
			}
			return result;
		}

		private void CheckMemberTypeAccessibility(BindingDiagnosticBag diagnostics, SyntaxNode node, Symbol member)
		{
			TypeSymbol sym;
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo;
			switch (member.Kind)
			{
			case SymbolKind.Method:
				sym = ((MethodSymbol)member).ReturnType;
				goto IL_005c;
			case SymbolKind.Property:
				sym = ((PropertySymbol)member).Type;
				goto IL_005c;
			case SymbolKind.Field:
			{
				FieldSymbol fieldSymbol = (FieldSymbol)member;
				if (fieldSymbol.HasDeclaredType)
				{
					sym = fieldSymbol.Type;
					goto IL_005c;
				}
				break;
			}
			default:
				{
					throw ExceptionUtilities.UnexpectedValue(member.Kind);
				}
				IL_005c:
				useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
				if (CheckAccessibility(sym, ref useSiteInfo) != 0)
				{
					ReportDiagnostic(diagnostics, node, new BadSymbolDiagnostic(member, ERRID.ERR_InaccessibleReturnTypeOfMember2, CustomSymbolDisplayFormatter.WithContainingType(member)));
				}
				((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(node, useSiteInfo);
				break;
			}
		}

		public static bool IsTopMostEnclosingLambdaAQueryLambda(Symbol containingMember, Symbol stopAtContainer)
		{
			bool result = false;
			Symbol symbol = containingMember;
			while ((object)symbol != null && (object)symbol != stopAtContainer && symbol.IsLambdaMethod)
			{
				result = symbol.IsQueryLambdaMethod;
				symbol = symbol.ContainingSymbol;
			}
			return result;
		}

		public BoundExpression BindLabel(Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax node, BindingDiagnosticBag diagnostics)
		{
			string valueText = node.LabelToken.ValueText;
			LookupResult instance = LookupResult.GetInstance();
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
			Lookup(instance, valueText, 0, LookupOptions.LabelsOnly, ref useSiteInfo);
			LabelSymbol labelSymbol = null;
			bool hasErrors = false;
			if (instance.IsGood && instance.HasSingleSymbol)
			{
				labelSymbol = (LabelSymbol)instance.Symbols.First();
			}
			else
			{
				if (instance.HasDiagnostic)
				{
					ReportDiagnostic(diagnostics, node, instance.Diagnostic);
				}
				else
				{
					ReportDiagnostic(diagnostics, node, ERRID.ERR_LabelNotDefined1, valueText);
				}
				hasErrors = true;
			}
			instance.Free();
			if ((object)labelSymbol == null)
			{
				return new BoundBadExpression(node, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, ImmutableArray<BoundExpression>.Empty, null, hasErrors: true);
			}
			return new BoundLabel(node, labelSymbol, null, hasErrors);
		}

		private BoundTypeArguments BindTypeArguments(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax typeArgumentsOpt, BindingDiagnosticBag diagnostics)
		{
			if (typeArgumentsOpt == null)
			{
				return null;
			}
			SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax> arguments = typeArgumentsOpt.Arguments;
			TypeSymbol[] array = new TypeSymbol[arguments.Count - 1 + 1];
			int num = arguments.Count - 1;
			for (int i = 0; i <= num; i++)
			{
				array[i] = BindTypeSyntax(arguments[i], diagnostics);
			}
			return new BoundTypeArguments(typeArgumentsOpt, array.AsImmutableOrNull());
		}

		private bool CheckSharedSymbolAccess(SyntaxNode node, bool isShared, [In][Out] ref BoundExpression receiver, QualificationKind qualKind, BindingDiagnosticBag diagnostics)
		{
			if (isShared)
			{
				if (qualKind == QualificationKind.QualifiedViaValue && receiver != null && receiver.Kind != BoundKind.TypeOrValueExpression && receiver.Kind != BoundKind.MyBaseReference && !receiver.HasErrors && (node.Parent == null || VisualBasicExtensions.Kind(node.Parent) != SyntaxKind.NamedFieldInitializer))
				{
					ReportDiagnostic(diagnostics, node, ERRID.WRN_SharedMemberThroughInstance);
				}
			}
			else
			{
				if (qualKind == QualificationKind.QualifiedViaTypeName || (qualKind == QualificationKind.Unqualified && receiver == null))
				{
					if (qualKind == QualificationKind.QualifiedViaTypeName && receiver != null && receiver.Kind == BoundKind.TypeExpression)
					{
						BoundExpression boundExpression = TryDefaultInstanceProperty((BoundTypeExpression)receiver, diagnostics);
						if (boundExpression != null)
						{
							receiver = boundExpression;
							return false;
						}
					}
					if (receiver != null && receiver.Kind == BoundKind.TypeExpression && IsReceiverOfNameOfArgument(receiver.Syntax))
					{
						receiver = BoundNodeExtensions.MakeCompilerGenerated(new BoundTypeAsValueExpression(receiver.Syntax, (BoundTypeExpression)receiver, receiver.Type));
						return false;
					}
					ReportDiagnostic(diagnostics, node, ERRID.ERR_ObjectReferenceNotSupplied);
					return true;
				}
				ERRID errorId = ERRID.ERR_None;
				if (qualKind == QualificationKind.Unqualified && !IsNameOfArgument(node) && !CanAccessMe(implicitReference: true, out errorId))
				{
					ReportDiagnostic(diagnostics, node, errorId);
					return true;
				}
			}
			return false;
		}

		private static bool IsReceiverOfNameOfArgument(SyntaxNode syntax)
		{
			SyntaxNode parent = syntax.Parent;
			if (parent != null && VisualBasicExtensions.Kind(parent) == SyntaxKind.SimpleMemberAccessExpression && ((Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax)parent).Expression == syntax)
			{
				return IsNameOfArgument(parent);
			}
			return false;
		}

		private static bool IsNameOfArgument(SyntaxNode syntax)
		{
			if (syntax.Parent != null && VisualBasicExtensions.Kind(syntax.Parent) == SyntaxKind.NameOfExpression)
			{
				return ((Microsoft.CodeAnalysis.VisualBasic.Syntax.NameOfExpressionSyntax)syntax.Parent).Argument == syntax;
			}
			return false;
		}

		protected virtual BoundExpression TryBindOmittedLeftForDictionaryAccess(Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax node, Binder accessingBinder, BindingDiagnosticBag diagnostics)
		{
			return ContainingBinder.TryBindOmittedLeftForDictionaryAccess(node, accessingBinder, diagnostics);
		}

		private BoundExpression BindDictionaryAccess(Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression = node.Expression;
			BoundExpression boundExpression;
			if (expression == null)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax correspondingConditionalAccessExpression = SyntaxNodeExtensions.GetCorrespondingConditionalAccessExpression(node);
				boundExpression = ((correspondingConditionalAccessExpression == null) ? TryBindOmittedLeftForDictionaryAccess(node, this, diagnostics) : GetConditionalAccessReceiver(correspondingConditionalAccessExpression));
				if (boundExpression == null)
				{
					return BadExpression(node, ImmutableArray.Create(ReportDiagnosticAndProduceBadExpression(diagnostics, node, ERRID.ERR_BadWithRef), new BoundLiteral(node.Name, ConstantValue.Create(node.Name.Identifier.ValueText), GetSpecialType(SpecialType.System_String, node.Name, diagnostics))), ErrorTypeSymbol.UnknownResultType);
				}
			}
			else
			{
				boundExpression = BindExpression(expression, diagnostics);
			}
			if (!boundExpression.IsLValue && boundExpression.Kind != BoundKind.LateMemberAccess)
			{
				boundExpression = MakeRValue(boundExpression, diagnostics);
			}
			TypeSymbol type = boundExpression.Type;
			if (!TypeSymbolExtensions.IsErrorType(type))
			{
				if (type.SpecialType == SpecialType.System_Object || TypeSymbolExtensions.IsExtensibleInterfaceNoUseSiteDiagnostics(type))
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax name = node.Name;
					ImmutableArray<BoundExpression> arguments = ImmutableArray.Create((BoundExpression)new BoundLiteral(name, ConstantValue.Create(node.Name.Identifier.ValueText), GetSpecialType(SpecialType.System_String, name, diagnostics)));
					return BindLateBoundInvocation(node, null, boundExpression, arguments, default(ImmutableArray<string>), diagnostics);
				}
				if (TypeSymbolExtensions.IsInterfaceType(type))
				{
					CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
					type.AllInterfacesWithDefinitionUseSiteDiagnostics(ref useSiteInfo);
					((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)node, useSiteInfo);
				}
				BoundExpression boundExpression2 = BindDefaultPropertyGroup(node, boundExpression, diagnostics);
				if (boundExpression2 != null && boundExpression2.Kind == BoundKind.PropertyGroup)
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax name2 = node.Name;
					BoundLiteral item = new BoundLiteral(name2, ConstantValue.Create(node.Name.Identifier.ValueText), GetSpecialType(SpecialType.System_String, name2, diagnostics));
					return BindInvocationExpression(node, boundExpression.Syntax, TypeCharacter.None, (BoundPropertyGroup)boundExpression2, ImmutableArray.Create((BoundExpression)item), default(ImmutableArray<string>), diagnostics, node, allowConstructorCall: false, suppressAbstractCallDiagnostics: false, isDefaultMemberAccess: true);
				}
				if (boundExpression2 == null || !boundExpression2.HasErrors)
				{
					switch (type.TypeKind)
					{
					case TypeKind.Array:
					case TypeKind.Enum:
						ReportQualNotObjectRecord(boundExpression, diagnostics);
						break;
					case TypeKind.Class:
						if (type.SpecialType == SpecialType.System_Array)
						{
							ReportDefaultMemberNotProperty(boundExpression, diagnostics);
						}
						else
						{
							ReportNoDefaultProperty(boundExpression, diagnostics);
						}
						break;
					case TypeKind.Interface:
					case TypeKind.TypeParameter:
						ReportNoDefaultProperty(boundExpression, diagnostics);
						break;
					case TypeKind.Struct:
						if (TypeSymbolExtensions.IsIntrinsicValueType(type))
						{
							ReportQualNotObjectRecord(boundExpression, diagnostics);
						}
						else
						{
							ReportNoDefaultProperty(boundExpression, diagnostics);
						}
						break;
					default:
						ReportDefaultMemberNotProperty(boundExpression, diagnostics);
						break;
					}
				}
			}
			return BadExpression(node, ImmutableArray.Create(boundExpression, new BoundLiteral(node.Name, ConstantValue.Create(node.Name.Identifier.ValueText), GetSpecialType(SpecialType.System_String, node.Name, diagnostics))), ErrorTypeSymbol.UnknownResultType);
		}

		private static void ReportNoDefaultProperty(BoundExpression expr, BindingDiagnosticBag diagnostics)
		{
			TypeSymbol type = expr.Type;
			SyntaxNode syntax = expr.Syntax;
			switch (type.TypeKind)
			{
			case TypeKind.Class:
				ReportDiagnostic(diagnostics, syntax, ERRID.ERR_NoDefaultNotExtend1, type);
				break;
			case TypeKind.Struct:
				ReportDiagnostic(diagnostics, syntax, ERRID.ERR_StructureNoDefault1, type);
				break;
			default:
				ReportDiagnostic(diagnostics, syntax, ERRID.ERR_InterfaceNoDefault1, type);
				break;
			case TypeKind.Error:
				break;
			}
		}

		private static void ReportQualNotObjectRecord(BoundExpression expr, BindingDiagnosticBag diagnostics)
		{
			ReportDiagnostic(diagnostics, expr.Syntax, ERRID.ERR_QualNotObjectRecord1, expr.Type);
		}

		private static void ReportDefaultMemberNotProperty(BoundExpression expr, BindingDiagnosticBag diagnostics)
		{
			ReportDiagnostic(diagnostics, expr.Syntax, ERRID.ERR_DefaultMemberNotProperty1, expr.Type);
		}

		private static BoundExpression GenerateBadExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax node, BoundExpression target, ImmutableArray<BoundExpression> boundArguments)
		{
			ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
			instance.Add(target);
			instance.AddRange(boundArguments);
			return BadExpression(node, instance.ToImmutableAndFree(), ErrorTypeSymbol.UnknownResultType);
		}

		private static void VerifyTypeCharacterConsistency(SyntaxNodeOrToken nodeOrToken, TypeSymbol type, TypeCharacter typeChar, BindingDiagnosticBag diagnostics)
		{
			string typeCharacterString = null;
			SpecialType specialTypeForTypeCharacter = GetSpecialTypeForTypeCharacter(typeChar, ref typeCharacterString);
			if (specialTypeForTypeCharacter != 0)
			{
				if (TypeSymbolExtensions.IsArrayType(type))
				{
					type = ((ArrayTypeSymbol)type).ElementType;
				}
				type = TypeSymbolExtensions.GetNullableUnderlyingTypeOrSelf(type);
				if (type.SpecialType != specialTypeForTypeCharacter)
				{
					ReportDiagnostic(diagnostics, nodeOrToken, ERRID.ERR_TypecharNoMatch2, typeCharacterString, type);
				}
			}
		}

		private static void VerifyTypeCharacterConsistency(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax name, TypeSymbol type, BindingDiagnosticBag diagnostics)
		{
			TypeCharacter typeCharacter = VisualBasicExtensions.GetTypeCharacter(name.Identifier);
			if (typeCharacter == TypeCharacter.None)
			{
				return;
			}
			string typeCharacterString = null;
			SpecialType specialTypeForTypeCharacter = GetSpecialTypeForTypeCharacter(typeCharacter, ref typeCharacterString);
			if (specialTypeForTypeCharacter != 0)
			{
				if (TypeSymbolExtensions.IsArrayType(type))
				{
					type = ((ArrayTypeSymbol)type).ElementType;
				}
				type = TypeSymbolExtensions.GetNullableUnderlyingTypeOrSelf(type);
				if (type.SpecialType != specialTypeForTypeCharacter)
				{
					ReportDiagnostic(diagnostics, name, ERRID.ERR_TypecharNoMatch2, typeCharacterString, type);
				}
			}
		}

		private BoundExpression BindArrayAccess(Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax node, BoundExpression expr, ImmutableArray<BoundExpression> boundArguments, ImmutableArray<string> argumentNames, BindingDiagnosticBag diagnostics)
		{
			if (expr.IsLValue)
			{
				expr = expr.MakeRValue();
			}
			ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance(boundArguments.Length);
			NamedTypeSymbol specialType = GetSpecialType(SpecialType.System_Int32, node.ArgumentList, diagnostics);
			ImmutableArray<BoundExpression>.Enumerator enumerator = boundArguments.GetEnumerator();
			while (enumerator.MoveNext())
			{
				BoundExpression current = enumerator.Current;
				instance.Add(ApplyImplicitConversion(current.Syntax, specialType, current, diagnostics));
			}
			boundArguments = instance.ToImmutableAndFree();
			if ((object)expr.Type == null)
			{
				return new BoundArrayAccess(node, expr, boundArguments, null, hasErrors: true);
			}
			if (!argumentNames.IsDefault && argumentNames.Length > 0)
			{
				ReportDiagnostic(diagnostics, node, ERRID.ERR_NamedSubscript);
			}
			ArrayTypeSymbol arrayTypeSymbol = (ArrayTypeSymbol)expr.Type;
			_ = arrayTypeSymbol.Rank;
			if (boundArguments.Length == arrayTypeSymbol.Rank)
			{
				return new BoundArrayAccess(node, expr, boundArguments, arrayTypeSymbol.ElementType);
			}
			ReportDiagnostic(id: (boundArguments.Length <= arrayTypeSymbol.Rank) ? ERRID.ERR_TooFewIndices : ERRID.ERR_TooManyIndices, diagBag: diagnostics, syntax: node.ArgumentList, args: new object[1] { node.ToString() });
			return new BoundArrayAccess(node, expr, boundArguments, arrayTypeSymbol.ElementType, hasErrors: true);
		}

		private TypeSymbol GetCommonExpressionTypeForErrorRecovery(VisualBasicSyntaxNode symbolReference, ImmutableArray<Symbol> symbols, ConstantFieldsInProgress constantFieldsInProgress)
		{
			TypeSymbol typeSymbol = null;
			string text = null;
			bool flag = false;
			bool flag2 = false;
			BindingDiagnosticBag discarded = BindingDiagnosticBag.Discarded;
			int num = symbols.Length - 1;
			for (int i = 0; i <= num; i++)
			{
				TypeSymbol expressionType = GetExpressionType(symbolReference, symbols[i], constantFieldsInProgress, discarded);
				if ((object)expressionType != null)
				{
					if ((object)typeSymbol == null)
					{
						typeSymbol = expressionType;
					}
					else if (!flag && !typeSymbol.Equals(expressionType))
					{
						flag = true;
					}
					if (text == null)
					{
						text = expressionType.Name;
					}
					else if (!flag2 && !CaseInsensitiveComparison.Equals(text, expressionType.Name))
					{
						flag2 = true;
					}
				}
			}
			if (flag)
			{
				if (flag2)
				{
					return ErrorTypeSymbol.UnknownResultType;
				}
				return new ExtendedErrorTypeSymbol(null, text);
			}
			return typeSymbol;
		}

		private TypeSymbol GetExpressionType(VisualBasicSyntaxNode symbolReference, Symbol s, ConstantFieldsInProgress constantFieldsInProgress, BindingDiagnosticBag diagnostics)
		{
			switch (s.Kind)
			{
			case SymbolKind.Method:
				return ((MethodSymbol)s).ReturnType;
			case SymbolKind.Field:
				return ((FieldSymbol)s).GetInferredType(constantFieldsInProgress);
			case SymbolKind.Property:
				return ((PropertySymbol)s).Type;
			case SymbolKind.Parameter:
				return ((ParameterSymbol)s).Type;
			case SymbolKind.Local:
				return GetLocalSymbolType((LocalSymbol)s, symbolReference, diagnostics);
			case SymbolKind.RangeVariable:
				return ((RangeVariableSymbol)s).Type;
			default:
				if (s is TypeSymbol result)
				{
					return result;
				}
				return null;
			}
		}

		private static SyntaxToken GetNamedArgumentIdentifier(SyntaxNode argumentExpression)
		{
			if (!(argumentExpression.Parent is Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax simpleArgumentSyntax) || !simpleArgumentSyntax.IsNamed)
			{
				return argumentExpression.GetFirstToken();
			}
			return simpleArgumentSyntax.NameColonEquals.Name.Identifier;
		}

		private BoundExpression BindArrayCreationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			TypeSymbol elementType = BindTypeSyntax(node.Type, diagnostics);
			Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax arrayBounds = node.ArrayBounds;
			ImmutableArray<BoundExpression> immutableArray = default(ImmutableArray<BoundExpression>);
			ArrayTypeSymbol arrayTypeSymbol = CreateArrayOf(elementType, node.RankSpecifiers, arrayBounds, diagnostics);
			DimensionSize[] knownSizes = new DimensionSize[arrayTypeSymbol.Rank - 1 + 1];
			immutableArray = BindArrayBounds(arrayBounds, diagnostics, knownSizes);
			BoundArrayInitialization initializerOpt = BindArrayInitializerList(node.Initializer, arrayTypeSymbol, knownSizes, diagnostics);
			if (immutableArray.Length == 0)
			{
				immutableArray = CreateArrayBounds(node, knownSizes, diagnostics);
			}
			return new BoundArrayCreation(node, immutableArray, initializerOpt, arrayTypeSymbol);
		}

		private BoundExpression BindArrayLiteralExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax node, BindingDiagnosticBag diagnostics)
		{
			DimensionSize[] array = new DimensionSize[ComputeArrayLiteralRank(node) - 1 + 1];
			TypeSymbol inferredElementType = null;
			bool hasDominantType;
			int numberOfCandidates;
			BoundArrayInitialization boundArrayInitialization = BindArrayInitializerList(node, array, out hasDominantType, out numberOfCandidates, out inferredElementType, diagnostics);
			boundArrayInitialization.SetWasCompilerGenerated();
			ArrayTypeSymbol inferredType = ArrayTypeSymbol.CreateVBArray(inferredElementType, default(ImmutableArray<CustomModifier>), array.Length, Compilation);
			ImmutableArray<BoundExpression> bounds = CreateArrayBounds(node, array, diagnostics);
			return new BoundArrayLiteral(node, hasDominantType, numberOfCandidates, inferredType, bounds, boundArrayInitialization, this);
		}

		private ImmutableArray<BoundExpression> CreateArrayBounds(SyntaxNode node, DimensionSize[] knownSizes, BindingDiagnosticBag diagnostics)
		{
			BoundExpression[] array = new BoundExpression[knownSizes.Length - 1 + 1];
			NamedTypeSymbol specialType = GetSpecialType(SpecialType.System_Int32, node, diagnostics);
			int num = knownSizes.Length - 1;
			for (int i = 0; i <= num; i++)
			{
				DimensionSize dimensionSize = knownSizes[i];
				BoundLiteral boundLiteral = new BoundLiteral(node, ConstantValue.Create(dimensionSize.Size), specialType);
				boundLiteral.SetWasCompilerGenerated();
				array[i] = boundLiteral;
			}
			return array.AsImmutableOrNull();
		}

		private static int ComputeArrayLiteralRank(Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax node)
		{
			int num = 1;
			while (true)
			{
				SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax> initializers = node.Initializers;
				if (initializers.Count == 0)
				{
					break;
				}
				node = initializers[0] as Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax;
				if (node == null)
				{
					break;
				}
				num++;
			}
			return num;
		}

		private BoundArrayInitialization BindArrayInitializerList(Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax node, ArrayTypeSymbol type, DimensionSize[] knownSizes, BindingDiagnosticBag diagnostics)
		{
			return BindArrayInitializerList(node, type, knownSizes, 1, null, diagnostics);
		}

		private BoundArrayInitialization BindArrayInitializerList(Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax node, DimensionSize[] knownSizes, out bool hasDominantType, out int numberOfCandidates, out TypeSymbol inferredElementType, BindingDiagnosticBag diagnostics)
		{
			ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
			BoundArrayInitialization result = BindArrayInitializerList(node, null, knownSizes, 1, instance, diagnostics);
			InferenceErrorReasons errorReasons = InferenceErrorReasons.Other;
			inferredElementType = InferDominantTypeOfExpressions(node, instance, diagnostics, ref numberOfCandidates, ref errorReasons);
			if ((object)inferredElementType == null)
			{
				inferredElementType = GetSpecialType(SpecialType.System_Object, node, diagnostics);
				hasDominantType = false;
			}
			else
			{
				hasDominantType = true;
			}
			instance.Free();
			return result;
		}

		private BoundArrayInitialization BindArrayInitializerList(Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax node, ArrayTypeSymbol type, DimensionSize[] knownSizes, int dimension, ArrayBuilder<BoundExpression> allInitializers, BindingDiagnosticBag diagnostics)
		{
			ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
			TypeSymbol type2 = ((dimension != 1) ? null : type);
			int num = knownSizes.Length;
			if (dimension != 1 || node.Initializers.Count != 0)
			{
				if (dimension == num)
				{
					TypeSymbol typeSymbol = type?.ElementType;
					SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax>.Enumerator enumerator = node.Initializers.GetEnumerator();
					while (enumerator.MoveNext())
					{
						Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax current = enumerator.Current;
						BoundExpression boundExpression;
						if (current.Kind() != SyntaxKind.CollectionInitializer)
						{
							boundExpression = BindValue(current, diagnostics);
							if ((object)typeSymbol != null)
							{
								boundExpression = ApplyImplicitConversion(current, typeSymbol, boundExpression, diagnostics);
							}
						}
						else
						{
							boundExpression = ReportDiagnosticAndProduceBadExpression(diagnostics, current, ERRID.ERR_ArrayInitializerTooManyDimensions);
						}
						instance.Add(boundExpression);
						allInitializers?.Add(boundExpression);
					}
				}
				else
				{
					SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax>.Enumerator enumerator2 = node.Initializers.GetEnumerator();
					while (enumerator2.MoveNext())
					{
						Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax current2 = enumerator2.Current;
						BoundArrayInitialization boundArrayInitialization = null;
						if (current2.Kind() == SyntaxKind.CollectionInitializer)
						{
							boundArrayInitialization = BindArrayInitializerList((Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax)current2, type, knownSizes, dimension + 1, allInitializers, diagnostics);
						}
						else
						{
							ReportDiagnostic(diagnostics, current2, ERRID.ERR_ArrayInitializerTooFewDimensions);
							boundArrayInitialization = new BoundArrayInitialization(current2, ImmutableArray<BoundExpression>.Empty, type2, hasErrors: true);
						}
						instance.Add(boundArrayInitialization);
					}
				}
				DimensionSize dimensionSize = knownSizes[dimension - 1];
				if (dimensionSize.Kind == DimensionSize.SizeKind.Unknown)
				{
					knownSizes[dimension - 1] = DimensionSize.ConstantSize(instance.Count);
				}
				else
				{
					if (dimensionSize.Kind == DimensionSize.SizeKind.NotConstant)
					{
						ReportDiagnostic(diagnostics, node, ERRID.ERR_ArrayInitializerForNonConstDim);
						return new BoundArrayInitialization(node, instance.ToImmutableAndFree(), type2, hasErrors: true);
					}
					if (dimensionSize.Size < instance.Count)
					{
						ReportDiagnostic(diagnostics, node, ERRID.ERR_InitializerTooManyElements1, instance.Count - dimensionSize.Size);
						return new BoundArrayInitialization(node, instance.ToImmutableAndFree(), type2, hasErrors: true);
					}
					if (dimensionSize.Size > instance.Count)
					{
						ReportDiagnostic(diagnostics, node, ERRID.ERR_InitializerTooFewElements1, dimensionSize.Size - instance.Count);
						return new BoundArrayInitialization(node, instance.ToImmutableAndFree(), type2, hasErrors: true);
					}
				}
			}
			return new BoundArrayInitialization(node, instance.ToImmutableAndFree(), type2);
		}

		private void CheckRangeArgumentLowerBound(Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax rangeArgument, BindingDiagnosticBag diagnostics)
		{
			ConstantValue constantValueOpt = BindValue(rangeArgument.LowerBound, diagnostics).ConstantValueOpt;
			if ((object)constantValueOpt == null || !constantValueOpt.IsIntegral || !constantValueOpt.IsDefaultValue)
			{
				ReportDiagnostic(diagnostics, rangeArgument.LowerBound, ERRID.ERR_OnlyNullLowerBound);
			}
		}

		private ImmutableArray<BoundExpression> BindArrayBounds(Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax arrayBoundsOpt, BindingDiagnosticBag diagnostics, DimensionSize[] knownSizes = null, bool errorOnEmptyBound = false)
		{
			if (arrayBoundsOpt == null)
			{
				return s_noArguments;
			}
			SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax> arguments = arrayBoundsOpt.Arguments;
			ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
			NamedTypeSymbol specialType = GetSpecialType(SpecialType.System_Int32, arrayBoundsOpt, diagnostics);
			SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax>.Enumerator enumerator = arguments.GetEnumerator();
			while (enumerator.MoveNext())
			{
				SyntaxKind syntaxKind = enumerator.Current.Kind();
				if (syntaxKind == SyntaxKind.SimpleArgument || syntaxKind == SyntaxKind.RangeArgument)
				{
					errorOnEmptyBound = true;
					break;
				}
			}
			int num = arguments.Count - 1;
			for (int i = 0; i <= num; i++)
			{
				BoundExpression boundExpression = null;
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expressionSyntax = null;
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax argumentSyntax = arguments[i];
				switch (argumentSyntax.Kind())
				{
				case SyntaxKind.SimpleArgument:
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax obj = (Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax)argumentSyntax;
					if (obj.NameColonEquals != null)
					{
						ReportDiagnostic(diagnostics, argumentSyntax, ERRID.ERR_NamedSubscript);
					}
					expressionSyntax = obj.Expression;
					break;
				}
				case SyntaxKind.RangeArgument:
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax rangeArgumentSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax)argumentSyntax;
					CheckRangeArgumentLowerBound(rangeArgumentSyntax, diagnostics);
					expressionSyntax = rangeArgumentSyntax.UpperBound;
					break;
				}
				case SyntaxKind.OmittedArgument:
					if (!errorOnEmptyBound)
					{
						continue;
					}
					ReportDiagnostic(diagnostics, argumentSyntax, ERRID.ERR_MissingSubscript);
					goto default;
				default:
					boundExpression = BadExpression(argumentSyntax, ErrorTypeSymbol.UnknownResultType);
					break;
				}
				if (expressionSyntax != null)
				{
					boundExpression = BindValue(expressionSyntax, diagnostics);
					boundExpression = ApplyImplicitConversion(expressionSyntax, specialType, boundExpression, diagnostics);
				}
				ConstantValue constantValueOpt = boundExpression.ConstantValueOpt;
				if ((object)constantValueOpt != null && !constantValueOpt.IsBad && constantValueOpt.Int32Value < -1)
				{
					ReportDiagnostic(diagnostics, argumentSyntax, ERRID.ERR_NegativeArraySize);
				}
				BoundLiteral boundLiteral = new BoundLiteral(argumentSyntax, ConstantValue.Create(1), specialType);
				boundLiteral.SetWasCompilerGenerated();
				bool integerOverflow = false;
				bool divideByZero = false;
				BoundExpression left = boundExpression;
				bool lengthOutOfLimit = false;
				ConstantValue constantValue = OverloadResolution.TryFoldConstantBinaryOperator(BinaryOperatorKind.Add, left, boundLiteral, specialType, ref integerOverflow, ref divideByZero, ref lengthOutOfLimit);
				if (knownSizes != null)
				{
					if ((object)constantValue != null)
					{
						knownSizes[i] = DimensionSize.ConstantSize(constantValue.Int32Value);
					}
					else
					{
						knownSizes[i] = DimensionSize.VariableSize();
					}
				}
				BoundBinaryOperator boundBinaryOperator = new BoundBinaryOperator(argumentSyntax, BinaryOperatorKind.Add, boundExpression, boundLiteral, CheckOverflow, constantValue, specialType);
				boundBinaryOperator.SetWasCompilerGenerated();
				instance.Add(boundBinaryOperator);
			}
			return instance.ToImmutableAndFree();
		}

		private BoundLiteral BindLiteralConstant(Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			object objectValue = RuntimeHelpers.GetObjectValue(node.Token.Value);
			TypeSymbol type = null;
			ConstantValue value;
			if (objectValue == null)
			{
				value = ConstantValue.Null;
			}
			else
			{
				SpecialType specialType = SpecialTypeExtensions.FromRuntimeTypeOfLiteralValue(RuntimeHelpers.GetObjectValue(objectValue));
				value = ConstantValue.Create(RuntimeHelpers.GetObjectValue(objectValue), specialType);
				type = GetSpecialType(specialType, node, diagnostics);
			}
			return new BoundLiteral(node, value, type);
		}

		internal TypeSymbol InferDominantTypeOfExpressions(SyntaxNode syntax, ArrayBuilder<BoundExpression> Expressions, BindingDiagnosticBag diagnostics, ref int numCandidates, ref InferenceErrorReasons errorReasons = InferenceErrorReasons.Other)
		{
			numCandidates = 0;
			int num = 0;
			int num2 = 0;
			BoundArrayLiteral boundArrayLiteral = null;
			bool flag = true;
			TypeInferenceCollection typeInferenceCollection = new TypeInferenceCollection();
			ArrayBuilder<BoundExpression>.Enumerator enumerator = Expressions.GetEnumerator();
			while (enumerator.MoveNext())
			{
				BoundExpression boundExpression = enumerator.Current;
				num++;
				if (!BoundExpressionExtensions.IsNothingLiteral(boundExpression))
				{
					boundExpression = BoundExpressionExtensions.GetMostEnclosedParenthesizedExpression(boundExpression);
				}
				BoundKind kind = boundExpression.Kind;
				TypeSymbol type = boundExpression.Type;
				switch (kind)
				{
				case BoundKind.UnboundLambda:
					type = ((UnboundLambda)boundExpression).InferredAnonymousDelegate.Key;
					typeInferenceCollection.AddType(type, RequiredConversion.Any, boundExpression);
					continue;
				case BoundKind.TupleLiteral:
					type = ((BoundTupleLiteral)boundExpression).InferredType;
					if ((object)type != null)
					{
						typeInferenceCollection.AddType(type, RequiredConversion.Any, boundExpression);
					}
					continue;
				case BoundKind.ArrayLiteral:
				{
					BoundArrayLiteral boundArrayLiteral2 = (BoundArrayLiteral)boundExpression;
					if (boundArrayLiteral2.IsEmptyArrayLiteral)
					{
						num2++;
						boundArrayLiteral = boundArrayLiteral2;
					}
					else if (boundArrayLiteral2.HasDominantType)
					{
						type = new ArrayLiteralTypeSymbol(boundArrayLiteral2);
						typeInferenceCollection.AddType(type, RequiredConversion.Any, boundExpression);
					}
					continue;
				}
				}
				if ((object)type != null && !TypeSymbolExtensions.IsVoidType(type) && (!TypeSymbolExtensions.IsArrayType(type) || !TypeSymbolExtensions.IsVoidType(((ArrayTypeSymbol)type).ElementType)))
				{
					typeInferenceCollection.AddType(type, RequiredConversion.Any, boundExpression);
					if (TypeSymbolExtensions.IsRestrictedType(type))
					{
						flag = false;
					}
				}
				else if (!BoundExpressionExtensions.IsNothingLiteral(boundExpression))
				{
					flag = false;
				}
			}
			errorReasons = InferenceErrorReasons.Other;
			ArrayBuilder<DominantTypeData> instance = ArrayBuilder<DominantTypeData>.GetInstance();
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
			typeInferenceCollection.FindDominantType(instance, ref errorReasons, ref useSiteInfo);
			if (((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(syntax, useSiteInfo))
			{
				diagnostics = BindingDiagnosticBag.Discarded;
			}
			TypeSymbol typeSymbol;
			if (instance.Count == 1 && errorReasons == InferenceErrorReasons.Other)
			{
				numCandidates = 1;
				typeSymbol = instance[0].ResultType;
			}
			else if (num == num2 && num > 0)
			{
				numCandidates = 1;
				typeSymbol = boundArrayLiteral.InferredType;
			}
			else if (flag && (errorReasons & InferenceErrorReasons.Ambiguous) != 0)
			{
				numCandidates = instance.Count;
				typeSymbol = GetSpecialType(SpecialType.System_Object, syntax, diagnostics);
			}
			else if (flag)
			{
				numCandidates = 0;
				typeSymbol = GetSpecialType(SpecialType.System_Object, syntax, diagnostics);
			}
			else
			{
				numCandidates = 0;
				typeSymbol = null;
			}
			if (typeSymbol is ArrayLiteralTypeSymbol arrayLiteralTypeSymbol)
			{
				typeSymbol = arrayLiteralTypeSymbol.ArrayLiteral.InferredType;
			}
			instance.Free();
			return typeSymbol;
		}

		public bool IsInAsyncContext()
		{
			if (ContainingMember.Kind == SymbolKind.Method)
			{
				return ((MethodSymbol)ContainingMember).IsAsync;
			}
			return false;
		}

		public bool IsInIteratorContext()
		{
			if (ContainingMember.Kind == SymbolKind.Method)
			{
				return ((MethodSymbol)ContainingMember).IsIterator;
			}
			return false;
		}

		private BoundExpression BindAwait(Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax node, BindingDiagnosticBag diagnostics, bool bindAsStatement = false)
		{
			if (IsInQuery)
			{
				ReportDiagnostic(diagnostics, node.AwaitKeyword, ERRID.ERR_BadAsyncInQuery);
			}
			else if (!IsInAsyncContext())
			{
				ReportDiagnostic(diagnostics, node.AwaitKeyword, GetAwaitInNonAsyncError());
			}
			BoundExpression operand = BindExpression(node.Expression, diagnostics);
			return BindAwait(node, operand, diagnostics, bindAsStatement);
		}

		private BoundExpression BindAwait(VisualBasicSyntaxNode node, BoundExpression operand, BindingDiagnosticBag diagnostics, bool bindAsStatement)
		{
			if (!operand.HasErrors && (object)operand.Type != null && TypeSymbolExtensions.IsVoidType(operand.Type) && operand.Kind == BoundKind.Call)
			{
				MethodSymbol method = ((BoundCall)operand).Method;
				if (method.IsSub && method.IsAsync)
				{
					ReportDiagnostic(diagnostics, operand.Syntax, ERRID.ERR_CantAwaitAsyncSub1, method.Name);
					return BadExpression(node, operand, ErrorTypeSymbol.UnknownResultType);
				}
			}
			operand = MakeRValue(operand, diagnostics);
			if (BoundExpressionExtensions.IsNothingLiteral(operand))
			{
				ReportDiagnostic(diagnostics, node, ERRID.ERR_BadAwaitNothing);
				return BadExpression(node, operand, ErrorTypeSymbol.UnknownResultType);
			}
			if (TypeSymbolExtensions.IsObjectType(operand.Type))
			{
				if (OptionStrict == OptionStrict.On)
				{
					ReportDiagnostic(diagnostics, node, ERRID.ERR_StrictDisallowsLateBinding);
					return BadExpression(node, operand, ErrorTypeSymbol.UnknownResultType);
				}
				if (OptionStrict == OptionStrict.Custom)
				{
					ReportDiagnostic(diagnostics, node, ERRID.WRN_LateBindingResolution);
				}
			}
			if (operand.HasErrors)
			{
				diagnostics = BindingDiagnosticBag.Discarded;
			}
			BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(withDiagnostics: true, diagnostics.AccumulatesDependencies);
			BindingDiagnosticBag instance2 = BindingDiagnosticBag.GetInstance(diagnostics);
			BoundRValuePlaceholder boundRValuePlaceholder = BoundNodeExtensions.MakeCompilerGenerated(new BoundRValuePlaceholder(operand.Syntax, operand.Type));
			BoundLValuePlaceholder boundLValuePlaceholder = null;
			BoundExpression boundExpression = null;
			BoundExpression boundExpression2 = null;
			BoundExpression boundExpression3 = null;
			if (TypeSymbolExtensions.IsObjectType(operand.Type))
			{
				boundExpression = BoundNodeExtensions.MakeCompilerGenerated(BindLateBoundMemberAccess(node, "GetAwaiter", null, boundRValuePlaceholder, operand.Type, instance, suppressLateBindingResolutionDiagnostics: true));
				boundExpression = ((BoundLateMemberAccess)boundExpression).SetAccessKind(LateBoundAccessKind.Get);
				boundLValuePlaceholder = BoundNodeExtensions.MakeCompilerGenerated(new BoundLValuePlaceholder(operand.Syntax, boundExpression.Type));
				boundExpression2 = BoundNodeExtensions.MakeCompilerGenerated(BindLateBoundMemberAccess(node, "IsCompleted", null, boundLValuePlaceholder, boundLValuePlaceholder.Type, instance, suppressLateBindingResolutionDiagnostics: true));
				boundExpression2 = ((BoundLateMemberAccess)boundExpression2).SetAccessKind(LateBoundAccessKind.Get);
				boundExpression3 = BoundNodeExtensions.MakeCompilerGenerated(BindLateBoundMemberAccess(node, "GetResult", null, boundLValuePlaceholder, boundLValuePlaceholder.Type, instance, suppressLateBindingResolutionDiagnostics: true));
				boundExpression3 = ((BoundLateMemberAccess)boundExpression3).SetAccessKind((!bindAsStatement) ? LateBoundAccessKind.Get : LateBoundAccessKind.Call);
			}
			else
			{
				LookupResult instance3 = LookupResult.GetInstance();
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
				LookupMember(instance3, boundRValuePlaceholder.Type, "GetAwaiter", 0, LookupOptions.AllMethodsOfAnyArity, ref useSiteInfo);
				BoundMethodGroup boundMethodGroup = null;
				if (instance3.Kind == LookupResultKind.Good && instance3.Symbols[0].Kind == SymbolKind.Method)
				{
					boundMethodGroup = BoundNodeExtensions.MakeCompilerGenerated(CreateBoundMethodGroup(node, instance3, LookupOptions.Default, instance.AccumulatesDependencies, boundRValuePlaceholder, null, QualificationKind.QualifiedViaValue));
					instance.Clear();
					boundExpression = BoundNodeExtensions.MakeCompilerGenerated(MakeRValue(BoundNodeExtensions.MakeCompilerGenerated(BindInvocationExpression(node, operand.Syntax, TypeCharacter.None, boundMethodGroup, ImmutableArray<BoundExpression>.Empty, default(ImmutableArray<string>), instance, node)), instance));
					if (boundExpression.HasErrors || DiagnosticBagHasErrorsOtherThanObsoleteOnes(instance.DiagnosticBag) || boundExpression.Kind != BoundKind.Call || TypeSymbolExtensions.IsObjectType(boundExpression.Type))
					{
						boundExpression = null;
					}
					else
					{
						instance2.AddRange(instance);
						MethodSymbol method2 = ((BoundCall)boundExpression).Method;
						if (method2.IsShared || method2.ParameterCount != 0)
						{
							boundExpression = null;
						}
					}
				}
				if (boundExpression != null && !TypeSymbolExtensions.IsErrorType(boundExpression.Type))
				{
					boundLValuePlaceholder = BoundNodeExtensions.MakeCompilerGenerated(new BoundLValuePlaceholder(operand.Syntax, boundExpression.Type));
					instance3.Clear();
					LookupMember(instance3, boundLValuePlaceholder.Type, "IsCompleted", 0, LookupOptions.AllMethodsOfAnyArity | LookupOptions.IgnoreExtensionMethods, ref useSiteInfo);
					if (instance3.Kind == LookupResultKind.Good && instance3.Symbols[0].Kind == SymbolKind.Property)
					{
						BoundPropertyGroup group = BoundNodeExtensions.MakeCompilerGenerated(new BoundPropertyGroup(node, instance3.Symbols.ToDowncastedImmutable<PropertySymbol>(), instance3.Kind, boundLValuePlaceholder, QualificationKind.QualifiedViaValue));
						instance.Clear();
						boundExpression2 = BoundNodeExtensions.MakeCompilerGenerated(MakeRValue(BoundNodeExtensions.MakeCompilerGenerated(BindInvocationExpression(node, operand.Syntax, TypeCharacter.None, group, ImmutableArray<BoundExpression>.Empty, default(ImmutableArray<string>), instance, node)), instance));
						if (boundExpression2.HasErrors || DiagnosticBagHasErrorsOtherThanObsoleteOnes(instance.DiagnosticBag) || boundExpression2.Kind != BoundKind.PropertyAccess || !TypeSymbolExtensions.IsBooleanType(boundExpression2.Type))
						{
							boundExpression2 = null;
						}
						else
						{
							instance2.AddRange(instance);
							PropertySymbol propertySymbol = ((BoundPropertyAccess)boundExpression2).PropertySymbol;
							if (propertySymbol.IsShared || propertySymbol.ParameterCount != 0)
							{
								boundExpression2 = null;
							}
						}
					}
					instance3.Clear();
					LookupMember(instance3, boundLValuePlaceholder.Type, "GetResult", 0, LookupOptions.AllMethodsOfAnyArity | LookupOptions.IgnoreExtensionMethods, ref useSiteInfo);
					if (instance3.Kind == LookupResultKind.Good && instance3.Symbols[0].Kind == SymbolKind.Method)
					{
						boundMethodGroup = BoundNodeExtensions.MakeCompilerGenerated(CreateBoundMethodGroup(node, instance3, LookupOptions.Default, instance.AccumulatesDependencies, boundLValuePlaceholder, null, QualificationKind.QualifiedViaValue));
						instance.Clear();
						boundExpression3 = BoundNodeExtensions.MakeCompilerGenerated(BindInvocationExpression(node, operand.Syntax, TypeCharacter.None, boundMethodGroup, ImmutableArray<BoundExpression>.Empty, default(ImmutableArray<string>), instance, node));
						if (boundExpression3.HasErrors || DiagnosticBagHasErrorsOtherThanObsoleteOnes(instance.DiagnosticBag) || boundExpression3.Kind != BoundKind.Call)
						{
							boundExpression3 = null;
						}
						else
						{
							instance2.AddRange(instance);
							MethodSymbol method3 = ((BoundCall)boundExpression3).Method;
							if (method3.IsShared || method3.ParameterCount != 0 || (method3.IsSub && method3.IsConditional))
							{
								boundExpression3 = null;
							}
						}
					}
					NamedTypeSymbol wellKnownType = GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_INotifyCompletion, node, diagnostics);
					if (!TypeSymbolExtensions.IsErrorType(wellKnownType) && !Conversions.IsWideningConversion(Conversions.ClassifyDirectCastConversion(boundExpression.Type, wellKnownType, ref useSiteInfo)))
					{
						ReportDiagnostic(diagnostics, node, ERRID.ERR_DoesntImplementAwaitInterface2, boundExpression.Type, wellKnownType);
					}
				}
				((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)node, useSiteInfo);
				instance3.Free();
			}
			bool flag = false;
			if (boundExpression == null)
			{
				flag = true;
				ReportDiagnostic(diagnostics, node, ERRID.ERR_BadGetAwaiterMethod1, operand.Type);
				boundExpression = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(node, ErrorTypeSymbol.UnknownResultType));
			}
			else if (TypeSymbolExtensions.IsErrorType(boundExpression.Type))
			{
				flag = true;
			}
			else if (boundExpression2 == null || boundExpression3 == null)
			{
				flag = true;
				ReportDiagnostic(diagnostics, node, ERRID.ERR_BadIsCompletedOnCompletedGetResult2, boundExpression.Type, operand.Type);
			}
			if (boundLValuePlaceholder == null)
			{
				boundLValuePlaceholder = BoundNodeExtensions.MakeCompilerGenerated(new BoundLValuePlaceholder(node, boundExpression.Type));
			}
			if (boundExpression2 == null)
			{
				boundExpression2 = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(node, ErrorTypeSymbol.UnknownResultType));
			}
			if (boundExpression3 == null)
			{
				boundExpression3 = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(node, ErrorTypeSymbol.UnknownResultType));
			}
			TypeSymbol type = ((!bindAsStatement) ? boundExpression3.Type : GetSpecialType(SpecialType.System_Void, node, diagnostics));
			if (!flag)
			{
				diagnostics.AddRange(instance2);
			}
			instance2.Free();
			instance.Free();
			return new BoundAwaitOperator(node, operand, boundRValuePlaceholder, boundExpression, boundLValuePlaceholder, boundExpression2, boundExpression3, type, flag);
		}

		private static bool DiagnosticBagHasErrorsOtherThanObsoleteOnes(DiagnosticBag bag)
		{
			if (bag.IsEmptyWithoutResolution)
			{
				return false;
			}
			foreach (Diagnostic item in bag.AsEnumerable())
			{
				if (item.Severity == DiagnosticSeverity.Error)
				{
					int code = item.Code;
					if (code != 30668 && (uint)(code - 30911) > 1u && code != 31075)
					{
						return true;
					}
				}
			}
			return false;
		}

		private DiagnosticInfo GetAwaitInNonAsyncError()
		{
			if (IsInLambda)
			{
				return ErrorFactory.ErrorInfo(ERRID.ERR_BadAwaitInNonAsyncLambda);
			}
			if (ContainingMember.Kind == SymbolKind.Method)
			{
				MethodSymbol methodSymbol = (MethodSymbol)ContainingMember;
				if (methodSymbol.IsSub)
				{
					return ErrorFactory.ErrorInfo(ERRID.ERR_BadAwaitInNonAsyncVoidMethod);
				}
				return ErrorFactory.ErrorInfo(ERRID.ERR_BadAwaitInNonAsyncMethod, methodSymbol.ReturnType);
			}
			return ErrorFactory.ErrorInfo(ERRID.ERR_BadAwaitNotInAsyncMethodOrLambda);
		}

		public void BindImportClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsClauseSyntax importClauseSyntax, ImportData data, DiagnosticBag diagBag)
		{
			ImportsBinder.BindImportClause(importClauseSyntax, this, data, diagBag);
		}

		internal static ImmutableArray<BoundInitializer> BindFieldAndPropertyInitializers(SourceMemberContainerTypeSymbol symbol, ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> initializers, SynthesizedInteractiveInitializerMethod scriptInitializerOpt, BindingDiagnosticBag diagnostics)
		{
			if (initializers.IsDefaultOrEmpty)
			{
				return ImmutableArray<BoundInitializer>.Empty;
			}
			SourceModuleSymbol sourceModuleSymbol = (SourceModuleSymbol)symbol.ContainingModule;
			_ = sourceModuleSymbol.ContainingSourceAssembly.DeclaringCompilation;
			ArrayBuilder<BoundInitializer> instance = ArrayBuilder<BoundInitializer>.GetInstance();
			int num = initializers.Length - 1;
			for (int i = 0; i <= num; i++)
			{
				ImmutableArray<FieldOrPropertyInitializer> immutableArray = initializers[i];
				Binder binder = null;
				int num2 = immutableArray.Length - 1;
				for (int j = 0; j <= num2; j++)
				{
					FieldOrPropertyInitializer fieldOrPropertyInitializer = immutableArray[j];
					if (!fieldOrPropertyInitializer.FieldsOrProperties.IsDefault && TypeSymbolExtensions.IsEnumType(fieldOrPropertyInitializer.FieldsOrProperties.First().ContainingType))
					{
						continue;
					}
					SyntaxReference syntax = fieldOrPropertyInitializer.Syntax;
					SyntaxTree syntaxTree = syntax.SyntaxTree;
					VisualBasicSyntaxNode visualBasicSyntaxNode = (VisualBasicSyntaxNode)syntax.GetSyntax();
					if (binder == null)
					{
						binder = BinderBuilder.CreateBinderForType(sourceModuleSymbol, syntaxTree, symbol);
						if ((object)scriptInitializerOpt != null)
						{
							binder = new TopLevelCodeBinder(scriptInitializerOpt, binder);
						}
					}
					if (fieldOrPropertyInitializer.FieldsOrProperties.IsDefault)
					{
						bool isLast = i == initializers.Length - 1 && j == immutableArray.Length - 1;
						instance.Add(binder.BindGlobalStatement(scriptInitializerOpt, (Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)visualBasicSyntaxNode, diagnostics, isLast));
						continue;
					}
					Symbol symbol2 = fieldOrPropertyInitializer.FieldsOrProperties.First();
					ImmutableArray<Symbol> additionalFieldsOrProperties = ((fieldOrPropertyInitializer.FieldsOrProperties.Length > 1) ? fieldOrPropertyInitializer.FieldsOrProperties.RemoveAt(0) : ImmutableArray<Symbol>.Empty);
					Binder binder2 = BinderBuilder.CreateBinderForInitializer(binder, symbol2, additionalFieldsOrProperties);
					if (visualBasicSyntaxNode.Kind() == SyntaxKind.ModifiedIdentifier)
					{
						SourceFieldSymbol fieldSymbol = (SourceFieldSymbol)symbol2;
						binder2.BindArrayFieldImplicitInitializer(fieldSymbol, instance, diagnostics);
					}
					else if (symbol2.Kind == SymbolKind.Field)
					{
						SourceFieldSymbol sourceFieldSymbol = (SourceFieldSymbol)symbol2;
						if (sourceFieldSymbol.IsConst)
						{
							BindConstFieldInitializer(sourceFieldSymbol, visualBasicSyntaxNode, instance);
							if (sourceFieldSymbol.Type.SpecialType == SpecialType.System_DateTime)
							{
								binder2.ReportUseSiteInfoForSynthesizedAttribute(WellKnownMember.System_Runtime_CompilerServices_DateTimeConstantAttribute__ctor, visualBasicSyntaxNode, diagnostics);
							}
							else if (sourceFieldSymbol.Type.SpecialType == SpecialType.System_Decimal)
							{
								binder2.ReportUseSiteInfoForSynthesizedAttribute(WellKnownMember.System_Runtime_CompilerServices_DecimalConstantAttribute__ctor, visualBasicSyntaxNode, diagnostics);
							}
							continue;
						}
						if (TypeSymbolExtensions.IsObjectType(sourceFieldSymbol.Type) && binder2.OptionStrict != OptionStrict.On && sourceFieldSymbol.Syntax != null && sourceFieldSymbol.Syntax.Kind() == SyntaxKind.ModifiedIdentifier)
						{
							Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax modifiedIdentifierSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax)sourceFieldSymbol.Syntax;
							if (modifiedIdentifierSyntax.Nullable.Node != null && modifiedIdentifierSyntax.Parent != null && modifiedIdentifierSyntax.Parent.Kind() == SyntaxKind.VariableDeclarator && ((Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax)modifiedIdentifierSyntax.Parent).AsClause == null)
							{
								ReportDiagnostic(diagnostics, modifiedIdentifierSyntax, ERRID.ERR_NullableTypeInferenceNotSupported);
							}
						}
						binder2.BindFieldInitializer(fieldOrPropertyInitializer.FieldsOrProperties.Cast<FieldSymbol>().ToImmutableArray(), visualBasicSyntaxNode, instance, diagnostics);
					}
					else
					{
						binder2.BindPropertyInitializer(fieldOrPropertyInitializer.FieldsOrProperties.Cast<PropertySymbol>().ToImmutableArray(), visualBasicSyntaxNode, instance, diagnostics);
					}
				}
			}
			return instance.ToImmutableAndFree();
		}

		private BoundInitializer BindGlobalStatement(SynthesizedInteractiveInitializerMethod scriptInitializerOpt, Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax statementNode, BindingDiagnosticBag diagnostics, bool isLast)
		{
			BoundStatement boundStatement = BindStatement(statementNode, diagnostics);
			if (Compilation.IsSubmission && isLast && boundStatement.Kind == BoundKind.ExpressionStatement && !boundStatement.HasErrors)
			{
				BoundExpression expression = ((BoundExpressionStatement)boundStatement).Expression;
				if ((object)expression.Type == null || expression.Type.SpecialType != SpecialType.System_Void)
				{
					TypeSymbol resultType = scriptInitializerOpt.ResultType;
					expression = ApplyImplicitConversion(expression.Syntax, resultType, expression, diagnostics);
					boundStatement = new BoundExpressionStatement(boundStatement.Syntax, expression, expression.HasErrors);
				}
			}
			return new BoundGlobalStatementInitializer(statementNode, boundStatement);
		}

		public void BindArrayFieldImplicitInitializer(SourceFieldSymbol fieldSymbol, ArrayBuilder<BoundInitializer> boundInitializers, BindingDiagnosticBag diagnostics)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax modifiedIdentifierSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax)fieldSymbol.Syntax;
			ImmutableArray<BoundExpression> bounds = BindArrayBounds(modifiedIdentifierSyntax.ArrayBounds, diagnostics);
			BoundArrayCreation boundArrayCreation = new BoundArrayCreation(modifiedIdentifierSyntax, bounds, null, fieldSymbol.Type);
			boundArrayCreation.SetWasCompilerGenerated();
			BoundMeReference receiverOpt = (fieldSymbol.IsShared ? null : CreateMeReference(modifiedIdentifierSyntax, isSynthetic: true));
			BoundFieldAccess boundFieldAccess = new BoundFieldAccess(modifiedIdentifierSyntax, receiverOpt, fieldSymbol, isLValue: true, fieldSymbol.Type);
			boundFieldAccess.SetWasCompilerGenerated();
			BoundFieldInitializer item = new BoundFieldInitializer(modifiedIdentifierSyntax, ImmutableArray.Create((FieldSymbol)fieldSymbol), boundFieldAccess, boundArrayCreation);
			boundInitializers.Add(item);
		}

		internal void BindFieldInitializer(ImmutableArray<FieldSymbol> fieldSymbols, SyntaxNode equalsValueOrAsNewSyntax, ArrayBuilder<BoundInitializer> boundInitializers, BindingDiagnosticBag diagnostics, bool bindingForSemanticModel = false)
		{
			SourceFieldSymbol sourceFieldSymbol = (SourceFieldSymbol)fieldSymbols.First();
			BoundMeReference receiverOpt = (sourceFieldSymbol.IsShared ? null : CreateMeReference(sourceFieldSymbol.Syntax, isSynthetic: true));
			BoundExpression boundExpression = new BoundFieldAccess(sourceFieldSymbol.Syntax, receiverOpt, sourceFieldSymbol, isLValue: true, sourceFieldSymbol.Type);
			boundExpression.SetWasCompilerGenerated();
			BoundWithLValueExpressionPlaceholder boundWithLValueExpressionPlaceholder = null;
			if (VisualBasicExtensions.Kind(equalsValueOrAsNewSyntax) == SyntaxKind.AsNewClause)
			{
				boundWithLValueExpressionPlaceholder = new BoundWithLValueExpressionPlaceholder(equalsValueOrAsNewSyntax, sourceFieldSymbol.Type);
				boundWithLValueExpressionPlaceholder.SetWasCompilerGenerated();
			}
			BoundExpression initialValue = BindFieldOrPropertyInitializerExpression(equalsValueOrAsNewSyntax, sourceFieldSymbol.Type, boundWithLValueExpressionPlaceholder, diagnostics);
			bool hasErrors = false;
			if (equalsValueOrAsNewSyntax.Parent != null && VisualBasicExtensions.Kind(equalsValueOrAsNewSyntax) == SyntaxKind.AsNewClause)
			{
				SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax>.Enumerator enumerator = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax)equalsValueOrAsNewSyntax.Parent).Names.GetEnumerator();
				while (enumerator.MoveNext())
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax current = enumerator.Current;
					if (!current.ArrayRankSpecifiers.IsEmpty() || current.ArrayBounds != null)
					{
						ReportDiagnostic(diagnostics, current, ERRID.ERR_AsNewArray);
						hasErrors = true;
					}
				}
			}
			boundInitializers.Add(new BoundFieldInitializer(equalsValueOrAsNewSyntax, fieldSymbols, (fieldSymbols.Length == 1) ? boundExpression : null, initialValue, hasErrors));
		}

		internal void BindPropertyInitializer(ImmutableArray<PropertySymbol> propertySymbols, SyntaxNode initValueOrAsNewNode, ArrayBuilder<BoundInitializer> boundInitializers, BindingDiagnosticBag diagnostics)
		{
			PropertySymbol propertySymbol = propertySymbols.First();
			BoundMeReference receiverOpt = (propertySymbol.IsShared ? null : CreateMeReference(initValueOrAsNewNode, isSynthetic: true));
			bool hasErrors = propertySymbol.ParameterCount > 0;
			BoundExpression expression = ((!propertySymbol.IsReadOnly || (object)propertySymbol.AssociatedField == null) ? ((BoundExpression)new BoundPropertyAccess(initValueOrAsNewNode, propertySymbol, null, PropertyAccessKind.Set, propertySymbol.HasSet, receiverOpt, ImmutableArray<BoundExpression>.Empty, default(BitVector), hasErrors)) : ((BoundExpression)new BoundFieldAccess(initValueOrAsNewNode, receiverOpt, propertySymbol.AssociatedField, isLValue: true, propertySymbol.Type, hasErrors)));
			expression = BindAssignmentTarget(initValueOrAsNewNode, expression, diagnostics);
			bool isError = default(bool);
			expression = AdjustAssignmentTarget(initValueOrAsNewNode, expression, diagnostics, ref isError);
			expression.SetWasCompilerGenerated();
			BoundExpression initialValue = BindFieldOrPropertyInitializerExpression(initValueOrAsNewNode, propertySymbol.Type, null, diagnostics);
			boundInitializers.Add(new BoundPropertyInitializer(initValueOrAsNewNode, propertySymbols, (propertySymbols.Length == 1) ? expression : null, initialValue));
		}

		private BoundExpression BindFieldOrPropertyInitializerExpression(SyntaxNode equalsValueOrAsNewSyntax, TypeSymbol targetType, BoundWithLValueExpressionPlaceholder asNewVariablePlaceholderOpt, BindingDiagnosticBag diagnostics)
		{
			BoundExpression boundExpression = null;
			if (VisualBasicExtensions.Kind(equalsValueOrAsNewSyntax) == SyntaxKind.AsNewClause)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax asNewClauseSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax)equalsValueOrAsNewSyntax;
				switch (asNewClauseSyntax.NewExpression.Kind())
				{
				case SyntaxKind.ObjectCreationExpression:
				{
					DisallowNewOnTupleType(SyntaxExtensions.Type(asNewClauseSyntax), diagnostics);
					Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax objectCreationExpressionSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax)asNewClauseSyntax.NewExpression;
					boundExpression = BindObjectCreationExpression(SyntaxExtensions.Type(asNewClauseSyntax.NewExpression), objectCreationExpressionSyntax.ArgumentList, targetType, objectCreationExpressionSyntax, diagnostics, asNewVariablePlaceholderOpt);
					break;
				}
				case SyntaxKind.AnonymousObjectCreationExpression:
					boundExpression = BindAnonymousObjectCreationExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax)asNewClauseSyntax.NewExpression, diagnostics);
					break;
				default:
					throw ExceptionUtilities.UnexpectedValue(asNewClauseSyntax.NewExpression.Kind());
				}
				VisualBasicSyntaxNode visualBasicSyntaxNode = asNewClauseSyntax;
			}
			else
			{
				VisualBasicSyntaxNode visualBasicSyntaxNode = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax)equalsValueOrAsNewSyntax).Value;
				boundExpression = BindValue((Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)visualBasicSyntaxNode, diagnostics);
			}
			if ((object)targetType != null)
			{
				return ApplyImplicitConversion(boundExpression.Syntax, targetType, boundExpression, diagnostics);
			}
			return MakeRValueAndIgnoreDiagnostics(boundExpression);
		}

		private static void BindConstFieldInitializer(SourceFieldSymbol fieldSymbol, VisualBasicSyntaxNode equalsValueOrAsNewSyntax, ArrayBuilder<BoundInitializer> boundInitializers)
		{
			if (fieldSymbol.IsConstButNotMetadataConstant)
			{
				ConstantValue constantValue = fieldSymbol.GetConstantValue(ConstantFieldsInProgress.Empty);
				if ((object)constantValue != null)
				{
					BoundFieldAccess boundFieldAccess = new BoundFieldAccess(equalsValueOrAsNewSyntax, null, fieldSymbol, isLValue: true, fieldSymbol.Type);
					boundFieldAccess.SetWasCompilerGenerated();
					BoundLiteral initialValue = new BoundLiteral(equalsValueOrAsNewSyntax, constantValue, fieldSymbol.Type);
					boundInitializers.Add(new BoundFieldInitializer(equalsValueOrAsNewSyntax, ImmutableArray.Create((FieldSymbol)fieldSymbol), boundFieldAccess, initialValue));
				}
			}
		}

		internal BoundExpression BindFieldAndEnumConstantInitializer(FieldSymbol fieldSymbol, VisualBasicSyntaxNode equalsValueOrAsNewSyntax, bool isEnum, BindingDiagnosticBag diagnostics, out ConstantValue constValue)
		{
			constValue = null;
			BoundExpression boundExpression = null;
			BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(withDiagnostics: true, diagnostics.AccumulatesDependencies);
			if (equalsValueOrAsNewSyntax.Kind() == SyntaxKind.EqualsValue)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax equalsValueSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax)equalsValueOrAsNewSyntax;
				boundExpression = BindValue(equalsValueSyntax.Value, instance);
			}
			else
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax asNewClauseSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax)equalsValueOrAsNewSyntax;
				TypeSymbol typeSymbol = (fieldSymbol.HasDeclaredType ? fieldSymbol.Type : GetSpecialType(SpecialType.System_Object, asNewClauseSyntax, BindingDiagnosticBag.Discarded));
				switch (asNewClauseSyntax.NewExpression.Kind())
				{
				case SyntaxKind.ObjectCreationExpression:
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax objectCreationExpressionSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax)asNewClauseSyntax.NewExpression;
					boundExpression = BindObjectCreationExpression(SyntaxExtensions.Type(asNewClauseSyntax), objectCreationExpressionSyntax.ArgumentList, typeSymbol, objectCreationExpressionSyntax, BindingDiagnosticBag.Discarded, null);
					break;
				}
				case SyntaxKind.AnonymousObjectCreationExpression:
					boundExpression = BindAnonymousObjectCreationExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax)asNewClauseSyntax.NewExpression, BindingDiagnosticBag.Discarded);
					break;
				default:
					throw ExceptionUtilities.UnexpectedValue(asNewClauseSyntax.NewExpression.Kind());
				}
				boundExpression = new BoundBadExpression(boundExpression.Syntax, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, ImmutableArray.Create(boundExpression), typeSymbol, hasErrors: true);
			}
			if (!boundExpression.HasErrors)
			{
				TypeSymbol typeSymbol2;
				if (fieldSymbol.HasDeclaredType)
				{
					typeSymbol2 = fieldSymbol.Type;
					if (isEnum)
					{
						typeSymbol2 = TypeSymbolExtensions.GetEnumUnderlyingTypeOrSelf(typeSymbol2);
					}
					boundExpression = ApplyImplicitConversion(boundExpression.Syntax, typeSymbol2, boundExpression, instance);
				}
				else
				{
					typeSymbol2 = boundExpression.Type ?? ErrorTypeSymbol.UnknownResultType;
				}
				if (instance.HasAnyErrors() || (fieldSymbol.HasDeclaredType && !TypeSymbolExtensions.IsValidTypeForConstField(typeSymbol2)))
				{
					constValue = GetExpressionConstantValueIfAny(boundExpression, BindingDiagnosticBag.Discarded, ConstantContext.Default);
				}
				else
				{
					constValue = GetExpressionConstantValueIfAny(boundExpression, instance, ConstantContext.Default);
				}
				if ((object)constValue == null)
				{
					boundExpression = BadExpression(boundExpression.Syntax, boundExpression, typeSymbol2);
				}
			}
			diagnostics.AddRange(instance);
			instance.Free();
			return boundExpression;
		}

		internal BoundExpression BindLocalConstantInitializer(LocalSymbol symbol, TypeSymbol type, Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax name, Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax equalsValueOpt, BindingDiagnosticBag diagnostics, out ConstantValue constValue)
		{
			constValue = null;
			BoundExpression boundExpression = null;
			if (equalsValueOpt != null)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value = equalsValueOpt.Value;
				if (IsBindingImplicitlyTypedLocal(symbol))
				{
					ReportDiagnostic(diagnostics, name, ERRID.ERR_CircularEvaluation1, symbol);
					return BadExpression(value, ErrorTypeSymbol.UnknownResultType);
				}
				LocalInProgressBinder localInProgressBinder = new LocalInProgressBinder(this, symbol);
				boundExpression = localInProgressBinder.BindValue(value, diagnostics);
				if ((object)type != null)
				{
					boundExpression = localInProgressBinder.ApplyImplicitConversion(value, type, boundExpression, diagnostics);
				}
				if (!boundExpression.HasErrors)
				{
					if ((object)boundExpression.Type == null || !TypeSymbolExtensions.IsErrorType(boundExpression.Type))
					{
						constValue = localInProgressBinder.GetExpressionConstantValueIfAny(boundExpression, diagnostics, ConstantContext.Default);
						if ((object)constValue != null)
						{
							return boundExpression;
						}
					}
					return BoundNodeExtensions.MakeCompilerGenerated(BadExpression(value, boundExpression, ErrorTypeSymbol.UnknownResultType));
				}
			}
			else
			{
				boundExpression = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(name, ErrorTypeSymbol.UnknownResultType));
				ReportDiagnostic(diagnostics, name, ERRID.ERR_ConstantWithNoValue);
			}
			return boundExpression;
		}

		internal BoundExpression BindParameterDefaultValue(TypeSymbol targetType, Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax equalsValueSyntax, BindingDiagnosticBag diagnostics, out ConstantValue constValue)
		{
			constValue = null;
			BoundExpression boundExpression = BindValue(equalsValueSyntax.Value, diagnostics);
			if (!boundExpression.HasErrors)
			{
				if (!TypeSymbolExtensions.IsErrorType(targetType))
				{
					boundExpression = ApplyImplicitConversion(boundExpression.Syntax, targetType, boundExpression, diagnostics);
				}
				constValue = GetExpressionConstantValueIfAny(boundExpression, diagnostics, ConstantContext.ParameterDefaultValue);
				if ((object)constValue == null)
				{
					boundExpression = BadExpression(boundExpression.Syntax, boundExpression, targetType);
				}
			}
			return boundExpression;
		}

		private BoundExpression BindInterpolatedStringExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringExpressionSyntax syntax, BindingDiagnosticBag diagnostics)
		{
			ArrayBuilder<BoundNode> instance = ArrayBuilder<BoundNode>.GetInstance();
			SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringContentSyntax>.Enumerator enumerator = syntax.Contents.GetEnumerator();
			while (enumerator.MoveNext())
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringContentSyntax current = enumerator.Current;
				switch (current.Kind())
				{
				case SyntaxKind.InterpolatedStringText:
					instance.Add(BindInterpolatedStringText((Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringTextSyntax)current, diagnostics));
					break;
				case SyntaxKind.Interpolation:
					instance.Add(BindInterpolation((Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationSyntax)current, diagnostics));
					break;
				default:
					throw ExceptionUtilities.Unreachable;
				}
			}
			return new BoundInterpolatedStringExpression(syntax, instance.ToImmutableAndFree(), this, GetSpecialType(SpecialType.System_String, syntax, diagnostics));
		}

		private BoundLiteral BindInterpolatedStringText(Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringTextSyntax syntax, BindingDiagnosticBag diagnostics)
		{
			return CreateStringLiteral(syntax, syntax.TextToken.ValueText, compilerGenerated: false, diagnostics);
		}

		private BoundInterpolation BindInterpolation(Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationSyntax syntax, BindingDiagnosticBag diagnostics)
		{
			BoundExpression expression = BindRValue(syntax.Expression, diagnostics);
			BoundExpression boundExpression = null;
			if (syntax.AlignmentClause != null)
			{
				boundExpression = BindRValue(syntax.AlignmentClause.Value, diagnostics);
				if (boundExpression.IsConstant && boundExpression.ConstantValueOpt.IsIntegral)
				{
					ConstantValue constantValueOpt = boundExpression.ConstantValueOpt;
					if (constantValueOpt.IsNegativeNumeric)
					{
						if (constantValueOpt.Int64Value < -32767)
						{
							ReportDiagnostic(diagnostics, syntax.AlignmentClause.Value, ERRID.ERR_InterpolationAlignmentOutOfRange);
						}
					}
					else if (decimal.Compare(new decimal(constantValueOpt.UInt64Value), new decimal(32767L)) > 0)
					{
						ReportDiagnostic(diagnostics, syntax.AlignmentClause.Value, ERRID.ERR_InterpolationAlignmentOutOfRange);
					}
				}
				else
				{
					ReportDiagnostic(diagnostics, syntax.AlignmentClause.Value, ERRID.ERR_ExpectedIntLiteral);
				}
			}
			BoundLiteral formatStringOpt = ((syntax.FormatClause != null) ? CreateStringLiteral(syntax.FormatClause, syntax.FormatClause.FormatStringToken.ValueText, compilerGenerated: false, diagnostics) : null);
			return new BoundInterpolation(syntax, expression, boundExpression, formatStringOpt);
		}

		private BoundMethodGroup CreateBoundMethodGroup(SyntaxNode node, LookupResult lookupResult, LookupOptions lookupOptionsUsed, bool withDependencies, BoundExpression receiver, BoundTypeArguments typeArgumentsOpt, QualificationKind qualKind, bool hasError = false)
		{
			ExtensionMethodGroup pendingExtensionMethodsOpt = null;
			if (lookupResult.IsGood && !SymbolExtensions.IsReducedExtensionMethod(lookupResult.Symbols[0]))
			{
				pendingExtensionMethodsOpt = new ExtensionMethodGroup(this, lookupOptionsUsed, withDependencies);
			}
			return new BoundMethodGroup(node, typeArgumentsOpt, lookupResult.Symbols.ToDowncastedImmutable<MethodSymbol>(), pendingExtensionMethodsOpt, lookupResult.Kind, receiver, qualKind, hasError);
		}

		private bool IsConstructorCallAllowed(Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax invocationExpression, BoundMethodOrPropertyGroup boundMemberGroup)
		{
			if (ContainingMember.Kind == SymbolKind.Method && ((MethodSymbol)ContainingMember).MethodKind == MethodKind.Constructor)
			{
				VisualBasicSyntaxNode parent = invocationExpression.Parent;
				if (parent == null || (parent.Kind() != SyntaxKind.CallStatement && parent.Kind() != SyntaxKind.ExpressionStatement))
				{
					return false;
				}
				VisualBasicSyntaxNode parent2 = parent.Parent;
				if (parent2 == null || parent2.Kind() != SyntaxKind.ConstructorBlock)
				{
					return false;
				}
				if (((Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstructorBlockSyntax)parent2).Statements[0] == parent)
				{
					BoundExpression receiverOpt = boundMemberGroup.ReceiverOpt;
					if (receiverOpt != null && (receiverOpt.Kind == BoundKind.MeReference || receiverOpt.Kind == BoundKind.MyBaseReference || receiverOpt.Kind == BoundKind.MyClassReference))
					{
						return true;
					}
				}
			}
			return false;
		}

		private BoundExpression BindDirectConstructorCall(Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax node, BoundMethodGroup group, BindingDiagnosticBag diagnostics)
		{
			ImmutableArray<BoundExpression> boundArguments = default(ImmutableArray<BoundExpression>);
			ImmutableArray<string> argumentNames = default(ImmutableArray<string>);
			ImmutableArray<Location> argumentNamesLocations = default(ImmutableArray<Location>);
			Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax argumentList = node.ArgumentList;
			if (IsConstructorCallAllowed(node, group))
			{
				new ConstructorCallArgumentsBinder(this).BindArgumentsAndNames(argumentList, ref boundArguments, ref argumentNames, ref argumentNamesLocations, diagnostics);
				return BindInvocationExpression(node, node.Expression, ExtractTypeCharacter(node.Expression), group, boundArguments, argumentNames, diagnostics, group.Syntax, allowConstructorCall: true);
			}
			if (!group.HasErrors)
			{
				ReportDiagnostic(diagnostics, group.Syntax, ERRID.ERR_InvalidConstructorCall);
			}
			BindArgumentsAndNames(argumentList, ref boundArguments, ref argumentNames, ref argumentNamesLocations, diagnostics);
			BoundExpression boundExpression = BindInvocationExpression(node, node.Expression, ExtractTypeCharacter(node.Expression), group, boundArguments, argumentNames, BindingDiagnosticBag.Discarded, group.Syntax, allowConstructorCall: true);
			if (boundExpression.Kind == BoundKind.Call)
			{
				BoundCall boundCall = (BoundCall)boundExpression;
				boundExpression = new BoundCall(boundCall.Syntax, boundCall.Method, boundCall.MethodGroupOpt, boundCall.ReceiverOpt, boundCall.Arguments, boundCall.DefaultArguments, boundCall.ConstantValueOpt, isLValue: false, suppressObjectClone: false, boundCall.Type, hasErrors: true);
			}
			return boundExpression;
		}

		private BoundExpression BindInvocationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			BoundExpression boundExpression;
			if (node.Expression == null)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax correspondingConditionalAccessExpression = SyntaxNodeExtensions.GetCorrespondingConditionalAccessExpression(node);
				boundExpression = ((correspondingConditionalAccessExpression == null) ? BoundNodeExtensions.MakeCompilerGenerated(ReportDiagnosticAndProduceBadExpression(diagnostics, node, ERRID.ERR_Syntax)) : GetConditionalAccessReceiver(correspondingConditionalAccessExpression));
			}
			else
			{
				boundExpression = BindExpression(node.Expression, isInvocationOrAddressOf: true, isOperandOfConditionalBranch: false, eventContext: false, diagnostics);
			}
			if (boundExpression.Kind == BoundKind.MethodGroup)
			{
				BoundMethodGroup group = (BoundMethodGroup)boundExpression;
				if (IsGroupOfConstructors(group))
				{
					return BindDirectConstructorCall(node, group, diagnostics);
				}
			}
			ImmutableArray<BoundExpression> boundArguments = default(ImmutableArray<BoundExpression>);
			ImmutableArray<string> argumentNames = default(ImmutableArray<string>);
			ImmutableArray<Location> argumentNamesLocations = default(ImmutableArray<Location>);
			BindArgumentsAndNames(node.ArgumentList, ref boundArguments, ref argumentNames, ref argumentNamesLocations, diagnostics);
			if (boundExpression.Kind == BoundKind.MethodGroup || boundExpression.Kind == BoundKind.PropertyGroup)
			{
				return BindInvocationExpressionPossiblyWithoutArguments(node, ExtractTypeCharacter(node.Expression), (BoundMethodOrPropertyGroup)boundExpression, boundArguments, argumentNames, argumentNamesLocations, allowBindingWithoutArguments: true, diagnostics);
			}
			if (boundExpression.Kind == BoundKind.NamespaceExpression)
			{
				BoundNamespaceExpression boundNamespaceExpression = (BoundNamespaceExpression)boundExpression;
				DiagnosticInfo info = ErrorFactory.ErrorInfo(ERRID.ERR_NamespaceNotExpression1, boundNamespaceExpression.NamespaceSymbol);
				ReportDiagnostic(diagnostics, node.Expression, info);
			}
			else
			{
				if (boundExpression.Kind != BoundKind.TypeExpression)
				{
					BoundExpression target = boundExpression;
					ImmutableArray<BoundExpression> boundArguments2 = boundArguments;
					ImmutableArray<string> argumentNames2 = argumentNames;
					ImmutableArray<Location> argumentNamesLocations2 = argumentNamesLocations;
					bool hasIndexableTarget = false;
					return BindIndexedInvocationExpression(node, target, boundArguments2, argumentNames2, argumentNamesLocations2, allowBindingWithoutArguments: true, out hasIndexableTarget, diagnostics);
				}
				BoundTypeExpression boundTypeExpression = (BoundTypeExpression)boundExpression;
				if (!IsCallStatementContext(node))
				{
					BoundExpression boundExpression2 = TryDefaultInstanceProperty(boundTypeExpression, diagnostics);
					if (boundExpression2 != null)
					{
						ImmutableArray<BoundExpression> boundArguments3 = boundArguments;
						ImmutableArray<string> argumentNames3 = argumentNames;
						ImmutableArray<Location> argumentNamesLocations3 = argumentNamesLocations;
						bool hasIndexableTarget = false;
						return BindIndexedInvocationExpression(node, boundExpression2, boundArguments3, argumentNames3, argumentNamesLocations3, allowBindingWithoutArguments: false, out hasIndexableTarget, diagnostics);
					}
				}
				DiagnosticInfo info2 = ErrorFactory.ErrorInfo(GetTypeNotExpressionErrorId(boundTypeExpression.Type), boundTypeExpression.Type);
				ReportDiagnostic(diagnostics, node.Expression, info2);
			}
			return GenerateBadExpression(node, boundExpression, boundArguments);
		}

		private BoundExpression BindIndexedInvocationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax node, BoundExpression target, ImmutableArray<BoundExpression> boundArguments, ImmutableArray<string> argumentNames, ImmutableArray<Location> argumentNamesLocations, bool allowBindingWithoutArguments, out bool hasIndexableTarget, BindingDiagnosticBag diagnostics)
		{
			hasIndexableTarget = false;
			if (!target.IsLValue && target.Kind != BoundKind.LateMemberAccess)
			{
				target = MakeRValue(target, diagnostics);
			}
			TypeSymbol type = target.Type;
			if ((object)type != null)
			{
				if (TypeSymbolExtensions.IsArrayType(type))
				{
					hasIndexableTarget = true;
					if (!IsCallStatementContext(node))
					{
						return BindArrayAccess(node, target, boundArguments, argumentNames, diagnostics);
					}
				}
				else if (type.Kind == SymbolKind.NamedType && type.TypeKind == TypeKind.Delegate)
				{
					hasIndexableTarget = true;
					MethodSymbol methodSymbol = ((NamedTypeSymbol)type).DelegateInvokeMethod;
					if ((object)methodSymbol == null)
					{
						if (!target.HasErrors)
						{
							ReportDiagnostic(diagnostics, target.Syntax, ERRID.ERR_DelegateNoInvoke1, target.Type);
						}
					}
					else if (ReportDelegateInvokeUseSite(diagnostics, target.Syntax, type, methodSymbol))
					{
						methodSymbol = null;
					}
					if ((object)methodSymbol != null)
					{
						BoundMethodGroup group = BoundNodeExtensions.MakeCompilerGenerated(new BoundMethodGroup(node.Expression ?? node, null, ImmutableArray.Create(methodSymbol), LookupResultKind.Good, target, QualificationKind.QualifiedViaValue));
						return BindInvocationExpression(node, node.Expression ?? node, ExtractTypeCharacter(node.Expression), group, boundArguments, argumentNames, diagnostics, node, allowConstructorCall: false, suppressAbstractCallDiagnostics: false, isDefaultMemberAccess: false, type);
					}
					ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
					instance.Add(target);
					instance.AddRange(boundArguments);
					return BadExpression(node, instance.ToImmutableAndFree(), ErrorTypeSymbol.UnknownResultType);
				}
			}
			if (target.Kind != BoundKind.BadExpression)
			{
				if (!IsCallStatementContext(node))
				{
					if (target.Type.SpecialType == SpecialType.System_Object || target.Type.SpecialType == SpecialType.System_Array)
					{
						hasIndexableTarget = true;
						return BindLateBoundInvocation(node, null, target, boundArguments, argumentNames, diagnostics, target.Kind == BoundKind.LateMemberAccess);
					}
					if (!target.HasErrors)
					{
						BoundExpression boundExpression = BindDefaultPropertyGroup(node.Expression ?? node, target, diagnostics);
						if (boundExpression != null)
						{
							hasIndexableTarget = true;
							if (boundExpression.Kind == BoundKind.PropertyGroup || boundExpression.Kind == BoundKind.MethodGroup)
							{
								return BindInvocationExpressionPossiblyWithoutArguments(node, TypeCharacter.None, (BoundMethodOrPropertyGroup)boundExpression, boundArguments, argumentNames, argumentNamesLocations, allowBindingWithoutArguments, diagnostics);
							}
						}
						else
						{
							ReportNoDefaultProperty(target, diagnostics);
						}
					}
				}
				else
				{
					if (target.Kind == BoundKind.LateMemberAccess)
					{
						hasIndexableTarget = true;
						BoundLateMemberAccess receiver = (BoundLateMemberAccess)target;
						return BindLateBoundInvocation(node, null, receiver, boundArguments, argumentNames, diagnostics);
					}
					if (!target.HasErrors)
					{
						DiagnosticInfo info = ErrorFactory.ErrorInfo(ERRID.ERR_ExpectedProcedure);
						ReportDiagnostic(diagnostics, node.Expression ?? node, info);
					}
				}
			}
			return GenerateBadExpression(node, target, boundArguments);
		}

		private BoundExpression BindInvocationExpressionPossiblyWithoutArguments(Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax node, TypeCharacter typeChar, BoundMethodOrPropertyGroup group, ImmutableArray<BoundExpression> boundArguments, ImmutableArray<string> argumentNames, ImmutableArray<Location> argumentNamesLocations, bool allowBindingWithoutArguments, BindingDiagnosticBag diagnostics)
		{
			if (allowBindingWithoutArguments && boundArguments.Length > 0 && !IsCallStatementContext(node) && ShouldBindWithoutArguments(node, ref group, diagnostics))
			{
				BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(diagnostics);
				BoundExpression boundExpression = null;
				BoundExpression boundExpression2 = BindInvocationExpression(node.Expression, node.Expression, typeChar, group, ImmutableArray<BoundExpression>.Empty, default(ImmutableArray<string>), instance, group.Syntax);
				if (boundExpression2.Kind == BoundKind.Call || boundExpression2.Kind == BoundKind.PropertyAccess)
				{
					diagnostics.AddRange(instance);
					instance.Clear();
					if (boundExpression2.Kind == BoundKind.PropertyAccess)
					{
						BoundExpression receiverOpt = ((BoundPropertyAccess)boundExpression2).ReceiverOpt;
						if (receiverOpt?.Syntax == boundExpression2.Syntax && !receiverOpt.WasCompilerGenerated)
						{
							BoundNodeExtensions.MakeCompilerGenerated(boundExpression2);
						}
						boundExpression2 = MakeRValue(boundExpression2, diagnostics);
					}
					else
					{
						BoundExpression receiverOpt2 = ((BoundCall)boundExpression2).ReceiverOpt;
						if (receiverOpt2?.Syntax == boundExpression2.Syntax && !receiverOpt2.WasCompilerGenerated)
						{
							BoundNodeExtensions.MakeCompilerGenerated(boundExpression2);
						}
					}
					if (boundExpression2.Kind == BoundKind.BadExpression)
					{
						boundExpression = GenerateBadExpression(node, boundExpression2, boundArguments);
					}
					else
					{
						bool hasIndexableTarget = false;
						BoundExpression boundExpression3 = BindIndexedInvocationExpression(node, boundExpression2, boundArguments, argumentNames, argumentNamesLocations, allowBindingWithoutArguments: false, out hasIndexableTarget, instance);
						if (hasIndexableTarget)
						{
							diagnostics.AddRange(instance);
							boundExpression = boundExpression3;
						}
						else
						{
							ReportDiagnostic(diagnostics, node.Expression, ERRID.ERR_FunctionResultCannotBeIndexed1, boundExpression2.ExpressionSymbol);
							boundExpression = BindInvocationExpression(node, node.Expression, typeChar, group, boundArguments, argumentNames, BindingDiagnosticBag.Discarded, group.Syntax);
						}
					}
				}
				instance.Free();
				if (boundExpression != null)
				{
					return boundExpression;
				}
			}
			return BindInvocationExpression(node, node.Expression ?? group.Syntax, typeChar, group, boundArguments, argumentNames, diagnostics, group.Syntax);
		}

		private BoundExpression BindDefaultPropertyGroup(VisualBasicSyntaxNode node, BoundExpression target, BindingDiagnosticBag diagnostics)
		{
			LookupResult instance = LookupResult.GetInstance();
			BoundExpression boundExpression = null;
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
			MemberLookup.LookupDefaultProperty(instance, target.Type, this, ref useSiteInfo);
			if (instance.HasSymbol)
			{
				boundExpression = BindSymbolAccess(node, instance, LookupOptions.Default, target, null, QualificationKind.QualifiedViaValue, diagnostics);
			}
			else
			{
				BindingDiagnosticBag instance2 = BindingDiagnosticBag.GetInstance(diagnostics);
				target = MakeRValue(target, instance2);
				TypeSymbol controlVariableType = null;
				target = ConvertToQueryableType(target, instance2, out controlVariableType);
				if ((object)controlVariableType != null)
				{
					instance.Clear();
					LookupMember(instance, target.Type, "ElementAtOrDefault", 0, LookupOptions.AllMethodsOfAnyArity, ref useSiteInfo);
					if (instance.IsGood)
					{
						SymbolKind kind = instance.Symbols[0].Kind;
						if (kind == SymbolKind.Method || kind == SymbolKind.Property)
						{
							diagnostics.AddRange(instance2);
							boundExpression = BindSymbolAccess(node, instance, LookupOptions.AllMethodsOfAnyArity, target, null, QualificationKind.QualifiedViaValue, diagnostics);
						}
					}
				}
				instance2.Free();
			}
			((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)node, useSiteInfo);
			instance.Free();
			boundExpression?.SetWasCompilerGenerated();
			return boundExpression;
		}

		private bool ShouldBindWithoutArguments(VisualBasicSyntaxNode node, ref BoundMethodOrPropertyGroup group, BindingDiagnosticBag diagnostics)
		{
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
			bool result = ShouldBindWithoutArguments(ref group, ref useSiteInfo);
			((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)node, useSiteInfo);
			return result;
		}

		private bool ShouldBindWithoutArguments(ref BoundMethodOrPropertyGroup group, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			if (group.Kind == BoundKind.MethodGroup)
			{
				ArrayBuilder<MethodSymbol> instance = ArrayBuilder<MethodSymbol>.GetInstance();
				BoundMethodGroup boundMethodGroup = (BoundMethodGroup)group;
				bool flag = false;
				bool flag2 = false;
				MethodSymbol methodSymbol = null;
				ImmutableArray<MethodSymbol>.Enumerator enumerator = boundMethodGroup.Methods.GetEnumerator();
				while (enumerator.MoveNext())
				{
					MethodSymbol current = enumerator.Current;
					if (current.IsReducedExtensionMethod)
					{
						methodSymbol = current;
						break;
					}
					if (current.IsSub)
					{
						if (MethodSymbolExtensions.CanBeCalledWithNoParameters(current))
						{
							instance.Add(current);
						}
						else
						{
							flag = true;
						}
						continue;
					}
					if (current.ParameterCount > 0)
					{
						instance.Free();
						return false;
					}
					instance.Add(current);
					flag2 = true;
				}
				if ((object)methodSymbol == null)
				{
					if (boundMethodGroup.AdditionalExtensionMethods(ref useSiteInfo).Length > 0)
					{
						instance.Free();
						return false;
					}
					if (!flag2)
					{
						instance.Free();
						return false;
					}
					if (flag)
					{
						if (instance.IsEmpty())
						{
							instance.Free();
							return false;
						}
						group = boundMethodGroup.Update(boundMethodGroup.TypeArgumentsOpt, instance.ToImmutable(), null, boundMethodGroup.ResultKind, boundMethodGroup.ReceiverOpt, boundMethodGroup.QualificationKind);
					}
					instance.Free();
					return true;
				}
				instance.Free();
				return boundMethodGroup.Methods.Length == 1 && boundMethodGroup.TypeArgumentsOpt == null && methodSymbol.ParameterCount == 0 && methodSymbol.Arity == 0 && !methodSymbol.IsSub && boundMethodGroup.AdditionalExtensionMethods(ref useSiteInfo).Length == 0;
			}
			ImmutableArray<PropertySymbol>.Enumerator enumerator2 = ((BoundPropertyGroup)group).Properties.GetEnumerator();
			while (enumerator2.MoveNext())
			{
				if (enumerator2.Current.ParameterCount > 0)
				{
					return false;
				}
			}
			return true;
		}

		private static bool IsGroupOfConstructors(BoundMethodOrPropertyGroup group)
		{
			if (group.Kind == BoundKind.MethodGroup)
			{
				return ((BoundMethodGroup)group).Methods[0].MethodKind == MethodKind.Constructor;
			}
			return false;
		}

		internal BoundExpression BindInvocationExpression(SyntaxNode node, SyntaxNode target, TypeCharacter typeChar, BoundMethodOrPropertyGroup group, ImmutableArray<BoundExpression> boundArguments, ImmutableArray<string> argumentNames, BindingDiagnosticBag diagnostics, SyntaxNode callerInfoOpt, bool allowConstructorCall = false, bool suppressAbstractCallDiagnostics = false, bool isDefaultMemberAccess = false, Symbol representCandidateInDiagnosticsOpt = null, bool forceExpandedForm = false)
		{
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
			OverloadResolution.OverloadResolutionResult results = OverloadResolution.MethodOrPropertyInvocationOverloadResolution(group, boundArguments, argumentNames, this, callerInfoOpt, ref useSiteInfo, includeEliminatedCandidates: false, forceExpandedForm);
			if (((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(node, useSiteInfo) && group.ResultKind != LookupResultKind.Inaccessible)
			{
				diagnostics = BindingDiagnosticBag.Discarded;
			}
			if (!results.BestResult.HasValue)
			{
				if (results.ResolutionIsLateBound)
				{
					if (group.Kind == BoundKind.MethodGroup)
					{
						bool flag = false;
						BoundMethodGroup boundMethodGroup = (BoundMethodGroup)group;
						ImmutableArray<MethodSymbol>.Enumerator enumerator = boundMethodGroup.Methods.GetEnumerator();
						while (enumerator.MoveNext())
						{
							if ((object)enumerator.Current.ReducedFrom != null)
							{
								flag = true;
								break;
							}
						}
						if (!flag)
						{
							useSiteInfo = new CompoundUseSiteInfo<AssemblySymbol>(useSiteInfo);
							flag = !boundMethodGroup.AdditionalExtensionMethods(ref useSiteInfo).IsEmpty;
							((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(node, useSiteInfo);
						}
						if (flag)
						{
							ReportDiagnostic(diagnostics, GetLocationForOverloadResolutionDiagnostic(node, group), ERRID.ERR_ExtensionMethodCannotBeLateBound);
							ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
							instance.Add(group);
							if (!boundArguments.IsEmpty)
							{
								instance.AddRange(boundArguments);
							}
							return new BoundBadExpression(node, LookupResultKind.OverloadResolutionFailure, ImmutableArray<Symbol>.Empty, instance.ToImmutableAndFree(), ErrorTypeSymbol.UnknownResultType, hasErrors: true);
						}
					}
					return BindLateBoundInvocation(node, group, isDefaultMemberAccess, boundArguments, argumentNames, diagnostics);
				}
				if (results.Candidates.Length == 0)
				{
					ImmutableArray<BoundExpression> arguments = boundArguments;
					CompoundUseSiteInfo<AssemblySymbol> useSiteInfo2 = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
					results = OverloadResolution.MethodOrPropertyInvocationOverloadResolution(group, arguments, argumentNames, this, callerInfoOpt, ref useSiteInfo2, includeEliminatedCandidates: true, forceExpandedForm);
				}
				return ReportOverloadResolutionFailureAndProduceBoundNode(node, group, boundArguments, argumentNames, ref results, diagnostics, callerInfoOpt, null, queryMode: false, null, representCandidateInDiagnosticsOpt);
			}
			return CreateBoundCallOrPropertyAccess(node, target, typeChar, group, boundArguments, results.BestResult.Value, results.AsyncLambdaSubToFunctionMismatch, diagnostics, suppressAbstractCallDiagnostics);
		}

		private BoundExpression CreateBoundCallOrPropertyAccess(SyntaxNode node, SyntaxNode target, TypeCharacter typeChar, BoundMethodOrPropertyGroup group, ImmutableArray<BoundExpression> boundArguments, OverloadResolution.CandidateAnalysisResult bestResult, ImmutableArray<BoundExpression> asyncLambdaSubToFunctionMismatch, BindingDiagnosticBag diagnostics, bool suppressAbstractCallDiagnostics = false)
		{
			OverloadResolution.Candidate candidate = bestResult.Candidate;
			Symbol underlyingSymbol = candidate.UnderlyingSymbol;
			TypeSymbol returnType = candidate.ReturnType;
			if (group.ResultKind == LookupResultKind.Inaccessible)
			{
				ReportDiagnostic(diagnostics, target, GetInaccessibleErrorInfo(bestResult.Candidate.UnderlyingSymbol));
			}
			else
			{
				CheckMemberTypeAccessibility(diagnostics, node, underlyingSymbol);
			}
			if (bestResult.TypeArgumentInferenceDiagnosticsOpt != null)
			{
				diagnostics.AddRange(bestResult.TypeArgumentInferenceDiagnosticsOpt);
			}
			(ImmutableArray<BoundExpression>, BitVector) tuple = PassArguments(node, ref bestResult, boundArguments, diagnostics);
			boundArguments = tuple.Item1;
			bool flag = false;
			BoundExpression receiver = group.ReceiverOpt;
			if (group.ResultKind == LookupResultKind.Good)
			{
				flag = CheckSharedSymbolAccess(target, underlyingSymbol.IsShared, ref receiver, group.QualificationKind, diagnostics);
			}
			ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagnostics, underlyingSymbol, node);
			flag |= group.HasErrors;
			if (!TypeSymbolExtensions.IsErrorType(returnType))
			{
				VerifyTypeCharacterConsistency(node, returnType, typeChar, diagnostics);
			}
			BoundExpression resolvedTypeOrValueExpression = null;
			if (receiver != null && !flag)
			{
				receiver = AdjustReceiverTypeOrValue(receiver, receiver.Syntax, underlyingSymbol.IsShared, diagnostics, ref resolvedTypeOrValueExpression);
			}
			if (!suppressAbstractCallDiagnostics && receiver != null && (BoundExpressionExtensions.IsMyBaseReference(receiver) || BoundExpressionExtensions.IsMyClassReference(receiver)) && underlyingSymbol.IsMustOverride)
			{
				ReportDiagnostic(diagnostics, group.Syntax, BoundExpressionExtensions.IsMyBaseReference(receiver) ? ERRID.ERR_MyBaseAbstractCall1 : ERRID.ERR_MyClassAbstractCall1, underlyingSymbol);
			}
			if (!asyncLambdaSubToFunctionMismatch.IsEmpty)
			{
				ImmutableArray<BoundExpression>.Enumerator enumerator = asyncLambdaSubToFunctionMismatch.GetEnumerator();
				while (enumerator.MoveNext())
				{
					SyntaxNode syntaxNode = enumerator.Current.Syntax;
					if (syntaxNode is Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaExpressionSyntax lambdaExpressionSyntax)
					{
						syntaxNode = lambdaExpressionSyntax.SubOrFunctionHeader;
					}
					ReportDiagnostic(diagnostics, syntaxNode, ERRID.WRN_AsyncSubCouldBeFunction);
				}
			}
			if (underlyingSymbol.Kind == SymbolKind.Method)
			{
				MethodSymbol methodSymbol = (MethodSymbol)underlyingSymbol;
				MethodSymbol reducedFrom = methodSymbol.ReducedFrom;
				ConstantValue constantValueOpt = null;
				if ((object)reducedFrom == null)
				{
					if (receiver != null && BoundExpressionExtensions.IsPropertyOrXmlPropertyAccess(receiver))
					{
						receiver = MakeRValue(receiver, diagnostics);
					}
					if (MethodSymbolExtensions.IsUserDefinedOperator(methodSymbol) && (object)ContainingMember == methodSymbol)
					{
						ReportDiagnostic(diagnostics, target, ERRID.WRN_RecursiveOperatorCall, methodSymbol);
					}
					constantValueOpt = OptimizeLibraryCall(methodSymbol, boundArguments, node, ref flag, diagnostics);
				}
				else
				{
					receiver = UpdateReceiverForExtensionMethodOrPropertyGroup(receiver, methodSymbol.ReceiverType, reducedFrom.Parameters[0], diagnostics);
				}
				BoundMethodGroup boundMethodGroup = (BoundMethodGroup)group;
				BoundExpression receiverOpt = ((receiver != null) ? null : (resolvedTypeOrValueExpression ?? boundMethodGroup.ReceiverOpt));
				boundMethodGroup = boundMethodGroup.Update(boundMethodGroup.TypeArgumentsOpt, boundMethodGroup.Methods, boundMethodGroup.PendingExtensionMethodsOpt, boundMethodGroup.ResultKind, receiverOpt, boundMethodGroup.QualificationKind);
				return new BoundCall(node, methodSymbol, boundMethodGroup, receiver, boundArguments, constantValueOpt, returnType, suppressObjectClone: false, flag, tuple.Item2);
			}
			PropertySymbol propertySymbol = (PropertySymbol)underlyingSymbol;
			PropertySymbol reducedFromDefinition = propertySymbol.ReducedFromDefinition;
			if ((object)reducedFromDefinition == null)
			{
				if (receiver != null && BoundExpressionExtensions.IsPropertyOrXmlPropertyAccess(receiver))
				{
					receiver = MakeRValue(receiver, diagnostics);
				}
			}
			else
			{
				receiver = UpdateReceiverForExtensionMethodOrPropertyGroup(receiver, propertySymbol.ReceiverType, reducedFromDefinition.Parameters[0], diagnostics);
			}
			BoundPropertyGroup boundPropertyGroup = (BoundPropertyGroup)group;
			BoundExpression receiverOpt2 = ((receiver != null) ? null : (resolvedTypeOrValueExpression ?? boundPropertyGroup.ReceiverOpt));
			boundPropertyGroup = boundPropertyGroup.Update(boundPropertyGroup.Properties, boundPropertyGroup.ResultKind, receiverOpt2, boundPropertyGroup.QualificationKind);
			return new BoundPropertyAccess(node, propertySymbol, boundPropertyGroup, PropertyAccessKind.Unknown, propertySymbol.IsWritable(receiver, this, isKnownTargetOfObjectMemberInitializer: false), receiver, boundArguments, tuple.Item2, flag);
		}

		internal void WarnOnRecursiveAccess(BoundPropertyAccess propertyAccess, PropertyAccessKind accessKind, BindingDiagnosticBag diagnostics)
		{
			PropertySymbol propertySymbol = propertyAccess.PropertySymbol;
			if ((object)propertySymbol.ReducedFromDefinition != null || propertySymbol.ParameterCount != 0 || (!propertySymbol.IsShared && (propertyAccess.ReceiverOpt == null || propertyAccess.ReceiverOpt.Kind != BoundKind.MeReference)))
			{
				return;
			}
			bool flag = false;
			if ((object)propertySymbol.GetMethod == ContainingMember)
			{
				if ((accessKind & PropertyAccessKind.Get) != 0 && (propertyAccess.AccessKind & PropertyAccessKind.Get) == 0)
				{
					flag = true;
				}
			}
			else if ((object)propertySymbol.SetMethod == ContainingMember && (accessKind & PropertyAccessKind.Set) != 0 && (propertyAccess.AccessKind & PropertyAccessKind.Set) == 0)
			{
				flag = true;
			}
			if (flag)
			{
				ReportDiagnostic(diagnostics, propertyAccess.Syntax, ERRID.WRN_RecursivePropertyCall, propertySymbol);
			}
		}

		internal void WarnOnRecursiveAccess(BoundExpression node, PropertyAccessKind accessKind, BindingDiagnosticBag diagnostics)
		{
			switch (node.Kind)
			{
			case BoundKind.PropertyAccess:
				WarnOnRecursiveAccess((BoundPropertyAccess)node, accessKind, diagnostics);
				break;
			default:
				throw ExceptionUtilities.UnexpectedValue(node.Kind);
			case BoundKind.XmlMemberAccess:
				break;
			}
		}

		private BoundExpression UpdateReceiverForExtensionMethodOrPropertyGroup(BoundExpression receiver, TypeSymbol targetType, ParameterSymbol thisParameterDefinition, BindingDiagnosticBag diagnostics)
		{
			if (receiver != null && BoundExpressionExtensions.IsValue(receiver) && !TypeSymbolExtensions.IsErrorType(targetType) && !TypeSymbolExtensions.IsErrorType(receiver.Type))
			{
				BoundExpression boundExpression = receiver;
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
				receiver = PassArgument(receiver, Conversions.ClassifyConversion(receiver, targetType, this, ref useSiteInfo), forceByValueSemantics: false, Conversions.ClassifyConversion(targetType, receiver.Type, ref useSiteInfo), targetType, thisParameterDefinition, diagnostics);
				diagnostics.Add(receiver, useSiteInfo);
				if (boundExpression.WasCompilerGenerated && receiver != boundExpression)
				{
					BoundKind kind = boundExpression.Kind;
					if (kind - 3 <= BoundKind.OmittedArgument || kind == BoundKind.MeReference)
					{
						receiver.SetWasCompilerGenerated();
					}
				}
			}
			return receiver;
		}

		private bool IsWellKnownTypeMember(WellKnownMember memberId, MethodSymbol method)
		{
			return (object)Compilation.GetWellKnownTypeMember(memberId) == method;
		}

		private ConstantValue OptimizeLibraryCall(MethodSymbol method, ImmutableArray<BoundExpression> arguments, SyntaxNode syntax, ref bool hasErrors, BindingDiagnosticBag diagnostics)
		{
			if (arguments.Length == 1 && arguments[0].IsConstant && !arguments[0].ConstantValueOpt.IsBad)
			{
				if ((object)Compilation.GetWellKnownType(WellKnownType.Microsoft_VisualBasic_Strings) != method.ContainingType)
				{
					return null;
				}
				if (IsWellKnownTypeMember(WellKnownMember.Microsoft_VisualBasic_Strings__AscWCharInt32, method) || IsWellKnownTypeMember(WellKnownMember.Microsoft_VisualBasic_Strings__AscWStringInt32, method))
				{
					ConstantValue constantValueOpt = arguments[0].ConstantValueOpt;
					string text = (constantValueOpt.IsNull ? string.Empty : ((!constantValueOpt.IsChar) ? constantValueOpt.StringValue : Microsoft.VisualBasic.CompilerServices.Conversions.ToString(constantValueOpt.CharValue)));
					if (text.IsEmpty())
					{
						ReportDiagnostic(diagnostics, syntax, ERRID.ERR_CannotConvertValue2, text, method.ReturnType);
						hasErrors = true;
						return null;
					}
					return ConstantValue.Create(Strings.AscW(text));
				}
				if (IsWellKnownTypeMember(WellKnownMember.Microsoft_VisualBasic_Strings__ChrWInt32Char, method))
				{
					int int32Value = arguments[0].ConstantValueOpt.Int32Value;
					if (int32Value < -32768 || int32Value > 65535)
					{
						ReportDiagnostic(diagnostics, syntax, ERRID.ERR_CannotConvertValue2, int32Value, method.ReturnType);
						hasErrors = true;
						return null;
					}
					return ConstantValue.Create(Strings.ChrW(int32Value));
				}
				if (IsWellKnownTypeMember(WellKnownMember.Microsoft_VisualBasic_Strings__AscCharInt32, method) || IsWellKnownTypeMember(WellKnownMember.Microsoft_VisualBasic_Strings__AscStringInt32, method))
				{
					ConstantValue constantValueOpt2 = arguments[0].ConstantValueOpt;
					string text2 = (constantValueOpt2.IsNull ? string.Empty : ((!constantValueOpt2.IsChar) ? constantValueOpt2.StringValue : Microsoft.VisualBasic.CompilerServices.Conversions.ToString(constantValueOpt2.CharValue)));
					if (text2.IsEmpty())
					{
						ReportDiagnostic(diagnostics, syntax, ERRID.ERR_CannotConvertValue2, text2, method.ReturnType);
						hasErrors = true;
						return null;
					}
					int num = Strings.AscW(text2);
					if (num < 128)
					{
						return ConstantValue.Create(num);
					}
					return null;
				}
				if (IsWellKnownTypeMember(WellKnownMember.Microsoft_VisualBasic_Strings__ChrInt32Char, method))
				{
					int int32Value2 = arguments[0].ConstantValueOpt.Int32Value;
					if (int32Value2 >= 0 && int32Value2 < 128)
					{
						return ConstantValue.Create(Strings.ChrW(int32Value2));
					}
					if (int32Value2 < -32768 || int32Value2 > 65535)
					{
						ReportDiagnostic(diagnostics, syntax, ERRID.ERR_CannotConvertValue2, int32Value2, method.ReturnType);
						hasErrors = true;
						return null;
					}
				}
			}
			return null;
		}

		private BoundExpression ReportOverloadResolutionFailureAndProduceBoundNode(SyntaxNode node, BoundMethodOrPropertyGroup group, ImmutableArray<BoundExpression> boundArguments, ImmutableArray<string> argumentNames, [In] ref OverloadResolution.OverloadResolutionResult results, BindingDiagnosticBag diagnostics, SyntaxNode callerInfoOpt, TypeSymbol overrideCommonReturnType = null, bool queryMode = false, BoundTypeExpression boundTypeExpression = null, Symbol representCandidateInDiagnosticsOpt = null, Location diagnosticLocationOpt = null)
		{
			return ReportOverloadResolutionFailureAndProduceBoundNode(node, group.ResultKind, boundArguments, argumentNames, ref results, diagnostics, callerInfoOpt, group, overrideCommonReturnType, queryMode, boundTypeExpression, representCandidateInDiagnosticsOpt, diagnosticLocationOpt);
		}

		private BoundExpression ReportOverloadResolutionFailureAndProduceBoundNode(SyntaxNode node, LookupResultKind lookupResult, ImmutableArray<BoundExpression> boundArguments, ImmutableArray<string> argumentNames, [In] ref OverloadResolution.OverloadResolutionResult results, BindingDiagnosticBag diagnostics, SyntaxNode callerInfoOpt, BoundMethodOrPropertyGroup groupOpt = null, TypeSymbol overrideCommonReturnType = null, bool queryMode = false, BoundTypeExpression boundTypeExpression = null, Symbol representCandidateInDiagnosticsOpt = null, Location diagnosticLocationOpt = null)
		{
			ArrayBuilder<OverloadResolution.CandidateAnalysisResult> instance = ArrayBuilder<OverloadResolution.CandidateAnalysisResult>.GetInstance();
			ImmutableArray<Symbol> bestSymbols = ImmutableArray<Symbol>.Empty;
			TypeSymbol commonReturnType = GetSetOfTheBestCandidates(ref results, instance, ref bestSymbols);
			if ((object)overrideCommonReturnType != null)
			{
				commonReturnType = overrideCommonReturnType;
			}
			BoundExpression result = ReportOverloadResolutionFailureAndProduceBoundNode(node, lookupResult, instance, bestSymbols, commonReturnType, boundArguments, argumentNames, diagnostics, callerInfoOpt, groupOpt, null, queryMode, boundTypeExpression, representCandidateInDiagnosticsOpt, diagnosticLocationOpt);
			instance.Free();
			return result;
		}

		private BoundExpression ReportOverloadResolutionFailureAndProduceBoundNode(SyntaxNode node, BoundMethodOrPropertyGroup group, ArrayBuilder<OverloadResolution.CandidateAnalysisResult> bestCandidates, ImmutableArray<Symbol> bestSymbols, TypeSymbol commonReturnType, ImmutableArray<BoundExpression> boundArguments, ImmutableArray<string> argumentNames, BindingDiagnosticBag diagnostics, SyntaxNode callerInfoOpt, Symbol delegateSymbol = null, bool queryMode = false, BoundTypeExpression boundTypeExpression = null, Symbol representCandidateInDiagnosticsOpt = null)
		{
			return ReportOverloadResolutionFailureAndProduceBoundNode(node, group.ResultKind, bestCandidates, bestSymbols, commonReturnType, boundArguments, argumentNames, diagnostics, callerInfoOpt, group, delegateSymbol, queryMode, boundTypeExpression, representCandidateInDiagnosticsOpt);
		}

		public static Location GetLocationForOverloadResolutionDiagnostic(SyntaxNode node, BoundMethodOrPropertyGroup groupOpt = null)
		{
			SyntaxNode syntaxNode;
			if (groupOpt != null)
			{
				if (node.SyntaxTree != groupOpt.Syntax.SyntaxTree || !node.Span.Contains(groupOpt.Syntax.Span))
				{
					return node.GetLocation();
				}
				syntaxNode = groupOpt.Syntax;
				if (syntaxNode == node && (groupOpt.ReceiverOpt == null || groupOpt.ReceiverOpt.Syntax == syntaxNode))
				{
					return syntaxNode.GetLocation();
				}
			}
			else
			{
				if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(node, SyntaxKind.InvocationExpression))
				{
					return node.GetLocation();
				}
				syntaxNode = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax)node).Expression ?? node;
			}
			switch (VisualBasicExtensions.Kind(syntaxNode))
			{
			case SyntaxKind.QualifiedName:
				return ((Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax)syntaxNode).Right.GetLocation();
			case SyntaxKind.SimpleMemberAccessExpression:
				if (syntaxNode.Parent != null && Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(syntaxNode.Parent, SyntaxKind.AddressOfExpression))
				{
					return syntaxNode.GetLocation();
				}
				return ((Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax)syntaxNode).Name.GetLocation();
			case SyntaxKind.XmlElementAccessExpression:
			case SyntaxKind.XmlDescendantAccessExpression:
			case SyntaxKind.XmlAttributeAccessExpression:
				return ((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax)syntaxNode).Name.GetLocation();
			case SyntaxKind.HandlesClauseItem:
				return ((Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax)syntaxNode).EventMember.GetLocation();
			default:
				return syntaxNode.GetLocation();
			}
		}

		private BoundExpression ReportOverloadResolutionFailureAndProduceBoundNode(SyntaxNode node, LookupResultKind lookupResult, ArrayBuilder<OverloadResolution.CandidateAnalysisResult> bestCandidates, ImmutableArray<Symbol> bestSymbols, TypeSymbol commonReturnType, ImmutableArray<BoundExpression> boundArguments, ImmutableArray<string> argumentNames, BindingDiagnosticBag diagnostics, SyntaxNode callerInfoOpt, BoundMethodOrPropertyGroup groupOpt = null, Symbol delegateSymbol = null, bool queryMode = false, BoundTypeExpression boundTypeExpression = null, Symbol representCandidateInDiagnosticsOpt = null, Location diagnosticLocationOpt = null)
		{
			OverloadResolution.CandidateAnalysisResultState candidateAnalysisResultState = OverloadResolution.CandidateAnalysisResultState.Count;
			if (bestCandidates.Count > 0)
			{
				candidateAnalysisResultState = bestCandidates[0].State;
			}
			if (boundArguments.IsDefault)
			{
				boundArguments = ImmutableArray<BoundExpression>.Empty;
			}
			OverloadResolution.CandidateAnalysisResult candidateAnalysisResult = default(OverloadResolution.CandidateAnalysisResult);
			OverloadResolution.Candidate candidate = null;
			bool allowUnexpandedParamArrayForm = false;
			bool flag = false;
			if (bestSymbols.Length == 1 && bestCandidates.Count < 3)
			{
				candidateAnalysisResult = bestCandidates[0];
				candidate = candidateAnalysisResult.Candidate;
				flag = candidateAnalysisResult.IsExpandedParamArrayForm;
				allowUnexpandedParamArrayForm = !flag;
				if (bestCandidates.Count > 1)
				{
					if (bestCandidates[1].IsExpandedParamArrayForm)
					{
						flag = true;
					}
					else
					{
						allowUnexpandedParamArrayForm = true;
					}
				}
			}
			if (lookupResult == LookupResultKind.Inaccessible)
			{
				if (candidate == null)
				{
					if (!queryMode)
					{
						ReportDiagnostic(diagnostics, (groupOpt != null) ? groupOpt.Syntax : node, ERRID.ERR_NoViableOverloadCandidates1, bestSymbols[0].Name);
					}
					goto IL_0556;
				}
				ReportDiagnostic(diagnostics, (groupOpt != null) ? groupOpt.Syntax : node, GetInaccessibleErrorInfo(candidate.UnderlyingSymbol));
			}
			if ((object)diagnosticLocationOpt == null)
			{
				diagnosticLocationOpt = GetLocationForOverloadResolutionDiagnostic(node, groupOpt);
			}
			switch (candidateAnalysisResultState)
			{
			case OverloadResolution.CandidateAnalysisResultState.HasUnsupportedMetadata:
			case OverloadResolution.CandidateAnalysisResultState.HasUseSiteError:
				if (candidate != null)
				{
					ReportOverloadResolutionFailureForASingleCandidate(node, diagnosticLocationOpt, lookupResult, ref candidateAnalysisResult, boundArguments, argumentNames, allowUnexpandedParamArrayForm, flag, includeMethodNameInErrorMessages: true, reportNarrowingConversions: false, diagnostics, delegateSymbol, queryMode, callerInfoOpt, representCandidateInDiagnosticsOpt);
				}
				else
				{
					ReportOverloadResolutionFailureForASetOfCandidates(node, diagnosticLocationOpt, lookupResult, ERRID.ERR_BadOverloadCandidates2, bestCandidates, boundArguments, argumentNames, diagnostics, delegateSymbol, queryMode, callerInfoOpt);
				}
				break;
			case OverloadResolution.CandidateAnalysisResultState.Ambiguous:
			{
				Symbol originalDefinition = bestSymbols[0].OriginalDefinition;
				Symbol containingSymbol = originalDefinition.ContainingSymbol;
				ReportDiagnostic(diagnostics, diagnosticLocationOpt, ERRID.ERR_MetadataMembersAmbiguous3, originalDefinition.Name, SymbolExtensions.GetKindText(containingSymbol), containingSymbol);
				break;
			}
			case OverloadResolution.CandidateAnalysisResultState.BadGenericArity:
			{
				BoundMethodGroup boundMethodGroup = (BoundMethodGroup)groupOpt;
				if (candidate != null)
				{
					ImmutableArray<TypeSymbol> immutableArray = ((boundMethodGroup.TypeArgumentsOpt != null) ? boundMethodGroup.TypeArgumentsOpt.Arguments : ImmutableArray<TypeSymbol>.Empty);
					if (immutableArray.IsDefault)
					{
						immutableArray = ImmutableArray<TypeSymbol>.Empty;
					}
					Symbol underlyingSymbol = candidate.UnderlyingSymbol;
					bool isExtensionMethod = candidate.IsExtensionMethod;
					if (candidate.Arity < immutableArray.Length)
					{
						if (isExtensionMethod)
						{
							ReportDiagnostic(diagnostics, boundMethodGroup.TypeArgumentsOpt.Syntax, (candidate.Arity == 0) ? ERRID.ERR_TypeOrMemberNotGeneric2 : ERRID.ERR_TooManyGenericArguments2, underlyingSymbol, underlyingSymbol.ContainingType);
						}
						else
						{
							ReportDiagnostic(diagnostics, boundMethodGroup.TypeArgumentsOpt.Syntax, (candidate.Arity == 0) ? ERRID.ERR_TypeOrMemberNotGeneric1 : ERRID.ERR_TooManyGenericArguments1, underlyingSymbol);
						}
					}
					else if (isExtensionMethod)
					{
						ReportDiagnostic(diagnostics, boundMethodGroup.TypeArgumentsOpt.Syntax, ERRID.ERR_TooFewGenericArguments2, underlyingSymbol, underlyingSymbol.ContainingType);
					}
					else
					{
						ReportDiagnostic(diagnostics, boundMethodGroup.TypeArgumentsOpt.Syntax, ERRID.ERR_TooFewGenericArguments1, underlyingSymbol);
					}
				}
				else
				{
					ReportDiagnostic(diagnostics, diagnosticLocationOpt, ERRID.ERR_NoTypeArgumentCountOverloadCand1, CustomSymbolDisplayFormatter.ShortErrorName(bestSymbols[0]));
				}
				break;
			}
			case OverloadResolution.CandidateAnalysisResultState.ArgumentCountMismatch:
				if (VisualBasicExtensions.Kind(node) == SyntaxKind.IdentifierName && node.Parent != null && VisualBasicExtensions.Kind(node.Parent) == SyntaxKind.NamedFieldInitializer && groupOpt != null && groupOpt.Kind == BoundKind.PropertyGroup)
				{
					ReportDiagnostic(diagnostics, diagnosticLocationOpt, (candidate != null) ? ERRID.ERR_ParameterizedPropertyInAggrInit1 : ERRID.ERR_NoZeroCountArgumentInitCandidates1, CustomSymbolDisplayFormatter.ShortErrorName(bestSymbols[0]));
				}
				else if (candidate != null && (!queryMode || candidate.ParameterCount <= boundArguments.Length))
				{
					ReportOverloadResolutionFailureForASingleCandidate(node, diagnosticLocationOpt, lookupResult, ref candidateAnalysisResult, boundArguments, argumentNames, allowUnexpandedParamArrayForm, flag, includeMethodNameInErrorMessages: true, reportNarrowingConversions: false, diagnostics, delegateSymbol, queryMode, callerInfoOpt, representCandidateInDiagnosticsOpt);
				}
				else
				{
					ReportDiagnostic(diagnostics, diagnosticLocationOpt, ERRID.ERR_NoArgumentCountOverloadCandidates1, CustomSymbolDisplayFormatter.ShortErrorName(bestSymbols[0]));
				}
				break;
			case OverloadResolution.CandidateAnalysisResultState.ArgumentMismatch:
			case OverloadResolution.CandidateAnalysisResultState.GenericConstraintsViolated:
			{
				bool flag2 = false;
				int num = boundArguments.Length - 1;
				for (int i = 0; i <= num; i++)
				{
					TypeSymbol type = boundArguments[i].Type;
					if (boundArguments[i].HasErrors || ((object)type != null && TypeSymbolExtensions.IsErrorType(type)))
					{
						flag2 = true;
						break;
					}
				}
				if (!flag2)
				{
					if (candidate != null)
					{
						ReportOverloadResolutionFailureForASingleCandidate(node, diagnosticLocationOpt, lookupResult, ref candidateAnalysisResult, boundArguments, argumentNames, allowUnexpandedParamArrayForm, flag, includeMethodNameInErrorMessages: true, reportNarrowingConversions: false, diagnostics, delegateSymbol, queryMode, callerInfoOpt, representCandidateInDiagnosticsOpt);
					}
					else
					{
						ReportOverloadResolutionFailureForASetOfCandidates(node, diagnosticLocationOpt, lookupResult, ((object)delegateSymbol == null) ? ERRID.ERR_NoCallableOverloadCandidates2 : ERRID.ERR_DelegateBindingFailure3, bestCandidates, boundArguments, argumentNames, diagnostics, delegateSymbol, queryMode, callerInfoOpt);
					}
				}
				break;
			}
			case OverloadResolution.CandidateAnalysisResultState.TypeInferenceFailed:
				if (candidate != null)
				{
					ReportOverloadResolutionFailureForASingleCandidate(node, diagnosticLocationOpt, lookupResult, ref candidateAnalysisResult, boundArguments, argumentNames, allowUnexpandedParamArrayForm, flag, includeMethodNameInErrorMessages: true, reportNarrowingConversions: false, diagnostics, delegateSymbol, queryMode, callerInfoOpt, representCandidateInDiagnosticsOpt);
				}
				else
				{
					ReportOverloadResolutionFailureForASetOfCandidates(node, diagnosticLocationOpt, lookupResult, ERRID.ERR_NoCallableOverloadCandidates2, bestCandidates, boundArguments, argumentNames, diagnostics, delegateSymbol, queryMode, callerInfoOpt);
				}
				break;
			case OverloadResolution.CandidateAnalysisResultState.Applicable:
				if (bestCandidates[0].RequiresNarrowingConversion)
				{
					ReportOverloadResolutionFailureForASetOfCandidates(node, diagnosticLocationOpt, lookupResult, ((object)delegateSymbol == null) ? ERRID.ERR_NoNonNarrowingOverloadCandidates2 : ERRID.ERR_DelegateBindingFailure3, bestCandidates, boundArguments, argumentNames, diagnostics, delegateSymbol, queryMode, callerInfoOpt);
				}
				else
				{
					ReportUnspecificProcedures(diagnosticLocationOpt, bestSymbols, diagnostics, (object)delegateSymbol != null);
				}
				break;
			default:
				throw ExceptionUtilities.UnexpectedValue(candidateAnalysisResultState);
			}
			goto IL_0556;
			IL_0556:
			ImmutableArray<BoundExpression> childBoundNodes;
			if (boundArguments.IsEmpty && boundTypeExpression == null)
			{
				childBoundNodes = ((groupOpt != null) ? ImmutableArray.Create((BoundExpression)groupOpt) : ImmutableArray<BoundExpression>.Empty);
			}
			else
			{
				ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
				if (groupOpt != null)
				{
					instance.Add(groupOpt);
				}
				if (!boundArguments.IsEmpty)
				{
					instance.AddRange(boundArguments);
				}
				if (boundTypeExpression != null)
				{
					instance.Add(boundTypeExpression);
				}
				childBoundNodes = instance.ToImmutableAndFree();
			}
			LookupResultKind lookupResultKind = LookupResultKind.OverloadResolutionFailure;
			if (lookupResult < lookupResultKind)
			{
				lookupResultKind = lookupResult;
			}
			return new BoundBadExpression(node, lookupResultKind, bestSymbols, childBoundNodes, commonReturnType, hasErrors: true);
		}

		private static TypeSymbol GetSetOfTheBestCandidates(ref OverloadResolution.OverloadResolutionResult results, ArrayBuilder<OverloadResolution.CandidateAnalysisResult> bestCandidates, ref ImmutableArray<Symbol> bestSymbols)
		{
			int[] array = new int[15];
			array[0] = 1;
			array[7] = 2;
			array[8] = 2;
			array[6] = 3;
			array[5] = 4;
			array[4] = 5;
			array[3] = 6;
			array[2] = 7;
			array[1] = 8;
			ImmutableArray<OverloadResolution.CandidateAnalysisResult>.Enumerator enumerator = results.Candidates.GetEnumerator();
			while (enumerator.MoveNext())
			{
				OverloadResolution.CandidateAnalysisResult current = enumerator.Current;
				int num = array[(uint)current.State];
				if (num == 0)
				{
					continue;
				}
				if (bestCandidates.Count == 0)
				{
					bestCandidates.Add(current);
					continue;
				}
				int num2 = array[(uint)bestCandidates[0].State];
				if (num == num2)
				{
					bestCandidates.Add(current);
				}
				else if (num < num2)
				{
					bestCandidates.Clear();
					bestCandidates.Add(current);
				}
			}
			ArrayBuilder<Symbol> instance = ArrayBuilder<Symbol>.GetInstance(bestCandidates.Count);
			TypeSymbol typeSymbol = null;
			if (bestCandidates.Count == 1)
			{
				Symbol underlyingSymbol = bestCandidates[0].Candidate.UnderlyingSymbol;
				instance.Add(underlyingSymbol);
				typeSymbol = bestCandidates[0].Candidate.ReturnType;
				if (underlyingSymbol.Kind == SymbolKind.Method)
				{
					MethodSymbol methodSymbol = (MethodSymbol)underlyingSymbol;
					if (methodSymbol.IsGenericMethod && TypeSymbolExtensions.ReferencesMethodsTypeParameter(typeSymbol, methodSymbol))
					{
						int state = (int)bestCandidates[0].State;
						if ((uint)(state - 1) <= 1u || (uint)(state - 4) <= 2u)
						{
							typeSymbol = null;
						}
					}
				}
			}
			else
			{
				int num3 = bestCandidates.Count - 1;
				for (int i = 0; i <= num3; i++)
				{
					if (i == 0 || !instance[instance.Count - 1].Equals(bestCandidates[i].Candidate.UnderlyingSymbol))
					{
						instance.Add(bestCandidates[i].Candidate.UnderlyingSymbol);
						TypeSymbol returnType = bestCandidates[i].Candidate.ReturnType;
						if ((object)typeSymbol == null)
						{
							typeSymbol = returnType;
						}
						else if ((object)typeSymbol != ErrorTypeSymbol.UnknownResultType && !TypeSymbolExtensions.IsSameTypeIgnoringAll(typeSymbol, returnType))
						{
							typeSymbol = ErrorTypeSymbol.UnknownResultType;
						}
					}
				}
			}
			bestSymbols = instance.ToImmutableAndFree();
			return typeSymbol ?? ErrorTypeSymbol.UnknownResultType;
		}

		private static void ReportUnspecificProcedures(Location diagnosticLocation, ImmutableArray<Symbol> bestSymbols, BindingDiagnosticBag diagnostics, bool isDelegateContext)
		{
			ArrayBuilder<DiagnosticInfo> instance = ArrayBuilder<DiagnosticInfo>.GetInstance(bestSymbols.Length);
			DiagnosticInfo diagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_NotMostSpecificOverload);
			bool flag = false;
			if (!SymbolExtensions.IsReducedExtensionMethod(bestSymbols[0]))
			{
				NamedTypeSymbol containingType = bestSymbols[0].ContainingType;
				int num = bestSymbols.Length - 1;
				for (int i = 1; i <= num; i++)
				{
					if (!TypeSymbol.Equals(bestSymbols[i].ContainingType, containingType, TypeCompareKind.ConsiderEverything))
					{
						flag = true;
					}
				}
			}
			int num2 = bestSymbols.Length - 1;
			for (int j = 0; j <= num2; j++)
			{
				Symbol symbol = bestSymbols[j];
				bool flag2 = SymbolExtensions.IsReducedExtensionMethod(symbol);
				if (isDelegateContext)
				{
					if (flag2)
					{
						instance.Add(ErrorFactory.ErrorInfo(ERRID.ERR_ExtensionMethodOverloadCandidate2, symbol, symbol.ContainingType));
					}
					else if (flag)
					{
						instance.Add(ErrorFactory.ErrorInfo(ERRID.ERR_OverloadCandidate1, CustomSymbolDisplayFormatter.WithContainingType(symbol)));
					}
					else
					{
						instance.Add(ErrorFactory.ErrorInfo(ERRID.ERR_OverloadCandidate1, symbol));
					}
				}
				else if (flag2)
				{
					instance.Add(ErrorFactory.ErrorInfo(ERRID.ERR_ExtensionMethodOverloadCandidate3, symbol, symbol.ContainingType, diagnosticInfo));
				}
				else if (flag)
				{
					instance.Add(ErrorFactory.ErrorInfo(ERRID.ERR_OverloadCandidate2, CustomSymbolDisplayFormatter.WithContainingType(symbol), diagnosticInfo));
				}
				else
				{
					instance.Add(ErrorFactory.ErrorInfo(ERRID.ERR_OverloadCandidate2, symbol, diagnosticInfo));
				}
			}
			ReportDiagnostic(diagnostics, diagnosticLocation, ErrorFactory.ErrorInfo(isDelegateContext ? ERRID.ERR_AmbiguousDelegateBinding2 : ERRID.ERR_NoMostSpecificOverload2, CustomSymbolDisplayFormatter.ShortErrorName(bestSymbols[0]), new CompoundDiagnosticInfo(instance.ToArrayAndFree())));
		}

		private void ReportOverloadResolutionFailureForASetOfCandidates(SyntaxNode node, Location diagnosticLocation, LookupResultKind lookupResult, ERRID errorNo, ArrayBuilder<OverloadResolution.CandidateAnalysisResult> candidates, ImmutableArray<BoundExpression> arguments, ImmutableArray<string> argumentNames, BindingDiagnosticBag diagnostics, Symbol delegateSymbol, bool queryMode, SyntaxNode callerInfoOpt)
		{
			ArrayBuilder<KeyValuePair<Symbol, ImmutableBindingDiagnostic<AssemblySymbol>>> instance = ArrayBuilder<KeyValuePair<Symbol, ImmutableBindingDiagnostic<AssemblySymbol>>>.GetInstance(candidates.Count);
			if (arguments.IsDefault)
			{
				arguments = ImmutableArray<BoundExpression>.Empty;
			}
			int num = candidates.Count - 1;
			for (int i = 0; i <= num; i++)
			{
				bool flag = candidates[i].IsExpandedParamArrayForm;
				bool flag2 = !flag;
				if (flag2 && i + 1 < candidates.Count && candidates[i + 1].IsExpandedParamArrayForm && candidates[i + 1].Candidate.UnderlyingSymbol.Equals(candidates[i].Candidate.UnderlyingSymbol))
				{
					flag = true;
					i++;
				}
				BindingDiagnosticBag instance2 = BindingDiagnosticBag.GetInstance(diagnostics);
				ArrayBuilder<OverloadResolution.CandidateAnalysisResult> arrayBuilder;
				int index;
				OverloadResolution.CandidateAnalysisResult candidateAnalysisResult = (arrayBuilder = candidates)[index = i];
				ReportOverloadResolutionFailureForASingleCandidate(node, diagnosticLocation, lookupResult, ref candidateAnalysisResult, arguments, argumentNames, flag2, flag, includeMethodNameInErrorMessages: false, errorNo == (ERRID)(((object)delegateSymbol == null) ? 30519 : 30950), instance2, delegateSymbol, queryMode, callerInfoOpt, null);
				arrayBuilder[index] = candidateAnalysisResult;
				instance.Add(KeyValuePairUtil.Create(candidates[i].Candidate.UnderlyingSymbol, instance2.ToReadOnlyAndFree()));
			}
			if (!ReportCommonErrorsFromLambdas(instance, arguments, diagnostics))
			{
				ArrayBuilder<DiagnosticInfo> instance3 = ArrayBuilder<DiagnosticInfo>.GetInstance(candidates.Count);
				int index = instance.Count - 1;
				for (int j = 0; j <= index; j++)
				{
					Symbol key = instance[j].Key;
					bool flag3 = SymbolExtensions.IsReducedExtensionMethod(key);
					ImmutableArray<Diagnostic> diagnostics2 = instance[j].Value.Diagnostics;
					if ((object)delegateSymbol == null || !diagnostics2.Skip(1).Any())
					{
						if (flag3)
						{
							ImmutableArray<Diagnostic>.Enumerator enumerator = diagnostics2.GetEnumerator();
							while (enumerator.MoveNext())
							{
								Diagnostic current = enumerator.Current;
								instance3.Add(ErrorFactory.ErrorInfo(ERRID.ERR_ExtensionMethodOverloadCandidate3, key, key.ContainingType, ((DiagnosticWithInfo)current).Info));
							}
						}
						else
						{
							ImmutableArray<Diagnostic>.Enumerator enumerator2 = diagnostics2.GetEnumerator();
							while (enumerator2.MoveNext())
							{
								Diagnostic current2 = enumerator2.Current;
								VisualBasicDiagnosticFormatter.Instance.Format(current2.WithLocation(Location.None));
								instance3.Add(ErrorFactory.ErrorInfo(ERRID.ERR_OverloadCandidate2, key, ((DiagnosticWithInfo)current2).Info));
							}
						}
					}
					else if (flag3)
					{
						instance3.Add(ErrorFactory.ErrorInfo(ERRID.ERR_ExtensionMethodOverloadCandidate3, key, key.ContainingType, ErrorFactory.ErrorInfo(ERRID.ERR_DelegateBindingMismatch, key)));
					}
					else
					{
						instance3.Add(ErrorFactory.ErrorInfo(ERRID.ERR_OverloadCandidate2, key, ErrorFactory.ErrorInfo(ERRID.ERR_DelegateBindingMismatch, key)));
					}
				}
				DiagnosticInfo[] arguments2 = instance3.ToArrayAndFree();
				if ((object)delegateSymbol == null)
				{
					ReportDiagnostic(diagnostics, diagnosticLocation, ErrorFactory.ErrorInfo(errorNo, CustomSymbolDisplayFormatter.ShortErrorName(candidates[0].Candidate.UnderlyingSymbol), new CompoundDiagnosticInfo(arguments2)));
				}
				else
				{
					ReportDiagnostic(diagnostics, diagnosticLocation, ErrorFactory.ErrorInfo(errorNo, CustomSymbolDisplayFormatter.ShortErrorName(candidates[0].Candidate.UnderlyingSymbol), CustomSymbolDisplayFormatter.DelegateSignature(delegateSymbol), new CompoundDiagnosticInfo(arguments2)));
				}
			}
			instance.Free();
		}

		private static bool ReportCommonErrorsFromLambdas(ArrayBuilder<KeyValuePair<Symbol, ImmutableBindingDiagnostic<AssemblySymbol>>> diagnosticPerSymbol, ImmutableArray<BoundExpression> arguments, BindingDiagnosticBag diagnostics)
		{
			bool result = false;
			ImmutableArray<Diagnostic>.Enumerator enumerator = diagnosticPerSymbol[0].Value.Diagnostics.GetEnumerator();
			while (enumerator.MoveNext())
			{
				Diagnostic current = enumerator.Current;
				if (current.Severity != DiagnosticSeverity.Error)
				{
					continue;
				}
				ImmutableArray<BoundExpression>.Enumerator enumerator2 = arguments.GetEnumerator();
				while (enumerator2.MoveNext())
				{
					BoundExpression current2 = enumerator2.Current;
					if (current2.Syntax.SyntaxTree != current.Location.SourceTree || current2.Kind != BoundKind.UnboundLambda || !current2.Syntax.Span.Contains(current.Location.SourceSpan))
					{
						continue;
					}
					bool flag = true;
					int num = diagnosticPerSymbol.Count - 1;
					for (int i = 1; i <= num; i++)
					{
						if (!diagnosticPerSymbol[i].Value.Diagnostics.Contains(current))
						{
							flag = false;
							break;
						}
					}
					if (flag)
					{
						result = true;
						diagnostics.Add(current);
					}
					break;
				}
			}
			return result;
		}

		private void ReportOverloadResolutionFailureForASingleCandidate(SyntaxNode node, Location diagnosticLocation, LookupResultKind lookupResult, ref OverloadResolution.CandidateAnalysisResult candidateAnalysisResult, ImmutableArray<BoundExpression> arguments, ImmutableArray<string> argumentNames, bool allowUnexpandedParamArrayForm, bool allowExpandedParamArrayForm, bool includeMethodNameInErrorMessages, bool reportNarrowingConversions, BindingDiagnosticBag diagnostics, Symbol delegateSymbol, bool queryMode, SyntaxNode callerInfoOpt, Symbol representCandidateInDiagnosticsOpt)
		{
			OverloadResolution.Candidate candidate = candidateAnalysisResult.Candidate;
			if (arguments.IsDefault)
			{
				arguments = ImmutableArray<BoundExpression>.Empty;
			}
			if (candidateAnalysisResult.State == OverloadResolution.CandidateAnalysisResultState.HasUseSiteError || candidateAnalysisResult.State == OverloadResolution.CandidateAnalysisResultState.HasUnsupportedMetadata)
			{
				if (lookupResult != LookupResultKind.Inaccessible)
				{
					ReportUseSite(diagnostics, diagnosticLocation, candidate.UnderlyingSymbol.GetUseSiteInfo());
				}
				return;
			}
			if (!argumentNames.IsDefault && argumentNames.Length == 0)
			{
				argumentNames = default(ImmutableArray<string>);
			}
			ArrayBuilder<int> instance = ArrayBuilder<int>.GetInstance(candidate.ParameterCount, -1);
			ArrayBuilder<int> instance2 = ArrayBuilder<int>.GetInstance();
			try
			{
				int num = 0;
				int index = 0;
				bool flag = false;
				bool flag2 = false;
				int index2 = -1;
				Symbol underlyingSymbol = candidate.UnderlyingSymbol;
				bool isExtensionMethod = candidate.IsExtensionMethod;
				int num2 = arguments.Length - 1;
				for (int i = 0; i <= num2; i++)
				{
					if (!argumentNames.IsDefault && argumentNames[i] != null)
					{
						if (!candidate.TryGetNamedParamIndex(argumentNames[i], ref index))
						{
							break;
						}
						if (index != i)
						{
							index2 = i;
							break;
						}
						if (index == candidate.ParameterCount - 1 && candidate.Parameters(index).IsParamArray)
						{
							break;
						}
					}
					if (index == candidate.ParameterCount)
					{
						if (!flag)
						{
							if (!includeMethodNameInErrorMessages)
							{
								ReportDiagnostic(diagnostics, arguments[i].Syntax, ERRID.ERR_TooManyArgs);
							}
							else if (isExtensionMethod)
							{
								ReportDiagnostic(diagnostics, arguments[i].Syntax, ERRID.ERR_TooManyArgs2, underlyingSymbol, underlyingSymbol.ContainingType);
							}
							else
							{
								ReportDiagnostic(diagnostics, arguments[i].Syntax, ERRID.ERR_TooManyArgs1, representCandidateInDiagnosticsOpt ?? underlyingSymbol);
							}
							flag = true;
						}
					}
					else
					{
						if (index == candidate.ParameterCount - 1 && candidate.Parameters(index).IsParamArray)
						{
							while (i < arguments.Length)
							{
								if (argumentNames.IsDefault || argumentNames[i] == null)
								{
									if (arguments[i].Kind == BoundKind.OmittedArgument)
									{
										ReportDiagnostic(diagnostics, arguments[i].Syntax, ERRID.ERR_OmittedParamArrayArgument);
										flag2 = true;
									}
									else
									{
										instance2.Add(i);
									}
									num++;
									i++;
									continue;
								}
								goto IL_0241;
							}
							break;
						}
						instance[index] = i;
						index++;
					}
					num++;
					IL_0241:;
				}
				bool flag3 = false;
				int num3 = num;
				int num4 = arguments.Length - 1;
				for (int j = num3; j <= num4; j++)
				{
					if (argumentNames[j] == null)
					{
						if (!flag)
						{
							ReportDiagnostic(diagnostics, GetNamedArgumentIdentifier(arguments[index2].Syntax), ERRID.ERR_BadNonTrailingNamedArgument, argumentNames[index2]);
						}
						return;
					}
					if (!candidate.TryGetNamedParamIndex(argumentNames[j], ref index))
					{
						if (!includeMethodNameInErrorMessages)
						{
							ReportDiagnostic(diagnostics, GetNamedArgumentIdentifier(arguments[j].Syntax), ERRID.ERR_NamedParamNotFound1, argumentNames[j]);
						}
						else if (isExtensionMethod)
						{
							ReportDiagnostic(diagnostics, GetNamedArgumentIdentifier(arguments[j].Syntax), ERRID.ERR_NamedParamNotFound3, argumentNames[j], underlyingSymbol, underlyingSymbol.ContainingType);
						}
						else
						{
							ReportDiagnostic(diagnostics, GetNamedArgumentIdentifier(arguments[j].Syntax), ERRID.ERR_NamedParamNotFound2, argumentNames[j], representCandidateInDiagnosticsOpt ?? underlyingSymbol);
						}
						flag = true;
						continue;
					}
					if (index == candidate.ParameterCount - 1 && candidate.Parameters(index).IsParamArray)
					{
						ReportDiagnostic(diagnostics, GetNamedArgumentIdentifier(arguments[j].Syntax), ERRID.ERR_NamedParamArrayArgument);
						flag = true;
						continue;
					}
					if (instance[index] != -1 && arguments[instance[index]].Kind != BoundKind.OmittedArgument)
					{
						if (!includeMethodNameInErrorMessages)
						{
							ReportDiagnostic(diagnostics, GetNamedArgumentIdentifier(arguments[j].Syntax), ERRID.ERR_NamedArgUsedTwice1, argumentNames[j]);
						}
						else if (isExtensionMethod)
						{
							ReportDiagnostic(diagnostics, GetNamedArgumentIdentifier(arguments[j].Syntax), ERRID.ERR_NamedArgUsedTwice3, argumentNames[j], underlyingSymbol, underlyingSymbol.ContainingType);
						}
						else
						{
							ReportDiagnostic(diagnostics, GetNamedArgumentIdentifier(arguments[j].Syntax), ERRID.ERR_NamedArgUsedTwice2, argumentNames[j], representCandidateInDiagnosticsOpt ?? underlyingSymbol);
						}
						flag = true;
						continue;
					}
					if (index < num)
					{
						if (!includeMethodNameInErrorMessages)
						{
							ReportDiagnostic(diagnostics, GetNamedArgumentIdentifier(arguments[j].Syntax), ERRID.ERR_NamedArgAlsoOmitted1, argumentNames[j]);
						}
						else if (isExtensionMethod)
						{
							ReportDiagnostic(diagnostics, GetNamedArgumentIdentifier(arguments[j].Syntax), ERRID.ERR_NamedArgAlsoOmitted3, argumentNames[j], underlyingSymbol, underlyingSymbol.ContainingType);
						}
						else
						{
							ReportDiagnostic(diagnostics, GetNamedArgumentIdentifier(arguments[j].Syntax), ERRID.ERR_NamedArgAlsoOmitted2, argumentNames[j], representCandidateInDiagnosticsOpt ?? underlyingSymbol);
						}
						flag = true;
					}
					instance[index] = j;
				}
				if (candidateAnalysisResult.TypeArgumentInferenceDiagnosticsOpt != null)
				{
					diagnostics.AddRange(candidateAnalysisResult.TypeArgumentInferenceDiagnosticsOpt);
				}
				if (candidate.IsGeneric && candidateAnalysisResult.State == OverloadResolution.CandidateAnalysisResultState.TypeInferenceFailed)
				{
					if ((object)delegateSymbol != null)
					{
						ReportDiagnostic(diagnostics, diagnosticLocation, ERRID.ERR_DelegateBindingTypeInferenceFails);
						return;
					}
					if (!candidateAnalysisResult.SomeInferenceFailed)
					{
						bool flag4 = false;
						int num5 = candidate.Arity - 1;
						for (int k = 0; k <= num5; k++)
						{
							if (candidateAnalysisResult.NotInferredTypeArguments[k])
							{
								if (!includeMethodNameInErrorMessages)
								{
									ReportDiagnostic(diagnostics, diagnosticLocation, ERRID.ERR_UnboundTypeParam1, candidate.TypeParameters[k]);
								}
								else if (isExtensionMethod)
								{
									ReportDiagnostic(diagnostics, diagnosticLocation, ERRID.ERR_UnboundTypeParam3, candidate.TypeParameters[k], underlyingSymbol, underlyingSymbol.ContainingType);
								}
								else
								{
									ReportDiagnostic(diagnostics, diagnosticLocation, ERRID.ERR_UnboundTypeParam2, candidate.TypeParameters[k], representCandidateInDiagnosticsOpt ?? underlyingSymbol);
								}
								flag4 = true;
							}
						}
						if (flag4)
						{
							return;
						}
					}
					InferenceErrorReasons inferenceErrorReasons = candidateAnalysisResult.InferenceErrorReasons;
					if ((inferenceErrorReasons & InferenceErrorReasons.Ambiguous) != 0)
					{
						if (!includeMethodNameInErrorMessages)
						{
							ReportDiagnostic(diagnostics, diagnosticLocation, queryMode ? ERRID.ERR_TypeInferenceFailureNoExplicitAmbiguous1 : ERRID.ERR_TypeInferenceFailureAmbiguous1);
						}
						else if (isExtensionMethod)
						{
							ReportDiagnostic(diagnostics, diagnosticLocation, queryMode ? ERRID.ERR_TypeInferenceFailureNoExplicitAmbiguous3 : ERRID.ERR_TypeInferenceFailureAmbiguous3, underlyingSymbol, underlyingSymbol.ContainingType);
						}
						else
						{
							ReportDiagnostic(diagnostics, diagnosticLocation, queryMode ? ERRID.ERR_TypeInferenceFailureNoExplicitAmbiguous2 : ERRID.ERR_TypeInferenceFailureAmbiguous2, representCandidateInDiagnosticsOpt ?? underlyingSymbol);
						}
					}
					else if ((inferenceErrorReasons & InferenceErrorReasons.NoBest) != 0)
					{
						if (!includeMethodNameInErrorMessages)
						{
							ReportDiagnostic(diagnostics, diagnosticLocation, queryMode ? ERRID.ERR_TypeInferenceFailureNoExplicitNoBest1 : ERRID.ERR_TypeInferenceFailureNoBest1);
						}
						else if (isExtensionMethod)
						{
							ReportDiagnostic(diagnostics, diagnosticLocation, queryMode ? ERRID.ERR_TypeInferenceFailureNoExplicitNoBest3 : ERRID.ERR_TypeInferenceFailureNoBest3, underlyingSymbol, underlyingSymbol.ContainingType);
						}
						else
						{
							ReportDiagnostic(diagnostics, diagnosticLocation, queryMode ? ERRID.ERR_TypeInferenceFailureNoExplicitNoBest2 : ERRID.ERR_TypeInferenceFailureNoBest2, representCandidateInDiagnosticsOpt ?? underlyingSymbol);
						}
					}
					else if (candidateAnalysisResult.TypeArgumentInferenceDiagnosticsOpt == null || !candidateAnalysisResult.TypeArgumentInferenceDiagnosticsOpt.HasAnyResolvedErrors())
					{
						if (!includeMethodNameInErrorMessages)
						{
							ReportDiagnostic(diagnostics, diagnosticLocation, queryMode ? ERRID.ERR_TypeInferenceFailureNoExplicit1 : ERRID.ERR_TypeInferenceFailure1);
						}
						else if (isExtensionMethod)
						{
							ReportDiagnostic(diagnostics, diagnosticLocation, queryMode ? ERRID.ERR_TypeInferenceFailureNoExplicit3 : ERRID.ERR_TypeInferenceFailure3, underlyingSymbol, underlyingSymbol.ContainingType);
						}
						else
						{
							ReportDiagnostic(diagnostics, diagnosticLocation, queryMode ? ERRID.ERR_TypeInferenceFailureNoExplicit2 : ERRID.ERR_TypeInferenceFailure2, representCandidateInDiagnosticsOpt ?? underlyingSymbol);
						}
					}
				}
				else if (candidateAnalysisResult.State == OverloadResolution.CandidateAnalysisResultState.GenericConstraintsViolated)
				{
					ConstraintsHelper.CheckConstraints((MethodSymbol)candidate.UnderlyingSymbol, diagnosticLocation, diagnostics, GetNewCompoundUseSiteInfo(diagnostics));
				}
				else
				{
					if (candidateAnalysisResult.TypeArgumentInferenceDiagnosticsOpt != null && candidateAnalysisResult.TypeArgumentInferenceDiagnosticsOpt.HasAnyErrors())
					{
						return;
					}
					bool flag5 = underlyingSymbol.Kind == SymbolKind.Property;
					int num6 = candidate.ParameterCount - 1;
					for (index = 0; index <= num6; index++)
					{
						ParameterSymbol parameterSymbol = candidate.Parameters(index);
						bool isByRef = parameterSymbol.IsByRef;
						TypeSymbol type = parameterSymbol.Type;
						BoundExpression boundExpression = null;
						BoundExpression boundExpression2;
						if (parameterSymbol.IsParamArray && index == candidate.ParameterCount - 1)
						{
							if (type.Kind != SymbolKind.ArrayType)
							{
								if (type.Kind != SymbolKind.ErrorType)
								{
									ReportDiagnostic(diagnostics, diagnosticLocation, ERRID.ERR_ParamArrayWrongType);
								}
								flag = true;
								continue;
							}
							if (flag2)
							{
								continue;
							}
							if (instance2.Count == 1)
							{
								boundExpression2 = arguments[instance2[0]];
								KeyValuePair<ConversionKind, MethodSymbol> outConvKind = default(KeyValuePair<ConversionKind, MethodSymbol>);
								if (allowUnexpandedParamArrayForm)
								{
									if (!boundExpression2.HasErrors)
									{
										CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
										if (OverloadResolution.CanPassToParamArray(boundExpression2, type, out outConvKind, this, ref useSiteInfo))
										{
											goto IL_09d8;
										}
									}
									allowUnexpandedParamArrayForm = false;
								}
								goto IL_09d8;
							}
							if (!allowExpandedParamArrayForm)
							{
								if (instance2.Count == 0)
								{
									if (!includeMethodNameInErrorMessages)
									{
										ReportDiagnostic(diagnostics, diagnosticLocation, ERRID.ERR_OmittedArgument1, CustomSymbolDisplayFormatter.ShortErrorName(parameterSymbol));
									}
									else if (isExtensionMethod)
									{
										ReportDiagnostic(diagnostics, diagnosticLocation, ERRID.ERR_OmittedArgument3, CustomSymbolDisplayFormatter.ShortErrorName(parameterSymbol), underlyingSymbol, underlyingSymbol.ContainingType);
									}
									else
									{
										ReportDiagnostic(diagnostics, diagnosticLocation, ERRID.ERR_OmittedArgument2, CustomSymbolDisplayFormatter.ShortErrorName(parameterSymbol), representCandidateInDiagnosticsOpt ?? underlyingSymbol);
									}
								}
								else if (!includeMethodNameInErrorMessages)
								{
									ReportDiagnostic(diagnostics, diagnosticLocation, ERRID.ERR_TooManyArgs);
								}
								else if (isExtensionMethod)
								{
									ReportDiagnostic(diagnostics, diagnosticLocation, ERRID.ERR_TooManyArgs2, underlyingSymbol, underlyingSymbol.ContainingType);
								}
								else
								{
									ReportDiagnostic(diagnostics, diagnosticLocation, ERRID.ERR_TooManyArgs1, representCandidateInDiagnosticsOpt ?? underlyingSymbol);
								}
								flag = true;
								continue;
							}
							allowUnexpandedParamArrayForm = false;
							goto IL_0aee;
						}
						int num7 = instance[index];
						boundExpression = ((num7 == -1) ? null : arguments[num7]);
						if (boundExpression == null || boundExpression.Kind == BoundKind.OmittedArgument)
						{
							if (boundExpression == null && flag3)
							{
								flag = true;
								continue;
							}
							boundExpression = GetArgumentForParameterDefaultValue(parameterSymbol, node, diagnostics, callerInfoOpt);
							if (boundExpression == null)
							{
								if (!includeMethodNameInErrorMessages)
								{
									ReportDiagnostic(diagnostics, diagnosticLocation, ERRID.ERR_OmittedArgument1, CustomSymbolDisplayFormatter.ShortErrorName(parameterSymbol));
								}
								else if (isExtensionMethod)
								{
									ReportDiagnostic(diagnostics, diagnosticLocation, ERRID.ERR_OmittedArgument3, CustomSymbolDisplayFormatter.ShortErrorName(parameterSymbol), underlyingSymbol, underlyingSymbol.ContainingType);
								}
								else
								{
									ReportDiagnostic(diagnostics, diagnosticLocation, ERRID.ERR_OmittedArgument2, CustomSymbolDisplayFormatter.ShortErrorName(parameterSymbol), representCandidateInDiagnosticsOpt ?? underlyingSymbol);
								}
								flag = true;
								continue;
							}
						}
						if (isByRef && !flag5 && (parameterSymbol.IsExplicitByRef || ((object)boundExpression.Type != null && TypeSymbolExtensions.IsStringType(boundExpression.Type))))
						{
							ReportByRefConversionErrors(candidate, parameterSymbol, boundExpression, type, reportNarrowingConversions, diagnostics, node, delegateSymbol);
						}
						else
						{
							ReportByValConversionErrors(parameterSymbol, boundExpression, type, reportNarrowingConversions, diagnostics, node, delegateSymbol);
						}
						continue;
						IL_0aee:
						if (allowUnexpandedParamArrayForm)
						{
							boundExpression = arguments[instance2[0]];
							ReportByValConversionErrors(parameterSymbol, boundExpression, type, reportNarrowingConversions, diagnostics);
						}
						else if (allowExpandedParamArrayForm)
						{
							ArrayTypeSymbol arrayTypeSymbol = (ArrayTypeSymbol)type;
							if (!arrayTypeSymbol.IsSZArray)
							{
								ReportDiagnostic(diagnostics, diagnosticLocation, ERRID.ERR_ParamArrayWrongType);
								flag = true;
								continue;
							}
							TypeSymbol elementType = arrayTypeSymbol.ElementType;
							int num8 = instance2.Count - 1;
							for (int l = 0; l <= num8; l++)
							{
								boundExpression = arguments[instance2[l]];
								ReportByValConversionErrors(parameterSymbol, boundExpression, elementType, reportNarrowingConversions, diagnostics);
							}
						}
						else
						{
							BoundExpression boundExpression3 = arguments[instance2[0]];
							ReportDiagnostic(diagnostics, boundExpression3.Syntax, ERRID.ERR_ParamArrayArgumentMismatch);
						}
						continue;
						IL_09d8:
						if (allowExpandedParamArrayForm && BoundExpressionExtensions.IsNothingLiteral(boundExpression2))
						{
							allowExpandedParamArrayForm = false;
						}
						goto IL_0aee;
					}
				}
			}
			finally
			{
				instance2.Free();
				instance.Free();
			}
		}

		private void ReportByRefConversionErrors(OverloadResolution.Candidate candidate, ParameterSymbol param, BoundExpression argument, TypeSymbol targetType, bool reportNarrowingConversions, BindingDiagnosticBag diagnostics, SyntaxNode diagnosticNode = null, Symbol delegateSymbol = null)
		{
			if (TypeSymbolExtensions.IsErrorType(targetType) || argument.HasErrors)
			{
				return;
			}
			if (BoundExpressionExtensions.IsSupportingAssignment(argument))
			{
				if ((argument.IsLValue && TypeSymbolExtensions.IsSameTypeIgnoringAll(targetType, argument.Type)) || ReportByValConversionErrors(param, argument, targetType, reportNarrowingConversions, diagnostics, diagnosticNode, delegateSymbol))
				{
					return;
				}
				BoundRValuePlaceholder boundRValuePlaceholder = new BoundRValuePlaceholder(argument.Syntax, targetType);
				TypeSymbol typeOfAssignmentTarget = BoundExpressionExtensions.GetTypeOfAssignmentTarget(argument);
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
				KeyValuePair<ConversionKind, MethodSymbol> convKind = Conversions.ClassifyConversion(boundRValuePlaceholder, typeOfAssignmentTarget, this, ref useSiteInfo);
				if (Conversions.NoConversion(convKind.Key))
				{
					CreateConversionAndReportDiagnostic(argument.Syntax, boundRValuePlaceholder, convKind, isExplicit: false, typeOfAssignmentTarget, diagnostics, param.Name);
				}
				else if (Conversions.IsNarrowingConversion(convKind.Key))
				{
					if (OptionStrict == OptionStrict.On)
					{
						CreateConversionAndReportDiagnostic(argument.Syntax, boundRValuePlaceholder, convKind, isExplicit: false, typeOfAssignmentTarget, diagnostics, param.Name);
					}
					else if (reportNarrowingConversions)
					{
						ReportDiagnostic(diagnostics, argument.Syntax, ERRID.ERR_ArgumentCopyBackNarrowing3, CustomSymbolDisplayFormatter.ShortErrorName(param), targetType, typeOfAssignmentTarget);
					}
				}
			}
			else
			{
				if (Report_ERRID_ReadOnlyInClosure(argument))
				{
					ReportDiagnostic(diagnostics, argument.Syntax, ERRID.ERR_ReadOnlyInClosure);
				}
				ReportByValConversionErrors(param, argument, targetType, reportNarrowingConversions, diagnostics, diagnosticNode, delegateSymbol);
			}
		}

		private bool ReportByValConversionErrors(ParameterSymbol param, BoundExpression argument, TypeSymbol targetType, bool reportNarrowingConversions, BindingDiagnosticBag diagnostics, SyntaxNode diagnosticNode = null, Symbol delegateSymbol = null)
		{
			if (TypeSymbolExtensions.IsErrorType(targetType) || argument.HasErrors)
			{
				return true;
			}
			BoundExpression source = argument;
			TypeSymbol destination = targetType;
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
			KeyValuePair<ConversionKind, MethodSymbol> convKind = Conversions.ClassifyConversion(source, destination, this, ref useSiteInfo);
			if (Conversions.NoConversion(convKind.Key))
			{
				if ((object)delegateSymbol == null)
				{
					CreateConversionAndReportDiagnostic(argument.Syntax, argument, convKind, isExplicit: false, targetType, diagnostics);
				}
				else
				{
					CreateConversionAndReportDiagnostic(diagnosticNode, argument, convKind, isExplicit: false, targetType, diagnostics);
				}
				return true;
			}
			bool flag = false;
			if (Conversions.IsNarrowingConversion(convKind.Key))
			{
				if ((convKind.Key & ConversionKind.InvolvesNarrowingFromNumericConstant) == 0 && OptionStrict == OptionStrict.On)
				{
					if ((object)delegateSymbol == null)
					{
						CreateConversionAndReportDiagnostic(argument.Syntax, argument, convKind, isExplicit: false, targetType, diagnostics);
					}
					else
					{
						CreateConversionAndReportDiagnostic(diagnosticNode, argument, convKind, isExplicit: false, targetType, diagnostics);
					}
					return true;
				}
				flag = true;
			}
			else if ((convKind.Key & ConversionKind.InvolvesNarrowingFromNumericConstant) != 0)
			{
				flag = true;
			}
			if (reportNarrowingConversions && flag)
			{
				ERRID id = ERRID.ERR_ArgumentNarrowing3;
				NamedTypeSymbol namedTypeSymbol = TypeSymbolExtensions.DelegateOrExpressionDelegate(targetType, this);
				if (argument.Kind == BoundKind.QueryLambda && (object)namedTypeSymbol != null)
				{
					MethodSymbol delegateInvokeMethod = namedTypeSymbol.DelegateInvokeMethod;
					if ((object)delegateInvokeMethod != null && !delegateInvokeMethod.IsSub)
					{
						id = ERRID.ERR_NestedFunctionArgumentNarrowing3;
						argument = ((BoundQueryLambda)argument).Expression;
						targetType = delegateInvokeMethod.ReturnType;
					}
				}
				if ((object)argument.Type == null)
				{
					ReportDiagnostic(diagnostics, argument.Syntax, ERRID.ERR_ArgumentNarrowing2, CustomSymbolDisplayFormatter.ShortErrorName(param), targetType);
				}
				else
				{
					ReportDiagnostic(diagnostics, argument.Syntax, id, CustomSymbolDisplayFormatter.ShortErrorName(param), argument.Type, targetType);
				}
			}
			return false;
		}

		private (ImmutableArray<BoundExpression> Arguments, BitVector DefaultArguments) PassArguments(SyntaxNode node, ref OverloadResolution.CandidateAnalysisResult candidate, ImmutableArray<BoundExpression> arguments, BindingDiagnosticBag diagnostics)
		{
			if (arguments.IsDefault)
			{
				arguments = ImmutableArray<BoundExpression>.Empty;
			}
			int parameterCount = candidate.Candidate.ParameterCount;
			ArrayBuilder<int> instance = ArrayBuilder<int>.GetInstance(parameterCount, -1);
			ArrayBuilder<BoundExpression> instance2 = ArrayBuilder<BoundExpression>.GetInstance(parameterCount);
			BitVector item = BitVector.Null;
			ArrayBuilder<int> arrayBuilder = null;
			if (candidate.IsExpandedParamArrayForm)
			{
				arrayBuilder = ArrayBuilder<int>.GetInstance();
			}
			if (candidate.ArgsToParamsOpt.IsDefaultOrEmpty)
			{
				int num = parameterCount;
				if (candidate.IsExpandedParamArrayForm)
				{
					num--;
				}
				int num2 = Math.Min(num, arguments.Length) - 1;
				for (int i = 0; i <= num2; i++)
				{
					if (arguments[i].Kind != BoundKind.OmittedArgument)
					{
						instance[i] = i;
					}
				}
				if (candidate.IsExpandedParamArrayForm)
				{
					int num3 = num;
					int num4 = arguments.Length - 1;
					for (int j = num3; j <= num4; j++)
					{
						arrayBuilder.Add(j);
					}
				}
			}
			else
			{
				ImmutableArray<int> argsToParamsOpt = candidate.ArgsToParamsOpt;
				int num5 = argsToParamsOpt.Length - 1;
				for (int k = 0; k <= num5; k++)
				{
					int num6 = argsToParamsOpt[k];
					if (arguments[k].Kind != BoundKind.OmittedArgument)
					{
						if (candidate.IsExpandedParamArrayForm && num6 == candidate.Candidate.ParameterCount - 1)
						{
							arrayBuilder.Add(k);
						}
						else
						{
							instance[num6] = k;
						}
					}
				}
			}
			bool forceByValueSemantics = candidate.Candidate.UnderlyingSymbol.Kind == SymbolKind.Property;
			int num7 = parameterCount - 1;
			for (int num6 = 0; num6 <= num7; num6++)
			{
				ParameterSymbol parameterSymbol = candidate.Candidate.Parameters(num6);
				TypeSymbol type = parameterSymbol.Type;
				BoundExpression boundExpression = null;
				KeyValuePair<ConversionKind, MethodSymbol> conversionTo = Conversions.Identity;
				KeyValuePair<ConversionKind, MethodSymbol> conversionFrom = Conversions.Identity;
				if (candidate.IsExpandedParamArrayForm && num6 == candidate.Candidate.ParameterCount - 1)
				{
					TypeSymbol elementType = ((ArrayTypeSymbol)type).ElementType;
					ArrayBuilder<BoundExpression> instance3 = ArrayBuilder<BoundExpression>.GetInstance(arrayBuilder.Count);
					int num8 = arrayBuilder.Count - 1;
					for (int l = 0; l <= num8; l++)
					{
						instance3.Add(PassArgumentByVal(arguments[arrayBuilder[l]], candidate.ConversionsOpt.IsDefaultOrEmpty ? Conversions.Identity : candidate.ConversionsOpt[arrayBuilder[l]], elementType, diagnostics));
					}
					boundExpression = BoundNodeExtensions.MakeCompilerGenerated(new BoundArrayCreation(node, isParamArrayArgument: true, new BoundExpression[1] { BoundNodeExtensions.MakeCompilerGenerated(new BoundLiteral(node, ConstantValue.Create(instance3.Count), GetSpecialType(SpecialType.System_Int32, node, diagnostics))) }.AsImmutableOrNull(), BoundNodeExtensions.MakeCompilerGenerated(new BoundArrayInitialization(node, instance3.ToImmutableAndFree(), type)), null, ConversionKind.DelegateRelaxationLevelNone, type));
				}
				else
				{
					int num9 = instance[num6];
					boundExpression = ((num9 == -1) ? null : arguments[num9]);
					if (boundExpression != null && num6 == candidate.Candidate.ParameterCount - 1 && parameterSymbol.IsParamArray)
					{
						boundExpression = ApplyImplicitConversion(boundExpression.Syntax, type, boundExpression, diagnostics);
					}
					else if (num9 > -1)
					{
						if (!candidate.ConversionsOpt.IsDefaultOrEmpty)
						{
							conversionTo = candidate.ConversionsOpt[num9];
						}
						if (!candidate.ConversionsBackOpt.IsDefaultOrEmpty)
						{
							conversionFrom = candidate.ConversionsBackOpt[num9];
						}
					}
				}
				bool flag = false;
				if (boundExpression == null)
				{
					if (item.IsNull)
					{
						item = BitVector.Create(parameterCount);
					}
					OverloadResolution.OptionalArgument optionalArgument = candidate.OptionalArguments[num6];
					boundExpression = optionalArgument.DefaultValue;
					diagnostics.AddDependencies(optionalArgument.Dependencies);
					flag = true;
					item[num6] = true;
					conversionTo = optionalArgument.Conversion;
					TypeSymbol type2 = boundExpression.Type;
					if ((object)type2 != null)
					{
						UseSiteInfo<AssemblySymbol> useSiteInfo = type2.GetUseSiteInfo();
						ReportUseSite(diagnostics, boundExpression.Syntax, useSiteInfo);
					}
				}
				BoundExpression boundExpression2 = PassArgument(boundExpression, conversionTo, forceByValueSemantics, conversionFrom, type, parameterSymbol, diagnostics);
				if (flag && boundExpression2 != boundExpression)
				{
					boundExpression2.SetWasCompilerGenerated();
				}
				instance2.Add(boundExpression2);
			}
			arrayBuilder?.Free();
			instance.Free();
			return (instance2.ToImmutableAndFree(), item);
		}

		private BoundExpression PassArgument(BoundExpression argument, KeyValuePair<ConversionKind, MethodSymbol> conversionTo, bool forceByValueSemantics, KeyValuePair<ConversionKind, MethodSymbol> conversionFrom, TypeSymbol targetType, ParameterSymbol param, BindingDiagnosticBag diagnostics)
		{
			if (param.IsByRef && !forceByValueSemantics && (param.IsExplicitByRef || ((object)argument.Type != null && TypeSymbolExtensions.IsStringType(argument.Type))))
			{
				return PassArgumentByRef(param.IsOut, argument, conversionTo, conversionFrom, targetType, param.Name, diagnostics);
			}
			return PassArgumentByVal(argument, conversionTo, targetType, diagnostics);
		}

		private BoundExpression PassArgumentByRef(bool isOutParameter, BoundExpression argument, KeyValuePair<ConversionKind, MethodSymbol> conversionTo, KeyValuePair<ConversionKind, MethodSymbol> conversionFrom, TypeSymbol targetType, string parameterName, BindingDiagnosticBag diagnostics)
		{
			bool isLValue = argument.IsLValue;
			if (isLValue && argument.Kind == BoundKind.PropertyAccess)
			{
				argument = BoundExpressionExtensions.SetAccessKind(argument, PropertyAccessKind.Get);
			}
			if (isLValue && Conversions.IsIdentityConversion(conversionTo.Key))
			{
				return argument;
			}
			if (isLValue || BoundExpressionExtensions.IsSupportingAssignment(argument))
			{
				BoundByRefArgumentPlaceholder boundByRefArgumentPlaceholder = BoundNodeExtensions.MakeCompilerGenerated(new BoundByRefArgumentPlaceholder(argument.Syntax, isOutParameter, argument.Type, argument.HasErrors));
				BoundExpression inConversion = CreateConversionAndReportDiagnostic(argument.Syntax, boundByRefArgumentPlaceholder, conversionTo, isExplicit: false, targetType, diagnostics);
				BoundRValuePlaceholder boundRValuePlaceholder = BoundNodeExtensions.MakeCompilerGenerated(new BoundRValuePlaceholder(argument.Syntax, targetType));
				TypeSymbol typeOfAssignmentTarget = BoundExpressionExtensions.GetTypeOfAssignmentTarget(argument);
				BoundExpression boundExpression = BoundNodeExtensions.MakeCompilerGenerated(CreateConversionAndReportDiagnostic(argument.Syntax, boundRValuePlaceholder, conversionFrom, isExplicit: false, typeOfAssignmentTarget, diagnostics, parameterName));
				if (argument.Kind == BoundKind.LateInvocation)
				{
					argument = MakeArgsRValues((BoundLateInvocation)argument, diagnostics);
				}
				BoundAssignmentOperator boundAssignmentOperator = BindAssignment(argument.Syntax, argument, boundExpression, diagnostics);
				if (!isLValue)
				{
					if (BoundExpressionExtensions.IsLateBound(argument))
					{
						argument = BoundExpressionExtensions.SetLateBoundAccessKind(argument, LateBoundAccessKind.Get | LateBoundAccessKind.Set);
					}
					else
					{
						WarnOnRecursiveAccess(argument, PropertyAccessKind.Get, diagnostics);
						argument = BoundExpressionExtensions.SetAccessKind(argument, PropertyAccessKind.Get | PropertyAccessKind.Set);
					}
				}
				return BoundNodeExtensions.MakeCompilerGenerated(new BoundByRefArgumentWithCopyBack(argument.Syntax, argument, inConversion, boundByRefArgumentPlaceholder, boundExpression, boundRValuePlaceholder, targetType, boundAssignmentOperator.HasErrors));
			}
			if (argument is BoundPropertyAccess boundPropertyAccess && boundPropertyAccess.AccessKind != PropertyAccessKind.Get)
			{
				MethodSymbol setMethod = boundPropertyAccess.PropertySymbol.SetMethod;
				if ((object)setMethod != null && setMethod.IsInitOnly)
				{
					Parser.CheckFeatureAvailability(diagnostics, argument.Syntax.Location, ((VisualBasicParseOptions)argument.Syntax.SyntaxTree.Options).LanguageVersion, Feature.InitOnlySettersUsage);
				}
			}
			return PassArgumentByVal(argument, conversionTo, targetType, diagnostics);
		}

		private BoundLateInvocation MakeArgsRValues(BoundLateInvocation invocation, BindingDiagnosticBag diagnostics)
		{
			ImmutableArray<BoundExpression> argumentsOpt = invocation.ArgumentsOpt;
			if (!argumentsOpt.IsEmpty)
			{
				ArrayBuilder<BoundExpression> arrayBuilder = null;
				int num = argumentsOpt.Length - 1;
				for (int i = 0; i <= num; i++)
				{
					BoundExpression boundExpression = argumentsOpt[i];
					BoundExpression boundExpression2 = MakeRValue(boundExpression, diagnostics);
					if (arrayBuilder == null && boundExpression != boundExpression2)
					{
						arrayBuilder = ArrayBuilder<BoundExpression>.GetInstance();
						arrayBuilder.AddRange(argumentsOpt, i);
					}
					arrayBuilder?.Add(boundExpression2);
				}
				if (arrayBuilder != null)
				{
					invocation = invocation.Update(invocation.Member, arrayBuilder.ToImmutableAndFree(), invocation.ArgumentNamesOpt, invocation.AccessKind, invocation.MethodOrPropertyGroupOpt, invocation.Type);
				}
			}
			return invocation;
		}

		internal BoundExpression PassArgumentByVal(BoundExpression argument, KeyValuePair<ConversionKind, MethodSymbol> conversion, TypeSymbol targetType, BindingDiagnosticBag diagnostics)
		{
			argument = CreateConversionAndReportDiagnostic(argument.Syntax, argument, conversion, isExplicit: false, targetType, diagnostics);
			return argument;
		}

		private void BindArgumentsAndNames(Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax argumentListOpt, ref ImmutableArray<BoundExpression> boundArguments, ref ImmutableArray<string> argumentNames, ref ImmutableArray<Location> argumentNamesLocations, BindingDiagnosticBag diagnostics)
		{
			ImmutableArray<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax> arguments = default(ImmutableArray<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax>);
			if (argumentListOpt != null)
			{
				SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax> arguments2 = argumentListOpt.Arguments;
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax[] array = new Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax[arguments2.Count - 1 + 1];
				int num = array.Length - 1;
				for (int i = 0; i <= num; i++)
				{
					array[i] = arguments2[i];
				}
				arguments = array.AsImmutableOrNull();
			}
			BindArgumentsAndNames(arguments, ref boundArguments, ref argumentNames, ref argumentNamesLocations, diagnostics);
		}

		private void BindArgumentsAndNames(ImmutableArray<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax> arguments, ref ImmutableArray<BoundExpression> boundArguments, ref ImmutableArray<string> argumentNames, ref ImmutableArray<Location> argumentNamesLocations, BindingDiagnosticBag diagnostics)
		{
			if (arguments.IsDefaultOrEmpty)
			{
				boundArguments = s_noArguments;
				argumentNames = default(ImmutableArray<string>);
				argumentNamesLocations = default(ImmutableArray<Location>);
				return;
			}
			ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
			ArrayBuilder<string> arrayBuilder = null;
			ArrayBuilder<Location> arrayBuilder2 = null;
			int num = 0;
			ImmutableArray<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax>.Enumerator enumerator = arguments.GetEnumerator();
			while (enumerator.MoveNext())
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax current = enumerator.Current;
				switch (current.Kind())
				{
				case SyntaxKind.SimpleArgument:
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax simpleArgumentSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax)current;
					instance.Add(BindValue(simpleArgumentSyntax.Expression, diagnostics));
					if (simpleArgumentSyntax.IsNamed)
					{
						if (arrayBuilder == null)
						{
							arrayBuilder = ArrayBuilder<string>.GetInstance();
							arrayBuilder2 = ArrayBuilder<Location>.GetInstance();
							int num2 = num - 1;
							for (int i = 0; i <= num2; i++)
							{
								arrayBuilder.Add(null);
								arrayBuilder2.Add(null);
							}
						}
						SyntaxToken identifier = simpleArgumentSyntax.NameColonEquals.Name.Identifier;
						if (identifier.ValueText.Length > 0)
						{
							arrayBuilder.Add(identifier.ValueText);
						}
						else
						{
							arrayBuilder.Add(null);
						}
						arrayBuilder2.Add(identifier.GetLocation());
					}
					else if (arrayBuilder != null)
					{
						arrayBuilder.Add(null);
						arrayBuilder2.Add(null);
					}
					break;
				}
				case SyntaxKind.OmittedArgument:
					instance.Add(new BoundOmittedArgument(current, null));
					if (arrayBuilder != null)
					{
						arrayBuilder.Add(null);
						arrayBuilder2.Add(null);
					}
					break;
				case SyntaxKind.RangeArgument:
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax rangeArgumentSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax)current;
					CheckRangeArgumentLowerBound(rangeArgumentSyntax, diagnostics);
					instance.Add(BindValue(rangeArgumentSyntax.UpperBound, diagnostics));
					if (arrayBuilder != null)
					{
						arrayBuilder.Add(null);
						arrayBuilder2.Add(null);
					}
					break;
				}
				default:
					throw ExceptionUtilities.UnexpectedValue(current.Kind());
				}
				num++;
			}
			boundArguments = instance.ToImmutableAndFree();
			argumentNames = arrayBuilder?.ToImmutableAndFree() ?? default(ImmutableArray<string>);
			argumentNamesLocations = arrayBuilder2?.ToImmutableAndFree() ?? default(ImmutableArray<Location>);
		}

		internal BoundExpression GetArgumentForParameterDefaultValue(ParameterSymbol param, SyntaxNode syntax, BindingDiagnosticBag diagnostics, SyntaxNode callerInfoOpt)
		{
			BoundExpression boundExpression = null;
			ConstantValue constantValue = (param.IsOptional ? param.get_ExplicitDefaultConstantValue(DefaultParametersInProgress) : null);
			if ((object)constantValue != null)
			{
				if (callerInfoOpt != null && callerInfoOpt.SyntaxTree != null && !EmbeddedSymbolExtensions.IsEmbeddedOrMyTemplateTree(callerInfoOpt.SyntaxTree) && !SuppressCallerInfo)
				{
					bool isCallerLineNumber = param.IsCallerLineNumber;
					bool isCallerMemberName = param.IsCallerMemberName;
					bool isCallerFilePath = param.IsCallerFilePath;
					if (isCallerLineNumber || isCallerMemberName || isCallerFilePath)
					{
						ConstantValue constantValue2 = null;
						if (isCallerLineNumber)
						{
							constantValue2 = ConstantValue.Create(callerInfoOpt.SyntaxTree.GetDisplayLineNumber(GetCallerLocation(callerInfoOpt)));
						}
						else if (isCallerMemberName)
						{
							Symbol symbol = ContainingMember;
							while ((object)symbol != null)
							{
								switch (symbol.Kind)
								{
								case SymbolKind.Method:
								{
									if (symbol.IsLambdaMethod)
									{
										symbol = symbol.ContainingSymbol;
										continue;
									}
									Symbol associatedSymbol = ((MethodSymbol)symbol).AssociatedSymbol;
									if ((object)associatedSymbol != null)
									{
										symbol = associatedSymbol;
									}
									break;
								}
								default:
									symbol = symbol.ContainingSymbol;
									continue;
								case SymbolKind.Event:
								case SymbolKind.Field:
								case SymbolKind.Property:
									break;
								}
								break;
							}
							if ((object)symbol != null && symbol.Name != null)
							{
								constantValue2 = ConstantValue.Create(symbol.Name);
							}
						}
						else
						{
							constantValue2 = ConstantValue.Create(callerInfoOpt.SyntaxTree.GetDisplayPath(callerInfoOpt.Span, Compilation.Options.SourceReferenceResolver));
						}
						if ((object)constantValue2 != null)
						{
							BindingDiagnosticBag bindingDiagnosticBag = new BindingDiagnosticBag(DiagnosticBag.GetInstance());
							BoundExpression boundExpression2 = ApplyImplicitConversion(expression: (constantValue2.Discriminator != ConstantValueTypeDiscriminator.Int32) ? new BoundLiteral(syntax, constantValue2, GetSpecialType(SpecialType.System_String, syntax, bindingDiagnosticBag)) : new BoundLiteral(syntax, constantValue2, GetSpecialType(SpecialType.System_Int32, syntax, bindingDiagnosticBag)), node: syntax, targetType: param.Type, diagnostics: bindingDiagnosticBag);
							if (!boundExpression2.HasErrors && !bindingDiagnosticBag.HasAnyErrors() && (boundExpression2.Kind != BoundKind.Conversion || (((BoundConversion)boundExpression2).ConversionKind & ConversionKind.UserDefined) == 0))
							{
								constantValue = constantValue2;
							}
							bindingDiagnosticBag.Free();
						}
					}
				}
				if (constantValue.IsBad)
				{
					constantValue = ConstantValue.Null;
				}
				SpecialType specialType = constantValue.SpecialType;
				TypeSymbol type = null;
				TypeSymbol nullableUnderlyingTypeOrSelf = TypeSymbolExtensions.GetNullableUnderlyingTypeOrSelf(param.Type);
				if (param.HasOptionCompare)
				{
					constantValue = ((!OptionCompareText) ? ConstantValue.Default(SpecialType.System_Int32) : ConstantValue.Create(1));
					type = ((TypeSymbolExtensions.GetEnumUnderlyingTypeOrSelf(nullableUnderlyingTypeOrSelf).SpecialType != SpecialType.System_Int32) ? GetSpecialType(SpecialType.System_Int32, syntax, diagnostics) : nullableUnderlyingTypeOrSelf);
				}
				else if (specialType != 0)
				{
					type = ((TypeSymbolExtensions.GetEnumUnderlyingTypeOrSelf(nullableUnderlyingTypeOrSelf).SpecialType != specialType) ? GetSpecialType(specialType, syntax, diagnostics) : nullableUnderlyingTypeOrSelf);
				}
				boundExpression = new BoundLiteral(syntax, constantValue, type);
			}
			else if (param.IsOptional)
			{
				if (param.Type.SpecialType == SpecialType.System_Object)
				{
					MethodSymbol methodSymbol = null;
					if (param.IsMarshalAsObject)
					{
						boundExpression = new BoundLiteral(syntax, ConstantValue.Null, null);
					}
					else if (param.IsIDispatchConstant)
					{
						methodSymbol = (MethodSymbol)GetWellKnownTypeMember(WellKnownMember.System_Runtime_InteropServices_DispatchWrapper__ctor, syntax, diagnostics);
					}
					else if (param.IsIUnknownConstant)
					{
						methodSymbol = (MethodSymbol)GetWellKnownTypeMember(WellKnownMember.System_Runtime_InteropServices_UnknownWrapper__ctor, syntax, diagnostics);
					}
					else
					{
						boundExpression = new BoundOmittedArgument(syntax, param.Type);
					}
					if ((object)methodSymbol != null)
					{
						BoundLiteral item = BoundNodeExtensions.MakeCompilerGenerated(new BoundLiteral(syntax, ConstantValue.Null, param.Type));
						boundExpression = new BoundObjectCreationExpression(syntax, methodSymbol, ImmutableArray.Create((BoundExpression)item), null, methodSymbol.ContainingType);
					}
				}
				else
				{
					boundExpression = new BoundLiteral(syntax, ConstantValue.Null, null);
				}
			}
			if (boundExpression == null)
			{
				return null;
			}
			return BoundNodeExtensions.MakeCompilerGenerated(boundExpression);
		}

		private static TextSpan GetCallerLocation(SyntaxNode syntax)
		{
			return VisualBasicExtensions.Kind(syntax) switch
			{
				SyntaxKind.SimpleMemberAccessExpression => ((Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax)syntax).Name.Span, 
				SyntaxKind.DictionaryAccessExpression => ((Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax)syntax).OperatorToken.Span, 
				_ => syntax.Span, 
			};
		}

		private static bool IsCallStatementContext(Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax node)
		{
			VisualBasicSyntaxNode parent = node.Parent;
			if (parent != null && parent.Kind() == SyntaxKind.ConditionalAccessExpression)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax conditionalAccessExpressionSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax)parent;
				if (conditionalAccessExpressionSyntax.WhenNotNull == node)
				{
					parent = conditionalAccessExpressionSyntax.Parent;
				}
			}
			if (parent != null)
			{
				if (parent.Kind() != SyntaxKind.CallStatement)
				{
					return parent.Kind() == SyntaxKind.ExpressionStatement;
				}
				return true;
			}
			return false;
		}

		private BoundExpression BindLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			SourceMemberFlags sourceMemberFlags = DecodeModifiers(node.SubOrFunctionHeader.Modifiers, SourceMemberFlags.Async | SourceMemberFlags.Iterator, ERRID.ERR_InvalidLambdaModifier, Accessibility.Public, diagnostics.DiagnosticBag ?? new DiagnosticBag()).FoundFlags & (SourceMemberFlags.Async | SourceMemberFlags.Iterator);
			if ((sourceMemberFlags & (SourceMemberFlags.Async | SourceMemberFlags.Iterator)) == (SourceMemberFlags.Async | SourceMemberFlags.Iterator) && diagnostics.AccumulatesDiagnostics)
			{
				ReportModifierError(node.SubOrFunctionHeader.Modifiers, ERRID.ERR_InvalidAsyncIteratorModifiers, diagnostics.DiagnosticBag, InvalidModifiers.InvalidAsyncIterator);
			}
			ImmutableArray<ParameterSymbol> parameters = DecodeParameterList(ContainingMember, isFromLambda: true, sourceMemberFlags, node.SubOrFunctionHeader.ParameterList, diagnostics);
			ImmutableArray<ParameterSymbol>.Enumerator enumerator = parameters.GetEnumerator();
			while (enumerator.MoveNext())
			{
				ParameterSymbol current = enumerator.Current;
				SyntaxNodeOrToken syntaxNodeOrToken = ((UnboundLambdaParameterSymbol)current).IdentifierSyntax;
				VerifyNameShadowingInMethodBody(current, syntaxNodeOrToken, syntaxNodeOrToken, diagnostics);
			}
			TypeSymbol typeSymbol = null;
			bool hasErrors = false;
			if (node.Kind() == SyntaxKind.MultiLineFunctionLambdaExpression && node.SubOrFunctionHeader.AsClause != null)
			{
				typeSymbol = BindTypeSyntax(node.SubOrFunctionHeader.AsClause.Type, diagnostics);
				if (TypeSymbolExtensions.IsRestrictedType(typeSymbol))
				{
					ReportDiagnostic(diagnostics, node.SubOrFunctionHeader.AsClause.Type, ERRID.ERR_RestrictedType1, typeSymbol);
					hasErrors = true;
				}
				else if (!TypeSymbolExtensions.IsErrorType(typeSymbol) && (sourceMemberFlags & (SourceMemberFlags.Async | SourceMemberFlags.Iterator)) != (SourceMemberFlags.Async | SourceMemberFlags.Iterator))
				{
					if (sourceMemberFlags == SourceMemberFlags.Async && !typeSymbol.OriginalDefinition.Equals(Compilation.GetWellKnownType(WellKnownType.System_Threading_Tasks_Task_T)) && !typeSymbol.Equals(Compilation.GetWellKnownType(WellKnownType.System_Threading_Tasks_Task)))
					{
						ReportDiagnostic(diagnostics, node.SubOrFunctionHeader.AsClause.Type, ERRID.ERR_BadAsyncReturn);
					}
					if (sourceMemberFlags == SourceMemberFlags.Iterator)
					{
						TypeSymbol originalDefinition = typeSymbol.OriginalDefinition;
						if (originalDefinition.SpecialType != SpecialType.System_Collections_Generic_IEnumerable_T && originalDefinition.SpecialType != SpecialType.System_Collections_Generic_IEnumerator_T && typeSymbol.SpecialType != SpecialType.System_Collections_IEnumerable && typeSymbol.SpecialType != SpecialType.System_Collections_IEnumerator)
						{
							ReportDiagnostic(diagnostics, node.SubOrFunctionHeader.AsClause.Type, ERRID.ERR_BadIteratorReturn);
						}
					}
				}
			}
			else if (node.Kind() == SyntaxKind.MultiLineSubLambdaExpression || node.Kind() == SyntaxKind.SingleLineSubLambdaExpression)
			{
				typeSymbol = GetSpecialType(SpecialType.System_Void, node.SubOrFunctionHeader, diagnostics);
				if (sourceMemberFlags == SourceMemberFlags.Iterator)
				{
					ReportDiagnostic(diagnostics, node.SubOrFunctionHeader.DeclarationKeyword, ERRID.ERR_BadIteratorReturn);
				}
			}
			return new UnboundLambda(node, this, sourceMemberFlags, parameters, typeSymbol, new UnboundLambda.UnboundLambdaBindingCache(diagnostics.AccumulatesDependencies), hasErrors);
		}

		internal ImmutableArray<BoundLambdaParameterSymbol> BuildBoundLambdaParameters(UnboundLambda source, UnboundLambda.TargetSignature targetSignature, BindingDiagnosticBag diagnostics)
		{
			if (source.Parameters.Length == 0)
			{
				return ImmutableArray<BoundLambdaParameterSymbol>.Empty;
			}
			ImmutableArray<ParameterSymbol> parameters = source.Parameters;
			BoundLambdaParameterSymbol[] array = new BoundLambdaParameterSymbol[parameters.Length - 1 + 1];
			int num = Math.Min(array.Length, targetSignature.ParameterTypes.Length);
			int num2 = num - 1;
			for (int i = 0; i <= num2; i++)
			{
				UnboundLambdaParameterSymbol unboundLambdaParameterSymbol = (UnboundLambdaParameterSymbol)parameters[i];
				TypeSymbol typeSymbol = unboundLambdaParameterSymbol.Type;
				TypeSymbol typeSymbol2 = targetSignature.ParameterTypes[i];
				if ((object)typeSymbol == null)
				{
					typeSymbol = typeSymbol2;
					if (!unboundLambdaParameterSymbol.IsByRef && source.Flags != 0 && TypeSymbolExtensions.IsRestrictedType(typeSymbol))
					{
						ReportDiagnostic(diagnostics, unboundLambdaParameterSymbol.IdentifierSyntax, ERRID.ERR_RestrictedResumableType1, typeSymbol);
					}
				}
				array[i] = new BoundLambdaParameterSymbol(unboundLambdaParameterSymbol.Name, unboundLambdaParameterSymbol.Ordinal, typeSymbol, unboundLambdaParameterSymbol.IsByRef, unboundLambdaParameterSymbol.Syntax, unboundLambdaParameterSymbol.Locations[0]);
			}
			if (array.Length != targetSignature.ParameterTypes.Length)
			{
				TypeSymbol typeSymbol3 = null;
				int num3 = array.Length - 1;
				for (int j = num; j <= num3; j++)
				{
					UnboundLambdaParameterSymbol unboundLambdaParameterSymbol2 = (UnboundLambdaParameterSymbol)parameters[j];
					TypeSymbol typeSymbol4 = unboundLambdaParameterSymbol2.Type;
					if ((object)typeSymbol4 == null)
					{
						if ((object)typeSymbol3 == null)
						{
							typeSymbol3 = GetSpecialType(SpecialType.System_Object, unboundLambdaParameterSymbol2.IdentifierSyntax, diagnostics);
						}
						typeSymbol4 = typeSymbol3;
						ReportLambdaParameterInferredToBeObject(unboundLambdaParameterSymbol2, diagnostics);
					}
					array[j] = new BoundLambdaParameterSymbol(unboundLambdaParameterSymbol2.Name, unboundLambdaParameterSymbol2.Ordinal, typeSymbol4, unboundLambdaParameterSymbol2.IsByRef, unboundLambdaParameterSymbol2.Syntax, unboundLambdaParameterSymbol2.Locations[0]);
				}
			}
			return array.AsImmutableOrNull();
		}

		internal BoundLambda BindUnboundLambda(UnboundLambda source, UnboundLambda.TargetSignature target)
		{
			BindingDiagnosticBag bindingDiagnosticBag = BindingDiagnosticBag.GetInstance(withDiagnostics: true, source.WithDependencies);
			TypeSymbol typeSymbol;
			if ((object)source.ReturnType != null)
			{
				typeSymbol = source.ReturnType;
				if (source.IsFunctionLambda && TypeSymbolExtensions.IsVoidType(typeSymbol))
				{
					typeSymbol = LambdaSymbol.ReturnTypeVoidReplacement;
				}
			}
			else if (target.ReturnType.SpecialType != SpecialType.System_Void && ((source.Flags & SourceMemberFlags.Async) == 0 || (object)target.ReturnType != Compilation.GetWellKnownType(WellKnownType.System_Threading_Tasks_Task)) && ((source.Flags & SourceMemberFlags.Iterator) == 0 || (target.ReturnType.SpecialType != SpecialType.System_Collections_IEnumerable && target.ReturnType.SpecialType != SpecialType.System_Collections_IEnumerator)))
			{
				typeSymbol = target.ReturnType;
				if (!TypeSymbolExtensions.IsErrorType(typeSymbol))
				{
					if (source.Flags == SourceMemberFlags.Async && !TypeSymbol.Equals(typeSymbol.OriginalDefinition, Compilation.GetWellKnownType(WellKnownType.System_Threading_Tasks_Task_T), TypeCompareKind.ConsiderEverything))
					{
						ReportDiagnostic(bindingDiagnosticBag, LambdaHeaderErrorNode(source), ERRID.ERR_BadAsyncReturn);
					}
					if (source.Flags == SourceMemberFlags.Iterator)
					{
						TypeSymbol originalDefinition = typeSymbol.OriginalDefinition;
						if (originalDefinition.SpecialType != SpecialType.System_Collections_Generic_IEnumerable_T && originalDefinition.SpecialType != SpecialType.System_Collections_Generic_IEnumerator_T)
						{
							ReportDiagnostic(bindingDiagnosticBag, LambdaHeaderErrorNode(source), ERRID.ERR_BadIteratorReturn);
						}
					}
				}
			}
			else
			{
				UnboundLambda.TargetSignature targetSignature = target;
				if (!TypeSymbolExtensions.IsVoidType(targetSignature.ReturnType))
				{
					targetSignature = new UnboundLambda.TargetSignature(targetSignature.ParameterTypes, targetSignature.ParameterIsByRef, Compilation.GetSpecialType(SpecialType.System_Void), returnsByRef: false);
				}
				KeyValuePair<TypeSymbol, ImmutableBindingDiagnostic<AssemblySymbol>> keyValuePair = source.InferReturnType(targetSignature);
				typeSymbol = keyValuePair.Key;
				bindingDiagnosticBag.AddRange(keyValuePair.Value);
			}
			ImmutableArray<BoundLambdaParameterSymbol> parameters = BuildBoundLambdaParameters(source, target, bindingDiagnosticBag);
			SourceLambdaSymbol sourceLambdaSymbol = new SourceLambdaSymbol(source.Syntax, source, parameters, typeSymbol, this);
			ConversionKind conversionKind = ConversionKind.DelegateRelaxationLevelNone;
			LambdaBodyBinder lambdaBinder = null;
			BoundBlock boundBlock = BindLambdaBody(sourceLambdaSymbol, bindingDiagnosticBag, ref lambdaBinder);
			if (boundBlock.HasErrors || bindingDiagnosticBag.HasAnyErrors())
			{
				conversionKind = ConversionKind.DelegateRelaxationLevelInvalid;
			}
			else if (sourceLambdaSymbol.IsSub)
			{
				conversionKind = ConversionKind.DelegateRelaxationLevelNone;
			}
			else
			{
				bool seenReturnWithAValue = false;
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(bindingDiagnosticBag);
				conversionKind = LambdaRelaxationVisitor.DetermineDelegateRelaxationLevel(sourceLambdaSymbol, source.Flags == SourceMemberFlags.Iterator, boundBlock, out seenReturnWithAValue, ref useSiteInfo);
				((BindingDiagnosticBag<AssemblySymbol>)bindingDiagnosticBag).Add(LambdaHeaderErrorNode(source), useSiteInfo);
				if (!seenReturnWithAValue && sourceLambdaSymbol.IsAsync && conversionKind < ConversionKind.DelegateRelaxationLevelWideningDropReturnOrArgs && sourceLambdaSymbol.ReturnType.OriginalDefinition.Equals(Compilation.GetWellKnownType(WellKnownType.System_Threading_Tasks_Task_T)))
				{
					conversionKind = ConversionKind.DelegateRelaxationLevelWideningDropReturnOrArgs;
				}
			}
			MethodConversionKind methodConversionKind = MethodConversionKind.Error_Unspecified;
			if (conversionKind != ConversionKind.DelegateRelaxationLevelInvalid)
			{
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo2 = GetNewCompoundUseSiteInfo(bindingDiagnosticBag);
				methodConversionKind = Conversions.ClassifyMethodConversionForLambdaOrAnonymousDelegate(target, sourceLambdaSymbol, ref useSiteInfo2);
				if (((BindingDiagnosticBag<AssemblySymbol>)bindingDiagnosticBag).Add(LambdaHeaderErrorNode(source), useSiteInfo2))
				{
					bindingDiagnosticBag = BindingDiagnosticBag.Discarded;
				}
				if (Conversions.IsDelegateRelaxationSupportedFor(methodConversionKind) && Conversions.IsStubRequiredForMethodConversion(methodConversionKind))
				{
					ImmutableArray<ParameterSymbol>.Enumerator enumerator = sourceLambdaSymbol.Parameters.GetEnumerator();
					while (enumerator.MoveNext())
					{
						ParameterSymbol current = enumerator.Current;
						TypeSymbol restrictedType = null;
						if (TypeSymbolExtensions.IsRestrictedTypeOrArrayType(current.Type, out restrictedType))
						{
							ReportDiagnostic(bindingDiagnosticBag, ((UnboundLambdaParameterSymbol)source.Parameters[current.Ordinal]).TypeSyntax, ERRID.ERR_RestrictedType1, restrictedType);
							conversionKind = ConversionKind.DelegateRelaxationLevelInvalid;
							methodConversionKind |= MethodConversionKind.Error_RestrictedType;
							break;
						}
					}
					if (conversionKind != ConversionKind.DelegateRelaxationLevelInvalid)
					{
						TypeSymbol restrictedType2 = null;
						if (TypeSymbolExtensions.IsRestrictedTypeOrArrayType(typeSymbol, out restrictedType2))
						{
							conversionKind = ConversionKind.DelegateRelaxationLevelInvalid;
							methodConversionKind |= MethodConversionKind.Error_RestrictedType;
							if ((object)source.ReturnType == null && target.ReturnType.SpecialType != SpecialType.System_Void)
							{
								ReportDiagnostic(bindingDiagnosticBag, LambdaHeaderErrorNode(source), ERRID.ERR_RestrictedType1, restrictedType2);
							}
						}
					}
				}
				conversionKind = (ConversionKind)Math.Max((int)conversionKind, (int)Conversions.DetermineDelegateRelaxationLevel(methodConversionKind));
			}
			ControlFlowPass.Analyze(new FlowAnalysisInfo(Compilation, sourceLambdaSymbol, boundBlock), bindingDiagnosticBag.DiagnosticBag, suppressConstantExpressionsSupport: true);
			bool flag = bindingDiagnosticBag.HasAnyErrors();
			if (flag)
			{
				conversionKind = ConversionKind.DelegateRelaxationLevelInvalid;
			}
			ImmutableBindingDiagnostic<AssemblySymbol> diagnostics = bindingDiagnosticBag.ToReadOnlyAndFree();
			return new BoundLambda(source.Syntax, sourceLambdaSymbol, boundBlock, diagnostics, lambdaBinder, conversionKind, methodConversionKind, flag);
		}

		private BoundBlock BindLambdaBody(LambdaSymbol lambdaSymbol, BindingDiagnosticBag diagnostics, ref LambdaBodyBinder lambdaBinder)
		{
			Binder binder = null;
			if (!ContainingBinder.OptionExplicit && !ContainingBinder.ImplicitVariableDeclarationAllowed)
			{
				binder = new ImplicitVariableBinder(this, lambdaSymbol);
				lambdaBinder = new LambdaBodyBinder(lambdaSymbol, binder);
			}
			else
			{
				lambdaBinder = new LambdaBodyBinder(lambdaSymbol, this);
			}
			SyntaxNode syntax = lambdaSymbol.Syntax;
			Binder binder2 = lambdaBinder.GetBinder(syntax);
			SyntaxNode syntaxNode = syntax;
			BoundBlock boundBlock;
			switch (VisualBasicExtensions.Kind(syntax))
			{
			case SyntaxKind.SingleLineFunctionLambdaExpression:
			{
				BoundExpression boundExpression = binder2.BindValue((Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)((Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineLambdaExpressionSyntax)syntax).Body, diagnostics);
				if ((object)lambdaSymbol.ReturnType != LambdaSymbol.ReturnTypeIsBeingInferred)
				{
					if ((object)lambdaSymbol.ReturnType != LambdaSymbol.ReturnTypeIsUnknown)
					{
						TypeSymbol typeSymbol = lambdaSymbol.ReturnType;
						if (lambdaSymbol.IsAsync && typeSymbol.OriginalDefinition.Equals(Compilation.GetWellKnownType(WellKnownType.System_Threading_Tasks_Task_T)))
						{
							typeSymbol = ((NamedTypeSymbol)typeSymbol).TypeArgumentsNoUseSiteDiagnostics[0];
						}
						boundExpression = binder2.ApplyImplicitConversion(boundExpression.Syntax, typeSymbol, boundExpression, diagnostics);
					}
					else
					{
						boundExpression = binder2.MakeRValueAndIgnoreDiagnostics(boundExpression);
					}
				}
				BoundReturnStatement boundReturnStatement = new BoundReturnStatement(boundExpression.Syntax, boundExpression, binder2.GetLocalForFunctionValue(), binder2.GetReturnLabel(), boundExpression.HasErrors);
				boundReturnStatement.SetWasCompilerGenerated();
				boundBlock = BoundNodeExtensions.MakeCompilerGenerated(new BoundBlock(syntax, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), ImmutableArray<LocalSymbol>.Empty, ImmutableArray.Create((BoundStatement)boundReturnStatement), boundExpression.HasErrors));
				break;
			}
			case SyntaxKind.SingleLineSubLambdaExpression:
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineLambdaExpressionSyntax singleLineLambdaExpressionSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineLambdaExpressionSyntax)syntax;
				Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax statementSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)singleLineLambdaExpressionSyntax.Body;
				if (statementSyntax.Kind() == SyntaxKind.LocalDeclarationStatement)
				{
					boundBlock = BoundNodeExtensions.MakeCompilerGenerated(binder2.BindBlock(syntax, singleLineLambdaExpressionSyntax.Statements, BindingDiagnosticBag.Discarded));
					ReportDiagnostic(diagnostics, statementSyntax, ERRID.ERR_SubDisallowsStatement);
				}
				else
				{
					boundBlock = BoundNodeExtensions.MakeCompilerGenerated(binder2.BindBlock(syntax, singleLineLambdaExpressionSyntax.Statements, diagnostics));
				}
				break;
			}
			case SyntaxKind.MultiLineFunctionLambdaExpression:
			case SyntaxKind.MultiLineSubLambdaExpression:
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax multiLineLambdaExpressionSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax)syntax;
				syntaxNode = multiLineLambdaExpressionSyntax.EndSubOrFunctionStatement;
				boundBlock = BoundNodeExtensions.MakeCompilerGenerated(binder2.BindBlock(syntax, multiLineLambdaExpressionSyntax.Statements, diagnostics));
				break;
			}
			default:
				throw ExceptionUtilities.UnexpectedValue(VisualBasicExtensions.Kind(syntax));
			}
			ArrayBuilder<LocalSymbol> instance = ArrayBuilder<LocalSymbol>.GetInstance();
			ArrayBuilder<BoundStatement> instance2 = ArrayBuilder<BoundStatement>.GetInstance();
			instance2.AddRange(boundBlock.Statements);
			switch (VisualBasicExtensions.Kind(syntax))
			{
			case SyntaxKind.SingleLineFunctionLambdaExpression:
			case SyntaxKind.MultiLineFunctionLambdaExpression:
			{
				LocalSymbol localForFunctionValue = binder2.GetLocalForFunctionValue();
				instance.Add(localForFunctionValue);
				BoundLabelStatement boundLabelStatement2 = new BoundLabelStatement(syntaxNode, binder2.GetReturnLabel());
				BoundLocal expressionOpt = BoundNodeExtensions.MakeCompilerGenerated(new BoundLocal(syntaxNode, localForFunctionValue, isLValue: false, localForFunctionValue.Type));
				BoundReturnStatement boundReturnStatement3 = new BoundReturnStatement(syntaxNode, expressionOpt, null, null);
				if (VisualBasicExtensions.Kind(syntax) == SyntaxKind.SingleLineFunctionLambdaExpression || syntaxNode == syntax)
				{
					boundLabelStatement2.SetWasCompilerGenerated();
					boundReturnStatement3.SetWasCompilerGenerated();
				}
				instance2.Add(boundLabelStatement2);
				instance2.Add(boundReturnStatement3);
				break;
			}
			case SyntaxKind.SingleLineSubLambdaExpression:
			case SyntaxKind.MultiLineSubLambdaExpression:
			{
				BoundLabelStatement boundLabelStatement = new BoundLabelStatement(syntaxNode, binder2.GetReturnLabel());
				BoundReturnStatement boundReturnStatement2 = new BoundReturnStatement(syntaxNode, null, null, null);
				if (VisualBasicExtensions.Kind(syntax) == SyntaxKind.SingleLineSubLambdaExpression || syntaxNode == syntax)
				{
					boundLabelStatement.SetWasCompilerGenerated();
					boundReturnStatement2.SetWasCompilerGenerated();
				}
				instance2.Add(boundLabelStatement);
				instance2.Add(boundReturnStatement2);
				break;
			}
			}
			if (binder != null)
			{
				binder.DisallowFurtherImplicitVariableDeclaration(diagnostics);
				instance.AddRange(binder.ImplicitlyDeclaredVariables);
			}
			if (!boundBlock.Locals.IsEmpty)
			{
				instance.AddRange(boundBlock.Locals);
			}
			boundBlock = boundBlock.Update(boundBlock.StatementListSyntax, instance.ToImmutableAndFree(), instance2.ToImmutableAndFree());
			boundBlock.SetWasCompilerGenerated();
			if (lambdaSymbol.IsAsync && !CheckAwaitWalker.VisitBlock(binder2, boundBlock, diagnostics) && !boundBlock.HasErrors && !lambdaSymbol.IsIterator)
			{
				ReportDiagnostic(diagnostics, ((Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaExpressionSyntax)syntax).SubOrFunctionHeader.DeclarationKeyword, ERRID.WRN_AsyncLacksAwaits);
			}
			return boundBlock;
		}

		public void ReportLambdaParameterInferredToBeObject(UnboundLambdaParameterSymbol unboundParam, BindingDiagnosticBag diagnostics)
		{
			if (OptionStrict == OptionStrict.On)
			{
				ReportDiagnostic(diagnostics, unboundParam.IdentifierSyntax, ERRID.ERR_StrictDisallowImplicitObjectLambda);
			}
			else if (OptionStrict == OptionStrict.Custom)
			{
				ReportDiagnostic(diagnostics, unboundParam.IdentifierSyntax, ERRID.WRN_ObjectAssumedVar1, ErrorFactory.ErrorInfo(ERRID.WRN_MissingAsClauseinVarDecl));
			}
		}

		public bool Report_ERRID_ReadOnlyInClosure(BoundExpression argument)
		{
			if (argument.HasErrors)
			{
				return false;
			}
			Symbol symbol = ContainingMember;
			if ((object)symbol == null)
			{
				return false;
			}
			FieldSymbol fieldSymbol;
			BoundExpression boundExpression;
			if (argument.Kind == BoundKind.PropertyAccess)
			{
				BoundPropertyAccess boundPropertyAccess = (BoundPropertyAccess)argument;
				if (!(boundPropertyAccess.PropertySymbol is SourcePropertySymbol sourcePropertySymbol) || !sourcePropertySymbol.IsReadOnly)
				{
					return false;
				}
				fieldSymbol = sourcePropertySymbol.AssociatedField;
				boundExpression = boundPropertyAccess.ReceiverOpt;
				if ((object)fieldSymbol == null)
				{
					return false;
				}
			}
			else
			{
				if (argument.Kind != BoundKind.FieldAccess)
				{
					return false;
				}
				BoundFieldAccess obj = (BoundFieldAccess)argument;
				boundExpression = obj.ReceiverOpt;
				fieldSymbol = obj.FieldSymbol;
				boundExpression = obj.ReceiverOpt;
			}
			Binder binder = null;
			if (symbol.IsLambdaMethod)
			{
				Binder binder2 = null;
				do
				{
					binder2 = ((LambdaSymbol)symbol).ContainingBinder;
					symbol = symbol.ContainingSymbol;
				}
				while ((object)symbol != null && symbol.IsLambdaMethod);
				MethodKind methodKind = binder2.KindOfContainingMethodAtRunTime();
				if (methodKind == MethodKind.Constructor || methodKind == MethodKind.StaticConstructor)
				{
					binder = binder2;
				}
			}
			if (binder == null)
			{
				return false;
			}
			if (boundExpression == null || boundExpression.Kind != BoundKind.FieldAccess)
			{
				return binder.IsLValueFieldAccess(fieldSymbol, boundExpression);
			}
			ArrayBuilder<FieldSymbol> instance = ArrayBuilder<FieldSymbol>.GetInstance();
			instance.Add(fieldSymbol);
			do
			{
				BoundFieldAccess boundFieldAccess = (BoundFieldAccess)boundExpression;
				instance.Add(boundFieldAccess.FieldSymbol);
				boundExpression = boundFieldAccess.ReceiverOpt;
			}
			while (boundExpression != null && boundExpression.Kind == BoundKind.FieldAccess);
			for (int i = instance.Count - 1; i >= 0; i += -1)
			{
				FieldSymbol fieldSymbol2 = instance[i];
				boundExpression = new BoundFieldAccess(argument.Syntax, boundExpression, fieldSymbol2, binder.IsLValueFieldAccess(fieldSymbol2, boundExpression), fieldSymbol2.Type);
			}
			instance.Free();
			return boundExpression.IsLValue;
		}

		internal KeyValuePair<NamedTypeSymbol, ImmutableBindingDiagnostic<AssemblySymbol>> InferAnonymousDelegateForLambda(UnboundLambda source)
		{
			BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(withDiagnostics: true, source.WithDependencies);
			UnboundLambda.TargetSignature targetSignature = new UnboundLambda.TargetSignature(ImmutableArray<ParameterSymbol>.Empty, Compilation.GetSpecialType(SpecialType.System_Void), returnsByRef: false);
			ImmutableArray<BoundLambdaParameterSymbol> immutableArray = BuildBoundLambdaParameters(source, targetSignature, instance);
			KeyValuePair<TypeSymbol, ImmutableBindingDiagnostic<AssemblySymbol>> keyValuePair = source.InferReturnType(new UnboundLambda.TargetSignature(StaticCast<ParameterSymbol>.From(immutableArray), targetSignature.ReturnType, targetSignature.ReturnsByRef));
			TypeSymbol key = keyValuePair.Key;
			instance.AddRange(keyValuePair.Value);
			NamedTypeSymbol key2 = ConstructAnonymousDelegateSymbol(source, immutableArray, key, instance);
			return new KeyValuePair<NamedTypeSymbol, ImmutableBindingDiagnostic<AssemblySymbol>>(key2, instance.ToReadOnlyAndFree());
		}

		private NamedTypeSymbol ConstructAnonymousDelegateSymbol(UnboundLambda source, ImmutableArray<BoundLambdaParameterSymbol> parameters, TypeSymbol returnType, BindingDiagnosticBag diagnostics)
		{
			AnonymousTypeField[] array = new AnonymousTypeField[parameters.Length + 1];
			int num = parameters.Length - 1;
			int i;
			for (i = 0; i <= num; i++)
			{
				UnboundLambdaParameterSymbol unboundLambdaParameterSymbol = (UnboundLambdaParameterSymbol)source.Parameters[i];
				array[i] = new AnonymousTypeField(parameters[i].Name, parameters[i].Type, unboundLambdaParameterSymbol.Syntax.GetLocation(), parameters[i].IsByRef);
				if (TypeSymbolExtensions.IsRestrictedType(parameters[i].Type))
				{
					ReportDiagnostic(diagnostics, unboundLambdaParameterSymbol.TypeSyntax, ERRID.ERR_RestrictedType1, parameters[i].Type);
				}
			}
			string returnParameterName = AnonymousTypeDescriptor.GetReturnParameterName(source.IsFunctionLambda);
			array[i] = new AnonymousTypeField(returnParameterName, returnType, source.Syntax.GetLocation());
			AnonymousTypeDescriptor delegateDescriptor = new AnonymousTypeDescriptor(array.AsImmutableOrNull(), source.Syntax.GetLocation(), isImplicitlyDeclared: true);
			return Compilation.AnonymousTypeManager.ConstructAnonymousDelegateSymbol(delegateDescriptor);
		}

		internal BoundLambda BindLambdaForErrorRecovery(UnboundLambda source)
		{
			if (source.BindingCache.ErrorRecoverySignature == null)
			{
				TypeSymbol result = null;
				TypeSymbol[] array = new TypeSymbol[source.Parameters.Length - 1 + 1];
				foreach (KeyValuePair<UnboundLambda.TargetSignature, KeyValuePair<TypeSymbol, ImmutableBindingDiagnostic<AssemblySymbol>>> item in source.BindingCache.InferredReturnType)
				{
					UnboundLambda.TargetSignature key = item.Key;
					int num = Math.Min(key.ParameterTypes.Length, array.Length) - 1;
					for (int i = 0; i <= num; i++)
					{
						BindLambdaForErrorRecoveryInferCommonType(ref array[i], key.ParameterTypes[i]);
					}
					BindLambdaForErrorRecoveryInferCommonType(ref result, item.Value.Key);
				}
				foreach (KeyValuePair<UnboundLambda.TargetSignature, BoundLambda> boundLambda in source.BindingCache.BoundLambdas)
				{
					UnboundLambda.TargetSignature key2 = boundLambda.Key;
					int num2 = Math.Min(key2.ParameterTypes.Length, array.Length) - 1;
					for (int j = 0; j <= num2; j++)
					{
						BindLambdaForErrorRecoveryInferCommonType(ref array[j], key2.ParameterTypes[j]);
					}
					BindLambdaForErrorRecoveryInferCommonType(ref result, key2.ReturnType);
				}
				BitVector empty = BitVector.Empty;
				int num3 = array.Length - 1;
				for (int k = 0; k <= num3; k++)
				{
					if ((object)source.Parameters[k].Type != null)
					{
						array[k] = source.Parameters[k].Type;
					}
					else if ((object)array[k] == null || (object)array[k] == LambdaSymbol.ErrorRecoveryInferenceError)
					{
						array[k] = Compilation.GetSpecialType(SpecialType.System_Object);
					}
					if (source.Parameters[k].IsByRef)
					{
						empty[k] = true;
					}
				}
				if ((object)source.ReturnType != null)
				{
					result = ((source.IsFunctionLambda && TypeSymbolExtensions.IsVoidType(source.ReturnType)) ? LambdaSymbol.ReturnTypeVoidReplacement : source.ReturnType);
				}
				else if ((object)result == null || (object)result == LambdaSymbol.ErrorRecoveryInferenceError)
				{
					result = source.InferReturnType(new UnboundLambda.TargetSignature(array.AsImmutableOrNull(), empty, Compilation.GetSpecialType(SpecialType.System_Void), returnsByRef: false)).Key;
				}
				Interlocked.CompareExchange(ref source.BindingCache.ErrorRecoverySignature, new UnboundLambda.TargetSignature(array.AsImmutableOrNull(), empty, result, returnsByRef: false), null);
			}
			return source.Bind(source.BindingCache.ErrorRecoverySignature);
		}

		private static void BindLambdaForErrorRecoveryInferCommonType(ref TypeSymbol result, TypeSymbol candidate)
		{
			if ((object)result == null)
			{
				result = candidate;
			}
			else if ((object)result != LambdaSymbol.ErrorRecoveryInferenceError && !TypeSymbolExtensions.IsSameTypeIgnoringAll(result, candidate))
			{
				result = LambdaSymbol.ErrorRecoveryInferenceError;
			}
		}

		internal KeyValuePair<TypeSymbol, ImmutableBindingDiagnostic<AssemblySymbol>> InferFunctionLambdaReturnType(UnboundLambda source, UnboundLambda.TargetSignature targetParameters)
		{
			KeyValuePair<TypeSymbol, ImmutableBindingDiagnostic<AssemblySymbol>> result;
			if (source.Flags == (SourceMemberFlags.Async | SourceMemberFlags.Iterator))
			{
				result = new KeyValuePair<TypeSymbol, ImmutableBindingDiagnostic<AssemblySymbol>>(LambdaSymbol.ReturnTypeIsUnknown, ImmutableBindingDiagnostic<AssemblySymbol>.Empty);
			}
			else
			{
				BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(withDiagnostics: true, source.WithDependencies);
				ImmutableArray<BoundLambdaParameterSymbol> parameters = BuildBoundLambdaParameters(source, targetParameters, instance);
				SourceLambdaSymbol lambdaSymbol = new SourceLambdaSymbol(source.Syntax, source, parameters, LambdaSymbol.ReturnTypeIsBeingInferred, this);
				LambdaBodyBinder lambdaBinder = null;
				BoundBlock boundBlock = BindLambdaBody(lambdaSymbol, instance, ref lambdaBinder);
				if (boundBlock.HasErrors || instance.HasAnyErrors())
				{
					result = new KeyValuePair<TypeSymbol, ImmutableBindingDiagnostic<AssemblySymbol>>(LambdaSymbol.ReturnTypeIsUnknown, instance.ToReadOnlyAndFree());
				}
				else
				{
					instance.Clear();
					ArrayBuilder<BoundExpression> instance2 = ArrayBuilder<BoundExpression>.GetInstance();
					LambdaReturnStatementsVisitor.CollectReturnExpressions(boundBlock, instance2, source.Flags == SourceMemberFlags.Iterator);
					TypeSymbol typeSymbol;
					if (instance2.Count == 0 && source.Flags == SourceMemberFlags.Async)
					{
						typeSymbol = GetWellKnownType(WellKnownType.System_Threading_Tasks_Task, source.Syntax, instance);
					}
					else if (instance2.Count == 0 && source.Flags == SourceMemberFlags.Iterator)
					{
						typeSymbol = GetSpecialType(SpecialType.System_Collections_Generic_IEnumerable_T, source.Syntax, instance).Construct(GetSpecialType(SpecialType.System_Object, source.Syntax, instance));
					}
					else
					{
						if (source.IsSingleLine)
						{
							BoundExpression boundExpression = null;
							if (instance2.Count > 0)
							{
								boundExpression = MakeRValue(instance2[0], instance);
							}
							typeSymbol = ((boundExpression == null || boundExpression.HasErrors || instance.HasAnyErrors()) ? GetSpecialType(SpecialType.System_Object, source.Syntax, instance) : boundExpression.Type);
							instance.Clear();
							TypeSymbol restrictedType = null;
							if (TypeSymbolExtensions.IsRestrictedTypeOrArrayType(typeSymbol, out restrictedType))
							{
								ReportDiagnostic(instance, LambdaHeaderErrorNode(source), ERRID.ERR_RestrictedType1, restrictedType);
							}
						}
						else
						{
							int numCandidates = 0;
							SyntaxNode syntax = source.Syntax;
							InferenceErrorReasons errorReasons = InferenceErrorReasons.Other;
							typeSymbol = InferDominantTypeOfExpressions(syntax, instance2, instance, ref numCandidates, ref errorReasons);
							TypeSymbol restrictedType2 = null;
							if ((object)typeSymbol == null)
							{
								ReportDiagnostic(instance, LambdaHeaderErrorNode(source), ERRID.ERR_LambdaNoType);
								typeSymbol = LambdaSymbol.ReturnTypeIsUnknown;
							}
							else if (TypeSymbolExtensions.IsRestrictedTypeOrArrayType(typeSymbol, out restrictedType2))
							{
								ReportDiagnostic(instance, LambdaHeaderErrorNode(source), ERRID.ERR_RestrictedType1, restrictedType2);
							}
							else if (numCandidates != 1)
							{
								if (OptionStrict == OptionStrict.On)
								{
									if (numCandidates == 0)
									{
										ReportDiagnostic(instance, LambdaHeaderErrorNode(source), ERRID.ERR_LambdaNoTypeObjectDisallowed);
									}
									else
									{
										ReportDiagnostic(instance, LambdaHeaderErrorNode(source), ERRID.ERR_LambdaTooManyTypesObjectDisallowed);
									}
								}
								else if (OptionStrict == OptionStrict.Custom)
								{
									if (numCandidates == 0)
									{
										ReportDiagnostic(instance, LambdaHeaderErrorNode(source), ERRID.WRN_ObjectAssumed1, ErrorFactory.ErrorInfo(ERRID.WRN_LambdaNoTypeObjectAssumed));
									}
									else
									{
										ReportDiagnostic(instance, LambdaHeaderErrorNode(source), ERRID.WRN_ObjectAssumed1, ErrorFactory.ErrorInfo(ERRID.WRN_LambdaTooManyTypesObjectAssumed));
									}
								}
							}
						}
						if (source.Flags == SourceMemberFlags.Async)
						{
							typeSymbol = GetWellKnownType(WellKnownType.System_Threading_Tasks_Task_T, source.Syntax, instance).Construct(typeSymbol);
						}
						else if (source.Flags == SourceMemberFlags.Iterator)
						{
							typeSymbol = GetSpecialType(SpecialType.System_Collections_Generic_IEnumerable_T, source.Syntax, instance).Construct(typeSymbol);
						}
					}
					instance2.Free();
					result = new KeyValuePair<TypeSymbol, ImmutableBindingDiagnostic<AssemblySymbol>>(typeSymbol, instance.ToReadOnlyAndFree());
				}
			}
			return result;
		}

		private static SyntaxNode LambdaHeaderErrorNode(UnboundLambda source)
		{
			if (source.Syntax is Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaExpressionSyntax lambdaExpressionSyntax)
			{
				return lambdaExpressionSyntax.SubOrFunctionHeader;
			}
			return source.Syntax;
		}

		private BoundExpression BindLateBoundMemberAccess(SyntaxNode node, string name, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax typeArguments, BoundExpression receiver, TypeSymbol containerType, BindingDiagnosticBag diagnostics)
		{
			BoundTypeArguments boundTypeArguments = BindTypeArguments(typeArguments, diagnostics);
			return BindLateBoundMemberAccess(node, name, boundTypeArguments, receiver, containerType, diagnostics);
		}

		private BoundExpression BindLateBoundMemberAccess(SyntaxNode node, string name, BoundTypeArguments boundTypeArguments, BoundExpression receiver, TypeSymbol containerType, BindingDiagnosticBag diagnostics, bool suppressLateBindingResolutionDiagnostics = false)
		{
			receiver = AdjustReceiverAmbiguousTypeOrValue(receiver, diagnostics);
			if (OptionStrict == OptionStrict.On)
			{
				if (!suppressLateBindingResolutionDiagnostics)
				{
					ReportDiagnostic(diagnostics, node, ERRID.ERR_StrictDisallowsLateBinding);
				}
				ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
				if (receiver != null)
				{
					instance.Add(receiver);
				}
				if (boundTypeArguments != null)
				{
					instance.Add(boundTypeArguments);
				}
				return BadExpression(node, instance.ToImmutableAndFree(), ErrorTypeSymbol.UnknownResultType);
			}
			if (OptionStrict == OptionStrict.Custom && !suppressLateBindingResolutionDiagnostics)
			{
				ReportDiagnostic(diagnostics, node, ERRID.WRN_LateBindingResolution);
			}
			NamedTypeSymbol specialType = GetSpecialType(SpecialType.System_Object, node, diagnostics);
			if (receiver != null && receiver.Kind == BoundKind.MeReference && (IsMeOrMyBaseOrMyClassInSharedContext() || IsInsideChainedConstructorCallArguments))
			{
				receiver = null;
			}
			if (receiver != null && !receiver.IsLValue)
			{
				receiver = MakeRValue(receiver, diagnostics);
			}
			return new BoundLateMemberAccess(node, name, containerType, receiver, boundTypeArguments, LateBoundAccessKind.Unknown, specialType);
		}

		private BoundExpression BindLateBoundInvocation(SyntaxNode node, BoundMethodOrPropertyGroup group, bool isDefaultMemberAccess, ImmutableArray<BoundExpression> arguments, ImmutableArray<string> argumentNames, BindingDiagnosticBag diagnostics)
		{
			string text = (isDefaultMemberAccess ? null : group.MemberName);
			BoundTypeArguments boundTypeArguments = BoundExpressionExtensions.TypeArguments(group);
			TypeSymbol containerOfFirstInGroup = group.ContainerOfFirstInGroup;
			BoundExpression boundExpression = AdjustReceiverAmbiguousTypeOrValue(ref group, diagnostics);
			if (boundExpression != null && (boundExpression.Kind == BoundKind.TypeExpression || boundExpression.Kind == BoundKind.NamespaceExpression))
			{
				boundExpression = null;
			}
			SyntaxNode node2 = ((!(node is Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax invocationExpressionSyntax)) ? node : (invocationExpressionSyntax.Expression ?? group.Syntax));
			BoundExpression boundExpression2 = BindLateBoundMemberAccess(node2, text, boundTypeArguments, boundExpression, containerOfFirstInGroup, diagnostics, suppressLateBindingResolutionDiagnostics: true);
			if (group.WasCompilerGenerated)
			{
				boundExpression2.SetWasCompilerGenerated();
			}
			if (boundExpression != null && (object)boundExpression.Type != null && TypeSymbolExtensions.IsInterfaceType(boundExpression.Type))
			{
				ReportDiagnostic(diagnostics, GetLocationForOverloadResolutionDiagnostic(node, group), ERRID.ERR_LateBoundOverloadInterfaceCall1, text);
			}
			return BindLateBoundInvocation(node, group, boundExpression2, arguments, argumentNames, diagnostics);
		}

		internal BoundExpression BindLateBoundInvocation(SyntaxNode node, BoundMethodOrPropertyGroup groupOpt, BoundExpression receiver, ImmutableArray<BoundExpression> arguments, ImmutableArray<string> argumentNames, BindingDiagnosticBag diagnostics, bool suppressLateBindingResolutionDiagnostics = false)
		{
			if (BoundExpressionExtensions.IsNothingLiteral(receiver))
			{
				ReportDiagnostic(diagnostics, node, ERRID.ERR_IllegalCallOrIndex);
				return BadExpression(node, arguments, ErrorTypeSymbol.UnknownResultType);
			}
			if (OptionStrict == OptionStrict.On)
			{
				ReportDiagnostic(diagnostics, GetLocationForOverloadResolutionDiagnostic(node, groupOpt), ERRID.ERR_StrictDisallowsLateBinding);
				ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
				if (receiver != null)
				{
					instance.Add(receiver);
				}
				if (!arguments.IsEmpty)
				{
					instance.AddRange(arguments);
				}
				return BadExpression(node, instance.ToImmutableAndFree(), ErrorTypeSymbol.UnknownResultType);
			}
			if (OptionStrict == OptionStrict.Custom && !suppressLateBindingResolutionDiagnostics)
			{
				ReportDiagnostic(diagnostics, GetLocationForOverloadResolutionDiagnostic(node, groupOpt), ERRID.WRN_LateBindingResolution);
			}
			bool flag = receiver != null && receiver.Kind != BoundKind.LateMemberAccess;
			NamedTypeSymbol specialType = GetSpecialType(SpecialType.System_Object, node, diagnostics);
			if (!arguments.IsEmpty)
			{
				CheckNamedArgumentsForLateboundInvocation(argumentNames, arguments, diagnostics);
				ArrayBuilder<BoundExpression> arrayBuilder = null;
				int num = arguments.Length - 1;
				for (int i = 0; i <= num; i++)
				{
					BoundExpression boundExpression = arguments[i];
					BoundExpression boundExpression2 = boundExpression;
					if (boundExpression2.Kind == BoundKind.OmittedArgument)
					{
						boundExpression2 = ((BoundOmittedArgument)boundExpression2).Update(GetSpecialType(SpecialType.System_Object, boundExpression2.Syntax, diagnostics));
					}
					if (!flag)
					{
						BoundExpressionExtensions.IsSupportingAssignment(boundExpression2);
					}
					else
						_ = 0;
					if (flag || !BoundExpressionExtensions.IsSupportingAssignment(boundExpression2))
					{
						boundExpression2 = ApplyImplicitConversion(boundExpression2.Syntax, specialType, boundExpression2, diagnostics);
					}
					if (arrayBuilder != null)
					{
						arrayBuilder.Add(boundExpression2);
					}
					else if (boundExpression2 != boundExpression)
					{
						arrayBuilder = ArrayBuilder<BoundExpression>.GetInstance(arguments.Length);
						int num2 = i - 1;
						for (int j = 0; j <= num2; j++)
						{
							arrayBuilder.Add(arguments[j]);
						}
						arrayBuilder.Add(boundExpression2);
					}
				}
				if (arrayBuilder != null)
				{
					arguments = arrayBuilder.ToImmutableAndFree();
				}
			}
			if (receiver != null && receiver.Kind == BoundKind.MeReference && (IsMeOrMyBaseOrMyClassInSharedContext() || IsInsideChainedConstructorCallArguments))
			{
				receiver = null;
			}
			if (receiver != null && !receiver.IsLValue && receiver.Kind != BoundKind.LateMemberAccess)
			{
				receiver = MakeRValue(receiver, diagnostics);
			}
			NamedTypeSymbol specialType2 = GetSpecialType(SpecialType.System_Object, node, diagnostics);
			return new BoundLateInvocation(node, receiver, arguments, argumentNames, LateBoundAccessKind.Unknown, groupOpt, specialType2);
		}

		private void CheckNamedArgumentsForLateboundInvocation(ImmutableArray<string> argumentNames, ImmutableArray<BoundExpression> arguments, BindingDiagnosticBag diagnostics)
		{
			if (argumentNames.IsDefault || argumentNames.Length == 0 || !LanguageVersionFacts.AllowNonTrailingNamedArguments(Compilation.LanguageVersion))
			{
				return;
			}
			bool flag = false;
			int num = argumentNames.Length - 1;
			for (int i = 0; i <= num; i++)
			{
				if (argumentNames[i] != null)
				{
					flag = true;
				}
				else if (flag)
				{
					ReportDiagnostic(diagnostics, arguments[i].Syntax, ERRID.ERR_NamedArgumentSpecificationBeforeFixedArgumentInLateboundInvocation);
					break;
				}
			}
		}

		internal void LookupMember(LookupResult lookupResult, NamespaceOrTypeSymbol container, string name, int arity, LookupOptions options, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			options = BinderSpecificLookupOptions(options);
			MemberLookup.Lookup(lookupResult, container, name, arity, options, this, ref useSiteInfo);
		}

		internal void LookupMember(LookupResult lookupResult, TypeSymbol container, string name, int arity, LookupOptions options, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			options = BinderSpecificLookupOptions(options);
			LookupResult instance = LookupResult.GetInstance();
			MemberLookup.Lookup(lookupResult, container, name, arity, options, this, instance, ref useSiteInfo);
			instance.Free();
		}

		internal void LookupMember(LookupResult lookupResult, NamespaceSymbol container, string name, int arity, LookupOptions options, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			options = BinderSpecificLookupOptions(options);
			MemberLookup.Lookup(lookupResult, container, name, arity, options, this, ref useSiteInfo);
		}

		internal void LookupMemberImmediate(LookupResult lookupResult, NamespaceSymbol container, string name, int arity, LookupOptions options, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			options = BinderSpecificLookupOptions(options);
			MemberLookup.LookupImmediate(lookupResult, container, name, arity, options, this, ref useSiteInfo);
		}

		internal void LookupExtensionMethods(LookupResult lookupResult, TypeSymbol container, string name, int arity, LookupOptions options, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			options = BinderSpecificLookupOptions(options);
			MemberLookup.LookupForExtensionMethods(lookupResult, container, name, arity, options, this, ref useSiteInfo);
		}

		internal void LookupMemberInModules(LookupResult lookupResult, NamespaceSymbol container, string name, int arity, LookupOptions options, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			options = BinderSpecificLookupOptions(options);
			MemberLookup.LookupInModules(lookupResult, container, name, arity, options, this, ref useSiteInfo);
		}

		internal void AddMemberLookupSymbolsInfo(LookupSymbolsInfo nameSet, NamespaceOrTypeSymbol container, LookupOptions options)
		{
			options = BinderSpecificLookupOptions(options);
			MemberLookup.AddLookupSymbolsInfo(nameSet, container, options, this);
		}

		internal SingleLookupResult CheckViability(Symbol sym, int arity, LookupOptions options, TypeSymbol accessThroughType, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			if (!sym.CanBeReferencedByNameIgnoringIllegalCharacters)
			{
				return SingleLookupResult.Empty;
			}
			if ((options & LookupOptions.LabelsOnly) != 0)
			{
				if (options == LookupOptions.LabelsOnly && sym.Kind == SymbolKind.Label)
				{
					return SingleLookupResult.Good(sym);
				}
				return SingleLookupResult.Empty;
			}
			if ((options & LookupOptions.MustNotBeReturnValueVariable) != 0 && sym.Kind == SymbolKind.Local && ((LocalSymbol)sym).IsFunctionValue)
			{
				return SingleLookupResult.Empty;
			}
			Symbol symbol = sym;
			if (sym is AliasSymbol aliasSymbol)
			{
				symbol = aliasSymbol.Target;
			}
			if ((object)symbol.ContainingModule != ContainingModule && (SymbolExtensions.IsHiddenByVisualBasicEmbeddedAttribute(symbol) || SymbolExtensions.IsHiddenByCodeAnalysisEmbeddedAttribute(symbol)))
			{
				return SingleLookupResult.Empty;
			}
			if (symbol.Kind == SymbolKind.NamedType && symbol.EmbeddedSymbolKind == EmbeddedSymbolKind.EmbeddedAttribute && SyntaxTree != null && EmbeddedSymbolExtensions.GetEmbeddedKind(SyntaxTree) == EmbeddedSymbolKind.None && !Compilation.Options.EmbedVbCoreRuntime)
			{
				return SingleLookupResult.Empty;
			}
			if (arity != -1)
			{
				switch (sym.Kind)
				{
				case SymbolKind.ErrorType:
				case SymbolKind.NamedType:
				{
					int arity3 = ((NamedTypeSymbol)sym).Arity;
					if (arity3 != arity)
					{
						return SingleLookupResult.WrongArity(sym, WrongArityErrid(arity3, arity));
					}
					break;
				}
				case SymbolKind.Namespace:
				case SymbolKind.TypeParameter:
					if (arity != 0)
					{
						return SingleLookupResult.WrongArity(symbol, WrongArityErrid(0, arity));
					}
					break;
				case SymbolKind.Alias:
					if (arity != 0)
					{
						return SingleLookupResult.WrongArity(symbol, WrongArityErrid(0, arity));
					}
					break;
				case SymbolKind.Method:
				{
					int arity2 = ((MethodSymbol)sym).Arity;
					if (arity2 != arity && (options & LookupOptions.AllMethodsOfAnyArity) == 0)
					{
						return SingleLookupResult.WrongArityAndStopLookup(sym, WrongArityErrid(arity2, arity));
					}
					break;
				}
				default:
					if (arity != 0)
					{
						return SingleLookupResult.WrongArityAndStopLookup(sym, WrongArityErrid(0, arity));
					}
					break;
				}
			}
			if ((options & LookupOptions.IgnoreAccessibility) == 0 && CheckAccessibility(symbol, ref useSiteInfo, ((options & LookupOptions.UseBaseReferenceAccessibility) != 0) ? null : accessThroughType) != 0)
			{
				return SingleLookupResult.Inaccessible(sym, GetInaccessibleErrorInfo(sym));
			}
			if ((options & LookupOptions.MustNotBeInstance) != 0 && SymbolExtensions.IsInstanceMember(sym))
			{
				return SingleLookupResult.MustNotBeInstance(sym, ERRID.ERR_ObjectReferenceNotSupplied);
			}
			if ((options & LookupOptions.MustBeInstance) != 0 && !SymbolExtensions.IsInstanceMember(sym))
			{
				return SingleLookupResult.MustBeInstance(sym);
			}
			return SingleLookupResult.Good(sym);
		}

		internal DiagnosticInfo GetInaccessibleErrorInfo(Symbol sym)
		{
			Symbol symbol = sym;
			if (sym is AliasSymbol aliasSymbol)
			{
				symbol = aliasSymbol.Target;
			}
			else if (sym.Kind == SymbolKind.Method)
			{
				sym = ((MethodSymbol)sym).ConstructedFrom;
			}
			if (symbol.Kind == SymbolKind.Method && (object)symbol.ContainingSymbol != null)
			{
				return new BadSymbolDiagnostic(sym, ERRID.ERR_InaccessibleMember3, sym.ContainingSymbol.Name, sym, AccessCheck.GetAccessibilityForErrorMessage(sym, Compilation.Assembly));
			}
			return new BadSymbolDiagnostic(sym, ERRID.ERR_InaccessibleSymbol2, CustomSymbolDisplayFormatter.QualifiedName(sym), AccessCheck.GetAccessibilityForErrorMessage(sym, sym.ContainingAssembly));
		}

		internal bool CanAddLookupSymbolInfo(Symbol sym, LookupOptions options, LookupSymbolsInfo nameSet, TypeSymbol accessThroughType)
		{
			if (!nameSet.CanBeAdded(sym.Name))
			{
				return false;
			}
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
			SingleLookupResult singleLookupResult = CheckViability(sym, -1, options, accessThroughType, ref useSiteInfo);
			if ((options & LookupOptions.MethodsOnly) != 0 && sym.Kind != SymbolKind.Method)
			{
				return false;
			}
			if (singleLookupResult.IsGoodOrAmbiguous)
			{
				return true;
			}
			return false;
		}

		private static ERRID WrongArityErrid(int actualArity, int arity)
		{
			if (actualArity < arity)
			{
				if (actualArity == 0)
				{
					return ERRID.ERR_TypeOrMemberNotGeneric1;
				}
				return ERRID.ERR_TooManyGenericArguments1;
			}
			return ERRID.ERR_TooFewGenericArguments1;
		}

		private BoundExpression BindObjectCreationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			DisallowNewOnTupleType(node.Type, diagnostics);
			TypeSymbol typeSymbol = BindTypeSyntax(node.Type, diagnostics);
			if (TypeSymbolExtensions.IsErrorType(typeSymbol))
			{
				if (!(typeSymbol is ExtendedErrorTypeSymbol extendedErrorTypeSymbol) || extendedErrorTypeSymbol.CandidateSymbols.Length != 1 || extendedErrorTypeSymbol.CandidateSymbols[0].Kind != SymbolKind.NamedType)
				{
					BindingDiagnosticBag discarded = BindingDiagnosticBag.Discarded;
					ImmutableArray<BoundExpression> boundArguments = default(ImmutableArray<BoundExpression>);
					ImmutableArray<string> argumentNames = default(ImmutableArray<string>);
					ImmutableArray<Location> argumentNamesLocations = default(ImmutableArray<Location>);
					BindArgumentsAndNames(node.ArgumentList, ref boundArguments, ref argumentNames, ref argumentNamesLocations, discarded);
					ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
					ImmutableArray<BoundExpression>.Enumerator enumerator = boundArguments.GetEnumerator();
					while (enumerator.MoveNext())
					{
						BoundExpression current = enumerator.Current;
						instance.Add(MakeRValueAndIgnoreDiagnostics(current));
					}
					BoundExpression boundExpression = BindObjectCollectionOrMemberInitializer(node, typeSymbol, null, discarded);
					if (boundExpression != null)
					{
						instance.Add(boundExpression);
					}
					discarded.Free();
					return BadExpression(node, instance.ToImmutableAndFree(), typeSymbol);
				}
				typeSymbol = (TypeSymbol)extendedErrorTypeSymbol.CandidateSymbols[0];
				diagnostics = BindingDiagnosticBag.Discarded;
			}
			return BindObjectCreationExpression(node.Type, node.ArgumentList, typeSymbol, node, diagnostics, null);
		}

		private static void DisallowNewOnTupleType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type, BindingDiagnosticBag diagnostics)
		{
			if (type.Kind() == SyntaxKind.TupleType)
			{
				diagnostics.Add(ERRID.ERR_NewWithTupleTypeSyntax, type.Location);
			}
		}

		internal BoundExpression BindObjectCreationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax typeNode, Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax argumentListOpt, TypeSymbol type0, Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax node, BindingDiagnosticBag diagnostics, BoundWithLValueExpressionPlaceholder asNewVariablePlaceholderOpt)
		{
			switch (type0.TypeKind)
			{
			case TypeKind.Delegate:
				return BindDelegateCreationExpression(type0, argumentListOpt, node, diagnostics);
			case TypeKind.Struct:
			{
				if (argumentListOpt != null && argumentListOpt.Arguments.Count != 0)
				{
					break;
				}
				MethodSymbol methodSymbol = null;
				ImmutableArray<MethodSymbol> instanceConstructors = ((NamedTypeSymbol)type0).InstanceConstructors;
				if (!instanceConstructors.IsEmpty)
				{
					ImmutableArray<MethodSymbol>.Enumerator enumerator = instanceConstructors.GetEnumerator();
					while (enumerator.MoveNext())
					{
						MethodSymbol current = enumerator.Current;
						if (current.ParameterCount == 0)
						{
							CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
							if (IsAccessible(current, ref useSiteInfo))
							{
								methodSymbol = current;
								ReportUseSite(diagnostics, node, methodSymbol);
							}
							((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)node, useSiteInfo);
							break;
						}
					}
				}
				return new BoundObjectCreationExpression(node, methodSymbol, ((object)methodSymbol == null) ? null : new BoundMethodGroup(typeNode, null, ImmutableArray.Create(methodSymbol), LookupResultKind.Good, null, QualificationKind.QualifiedViaTypeName), ImmutableArray<BoundExpression>.Empty, BitVector.Null, BindObjectCollectionOrMemberInitializer(node, type0, asNewVariablePlaceholderOpt, diagnostics), type0);
			}
			}
			ImmutableArray<BoundExpression> boundArguments = default(ImmutableArray<BoundExpression>);
			ImmutableArray<string> argumentNames = default(ImmutableArray<string>);
			ImmutableArray<Location> argumentNamesLocations = default(ImmutableArray<Location>);
			BindArgumentsAndNames(argumentListOpt, ref boundArguments, ref argumentNames, ref argumentNamesLocations, diagnostics);
			BoundObjectInitializerExpressionBase objectInitializerExpressionOpt = BindObjectCollectionOrMemberInitializer(node, type0, asNewVariablePlaceholderOpt, diagnostics);
			return BindObjectCreationExpression(typeNode, argumentListOpt, type0, node, boundArguments, argumentNames, objectInitializerExpressionOpt, diagnostics, typeNode);
		}

		internal BoundExpression BindObjectCreationExpression(SyntaxNode syntax, TypeSymbol type, ImmutableArray<BoundExpression> arguments, BindingDiagnosticBag diagnostics)
		{
			return BindObjectCreationExpression(syntax, null, type, syntax, arguments, default(ImmutableArray<string>), null, diagnostics, null);
		}

		private static ImmutableArray<BoundExpression> MergeBoundChildNodesWithObjectInitializerForBadNode(ImmutableArray<BoundExpression> boundArguments, BoundObjectInitializerExpressionBase objectInitializerExpression)
		{
			ImmutableArray<BoundExpression> result = boundArguments;
			if (objectInitializerExpression != null)
			{
				result = result.Add(objectInitializerExpression);
			}
			return result;
		}

		private BoundExpression BindObjectCreationExpression(SyntaxNode typeNode, Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax argumentListOpt, TypeSymbol type0, SyntaxNode node, ImmutableArray<BoundExpression> boundArguments, ImmutableArray<string> argumentNames, BoundObjectInitializerExpressionBase objectInitializerExpressionOpt, BindingDiagnosticBag diagnostics, VisualBasicSyntaxNode callerInfoOpt)
		{
			LookupResultKind lookupResultKind = LookupResultKind.Good;
			bool flag = false;
			NamedTypeSymbol namedTypeSymbol = null;
			switch (type0.TypeKind)
			{
			case TypeKind.Class:
				if (((NamedTypeSymbol)type0).IsMustInherit)
				{
					ReportDiagnostic(diagnostics, node, ERRID.ERR_NewOnAbstractClass);
					lookupResultKind = LookupResultKind.NotCreatable;
					flag = true;
				}
				namedTypeSymbol = (NamedTypeSymbol)type0;
				break;
			case TypeKind.Interface:
			{
				TypeSymbol coClassType = ((NamedTypeSymbol)type0).CoClassType;
				DiagnosticInfo diagnosticInfo;
				if ((object)coClassType != null)
				{
					switch (coClassType.TypeKind)
					{
					case TypeKind.Error:
					case TypeKind.Interface:
						diagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_CoClassMissing2, coClassType, type0);
						break;
					case TypeKind.Array:
						diagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_InvalidCoClass1, coClassType);
						break;
					case TypeKind.Class:
					case TypeKind.Delegate:
					case TypeKind.Enum:
					case TypeKind.Module:
					case TypeKind.Struct:
					{
						NamedTypeSymbol namedTypeSymbol2 = (NamedTypeSymbol)coClassType;
						if (namedTypeSymbol2.IsUnboundGenericType)
						{
							diagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_InvalidCoClass1, coClassType);
							break;
						}
						CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
						bool num = CheckAccessibility(namedTypeSymbol2, ref useSiteInfo) != AccessCheckResult.Accessible;
						((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(node, useSiteInfo);
						if (num)
						{
							diagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_InAccessibleCoClass3, coClassType, type0, AccessibilityExtensions.ToDiagnosticString(coClassType.DeclaredAccessibility));
							break;
						}
						if (type0.ContainingAssembly.IsLinked)
						{
							return BindNoPiaObjectCreationExpression(node, type0, namedTypeSymbol2, boundArguments, objectInitializerExpressionOpt, diagnostics);
						}
						if (namedTypeSymbol2.IsMustInherit)
						{
							diagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_InvalidCoClass1, coClassType);
						}
						else
						{
							namedTypeSymbol = namedTypeSymbol2;
							diagnosticInfo = null;
						}
						break;
					}
					default:
						throw ExceptionUtilities.UnexpectedValue(coClassType.TypeKind);
					}
				}
				else
				{
					diagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_NewIfNullOnNonClass);
				}
				if (diagnosticInfo != null)
				{
					ReportDiagnostic(diagnostics, node, diagnosticInfo);
					lookupResultKind = LookupResultKind.NotCreatable;
					flag = true;
					namedTypeSymbol = (NamedTypeSymbol)type0;
				}
				break;
			}
			case TypeKind.Error:
				return new BoundBadExpression(node, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, MergeBoundChildNodesWithObjectInitializerForBadNode(boundArguments, objectInitializerExpressionOpt), type0, hasErrors: true);
			case TypeKind.TypeParameter:
			{
				TypeParameterSymbol typeParameterSymbol = (TypeParameterSymbol)type0;
				if (!typeParameterSymbol.HasConstructorConstraint && !typeParameterSymbol.IsValueType)
				{
					ReportDiagnostic(diagnostics, typeNode, ERRID.ERR_NewIfNullOnGenericParam);
				}
				else
				{
					if (boundArguments.IsEmpty)
					{
						return new BoundNewT(node, objectInitializerExpressionOpt, typeParameterSymbol);
					}
					TextSpan span = argumentListOpt.Arguments.Span;
					ReportDiagnostic(diagnostics, GetLocation(span), ERRID.ERR_NewArgsDisallowedForTypeParam);
				}
				lookupResultKind = LookupResultKind.NotCreatable;
				flag = true;
				break;
			}
			case TypeKind.Enum:
			case TypeKind.Struct:
				namedTypeSymbol = (NamedTypeSymbol)type0;
				break;
			case TypeKind.Module:
				namedTypeSymbol = (NamedTypeSymbol)type0;
				lookupResultKind = LookupResultKind.NotCreatable;
				flag = true;
				break;
			case TypeKind.Array:
				lookupResultKind = LookupResultKind.NotCreatable;
				flag = true;
				break;
			default:
				throw ExceptionUtilities.UnexpectedValue(type0.TypeKind);
			}
			BoundMethodGroup boundMethodGroup = null;
			if ((object)namedTypeSymbol != null && !namedTypeSymbol.IsInterface)
			{
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo2 = GetNewCompoundUseSiteInfo(diagnostics);
				ImmutableArray<MethodSymbol> methods = GetAccessibleConstructors(namedTypeSymbol, ref useSiteInfo2);
				((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(node, useSiteInfo2);
				LookupResultKind resultKind = LookupResultKind.Good;
				if (methods.Length == 0)
				{
					methods = namedTypeSymbol.InstanceConstructors;
					resultKind = LookupResultKind.Inaccessible;
				}
				if (methods.Length > 0)
				{
					boundMethodGroup = BoundNodeExtensions.MakeCompilerGenerated(new BoundMethodGroup(typeNode, null, methods, resultKind, null, QualificationKind.QualifiedViaTypeName));
				}
			}
			if (boundMethodGroup == null || boundMethodGroup.ResultKind == LookupResultKind.Inaccessible)
			{
				if (!flag)
				{
					ReportDiagnostic(diagnostics, Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(typeNode, SyntaxKind.QualifiedName) ? ((Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax)typeNode).Right : typeNode, ErrorFactory.ErrorInfo(ERRID.ERR_NoViableOverloadCandidates1, "New"));
				}
				diagnostics = BindingDiagnosticBag.Discarded;
			}
			BoundExpression result;
			if (boundMethodGroup == null)
			{
				result = new BoundBadExpression(node, LookupResult.WorseResultKind(lookupResultKind, LookupResultKind.Empty), ImmutableArray<Symbol>.Empty, MergeBoundChildNodesWithObjectInitializerForBadNode(boundArguments, objectInitializerExpressionOpt), type0, hasErrors: true);
			}
			else
			{
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo3 = GetNewCompoundUseSiteInfo(diagnostics);
				OverloadResolution.OverloadResolutionResult results = OverloadResolution.MethodInvocationOverloadResolution(boundMethodGroup, boundArguments, argumentNames, this, callerInfoOpt, ref useSiteInfo3);
				if (((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(node, useSiteInfo3) && boundMethodGroup.ResultKind != LookupResultKind.Inaccessible)
				{
					diagnostics = BindingDiagnosticBag.Discarded;
				}
				if (!results.BestResult.HasValue)
				{
					if (results.Candidates.Length == 0)
					{
						BoundMethodGroup methodGroup = boundMethodGroup;
						ImmutableArray<BoundExpression> arguments = boundArguments;
						CompoundUseSiteInfo<AssemblySymbol> useSiteInfo4 = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
						results = OverloadResolution.MethodInvocationOverloadResolution(methodGroup, arguments, argumentNames, this, callerInfoOpt, ref useSiteInfo4, includeEliminatedCandidates: true);
					}
					result = ReportOverloadResolutionFailureAndProduceBoundNode(node, boundMethodGroup, boundArguments, argumentNames, ref results, diagnostics, callerInfoOpt, type0);
					BoundBadExpression boundBadExpression = (BoundBadExpression)result;
					ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
					ImmutableArray<BoundExpression>.Enumerator enumerator = boundBadExpression.ChildBoundNodes.GetEnumerator();
					while (enumerator.MoveNext())
					{
						BoundExpression current = enumerator.Current;
						if (current == boundMethodGroup)
						{
							instance.Add(boundMethodGroup.Update(boundMethodGroup.TypeArgumentsOpt, boundMethodGroup.Methods, boundMethodGroup.PendingExtensionMethodsOpt, LookupResult.WorseResultKind(boundMethodGroup.ResultKind, boundBadExpression.ResultKind), boundMethodGroup.ReceiverOpt, boundMethodGroup.QualificationKind));
						}
						else
						{
							instance.Add(current);
						}
					}
					if (objectInitializerExpressionOpt != null)
					{
						instance.Add(objectInitializerExpressionOpt);
					}
					result = boundBadExpression.Update(LookupResult.WorseResultKind(lookupResultKind, boundBadExpression.ResultKind), boundBadExpression.Symbols, instance.ToImmutableAndFree(), boundBadExpression.Type);
				}
				else
				{
					OverloadResolution.CandidateAnalysisResult candidate = results.BestResult.Value;
					(ImmutableArray<BoundExpression>, BitVector) tuple = PassArguments(typeNode, ref candidate, boundArguments, diagnostics);
					(boundArguments, _) = tuple;
					ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagnostics, candidate.Candidate.UnderlyingSymbol, node);
					if (TypeSymbolExtensions.IsInterfaceType(type0))
					{
						ApplyImplicitConversion(node, type0, new BoundRValuePlaceholder(node, namedTypeSymbol), diagnostics);
					}
					if (lookupResultKind != LookupResultKind.Good)
					{
						ArrayBuilder<BoundExpression> instance2 = ArrayBuilder<BoundExpression>.GetInstance();
						instance2.Add(boundMethodGroup);
						instance2.AddRange(boundArguments);
						if (objectInitializerExpressionOpt != null)
						{
							instance2.Add(objectInitializerExpressionOpt);
						}
						result = new BoundBadExpression(node, lookupResultKind, ImmutableArray.Create(candidate.Candidate.UnderlyingSymbol), instance2.ToImmutableAndFree(), type0, hasErrors: true);
					}
					else
					{
						result = new BoundObjectCreationExpression(node, (MethodSymbol)candidate.Candidate.UnderlyingSymbol, boundMethodGroup, boundArguments, tuple.Item2, objectInitializerExpressionOpt, type0);
					}
				}
			}
			return result;
		}

		private BoundExpression BindNoPiaObjectCreationExpression(SyntaxNode node, TypeSymbol @interface, NamedTypeSymbol coClass, ImmutableArray<BoundExpression> boundArguments, BoundObjectInitializerExpressionBase initializerOpt, BindingDiagnosticBag diagnostics)
		{
			bool hasErrors = false;
			string guidString = null;
			if (!coClass.GetGuidString(ref guidString))
			{
				ReportDiagnostic(diagnostics, node, ERRID.ERR_NoPIAAttributeMissing2, coClass, AttributeDescription.GuidAttribute.FullName);
				hasErrors = true;
			}
			BoundNoPiaObjectCreationExpression boundNoPiaObjectCreationExpression = new BoundNoPiaObjectCreationExpression(node, guidString, initializerOpt, @interface, hasErrors);
			if (boundArguments.Any())
			{
				ReportDiagnostic(diagnostics, node, ERRID.ERR_NoArgumentCountOverloadCandidates1, "New");
				ImmutableArray<BoundExpression> exprs = boundArguments.Add(boundNoPiaObjectCreationExpression);
				return BadExpression(node, exprs, boundNoPiaObjectCreationExpression.Type);
			}
			return boundNoPiaObjectCreationExpression;
		}

		private BoundObjectInitializerExpressionBase BindObjectCollectionOrMemberInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax syntaxNode, TypeSymbol initializedObjectType, BoundWithLValueExpressionPlaceholder asNewVariablePlaceholderOpt, BindingDiagnosticBag diagnostics)
		{
			if (syntaxNode.Initializer == null)
			{
				return null;
			}
			if (syntaxNode.Initializer.Kind() == SyntaxKind.ObjectMemberInitializer)
			{
				return BindObjectInitializer(syntaxNode, initializedObjectType, asNewVariablePlaceholderOpt, diagnostics);
			}
			if (syntaxNode.Initializer.Kind() == SyntaxKind.ObjectCollectionInitializer)
			{
				return BindCollectionInitializer(syntaxNode, initializedObjectType, diagnostics);
			}
			throw ExceptionUtilities.UnexpectedValue(syntaxNode.Initializer.Kind());
		}

		private BoundObjectInitializerExpression BindObjectInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax objectCreationSyntax, TypeSymbol initializedObjectType, BoundWithLValueExpressionPlaceholder asNewVariablePlaceholderOpt, BindingDiagnosticBag diagnostics)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax objectMemberInitializerSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax)objectCreationSyntax.Initializer;
			bool flag = asNewVariablePlaceholderOpt == null || !initializedObjectType.IsValueType;
			BoundWithLValueExpressionPlaceholder boundWithLValueExpressionPlaceholder = null;
			if (flag)
			{
				boundWithLValueExpressionPlaceholder = new BoundWithLValueExpressionPlaceholder(objectCreationSyntax, initializedObjectType);
				boundWithLValueExpressionPlaceholder.SetWasCompilerGenerated();
			}
			else
			{
				boundWithLValueExpressionPlaceholder = asNewVariablePlaceholderOpt;
			}
			ObjectInitializerBinder objectInitializerBinder = new ObjectInitializerBinder(this, boundWithLValueExpressionPlaceholder);
			if (initializedObjectType.SpecialType == SpecialType.System_Object || TypeSymbolExtensions.IsErrorType(initializedObjectType))
			{
				if (initializedObjectType.SpecialType == SpecialType.System_Object)
				{
					ReportDiagnostic(diagnostics, objectMemberInitializerSyntax, ErrorFactory.ErrorInfo(ERRID.ERR_AggrInitInvalidForObject));
				}
				int count = objectMemberInitializerSyntax.Initializers.Count;
				BoundExpression[] array = new BoundExpression[count - 1 + 1];
				int num = count - 1;
				for (int i = 0; i <= num; i++)
				{
					BoundExpression expr = objectInitializerBinder.BindValue(((Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax)objectMemberInitializerSyntax.Initializers[i]).Expression, diagnostics);
					array[i] = MakeRValueAndIgnoreDiagnostics(expr);
				}
				return new BoundObjectInitializerExpression(objectCreationSyntax.Initializer, createTemporaryLocalForInitialization: true, this, boundWithLValueExpressionPlaceholder, array.AsImmutableOrNull(), initializedObjectType, hasErrors: true);
			}
			HashSet<string> hashSet = new HashSet<string>(CaseInsensitiveComparison.Comparer);
			ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
			BindingDiagnosticBag instance2 = BindingDiagnosticBag.GetInstance(withDiagnostics: true, diagnostics.AccumulatesDependencies);
			SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax>.Enumerator enumerator = objectMemberInitializerSyntax.Initializers.GetEnumerator();
			while (enumerator.MoveNext())
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax namedFieldInitializerSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax)enumerator.Current;
				Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax name = namedFieldInitializerSyntax.Name;
				BoundExpression boundExpression;
				if (!name.HasErrors)
				{
					boundExpression = BindMemberAccess(name, boundWithLValueExpressionPlaceholder, name, eventContext: false, instance2);
					diagnostics.AddRange(instance2);
					string valueText = name.Identifier.ValueText;
					if (boundExpression.Kind == BoundKind.FieldAccess || boundExpression.Kind == BoundKind.PropertyGroup)
					{
						boundExpression = BindAssignmentTarget(name, boundExpression, diagnostics);
						BoundPropertyAccess boundPropertyAccess = boundExpression as BoundPropertyAccess;
						if (boundPropertyAccess != null && boundPropertyAccess.AccessKind != PropertyAccessKind.Get && !boundPropertyAccess.IsWriteable && boundPropertyAccess.PropertySymbol.IsWritable(boundPropertyAccess.ReceiverOpt, this, isKnownTargetOfObjectMemberInitializer: true))
						{
							boundPropertyAccess = boundPropertyAccess.Update(boundPropertyAccess.PropertySymbol, boundPropertyAccess.PropertyGroupOpt, boundPropertyAccess.AccessKind, isWriteable: true, boundPropertyAccess.IsLValue, boundPropertyAccess.ReceiverOpt, boundPropertyAccess.Arguments, boundPropertyAccess.DefaultArguments, boundPropertyAccess.Type);
							boundExpression = boundPropertyAccess;
						}
						if (!boundExpression.HasErrors)
						{
							bool flag2;
							if (boundExpression.Kind == BoundKind.FieldAccess)
							{
								flag2 = ((BoundFieldAccess)boundExpression).FieldSymbol.IsShared;
							}
							else
							{
								PropertySymbol propertySymbol = boundPropertyAccess.PropertySymbol;
								flag2 = (object)propertySymbol.ReducedFrom != null || propertySymbol.IsShared;
							}
							if (flag2)
							{
								ReportDiagnostic(diagnostics, name, ErrorFactory.ErrorInfo(ERRID.ERR_SharedMemberAggrMemberInit1, valueText));
							}
							else if (!hashSet.Add(valueText))
							{
								ReportDiagnostic(diagnostics, name, ErrorFactory.ErrorInfo(ERRID.ERR_DuplicateAggrMemberInit1, valueText));
							}
						}
					}
					else
					{
						if (!instance2.HasAnyErrors())
						{
							ReportDiagnostic(diagnostics, name, ErrorFactory.ErrorInfo(ERRID.ERR_NonFieldPropertyAggrMemberInit1, valueText));
						}
						boundExpression = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(namedFieldInitializerSyntax, boundExpression, ErrorTypeSymbol.UnknownResultType));
					}
				}
				else
				{
					boundExpression = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(namedFieldInitializerSyntax, ErrorTypeSymbol.UnknownResultType));
				}
				BoundExpression op = objectInitializerBinder.BindValue(namedFieldInitializerSyntax.Expression, diagnostics);
				BoundExpression item = BindAssignment(namedFieldInitializerSyntax, boundExpression, op, diagnostics);
				instance.Add(item);
				instance2.Clear();
			}
			instance2.Free();
			return new BoundObjectInitializerExpression(objectCreationSyntax.Initializer, flag, this, boundWithLValueExpressionPlaceholder, instance.ToImmutableAndFree(), initializedObjectType);
		}

		private BoundCollectionInitializerExpression BindCollectionInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax objectCreationSyntax, TypeSymbol initializedObjectType, BindingDiagnosticBag diagnostics)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCollectionInitializerSyntax objectCollectionInitializerSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCollectionInitializerSyntax)objectCreationSyntax.Initializer;
			TypeSymbol currentType = null;
			BoundExpression boundGetEnumeratorCall = null;
			BoundLValuePlaceholder boundEnumeratorPlaceholder = null;
			BoundRValuePlaceholder collectionPlaceholder = null;
			BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(diagnostics);
			bool flag = false;
			if (MatchesForEachCollectionDesignPattern(initializedObjectType, new BoundRValuePlaceholder(objectCollectionInitializerSyntax, initializedObjectType), out currentType, out boundGetEnumeratorCall, out boundEnumeratorPlaceholder, out boundGetEnumeratorCall, out boundGetEnumeratorCall, out collectionPlaceholder, instance))
			{
				diagnostics.AddRange(instance);
				flag = true;
			}
			else
			{
				BindingDiagnosticBag instance2 = BindingDiagnosticBag.GetInstance(diagnostics);
				NamedTypeSymbol specialType = GetSpecialType(SpecialType.System_Collections_IEnumerable, objectCreationSyntax, instance2);
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
				if (IsOrInheritsFromOrImplementsInterface(initializedObjectType, specialType, ref useSiteInfo))
				{
					diagnostics.AddRange(instance2);
					flag = true;
				}
				else
				{
					ReportDiagnostic(diagnostics, objectCollectionInitializerSyntax, ErrorFactory.ErrorInfo(ERRID.ERR_NotACollection1, initializedObjectType.Name));
				}
				((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)objectCollectionInitializerSyntax, useSiteInfo);
				instance2.Free();
			}
			LookupResult instance3 = LookupResult.GetInstance();
			instance.Clear();
			GetMemberIfMatchesRequirements("Add", initializedObjectType, (Symbol y) => y.Kind == SymbolKind.Method, instance3, objectCollectionInitializerSyntax, instance);
			SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax> initializers = objectCollectionInitializerSyntax.Initializer.Initializers;
			int count = initializers.Count;
			BoundWithLValueExpressionPlaceholder boundWithLValueExpressionPlaceholder = null;
			if (instance3.IsGood)
			{
				diagnostics.AddRange(instance);
			}
			else if (flag)
			{
				ReportDiagnostic(diagnostics, objectCollectionInitializerSyntax, ErrorFactory.ErrorInfo(ERRID.ERR_NoAddMethod1, initializedObjectType));
			}
			instance.Free();
			BoundExpression[] array = new BoundExpression[count - 1 + 1];
			boundWithLValueExpressionPlaceholder = new BoundWithLValueExpressionPlaceholder(objectCreationSyntax, initializedObjectType);
			boundWithLValueExpressionPlaceholder.SetWasCompilerGenerated();
			int num = count - 1;
			for (int i = 0; i <= num; i++)
			{
				array[i] = BindCollectionInitializerElement(initializers[i], boundWithLValueExpressionPlaceholder, instance3, diagnostics);
			}
			ImmutableArray<BoundExpression> initializers2 = array.AsImmutableOrNull();
			instance3.Free();
			return new BoundCollectionInitializerExpression(objectCreationSyntax.Initializer, boundWithLValueExpressionPlaceholder, initializers2, initializedObjectType);
		}

		private BoundExpression BindCollectionInitializerElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax topLevelInitializer, BoundWithLValueExpressionPlaceholder placeholder, LookupResult result, BindingDiagnosticBag diagnostics)
		{
			ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
			if (topLevelInitializer.Kind() == SyntaxKind.CollectionInitializer)
			{
				SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax> initializers = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax)topLevelInitializer).Initializers;
				if (initializers.IsEmpty())
				{
					ReportDiagnostic(diagnostics, topLevelInitializer, ErrorFactory.ErrorInfo(ERRID.ERR_EmptyAggregateInitializer));
				}
				else
				{
					SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax>.Enumerator enumerator = initializers.GetEnumerator();
					while (enumerator.MoveNext())
					{
						Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax current = enumerator.Current;
						instance.Add(BindValue(current, diagnostics));
					}
				}
			}
			else
			{
				instance.Add(BindValue(topLevelInitializer, diagnostics));
			}
			if (result.IsGood && !instance.IsEmpty())
			{
				BoundMethodGroup group = BoundNodeExtensions.MakeCompilerGenerated(CreateBoundMethodGroup(topLevelInitializer, result, LookupOptions.AllMethodsOfAnyArity, diagnostics.AccumulatesDependencies, placeholder, null, QualificationKind.QualifiedViaValue));
				BoundExpression boundExpression = BindInvocationExpression(topLevelInitializer, topLevelInitializer, TypeCharacter.None, group, instance.ToImmutableAndFree(), default(ImmutableArray<string>), diagnostics, topLevelInitializer);
				boundExpression.SetWasCompilerGenerated();
				if (boundExpression.Kind == BoundKind.LateInvocation)
				{
					boundExpression = BoundExpressionExtensions.SetLateBoundAccessKind((BoundLateInvocation)boundExpression, LateBoundAccessKind.Call);
				}
				return boundExpression;
			}
			return BoundNodeExtensions.MakeCompilerGenerated(new BoundBadExpression(topLevelInitializer, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, instance.ToImmutableAndFree(), ErrorTypeSymbol.UnknownResultType, hasErrors: true));
		}

		private BoundExpression BindIsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			bool isNot = node.Kind() == SyntaxKind.IsNotExpression;
			BoundExpression left = BindExpression(node.Left, diagnostics);
			BoundExpression right = BindExpression(node.Right, diagnostics);
			return BindIsExpression(left, right, node, isNot, diagnostics);
		}

		private BoundExpression BindIsExpression(BoundExpression left, BoundExpression right, SyntaxNode node, bool isNot, BindingDiagnosticBag diagnostics)
		{
			left = MakeRValue(left, diagnostics);
			right = MakeRValue(right, diagnostics);
			left = ValidateAndConvertIsExpressionArgument(left, right, isNot, diagnostics);
			right = ValidateAndConvertIsExpressionArgument(right, left, isNot, diagnostics);
			NamedTypeSymbol specialType = GetSpecialType(SpecialType.System_Boolean, node, diagnostics);
			return new BoundBinaryOperator(node, isNot ? BinaryOperatorKind.IsNot : BinaryOperatorKind.Is, left, right, @checked: false, specialType, TypeSymbolExtensions.IsErrorType(specialType));
		}

		private BoundExpression ValidateAndConvertIsExpressionArgument(BoundExpression targetArgument, BoundExpression otherArgument, bool isNot, BindingDiagnosticBag diagnostics)
		{
			TypeSymbol type = targetArgument.Type;
			if (BoundExpressionExtensions.IsNothingLiteral(targetArgument))
			{
				return targetArgument;
			}
			if (TypeSymbolExtensions.IsErrorType(type))
			{
				return targetArgument;
			}
			if (type.IsReferenceType)
			{
				return ApplyImplicitConversion(targetArgument.Syntax, GetSpecialType(SpecialType.System_Object, targetArgument.Syntax, diagnostics), targetArgument, diagnostics);
			}
			if (TypeSymbolExtensions.IsNullableType(type))
			{
				if (!otherArgument.HasErrors && !BoundExpressionExtensions.IsNothingLiteral(otherArgument))
				{
					ReportDiagnostic(diagnostics, targetArgument.Syntax, isNot ? ERRID.ERR_IsNotOperatorNullable1 : ERRID.ERR_IsOperatorNullable1, type);
				}
				return targetArgument;
			}
			if (TypeSymbolExtensions.IsTypeParameter(type) && !type.IsValueType)
			{
				if (!otherArgument.HasErrors && !BoundExpressionExtensions.IsNothingLiteral(otherArgument))
				{
					ReportDiagnostic(diagnostics, targetArgument.Syntax, isNot ? ERRID.ERR_IsNotOperatorGenericParam1 : ERRID.ERR_IsOperatorGenericParam1, type);
				}
				return ApplyImplicitConversion(targetArgument.Syntax, GetSpecialType(SpecialType.System_Object, targetArgument.Syntax, diagnostics), targetArgument, diagnostics);
			}
			ReportDiagnostic(diagnostics, targetArgument.Syntax, isNot ? ERRID.ERR_IsNotOpRequiresReferenceTypes1 : ERRID.ERR_IsOperatorRequiresReferenceTypes1, type);
			return targetArgument;
		}

		private BoundExpression BindBinaryOperator(Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax node, bool isOperandOfConditionalBranch, BindingDiagnosticBag diagnostics)
		{
			BinaryOperatorKind binaryOperatorKind = OverloadResolution.MapBinaryOperatorKind(node.Kind());
			bool flag = isOperandOfConditionalBranch && (binaryOperatorKind == BinaryOperatorKind.AndAlso || binaryOperatorKind == BinaryOperatorKind.OrElse);
			Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax binaryExpressionSyntax = node;
			Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expressionSyntax;
			while (true)
			{
				expressionSyntax = binaryExpressionSyntax.Left;
				switch (expressionSyntax.Kind())
				{
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
					if (!flag)
					{
						goto IL_00ab;
					}
					break;
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
					goto IL_00ab;
				}
				break;
				IL_00ab:
				binaryExpressionSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax)expressionSyntax;
			}
			BoundExpression boundExpression = BindValue(expressionSyntax, diagnostics, flag);
			do
			{
				binaryExpressionSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax)expressionSyntax.Parent;
				BoundExpression right = BindValue(binaryExpressionSyntax.Right, diagnostics, flag);
				boundExpression = BindBinaryOperator(binaryExpressionSyntax, boundExpression, right, VisualBasicExtensions.Kind(binaryExpressionSyntax.OperatorToken), OverloadResolution.MapBinaryOperatorKind(binaryExpressionSyntax.Kind()), (binaryExpressionSyntax == node) ? isOperandOfConditionalBranch : flag, diagnostics);
				expressionSyntax = binaryExpressionSyntax;
			}
			while (expressionSyntax != node);
			return boundExpression;
		}

		private BoundExpression BindBinaryOperator(SyntaxNode node, BoundExpression left, BoundExpression right, SyntaxKind operatorTokenKind, BinaryOperatorKind preliminaryOperatorKind, bool isOperandOfConditionalBranch, BindingDiagnosticBag diagnostics, bool isSelectCase = false)
		{
			BindingDiagnosticBag bindingDiagnosticBag = diagnostics;
			if (left.HasErrors || right.HasErrors)
			{
				diagnostics = BindingDiagnosticBag.Discarded;
			}
			ConvertNothingLiterals(preliminaryOperatorKind, ref left, ref right, diagnostics);
			left = MakeRValue(left, diagnostics);
			right = MakeRValue(right, diagnostics);
			if ((left.HasErrors || right.HasErrors) && diagnostics == bindingDiagnosticBag)
			{
				diagnostics = BindingDiagnosticBag.Discarded;
			}
			TypeSymbol typeSymbol = left.Type;
			TypeSymbol typeSymbol2 = right.Type;
			bool flag = TypeSymbolExtensions.IsDBNullType(typeSymbol);
			bool flag2 = TypeSymbolExtensions.IsDBNullType(typeSymbol2);
			if ((preliminaryOperatorKind == BinaryOperatorKind.Concatenate && flag != flag2) || (preliminaryOperatorKind == BinaryOperatorKind.Add && ((TypeSymbolExtensions.IsStringType(typeSymbol) && flag2) || (flag && TypeSymbolExtensions.IsStringType(typeSymbol2)))))
			{
				if (flag)
				{
					typeSymbol = SubstituteDBNullWithNothingString(ref left, typeSymbol2, diagnostics);
				}
				else
				{
					typeSymbol2 = SubstituteDBNullWithNothingString(ref right, typeSymbol, diagnostics);
				}
			}
			SpecialType intrinsicOperatorType = SpecialType.None;
			OverloadResolution.OverloadResolutionResult userDefinedOperator = default(OverloadResolution.OverloadResolutionResult);
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
			BinaryOperatorKind binaryOperatorKind = OverloadResolution.ResolveBinaryOperator(preliminaryOperatorKind, left, right, this, considerUserDefinedOrLateBound: true, out intrinsicOperatorType, out userDefinedOperator, ref useSiteInfo);
			if (((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(node, useSiteInfo))
			{
				diagnostics = BindingDiagnosticBag.Discarded;
			}
			if (binaryOperatorKind == BinaryOperatorKind.UserDefined)
			{
				OverloadResolution.Candidate candidate = (userDefinedOperator.BestResult.HasValue ? userDefinedOperator.BestResult.Value.Candidate : null);
				if (candidate == null || !candidate.IsLifted || (OverloadResolution.IsValidInLiftedSignature(candidate.Parameters(0).Type) && OverloadResolution.IsValidInLiftedSignature(candidate.Parameters(1).Type) && OverloadResolution.IsValidInLiftedSignature(candidate.ReturnType)))
				{
					if (preliminaryOperatorKind == BinaryOperatorKind.AndAlso || preliminaryOperatorKind == BinaryOperatorKind.OrElse)
					{
						return BindUserDefinedShortCircuitingOperator(node, preliminaryOperatorKind, left, right, ref userDefinedOperator, diagnostics);
					}
					return BindUserDefinedNonShortCircuitingBinaryOperator(node, preliminaryOperatorKind, left, right, ref userDefinedOperator, diagnostics);
				}
				binaryOperatorKind = BinaryOperatorKind.Error;
			}
			if (binaryOperatorKind == BinaryOperatorKind.Error)
			{
				ReportUndefinedOperatorError(node, left, right, operatorTokenKind, preliminaryOperatorKind, diagnostics);
				return new BoundBinaryOperator(node, preliminaryOperatorKind | BinaryOperatorKind.Error, left, right, CheckOverflow, ErrorTypeSymbol.UnknownResultType, hasErrors: true);
			}
			TypeSymbol typeSymbol3 = ((intrinsicOperatorType != 0) ? GetSpecialTypeForBinaryOperator(node, typeSymbol, typeSymbol2, intrinsicOperatorType, (binaryOperatorKind & BinaryOperatorKind.Lifted) != 0, diagnostics) : (((binaryOperatorKind & BinaryOperatorKind.Lifted) != 0 && !TypeSymbolExtensions.IsNullableType(typeSymbol)) ? typeSymbol2 : typeSymbol));
			TypeSymbol typeSymbol4 = typeSymbol3;
			TypeSymbol typeSymbol5 = null;
			if ((uint)(preliminaryOperatorKind - 3) <= 6u)
			{
				if (OptionCompareText && (TypeSymbolExtensions.IsObjectType(typeSymbol3) || TypeSymbolExtensions.IsStringType(typeSymbol3)))
				{
					binaryOperatorKind |= BinaryOperatorKind.CompareText;
				}
				if (!TypeSymbolExtensions.IsObjectType(typeSymbol4) || (isOperandOfConditionalBranch && preliminaryOperatorKind != BinaryOperatorKind.Like))
				{
					TypeSymbol specialTypeForBinaryOperator = GetSpecialTypeForBinaryOperator(node, typeSymbol, typeSymbol2, SpecialType.System_Boolean, makeNullable: false, diagnostics);
					if ((binaryOperatorKind & BinaryOperatorKind.Lifted) != 0)
					{
						typeSymbol4 = GetNullableTypeForBinaryOperator(typeSymbol, typeSymbol2, specialTypeForBinaryOperator);
						if ((preliminaryOperatorKind == BinaryOperatorKind.Equals || preliminaryOperatorKind == BinaryOperatorKind.NotEquals) && (IsKnownToBeNullableNothing(left) || IsKnownToBeNullableNothing(right)))
						{
							ReportDiagnostic(diagnostics, node, ErrorFactory.ErrorInfo((preliminaryOperatorKind == BinaryOperatorKind.Equals) ? ERRID.WRN_EqualToLiteralNothing : ERRID.WRN_NotEqualToLiteralNothing));
						}
					}
					else if (!TypeSymbolExtensions.IsObjectType(typeSymbol4))
					{
						typeSymbol4 = specialTypeForBinaryOperator;
					}
					else
					{
						typeSymbol5 = specialTypeForBinaryOperator;
					}
				}
			}
			if ((TypeSymbolExtensions.IsErrorType(TypeSymbolExtensions.GetNullableUnderlyingTypeOrSelf(typeSymbol3)) || TypeSymbolExtensions.IsErrorType(TypeSymbolExtensions.GetNullableUnderlyingTypeOrSelf(typeSymbol4)) || ((object)typeSymbol5 != null && TypeSymbolExtensions.IsErrorType(TypeSymbolExtensions.GetNullableUnderlyingTypeOrSelf(typeSymbol5)))) && diagnostics == bindingDiagnosticBag)
			{
				diagnostics = BindingDiagnosticBag.Discarded;
			}
			bool hasErrors = false;
			if (OptionStrict == OptionStrict.On)
			{
				bool flag3 = false;
				if (TypeSymbolExtensions.IsObjectType(typeSymbol))
				{
					ReportBinaryOperatorOnObject(operatorTokenKind, left, preliminaryOperatorKind, diagnostics);
					flag3 = true;
				}
				if (TypeSymbolExtensions.IsObjectType(typeSymbol2))
				{
					ReportBinaryOperatorOnObject(operatorTokenKind, right, preliminaryOperatorKind, diagnostics);
					flag3 = true;
				}
				if (flag3)
				{
					hasErrors = true;
					if (diagnostics == bindingDiagnosticBag)
					{
						diagnostics = BindingDiagnosticBag.Discarded;
					}
				}
			}
			else if (OptionStrict == OptionStrict.Custom && (!isSelectCase || preliminaryOperatorKind != BinaryOperatorKind.OrElse))
			{
				ERRID id = (isSelectCase ? ERRID.WRN_ObjectMathSelectCase : (preliminaryOperatorKind switch
				{
					BinaryOperatorKind.NotEquals => ERRID.WRN_ObjectMath1Not, 
					BinaryOperatorKind.Equals => ERRID.WRN_ObjectMath1, 
					_ => ERRID.WRN_ObjectMath2, 
				}));
				if (TypeSymbolExtensions.IsObjectType(typeSymbol))
				{
					ReportDiagnostic(diagnostics, left.Syntax, ErrorFactory.ErrorInfo(id, ref operatorTokenKind));
				}
				if (TypeSymbolExtensions.IsObjectType(typeSymbol2))
				{
					ReportDiagnostic(diagnostics, right.Syntax, ErrorFactory.ErrorInfo(id, ref operatorTokenKind));
				}
			}
			bool flag4 = false;
			if (preliminaryOperatorKind == BinaryOperatorKind.Concatenate)
			{
				flag4 = true;
				if (TypeSymbolExtensions.IsStringType(typeSymbol3))
				{
					if (TypeSymbolExtensions.IsNullableType(left.Type))
					{
						left = ForceLiftToEmptyString(left, typeSymbol3, diagnostics);
					}
					if (TypeSymbolExtensions.IsNullableType(right.Type))
					{
						right = ForceLiftToEmptyString(right, typeSymbol3, diagnostics);
					}
				}
			}
			BoundExpression boundExpression = left;
			left = ApplyConversion(left.Syntax, typeSymbol3, left, flag4, diagnostics, isOperandOfConditionalBranch: false, flag4);
			if (flag4 && left != boundExpression && left.Kind == BoundKind.Conversion)
			{
				BoundConversion boundConversion = (BoundConversion)left;
				left = boundConversion.Update(boundConversion.Operand, boundConversion.ConversionKind, boundConversion.Checked, explicitCastInCode: false, boundConversion.ConstantValueOpt, boundConversion.ExtendedInfoOpt, boundConversion.Type);
			}
			if ((preliminaryOperatorKind == BinaryOperatorKind.LeftShift || preliminaryOperatorKind == BinaryOperatorKind.RightShift) && !TypeSymbolExtensions.IsObjectType(typeSymbol3))
			{
				TypeSymbol typeSymbol6 = GetSpecialTypeForBinaryOperator(node, typeSymbol, typeSymbol2, SpecialType.System_Int32, makeNullable: false, diagnostics);
				if ((binaryOperatorKind & BinaryOperatorKind.Lifted) != 0)
				{
					typeSymbol6 = GetNullableTypeForBinaryOperator(typeSymbol, typeSymbol2, typeSymbol6);
				}
				right = ApplyImplicitConversion(right.Syntax, typeSymbol6, right, diagnostics);
			}
			else
			{
				boundExpression = right;
				right = ApplyConversion(right.Syntax, typeSymbol3, right, flag4, diagnostics, isOperandOfConditionalBranch: false, flag4);
				if (flag4 && right != boundExpression && right.Kind == BoundKind.Conversion)
				{
					BoundConversion boundConversion2 = (BoundConversion)right;
					right = boundConversion2.Update(boundConversion2.Operand, boundConversion2.ConversionKind, boundConversion2.Checked, explicitCastInCode: false, boundConversion2.ConstantValueOpt, boundConversion2.ExtendedInfoOpt, boundConversion2.Type);
				}
			}
			if ((binaryOperatorKind & BinaryOperatorKind.OpMask) == BinaryOperatorKind.Add && TypeSymbolExtensions.IsStringType(typeSymbol4))
			{
				binaryOperatorKind &= ~BinaryOperatorKind.OpMask;
				binaryOperatorKind |= BinaryOperatorKind.Concatenate;
			}
			ConstantValue constantValue = null;
			if (!left.HasErrors && !right.HasErrors)
			{
				bool integerOverflow = false;
				bool divideByZero = false;
				bool lengthOutOfLimit = false;
				constantValue = OverloadResolution.TryFoldConstantBinaryOperator(binaryOperatorKind, left, right, typeSymbol4, ref integerOverflow, ref divideByZero, ref lengthOutOfLimit);
				if ((object)constantValue != null)
				{
					if (divideByZero)
					{
						ReportDiagnostic(diagnostics, node, ErrorFactory.ErrorInfo(ERRID.ERR_ZeroDivide));
					}
					else if (lengthOutOfLimit)
					{
						ReportDiagnostic(diagnostics, right.Syntax, ErrorFactory.ErrorInfo(ERRID.ERR_ConstantStringTooLong));
					}
					else if (constantValue.IsBad || integerOverflow)
					{
						ReportDiagnostic(diagnostics, node, ErrorFactory.ErrorInfo(ERRID.ERR_ExpressionOverflow1, typeSymbol4));
						if (!constantValue.IsBad)
						{
							constantValue = ConstantValue.Bad;
						}
					}
				}
			}
			BoundExpression boundExpression2 = new BoundBinaryOperator(node, binaryOperatorKind | (isOperandOfConditionalBranch ? BinaryOperatorKind.IsOperandOfConditionalBranch : ((BinaryOperatorKind)0)), left, right, CheckOverflow, constantValue, typeSymbol4, hasErrors);
			if ((object)typeSymbol5 != null)
			{
				boundExpression2 = ApplyConversion(node, typeSymbol5, boundExpression2, isExplicit: true, diagnostics);
			}
			return boundExpression2;
		}

		private BoundExpression ForceLiftToEmptyString(BoundExpression left, TypeSymbol stringType, BindingDiagnosticBag diagnostics)
		{
			BoundLiteral elseExpression = BoundNodeExtensions.MakeCompilerGenerated(new BoundLiteral(left.Syntax, ConstantValue.Nothing, stringType));
			return BoundNodeExtensions.MakeCompilerGenerated(AnalyzeConversionAndCreateBinaryConditionalExpression(left.Syntax, left, elseExpression, null, stringType, hasErrors: false, diagnostics, explicitConversion: true));
		}

		private BoundUserDefinedBinaryOperator BindUserDefinedNonShortCircuitingBinaryOperator(SyntaxNode node, BinaryOperatorKind opKind, BoundExpression left, BoundExpression right, [In] ref OverloadResolution.OverloadResolutionResult userDefinedOperator, BindingDiagnosticBag diagnostics)
		{
			opKind |= BinaryOperatorKind.UserDefined;
			BoundExpression boundExpression;
			if (userDefinedOperator.BestResult.HasValue)
			{
				OverloadResolution.CandidateAnalysisResult value = userDefinedOperator.BestResult.Value;
				boundExpression = CreateBoundCallOrPropertyAccess(node, node, TypeCharacter.None, BoundNodeExtensions.MakeCompilerGenerated(new BoundMethodGroup(node, null, ImmutableArray.Create((MethodSymbol)value.Candidate.UnderlyingSymbol), LookupResultKind.Good, null, QualificationKind.Unqualified)), ImmutableArray.Create(left, right), value, userDefinedOperator.AsyncLambdaSubToFunctionMismatch, diagnostics);
				if (value.Candidate.IsLifted)
				{
					opKind |= BinaryOperatorKind.Lifted;
				}
			}
			else
			{
				boundExpression = ReportOverloadResolutionFailureAndProduceBoundNode(node, LookupResultKind.Good, ImmutableArray.Create(left, right), default(ImmutableArray<string>), ref userDefinedOperator, diagnostics, null);
			}
			return new BoundUserDefinedBinaryOperator(node, opKind, boundExpression, CheckOverflow, boundExpression.Type);
		}

		private BoundUserDefinedShortCircuitingOperator BindUserDefinedShortCircuitingOperator(SyntaxNode node, BinaryOperatorKind opKind, BoundExpression left, BoundExpression right, [In] ref OverloadResolution.OverloadResolutionResult bitwiseOperator, BindingDiagnosticBag diagnostics)
		{
			BinaryOperatorKind binaryOperatorKind = ((opKind == BinaryOperatorKind.AndAlso) ? BinaryOperatorKind.And : BinaryOperatorKind.Or) | BinaryOperatorKind.UserDefined;
			BoundExpression leftOperand = null;
			BoundRValuePlaceholder boundRValuePlaceholder = null;
			BoundExpression leftTest = null;
			bool flag = false;
			BoundUserDefinedBinaryOperator boundUserDefinedBinaryOperator;
			TypeSymbol typeSymbol;
			if (!bitwiseOperator.BestResult.HasValue)
			{
				boundUserDefinedBinaryOperator = BindUserDefinedNonShortCircuitingBinaryOperator(node, binaryOperatorKind, left, right, ref bitwiseOperator, diagnostics);
				typeSymbol = boundUserDefinedBinaryOperator.Type;
				flag = true;
			}
			else
			{
				OverloadResolution.CandidateAnalysisResult candidate = bitwiseOperator.BestResult.Value;
				OverloadResolution.Candidate candidate2 = candidate.Candidate;
				typeSymbol = candidate2.ReturnType;
				if (candidate2.IsLifted)
				{
					binaryOperatorKind |= BinaryOperatorKind.Lifted;
				}
				if (!TypeSymbolExtensions.IsSameTypeIgnoringAll(typeSymbol, candidate2.Parameters(0).Type) || !TypeSymbolExtensions.IsSameTypeIgnoringAll(typeSymbol, candidate2.Parameters(1).Type))
				{
					ReportDiagnostic(diagnostics, node, ERRID.ERR_UnacceptableLogicalOperator3, candidate2.UnderlyingSymbol, candidate2.UnderlyingSymbol.ContainingType, SyntaxFacts.GetText((opKind == BinaryOperatorKind.AndAlso) ? SyntaxKind.AndAlsoKeyword : SyntaxKind.OrElseKeyword));
					boundUserDefinedBinaryOperator = BindUserDefinedNonShortCircuitingBinaryOperator(node, binaryOperatorKind, left, right, ref bitwiseOperator, BindingDiagnosticBag.Discarded);
					flag = true;
				}
				else
				{
					boundRValuePlaceholder = BoundNodeExtensions.MakeCompilerGenerated(new BoundRValuePlaceholder(left.Syntax, typeSymbol));
					CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
					OverloadResolution.OverloadResolutionResult userDefinedOperator = ((opKind != BinaryOperatorKind.AndAlso) ? OverloadResolution.ResolveIsTrueOperator(boundRValuePlaceholder, this, ref useSiteInfo) : OverloadResolution.ResolveIsFalseOperator(boundRValuePlaceholder, this, ref useSiteInfo));
					if (((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(node, useSiteInfo))
					{
						diagnostics = BindingDiagnosticBag.Discarded;
					}
					if (!userDefinedOperator.BestResult.HasValue)
					{
						ReportDiagnostic(diagnostics, node, ERRID.ERR_ConditionOperatorRequired3, typeSymbol, SyntaxFacts.GetText((opKind == BinaryOperatorKind.AndAlso) ? SyntaxKind.IsFalseKeyword : SyntaxKind.IsTrueKeyword), SyntaxFacts.GetText((opKind == BinaryOperatorKind.AndAlso) ? SyntaxKind.AndAlsoKeyword : SyntaxKind.OrElseKeyword));
						boundUserDefinedBinaryOperator = BindUserDefinedNonShortCircuitingBinaryOperator(node, binaryOperatorKind, left, right, ref bitwiseOperator, BindingDiagnosticBag.Discarded);
						boundRValuePlaceholder = null;
						flag = true;
					}
					else
					{
						OverloadResolution.Candidate candidate3 = userDefinedOperator.BestResult.Value.Candidate;
						if (!TypeSymbolExtensions.IsSameTypeIgnoringAll(typeSymbol, candidate3.Parameters(0).Type))
						{
							ReportDiagnostic(diagnostics, node, ERRID.ERR_BinaryOperands3, SyntaxFacts.GetText((opKind == BinaryOperatorKind.AndAlso) ? SyntaxKind.AndAlsoKeyword : SyntaxKind.OrElseKeyword), left.Type, right.Type);
							flag = true;
							diagnostics = BindingDiagnosticBag.Discarded;
							boundUserDefinedBinaryOperator = BindUserDefinedNonShortCircuitingBinaryOperator(node, binaryOperatorKind, left, right, ref bitwiseOperator, diagnostics);
						}
						else
						{
							(ImmutableArray<BoundExpression>, BitVector) tuple = PassArguments(node, ref candidate, ImmutableArray.Create(left, right), diagnostics);
							candidate.ConversionsOpt = default(ImmutableArray<KeyValuePair<ConversionKind, MethodSymbol>>);
							boundUserDefinedBinaryOperator = new BoundUserDefinedBinaryOperator(node, binaryOperatorKind, CreateBoundCallOrPropertyAccess(node, node, TypeCharacter.None, BoundNodeExtensions.MakeCompilerGenerated(new BoundMethodGroup(node, null, ImmutableArray.Create((MethodSymbol)candidate2.UnderlyingSymbol), LookupResultKind.Good, null, QualificationKind.Unqualified)), ImmutableArray.Create(boundRValuePlaceholder, tuple.Item1[1]), candidate, bitwiseOperator.AsyncLambdaSubToFunctionMismatch, diagnostics), CheckOverflow, typeSymbol);
							leftOperand = tuple.Item1[0];
						}
						BoundUserDefinedUnaryOperator boundUserDefinedUnaryOperator = BoundNodeExtensions.MakeCompilerGenerated(BindUserDefinedUnaryOperator(node, (opKind == BinaryOperatorKind.AndAlso) ? UnaryOperatorKind.IsFalse : UnaryOperatorKind.IsTrue, boundRValuePlaceholder, ref userDefinedOperator, diagnostics));
						boundUserDefinedUnaryOperator.UnderlyingExpression.SetWasCompilerGenerated();
						if (flag)
						{
							boundRValuePlaceholder = null;
						}
						leftTest = ((!candidate3.IsLifted) ? ((BoundExpression)boundUserDefinedUnaryOperator) : ((BoundExpression)ApplyNullableIsTrueOperator(boundUserDefinedUnaryOperator, TypeSymbolExtensions.GetNullableUnderlyingTypeOrSelf(candidate3.ReturnType))));
					}
				}
			}
			boundUserDefinedBinaryOperator.UnderlyingExpression.SetWasCompilerGenerated();
			boundUserDefinedBinaryOperator.SetWasCompilerGenerated();
			return new BoundUserDefinedShortCircuitingOperator(node, leftOperand, boundRValuePlaceholder, leftTest, boundUserDefinedBinaryOperator, typeSymbol, flag);
		}

		private static void ReportBinaryOperatorOnObject(SyntaxKind operatorTokenKind, BoundExpression operand, BinaryOperatorKind preliminaryOperatorKind, BindingDiagnosticBag diagnostics)
		{
			ReportDiagnostic(diagnostics, operand.Syntax, ErrorFactory.ErrorInfo((preliminaryOperatorKind == BinaryOperatorKind.Equals || preliminaryOperatorKind == BinaryOperatorKind.NotEquals) ? ERRID.ERR_StrictDisallowsObjectComparison1 : ERRID.ERR_StrictDisallowsObjectOperand1, ref operatorTokenKind));
		}

		private TypeSymbol SubstituteDBNullWithNothingString(ref BoundExpression dbNullOperand, TypeSymbol otherOperandType, BindingDiagnosticBag diagnostics)
		{
			TypeSymbol typeSymbol = ((!TypeSymbolExtensions.IsStringType(otherOperandType)) ? GetSpecialType(SpecialType.System_String, dbNullOperand.Syntax, diagnostics) : otherOperandType);
			dbNullOperand = new BoundConversion(dbNullOperand.Syntax, dbNullOperand, ConversionKind.Widening, @checked: false, explicitCastInCode: false, ConstantValue.Nothing, typeSymbol);
			return typeSymbol;
		}

		private TypeSymbol GetSpecialTypeForBinaryOperator(SyntaxNode node, TypeSymbol leftType, TypeSymbol rightType, SpecialType specialType, bool makeNullable, BindingDiagnosticBag diagnostics)
		{
			TypeSymbol nullableUnderlyingTypeOrSelf = TypeSymbolExtensions.GetNullableUnderlyingTypeOrSelf(leftType);
			SpecialType specialType2 = nullableUnderlyingTypeOrSelf.SpecialType;
			TypeSymbol nullableUnderlyingTypeOrSelf2 = TypeSymbolExtensions.GetNullableUnderlyingTypeOrSelf(rightType);
			SpecialType specialType3 = nullableUnderlyingTypeOrSelf2.SpecialType;
			TypeSymbol typeSymbol;
			if (specialType2 == specialType)
			{
				typeSymbol = ((!makeNullable) ? nullableUnderlyingTypeOrSelf : (TypeSymbolExtensions.IsNullableType(leftType) ? leftType : ((specialType3 != specialType) ? ((NamedTypeSymbol)rightType.OriginalDefinition).Construct(leftType) : rightType)));
			}
			else if (specialType3 == specialType)
			{
				typeSymbol = ((!makeNullable) ? nullableUnderlyingTypeOrSelf2 : ((!TypeSymbolExtensions.IsNullableType(rightType)) ? ((NamedTypeSymbol)leftType.OriginalDefinition).Construct(nullableUnderlyingTypeOrSelf2) : rightType));
			}
			else
			{
				typeSymbol = GetSpecialType(specialType, node, diagnostics);
				if (makeNullable)
				{
					typeSymbol = ((!TypeSymbolExtensions.IsNullableType(leftType)) ? ((NamedTypeSymbol)rightType.OriginalDefinition).Construct(typeSymbol) : ((NamedTypeSymbol)leftType.OriginalDefinition).Construct(typeSymbol));
				}
			}
			return typeSymbol;
		}

		private static TypeSymbol GetNullableTypeForBinaryOperator(TypeSymbol leftType, TypeSymbol rightType, TypeSymbol ofType)
		{
			bool flag = TypeSymbolExtensions.IsNullableType(leftType);
			bool flag2 = TypeSymbolExtensions.IsNullableType(rightType);
			SpecialType specialType = ofType.SpecialType;
			if (specialType != 0)
			{
				if (flag && TypeSymbolExtensions.GetNullableUnderlyingType(leftType).SpecialType == specialType)
				{
					return leftType;
				}
				if (flag2 && TypeSymbolExtensions.GetNullableUnderlyingType(rightType).SpecialType == specialType)
				{
					return rightType;
				}
			}
			if (flag)
			{
				return ((NamedTypeSymbol)leftType.OriginalDefinition).Construct(ofType);
			}
			return ((NamedTypeSymbol)rightType.OriginalDefinition).Construct(ofType);
		}

		private static bool IsKnownToBeNullableNothing(BoundExpression expr)
		{
			BoundExpression boundExpression = expr;
			while (boundExpression.Kind == BoundKind.Conversion || boundExpression.Kind == BoundKind.DirectCast)
			{
				if (boundExpression.HasErrors)
				{
					return false;
				}
				TypeSymbol typeSymbol = null;
				switch (boundExpression.Kind)
				{
				case BoundKind.Conversion:
				{
					BoundConversion obj2 = (BoundConversion)boundExpression;
					typeSymbol = obj2.Type;
					boundExpression = obj2.Operand;
					break;
				}
				case BoundKind.DirectCast:
				{
					BoundDirectCast obj = (BoundDirectCast)boundExpression;
					typeSymbol = obj.Type;
					boundExpression = obj.Operand;
					break;
				}
				}
				if ((object)typeSymbol == null || (!TypeSymbolExtensions.IsNullableType(typeSymbol) && !TypeSymbolExtensions.IsObjectType(typeSymbol)))
				{
					return false;
				}
			}
			return BoundExpressionExtensions.IsNothingLiteral(boundExpression);
		}

		private void ReportUndefinedOperatorError(SyntaxNode syntax, BoundExpression left, BoundExpression right, SyntaxKind operatorTokenKind, BinaryOperatorKind operatorKind, BindingDiagnosticBag diagnostics)
		{
			TypeSymbol type = left.Type;
			TypeSymbol type2 = right.Type;
			if (TypeSymbolExtensions.IsErrorType(type) || TypeSymbolExtensions.IsErrorType(type2))
			{
				return;
			}
			string text = SyntaxFacts.GetText(operatorTokenKind);
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo;
			if (OverloadResolution.UseUserDefinedBinaryOperators(operatorKind, type, type2))
			{
				useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
				if (!TypeSymbolExtensions.CanContainUserDefinedOperators(type, ref useSiteInfo))
				{
					useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
					if (!TypeSymbolExtensions.CanContainUserDefinedOperators(type2, ref useSiteInfo) && (operatorKind == BinaryOperatorKind.Equals || operatorKind == BinaryOperatorKind.NotEquals) && type.IsReferenceType && type2.IsReferenceType)
					{
						ReportDiagnostic(diagnostics, syntax, ERRID.ERR_ReferenceComparison3, text, type, type2);
						return;
					}
				}
			}
			useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
			if (IsIEnumerableOfXElement(type, ref useSiteInfo))
			{
				ReportDiagnostic(diagnostics, syntax, ERRID.ERR_BinaryOperandsForXml4, text, type, type2, type);
				return;
			}
			useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
			if (IsIEnumerableOfXElement(type2, ref useSiteInfo))
			{
				ReportDiagnostic(diagnostics, syntax, ERRID.ERR_BinaryOperandsForXml4, text, type, type2, type2);
			}
			else
			{
				ReportDiagnostic(diagnostics, syntax, ERRID.ERR_BinaryOperands3, text, type, type2);
			}
		}

		private void ConvertNothingLiterals(BinaryOperatorKind operatorKind, ref BoundExpression left, ref BoundExpression right, BindingDiagnosticBag diagnostics)
		{
			if (BoundExpressionExtensions.IsNothingLiteral(left))
			{
				TypeSymbol typeSymbol;
				if (BoundExpressionExtensions.IsNothingLiteral(right))
				{
					SpecialType typeId;
					switch (operatorKind)
					{
					case BinaryOperatorKind.Concatenate:
					case BinaryOperatorKind.Like:
						typeId = SpecialType.System_String;
						break;
					case BinaryOperatorKind.OrElse:
					case BinaryOperatorKind.AndAlso:
						typeId = SpecialType.System_Boolean;
						break;
					case BinaryOperatorKind.Add:
					case BinaryOperatorKind.Equals:
					case BinaryOperatorKind.NotEquals:
					case BinaryOperatorKind.LessThanOrEqual:
					case BinaryOperatorKind.GreaterThanOrEqual:
					case BinaryOperatorKind.LessThan:
					case BinaryOperatorKind.GreaterThan:
					case BinaryOperatorKind.Subtract:
					case BinaryOperatorKind.Multiply:
					case BinaryOperatorKind.Power:
					case BinaryOperatorKind.Divide:
					case BinaryOperatorKind.Modulo:
					case BinaryOperatorKind.IntegerDivide:
					case BinaryOperatorKind.LeftShift:
					case BinaryOperatorKind.RightShift:
					case BinaryOperatorKind.Xor:
					case BinaryOperatorKind.Or:
					case BinaryOperatorKind.And:
						typeId = SpecialType.System_Int32;
						break;
					default:
						throw ExceptionUtilities.UnexpectedValue(operatorKind);
					}
					typeSymbol = GetSpecialType(typeId, right.Syntax, diagnostics);
					right = ApplyImplicitConversion(right.Syntax, typeSymbol, right, diagnostics);
				}
				else
				{
					typeSymbol = right.Type;
					if ((object)typeSymbol == null)
					{
						return;
					}
				}
				SpecialType specialType = SpecialType.None;
				switch (operatorKind)
				{
				case BinaryOperatorKind.Concatenate:
				case BinaryOperatorKind.Like:
					if (TypeSymbolExtensions.IsIntrinsicType(TypeSymbolExtensions.GetEnumUnderlyingTypeOrSelf(TypeSymbolExtensions.GetNullableUnderlyingTypeOrSelf(typeSymbol))) || TypeSymbolExtensions.IsCharSZArray(typeSymbol) || TypeSymbolExtensions.IsDBNullType(typeSymbol))
					{
						specialType = SpecialType.System_String;
					}
					break;
				case BinaryOperatorKind.LeftShift:
				case BinaryOperatorKind.RightShift:
					specialType = SpecialType.System_Int32;
					break;
				}
				left = ApplyImplicitConversion(targetType: (specialType != 0 && specialType != typeSymbol.SpecialType) ? GetSpecialType(specialType, left.Syntax, diagnostics) : typeSymbol, node: left.Syntax, expression: left, diagnostics: diagnostics);
			}
			else
			{
				if (!BoundExpressionExtensions.IsNothingLiteral(right))
				{
					return;
				}
				TypeSymbol type = left.Type;
				if ((object)type != null)
				{
					TypeSymbol typeSymbol = type;
					if ((uint)(operatorKind - 2) <= 1u && (TypeSymbolExtensions.IsIntrinsicType(TypeSymbolExtensions.GetEnumUnderlyingTypeOrSelf(TypeSymbolExtensions.GetNullableUnderlyingTypeOrSelf(type))) || TypeSymbolExtensions.IsCharSZArray(type) || TypeSymbolExtensions.IsDBNullType(type)) && type.SpecialType != SpecialType.System_String)
					{
						typeSymbol = GetSpecialType(SpecialType.System_String, right.Syntax, diagnostics);
					}
					right = ApplyImplicitConversion(right.Syntax, typeSymbol, right, diagnostics);
				}
			}
		}

		private BoundExpression BindUnaryOperator(Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			BoundExpression boundExpression = BindValue(node.Operand, diagnostics);
			UnaryOperatorKind unaryOperatorKind = OverloadResolution.MapUnaryOperatorKind(node.Kind());
			if (!boundExpression.HasErrors && BoundExpressionExtensions.IsNothingLiteral(boundExpression))
			{
				NamedTypeSymbol specialType = GetSpecialType(SpecialType.System_Int32, node.Operand, diagnostics);
				boundExpression = ApplyImplicitConversion(node.Operand, specialType, boundExpression, diagnostics);
			}
			else
			{
				boundExpression = MakeRValue(boundExpression, diagnostics);
			}
			if (boundExpression.HasErrors)
			{
				diagnostics = BindingDiagnosticBag.Discarded;
			}
			SpecialType intrinsicOperatorType = SpecialType.None;
			OverloadResolution.OverloadResolutionResult userDefinedOperator = default(OverloadResolution.OverloadResolutionResult);
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
			UnaryOperatorKind unaryOperatorKind2 = OverloadResolution.ResolveUnaryOperator(unaryOperatorKind, boundExpression, this, out intrinsicOperatorType, out userDefinedOperator, ref useSiteInfo);
			if (((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)node, useSiteInfo))
			{
				diagnostics = BindingDiagnosticBag.Discarded;
			}
			if (unaryOperatorKind2 == UnaryOperatorKind.UserDefined)
			{
				OverloadResolution.Candidate candidate = (userDefinedOperator.BestResult.HasValue ? userDefinedOperator.BestResult.Value.Candidate : null);
				if (candidate == null || !candidate.IsLifted || (OverloadResolution.IsValidInLiftedSignature(candidate.Parameters(0).Type) && OverloadResolution.IsValidInLiftedSignature(candidate.ReturnType)))
				{
					return BindUserDefinedUnaryOperator(node, unaryOperatorKind, boundExpression, ref userDefinedOperator, diagnostics);
				}
				unaryOperatorKind2 = UnaryOperatorKind.Error;
			}
			if (unaryOperatorKind2 == UnaryOperatorKind.Error)
			{
				ReportUndefinedOperatorError(node, boundExpression, diagnostics);
				return new BoundUnaryOperator(node, unaryOperatorKind | UnaryOperatorKind.Error, boundExpression, CheckOverflow, ErrorTypeSymbol.UnknownResultType, hasErrors: true);
			}
			TypeSymbol type = boundExpression.Type;
			TypeSymbol typeSymbol = null;
			if (intrinsicOperatorType == SpecialType.None)
			{
				typeSymbol = type;
			}
			else if (TypeSymbolExtensions.GetNullableUnderlyingTypeOrSelf(type).SpecialType == intrinsicOperatorType)
			{
				typeSymbol = type;
			}
			else
			{
				typeSymbol = GetSpecialType(intrinsicOperatorType, node.Operand, diagnostics);
				if (TypeSymbolExtensions.IsNullableType(type))
				{
					typeSymbol = ((NamedTypeSymbol)type.OriginalDefinition).Construct(typeSymbol);
				}
			}
			if (type.SpecialType == SpecialType.System_Object)
			{
				if (OptionStrict == OptionStrict.On)
				{
					BindingDiagnosticBag diagBag = diagnostics;
					SyntaxNodeOrToken syntax = node.Operand;
					SyntaxToken syntaxToken = node.OperatorToken;
					ReportDiagnostic(diagBag, syntax, ErrorFactory.ErrorInfo(ERRID.ERR_StrictDisallowsObjectOperand1, ref syntaxToken));
				}
				else if (OptionStrict == OptionStrict.Custom)
				{
					BindingDiagnosticBag diagBag2 = diagnostics;
					SyntaxNodeOrToken syntax2 = node.Operand;
					SyntaxToken syntaxToken = node.OperatorToken;
					ReportDiagnostic(diagBag2, syntax2, ErrorFactory.ErrorInfo(ERRID.WRN_ObjectMath2, ref syntaxToken));
				}
			}
			boundExpression = ApplyImplicitConversion(node.Operand, typeSymbol, boundExpression, diagnostics);
			ConstantValue constantValue = null;
			if (!boundExpression.HasErrors)
			{
				bool integerOverflow = false;
				constantValue = OverloadResolution.TryFoldConstantUnaryOperator(unaryOperatorKind2, boundExpression, typeSymbol, ref integerOverflow);
				if ((object)constantValue != null && (constantValue.IsBad || integerOverflow))
				{
					ReportDiagnostic(diagnostics, node, ErrorFactory.ErrorInfo(ERRID.ERR_ExpressionOverflow1, typeSymbol));
					if (!constantValue.IsBad)
					{
						constantValue = ConstantValue.Bad;
					}
				}
			}
			return new BoundUnaryOperator(node, unaryOperatorKind2, boundExpression, CheckOverflow, constantValue, typeSymbol);
		}

		private BoundUserDefinedUnaryOperator BindUserDefinedUnaryOperator(SyntaxNode node, UnaryOperatorKind opKind, BoundExpression operand, [In] ref OverloadResolution.OverloadResolutionResult userDefinedOperator, BindingDiagnosticBag diagnostics)
		{
			opKind |= UnaryOperatorKind.UserDefined;
			BoundExpression boundExpression;
			if (userDefinedOperator.BestResult.HasValue)
			{
				OverloadResolution.CandidateAnalysisResult value = userDefinedOperator.BestResult.Value;
				boundExpression = CreateBoundCallOrPropertyAccess(node, node, TypeCharacter.None, BoundNodeExtensions.MakeCompilerGenerated(new BoundMethodGroup(node, null, ImmutableArray.Create((MethodSymbol)value.Candidate.UnderlyingSymbol), LookupResultKind.Good, null, QualificationKind.Unqualified)), ImmutableArray.Create(operand), value, userDefinedOperator.AsyncLambdaSubToFunctionMismatch, diagnostics);
				if (value.Candidate.IsLifted)
				{
					opKind |= UnaryOperatorKind.Lifted;
				}
			}
			else
			{
				boundExpression = ReportOverloadResolutionFailureAndProduceBoundNode(node, LookupResultKind.Good, ImmutableArray.Create(operand), default(ImmutableArray<string>), ref userDefinedOperator, diagnostics, null);
			}
			return new BoundUserDefinedUnaryOperator(node, opKind, boundExpression, boundExpression.Type);
		}

		private static void ReportUndefinedOperatorError(Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax syntax, BoundExpression operand, BindingDiagnosticBag diagnostics)
		{
			if (!TypeSymbolExtensions.IsErrorType(operand.Type))
			{
				SyntaxNodeOrToken syntax2 = syntax;
				SyntaxToken syntaxToken = syntax.OperatorToken;
				ReportDiagnostic(diagnostics, syntax2, ErrorFactory.ErrorInfo(ERRID.ERR_UnaryOperand2, ref syntaxToken, operand.Type));
			}
		}

		private SynthesizedLambdaSymbol CreateQueryLambdaSymbol(VisualBasicSyntaxNode syntaxNode, SynthesizedLambdaKind kind, ImmutableArray<BoundLambdaParameterSymbol> parameters)
		{
			return new SynthesizedLambdaSymbol(kind, syntaxNode, parameters, LambdaSymbol.ReturnTypePendingDelegate, this);
		}

		private static BoundQueryLambda CreateBoundQueryLambda(SynthesizedLambdaSymbol queryLambdaSymbol, ImmutableArray<RangeVariableSymbol> rangeVariables, BoundExpression expression, bool exprIsOperandOfConditionalBranch)
		{
			return new BoundQueryLambda(queryLambdaSymbol.Syntax, queryLambdaSymbol, rangeVariables, expression, exprIsOperandOfConditionalBranch);
		}

		internal virtual BoundExpression BindGroupAggregationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupAggregationSyntax group, BindingDiagnosticBag diagnostics)
		{
			return BadExpression(group, ErrorTypeSymbol.UnknownResultType);
		}

		internal virtual BoundExpression BindFunctionAggregationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax function, BindingDiagnosticBag diagnostics)
		{
			return BadExpression(function, ErrorTypeSymbol.UnknownResultType);
		}

		private BoundExpression BindQueryExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax query, BindingDiagnosticBag diagnostics)
		{
			if (query.Clauses.Count < 1)
			{
				return BadExpression(query, ErrorTypeSymbol.UnknownResultType);
			}
			SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator enumerator = query.Clauses.GetEnumerator();
			enumerator.MoveNext();
			return enumerator.Current.Kind() switch
			{
				SyntaxKind.FromClause => BindFromQueryExpression(query, enumerator, diagnostics), 
				SyntaxKind.AggregateClause => BindAggregateQueryExpression(query, enumerator, diagnostics), 
				_ => BadExpression(query, ErrorTypeSymbol.UnknownResultType), 
			};
		}

		private BoundQueryClauseBase BindSubsequentQueryOperators(BoundQueryClauseBase source, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator operators, BindingDiagnosticBag diagnostics)
		{
			while (operators.MoveNext())
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax current = operators.Current;
				source = current.Kind() switch
				{
					SyntaxKind.FromClause => BindFromClause(source, (Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax)current, ref operators, diagnostics), 
					SyntaxKind.SelectClause => BindSelectClause(source, (Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax)current, operators, diagnostics), 
					SyntaxKind.LetClause => BindLetClause(source, (Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax)current, operators, diagnostics), 
					SyntaxKind.WhereClause => BindWhereClause(source, (Microsoft.CodeAnalysis.VisualBasic.Syntax.WhereClauseSyntax)current, diagnostics), 
					SyntaxKind.SkipWhileClause => BindSkipWhileClause(source, (Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax)current, diagnostics), 
					SyntaxKind.TakeWhileClause => BindTakeWhileClause(source, (Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax)current, diagnostics), 
					SyntaxKind.DistinctClause => BindDistinctClause(source, (Microsoft.CodeAnalysis.VisualBasic.Syntax.DistinctClauseSyntax)current, diagnostics), 
					SyntaxKind.SkipClause => BindSkipClause(source, (Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax)current, diagnostics), 
					SyntaxKind.TakeClause => BindTakeClause(source, (Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax)current, diagnostics), 
					SyntaxKind.OrderByClause => BindOrderByClause(source, (Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderByClauseSyntax)current, diagnostics), 
					SyntaxKind.SimpleJoinClause => BindInnerJoinClause(source, (Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax)current, null, ref operators, diagnostics), 
					SyntaxKind.GroupJoinClause => BindGroupJoinClause(source, (Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax)current, null, operators, diagnostics), 
					SyntaxKind.GroupByClause => BindGroupByClause(source, (Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax)current, diagnostics), 
					SyntaxKind.AggregateClause => BindAggregateClause(source, (Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax)current, operators, diagnostics), 
					_ => throw ExceptionUtilities.UnexpectedValue(current.Kind()), 
				};
			}
			return source;
		}

		private BoundQueryExpression BindFromQueryExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax query, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator operators, BindingDiagnosticBag diagnostics)
		{
			BoundQueryClauseBase source = BindFromClause(null, (Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax)operators.Current, ref operators, diagnostics);
			source = BindSubsequentQueryOperators(source, operators, diagnostics);
			if (!TypeSymbolExtensions.IsErrorType(source.Type) && source.Kind == BoundKind.QueryableSource && ((BoundQueryableSource)source).Source.Kind == BoundKind.QuerySource)
			{
				source = BindFinalImplicitSelectClause(source, diagnostics);
			}
			return new BoundQueryExpression(query, source, source.Type);
		}

		private BoundQueryExpression BindAggregateQueryExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax query, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator operators, BindingDiagnosticBag diagnostics)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax aggregateClauseSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax)operators.Current;
			bool flag = operators.MoveNext();
			operators = aggregateClauseSyntax.AdditionalQueryOperators.GetEnumerator();
			BoundQueryClauseBase source = BindCollectionRangeVariables(aggregateClauseSyntax, null, aggregateClauseSyntax.Variables, ref operators, diagnostics);
			source = BindSubsequentQueryOperators(source, operators, diagnostics);
			SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax> aggregationVariables = aggregateClauseSyntax.AggregationVariables;
			int count = aggregationVariables.Count;
			switch (count)
			{
			case 0:
			{
				IntoClauseDisallowGroupReferenceBinder item = new IntoClauseDisallowGroupReferenceBinder(this, source, source.RangeVariables, source.CompoundVariableType, source.RangeVariables);
				source = new BoundAggregateClause(aggregateClauseSyntax, null, null, BoundNodeExtensions.MakeCompilerGenerated(BadExpression(aggregateClauseSyntax, source, ErrorTypeSymbol.UnknownResultType)), ImmutableArray<RangeVariableSymbol>.Empty, ErrorTypeSymbol.UnknownResultType, ImmutableArray.Create((Binder)item), ErrorTypeSymbol.UnknownResultType);
				break;
			}
			case 1:
			{
				IntoClauseDisallowGroupReferenceBinder intoClauseDisallowGroupReferenceBinder2 = new IntoClauseDisallowGroupReferenceBinder(this, source, source.RangeVariables, source.CompoundVariableType, source.RangeVariables);
				BoundExpression selector = null;
				intoClauseDisallowGroupReferenceBinder2.BindAggregationRangeVariable(aggregationVariables[0], null, out selector, diagnostics);
				source = new BoundAggregateClause(aggregateClauseSyntax, null, null, selector, ImmutableArray<RangeVariableSymbol>.Empty, selector.Type, ImmutableArray.Create((Binder)intoClauseDisallowGroupReferenceBinder2), selector.Type);
				break;
			}
			default:
			{
				HashSet<string> declaredNames = CreateSetOfDeclaredNames();
				BoundExpression[] array = new BoundExpression[count - 1 + 1];
				AnonymousTypeField[] array2 = new AnonymousTypeField[array.Length - 1 + 1];
				BoundRValuePlaceholder boundRValuePlaceholder = BoundNodeExtensions.MakeCompilerGenerated(new BoundRValuePlaceholder(aggregateClauseSyntax, source.Type));
				IntoClauseDisallowGroupReferenceBinder intoClauseDisallowGroupReferenceBinder = new IntoClauseDisallowGroupReferenceBinder(this, boundRValuePlaceholder, source.RangeVariables, source.CompoundVariableType, source.RangeVariables);
				int num = count - 1;
				for (int i = 0; i <= num; i++)
				{
					RangeVariableSymbol rangeVariableSymbol = intoClauseDisallowGroupReferenceBinder.BindAggregationRangeVariable(aggregationVariables[i], declaredNames, out array[i], diagnostics);
					array2[i] = new AnonymousTypeField(rangeVariableSymbol.Name, rangeVariableSymbol.Type, rangeVariableSymbol.Syntax.GetLocation(), isKeyOrByRef: true);
				}
				BoundExpression boundExpression = BoundNodeExtensions.MakeCompilerGenerated(BindAnonymousObjectCreationExpression(aggregateClauseSyntax, new AnonymousTypeDescriptor(array2.AsImmutableOrNull(), aggregateClauseSyntax.IntoKeyword.GetLocation(), isImplicitlyDeclared: true), array.AsImmutableOrNull(), diagnostics));
				source = new BoundAggregateClause(aggregateClauseSyntax, source, boundRValuePlaceholder, boundExpression, ImmutableArray<RangeVariableSymbol>.Empty, boundExpression.Type, ImmutableArray.Create((Binder)intoClauseDisallowGroupReferenceBinder), boundExpression.Type);
				break;
			}
			}
			return new BoundQueryExpression(query, source, flag ? ErrorTypeSymbol.UnknownResultType : source.Type, flag);
		}

		private BoundAggregateClause BindAggregateClause(BoundQueryClauseBase source, Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax aggregate, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator operatorsEnumerator, BindingDiagnosticBag diagnostics)
		{
			BoundLambdaParameterSymbol item = CreateQueryLambdaParameterSymbol(GetQueryLambdaParameterName(source.RangeVariables), 0, source.CompoundVariableType, aggregate, source.RangeVariables);
			SynthesizedLambdaSymbol synthesizedLambdaSymbol = CreateQueryLambdaSymbol(LambdaUtilities.GetAggregateLambdaBody(aggregate), SynthesizedLambdaKind.AggregateQueryLambda, ImmutableArray.Create(item));
			QueryLambdaBinder queryLambdaBinder = new QueryLambdaBinder(synthesizedLambdaSymbol, source.RangeVariables);
			ImmutableArray<RangeVariableSymbol> declaredRangeVariables = default(ImmutableArray<RangeVariableSymbol>);
			BoundQueryClauseBase group = null;
			IntoClauseDisallowGroupReferenceBinder intoBinder = null;
			BoundExpression boundExpression = queryLambdaBinder.BindAggregateClauseFirstSelector(aggregate, operatorsEnumerator, source.RangeVariables, ImmutableArray<RangeVariableSymbol>.Empty, out declaredRangeVariables, out group, out intoBinder, diagnostics);
			BoundQueryLambda boundQueryLambda = CreateBoundQueryLambda(synthesizedLambdaSymbol, source.RangeVariables, boundExpression, exprIsOperandOfConditionalBranch: false);
			synthesizedLambdaSymbol.SetQueryLambdaReturnType(boundExpression.Type);
			boundQueryLambda.SetWasCompilerGenerated();
			BoundExpression firstSelectExpression;
			if (TypeSymbolExtensions.IsErrorType(source.Type))
			{
				firstSelectExpression = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(aggregate, ImmutableArray.Create((BoundExpression)source, (BoundExpression)boundQueryLambda), ErrorTypeSymbol.UnknownResultType));
			}
			else
			{
				BindingDiagnosticBag diagnostics2 = diagnostics;
				if (ShouldSuppressDiagnostics(boundQueryLambda))
				{
					diagnostics2 = BindingDiagnosticBag.Discarded;
				}
				firstSelectExpression = BindQueryOperatorCall(aggregate, source, "Select", ImmutableArray.Create((BoundExpression)boundQueryLambda), aggregate.AggregateKeyword.Span, diagnostics2);
			}
			return CompleteAggregateClauseBinding(aggregate, operatorsEnumerator, source.RangeVariables, ImmutableArray<RangeVariableSymbol>.Empty, firstSelectExpression, queryLambdaBinder, declaredRangeVariables, boundQueryLambda.Expression.Type, group, intoBinder, diagnostics);
		}

		private BoundAggregateClause CompleteAggregateClauseBinding(Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax aggregate, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator operatorsEnumerator, ImmutableArray<RangeVariableSymbol> sourceRangeVariablesPart1, ImmutableArray<RangeVariableSymbol> sourceRangeVariablesPart2, BoundExpression firstSelectExpression, QueryLambdaBinder firstSelectSelectorBinder, ImmutableArray<RangeVariableSymbol> firstSelectDeclaredRangeVariables, TypeSymbol firstSelectCompoundVariableType, BoundQueryClauseBase group, IntoClauseDisallowGroupReferenceBinder intoBinder, BindingDiagnosticBag diagnostics)
		{
			SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax> aggregationVariables = aggregate.AggregationVariables;
			if (aggregationVariables.Count <= 1)
			{
				return new BoundAggregateClause(aggregate, null, null, firstSelectExpression, firstSelectSelectorBinder.RangeVariables.Concat(firstSelectDeclaredRangeVariables), firstSelectCompoundVariableType, ImmutableArray.Create((Binder)firstSelectSelectorBinder, (Binder)intoBinder), firstSelectExpression.Type);
			}
			bool flag = firstSelectExpression.Kind == BoundKind.BadExpression;
			if (!flag && firstSelectExpression.HasErrors && firstSelectExpression.Kind == BoundKind.QueryClause)
			{
				flag = ((BoundQueryClause)firstSelectExpression).UnderlyingExpression.Kind == BoundKind.BadExpression;
			}
			BoundQueryClause boundQueryClause = BoundNodeExtensions.MakeCompilerGenerated(new BoundQueryClause(aggregate, firstSelectExpression, firstSelectSelectorBinder.RangeVariables.Concat(firstSelectDeclaredRangeVariables), firstSelectCompoundVariableType, ImmutableArray<Binder>.Empty, firstSelectExpression.Type));
			BoundLambdaParameterSymbol boundLambdaParameterSymbol = CreateQueryLambdaParameterSymbol(GetQueryLambdaParameterName(boundQueryClause.RangeVariables), 0, boundQueryClause.CompoundVariableType, aggregate, boundQueryClause.RangeVariables);
			SynthesizedLambdaSymbol synthesizedLambdaSymbol = CreateQueryLambdaSymbol(aggregate, SynthesizedLambdaKind.AggregateNonUserCodeQueryLambda, ImmutableArray.Create(boundLambdaParameterSymbol));
			RangeVariableSymbol rangeVariableSymbol = firstSelectDeclaredRangeVariables[0];
			QueryLambdaBinder parent = new QueryLambdaBinder(synthesizedLambdaSymbol, ImmutableArray<RangeVariableSymbol>.Empty);
			BoundRangeVariable groupReference = BoundNodeExtensions.MakeCompilerGenerated(new BoundRangeVariable(rangeVariableSymbol.Syntax, rangeVariableSymbol, rangeVariableSymbol.Type));
			intoBinder = new IntoClauseDisallowGroupReferenceBinder(parent, groupReference, group.RangeVariables, group.CompoundVariableType, firstSelectSelectorBinder.RangeVariables.Concat(group.RangeVariables));
			BoundExpression compoundKeyReferencePart;
			ImmutableArray<RangeVariableSymbol> keysRangeVariablesPart;
			BoundExpression compoundKeyReferencePart2;
			ImmutableArray<RangeVariableSymbol> keysRangeVariablesPart2;
			if (sourceRangeVariablesPart1.Length > 0)
			{
				AnonymousTypeManager.AnonymousTypePublicSymbol anonymousTypePublicSymbol = (AnonymousTypeManager.AnonymousTypePublicSymbol)boundLambdaParameterSymbol.Type;
				AnonymousTypeManager.AnonymousTypePropertyPublicSymbol propertySymbol = anonymousTypePublicSymbol.Properties[0];
				compoundKeyReferencePart = BoundNodeExtensions.MakeCompilerGenerated(new BoundPropertyAccess(aggregate, propertySymbol, null, PropertyAccessKind.Get, isWriteable: false, BoundNodeExtensions.MakeCompilerGenerated(new BoundParameter(boundLambdaParameterSymbol.Syntax, boundLambdaParameterSymbol, isLValue: false, boundLambdaParameterSymbol.Type)), ImmutableArray<BoundExpression>.Empty));
				keysRangeVariablesPart = sourceRangeVariablesPart1;
				if (sourceRangeVariablesPart2.Length > 0)
				{
					propertySymbol = anonymousTypePublicSymbol.Properties[1];
					compoundKeyReferencePart2 = BoundNodeExtensions.MakeCompilerGenerated(new BoundPropertyAccess(aggregate, propertySymbol, null, PropertyAccessKind.Get, isWriteable: false, BoundNodeExtensions.MakeCompilerGenerated(new BoundParameter(boundLambdaParameterSymbol.Syntax, boundLambdaParameterSymbol, isLValue: false, boundLambdaParameterSymbol.Type)), ImmutableArray<BoundExpression>.Empty));
					keysRangeVariablesPart2 = sourceRangeVariablesPart2;
				}
				else
				{
					compoundKeyReferencePart2 = null;
					keysRangeVariablesPart2 = ImmutableArray<RangeVariableSymbol>.Empty;
				}
			}
			else if (sourceRangeVariablesPart2.Length > 0)
			{
				AnonymousTypeManager.AnonymousTypePropertyPublicSymbol propertySymbol2 = ((AnonymousTypeManager.AnonymousTypePublicSymbol)boundLambdaParameterSymbol.Type).Properties[0];
				compoundKeyReferencePart = BoundNodeExtensions.MakeCompilerGenerated(new BoundPropertyAccess(aggregate, propertySymbol2, null, PropertyAccessKind.Get, isWriteable: false, BoundNodeExtensions.MakeCompilerGenerated(new BoundParameter(boundLambdaParameterSymbol.Syntax, boundLambdaParameterSymbol, isLValue: false, boundLambdaParameterSymbol.Type)), ImmutableArray<BoundExpression>.Empty));
				keysRangeVariablesPart = sourceRangeVariablesPart2;
				compoundKeyReferencePart2 = null;
				keysRangeVariablesPart2 = ImmutableArray<RangeVariableSymbol>.Empty;
			}
			else
			{
				compoundKeyReferencePart = null;
				keysRangeVariablesPart = ImmutableArray<RangeVariableSymbol>.Empty;
				compoundKeyReferencePart2 = null;
				keysRangeVariablesPart2 = ImmutableArray<RangeVariableSymbol>.Empty;
			}
			ImmutableArray<RangeVariableSymbol> declaredRangeVariables = default(ImmutableArray<RangeVariableSymbol>);
			BoundExpression boundExpression = intoBinder.BindIntoSelector(aggregate, firstSelectSelectorBinder.RangeVariables, compoundKeyReferencePart, keysRangeVariablesPart, compoundKeyReferencePart2, keysRangeVariablesPart2, null, aggregationVariables, MustProduceFlatCompoundVariable(operatorsEnumerator), out declaredRangeVariables, diagnostics);
			BoundQueryLambda boundQueryLambda = CreateBoundQueryLambda(synthesizedLambdaSymbol, boundQueryClause.RangeVariables, boundExpression, exprIsOperandOfConditionalBranch: false);
			synthesizedLambdaSymbol.SetQueryLambdaReturnType(boundExpression.Type);
			boundQueryLambda.SetWasCompilerGenerated();
			BoundExpression boundExpression2;
			if (TypeSymbolExtensions.IsErrorType(boundQueryClause.Type))
			{
				boundExpression2 = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(aggregate, ImmutableArray.Create((BoundExpression)boundQueryClause, (BoundExpression)boundQueryLambda), ErrorTypeSymbol.UnknownResultType));
			}
			else
			{
				BindingDiagnosticBag diagnostics2 = diagnostics;
				if (flag || ShouldSuppressDiagnostics(boundQueryLambda))
				{
					diagnostics2 = BindingDiagnosticBag.Discarded;
				}
				boundExpression2 = BindQueryOperatorCall(aggregate, boundQueryClause, "Select", ImmutableArray.Create((BoundExpression)boundQueryLambda), aggregate.AggregateKeyword.Span, diagnostics2);
			}
			return new BoundAggregateClause(aggregate, null, null, boundExpression2, firstSelectSelectorBinder.RangeVariables.Concat(declaredRangeVariables), boundQueryLambda.Expression.Type, ImmutableArray.Create((Binder)firstSelectSelectorBinder, (Binder)intoBinder), boundExpression2.Type);
		}

		private BoundQueryClause BindFinalImplicitSelectClause(BoundQueryClauseBase source, BindingDiagnosticBag diagnostics)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax fromClauseSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax)source.Syntax.Parent;
			BoundLambdaParameterSymbol boundLambdaParameterSymbol = CreateQueryLambdaParameterSymbol(GetQueryLambdaParameterName(source.RangeVariables), 0, source.CompoundVariableType, fromClauseSyntax, source.RangeVariables);
			LambdaUtilities.IsNonUserCodeQueryLambda(fromClauseSyntax);
			SynthesizedLambdaSymbol synthesizedLambdaSymbol = CreateQueryLambdaSymbol(fromClauseSyntax, SynthesizedLambdaKind.FromNonUserCodeQueryLambda, ImmutableArray.Create(boundLambdaParameterSymbol));
			synthesizedLambdaSymbol.SetQueryLambdaReturnType(source.CompoundVariableType);
			BoundQueryLambda boundQueryLambda = CreateBoundQueryLambda(expression: BoundNodeExtensions.MakeCompilerGenerated(new BoundParameter(boundLambdaParameterSymbol.Syntax, boundLambdaParameterSymbol, isLValue: false, boundLambdaParameterSymbol.Type)), queryLambdaSymbol: synthesizedLambdaSymbol, rangeVariables: ImmutableArray<RangeVariableSymbol>.Empty, exprIsOperandOfConditionalBranch: false);
			boundQueryLambda.SetWasCompilerGenerated();
			if (TypeSymbolExtensions.IsErrorType(boundLambdaParameterSymbol.Type))
			{
				diagnostics = BindingDiagnosticBag.Discarded;
			}
			BoundExpression boundExpression = BindQueryOperatorCall(source.Syntax.Parent, source, "Select", ImmutableArray.Create((BoundExpression)boundQueryLambda), source.Syntax.Span, diagnostics);
			return BoundNodeExtensions.MakeCompilerGenerated(new BoundQueryClause(source.Syntax.Parent, boundExpression, ImmutableArray<RangeVariableSymbol>.Empty, source.CompoundVariableType, ImmutableArray<Binder>.Empty, boundExpression.Type));
		}

		private BoundQueryClause BindSelectClause(BoundQueryClauseBase source, Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax clauseSyntax, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator operatorsEnumerator, BindingDiagnosticBag diagnostics)
		{
			BoundLambdaParameterSymbol item = CreateQueryLambdaParameterSymbol(GetQueryLambdaParameterName(source.RangeVariables), 0, source.CompoundVariableType, clauseSyntax, source.RangeVariables);
			SynthesizedLambdaSymbol synthesizedLambdaSymbol = CreateQueryLambdaSymbol(LambdaUtilities.GetSelectLambdaBody(clauseSyntax), SynthesizedLambdaKind.SelectQueryLambda, ImmutableArray.Create(item));
			QueryLambdaBinder queryLambdaBinder = new QueryLambdaBinder(synthesizedLambdaSymbol, source.RangeVariables);
			ImmutableArray<RangeVariableSymbol> declaredRangeVariables = default(ImmutableArray<RangeVariableSymbol>);
			BoundExpression boundExpression = queryLambdaBinder.BindSelectClauseSelector(clauseSyntax, operatorsEnumerator, out declaredRangeVariables, diagnostics);
			BoundQueryLambda boundQueryLambda = CreateBoundQueryLambda(synthesizedLambdaSymbol, source.RangeVariables, boundExpression, exprIsOperandOfConditionalBranch: false);
			synthesizedLambdaSymbol.SetQueryLambdaReturnType(boundExpression.Type);
			boundQueryLambda.SetWasCompilerGenerated();
			BoundExpression boundExpression2;
			if (TypeSymbolExtensions.IsErrorType(source.Type))
			{
				boundExpression2 = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(clauseSyntax, ImmutableArray.Create((BoundExpression)source, (BoundExpression)boundQueryLambda), ErrorTypeSymbol.UnknownResultType));
			}
			else
			{
				if (ShouldSuppressDiagnostics(boundQueryLambda))
				{
					diagnostics = BindingDiagnosticBag.Discarded;
				}
				boundExpression2 = BindQueryOperatorCall(clauseSyntax, source, "Select", ImmutableArray.Create((BoundExpression)boundQueryLambda), clauseSyntax.SelectKeyword.Span, diagnostics);
			}
			return new BoundQueryClause(clauseSyntax, boundExpression2, declaredRangeVariables, boundQueryLambda.Expression.Type, ImmutableArray.Create((Binder)queryLambdaBinder), boundExpression2.Type);
		}

		private static bool ShouldSuppressDiagnostics(BoundQueryLambda lambda)
		{
			if (lambda.HasErrors)
			{
				return true;
			}
			ImmutableArray<ParameterSymbol>.Enumerator enumerator = lambda.LambdaSymbol.Parameters.GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (TypeSymbolExtensions.IsErrorType(enumerator.Current.Type))
				{
					return true;
				}
			}
			TypeSymbol type = lambda.Expression.Type;
			return (object)type != null && TypeSymbolExtensions.IsErrorType(type);
		}

		private static bool ShadowsRangeVariableInTheChildScope(Binder childScopeBinder, RangeVariableSymbol rangeVar)
		{
			LookupResult instance = LookupResult.GetInstance();
			string name = rangeVar.Name;
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
			childScopeBinder.LookupInSingleBinder(instance, name, 0, LookupOptions.Default, childScopeBinder, ref useSiteInfo);
			bool result = instance.IsGood && instance.Symbols[0].Kind == SymbolKind.RangeVariable;
			instance.Free();
			return result;
		}

		private BoundQueryClause BindLetClause(BoundQueryClauseBase source, Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax clauseSyntax, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator operatorsEnumerator, BindingDiagnosticBag diagnostics, bool skipFirstVariable = false)
		{
			BindingDiagnosticBag bindingDiagnosticBag = diagnostics;
			SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax> variables = clauseSyntax.Variables;
			if (variables.Count == 0)
			{
				return new BoundQueryClause(clauseSyntax, BoundNodeExtensions.MakeCompilerGenerated(BadExpression(clauseSyntax, source, ErrorTypeSymbol.UnknownResultType)), source.RangeVariables.Add(RangeVariableSymbol.CreateForErrorRecovery(this, clauseSyntax, ErrorTypeSymbol.UnknownResultType)), ErrorTypeSymbol.UnknownResultType, ImmutableArray.Create(this), ErrorTypeSymbol.UnknownResultType, hasErrors: true);
			}
			int num = (skipFirstVariable ? 1 : 0);
			int num2 = variables.Count - 1;
			for (int i = num; i <= num2; i++)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax expressionRangeVariableSyntax = variables[i];
				BoundLambdaParameterSymbol item = CreateQueryLambdaParameterSymbol(GetQueryLambdaParameterName(source.RangeVariables), 0, source.CompoundVariableType, expressionRangeVariableSyntax, source.RangeVariables);
				SynthesizedLambdaSymbol synthesizedLambdaSymbol = CreateQueryLambdaSymbol(LambdaUtilities.GetLetVariableLambdaBody(expressionRangeVariableSyntax), SynthesizedLambdaKind.LetVariableQueryLambda, ImmutableArray.Create(item));
				QueryLambdaBinder queryLambdaBinder = new QueryLambdaBinder(synthesizedLambdaSymbol, source.RangeVariables);
				ImmutableArray<RangeVariableSymbol> declaredRangeVariables = default(ImmutableArray<RangeVariableSymbol>);
				BoundExpression boundExpression = queryLambdaBinder.BindLetClauseVariableSelector(expressionRangeVariableSyntax, operatorsEnumerator, out declaredRangeVariables, diagnostics);
				BoundQueryLambda boundQueryLambda = CreateBoundQueryLambda(synthesizedLambdaSymbol, source.RangeVariables, boundExpression, exprIsOperandOfConditionalBranch: false);
				synthesizedLambdaSymbol.SetQueryLambdaReturnType(boundExpression.Type);
				boundQueryLambda.SetWasCompilerGenerated();
				BoundExpression boundExpression2;
				if (TypeSymbolExtensions.IsErrorType(source.Type))
				{
					boundExpression2 = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(expressionRangeVariableSyntax, ImmutableArray.Create((BoundExpression)source, (BoundExpression)boundQueryLambda), ErrorTypeSymbol.UnknownResultType));
				}
				else
				{
					if (bindingDiagnosticBag != BindingDiagnosticBag.Discarded && ShouldSuppressDiagnostics(boundQueryLambda))
					{
						bindingDiagnosticBag = BindingDiagnosticBag.Discarded;
					}
					boundExpression2 = BindQueryOperatorCall(operatorNameLocation: (i != 0) ? variables.GetSeparator(i - 1).Span : clauseSyntax.LetKeyword.Span, node: expressionRangeVariableSyntax, source: source, operatorName: "Select", arguments: ImmutableArray.Create((BoundExpression)boundQueryLambda), diagnostics: bindingDiagnosticBag);
				}
				source = new BoundQueryClause(expressionRangeVariableSyntax, boundExpression2, source.RangeVariables.Concat(declaredRangeVariables), boundQueryLambda.Expression.Type, ImmutableArray.Create((Binder)queryLambdaBinder), boundExpression2.Type);
			}
			return (BoundQueryClause)source;
		}

		private static bool MustProduceFlatCompoundVariable(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator operatorsEnumerator)
		{
			while (operatorsEnumerator.MoveNext())
			{
				switch (operatorsEnumerator.Current.Kind())
				{
				case SyntaxKind.FromClause:
				case SyntaxKind.LetClause:
				case SyntaxKind.AggregateClause:
				case SyntaxKind.SimpleJoinClause:
				case SyntaxKind.GroupJoinClause:
				case SyntaxKind.SelectClause:
					return false;
				case SyntaxKind.GroupByClause:
					return ((Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax)operatorsEnumerator.Current).Items.Count == 0;
				}
			}
			return true;
		}

		private static bool MustProduceFlatCompoundVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax groupOrInnerJoin, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator operatorsEnumerator)
		{
			switch (groupOrInnerJoin.Parent.Kind())
			{
			case SyntaxKind.SimpleJoinClause:
				return false;
			case SyntaxKind.GroupJoinClause:
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax groupJoinClauseSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax)groupOrInnerJoin.Parent;
				return groupOrInnerJoin == groupJoinClauseSyntax.AdditionalJoins.LastOrDefault();
			}
			default:
				return MustProduceFlatCompoundVariable(operatorsEnumerator);
			}
		}

		private BoundQueryClauseBase BindFromClause(BoundQueryClauseBase sourceOpt, Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax from, ref SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator operatorsEnumerator, BindingDiagnosticBag diagnostics)
		{
			return BindCollectionRangeVariables(from, sourceOpt, from.Variables, ref operatorsEnumerator, diagnostics);
		}

		private BoundQueryClauseBase BindCollectionRangeVariables(Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax clauseSyntax, BoundQueryClauseBase sourceOpt, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax> variables, ref SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator operatorsEnumerator, BindingDiagnosticBag diagnostics)
		{
			if (variables.Count == 0)
			{
				RangeVariableSymbol item = RangeVariableSymbol.CreateForErrorRecovery(this, clauseSyntax, ErrorTypeSymbol.UnknownResultType);
				if (sourceOpt == null)
				{
					return new BoundQueryableSource(clauseSyntax, BoundNodeExtensions.MakeCompilerGenerated(new BoundQuerySource(BoundNodeExtensions.MakeCompilerGenerated(BadExpression(clauseSyntax, ErrorTypeSymbol.UnknownResultType)))), null, ImmutableArray.Create(item), ErrorTypeSymbol.UnknownResultType, ImmutableArray.Create(this), ErrorTypeSymbol.UnknownResultType, hasErrors: true);
				}
				return new BoundQueryClause(clauseSyntax, BoundNodeExtensions.MakeCompilerGenerated(BadExpression(clauseSyntax, sourceOpt, ErrorTypeSymbol.UnknownResultType)), sourceOpt.RangeVariables.Add(item), ErrorTypeSymbol.UnknownResultType, ImmutableArray.Create(this), ErrorTypeSymbol.UnknownResultType, hasErrors: true);
			}
			BoundQueryClauseBase boundQueryClauseBase = sourceOpt;
			if (boundQueryClauseBase == null)
			{
				boundQueryClauseBase = BindCollectionRangeVariable(variables[0], beginsTheQuery: true, null, diagnostics);
			}
			BindingDiagnosticBag bindingDiagnosticBag = diagnostics;
			int num = ((boundQueryClauseBase != sourceOpt) ? 1 : 0);
			int num2 = variables.Count - 1;
			for (int i = num; i <= num2; i++)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax collectionRangeVariableSyntax = variables[i];
				BoundLambdaParameterSymbol item2 = CreateQueryLambdaParameterSymbol(GetQueryLambdaParameterName(boundQueryClauseBase.RangeVariables), 0, boundQueryClauseBase.CompoundVariableType, collectionRangeVariableSyntax, boundQueryClauseBase.RangeVariables);
				SynthesizedLambdaSymbol synthesizedLambdaSymbol = CreateQueryLambdaSymbol(LambdaUtilities.GetFromOrAggregateVariableLambdaBody(collectionRangeVariableSyntax), SynthesizedLambdaKind.FromOrAggregateVariableQueryLambda, ImmutableArray.Create(item2));
				QueryLambdaBinder queryLambdaBinder = new QueryLambdaBinder(synthesizedLambdaSymbol, boundQueryClauseBase.RangeVariables);
				BoundQueryableSource boundQueryableSource = queryLambdaBinder.BindCollectionRangeVariable(collectionRangeVariableSyntax, beginsTheQuery: false, null, diagnostics);
				BoundQueryLambda boundQueryLambda = CreateBoundQueryLambda(synthesizedLambdaSymbol, boundQueryClauseBase.RangeVariables, boundQueryableSource, exprIsOperandOfConditionalBranch: false);
				boundQueryLambda.SetWasCompilerGenerated();
				BoundLambdaParameterSymbol item3 = CreateQueryLambdaParameterSymbol(GetQueryLambdaParameterNameLeft(boundQueryClauseBase.RangeVariables), 0, boundQueryClauseBase.CompoundVariableType, collectionRangeVariableSyntax, boundQueryClauseBase.RangeVariables);
				BoundLambdaParameterSymbol boundLambdaParameterSymbol = CreateQueryLambdaParameterSymbol(GetQueryLambdaParameterNameRight(boundQueryableSource.RangeVariables), 1, boundQueryableSource.CompoundVariableType, collectionRangeVariableSyntax, boundQueryableSource.RangeVariables);
				Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax queryClauseSyntax = null;
				if (i == variables.Count - 1)
				{
					queryClauseSyntax = JoinShouldAbsorbNextOperator(ref operatorsEnumerator);
				}
				ImmutableArray<RangeVariableSymbol> rangeVariables = boundQueryClauseBase.RangeVariables;
				ImmutableArray<RangeVariableSymbol> rangeVariables2 = rangeVariables.Concat(boundQueryableSource.RangeVariables);
				BoundQueryClauseBase group = null;
				IntoClauseDisallowGroupReferenceBinder intoBinder = null;
				QueryLambdaBinder queryLambdaBinder2 = null;
				SynthesizedLambdaKind lambdaKind = SynthesizedLambdaKind.UserDefined;
				VisualBasicSyntaxNode lambdaSyntax = null;
				GetAbsorbingJoinSelectorLambdaKindAndSyntax(clauseSyntax, queryClauseSyntax, out lambdaKind, out lambdaSyntax);
				SynthesizedLambdaSymbol synthesizedLambdaSymbol2 = CreateQueryLambdaSymbol(lambdaSyntax, lambdaKind, ImmutableArray.Create(item3, boundLambdaParameterSymbol));
				ImmutableArray<RangeVariableSymbol> joinSelectorDeclaredRangeVariables;
				BoundExpression boundExpression;
				ImmutableArray<Binder> binders;
				if (queryClauseSyntax != null)
				{
					queryLambdaBinder2 = new QueryLambdaBinder(synthesizedLambdaSymbol2, rangeVariables2);
					joinSelectorDeclaredRangeVariables = default(ImmutableArray<RangeVariableSymbol>);
					boundExpression = queryLambdaBinder2.BindAbsorbingJoinSelector(queryClauseSyntax, operatorsEnumerator, rangeVariables, boundQueryableSource.RangeVariables, out joinSelectorDeclaredRangeVariables, out group, out intoBinder, diagnostics);
					binders = ImmutableArray.Create((Binder)queryLambdaBinder, (Binder)queryLambdaBinder2);
				}
				else
				{
					joinSelectorDeclaredRangeVariables = ImmutableArray<RangeVariableSymbol>.Empty;
					if (rangeVariables.Length > 0)
					{
						queryLambdaBinder2 = new QueryLambdaBinder(synthesizedLambdaSymbol2, rangeVariables2);
						boundExpression = queryLambdaBinder2.BuildJoinSelector(collectionRangeVariableSyntax, i == variables.Count - 1 && MustProduceFlatCompoundVariable(operatorsEnumerator), diagnostics);
					}
					else
					{
						boundExpression = BoundNodeExtensions.MakeCompilerGenerated(new BoundParameter(boundLambdaParameterSymbol.Syntax, boundLambdaParameterSymbol, isLValue: false, boundLambdaParameterSymbol.Type));
					}
					binders = ImmutableArray.Create((Binder)queryLambdaBinder);
				}
				BoundQueryLambda boundQueryLambda2 = CreateBoundQueryLambda(synthesizedLambdaSymbol2, rangeVariables2, boundExpression, exprIsOperandOfConditionalBranch: false);
				synthesizedLambdaSymbol2.SetQueryLambdaReturnType(boundExpression.Type);
				boundQueryLambda2.SetWasCompilerGenerated();
				BoundExpression boundExpression2;
				if (TypeSymbolExtensions.IsErrorType(boundQueryClauseBase.Type))
				{
					boundExpression2 = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(collectionRangeVariableSyntax, ImmutableArray.Create<BoundExpression>(boundQueryClauseBase, boundQueryLambda, boundQueryLambda2), ErrorTypeSymbol.UnknownResultType));
				}
				else
				{
					if (bindingDiagnosticBag != BindingDiagnosticBag.Discarded && (ShouldSuppressDiagnostics(boundQueryLambda) || ShouldSuppressDiagnostics(boundQueryLambda2)))
					{
						bindingDiagnosticBag = BindingDiagnosticBag.Discarded;
					}
					boundExpression2 = BindQueryOperatorCall(operatorNameLocation: (i != 0) ? variables.GetSeparator(i - 1).Span : clauseSyntax.GetFirstToken().Span, node: collectionRangeVariableSyntax, source: boundQueryClauseBase, operatorName: "SelectMany", arguments: ImmutableArray.Create((BoundExpression)boundQueryLambda, (BoundExpression)boundQueryLambda2), diagnostics: bindingDiagnosticBag);
				}
				boundQueryClauseBase = new BoundQueryClause(collectionRangeVariableSyntax, boundExpression2, rangeVariables2, boundQueryLambda2.Expression.Type, binders, boundExpression2.Type);
				if (queryClauseSyntax != null)
				{
					boundQueryClauseBase = AbsorbOperatorFollowingJoin((BoundQueryClause)boundQueryClauseBase, queryClauseSyntax, operatorsEnumerator, joinSelectorDeclaredRangeVariables, queryLambdaBinder2, rangeVariables, boundQueryableSource.RangeVariables, group, intoBinder, diagnostics);
					break;
				}
			}
			return boundQueryClauseBase;
		}

		private static void GetAbsorbingJoinSelectorLambdaKindAndSyntax(Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax clauseSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax absorbNextOperator, out SynthesizedLambdaKind lambdaKind, out VisualBasicSyntaxNode lambdaSyntax)
		{
			if (absorbNextOperator == null)
			{
				switch (clauseSyntax.Kind())
				{
				case SyntaxKind.SimpleJoinClause:
					lambdaKind = SynthesizedLambdaKind.JoinNonUserCodeQueryLambda;
					break;
				case SyntaxKind.FromClause:
					lambdaKind = SynthesizedLambdaKind.FromNonUserCodeQueryLambda;
					break;
				case SyntaxKind.AggregateClause:
					lambdaKind = SynthesizedLambdaKind.FromNonUserCodeQueryLambda;
					break;
				default:
					throw ExceptionUtilities.UnexpectedValue(clauseSyntax.Kind());
				}
				lambdaSyntax = clauseSyntax;
				return;
			}
			switch (absorbNextOperator.Kind())
			{
			case SyntaxKind.AggregateClause:
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax rangeVariable2 = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax)absorbNextOperator).Variables.First();
				lambdaSyntax = LambdaUtilities.GetFromOrAggregateVariableLambdaBody(rangeVariable2);
				lambdaKind = SynthesizedLambdaKind.AggregateQueryLambda;
				break;
			}
			case SyntaxKind.LetClause:
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax rangeVariable = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax)absorbNextOperator).Variables.First();
				lambdaSyntax = LambdaUtilities.GetLetVariableLambdaBody(rangeVariable);
				lambdaKind = SynthesizedLambdaKind.LetVariableQueryLambda;
				break;
			}
			case SyntaxKind.SelectClause:
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax selectClause = (Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax)absorbNextOperator;
				lambdaSyntax = LambdaUtilities.GetSelectLambdaBody(selectClause);
				lambdaKind = SynthesizedLambdaKind.SelectQueryLambda;
				break;
			}
			default:
				throw ExceptionUtilities.UnexpectedValue(absorbNextOperator.Kind());
			}
		}

		private static Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax JoinShouldAbsorbNextOperator(ref SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator operatorsEnumerator)
		{
			SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator enumerator = operatorsEnumerator;
			if (enumerator.MoveNext())
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax current = enumerator.Current;
				switch (current.Kind())
				{
				case SyntaxKind.LetClause:
					if (((Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax)current).Variables.Count > 0)
					{
						operatorsEnumerator = enumerator;
						return current;
					}
					break;
				case SyntaxKind.SelectClause:
					operatorsEnumerator = enumerator;
					return current;
				case SyntaxKind.AggregateClause:
					operatorsEnumerator = enumerator;
					return current;
				}
			}
			return null;
		}

		private BoundQueryClauseBase AbsorbOperatorFollowingJoin(BoundQueryClause absorbingJoin, Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax absorbNextOperator, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator operatorsEnumerator, ImmutableArray<RangeVariableSymbol> joinSelectorDeclaredRangeVariables, QueryLambdaBinder joinSelectorBinder, ImmutableArray<RangeVariableSymbol> leftRangeVariables, ImmutableArray<RangeVariableSymbol> rightRangeVariables, BoundQueryClauseBase group, IntoClauseDisallowGroupReferenceBinder intoBinder, BindingDiagnosticBag diagnostics)
		{
			switch (absorbNextOperator.Kind())
			{
			case SyntaxKind.SelectClause:
				return new BoundQueryClause(absorbNextOperator, absorbingJoin, joinSelectorDeclaredRangeVariables, absorbingJoin.CompoundVariableType, ImmutableArray.Create(absorbingJoin.Binders.Last()), absorbingJoin.Type);
			case SyntaxKind.LetClause:
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax letClauseSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax)absorbNextOperator;
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax syntax = letClauseSyntax.Variables.First();
				BoundQueryClause source = new BoundQueryClause(syntax, absorbingJoin, absorbingJoin.RangeVariables.Concat(joinSelectorDeclaredRangeVariables), absorbingJoin.CompoundVariableType, ImmutableArray.Create(absorbingJoin.Binders.Last()), absorbingJoin.Type);
				return BindLetClause(source, letClauseSyntax, operatorsEnumerator, diagnostics, skipFirstVariable: true);
			}
			case SyntaxKind.AggregateClause:
				return CompleteAggregateClauseBinding((Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax)absorbNextOperator, operatorsEnumerator, leftRangeVariables, rightRangeVariables, absorbingJoin, joinSelectorBinder, joinSelectorDeclaredRangeVariables, absorbingJoin.CompoundVariableType, group, intoBinder, diagnostics);
			default:
				throw ExceptionUtilities.UnexpectedValue(absorbNextOperator.Kind());
			}
		}

		private BoundQueryClauseBase BindInnerJoinClause(BoundQueryClauseBase outer, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax join, HashSet<string> declaredNames, ref SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator operatorsEnumerator, BindingDiagnosticBag diagnostics)
		{
			bool flag;
			if (declaredNames == null)
			{
				flag = false;
				declaredNames = CreateSetOfDeclaredNames(outer.RangeVariables);
			}
			else
			{
				flag = true;
			}
			BoundQueryClauseBase boundQueryClauseBase;
			if (join.JoinedVariables.Count == 0)
			{
				RangeVariableSymbol item = RangeVariableSymbol.CreateForErrorRecovery(this, join, ErrorTypeSymbol.UnknownResultType);
				boundQueryClauseBase = BoundNodeExtensions.MakeCompilerGenerated(new BoundQueryableSource(join, BoundNodeExtensions.MakeCompilerGenerated(new BoundQuerySource(BoundNodeExtensions.MakeCompilerGenerated(BadExpression(join, ErrorTypeSymbol.UnknownResultType)))), null, ImmutableArray.Create(item), ErrorTypeSymbol.UnknownResultType, ImmutableArray<Binder>.Empty, ErrorTypeSymbol.UnknownResultType, hasErrors: true));
			}
			else
			{
				boundQueryClauseBase = BindCollectionRangeVariable(join.JoinedVariables[0], beginsTheQuery: false, declaredNames, diagnostics);
			}
			SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax>.Enumerator enumerator = join.AdditionalJoins.GetEnumerator();
			while (enumerator.MoveNext())
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax current = enumerator.Current;
				switch (current.Kind())
				{
				case SyntaxKind.SimpleJoinClause:
				{
					BoundQueryClauseBase outer2 = boundQueryClauseBase;
					Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax join2 = (Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax)current;
					HashSet<string> declaredNames2 = declaredNames;
					SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator operatorsEnumerator2 = default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator);
					boundQueryClauseBase = BindInnerJoinClause(outer2, join2, declaredNames2, ref operatorsEnumerator2, diagnostics);
					break;
				}
				case SyntaxKind.GroupJoinClause:
					boundQueryClauseBase = BindGroupJoinClause(boundQueryClauseBase, (Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax)current, declaredNames, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator), diagnostics);
					break;
				}
			}
			BoundQueryLambda outerKeyLambda = null;
			BoundQueryLambda innerKeyLambda = null;
			QueryLambdaBinder outerKeyBinder = null;
			QueryLambdaBinder innerKeyBinder = null;
			ImmutableArray<RangeVariableSymbol> immutableArray = outer.RangeVariables.Concat(boundQueryClauseBase.RangeVariables);
			QueryLambdaBinder.BindJoinKeys(this, join, outer, boundQueryClauseBase, immutableArray, out outerKeyLambda, out outerKeyBinder, out innerKeyLambda, out innerKeyBinder, diagnostics);
			BoundLambdaParameterSymbol item2 = CreateQueryLambdaParameterSymbol(GetQueryLambdaParameterNameLeft(outer.RangeVariables), 0, outer.CompoundVariableType, join, outer.RangeVariables);
			BoundLambdaParameterSymbol item3 = CreateQueryLambdaParameterSymbol(GetQueryLambdaParameterNameRight(boundQueryClauseBase.RangeVariables), 1, boundQueryClauseBase.CompoundVariableType, join, boundQueryClauseBase.RangeVariables);
			Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax queryClauseSyntax = null;
			if (!flag)
			{
				queryClauseSyntax = JoinShouldAbsorbNextOperator(ref operatorsEnumerator);
			}
			BoundQueryClauseBase group = null;
			IntoClauseDisallowGroupReferenceBinder intoBinder = null;
			SynthesizedLambdaKind lambdaKind = SynthesizedLambdaKind.UserDefined;
			VisualBasicSyntaxNode lambdaSyntax = null;
			GetAbsorbingJoinSelectorLambdaKindAndSyntax(join, queryClauseSyntax, out lambdaKind, out lambdaSyntax);
			SynthesizedLambdaSymbol synthesizedLambdaSymbol = CreateQueryLambdaSymbol(lambdaSyntax, lambdaKind, ImmutableArray.Create(item2, item3));
			QueryLambdaBinder queryLambdaBinder = new QueryLambdaBinder(synthesizedLambdaSymbol, immutableArray);
			ImmutableArray<RangeVariableSymbol> joinSelectorDeclaredRangeVariables;
			BoundExpression boundExpression;
			ImmutableArray<Binder> binders;
			if (queryClauseSyntax != null)
			{
				joinSelectorDeclaredRangeVariables = default(ImmutableArray<RangeVariableSymbol>);
				lambdaSyntax = null;
				boundExpression = queryLambdaBinder.BindAbsorbingJoinSelector(queryClauseSyntax, operatorsEnumerator, outer.RangeVariables, boundQueryClauseBase.RangeVariables, out joinSelectorDeclaredRangeVariables, out group, out intoBinder, diagnostics);
				binders = ImmutableArray.Create((Binder)outerKeyBinder, (Binder)innerKeyBinder, (Binder)queryLambdaBinder);
			}
			else
			{
				joinSelectorDeclaredRangeVariables = ImmutableArray<RangeVariableSymbol>.Empty;
				boundExpression = queryLambdaBinder.BuildJoinSelector(join, MustProduceFlatCompoundVariable(join, operatorsEnumerator), diagnostics);
				binders = ImmutableArray.Create((Binder)outerKeyBinder, (Binder)innerKeyBinder);
			}
			BoundQueryLambda boundQueryLambda = CreateBoundQueryLambda(synthesizedLambdaSymbol, immutableArray, boundExpression, exprIsOperandOfConditionalBranch: false);
			synthesizedLambdaSymbol.SetQueryLambdaReturnType(boundExpression.Type);
			boundQueryLambda.SetWasCompilerGenerated();
			BoundExpression boundExpression2;
			if (TypeSymbolExtensions.IsErrorType(outer.Type))
			{
				boundExpression2 = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(join, ImmutableArray.Create(new BoundExpression[5] { outer, boundQueryClauseBase, outerKeyLambda, innerKeyLambda, boundQueryLambda }), ErrorTypeSymbol.UnknownResultType));
			}
			else
			{
				BindingDiagnosticBag diagnostics2 = diagnostics;
				if (boundQueryClauseBase.HasErrors || TypeSymbolExtensions.IsErrorType(boundQueryClauseBase.Type) || ShouldSuppressDiagnostics(outerKeyLambda) || ShouldSuppressDiagnostics(innerKeyLambda) || ShouldSuppressDiagnostics(boundQueryLambda))
				{
					diagnostics2 = BindingDiagnosticBag.Discarded;
				}
				boundExpression2 = BindQueryOperatorCall(join, outer, "Join", ImmutableArray.Create<BoundExpression>(boundQueryClauseBase, outerKeyLambda, innerKeyLambda, boundQueryLambda), join.JoinKeyword.Span, diagnostics2);
			}
			BoundQueryClauseBase boundQueryClauseBase2 = new BoundQueryClause(join, boundExpression2, immutableArray, boundQueryLambda.Expression.Type, binders, boundExpression2.Type);
			if (queryClauseSyntax != null)
			{
				boundQueryClauseBase2 = AbsorbOperatorFollowingJoin((BoundQueryClause)boundQueryClauseBase2, queryClauseSyntax, operatorsEnumerator, joinSelectorDeclaredRangeVariables, queryLambdaBinder, outer.RangeVariables, boundQueryClauseBase.RangeVariables, group, intoBinder, diagnostics);
			}
			return boundQueryClauseBase2;
		}

		private static HashSet<string> CreateSetOfDeclaredNames()
		{
			return new HashSet<string>(CaseInsensitiveComparison.Comparer);
		}

		private static HashSet<string> CreateSetOfDeclaredNames(ImmutableArray<RangeVariableSymbol> rangeVariables)
		{
			HashSet<string> hashSet = new HashSet<string>(CaseInsensitiveComparison.Comparer);
			ImmutableArray<RangeVariableSymbol>.Enumerator enumerator = rangeVariables.GetEnumerator();
			while (enumerator.MoveNext())
			{
				RangeVariableSymbol current = enumerator.Current;
				hashSet.Add(current.Name);
			}
			return hashSet;
		}

		[Conditional("DEBUG")]
		private static void AssertDeclaredNames(HashSet<string> declaredNames, ImmutableArray<RangeVariableSymbol> rangeVariables)
		{
		}

		private BoundQueryClause BindGroupJoinClause(BoundQueryClauseBase outer, Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax groupJoin, HashSet<string> declaredNames, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator operatorsEnumerator, BindingDiagnosticBag diagnostics)
		{
			HashSet<string> declaredNames2 = CreateSetOfDeclaredNames(outer.RangeVariables);
			if (declaredNames == null)
			{
				declaredNames = CreateSetOfDeclaredNames(outer.RangeVariables);
			}
			BoundQueryClauseBase boundQueryClauseBase;
			if (groupJoin.JoinedVariables.Count == 0)
			{
				RangeVariableSymbol item = RangeVariableSymbol.CreateForErrorRecovery(this, groupJoin, ErrorTypeSymbol.UnknownResultType);
				boundQueryClauseBase = BoundNodeExtensions.MakeCompilerGenerated(new BoundQueryableSource(groupJoin, BoundNodeExtensions.MakeCompilerGenerated(new BoundQuerySource(BoundNodeExtensions.MakeCompilerGenerated(BadExpression(groupJoin, ErrorTypeSymbol.UnknownResultType)))), null, ImmutableArray.Create(item), ErrorTypeSymbol.UnknownResultType, ImmutableArray<Binder>.Empty, ErrorTypeSymbol.UnknownResultType, hasErrors: true));
			}
			else
			{
				boundQueryClauseBase = BindCollectionRangeVariable(groupJoin.JoinedVariables[0], beginsTheQuery: false, declaredNames2, diagnostics);
			}
			SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax>.Enumerator enumerator = groupJoin.AdditionalJoins.GetEnumerator();
			while (enumerator.MoveNext())
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax current = enumerator.Current;
				switch (current.Kind())
				{
				case SyntaxKind.SimpleJoinClause:
				{
					BoundQueryClauseBase outer2 = boundQueryClauseBase;
					Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax join = (Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax)current;
					SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator operatorsEnumerator2 = default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator);
					boundQueryClauseBase = BindInnerJoinClause(outer2, join, declaredNames2, ref operatorsEnumerator2, diagnostics);
					break;
				}
				case SyntaxKind.GroupJoinClause:
					boundQueryClauseBase = BindGroupJoinClause(boundQueryClauseBase, (Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax)current, declaredNames2, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>.Enumerator), diagnostics);
					break;
				}
			}
			BoundQueryLambda outerKeyLambda = null;
			BoundQueryLambda innerKeyLambda = null;
			QueryLambdaBinder outerKeyBinder = null;
			QueryLambdaBinder innerKeyBinder = null;
			QueryLambdaBinder.BindJoinKeys(this, groupJoin, outer, boundQueryClauseBase, outer.RangeVariables.Concat(boundQueryClauseBase.RangeVariables), out outerKeyLambda, out outerKeyBinder, out innerKeyLambda, out innerKeyBinder, diagnostics);
			BoundMethodGroup methodGroup = null;
			TypeSymbol groupType = InferGroupType(outer, boundQueryClauseBase, groupJoin, outerKeyLambda, innerKeyLambda, out methodGroup, diagnostics);
			IntoClauseBinder intoBinder = null;
			ImmutableArray<RangeVariableSymbol> intoRangeVariables = default(ImmutableArray<RangeVariableSymbol>);
			BoundQueryLambda boundQueryLambda = BindIntoSelectorLambda(groupJoin, outer.RangeVariables, outer.CompoundVariableType, addKeysInScope: true, declaredNames, groupType, boundQueryClauseBase.RangeVariables, boundQueryClauseBase.CompoundVariableType, groupJoin.AggregationVariables, MustProduceFlatCompoundVariable(groupJoin, operatorsEnumerator), diagnostics, out intoBinder, out intoRangeVariables);
			BoundExpression boundExpression;
			if (TypeSymbolExtensions.IsErrorType(outer.Type) || methodGroup == null)
			{
				boundExpression = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(groupJoin, ImmutableArray.Create(new BoundExpression[5] { outer, boundQueryClauseBase, outerKeyLambda, innerKeyLambda, boundQueryLambda }), ErrorTypeSymbol.UnknownResultType));
			}
			else
			{
				BindingDiagnosticBag diagnostics2 = diagnostics;
				if (boundQueryClauseBase.HasErrors || TypeSymbolExtensions.IsErrorType(boundQueryClauseBase.Type) || ShouldSuppressDiagnostics(outerKeyLambda) || ShouldSuppressDiagnostics(innerKeyLambda) || ShouldSuppressDiagnostics(boundQueryLambda))
				{
					diagnostics2 = BindingDiagnosticBag.Discarded;
				}
				boundExpression = BindQueryOperatorCall(groupJoin, outer, "GroupJoin", methodGroup, ImmutableArray.Create<BoundExpression>(boundQueryClauseBase, outerKeyLambda, innerKeyLambda, boundQueryLambda), groupJoin.JoinKeyword.Span, diagnostics2);
			}
			return new BoundQueryClause(groupJoin, boundExpression, outer.RangeVariables.Concat(intoRangeVariables), boundQueryLambda.Expression.Type, ImmutableArray.Create((Binder)outerKeyBinder, (Binder)innerKeyBinder, (Binder)intoBinder), boundExpression.Type);
		}

		private BoundQueryClause BindGroupByClause(BoundQueryClauseBase source, Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax groupBy, BindingDiagnosticBag diagnostics)
		{
			QueryLambdaBinder itemsLambdaBinder = null;
			ImmutableArray<RangeVariableSymbol> itemsRangeVariables = default(ImmutableArray<RangeVariableSymbol>);
			BoundQueryLambda boundQueryLambda = BindGroupByItems(source, groupBy, out itemsLambdaBinder, out itemsRangeVariables, diagnostics);
			QueryLambdaBinder keysLambdaBinder = null;
			ImmutableArray<RangeVariableSymbol> keysRangeVariables = default(ImmutableArray<RangeVariableSymbol>);
			BoundQueryLambda boundQueryLambda2 = BindGroupByKeys(source, groupBy, out keysLambdaBinder, out keysRangeVariables, diagnostics);
			BoundMethodGroup methodGroup = null;
			TypeSymbol groupType = InferGroupType(source, groupBy, boundQueryLambda, boundQueryLambda2, keysRangeVariables, out methodGroup, diagnostics);
			ImmutableArray<RangeVariableSymbol> groupRangeVariables;
			TypeSymbol groupCompoundVariableType;
			if (boundQueryLambda == null)
			{
				groupRangeVariables = source.RangeVariables;
				groupCompoundVariableType = source.CompoundVariableType;
			}
			else
			{
				groupRangeVariables = itemsRangeVariables;
				groupCompoundVariableType = boundQueryLambda.Expression.Type;
			}
			IntoClauseBinder intoBinder = null;
			ImmutableArray<RangeVariableSymbol> intoRangeVariables = default(ImmutableArray<RangeVariableSymbol>);
			BoundQueryLambda boundQueryLambda3 = BindIntoSelectorLambda(groupBy, keysRangeVariables, boundQueryLambda2.Expression.Type, addKeysInScope: false, null, groupType, groupRangeVariables, groupCompoundVariableType, groupBy.AggregationVariables, mustProduceFlatCompoundVariable: true, diagnostics, out intoBinder, out intoRangeVariables);
			BoundExpression[] items;
			ImmutableArray<Binder> binders;
			if (boundQueryLambda == null)
			{
				items = new BoundExpression[2] { boundQueryLambda2, boundQueryLambda3 };
				binders = ImmutableArray.Create((Binder)keysLambdaBinder, (Binder)intoBinder);
			}
			else
			{
				items = new BoundExpression[3] { boundQueryLambda2, boundQueryLambda, boundQueryLambda3 };
				binders = ImmutableArray.Create((Binder)keysLambdaBinder, (Binder)itemsLambdaBinder, (Binder)intoBinder);
			}
			BoundExpression boundExpression;
			if (TypeSymbolExtensions.IsErrorType(source.Type) || methodGroup == null)
			{
				boundExpression = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(groupBy, ImmutableArray.Create((BoundExpression)source).AddRange(items), ErrorTypeSymbol.UnknownResultType));
			}
			else
			{
				BindingDiagnosticBag diagnostics2 = diagnostics;
				if (ShouldSuppressDiagnostics(boundQueryLambda2) || ShouldSuppressDiagnostics(boundQueryLambda3) || (boundQueryLambda != null && ShouldSuppressDiagnostics(boundQueryLambda)))
				{
					diagnostics2 = BindingDiagnosticBag.Discarded;
				}
				boundExpression = BindQueryOperatorCall(groupBy, source, "GroupBy", methodGroup, items.AsImmutableOrNull(), GetGroupByOperatorNameSpan(groupBy), diagnostics2);
			}
			return new BoundQueryClause(groupBy, boundExpression, keysRangeVariables.Concat(intoRangeVariables), boundQueryLambda3.Expression.Type, binders, boundExpression.Type);
		}

		private static TextSpan GetGroupByOperatorNameSpan(Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax groupBy)
		{
			if (groupBy.Items.Count == 0)
			{
				SyntaxToken left = groupBy.GroupKeyword;
				SyntaxToken right = groupBy.ByKeyword;
				return GetQueryOperatorNameSpan(ref left, ref right);
			}
			return groupBy.GroupKeyword.Span;
		}

		private BoundQueryLambda BindGroupByItems(BoundQueryClauseBase source, Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax groupBy, out QueryLambdaBinder itemsLambdaBinder, out ImmutableArray<RangeVariableSymbol> itemsRangeVariables, BindingDiagnosticBag diagnostics)
		{
			BoundQueryLambda boundQueryLambda = null;
			SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax> items = groupBy.Items;
			if (items.Count > 0)
			{
				BoundLambdaParameterSymbol item = CreateQueryLambdaParameterSymbol(GetQueryLambdaParameterName(source.RangeVariables), 0, source.CompoundVariableType, groupBy, source.RangeVariables);
				SynthesizedLambdaSymbol synthesizedLambdaSymbol = CreateQueryLambdaSymbol(LambdaUtilities.GetGroupByItemsLambdaBody(groupBy), SynthesizedLambdaKind.GroupByItemsQueryLambda, ImmutableArray.Create(item));
				itemsLambdaBinder = new QueryLambdaBinder(synthesizedLambdaSymbol, source.RangeVariables);
				BoundExpression boundExpression = itemsLambdaBinder.BindExpressionRangeVariables(items, requireRangeVariable: false, groupBy, out itemsRangeVariables, diagnostics);
				boundQueryLambda = CreateBoundQueryLambda(synthesizedLambdaSymbol, source.RangeVariables, boundExpression, exprIsOperandOfConditionalBranch: false);
				synthesizedLambdaSymbol.SetQueryLambdaReturnType(boundExpression.Type);
				boundQueryLambda.SetWasCompilerGenerated();
			}
			else
			{
				itemsLambdaBinder = null;
				itemsRangeVariables = ImmutableArray<RangeVariableSymbol>.Empty;
			}
			return boundQueryLambda;
		}

		private BoundQueryLambda BindGroupByKeys(BoundQueryClauseBase source, Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax groupBy, out QueryLambdaBinder keysLambdaBinder, out ImmutableArray<RangeVariableSymbol> keysRangeVariables, BindingDiagnosticBag diagnostics)
		{
			SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax> keys = groupBy.Keys;
			BoundLambdaParameterSymbol item = CreateQueryLambdaParameterSymbol(GetQueryLambdaParameterName(source.RangeVariables), 0, source.CompoundVariableType, groupBy, source.RangeVariables);
			SynthesizedLambdaSymbol synthesizedLambdaSymbol = CreateQueryLambdaSymbol(LambdaUtilities.GetGroupByKeysLambdaBody(groupBy), SynthesizedLambdaKind.GroupByKeysQueryLambda, ImmutableArray.Create(item));
			keysLambdaBinder = new QueryLambdaBinder(synthesizedLambdaSymbol, source.RangeVariables);
			BoundExpression boundExpression = keysLambdaBinder.BindExpressionRangeVariables(keys, requireRangeVariable: true, groupBy, out keysRangeVariables, diagnostics);
			BoundQueryLambda boundQueryLambda = CreateBoundQueryLambda(synthesizedLambdaSymbol, source.RangeVariables, boundExpression, exprIsOperandOfConditionalBranch: false);
			synthesizedLambdaSymbol.SetQueryLambdaReturnType(boundExpression.Type);
			boundQueryLambda.SetWasCompilerGenerated();
			return boundQueryLambda;
		}

		private TypeSymbol InferGroupType(BoundQueryClauseBase source, Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax groupBy, BoundQueryLambda itemsLambda, BoundQueryLambda keysLambda, ImmutableArray<RangeVariableSymbol> keysRangeVariables, out BoundMethodGroup methodGroup, BindingDiagnosticBag diagnostics)
		{
			TypeSymbol result = ErrorTypeSymbol.UnknownResultType;
			if (!TypeSymbolExtensions.IsErrorType(source.Type))
			{
				methodGroup = LookupQueryOperator(groupBy, source, "GroupBy", null, diagnostics);
				if (methodGroup == null)
				{
					ReportDiagnostic(diagnostics, Location.Create(groupBy.SyntaxTree, GetGroupByOperatorNameSpan(groupBy)), ERRID.ERR_QueryOperatorNotFound, "GroupBy");
				}
				else if (!ShouldSuppressDiagnostics(keysLambda) && (itemsLambda == null || !ShouldSuppressDiagnostics(itemsLambda)))
				{
					GroupTypeInferenceLambda groupTypeInferenceLambda = new GroupTypeInferenceLambda(groupBy, this, new ParameterSymbol[2]
					{
						CreateQueryLambdaParameterSymbol("$VB$It1", 0, keysLambda.Expression.Type, groupBy, keysRangeVariables),
						CreateQueryLambdaParameterSymbol("$VB$It2", 1, null, groupBy)
					}.AsImmutableOrNull(), Compilation);
					BoundExpression[] array = ((itemsLambda != null) ? new BoundExpression[3] { keysLambda, itemsLambda, groupTypeInferenceLambda } : new BoundExpression[2] { keysLambda, groupTypeInferenceLambda });
					CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
					OverloadResolution.OverloadResolutionResult overloadResolutionResult = OverloadResolution.QueryOperatorInvocationOverloadResolution(methodGroup, array.AsImmutableOrNull(), this, ref useSiteInfo);
					((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)groupBy, useSiteInfo);
					if (overloadResolutionResult.BestResult.HasValue)
					{
						result = TypeSymbolExtensions.DelegateOrExpressionDelegate(((MethodSymbol)overloadResolutionResult.BestResult.Value.Candidate.UnderlyingSymbol).Parameters[array.Length - 1].Type, this).DelegateInvokeMethod.Parameters[1].Type;
					}
					else if (!source.HasErrors)
					{
						ReportDiagnostic(diagnostics, Location.Create(groupBy.SyntaxTree, GetGroupByOperatorNameSpan(groupBy)), ERRID.ERR_QueryOperatorNotFound, "GroupBy");
					}
				}
			}
			return result;
		}

		private TypeSymbol InferGroupType(BoundQueryClauseBase outer, BoundQueryClauseBase inner, Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax groupJoin, BoundQueryLambda outerKeyLambda, BoundQueryLambda innerKeyLambda, out BoundMethodGroup methodGroup, BindingDiagnosticBag diagnostics)
		{
			TypeSymbol result = ErrorTypeSymbol.UnknownResultType;
			if (!TypeSymbolExtensions.IsErrorType(outer.Type))
			{
				methodGroup = LookupQueryOperator(groupJoin, outer, "GroupJoin", null, diagnostics);
				if (methodGroup == null)
				{
					SyntaxTree syntaxTree = groupJoin.SyntaxTree;
					SyntaxToken left = groupJoin.GroupKeyword;
					SyntaxToken right = groupJoin.JoinKeyword;
					ReportDiagnostic(diagnostics, Location.Create(syntaxTree, GetQueryOperatorNameSpan(ref left, ref right)), ERRID.ERR_QueryOperatorNotFound, "GroupJoin");
				}
				else if (!ShouldSuppressDiagnostics(innerKeyLambda) && !ShouldSuppressDiagnostics(outerKeyLambda) && !inner.HasErrors && !TypeSymbolExtensions.IsErrorType(inner.Type))
				{
					GroupTypeInferenceLambda groupTypeInferenceLambda = new GroupTypeInferenceLambda(groupJoin, this, new ParameterSymbol[2]
					{
						CreateQueryLambdaParameterSymbol("$VB$It1", 0, outer.CompoundVariableType, groupJoin, outer.RangeVariables),
						CreateQueryLambdaParameterSymbol("$VB$It2", 1, null, groupJoin)
					}.AsImmutableOrNull(), Compilation);
					BoundExpression[] array = new BoundExpression[4] { inner, outerKeyLambda, innerKeyLambda, groupTypeInferenceLambda };
					CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
					OverloadResolution.OverloadResolutionResult overloadResolutionResult = OverloadResolution.QueryOperatorInvocationOverloadResolution(methodGroup, array.AsImmutableOrNull(), this, ref useSiteInfo);
					((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)groupJoin, useSiteInfo);
					if (overloadResolutionResult.BestResult.HasValue)
					{
						result = TypeSymbolExtensions.DelegateOrExpressionDelegate(((MethodSymbol)overloadResolutionResult.BestResult.Value.Candidate.UnderlyingSymbol).Parameters[array.Length - 1].Type, this).DelegateInvokeMethod.Parameters[1].Type;
					}
					else if (!outer.HasErrors)
					{
						SyntaxTree syntaxTree2 = groupJoin.SyntaxTree;
						SyntaxToken right = groupJoin.GroupKeyword;
						SyntaxToken left = groupJoin.JoinKeyword;
						ReportDiagnostic(diagnostics, Location.Create(syntaxTree2, GetQueryOperatorNameSpan(ref right, ref left)), ERRID.ERR_QueryOperatorNotFound, "GroupJoin");
					}
				}
			}
			return result;
		}

		private BoundQueryLambda BindIntoSelectorLambda(Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax clauseSyntax, ImmutableArray<RangeVariableSymbol> keysRangeVariables, TypeSymbol keysCompoundVariableType, bool addKeysInScope, HashSet<string> declaredNames, TypeSymbol groupType, ImmutableArray<RangeVariableSymbol> groupRangeVariables, TypeSymbol groupCompoundVariableType, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax> aggregationVariables, bool mustProduceFlatCompoundVariable, BindingDiagnosticBag diagnostics, out IntoClauseBinder intoBinder, out ImmutableArray<RangeVariableSymbol> intoRangeVariables)
		{
			BoundLambdaParameterSymbol boundLambdaParameterSymbol = CreateQueryLambdaParameterSymbol(GetQueryLambdaParameterName(keysRangeVariables), 0, keysCompoundVariableType, clauseSyntax, keysRangeVariables);
			BoundLambdaParameterSymbol boundLambdaParameterSymbol2 = CreateQueryLambdaParameterSymbol("$VB$ItAnonymous", 1, groupType, clauseSyntax);
			SynthesizedLambdaSymbol synthesizedLambdaSymbol = CreateQueryLambdaSymbol(clauseSyntax, SynthesizedLambdaKind.GroupNonUserCodeQueryLambda, ImmutableArray.Create(boundLambdaParameterSymbol, boundLambdaParameterSymbol2));
			QueryLambdaBinder parent = new QueryLambdaBinder(synthesizedLambdaSymbol, ImmutableArray<RangeVariableSymbol>.Empty);
			BoundParameter groupReference = BoundNodeExtensions.MakeCompilerGenerated(new BoundParameter(boundLambdaParameterSymbol2.Syntax, boundLambdaParameterSymbol2, isLValue: false, boundLambdaParameterSymbol2.Type));
			intoBinder = new IntoClauseBinder(parent, groupReference, groupRangeVariables, groupCompoundVariableType, addKeysInScope ? keysRangeVariables.Concat(groupRangeVariables) : groupRangeVariables);
			BoundExpression boundExpression = intoBinder.BindIntoSelector(clauseSyntax, keysRangeVariables, BoundNodeExtensions.MakeCompilerGenerated(new BoundParameter(boundLambdaParameterSymbol.Syntax, boundLambdaParameterSymbol, isLValue: false, boundLambdaParameterSymbol.Type)), keysRangeVariables, null, ImmutableArray<RangeVariableSymbol>.Empty, declaredNames, aggregationVariables, mustProduceFlatCompoundVariable, out intoRangeVariables, diagnostics);
			BoundQueryLambda boundQueryLambda = CreateBoundQueryLambda(synthesizedLambdaSymbol, keysRangeVariables, boundExpression, exprIsOperandOfConditionalBranch: false);
			synthesizedLambdaSymbol.SetQueryLambdaReturnType(boundExpression.Type);
			boundQueryLambda.SetWasCompilerGenerated();
			return boundQueryLambda;
		}

		private void VerifyRangeVariableName(RangeVariableSymbol rangeVar, SyntaxToken identifier, BindingDiagnosticBag diagnostics)
		{
			if (VisualBasicExtensions.GetTypeCharacter(identifier) != 0)
			{
				ReportDiagnostic(diagnostics, identifier, ERRID.ERR_QueryAnonymousTypeDisallowsTypeChar);
			}
			if (Compilation.ObjectType.GetMembers(rangeVar.Name).Length > 0)
			{
				ReportDiagnostic(diagnostics, identifier, ERRID.ERR_QueryInvalidControlVariableName1);
			}
			else
			{
				VerifyNameShadowingInMethodBody(rangeVar, identifier, identifier, diagnostics);
			}
		}

		private static VisualBasicSyntaxNode GetQueryLambdaParameterSyntax(VisualBasicSyntaxNode syntaxNode, ImmutableArray<RangeVariableSymbol> rangeVariables)
		{
			if (rangeVariables.Length == 1)
			{
				return rangeVariables[0].Syntax;
			}
			return syntaxNode;
		}

		private BoundLambdaParameterSymbol CreateQueryLambdaParameterSymbol(string name, int ordinal, TypeSymbol type, VisualBasicSyntaxNode syntaxNode, ImmutableArray<RangeVariableSymbol> rangeVariables)
		{
			syntaxNode = GetQueryLambdaParameterSyntax(syntaxNode, rangeVariables);
			return new BoundLambdaParameterSymbol(name, ordinal, type, isByRef: false, syntaxNode, syntaxNode.GetLocation());
		}

		private static BoundLambdaParameterSymbol CreateQueryLambdaParameterSymbol(string name, int ordinal, TypeSymbol type, VisualBasicSyntaxNode syntaxNode)
		{
			return new BoundLambdaParameterSymbol(name, ordinal, type, isByRef: false, syntaxNode, syntaxNode.GetLocation());
		}

		private static string GetQueryLambdaParameterName(ImmutableArray<RangeVariableSymbol> rangeVariables)
		{
			return rangeVariables.Length switch
			{
				0 => "$VB$ItAnonymous", 
				1 => rangeVariables[0].Name, 
				_ => "$VB$It", 
			};
		}

		private static string GetQueryLambdaParameterNameLeft(ImmutableArray<RangeVariableSymbol> rangeVariables)
		{
			return rangeVariables.Length switch
			{
				0 => "$VB$ItAnonymous", 
				1 => rangeVariables[0].Name, 
				_ => "$VB$It1", 
			};
		}

		private static string GetQueryLambdaParameterNameRight(ImmutableArray<RangeVariableSymbol> rangeVariables)
		{
			return rangeVariables.Length switch
			{
				0 => throw ExceptionUtilities.UnexpectedValue(rangeVariables.Length), 
				1 => rangeVariables[0].Name, 
				_ => "$VB$It2", 
			};
		}

		private BoundQueryClause BindWhereClause(BoundQueryClauseBase source, Microsoft.CodeAnalysis.VisualBasic.Syntax.WhereClauseSyntax where, BindingDiagnosticBag diagnostics)
		{
			return BindFilterQueryOperator(source, where, "Where", where.WhereKeyword.Span, where.Condition, diagnostics);
		}

		private BoundQueryClause BindSkipWhileClause(BoundQueryClauseBase source, Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax skipWhile, BindingDiagnosticBag diagnostics)
		{
			SyntaxToken left = skipWhile.SkipOrTakeKeyword;
			SyntaxToken right = skipWhile.WhileKeyword;
			return BindFilterQueryOperator(source, skipWhile, "SkipWhile", GetQueryOperatorNameSpan(ref left, ref right), skipWhile.Condition, diagnostics);
		}

		private static TextSpan GetQueryOperatorNameSpan(ref SyntaxToken left, ref SyntaxToken right)
		{
			TextSpan result = left.Span;
			if (right.ValueText.Length > 0)
			{
				result = TextSpan.FromBounds(result.Start, right.Span.End);
			}
			return result;
		}

		private BoundQueryClause BindTakeWhileClause(BoundQueryClauseBase source, Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax takeWhile, BindingDiagnosticBag diagnostics)
		{
			SyntaxToken left = takeWhile.SkipOrTakeKeyword;
			SyntaxToken right = takeWhile.WhileKeyword;
			return BindFilterQueryOperator(source, takeWhile, "TakeWhile", GetQueryOperatorNameSpan(ref left, ref right), takeWhile.Condition, diagnostics);
		}

		private BoundQueryClause BindFilterQueryOperator(BoundQueryClauseBase source, Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax operatorSyntax, string operatorName, TextSpan operatorNameLocation, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition, BindingDiagnosticBag diagnostics)
		{
			BoundLambdaParameterSymbol item = CreateQueryLambdaParameterSymbol(GetQueryLambdaParameterName(source.RangeVariables), 0, source.CompoundVariableType, condition, source.RangeVariables);
			SynthesizedLambdaSymbol synthesizedLambdaSymbol = CreateQueryLambdaSymbol(condition, SynthesizedLambdaKind.FilterConditionQueryLambda, ImmutableArray.Create(item));
			QueryLambdaBinder queryLambdaBinder = new QueryLambdaBinder(synthesizedLambdaSymbol, source.RangeVariables);
			BoundExpression boundExpression = queryLambdaBinder.BindValue(condition, diagnostics);
			BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(withDiagnostics: true, diagnostics.AccumulatesDependencies);
			NamedTypeSymbol specialType = GetSpecialType(SpecialType.System_Boolean, condition, diagnostics);
			TypeSymbol type = boundExpression.Type;
			bool flag = false;
			if ((object)type == null)
			{
				if (BoundExpressionExtensions.IsNothingLiteral(boundExpression))
				{
					flag = true;
				}
			}
			else if (TypeSymbolExtensions.IsObjectType(type))
			{
				flag = true;
			}
			BoundExpression boundExpression2 = queryLambdaBinder.ApplyImplicitConversion(condition, specialType, boundExpression, instance, isOperandOfConditionalBranch: true);
			if (flag)
			{
				boundExpression = boundExpression2;
				diagnostics.AddRange(instance);
			}
			else if (boundExpression2.HasErrors && instance.HasAnyErrors())
			{
				diagnostics.AddRange(instance);
				diagnostics = BindingDiagnosticBag.Discarded;
			}
			else
			{
				diagnostics.AddDependencies(instance);
			}
			instance.Free();
			BoundQueryLambda boundQueryLambda = CreateBoundQueryLambda(synthesizedLambdaSymbol, source.RangeVariables, boundExpression, exprIsOperandOfConditionalBranch: true);
			boundQueryLambda.SetWasCompilerGenerated();
			BoundExpression boundExpression3;
			if (TypeSymbolExtensions.IsErrorType(source.Type))
			{
				boundExpression3 = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(operatorSyntax, ImmutableArray.Create((BoundExpression)source, (BoundExpression)boundQueryLambda), ErrorTypeSymbol.UnknownResultType));
			}
			else
			{
				if (diagnostics != BindingDiagnosticBag.Discarded && ShouldSuppressDiagnostics(boundQueryLambda))
				{
					diagnostics = BindingDiagnosticBag.Discarded;
				}
				boundExpression3 = BindQueryOperatorCall(operatorSyntax, source, operatorName, ImmutableArray.Create((BoundExpression)boundQueryLambda), operatorNameLocation, diagnostics);
			}
			return new BoundQueryClause(operatorSyntax, boundExpression3, source.RangeVariables, source.CompoundVariableType, ImmutableArray.Create((Binder)queryLambdaBinder), boundExpression3.Type);
		}

		private BoundQueryClause BindDistinctClause(BoundQueryClauseBase source, Microsoft.CodeAnalysis.VisualBasic.Syntax.DistinctClauseSyntax distinct, BindingDiagnosticBag diagnostics)
		{
			BoundExpression boundExpression = ((!TypeSymbolExtensions.IsErrorType(source.Type)) ? BindQueryOperatorCall(distinct, source, "Distinct", ImmutableArray<BoundExpression>.Empty, distinct.DistinctKeyword.Span, diagnostics) : BoundNodeExtensions.MakeCompilerGenerated(BadExpression(distinct, source, ErrorTypeSymbol.UnknownResultType)));
			return new BoundQueryClause(distinct, boundExpression, source.RangeVariables, source.CompoundVariableType, ImmutableArray<Binder>.Empty, boundExpression.Type);
		}

		private BoundQueryClause BindSkipClause(BoundQueryClauseBase source, Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax skip, BindingDiagnosticBag diagnostics)
		{
			return BindPartitionClause(source, skip, "Skip", diagnostics);
		}

		private BoundQueryClause BindTakeClause(BoundQueryClauseBase source, Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax take, BindingDiagnosticBag diagnostics)
		{
			return BindPartitionClause(source, take, "Take", diagnostics);
		}

		private BoundQueryClause BindPartitionClause(BoundQueryClauseBase source, Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax partition, string operatorName, BindingDiagnosticBag diagnostics)
		{
			BoundExpression boundExpression = BindValue(partition.Count, diagnostics);
			BoundExpression boundExpression2;
			if (TypeSymbolExtensions.IsErrorType(source.Type))
			{
				boundExpression2 = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(partition, ImmutableArray.Create(source, boundExpression), ErrorTypeSymbol.UnknownResultType));
			}
			else
			{
				if (boundExpression.HasErrors || ((object)boundExpression.Type != null && TypeSymbolExtensions.IsErrorType(boundExpression.Type)))
				{
					diagnostics = BindingDiagnosticBag.Discarded;
				}
				boundExpression2 = BindQueryOperatorCall(partition, source, operatorName, ImmutableArray.Create(boundExpression), partition.SkipOrTakeKeyword.Span, diagnostics);
			}
			return new BoundQueryClause(partition, boundExpression2, source.RangeVariables, source.CompoundVariableType, ImmutableArray<Binder>.Empty, boundExpression2.Type);
		}

		private BoundQueryClause BindOrderByClause(BoundQueryClauseBase source, Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderByClauseSyntax orderBy, BindingDiagnosticBag diagnostics)
		{
			DiagnosticBag diagnosticBag = null;
			BindingDiagnosticBag bindingDiagnosticBag = diagnostics;
			string queryLambdaParameterName = GetQueryLambdaParameterName(source.RangeVariables);
			BoundQueryPart boundQueryPart = source;
			SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax> orderings = orderBy.Orderings;
			if (orderings.Count == 0)
			{
				return new BoundQueryClause(orderBy, BoundNodeExtensions.MakeCompilerGenerated(BadExpression(orderBy, source, ErrorTypeSymbol.UnknownResultType)), source.RangeVariables, source.CompoundVariableType, ImmutableArray.Create(this), ErrorTypeSymbol.UnknownResultType, hasErrors: true);
			}
			QueryLambdaBinder queryLambdaBinder = null;
			int num = orderings.Count - 1;
			for (int i = 0; i <= num; i++)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax orderingSyntax = orderings[i];
				BoundLambdaParameterSymbol item = CreateQueryLambdaParameterSymbol(queryLambdaParameterName, 0, source.CompoundVariableType, orderingSyntax.Expression, source.RangeVariables);
				SynthesizedLambdaSymbol synthesizedLambdaSymbol = CreateQueryLambdaSymbol(LambdaUtilities.GetOrderingLambdaBody(orderingSyntax), SynthesizedLambdaKind.OrderingQueryLambda, ImmutableArray.Create(item));
				queryLambdaBinder = new QueryLambdaBinder(synthesizedLambdaSymbol, source.RangeVariables);
				BoundExpression expression = queryLambdaBinder.BindValue(orderingSyntax.Expression, diagnostics);
				BoundQueryLambda boundQueryLambda = CreateBoundQueryLambda(synthesizedLambdaSymbol, source.RangeVariables, expression, exprIsOperandOfConditionalBranch: false);
				boundQueryLambda.SetWasCompilerGenerated();
				BoundExpression boundExpression;
				if (TypeSymbolExtensions.IsErrorType(boundQueryPart.Type))
				{
					boundExpression = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(orderingSyntax, ImmutableArray.Create((BoundExpression)boundQueryPart, (BoundExpression)boundQueryLambda), ErrorTypeSymbol.UnknownResultType));
				}
				else
				{
					if (bindingDiagnosticBag != BindingDiagnosticBag.Discarded && ShouldSuppressDiagnostics(boundQueryLambda))
					{
						bindingDiagnosticBag = BindingDiagnosticBag.Discarded;
					}
					string operatorName;
					TextSpan operatorNameLocation;
					if (i == 0)
					{
						operatorName = ((orderingSyntax.Kind() != SyntaxKind.AscendingOrdering) ? "OrderByDescending" : "OrderBy");
						SyntaxToken left = orderBy.OrderKeyword;
						SyntaxToken right = orderBy.ByKeyword;
						operatorNameLocation = GetQueryOperatorNameSpan(ref left, ref right);
					}
					else
					{
						operatorName = ((orderingSyntax.Kind() != SyntaxKind.AscendingOrdering) ? "ThenByDescending" : "ThenBy");
						operatorNameLocation = orderings.GetSeparator(i - 1).Span;
					}
					boundExpression = BindQueryOperatorCall(orderingSyntax, boundQueryPart, operatorName, ImmutableArray.Create((BoundExpression)boundQueryLambda), operatorNameLocation, bindingDiagnosticBag);
				}
				boundQueryPart = new BoundOrdering(orderingSyntax, boundExpression, boundExpression.Type);
			}
			diagnosticBag?.Free();
			return new BoundQueryClause(orderBy, boundQueryPart, source.RangeVariables, source.CompoundVariableType, ImmutableArray.Create((Binder)queryLambdaBinder), boundQueryPart.Type);
		}

		private BoundQueryableSource BindCollectionRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax syntax, bool beginsTheQuery, HashSet<string> declaredNames, BindingDiagnosticBag diagnostics)
		{
			BoundQueryPart boundQueryPart = new BoundQuerySource(BindRValue(syntax.Expression, diagnostics));
			TypeSymbol controlVariableType = null;
			BoundExpression boundExpression = ConvertToQueryableType(boundQueryPart, diagnostics, out controlVariableType);
			bool flag = false;
			if ((object)controlVariableType == null)
			{
				if (!boundQueryPart.HasErrors)
				{
					ReportDiagnostic(diagnostics, syntax.Expression, ERRID.ERR_ExpectedQueryableSource, boundQueryPart.Type);
				}
				flag = true;
			}
			else if (boundQueryPart != boundExpression)
			{
				boundQueryPart = BoundNodeExtensions.MakeCompilerGenerated(new BoundToQueryableCollectionConversion((BoundCall)boundExpression));
			}
			TypeSymbol typeSymbol = null;
			if (syntax.AsClause != null)
			{
				typeSymbol = DecodeModifiedIdentifierType(syntax.Identifier, syntax.AsClause, null, null, diagnostics, ModifiedIdentifierTypeDecoderContext.LocalType | ModifiedIdentifierTypeDecoderContext.QueryRangeVariableType);
			}
			else if (syntax.Identifier.Nullable.Node != null)
			{
				ReportDiagnostic(diagnostics, syntax.Identifier.Nullable, ERRID.ERR_NullableTypeInferenceNotSupported);
			}
			if ((object)controlVariableType == null)
			{
				controlVariableType = (((object)typeSymbol != null) ? typeSymbol : ErrorTypeSymbol.UnknownResultType);
			}
			else if ((object)typeSymbol != null && !TypeSymbolExtensions.IsSameTypeIgnoringAll(typeSymbol, controlVariableType))
			{
				boundQueryPart = ApplyImplicitCollectionConversion(syntax, boundQueryPart, controlVariableType, typeSymbol, diagnostics);
				controlVariableType = typeSymbol;
			}
			RangeVariableSymbol rangeVariableSymbol = null;
			string text = syntax.Identifier.Identifier.ValueText;
			RangeVariableSymbol rangeVariableOpt = null;
			if (text != null && text.Length == 0)
			{
				text = null;
			}
			if (text != null)
			{
				rangeVariableSymbol = RangeVariableSymbol.Create(this, syntax.Identifier.Identifier, controlVariableType);
				rangeVariableOpt = rangeVariableSymbol;
				bool flag2 = false;
				if (declaredNames != null && !declaredNames.Add(text))
				{
					ReportDiagnostic(diagnostics, syntax.Identifier.Identifier, ERRID.ERR_QueryDuplicateAnonTypeMemberName1, text);
					flag2 = true;
				}
				else
				{
					VerifyRangeVariableName(rangeVariableSymbol, syntax.Identifier.Identifier, diagnostics);
					if (!beginsTheQuery && declaredNames == null && ShadowsRangeVariableInTheChildScope(this, rangeVariableSymbol))
					{
						flag2 = true;
					}
				}
				if (flag2)
				{
					rangeVariableSymbol = RangeVariableSymbol.CreateForErrorRecovery(this, rangeVariableSymbol.Syntax, controlVariableType);
				}
			}
			else
			{
				rangeVariableSymbol = RangeVariableSymbol.CreateForErrorRecovery(this, syntax, controlVariableType);
			}
			return new BoundQueryableSource(syntax, boundQueryPart, rangeVariableOpt, ImmutableArray.Create(rangeVariableSymbol), controlVariableType, ImmutableArray<Binder>.Empty, flag ? ErrorTypeSymbol.UnknownResultType : boundQueryPart.Type, flag);
		}

		private BoundQueryPart ApplyImplicitCollectionConversion(Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax syntax, BoundQueryPart source, TypeSymbol variableType, TypeSymbol targetVariableType, BindingDiagnosticBag diagnostics)
		{
			if (TypeSymbolExtensions.IsErrorType(source.Type))
			{
				BoundRValuePlaceholder expression = new BoundRValuePlaceholder(syntax.AsClause, variableType);
				ApplyImplicitConversion(syntax.AsClause, targetVariableType, expression, diagnostics);
				return source;
			}
			BoundLambdaParameterSymbol boundLambdaParameterSymbol = CreateQueryLambdaParameterSymbol(syntax.Identifier.Identifier.ValueText, 0, variableType, syntax.AsClause);
			SynthesizedLambdaSymbol synthesizedLambdaSymbol = CreateQueryLambdaSymbol(syntax.AsClause, SynthesizedLambdaKind.ConversionNonUserCodeQueryLambda, ImmutableArray.Create(boundLambdaParameterSymbol));
			synthesizedLambdaSymbol.SetQueryLambdaReturnType(targetVariableType);
			QueryLambdaBinder queryLambdaBinder = new QueryLambdaBinder(synthesizedLambdaSymbol, ImmutableArray<RangeVariableSymbol>.Empty);
			BoundExpression expression2 = queryLambdaBinder.ApplyImplicitConversion(syntax.AsClause, targetVariableType, BoundNodeExtensions.MakeCompilerGenerated(new BoundParameter(boundLambdaParameterSymbol.Syntax, boundLambdaParameterSymbol, isLValue: false, variableType)), diagnostics);
			BoundQueryLambda boundQueryLambda = CreateBoundQueryLambda(synthesizedLambdaSymbol, ImmutableArray<RangeVariableSymbol>.Empty, expression2, exprIsOperandOfConditionalBranch: false);
			boundQueryLambda.SetWasCompilerGenerated();
			if (ShouldSuppressDiagnostics(boundQueryLambda))
			{
				diagnostics = BindingDiagnosticBag.Discarded;
			}
			BoundExpression boundExpression = BindQueryOperatorCall(syntax.AsClause, source, "Select", ImmutableArray.Create((BoundExpression)boundQueryLambda), syntax.AsClause.Span, diagnostics);
			return BoundNodeExtensions.MakeCompilerGenerated(new BoundQueryClause(source.Syntax, boundExpression, ImmutableArray<RangeVariableSymbol>.Empty, targetVariableType, ImmutableArray.Create((Binder)queryLambdaBinder), boundExpression.Type));
		}

		private BoundExpression ConvertToQueryableType(BoundExpression source, BindingDiagnosticBag diagnostics, out TypeSymbol controlVariableType)
		{
			controlVariableType = null;
			if (!BoundExpressionExtensions.IsValue(source) || TypeSymbolExtensions.IsErrorType(source.Type))
			{
				return source;
			}
			TypeSymbol typeSymbol = InferControlVariableType(source, diagnostics);
			if ((object)typeSymbol != null)
			{
				controlVariableType = typeSymbol;
				return source;
			}
			BoundExpression boundExpression = null;
			BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(diagnostics);
			BoundExpression boundExpression2 = BindQueryOperatorCall(source.Syntax, source, "AsQueryable", ImmutableArray<BoundExpression>.Empty, source.Syntax.Span, instance);
			if (!boundExpression2.HasErrors && boundExpression2.Kind == BoundKind.Call)
			{
				typeSymbol = InferControlVariableType(boundExpression2, diagnostics);
				if ((object)typeSymbol != null)
				{
					controlVariableType = typeSymbol;
					boundExpression = boundExpression2;
					diagnostics.AddRange(instance);
				}
			}
			if (boundExpression == null)
			{
				instance.Clear();
				BoundExpression boundExpression3 = BindQueryOperatorCall(source.Syntax, source, "AsEnumerable", ImmutableArray<BoundExpression>.Empty, source.Syntax.Span, instance);
				if (!boundExpression3.HasErrors && boundExpression3.Kind == BoundKind.Call)
				{
					typeSymbol = InferControlVariableType(boundExpression3, diagnostics);
					if ((object)typeSymbol != null)
					{
						controlVariableType = typeSymbol;
						boundExpression = boundExpression3;
						diagnostics.AddRange(instance);
					}
				}
			}
			if (boundExpression == null)
			{
				instance.Clear();
				typeSymbol = GetSpecialType(SpecialType.System_Object, source.Syntax, instance);
				BoundExpression boundExpression4 = BindQueryOperatorCall(source.Syntax, source, "Cast", new BoundTypeArguments(source.Syntax, ImmutableArray.Create(typeSymbol)), ImmutableArray<BoundExpression>.Empty, source.Syntax.Span, instance);
				if (!boundExpression4.HasErrors && boundExpression4.Kind == BoundKind.Call)
				{
					controlVariableType = typeSymbol;
					boundExpression = boundExpression4;
					diagnostics.AddRange(instance);
				}
			}
			instance.Free();
			return (boundExpression == null) ? source : boundExpression;
		}

		private TypeSymbol InferControlVariableType(BoundExpression source, BindingDiagnosticBag diagnostics)
		{
			TypeSymbol typeSymbol = null;
			LookupResult instance = LookupResult.GetInstance();
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
			LookupMember(instance, source.Type, "Select", 0, LookupOptions.MustBeInstance | LookupOptions.AllMethodsOfAnyArity | LookupOptions.MethodsOnly, ref useSiteInfo);
			if (instance.IsGood)
			{
				bool failedDueToAnAmbiguity = false;
				typeSymbol = InferControlVariableType(instance.Symbols, out failedDueToAnAmbiguity);
				if ((object)typeSymbol == null && !failedDueToAnAmbiguity && !SymbolExtensions.IsReducedExtensionMethod(instance.Symbols[0]))
				{
					instance.Clear();
					LookupExtensionMethods(instance, source.Type, "Select", 0, LookupOptions.MustBeInstance | LookupOptions.AllMethodsOfAnyArity | LookupOptions.MethodsOnly, ref useSiteInfo);
					if (instance.IsGood)
					{
						typeSymbol = InferControlVariableType(instance.Symbols, out failedDueToAnAmbiguity);
					}
				}
			}
			diagnostics.Add(source, useSiteInfo);
			instance.Free();
			return typeSymbol;
		}

		private TypeSymbol InferControlVariableType(ArrayBuilder<Symbol> methods, out bool failedDueToAnAmbiguity)
		{
			TypeSymbol typeSymbol = null;
			failedDueToAnAmbiguity = false;
			ArrayBuilder<Symbol>.Enumerator enumerator = methods.GetEnumerator();
			while (enumerator.MoveNext())
			{
				MethodSymbol method = (MethodSymbol)enumerator.Current;
				TypeSymbol typeSymbol2 = InferControlVariableType(method);
				if ((object)typeSymbol2 != null)
				{
					if (TypeSymbolExtensions.ReferencesMethodsTypeParameter(typeSymbol2, method))
					{
						failedDueToAnAmbiguity = true;
						return null;
					}
					if ((object)typeSymbol == null)
					{
						typeSymbol = typeSymbol2;
					}
					else if (!TypeSymbolExtensions.IsSameTypeIgnoringAll(typeSymbol, typeSymbol2))
					{
						failedDueToAnAmbiguity = true;
						return null;
					}
				}
			}
			return typeSymbol;
		}

		private TypeSymbol InferControlVariableType(MethodSymbol method)
		{
			if (method.IsSub)
			{
				return null;
			}
			if (method.ParameterCount != 1)
			{
				return null;
			}
			ParameterSymbol parameterSymbol = method.Parameters[0];
			if (parameterSymbol.IsByRef)
			{
				return null;
			}
			NamedTypeSymbol namedTypeSymbol = TypeSymbolExtensions.DelegateOrExpressionDelegate(parameterSymbol.Type, this);
			if ((object)namedTypeSymbol == null)
			{
				return null;
			}
			MethodSymbol delegateInvokeMethod = namedTypeSymbol.DelegateInvokeMethod;
			if ((object)delegateInvokeMethod == null || delegateInvokeMethod.IsSub || delegateInvokeMethod.ParameterCount != 1)
			{
				return null;
			}
			ParameterSymbol parameterSymbol2 = delegateInvokeMethod.Parameters[0];
			if (parameterSymbol2.IsOptional || parameterSymbol2.IsByRef || parameterSymbol2.IsParamArray)
			{
				return null;
			}
			TypeSymbol type = parameterSymbol2.Type;
			return TypeSymbolExtensions.IsErrorType(type) ? null : type;
		}

		private BoundMethodGroup LookupQueryOperator(SyntaxNode node, BoundExpression source, string operatorName, BoundTypeArguments typeArgumentsOpt, BindingDiagnosticBag diagnostics)
		{
			LookupResult instance = LookupResult.GetInstance();
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
			LookupMember(instance, source.Type, operatorName, 0, LookupOptions.MustBeInstance | LookupOptions.AllMethodsOfAnyArity | LookupOptions.MethodsOnly, ref useSiteInfo);
			BoundMethodGroup result = null;
			if (!instance.IsClear && (instance.Kind == LookupResultKind.Good || instance.Kind == LookupResultKind.Inaccessible))
			{
				result = BoundNodeExtensions.MakeCompilerGenerated(CreateBoundMethodGroup(node, instance, LookupOptions.MustBeInstance | LookupOptions.AllMethodsOfAnyArity | LookupOptions.MethodsOnly, diagnostics.AccumulatesDependencies, source, typeArgumentsOpt, QualificationKind.QualifiedViaValue));
			}
			((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(node, useSiteInfo);
			instance.Free();
			return result;
		}

		private BoundExpression BindQueryOperatorCall(SyntaxNode node, BoundExpression source, string operatorName, ImmutableArray<BoundExpression> arguments, TextSpan operatorNameLocation, BindingDiagnosticBag diagnostics)
		{
			return BindQueryOperatorCall(node, source, operatorName, LookupQueryOperator(node, source, operatorName, null, diagnostics), arguments, operatorNameLocation, diagnostics);
		}

		private BoundExpression BindQueryOperatorCall(SyntaxNode node, BoundExpression source, string operatorName, BoundTypeArguments typeArgumentsOpt, ImmutableArray<BoundExpression> arguments, TextSpan operatorNameLocation, BindingDiagnosticBag diagnostics)
		{
			return BindQueryOperatorCall(node, source, operatorName, LookupQueryOperator(node, source, operatorName, typeArgumentsOpt, diagnostics), arguments, operatorNameLocation, diagnostics);
		}

		private BoundExpression BindQueryOperatorCall(SyntaxNode node, BoundExpression source, string operatorName, BoundMethodGroup methodGroup, ImmutableArray<BoundExpression> arguments, TextSpan operatorNameLocation, BindingDiagnosticBag diagnostics)
		{
			BoundExpression boundExpression = null;
			if (methodGroup != null)
			{
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
				OverloadResolution.OverloadResolutionResult results = OverloadResolution.QueryOperatorInvocationOverloadResolution(methodGroup, arguments, this, ref useSiteInfo);
				if (((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(node, useSiteInfo) && methodGroup.ResultKind != LookupResultKind.Inaccessible)
				{
					diagnostics = BindingDiagnosticBag.Discarded;
				}
				if (!results.BestResult.HasValue)
				{
					if (results.Candidates.Length == 0)
					{
						ImmutableArray<BoundExpression> arguments2 = arguments;
						CompoundUseSiteInfo<AssemblySymbol> useSiteInfo2 = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
						results = OverloadResolution.QueryOperatorInvocationOverloadResolution(methodGroup, arguments2, this, ref useSiteInfo2, includeEliminatedCandidates: true);
					}
					if (results.Candidates.Length > 0)
					{
						boundExpression = ReportOverloadResolutionFailureAndProduceBoundNode(node, methodGroup, arguments, default(ImmutableArray<string>), ref results, diagnostics, null, null, queryMode: true, null, null, Location.Create(node.SyntaxTree, operatorNameLocation));
					}
				}
				else
				{
					boundExpression = CreateBoundCallOrPropertyAccess(node, node, TypeCharacter.None, methodGroup, arguments, results.BestResult.Value, results.AsyncLambdaSubToFunctionMismatch, diagnostics);
					int num = arguments.Length - 1;
					for (int i = 0; i <= num; i++)
					{
						BoundExpression boundExpression2 = arguments[i];
						if (boundExpression2.Kind == BoundKind.QueryLambda)
						{
							BoundQueryLambda boundQueryLambda = (BoundQueryLambda)boundExpression2;
							if ((object)boundQueryLambda.LambdaSymbol.ReturnType == LambdaSymbol.ReturnTypePendingDelegate)
							{
								TypeSymbol returnType = TypeSymbolExtensions.DelegateOrExpressionDelegate(((BoundCall)boundExpression).Method.Parameters[i].Type, this).DelegateInvokeMethod.ReturnType;
								boundQueryLambda.LambdaSymbol.SetQueryLambdaReturnType(returnType);
							}
						}
					}
				}
			}
			if (boundExpression == null)
			{
				ImmutableArray<BoundExpression> immutableArray;
				if (arguments.IsEmpty)
				{
					immutableArray = ImmutableArray.Create(methodGroup ?? source);
				}
				else
				{
					ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
					instance.Add(methodGroup ?? source);
					instance.AddRange(arguments);
					immutableArray = instance.ToImmutableAndFree();
				}
				if (methodGroup == null)
				{
					boundExpression = BadExpression(node, immutableArray, ErrorTypeSymbol.UnknownResultType);
				}
				else
				{
					ArrayBuilder<Symbol> instance2 = ArrayBuilder<Symbol>.GetInstance();
					BoundExpressionExtensions.GetExpressionSymbols(methodGroup, instance2);
					LookupResultKind lookupResultKind = LookupResultKind.OverloadResolutionFailure;
					if (methodGroup.ResultKind < lookupResultKind)
					{
						lookupResultKind = methodGroup.ResultKind;
					}
					boundExpression = new BoundBadExpression(node, lookupResultKind, instance2.ToImmutableAndFree(), immutableArray, ErrorTypeSymbol.UnknownResultType, hasErrors: true);
				}
			}
			if (boundExpression.HasErrors && !source.HasErrors)
			{
				ReportDiagnostic(diagnostics, Location.Create(node.SyntaxTree, operatorNameLocation), ERRID.ERR_QueryOperatorNotFound, operatorName);
			}
			boundExpression.SetWasCompilerGenerated();
			return boundExpression;
		}

		private BoundStatement BindSelectBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectBlockSyntax node, BindingDiagnosticBag diagnostics)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax selectStatement = node.SelectStatement;
			BoundExpression boundExpression = BindSelectExpression(selectStatement.Expression, diagnostics);
			if (boundExpression.HasErrors)
			{
				diagnostics = BindingDiagnosticBag.Discarded;
			}
			BoundRValuePlaceholder boundRValuePlaceholder = new BoundRValuePlaceholder(selectStatement.Expression, boundExpression.Type);
			boundRValuePlaceholder.SetWasCompilerGenerated();
			BoundExpressionStatement expressionStatement = new BoundExpressionStatement(selectStatement, boundExpression);
			Binder binder = GetBinder(node);
			bool recommendSwitchTable = false;
			ImmutableArray<BoundCaseBlock> caseBlocks = binder.BindCaseBlocks(node.CaseBlocks, boundRValuePlaceholder, TypeSymbolExtensions.IsIntrinsicOrEnumType(boundExpression.Type), ref recommendSwitchTable, diagnostics);
			return new BoundSelectStatement(node, expressionStatement, boundRValuePlaceholder, caseBlocks, recommendSwitchTable, binder.GetExitLabel(SyntaxKind.ExitSelectStatement));
		}

		private BoundExpression BindSelectExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			ERRID eRRID = ERRID.ERR_None;
			switch (node.Kind())
			{
			case SyntaxKind.ParenthesizedExpression:
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ParenthesizedExpressionSyntax parenthesizedExpressionSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.ParenthesizedExpressionSyntax)node;
				BoundExpression boundExpression = BindSelectExpression(parenthesizedExpressionSyntax.Expression, diagnostics);
				return new BoundParenthesized(node, boundExpression, boundExpression.Type);
			}
			case SyntaxKind.AddressOfExpression:
				eRRID = ERRID.ERR_AddressOfInSelectCaseExpr;
				break;
			case SyntaxKind.SingleLineFunctionLambdaExpression:
			case SyntaxKind.SingleLineSubLambdaExpression:
			case SyntaxKind.MultiLineFunctionLambdaExpression:
			case SyntaxKind.MultiLineSubLambdaExpression:
				eRRID = ERRID.ERR_LambdaInSelectCaseExpr;
				break;
			}
			BoundExpression boundExpression2 = BindExpression(node, diagnostics);
			if (boundExpression2.HasErrors)
			{
				boundExpression2 = MakeRValue(boundExpression2, diagnostics);
			}
			else if (eRRID != 0)
			{
				ReportDiagnostic(diagnostics, node, eRRID);
				boundExpression2 = MakeRValueAndIgnoreDiagnostics(boundExpression2);
			}
			else
			{
				boundExpression2 = MakeRValue(boundExpression2, diagnostics);
			}
			return boundExpression2;
		}

		private ImmutableArray<BoundCaseBlock> BindCaseBlocks(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax> caseBlocks, BoundRValuePlaceholder selectExpression, bool convertCaseElements, ref bool recommendSwitchTable, BindingDiagnosticBag diagnostics)
		{
			if (!caseBlocks.IsEmpty())
			{
				ArrayBuilder<BoundCaseBlock> instance = ArrayBuilder<BoundCaseBlock>.GetInstance();
				SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax>.Enumerator enumerator = caseBlocks.GetEnumerator();
				while (enumerator.MoveNext())
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax current = enumerator.Current;
					instance.Add(BindCaseBlock(current, selectExpression, convertCaseElements, diagnostics));
				}
				return OptimizeSelectStatement(selectExpression, instance, ref recommendSwitchTable, diagnostics);
			}
			return ImmutableArray<BoundCaseBlock>.Empty;
		}

		private BoundCaseBlock BindCaseBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax node, BoundRValuePlaceholder selectExpression, bool convertCaseElements, BindingDiagnosticBag diagnostics)
		{
			BoundCaseStatement caseStatement = BindCaseStatement(node.CaseStatement, selectExpression, convertCaseElements, diagnostics);
			SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements = node.Statements;
			BoundBlock body = BoundNodeExtensions.MakeCompilerGenerated(GetBinder(statements).BindBlock(node, statements, diagnostics));
			return new BoundCaseBlock(node, caseStatement, body);
		}

		private BoundCaseStatement BindCaseStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax node, BoundRValuePlaceholder selectExpressionOpt, bool convertCaseElements, BindingDiagnosticBag diagnostics)
		{
			ImmutableArray<BoundCaseClause> caseClauses;
			if (node.Kind() == SyntaxKind.CaseStatement)
			{
				ArrayBuilder<BoundCaseClause> instance = ArrayBuilder<BoundCaseClause>.GetInstance();
				SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax>.Enumerator enumerator = node.Cases.GetEnumerator();
				while (enumerator.MoveNext())
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax current = enumerator.Current;
					instance.Add(BindCaseClause(current, selectExpressionOpt, convertCaseElements, diagnostics));
				}
				caseClauses = instance.ToImmutableAndFree();
			}
			else
			{
				caseClauses = ImmutableArray<BoundCaseClause>.Empty;
			}
			return new BoundCaseStatement(node, caseClauses, null);
		}

		private BoundCaseClause BindCaseClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax node, BoundRValuePlaceholder selectExpressionOpt, bool convertCaseElements, BindingDiagnosticBag diagnostics)
		{
			switch (node.Kind())
			{
			case SyntaxKind.CaseEqualsClause:
			case SyntaxKind.CaseNotEqualsClause:
			case SyntaxKind.CaseLessThanClause:
			case SyntaxKind.CaseLessThanOrEqualClause:
			case SyntaxKind.CaseGreaterThanOrEqualClause:
			case SyntaxKind.CaseGreaterThanClause:
				return BindRelationalCaseClause((Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax)node, selectExpressionOpt, convertCaseElements, diagnostics);
			case SyntaxKind.SimpleCaseClause:
				return BindSimpleCaseClause((Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleCaseClauseSyntax)node, selectExpressionOpt, convertCaseElements, diagnostics);
			case SyntaxKind.RangeCaseClause:
				return BindRangeCaseClause((Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeCaseClauseSyntax)node, selectExpressionOpt, convertCaseElements, diagnostics);
			default:
				throw ExceptionUtilities.UnexpectedValue(node.Kind());
			}
		}

		private BoundCaseClause BindRelationalCaseClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax node, BoundRValuePlaceholder selectExpressionOpt, bool convertCaseElements, BindingDiagnosticBag diagnostics)
		{
			BinaryOperatorKind operatorKind = node.Kind() switch
			{
				SyntaxKind.CaseEqualsClause => BinaryOperatorKind.Equals, 
				SyntaxKind.CaseNotEqualsClause => BinaryOperatorKind.NotEquals, 
				SyntaxKind.CaseLessThanOrEqualClause => BinaryOperatorKind.LessThanOrEqual, 
				SyntaxKind.CaseGreaterThanOrEqualClause => BinaryOperatorKind.GreaterThanOrEqual, 
				SyntaxKind.CaseLessThanClause => BinaryOperatorKind.LessThan, 
				SyntaxKind.CaseGreaterThanClause => BinaryOperatorKind.GreaterThan, 
				_ => throw ExceptionUtilities.UnexpectedValue(node.Kind()), 
			};
			BoundExpression conditionOpt = null;
			BoundExpression valueOpt = BindCaseClauseExpression(node.Value, node, selectExpressionOpt, VisualBasicExtensions.Kind(node.OperatorToken), operatorKind, convertCaseElements, ref conditionOpt, diagnostics);
			return new BoundRelationalCaseClause(node, operatorKind, valueOpt, conditionOpt);
		}

		private BoundCaseClause BindSimpleCaseClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleCaseClauseSyntax node, BoundRValuePlaceholder selectExpressionOpt, bool convertCaseElements, BindingDiagnosticBag diagnostics)
		{
			BoundExpression conditionOpt = null;
			BoundExpression valueOpt = BindCaseClauseExpression(node.Value, node, selectExpressionOpt, SyntaxKind.EqualsToken, BinaryOperatorKind.Equals, convertCaseElements, ref conditionOpt, diagnostics);
			return new BoundSimpleCaseClause(node, valueOpt, conditionOpt);
		}

		private BoundCaseClause BindRangeCaseClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeCaseClauseSyntax node, BoundRValuePlaceholder selectExpressionOpt, bool convertCaseElements, BindingDiagnosticBag diagnostics)
		{
			BoundExpression conditionOpt = null;
			BoundExpression lowerBoundOpt = BindCaseClauseExpression(node.LowerBound, node, selectExpressionOpt, SyntaxKind.GreaterThanEqualsToken, BinaryOperatorKind.GreaterThanOrEqual, convertCaseElements, ref conditionOpt, diagnostics);
			BoundExpression conditionOpt2 = null;
			BoundExpression upperBoundOpt = BindCaseClauseExpression(node.UpperBound, node, selectExpressionOpt, SyntaxKind.LessThanEqualsToken, BinaryOperatorKind.LessThanOrEqual, convertCaseElements, ref conditionOpt2, diagnostics);
			return new BoundRangeCaseClause(node, lowerBoundOpt, upperBoundOpt, conditionOpt, conditionOpt2);
		}

		private BoundExpression BindCaseClauseExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expressionSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax caseClauseSyntax, BoundRValuePlaceholder selectExpressionOpt, SyntaxKind operatorTokenKind, BinaryOperatorKind operatorKind, bool convertCaseElements, ref BoundExpression conditionOpt, BindingDiagnosticBag diagnostics)
		{
			BoundExpression boundExpression = BindValue(expressionSyntax, diagnostics);
			if (selectExpressionOpt == null)
			{
				conditionOpt = null;
				return MakeRValue(boundExpression, diagnostics);
			}
			if (convertCaseElements && TypeSymbolExtensions.IsIntrinsicOrEnumType(boundExpression.Type))
			{
				return ApplyImplicitConversion(expressionSyntax, selectExpressionOpt.Type, boundExpression, diagnostics);
			}
			conditionOpt = BoundNodeExtensions.MakeCompilerGenerated(BindBinaryOperator(caseClauseSyntax, selectExpressionOpt, boundExpression, operatorTokenKind, operatorKind, isOperandOfConditionalBranch: false, diagnostics, isSelectCase: true));
			return null;
		}

		private ImmutableArray<BoundCaseBlock> OptimizeSelectStatement(BoundRValuePlaceholder selectExpression, ArrayBuilder<BoundCaseBlock> caseBlockBuilder, ref bool generateSwitchTable, BindingDiagnosticBag diagnostics)
		{
			generateSwitchTable = RecommendSwitchTable(selectExpression, caseBlockBuilder, diagnostics);
			if (!generateSwitchTable && caseBlockBuilder.Any())
			{
				NamedTypeSymbol specialType = GetSpecialType(SpecialType.System_Boolean, selectExpression.Syntax, diagnostics);
				ArrayBuilder<BoundCaseClause> instance = ArrayBuilder<BoundCaseClause>.GetInstance();
				int num = caseBlockBuilder.Count - 1;
				for (int i = 0; i <= num; i++)
				{
					BoundCaseBlock boundCaseBlock = caseBlockBuilder[i];
					if (VisualBasicExtensions.Kind(boundCaseBlock.Syntax) != SyntaxKind.CaseElseBlock && !boundCaseBlock.CaseStatement.Syntax.IsMissing)
					{
						BoundCaseStatement caseStatement = boundCaseBlock.CaseStatement;
						SyntaxNode syntax = caseStatement.Syntax;
						BoundExpression boundExpression = null;
						bool flag = false;
						ImmutableArray<BoundCaseClause>.Enumerator enumerator = caseStatement.CaseClauses.GetEnumerator();
						while (enumerator.MoveNext())
						{
							BoundCaseClause current = enumerator.Current;
							BoundExpression conditionOpt = null;
							BoundCaseClause boundCaseClause = ComputeCaseClauseCondition(current, out conditionOpt, selectExpression, diagnostics);
							instance.Add(boundCaseClause);
							flag = flag || !boundCaseClause.Equals(current);
							boundExpression = ((boundExpression != null) ? BoundNodeExtensions.MakeCompilerGenerated(BindBinaryOperator(syntax, boundExpression, conditionOpt, SyntaxKind.OrElseKeyword, BinaryOperatorKind.OrElse, isOperandOfConditionalBranch: false, diagnostics, isSelectCase: true)) : conditionOpt);
						}
						ImmutableArray<BoundCaseClause> caseClauses = ((!flag) ? caseStatement.CaseClauses : instance.ToImmutable());
						instance.Clear();
						boundExpression = ApplyImplicitConversion(boundExpression.Syntax, specialType, boundExpression, diagnostics, isOperandOfConditionalBranch: true);
						caseStatement = caseStatement.Update(caseClauses, boundExpression);
						caseBlockBuilder[i] = boundCaseBlock.Update(caseStatement, boundCaseBlock.Body);
					}
				}
				instance.Free();
			}
			return caseBlockBuilder.ToImmutableAndFree();
		}

		private BoundCaseClause ComputeCaseClauseCondition(BoundCaseClause caseClause, out BoundExpression conditionOpt, BoundRValuePlaceholder selectExpression, BindingDiagnosticBag diagnostics)
		{
			return caseClause.Kind switch
			{
				BoundKind.RelationalCaseClause => ComputeRelationalCaseClauseCondition((BoundRelationalCaseClause)caseClause, out conditionOpt, selectExpression, diagnostics), 
				BoundKind.SimpleCaseClause => ComputeSimpleCaseClauseCondition((BoundSimpleCaseClause)caseClause, out conditionOpt, selectExpression, diagnostics), 
				BoundKind.RangeCaseClause => ComputeRangeCaseClauseCondition((BoundRangeCaseClause)caseClause, out conditionOpt, selectExpression, diagnostics), 
				_ => throw ExceptionUtilities.UnexpectedValue(caseClause.Kind), 
			};
		}

		private BoundCaseClause ComputeRelationalCaseClauseCondition(BoundRelationalCaseClause boundClause, out BoundExpression conditionOpt, BoundRValuePlaceholder selectExpression, BindingDiagnosticBag diagnostics)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax relationalCaseClauseSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax)boundClause.Syntax;
			conditionOpt = boundClause.ConditionOpt ?? BoundNodeExtensions.MakeCompilerGenerated(BindBinaryOperator(relationalCaseClauseSyntax, selectExpression, boundClause.ValueOpt, VisualBasicExtensions.Kind(relationalCaseClauseSyntax.OperatorToken), boundClause.OperatorKind, isOperandOfConditionalBranch: false, diagnostics, isSelectCase: true));
			return boundClause.Update(boundClause.OperatorKind, null, conditionOpt);
		}

		private BoundCaseClause ComputeSimpleCaseClauseCondition(BoundSimpleCaseClause boundClause, out BoundExpression conditionOpt, BoundRValuePlaceholder selectExpression, BindingDiagnosticBag diagnostics)
		{
			conditionOpt = boundClause.ConditionOpt ?? BoundNodeExtensions.MakeCompilerGenerated(BindBinaryOperator(boundClause.Syntax, selectExpression, boundClause.ValueOpt, SyntaxKind.EqualsToken, BinaryOperatorKind.Equals, isOperandOfConditionalBranch: false, diagnostics, isSelectCase: true));
			return boundClause.Update(null, conditionOpt);
		}

		private BoundCaseClause ComputeRangeCaseClauseCondition(BoundRangeCaseClause boundClause, out BoundExpression conditionOpt, BoundRValuePlaceholder selectExpression, BindingDiagnosticBag diagnostics)
		{
			SyntaxNode syntax = boundClause.Syntax;
			BoundExpression boundExpression = boundClause.LowerBoundConditionOpt;
			if (boundExpression == null)
			{
				boundExpression = BoundNodeExtensions.MakeCompilerGenerated(BindBinaryOperator(boundClause.Syntax, selectExpression, boundClause.LowerBoundOpt, SyntaxKind.GreaterThanEqualsToken, BinaryOperatorKind.GreaterThanOrEqual, isOperandOfConditionalBranch: false, diagnostics, isSelectCase: true));
			}
			BoundExpression boundExpression2 = boundClause.UpperBoundConditionOpt;
			if (boundExpression2 == null)
			{
				boundExpression2 = BoundNodeExtensions.MakeCompilerGenerated(BindBinaryOperator(syntax, selectExpression, boundClause.UpperBoundOpt, SyntaxKind.LessThanEqualsToken, BinaryOperatorKind.LessThanOrEqual, isOperandOfConditionalBranch: false, diagnostics, isSelectCase: true));
			}
			conditionOpt = BoundNodeExtensions.MakeCompilerGenerated(BindBinaryOperator(syntax, boundExpression, boundExpression2, SyntaxKind.AndAlsoKeyword, BinaryOperatorKind.AndAlso, isOperandOfConditionalBranch: false, diagnostics, isSelectCase: true));
			return boundClause.Update(null, null, boundExpression, boundExpression2);
		}

		private bool RecommendSwitchTable(BoundRValuePlaceholder selectExpr, ArrayBuilder<BoundCaseBlock> caseBlocks, BindingDiagnosticBag diagnostics)
		{
			if (!caseBlocks.Any() || !TypeSymbolExtensions.IsValidTypeForSwitchTable(selectExpr.Type))
			{
				return false;
			}
			if (TypeSymbolExtensions.IsStringType(selectExpr.Type) && OptionCompareText)
			{
				return false;
			}
			bool flag = true;
			ArrayBuilder<BoundCaseBlock>.Enumerator enumerator = caseBlocks.GetEnumerator();
			while (enumerator.MoveNext())
			{
				ImmutableArray<BoundCaseClause>.Enumerator enumerator2 = enumerator.Current.CaseStatement.CaseClauses.GetEnumerator();
				while (enumerator2.MoveNext())
				{
					BoundCaseClause current = enumerator2.Current;
					switch (current.Kind)
					{
					case BoundKind.RelationalCaseClause:
					{
						BoundRelationalCaseClause boundRelationalCaseClause = (BoundRelationalCaseClause)current;
						BoundExpression valueOpt2 = boundRelationalCaseClause.ValueOpt;
						if (valueOpt2 == null || boundRelationalCaseClause.OperatorKind != BinaryOperatorKind.Equals || (object)valueOpt2.ConstantValueOpt == null || !SwitchConstantValueHelper.IsValidSwitchCaseLabelConstant(valueOpt2.ConstantValueOpt))
						{
							return false;
						}
						break;
					}
					case BoundKind.RangeCaseClause:
					{
						BoundRangeCaseClause obj = (BoundRangeCaseClause)current;
						BoundExpression lowerBoundOpt = obj.LowerBoundOpt;
						BoundExpression upperBoundOpt = obj.UpperBoundOpt;
						if (lowerBoundOpt == null || upperBoundOpt == null || (object)lowerBoundOpt.ConstantValueOpt == null || (object)upperBoundOpt.ConstantValueOpt == null || !SwitchConstantValueHelper.IsValidSwitchCaseLabelConstant(lowerBoundOpt.ConstantValueOpt) || !SwitchConstantValueHelper.IsValidSwitchCaseLabelConstant(upperBoundOpt.ConstantValueOpt))
						{
							return false;
						}
						flag = false;
						break;
					}
					default:
					{
						BoundExpression valueOpt = ((BoundSimpleCaseClause)current).ValueOpt;
						if (valueOpt == null || (object)valueOpt.ConstantValueOpt == null || !SwitchConstantValueHelper.IsValidSwitchCaseLabelConstant(valueOpt.ConstantValueOpt))
						{
							return false;
						}
						break;
					}
					}
				}
			}
			return !ReportInvalidSelectCaseRange(caseBlocks, diagnostics) && flag;
		}

		private bool ReportInvalidSelectCaseRange(ArrayBuilder<BoundCaseBlock> caseBlocks, BindingDiagnosticBag diagnostics)
		{
			ArrayBuilder<BoundCaseBlock>.Enumerator enumerator = caseBlocks.GetEnumerator();
			while (enumerator.MoveNext())
			{
				ImmutableArray<BoundCaseClause>.Enumerator enumerator2 = enumerator.Current.CaseStatement.CaseClauses.GetEnumerator();
				while (enumerator2.MoveNext())
				{
					BoundCaseClause current = enumerator2.Current;
					BoundKind kind = current.Kind;
					if (kind == BoundKind.RangeCaseClause)
					{
						BoundRangeCaseClause boundRangeCaseClause = (BoundRangeCaseClause)current;
						BoundExpression lowerBoundOpt = boundRangeCaseClause.LowerBoundOpt;
						if (IsInvalidSelectCaseRange(ubConstantValue: boundRangeCaseClause.UpperBoundOpt.ConstantValueOpt, lbConstantValue: lowerBoundOpt.ConstantValueOpt))
						{
							ReportDiagnostic(diagnostics, boundRangeCaseClause.Syntax, ERRID.WRN_SelectCaseInvalidRange);
							return true;
						}
					}
				}
			}
			return false;
		}

		private static bool IsInvalidSelectCaseRange(ConstantValue lbConstantValue, ConstantValue ubConstantValue)
		{
			switch (lbConstantValue.SpecialType)
			{
			case SpecialType.System_Boolean:
			case SpecialType.System_Byte:
			case SpecialType.System_UInt16:
			case SpecialType.System_UInt32:
			case SpecialType.System_UInt64:
				return lbConstantValue.UInt64Value > ubConstantValue.UInt64Value;
			case SpecialType.System_Char:
			case SpecialType.System_SByte:
			case SpecialType.System_Int16:
			case SpecialType.System_Int32:
			case SpecialType.System_Int64:
				return lbConstantValue.Int64Value > ubConstantValue.Int64Value;
			case SpecialType.System_Single:
			case SpecialType.System_Double:
				return lbConstantValue.DoubleValue > ubConstantValue.DoubleValue;
			case SpecialType.System_Decimal:
				return decimal.Compare(lbConstantValue.DecimalValue, ubConstantValue.DecimalValue) > 0;
			default:
				return false;
			}
		}

		public virtual BoundStatement BindStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax node, BindingDiagnosticBag diagnostics)
		{
			switch (node.Kind())
			{
			case SyntaxKind.SimpleAssignmentStatement:
			case SyntaxKind.AddAssignmentStatement:
			case SyntaxKind.SubtractAssignmentStatement:
			case SyntaxKind.MultiplyAssignmentStatement:
			case SyntaxKind.DivideAssignmentStatement:
			case SyntaxKind.IntegerDivideAssignmentStatement:
			case SyntaxKind.ExponentiateAssignmentStatement:
			case SyntaxKind.LeftShiftAssignmentStatement:
			case SyntaxKind.RightShiftAssignmentStatement:
			case SyntaxKind.ConcatenateAssignmentStatement:
				return BindAssignmentStatement((Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax)node, diagnostics);
			case SyntaxKind.MidAssignmentStatement:
				return BindMidAssignmentStatement((Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax)node, diagnostics);
			case SyntaxKind.AddHandlerStatement:
			case SyntaxKind.RemoveHandlerStatement:
				return BindAddRemoveHandlerStatement((Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax)node, diagnostics);
			case SyntaxKind.RaiseEventStatement:
				return BindRaiseEventStatement((Microsoft.CodeAnalysis.VisualBasic.Syntax.RaiseEventStatementSyntax)node, diagnostics);
			case SyntaxKind.PrintStatement:
				return BindPrintStatement((Microsoft.CodeAnalysis.VisualBasic.Syntax.PrintStatementSyntax)node, diagnostics);
			case SyntaxKind.ExpressionStatement:
				return BindExpressionStatement((Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionStatementSyntax)node, diagnostics);
			case SyntaxKind.CallStatement:
				return BindCallStatement((Microsoft.CodeAnalysis.VisualBasic.Syntax.CallStatementSyntax)node, diagnostics);
			case SyntaxKind.GoToStatement:
				return BindGoToStatement((Microsoft.CodeAnalysis.VisualBasic.Syntax.GoToStatementSyntax)node, diagnostics);
			case SyntaxKind.LabelStatement:
				return BindLabelStatement((Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax)node, diagnostics);
			case SyntaxKind.SingleLineIfStatement:
				return BindSingleLineIfStatement((Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineIfStatementSyntax)node, diagnostics);
			case SyntaxKind.MultiLineIfBlock:
				return BindMultiLineIfBlock((Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineIfBlockSyntax)node, diagnostics);
			case SyntaxKind.ElseIfStatement:
			{
				BoundExpression item = BindBooleanExpression(((Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfStatementSyntax)node).Condition, diagnostics);
				return new BoundBadStatement(node, ImmutableArray.Create((BoundNode)item), hasErrors: true);
			}
			case SyntaxKind.SelectBlock:
				return BindSelectBlock((Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectBlockSyntax)node, diagnostics);
			case SyntaxKind.CaseStatement:
				return BindStandAloneCaseStatement((Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax)node, diagnostics);
			case SyntaxKind.LocalDeclarationStatement:
				return BindLocalDeclaration((Microsoft.CodeAnalysis.VisualBasic.Syntax.LocalDeclarationStatementSyntax)node, diagnostics);
			case SyntaxKind.SimpleDoLoopBlock:
			case SyntaxKind.DoWhileLoopBlock:
			case SyntaxKind.DoUntilLoopBlock:
			case SyntaxKind.DoLoopWhileBlock:
			case SyntaxKind.DoLoopUntilBlock:
				return BindDoLoop((Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax)node, diagnostics);
			case SyntaxKind.WhileBlock:
				return BindWhileBlock((Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileBlockSyntax)node, diagnostics);
			case SyntaxKind.ForBlock:
				return BindForToBlock((Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax)node, diagnostics);
			case SyntaxKind.ForEachBlock:
				return BindForEachBlock((Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax)node, diagnostics);
			case SyntaxKind.WithBlock:
				return BindWithBlock((Microsoft.CodeAnalysis.VisualBasic.Syntax.WithBlockSyntax)node, diagnostics);
			case SyntaxKind.UsingBlock:
				return BindUsingBlock((Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingBlockSyntax)node, diagnostics);
			case SyntaxKind.SyncLockBlock:
				return BindSyncLockBlock((Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockBlockSyntax)node, diagnostics);
			case SyntaxKind.TryBlock:
				return BindTryBlock((Microsoft.CodeAnalysis.VisualBasic.Syntax.TryBlockSyntax)node, diagnostics);
			case SyntaxKind.ExitDoStatement:
			case SyntaxKind.ExitForStatement:
			case SyntaxKind.ExitSubStatement:
			case SyntaxKind.ExitFunctionStatement:
			case SyntaxKind.ExitPropertyStatement:
			case SyntaxKind.ExitTryStatement:
			case SyntaxKind.ExitSelectStatement:
			case SyntaxKind.ExitWhileStatement:
				return BindExitStatement((Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax)node, diagnostics);
			case SyntaxKind.ContinueWhileStatement:
			case SyntaxKind.ContinueDoStatement:
			case SyntaxKind.ContinueForStatement:
				return BindContinueStatement((Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax)node, diagnostics);
			case SyntaxKind.ReturnStatement:
				return BindReturn((Microsoft.CodeAnalysis.VisualBasic.Syntax.ReturnStatementSyntax)node, diagnostics);
			case SyntaxKind.YieldStatement:
				return BindYield((Microsoft.CodeAnalysis.VisualBasic.Syntax.YieldStatementSyntax)node, diagnostics);
			case SyntaxKind.ThrowStatement:
				return BindThrow((Microsoft.CodeAnalysis.VisualBasic.Syntax.ThrowStatementSyntax)node, diagnostics);
			case SyntaxKind.ErrorStatement:
				return BindError((Microsoft.CodeAnalysis.VisualBasic.Syntax.ErrorStatementSyntax)node, diagnostics);
			case SyntaxKind.EmptyStatement:
				return new BoundNoOpStatement(node);
			case SyntaxKind.SubBlock:
			case SyntaxKind.FunctionBlock:
			case SyntaxKind.ConstructorBlock:
			case SyntaxKind.OperatorBlock:
			case SyntaxKind.GetAccessorBlock:
			case SyntaxKind.SetAccessorBlock:
			case SyntaxKind.AddHandlerAccessorBlock:
			case SyntaxKind.RemoveHandlerAccessorBlock:
			case SyntaxKind.RaiseEventAccessorBlock:
				return BindMethodBlock((Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax)node, diagnostics);
			case SyntaxKind.ReDimStatement:
			case SyntaxKind.ReDimPreserveStatement:
				return BindRedimStatement((Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax)node, diagnostics);
			case SyntaxKind.EraseStatement:
				return BindEraseStatement((Microsoft.CodeAnalysis.VisualBasic.Syntax.EraseStatementSyntax)node, diagnostics);
			case SyntaxKind.EndIfStatement:
			case SyntaxKind.EndUsingStatement:
			case SyntaxKind.EndWithStatement:
			case SyntaxKind.EndSelectStatement:
			case SyntaxKind.EndStructureStatement:
			case SyntaxKind.EndEnumStatement:
			case SyntaxKind.EndInterfaceStatement:
			case SyntaxKind.EndClassStatement:
			case SyntaxKind.EndModuleStatement:
			case SyntaxKind.EndNamespaceStatement:
			case SyntaxKind.EndSubStatement:
			case SyntaxKind.EndFunctionStatement:
			case SyntaxKind.EndGetStatement:
			case SyntaxKind.EndSetStatement:
			case SyntaxKind.EndPropertyStatement:
			case SyntaxKind.EndOperatorStatement:
			case SyntaxKind.EndEventStatement:
			case SyntaxKind.EndAddHandlerStatement:
			case SyntaxKind.EndRemoveHandlerStatement:
			case SyntaxKind.EndRaiseEventStatement:
			case SyntaxKind.EndWhileStatement:
			case SyntaxKind.EndTryStatement:
			case SyntaxKind.EndSyncLockStatement:
			case SyntaxKind.IncompleteMember:
			case SyntaxKind.FinallyStatement:
			case SyntaxKind.NextStatement:
				return new BoundBadStatement(node, ImmutableArray<BoundNode>.Empty, hasErrors: true);
			case SyntaxKind.SimpleLoopStatement:
			case SyntaxKind.LoopWhileStatement:
			case SyntaxKind.LoopUntilStatement:
				if (!SyntaxFacts.IsDoLoopBlock(node.Parent.Kind()))
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax whileOrUntilClause = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax)node).WhileOrUntilClause;
					ImmutableArray<BoundNode> childBoundNodes2 = ((whileOrUntilClause == null) ? ImmutableArray<BoundNode>.Empty : ImmutableArray.Create((BoundNode)BindBooleanExpression(whileOrUntilClause.Condition, diagnostics)));
					return new BoundBadStatement(node, childBoundNodes2, hasErrors: true);
				}
				break;
			case SyntaxKind.CatchStatement:
				if (node.Parent.Kind() != SyntaxKind.CatchBlock)
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchFilterClauseSyntax whenClause = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax)node).WhenClause;
					ImmutableArray<BoundNode> childBoundNodes = ((whenClause == null) ? ImmutableArray<BoundNode>.Empty : ImmutableArray.Create((BoundNode)BindBooleanExpression(whenClause.Filter, diagnostics)));
					return new BoundBadStatement(node, childBoundNodes, hasErrors: true);
				}
				break;
			case SyntaxKind.ResumeStatement:
			case SyntaxKind.ResumeLabelStatement:
			case SyntaxKind.ResumeNextStatement:
				return BindResumeStatement((Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax)node, diagnostics);
			case SyntaxKind.OnErrorGoToZeroStatement:
			case SyntaxKind.OnErrorGoToMinusOneStatement:
			case SyntaxKind.OnErrorGoToLabelStatement:
			case SyntaxKind.OnErrorResumeNextStatement:
				return BindOnErrorStatement(node, diagnostics);
			case SyntaxKind.StopStatement:
				return BindStopStatement((Microsoft.CodeAnalysis.VisualBasic.Syntax.StopOrEndStatementSyntax)node);
			case SyntaxKind.EndStatement:
				return BindEndStatement((Microsoft.CodeAnalysis.VisualBasic.Syntax.StopOrEndStatementSyntax)node, diagnostics);
			}
			return new BoundBadStatement(node, ImmutableArray<BoundNode>.Empty, hasErrors: true);
		}

		private BoundBadStatement BindStandAloneCaseStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax caseStatement, BindingDiagnosticBag diagnostics)
		{
			BoundCaseStatement boundCaseStatement = BindCaseStatement(caseStatement, null, convertCaseElements: false, diagnostics);
			ArrayBuilder<BoundNode> instance = ArrayBuilder<BoundNode>.GetInstance(boundCaseStatement.CaseClauses.Length);
			ImmutableArray<BoundCaseClause>.Enumerator enumerator = boundCaseStatement.CaseClauses.GetEnumerator();
			while (enumerator.MoveNext())
			{
				BoundCaseClause current = enumerator.Current;
				switch (current.Kind)
				{
				case BoundKind.SimpleCaseClause:
				case BoundKind.RelationalCaseClause:
					instance.Add(((BoundSingleValueCaseClause)current).ValueOpt);
					break;
				case BoundKind.RangeCaseClause:
				{
					BoundRangeCaseClause boundRangeCaseClause = (BoundRangeCaseClause)current;
					instance.Add(boundRangeCaseClause.LowerBoundOpt);
					instance.Add(boundRangeCaseClause.UpperBoundOpt);
					break;
				}
				default:
					throw ExceptionUtilities.UnexpectedValue(current.Kind);
				}
			}
			return new BoundBadStatement(caseStatement, instance.ToImmutableAndFree(), hasErrors: true);
		}

		private BoundBlock BindMethodBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax methodBlock, BindingDiagnosticBag diagnostics)
		{
			ArrayBuilder<BoundStatement> instance = ArrayBuilder<BoundStatement>.GetInstance();
			ImmutableArray<LocalSymbol> immutableArray = ImmutableArray<LocalSymbol>.Empty;
			MethodSymbol methodSymbol = (MethodSymbol)ContainingMember;
			LocalSymbol localSymbol = ((!methodSymbol.IsIterator && (!methodSymbol.IsAsync || !methodSymbol.ReturnType.Equals(Compilation.GetWellKnownType(WellKnownType.System_Threading_Tasks_Task)))) ? GetLocalForFunctionValue() : null);
			if ((object)localSymbol != null)
			{
				BoundLocalDeclaration boundLocalDeclaration = new BoundLocalDeclaration(methodBlock.BlockStatement, localSymbol, null);
				boundLocalDeclaration.SetWasCompilerGenerated();
				instance.Add(boundLocalDeclaration);
			}
			Binder binder = GetBinder(methodBlock);
			BoundBlock boundBlock = binder.BindBlock(methodBlock, methodBlock.Statements, diagnostics);
			BoundLabelStatement item = new BoundLabelStatement(methodBlock.EndBlockStatement, binder.GetReturnLabel());
			if (boundBlock != null)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax resumeWithoutLabel = null;
				CheckOnErrorAndAwaitWalker.VisitBlock(binder, boundBlock, diagnostics, out var containsAwait, out var containsOnError, out var containsResume, out resumeWithoutLabel, out var containsLineNumberLabel, out var containsCatch, out var reportedAnError);
				if (binder.IsInAsyncContext() && !binder.IsInIteratorContext() && !containsAwait && !boundBlock.HasErrors && methodBlock.BlockStatement is Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax)
				{
					ReportDiagnostic(diagnostics, ((Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax)methodBlock.BlockStatement).Identifier, ERRID.WRN_AsyncLacksAwaits);
				}
				if (!reportedAnError && (containsOnError || containsResume || (containsCatch && containsLineNumberLabel)))
				{
					if (methodSymbol.MethodKind == MethodKind.Constructor)
					{
						bool isMyBaseConstructorCall = false;
						if (InitializerRewriter.HasExplicitMeConstructorCall(boundBlock, ContainingMember.ContainingType, out isMyBaseConstructorCall) || isMyBaseConstructorCall)
						{
							instance.Add(boundBlock.Statements[0]);
							boundBlock = boundBlock.Update(boundBlock.StatementListSyntax, boundBlock.Locals, boundBlock.Statements.RemoveAt(0));
						}
					}
					boundBlock = boundBlock.Update(boundBlock.StatementListSyntax, boundBlock.Locals, boundBlock.Statements.Add(item));
					instance.Add(BoundNodeExtensions.MakeCompilerGenerated(new BoundUnstructuredExceptionHandlingStatement(methodBlock, containsOnError, containsResume, resumeWithoutLabel, containsLineNumberLabel, BoundNodeExtensions.MakeCompilerGenerated(boundBlock))));
				}
				else
				{
					immutableArray = boundBlock.Locals;
					instance.AddRange(boundBlock.Statements);
					instance.Add(item);
				}
				DisallowFurtherImplicitVariableDeclaration(diagnostics);
				ImmutableArray<LocalSymbol> implicitlyDeclaredVariables = ImplicitlyDeclaredVariables;
				if (implicitlyDeclaredVariables.Length > 0)
				{
					immutableArray = ((!immutableArray.IsEmpty) ? implicitlyDeclaredVariables.Concat(immutableArray) : implicitlyDeclaredVariables);
				}
				ReportNameConfictsBetweenStaticLocals(binder, diagnostics);
			}
			else
			{
				instance.Add(item);
			}
			if ((object)localSymbol != null)
			{
				if (immutableArray.IsEmpty)
				{
					immutableArray = ImmutableArray.Create(localSymbol);
				}
				else
				{
					ArrayBuilder<LocalSymbol> instance2 = ArrayBuilder<LocalSymbol>.GetInstance();
					instance2.Add(localSymbol);
					instance2.AddRange(immutableArray);
					immutableArray = instance2.ToImmutableAndFree();
				}
				instance.Add(new BoundReturnStatement(methodBlock.EndBlockStatement, BoundNodeExtensions.MakeCompilerGenerated(new BoundLocal(methodBlock.EndBlockStatement, localSymbol, isLValue: false, localSymbol.Type)), null, null));
			}
			else
			{
				instance.Add(new BoundReturnStatement(methodBlock.EndBlockStatement, null, null, null));
			}
			return new BoundBlock(methodBlock, methodBlock?.Statements ?? default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), immutableArray, instance.ToImmutableAndFree());
		}

		private static void ReportNameConfictsBetweenStaticLocals(Binder methodBlockBinder, BindingDiagnosticBag diagnostics)
		{
			Binder binder = methodBlockBinder;
			MethodBodyBinder methodBodyBinder;
			do
			{
				methodBodyBinder = binder as MethodBodyBinder;
				if (methodBodyBinder != null)
				{
					break;
				}
				binder = binder.ContainingBinder;
			}
			while (binder != null);
			if (methodBodyBinder == null)
			{
				return;
			}
			Dictionary<string, ArrayBuilder<LocalSymbol>> dictionary = null;
			foreach (BlockBaseBinder value3 in methodBodyBinder.StmtListToBinderMap.Values)
			{
				ImmutableArray<LocalSymbol>.Enumerator enumerator2 = value3.Locals.GetEnumerator();
				while (enumerator2.MoveNext())
				{
					LocalSymbol current = enumerator2.Current;
					if (current.IsStatic)
					{
						ArrayBuilder<LocalSymbol> value = null;
						if (dictionary == null)
						{
							dictionary = new Dictionary<string, ArrayBuilder<LocalSymbol>>(CaseInsensitiveComparison.Comparer);
							value = new ArrayBuilder<LocalSymbol>();
							dictionary.Add(current.Name, value);
						}
						else if (!dictionary.TryGetValue(current.Name, out value))
						{
							value = new ArrayBuilder<LocalSymbol>();
							dictionary.Add(current.Name, value);
						}
						value.Add(current);
					}
				}
			}
			if (dictionary == null)
			{
				return;
			}
			foreach (KeyValuePair<string, ArrayBuilder<LocalSymbol>> item in dictionary)
			{
				ArrayBuilder<LocalSymbol> value2 = item.Value;
				if (value2.Count <= 1)
				{
					continue;
				}
				LocalSymbol localSymbol = value2[0];
				int num = value2.Count - 1;
				for (int i = 1; i <= num; i++)
				{
					if (localSymbol.IdentifierToken.Position > value2[i].IdentifierToken.Position)
					{
						localSymbol = value2[i];
					}
				}
				ArrayBuilder<LocalSymbol>.Enumerator enumerator4 = value2.GetEnumerator();
				while (enumerator4.MoveNext())
				{
					LocalSymbol current2 = enumerator4.Current;
					if ((object)localSymbol != current2)
					{
						ReportDiagnostic(diagnostics, current2.IdentifierToken, ERRID.ERR_DuplicateLocalStatic1, current2.Name);
					}
				}
			}
		}

		private BoundStatement BindRedimStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax node, BindingDiagnosticBag diagnostics)
		{
			ArrayBuilder<BoundRedimClause> instance = ArrayBuilder<BoundRedimClause>.GetInstance();
			bool flag = node.Kind() == SyntaxKind.ReDimPreserveStatement;
			SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax>.Enumerator enumerator = node.Clauses.GetEnumerator();
			while (enumerator.MoveNext())
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax current = enumerator.Current;
				bool isError = false;
				BoundExpression boundExpression = BindAssignmentTarget(current.Expression, diagnostics);
				if (boundExpression.HasErrors)
				{
					isError = true;
				}
				AdjustAssignmentTarget(current.Expression, boundExpression, diagnostics, ref isError);
				if (!isError && flag && MakeRValue(boundExpression, diagnostics).HasErrors)
				{
					isError = true;
				}
				ImmutableArray<BoundExpression> indices = ImmutableArray<BoundExpression>.Empty;
				if (current.ArrayBounds != null)
				{
					indices = BindArrayBounds(current.ArrayBounds, diagnostics, null, errorOnEmptyBound: true);
					ImmutableArray<BoundExpression>.Enumerator enumerator2 = indices.GetEnumerator();
					while (enumerator2.MoveNext())
					{
						if (enumerator2.Current.HasErrors)
						{
							isError = true;
						}
					}
				}
				ArrayTypeSymbol arrayTypeSymbol = null;
				if (!isError)
				{
					TypeSymbol type = boundExpression.Type;
					if (TypeSymbolExtensions.IsArrayType(type))
					{
						arrayTypeSymbol = (ArrayTypeSymbol)type;
					}
					else if (TypeSymbolExtensions.IsObjectType(type))
					{
						if (indices.Length > 0)
						{
							arrayTypeSymbol = ArrayTypeSymbol.CreateVBArray(type, default(ImmutableArray<CustomModifier>), indices.Length, Compilation);
						}
					}
					else
					{
						ReportDiagnostic(diagnostics, current.Expression, ERRID.ERR_ExpectedArray1, "Redim");
						isError = true;
					}
				}
				if (!isError)
				{
					if (indices.Length == 0)
					{
						ReportDiagnostic(diagnostics, current, ERRID.ERR_RedimNoSizes);
						isError = true;
					}
					else if (arrayTypeSymbol.Rank != indices.Length)
					{
						ReportDiagnostic(diagnostics, current, ERRID.ERR_RedimRankMismatch);
						isError = true;
					}
				}
				if (!isError && indices.Length > 32)
				{
					ReportDiagnostic(diagnostics, current, ERRID.ERR_ArrayRankLimit);
					isError = true;
				}
				instance.Add(new BoundRedimClause(current, boundExpression, indices, arrayTypeSymbol, flag, isError));
			}
			return new BoundRedimStatement(node, instance.ToImmutableAndFree());
		}

		private BoundStatement BindEraseStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.EraseStatementSyntax node, BindingDiagnosticBag diagnostics)
		{
			ArrayBuilder<BoundAssignmentOperator> instance = ArrayBuilder<BoundAssignmentOperator>.GetInstance();
			SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax>.Enumerator enumerator = node.Expressions.GetEnumerator();
			while (enumerator.MoveNext())
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax current = enumerator.Current;
				BoundExpression boundExpression = BindAssignmentTarget(current, diagnostics);
				BoundLiteral boundLiteral = BoundNodeExtensions.MakeCompilerGenerated(new BoundLiteral(current, ConstantValue.Nothing, null));
				BoundAssignmentOperator item;
				if (boundExpression.HasErrors)
				{
					item = BoundNodeExtensions.MakeCompilerGenerated(new BoundAssignmentOperator(current, boundExpression, boundLiteral, suppressObjectClone: false, boundExpression.Type, hasErrors: true));
				}
				else if (!TypeSymbolExtensions.IsErrorType(boundExpression.Type) && !TypeSymbolExtensions.IsArrayType(boundExpression.Type) && boundExpression.Type.SpecialType != SpecialType.System_Array && boundExpression.Type.SpecialType != SpecialType.System_Object)
				{
					ReportDiagnostic(diagnostics, current, ERRID.ERR_ExpectedArray1, "Erase");
					item = BoundNodeExtensions.MakeCompilerGenerated(new BoundAssignmentOperator(current, boundExpression, boundLiteral, suppressObjectClone: false, boundExpression.Type, hasErrors: true));
				}
				else
				{
					item = BoundNodeExtensions.MakeCompilerGenerated(BindAssignment(current, boundExpression, BoundNodeExtensions.MakeCompilerGenerated(ApplyImplicitConversion(current, boundExpression.Type, boundLiteral, diagnostics)), diagnostics));
				}
				instance.Add(item);
			}
			return new BoundEraseStatement(node, instance.ToImmutableAndFree());
		}

		private BoundStatement BindGoToStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.GoToStatementSyntax node, BindingDiagnosticBag diagnostics)
		{
			LabelSymbol labelSymbol = null;
			BoundExpression boundExpression = BindExpression(node.Label, diagnostics);
			if (boundExpression.Kind == BoundKind.Label)
			{
				BoundLabel boundLabel = (BoundLabel)boundExpression;
				labelSymbol = boundLabel.Label;
				bool hasErrors = boundLabel.HasErrors || !IsValidLabelForGoto(labelSymbol, node.Label, diagnostics);
				return new BoundGotoStatement(node, labelSymbol, boundLabel, hasErrors);
			}
			return new BoundBadStatement(node, ImmutableArray.Create((BoundNode)boundExpression), hasErrors: true);
		}

		private bool IsValidLabelForGoto(LabelSymbol label, Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax labelSyntax, BindingDiagnosticBag diagnostics)
		{
			bool flag = false;
			VisualBasicSyntaxNode visualBasicSyntaxNode = (VisualBasicSyntaxNode)label.LabelName.Parent;
			ERRID eRRID = ERRID.ERR_None;
			for (; visualBasicSyntaxNode != null; visualBasicSyntaxNode = visualBasicSyntaxNode.Parent)
			{
				switch (visualBasicSyntaxNode.Kind())
				{
				case SyntaxKind.TryBlock:
				case SyntaxKind.CatchBlock:
				case SyntaxKind.FinallyBlock:
					eRRID = ERRID.ERR_GotoIntoTryHandler;
					goto default;
				case SyntaxKind.UsingBlock:
					eRRID = ERRID.ERR_GotoIntoUsing;
					goto default;
				case SyntaxKind.SyncLockBlock:
					eRRID = ERRID.ERR_GotoIntoSyncLock;
					goto default;
				case SyntaxKind.WithBlock:
					eRRID = ERRID.ERR_GotoIntoWith;
					goto default;
				case SyntaxKind.ForBlock:
				case SyntaxKind.ForEachBlock:
					eRRID = ERRID.ERR_GotoIntoFor;
					goto default;
				default:
					if (eRRID == ERRID.ERR_None)
					{
						continue;
					}
					if (!IsValidBranchTarget(visualBasicSyntaxNode, labelSyntax))
					{
						ReportDiagnostic(diagnostics, labelSyntax, ErrorFactory.ErrorInfo(eRRID, label.Name));
						flag = true;
					}
					break;
				case SyntaxKind.SubBlock:
				case SyntaxKind.FunctionBlock:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
					break;
				}
				break;
			}
			return !flag;
		}

		private static bool IsValidBranchTarget(VisualBasicSyntaxNode block, Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax labelSyntax)
		{
			for (VisualBasicSyntaxNode parent = labelSyntax.Parent; parent != null; parent = parent.Parent)
			{
				if (parent == block)
				{
					return true;
				}
			}
			return false;
		}

		private BoundStatement BindLabelStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax node, BindingDiagnosticBag diagnostics)
		{
			SyntaxToken labelToken = node.LabelToken;
			string valueText = labelToken.ValueText;
			LookupResult instance = LookupResult.GetInstance();
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
			Lookup(instance, valueText, 0, LookupOptions.LabelsOnly, ref useSiteInfo);
			SourceLabelSymbol sourceLabelSymbol = (SourceLabelSymbol)instance.SingleSymbol;
			bool hasErrors = false;
			if (sourceLabelSymbol.LabelName != labelToken)
			{
				ReportDiagnostic(diagnostics, labelToken, ERRID.ERR_MultiplyDefined1, valueText);
				hasErrors = true;
			}
			instance.Free();
			return new BoundLabelStatement(node, sourceLabelSymbol, hasErrors);
		}

		private void DecodeLocalModifiersAndReportErrors(SyntaxTokenList syntax, BindingDiagnosticBag diagBag)
		{
			SourceMemberFlags sourceMemberFlags = SourceMemberFlags.None;
			SyntaxToken syntaxToken = default(SyntaxToken);
			SyntaxToken syntaxToken2 = default(SyntaxToken);
			SyntaxTokenList.Enumerator enumerator = syntax.GetEnumerator();
			while (enumerator.MoveNext())
			{
				SyntaxToken current = enumerator.Current;
				SourceMemberFlags sourceMemberFlags2 = MapKeywordToFlag(current);
				if (sourceMemberFlags2 == SourceMemberFlags.None)
				{
					continue;
				}
				if ((sourceMemberFlags2 & (SourceMemberFlags.Dim | SourceMemberFlags.Const | SourceMemberFlags.Static)) == 0)
				{
					ReportDiagnostic(diagBag, current, ERRID.ERR_BadLocalDimFlags1, current.ToString());
					continue;
				}
				if ((sourceMemberFlags2 & sourceMemberFlags) != 0)
				{
					ReportDiagnostic(diagBag, current, ERRID.ERR_DuplicateSpecifier);
					continue;
				}
				switch (sourceMemberFlags2)
				{
				case SourceMemberFlags.Dim:
					syntaxToken = current;
					break;
				case SourceMemberFlags.Static:
					syntaxToken2 = current;
					break;
				}
				sourceMemberFlags |= sourceMemberFlags2;
			}
			if ((sourceMemberFlags & SourceMemberFlags.Const) != 0)
			{
				if ((sourceMemberFlags & SourceMemberFlags.Dim) != 0)
				{
					ReportDiagnostic(diagBag, syntaxToken, ERRID.ERR_BadLocalConstFlags1, syntaxToken.ToString());
				}
				else if ((sourceMemberFlags & SourceMemberFlags.Static) != 0)
				{
					ReportDiagnostic(diagBag, syntaxToken2, ERRID.ERR_BadLocalConstFlags1, syntaxToken2.ToString());
				}
			}
			else if ((sourceMemberFlags & SourceMemberFlags.Static) != 0)
			{
				if ((object)ContainingType != null && ContainingType.TypeKind == TypeKind.Struct)
				{
					ReportDiagnostic(diagBag, syntaxToken2, ERRID.ERR_BadStaticLocalInStruct);
				}
				else if (IsInLambda)
				{
					ReportDiagnostic(diagBag, syntaxToken2, ERRID.ERR_StaticInLambda);
				}
				else if (ContainingMember.Kind == SymbolKind.Method && ((MethodSymbol)ContainingMember).IsGenericMethod)
				{
					ReportDiagnostic(diagBag, syntaxToken2, ERRID.ERR_BadStaticLocalInGenericMethod);
				}
			}
		}

		private BoundStatement BindLocalDeclaration(Microsoft.CodeAnalysis.VisualBasic.Syntax.LocalDeclarationStatementSyntax node, BindingDiagnosticBag diagnostics)
		{
			DecodeLocalModifiersAndReportErrors(node.Modifiers, diagnostics);
			ImmutableArray<BoundLocalDeclarationBase> localDeclarations = BindVariableDeclarators(node.Declarators, diagnostics);
			return new BoundDimStatement(node, localDeclarations, null);
		}

		private ImmutableArray<BoundLocalDeclarationBase> BindVariableDeclarators(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax> declarators, BindingDiagnosticBag diagnostics)
		{
			ArrayBuilder<BoundLocalDeclarationBase> instance = ArrayBuilder<BoundLocalDeclarationBase>.GetInstance();
			SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax>.Enumerator enumerator = declarators.GetEnumerator();
			while (enumerator.MoveNext())
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax current = enumerator.Current;
				Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClause = current.AsClause;
				Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax initializer = current.Initializer;
				if (initializer != null && current.Names.Count > 1)
				{
					ReportDiagnostic(diagnostics, current, ERRID.ERR_InitWithMultipleDeclarators);
				}
				SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax> names = current.Names;
				if (names.Count == 1)
				{
					instance.Add(BindVariableDeclaration(current, names[0], asClause, initializer, diagnostics));
					continue;
				}
				if (asClause == null || asClause.Kind() != SyntaxKind.AsNewClause)
				{
					int num = names.Count - 1;
					for (int i = 0; i <= num; i++)
					{
						BoundLocalDeclaration item = BindVariableDeclaration(current, names[i], asClause, (i == names.Count - 1) ? initializer : null, diagnostics);
						instance.Add(item);
					}
					continue;
				}
				int count = names.Count;
				ArrayBuilder<BoundLocalDeclaration> instance2 = ArrayBuilder<BoundLocalDeclaration>.GetInstance(count);
				int num2 = count - 1;
				for (int j = 0; j <= num2; j++)
				{
					BoundLocalDeclaration item2 = BindVariableDeclaration(current, names[j], asClause, null, diagnostics, j > 0);
					instance2.Add(item2);
				}
				BoundLocalDeclaration boundLocalDeclaration = instance2[0];
				BoundExpression initializerOpt = boundLocalDeclaration.InitializerOpt;
				instance2[0] = boundLocalDeclaration.Update(boundLocalDeclaration.LocalSymbol, null, boundLocalDeclaration.IdentifierInitializerOpt, initializedByAsNew: true);
				instance.Add(new BoundAsNewLocalDeclarations(current, instance2.ToImmutableAndFree(), initializerOpt));
			}
			return instance.ToImmutableAndFree();
		}

		private LocalSymbol GetLocalForDeclaration(SyntaxToken identifier)
		{
			Binder binder = this;
			BlockBaseBinder blockBaseBinder;
			while (true)
			{
				blockBaseBinder = binder as BlockBaseBinder;
				if (blockBaseBinder != null)
				{
					break;
				}
				binder = binder.ContainingBinder;
			}
			ImmutableArray<LocalSymbol>.Enumerator enumerator = blockBaseBinder.Locals.GetEnumerator();
			while (enumerator.MoveNext())
			{
				LocalSymbol current = enumerator.Current;
				if (current.IdentifierToken == identifier)
				{
					return current;
				}
			}
			throw ExceptionUtilities.Unreachable;
		}

		internal virtual BoundLocalDeclaration BindVariableDeclaration(VisualBasicSyntaxNode tree, Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax name, Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClauseOpt, Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax equalsValueOpt, BindingDiagnosticBag diagnostics, bool skipAsNewInitializer = false)
		{
			LocalSymbol localForDeclaration = GetLocalForDeclaration(name.Identifier);
			BoundExpression valueExpression = null;
			TypeSymbol asClauseType = null;
			ImmutableArray<BoundExpression> bounds = default(ImmutableArray<BoundExpression>);
			if (name.ArrayBounds != null)
			{
				bounds = BindArrayBounds(name.ArrayBounds, diagnostics);
			}
			TypeSymbol typeSymbol = ComputeVariableType(localForDeclaration, name, asClauseOpt, equalsValueOpt, out valueExpression, out asClauseType, diagnostics);
			VerifyLocalSymbolNameAndSetType(localForDeclaration, typeSymbol, name, name.Identifier, diagnostics);
			bool flag = asClauseOpt != null && asClauseOpt.Kind() == SyntaxKind.AsNewClause;
			VisualBasicSyntaxNode visualBasicSyntaxNode = ((asClauseOpt == null) ? ((VisualBasicSyntaxNode)equalsValueOpt) : ((VisualBasicSyntaxNode)SyntaxExtensions.Type(asClauseOpt)));
			TypeSymbol restrictedType = null;
			if (TypeSymbolExtensions.IsRestrictedArrayType(typeSymbol, out restrictedType))
			{
				if (!flag || !skipAsNewInitializer)
				{
					ReportDiagnostic(diagnostics, visualBasicSyntaxNode, ERRID.ERR_RestrictedType1, restrictedType);
				}
			}
			else if (localForDeclaration.IsStatic)
			{
				if (TypeSymbolExtensions.IsRestrictedType(typeSymbol))
				{
					if (!flag || !skipAsNewInitializer)
					{
						ReportDiagnostic(diagnostics, visualBasicSyntaxNode, ERRID.ERR_RestrictedType1, typeSymbol);
					}
				}
				else if (IsInAsyncContext() || IsInIteratorContext())
				{
					ReportDiagnostic(diagnostics, name, ERRID.ERR_BadStaticInitializerInResumable);
				}
			}
			else if ((IsInAsyncContext() || IsInIteratorContext()) && TypeSymbolExtensions.IsRestrictedType(typeSymbol) && (!flag || !skipAsNewInitializer))
			{
				ReportDiagnostic(diagnostics, visualBasicSyntaxNode, ERRID.ERR_CannotLiftRestrictedTypeResumable1, typeSymbol);
			}
			if (valueExpression == null)
			{
				if (localForDeclaration.IsConst)
				{
					valueExpression = localForDeclaration.GetConstantExpression(this);
				}
				else if (equalsValueOpt != null)
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value = equalsValueOpt.Value;
					valueExpression = BindValue(value, diagnostics);
				}
			}
			if (valueExpression != null && !localForDeclaration.IsConst)
			{
				valueExpression = ApplyImplicitConversion(valueExpression.Syntax, typeSymbol, valueExpression, diagnostics);
			}
			if (flag)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax asNewClauseSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax)asClauseOpt;
				if (localForDeclaration.IsConst)
				{
					ReportDiagnostic(diagnostics, asNewClauseSyntax.NewExpression.NewKeyword, ERRID.ERR_BadLocalConstFlags1, asNewClauseSyntax.NewExpression.NewKeyword.ToString());
				}
				else
				{
					switch (asNewClauseSyntax.NewExpression.Kind())
					{
					case SyntaxKind.ObjectCreationExpression:
						if (!skipAsNewInitializer)
						{
							DisallowNewOnTupleType(SyntaxExtensions.Type(asNewClauseSyntax), diagnostics);
							Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax objectCreationExpressionSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax)asNewClauseSyntax.NewExpression;
							BoundWithLValueExpressionPlaceholder boundWithLValueExpressionPlaceholder = new BoundWithLValueExpressionPlaceholder(asClauseOpt, localForDeclaration.Type);
							boundWithLValueExpressionPlaceholder.SetWasCompilerGenerated();
							valueExpression = BindObjectCreationExpression(SyntaxExtensions.Type(asNewClauseSyntax), objectCreationExpressionSyntax.ArgumentList, asClauseType, objectCreationExpressionSyntax, diagnostics, boundWithLValueExpressionPlaceholder);
						}
						break;
					default:
						throw ExceptionUtilities.UnexpectedValue(asNewClauseSyntax.NewExpression.Kind());
					case SyntaxKind.AnonymousObjectCreationExpression:
						break;
					}
					if (TypeSymbolExtensions.IsArrayType(typeSymbol))
					{
						ReportDiagnostic(diagnostics, asNewClauseSyntax.NewExpression.NewKeyword, ERRID.ERR_AsNewArray);
						valueExpression = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(asNewClauseSyntax, valueExpression, typeSymbol));
					}
					else if (valueExpression != null && !valueExpression.HasErrors && !TypeSymbolExtensions.IsSameTypeIgnoringAll(typeSymbol, valueExpression.Type))
					{
						valueExpression = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(asNewClauseSyntax, valueExpression, valueExpression.Type));
					}
				}
			}
			BoundArrayCreation identifierInitializerOpt = null;
			if (name.ArrayBounds != null)
			{
				identifierInitializerOpt = BoundNodeExtensions.MakeCompilerGenerated(new BoundArrayCreation(name, bounds, null, typeSymbol));
				if (valueExpression != null && !flag)
				{
					ReportDiagnostic(diagnostics, name, ERRID.ERR_InitWithExplicitArraySizes);
				}
			}
			if (localForDeclaration.IsConst && !TypeSymbolExtensions.IsErrorType(typeSymbol))
			{
				if (!TypeSymbolExtensions.IsValidTypeForConstField(typeSymbol))
				{
					visualBasicSyntaxNode = ((asClauseOpt != null && !TypeSymbolExtensions.IsArrayType(typeSymbol)) ? ((VisualBasicSyntaxNode)SyntaxExtensions.Type(asClauseOpt)) : ((VisualBasicSyntaxNode)name));
					ReportDiagnostic(diagnostics, visualBasicSyntaxNode, ERRID.ERR_ConstAsNonConstant);
				}
				else
				{
					BindingDiagnosticBag constantValueDiagnostics = localForDeclaration.GetConstantValueDiagnostics(this);
					if (constantValueDiagnostics != null)
					{
						diagnostics.AddRange(constantValueDiagnostics, allowMismatchInDependencyAccumulation: true);
					}
				}
			}
			return new BoundLocalDeclaration(name, localForDeclaration, valueExpression, identifierInitializerOpt, flag);
		}

		internal TypeSymbol ComputeVariableType(LocalSymbol symbol, Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax modifiedIdentifierOpt, Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClauseOpt, Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax equalsValueOpt, out BoundExpression valueExpression, out TypeSymbol asClauseType, BindingDiagnosticBag diagnostics)
		{
			valueExpression = null;
			Func<DiagnosticInfo> getRequireTypeDiagnosticInfoFunc = null;
			if (symbol.IsStatic)
			{
				if (OptionStrict == OptionStrict.On)
				{
					getRequireTypeDiagnosticInfoFunc = ErrorFactory.GetErrorInfo_ERR_StrictDisallowImplicitObject;
				}
				else if (OptionStrict == OptionStrict.Custom)
				{
					getRequireTypeDiagnosticInfoFunc = ErrorFactory.GetErrorInfo_WRN_ObjectAssumedVar1_WRN_StaticLocalNoInference;
				}
			}
			else if (!OptionInfer || equalsValueOpt == null)
			{
				if (OptionStrict == OptionStrict.On)
				{
					getRequireTypeDiagnosticInfoFunc = ErrorFactory.GetErrorInfo_ERR_StrictDisallowImplicitObject;
				}
				else if (OptionStrict == OptionStrict.Custom)
				{
					getRequireTypeDiagnosticInfoFunc = ErrorFactory.GetErrorInfo_WRN_ObjectAssumedVar1_WRN_MissingAsClauseinVarDecl;
				}
			}
			TypeSymbol typeSymbol;
			bool flag;
			if (modifiedIdentifierOpt != null)
			{
				if (asClauseOpt != null && asClauseOpt.Kind() == SyntaxKind.AsNewClause)
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax newExpression = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax)asClauseOpt).NewExpression;
					if (newExpression.Kind() == SyntaxKind.AnonymousObjectCreationExpression)
					{
						LocalInProgressBinder localInProgressBinder = new LocalInProgressBinder(this, symbol);
						valueExpression = localInProgressBinder.BindAnonymousObjectCreationExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax)newExpression, diagnostics);
						asClauseType = valueExpression.Type;
						return asClauseType;
					}
				}
				typeSymbol = DecodeModifiedIdentifierType(modifiedIdentifierOpt, asClauseOpt, equalsValueOpt, getRequireTypeDiagnosticInfoFunc, out asClauseType, diagnostics, symbol.IsStatic ? (ModifiedIdentifierTypeDecoderContext.LocalType | ModifiedIdentifierTypeDecoderContext.StaticLocalType) : ModifiedIdentifierTypeDecoderContext.LocalType);
				flag = !HasDefaultType(modifiedIdentifierOpt, asClauseOpt);
			}
			else
			{
				SyntaxToken identifierToken = symbol.IdentifierToken;
				typeSymbol = DecodeIdentifierType(identifierToken, asClauseOpt, getRequireTypeDiagnosticInfoFunc, ref asClauseType, diagnostics);
				flag = !HasDefaultType(identifierToken, asClauseOpt);
			}
			if (flag && (!symbol.IsConst || typeSymbol.SpecialType != SpecialType.System_Object))
			{
				return typeSymbol;
			}
			if (OptionInfer && !symbol.IsStatic && !symbol.IsConst)
			{
				if (equalsValueOpt != null)
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value = equalsValueOpt.Value;
					LocalInProgressBinder localInProgressBinder2 = new LocalInProgressBinder(this, symbol);
					valueExpression = localInProgressBinder2.BindValue(value, diagnostics);
					BoundExpression boundExpression = valueExpression;
					if (!BoundExpressionExtensions.IsNothingLiteral(boundExpression))
					{
						boundExpression = BoundExpressionExtensions.GetMostEnclosedParenthesizedExpression(boundExpression);
					}
					TypeSymbol typeSymbol2 = null;
					BoundArrayLiteral boundArrayLiteral = null;
					switch (boundExpression.Kind)
					{
					case BoundKind.UnboundLambda:
						typeSymbol2 = ((UnboundLambda)boundExpression).InferredAnonymousDelegate.Key;
						break;
					case BoundKind.ArrayLiteral:
						boundArrayLiteral = (BoundArrayLiteral)boundExpression;
						typeSymbol2 = boundArrayLiteral.InferredType;
						break;
					case BoundKind.TupleLiteral:
						typeSymbol2 = ((BoundTupleLiteral)boundExpression).InferredType;
						break;
					default:
						typeSymbol2 = boundExpression.Type;
						break;
					}
					if ((object)typeSymbol2 != null)
					{
						BindingDiagnosticBag diagnostics2 = (boundExpression.HasErrors ? BindingDiagnosticBag.Discarded : diagnostics);
						if (modifiedIdentifierOpt != null)
						{
							typeSymbol = InferVariableType(typeSymbol, modifiedIdentifierOpt, value, typeSymbol2, boundExpression, getRequireTypeDiagnosticInfoFunc, diagnostics2);
							if ((object)typeSymbol != typeSymbol2 && boundArrayLiteral != null)
							{
								ReportArrayLiteralInferredTypeDiagnostics(boundArrayLiteral, diagnostics2);
							}
						}
						else
						{
							typeSymbol = typeSymbol2;
						}
					}
				}
			}
			else if (symbol.IsConst)
			{
				valueExpression = symbol.GetConstantExpression(this);
				TypeSymbol type = valueExpression.Type;
				if ((object)type != null && TypeSymbolExtensions.IsIntrinsicType(TypeSymbolExtensions.GetEnumUnderlyingTypeOrSelf(type)))
				{
					typeSymbol = valueExpression.Type;
				}
			}
			else if (!symbol.IsStatic && OptionStrict != OptionStrict.On && !flag && TypeSymbolExtensions.IsObjectType(typeSymbol) && modifiedIdentifierOpt != null && modifiedIdentifierOpt.Nullable.Node != null && equalsValueOpt != null)
			{
				ReportDiagnostic(diagnostics, modifiedIdentifierOpt, ERRID.ERR_NullableTypeInferenceNotSupported);
			}
			return typeSymbol;
		}

		internal TypeSymbol InferForFromToVariableType(LocalSymbol symbol, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax fromValueSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax toValueSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax stepClauseSyntaxOpt, out BoundExpression fromValueExpression, out BoundExpression toValueExpression, out BoundExpression stepValueExpression, BindingDiagnosticBag diagnostics)
		{
			fromValueExpression = null;
			toValueExpression = null;
			stepValueExpression = null;
			SyntaxToken identifierToken = symbol.IdentifierToken;
			SyntaxToken identifier = identifierToken;
			TypeSymbol asClauseType = null;
			TypeSymbol result = DecodeIdentifierType(identifier, null, null, ref asClauseType, diagnostics);
			if (!HasDefaultType(identifierToken, null))
			{
				return result;
			}
			LocalInProgressBinder localInProgressBinder = new LocalInProgressBinder(this, symbol);
			fromValueExpression = localInProgressBinder.BindRValue(fromValueSyntax, diagnostics);
			toValueExpression = localInProgressBinder.BindRValue(toValueSyntax, diagnostics);
			if (stepClauseSyntaxOpt != null)
			{
				stepValueExpression = localInProgressBinder.BindRValue(stepClauseSyntaxOpt.StepValue, diagnostics);
			}
			if (toValueExpression.HasErrors || fromValueExpression.HasErrors || (stepValueExpression != null && stepValueExpression.HasErrors))
			{
				return result;
			}
			int numCandidates = 0;
			ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance(2);
			instance.Add(fromValueExpression);
			instance.Add(toValueExpression);
			if (stepValueExpression != null)
			{
				instance.Add(stepValueExpression);
			}
			Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax identifierNameSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)identifierToken.Parent;
			InferenceErrorReasons errorReasons = InferenceErrorReasons.Other;
			TypeSymbol typeSymbol = InferDominantTypeOfExpressions(identifierNameSyntax, instance, diagnostics, ref numCandidates, ref errorReasons);
			instance.Free();
			if (numCandidates == 0 || (numCandidates > 1 && (errorReasons & InferenceErrorReasons.Ambiguous) == 0))
			{
				ReportDiagnostic(diagnostics, identifierNameSyntax, ERRID.ERR_NoSuitableWidestType1, identifierNameSyntax.Identifier.ValueText);
				return result;
			}
			if (numCandidates > 1)
			{
				ReportDiagnostic(diagnostics, identifierNameSyntax, ERRID.ERR_AmbiguousWidestType3, identifierNameSyntax.Identifier.ValueText);
				return result;
			}
			if ((object)typeSymbol != null)
			{
				return typeSymbol;
			}
			return result;
		}

		internal TypeSymbol InferForEachVariableType(LocalSymbol symbol, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax collectionSyntax, out BoundExpression collectionExpression, out TypeSymbol currentType, out TypeSymbol elementType, out bool isEnumerable, out BoundExpression boundGetEnumeratorCall, out BoundLValuePlaceholder boundEnumeratorPlaceholder, out BoundExpression boundMoveNextCall, out BoundExpression boundCurrentAccess, out BoundRValuePlaceholder collectionPlaceholder, out bool needToDispose, out bool isOrInheritsFromOrImplementsIDisposable, BindingDiagnosticBag diagnostics)
		{
			collectionExpression = null;
			currentType = null;
			elementType = null;
			isEnumerable = false;
			boundGetEnumeratorCall = null;
			boundEnumeratorPlaceholder = null;
			boundMoveNextCall = null;
			boundCurrentAccess = null;
			collectionPlaceholder = null;
			needToDispose = false;
			isOrInheritsFromOrImplementsIDisposable = false;
			SyntaxToken identifierToken = symbol.IdentifierToken;
			TypeSymbol asClauseType = null;
			TypeSymbol result = DecodeIdentifierType(identifierToken, null, null, ref asClauseType, diagnostics);
			if (!HasDefaultType(identifierToken, null))
			{
				return result;
			}
			LocalInProgressBinder localInProgressBinder = new LocalInProgressBinder(this, symbol);
			collectionExpression = localInProgressBinder.BindValue(collectionSyntax, diagnostics);
			if (!collectionExpression.IsLValue && !BoundExpressionExtensions.IsNothingLiteral(collectionExpression))
			{
				collectionExpression = MakeRValue(collectionExpression, diagnostics);
			}
			collectionExpression = InterpretForEachStatementCollection(collectionExpression, out currentType, out elementType, out isEnumerable, out boundGetEnumeratorCall, out boundEnumeratorPlaceholder, out boundMoveNextCall, out boundCurrentAccess, out collectionPlaceholder, out needToDispose, out isOrInheritsFromOrImplementsIDisposable, diagnostics);
			if ((object)elementType != null)
			{
				return elementType;
			}
			return result;
		}

		private TypeSymbol InferVariableType(TypeSymbol defaultType, Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax name, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax valueSyntax, TypeSymbol valueType, BoundExpression valueExpression, Func<DiagnosticInfo> getRequireTypeDiagnosticInfoFunc, BindingDiagnosticBag diagnostics)
		{
			bool flag = IsArrayType(name);
			bool flag2 = name.Nullable.Node != null;
			SyntaxToken identifier = name.Identifier;
			if (flag2 && TypeSymbolExtensions.IsArrayType(valueType) && !flag)
			{
				ReportDiagnostic(diagnostics, identifier, ERRID.ERR_CannotInferNullableForVariable1, name.Identifier.ToString());
			}
			else if (flag && !TypeSymbolExtensions.IsArrayType(valueType))
			{
				ReportDiagnostic(diagnostics, identifier, ERRID.ERR_InferringNonArrayType1, valueType);
			}
			else if (!flag)
			{
				if (!flag2)
				{
					return valueType;
				}
				if (valueType.IsValueType)
				{
					if (TypeSymbolExtensions.IsNullableType(valueType))
					{
						return valueType;
					}
					return DecodeModifiedIdentifierType(name, valueType, null, valueSyntax, getRequireTypeDiagnosticInfoFunc, diagnostics);
				}
				ReportDiagnostic(diagnostics, identifier, ERRID.ERR_CannotInferNullableForVariable1, identifier.ToString());
			}
			else
			{
				if (flag2)
				{
					TypeSymbol elementType = ((ArrayTypeSymbol)valueType).ElementType;
					while (TypeSymbolExtensions.IsArrayType(elementType))
					{
						elementType = ((ArrayTypeSymbol)elementType).ElementType;
					}
					if (!TypeSymbolExtensions.IsNullableType(elementType))
					{
						ReportDiagnostic(diagnostics, identifier, ERRID.ERR_CannotInferNullableForVariable1, identifier.ToString());
						return defaultType;
					}
				}
				if (((ArrayTypeSymbol)defaultType).Rank == ((ArrayTypeSymbol)valueType).Rank)
				{
					TypeSymbol typeSymbol = defaultType;
					TypeSymbol typeSymbol2 = valueType;
					while (true)
					{
						if (TypeSymbolExtensions.IsArrayType(typeSymbol) && TypeSymbolExtensions.IsArrayType(typeSymbol2))
						{
							ArrayTypeSymbol arrayTypeSymbol = (ArrayTypeSymbol)typeSymbol;
							ArrayTypeSymbol arrayTypeSymbol2 = (ArrayTypeSymbol)typeSymbol2;
							if (arrayTypeSymbol.Rank != arrayTypeSymbol2.Rank)
							{
								break;
							}
							typeSymbol = arrayTypeSymbol.ElementType;
							typeSymbol2 = arrayTypeSymbol2.ElementType;
							continue;
						}
						if (!TypeSymbolExtensions.IsArrayType(typeSymbol2) && TypeSymbolExtensions.IsArrayType(typeSymbol))
						{
							break;
						}
						return valueType;
					}
					return DecodeModifiedIdentifierType(name, typeSymbol2, null, valueSyntax, getRequireTypeDiagnosticInfoFunc, diagnostics);
				}
				if (!(valueExpression is BoundArrayLiteral boundArrayLiteral) || !boundArrayLiteral.IsEmptyArrayLiteral)
				{
					ReportDiagnostic(diagnostics, name, ERRID.ERR_TypeInferenceArrayRankMismatch1, name.Identifier.ToString());
				}
			}
			return defaultType;
		}

		internal virtual BoundLocal BindCatchVariableDeclaration(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax name, Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClause, BindingDiagnosticBag diagnostics)
		{
			SyntaxToken identifier = name.Identifier;
			LocalSymbol localForDeclaration = GetLocalForDeclaration(identifier);
			TypeSymbol type = BindTypeSyntax(SyntaxExtensions.Type(asClause), diagnostics);
			VerifyLocalSymbolNameAndSetType(localForDeclaration, type, name, identifier, diagnostics);
			return new BoundLocal(name, localForDeclaration, localForDeclaration.Type);
		}

		private void VerifyLocalSymbolNameAndSetType(LocalSymbol local, TypeSymbol type, VisualBasicSyntaxNode nameSyntax, SyntaxToken identifier, BindingDiagnosticBag diagnostics)
		{
			LocalSymbol localForFunctionValue = GetLocalForFunctionValue();
			string valueText = identifier.ValueText;
			local.SetType(type);
			if ((object)localForFunctionValue != null && CaseInsensitiveComparison.Equals(local.Name, localForFunctionValue.Name))
			{
				ReportDiagnostic(diagnostics, nameSyntax, ERRID.ERR_LocalSameAsFunc);
				return;
			}
			LookupResult instance = LookupResult.GetInstance();
			string valueText2 = identifier.ValueText;
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
			Lookup(instance, valueText2, 0, LookupOptions.Default, ref useSiteInfo);
			LocalSymbol localSymbol = (LocalSymbol)instance.SingleSymbol;
			instance.Free();
			if (localSymbol.IdentifierToken.FullSpan != identifier.FullSpan)
			{
				if (localSymbol.CanBeReferencedByName && (!localSymbol.IsStatic || !local.IsStatic))
				{
					ReportDiagnostic(diagnostics, nameSyntax, ERRID.ERR_DuplicateLocals1, valueText);
				}
			}
			else
			{
				ContainingBinder?.VerifyNameShadowingInMethodBody(local, nameSyntax, identifier, diagnostics);
			}
		}

		private void VerifyNameShadowingInMethodBody(Symbol symbol, SyntaxNodeOrToken nameSyntax, SyntaxNodeOrToken identifier, BindingDiagnosticBag diagnostics)
		{
			string name = symbol.Name;
			Binder binder = this;
			LookupResult instance = LookupResult.GetInstance();
			while (!(binder is NamedTypeBinder))
			{
				instance.Clear();
				Binder binder2 = binder;
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
				binder2.LookupInSingleBinder(instance, name, 0, LookupOptions.Default, this, ref useSiteInfo);
				if (instance.HasSingleSymbol)
				{
					Symbol singleSymbol = instance.SingleSymbol;
					if ((object)singleSymbol == symbol)
					{
						break;
					}
					switch (singleSymbol.Kind)
					{
					case SymbolKind.Local:
					case SymbolKind.RangeVariable:
					{
						ERRID id = ((symbol.Kind == SymbolKind.Parameter) ? ERRID.ERR_LambdaParamShadowLocal1 : ((symbol.Kind != SymbolKind.RangeVariable) ? ERRID.ERR_BlockLocalShadowing1 : ((!ImplicitVariableDeclarationAllowed) ? ERRID.ERR_IterationVariableShadowLocal1 : ERRID.ERR_IterationVariableShadowLocal2)));
						ReportDiagnostic(diagnostics, nameSyntax, id, name);
						break;
					}
					case SymbolKind.Parameter:
					{
						ERRID id = ((symbol.Kind == SymbolKind.Parameter) ? ERRID.ERR_LambdaParamShadowLocal1 : ((symbol.Kind != SymbolKind.RangeVariable) ? ((((MethodSymbol)singleSymbol.ContainingSymbol).MethodKind != 0) ? ERRID.ERR_LocalNamedSameAsParam1 : ERRID.ERR_LocalNamedSameAsParamInLambda1) : ((!ImplicitVariableDeclarationAllowed) ? ERRID.ERR_IterationVariableShadowLocal1 : ERRID.ERR_IterationVariableShadowLocal2)));
						ReportDiagnostic(diagnostics, nameSyntax, id, name);
						break;
					}
					case SymbolKind.TypeParameter:
						if (!(symbol is LocalSymbol localSymbol) || (!localSymbol.IsFor && !localSymbol.IsForEach) || !localSymbol.HasInferredType)
						{
							ReportDiagnostic(diagnostics, nameSyntax, ERRID.ERR_NameSameAsMethodTypeParam1, name);
						}
						break;
					}
					break;
				}
				if (binder is ImplicitVariableBinder implicitVariableBinder && !implicitVariableBinder.AllImplicitVariableDeclarationsAreHandled)
				{
					ERRID id = ((symbol.Kind == SymbolKind.Parameter) ? ERRID.ERR_LambdaParamShadowLocal1 : ((symbol.Kind == SymbolKind.RangeVariable) ? ERRID.ERR_IterationVariableShadowLocal2 : ERRID.ERR_BlockLocalShadowing1));
					implicitVariableBinder.RememberPossibleShadowingVariable(name, identifier, id);
				}
				binder = binder.ContainingBinder;
				if (binder == null)
				{
					break;
				}
			}
			instance.Free();
		}

		internal BoundExpression AdjustAssignmentTarget(SyntaxNode node, BoundExpression op1, BindingDiagnosticBag diagnostics, ref bool isError)
		{
			switch (op1.Kind)
			{
			case BoundKind.XmlMemberAccess:
			{
				BoundXmlMemberAccess boundXmlMemberAccess = (BoundXmlMemberAccess)op1;
				BoundExpression memberAccess = AdjustAssignmentTarget(node, boundXmlMemberAccess.MemberAccess, diagnostics, ref isError);
				return BoundExpressionExtensions.Update(boundXmlMemberAccess, memberAccess);
			}
			case BoundKind.PropertyAccess:
			{
				BoundPropertyAccess boundPropertyAccess = (BoundPropertyAccess)op1;
				PropertySymbol propertySymbol = boundPropertyAccess.PropertySymbol;
				if (boundPropertyAccess.IsLValue)
				{
					WarnOnRecursiveAccess(boundPropertyAccess, PropertyAccessKind.Get, diagnostics);
					return boundPropertyAccess.SetAccessKind(PropertyAccessKind.Get);
				}
				MethodSymbol mostDerivedSetMethod = propertySymbol.GetMostDerivedSetMethod();
				if (!boundPropertyAccess.IsWriteable)
				{
					if ((object)mostDerivedSetMethod == null)
					{
						ReportDiagnostic(diagnostics, node, ERRID.ERR_NoSetProperty1, CustomSymbolDisplayFormatter.ShortErrorName(propertySymbol));
					}
					else
					{
						ReportDiagnostic(diagnostics, node, ERRID.ERR_AssignmentInitOnly, CustomSymbolDisplayFormatter.ShortErrorName(propertySymbol));
					}
					isError = true;
				}
				if ((object)mostDerivedSetMethod != null)
				{
					if (boundPropertyAccess.IsWriteable && mostDerivedSetMethod.IsInitOnly)
					{
						Parser.CheckFeatureAvailability(diagnostics, node.Location, ((VisualBasicParseOptions)node.SyntaxTree.Options).LanguageVersion, Feature.InitOnlySettersUsage);
					}
					ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagnostics, mostDerivedSetMethod, node);
					if (ReportUseSite(diagnostics, op1.Syntax, mostDerivedSetMethod))
					{
						isError = true;
					}
					else
					{
						TypeSymbol accessThroughType = GetAccessThroughType(boundPropertyAccess.ReceiverOpt);
						CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
						if (!IsAccessible(mostDerivedSetMethod, ref useSiteInfo, accessThroughType) && IsAccessible(propertySymbol, ref useSiteInfo, accessThroughType))
						{
							ReportDiagnostic(diagnostics, node, ERRID.ERR_NoAccessibleSet, CustomSymbolDisplayFormatter.ShortErrorName(propertySymbol));
							isError = true;
						}
						((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(node, useSiteInfo);
					}
				}
				WarnOnRecursiveAccess(boundPropertyAccess, PropertyAccessKind.Set, diagnostics);
				return boundPropertyAccess.SetAccessKind(PropertyAccessKind.Set);
			}
			case BoundKind.LateMemberAccess:
				return ((BoundLateMemberAccess)op1).SetAccessKind(LateBoundAccessKind.Set);
			case BoundKind.LateInvocation:
				return ((BoundLateInvocation)op1).SetAccessKind(LateBoundAccessKind.Set);
			default:
				return op1;
			}
		}

		private BoundAssignmentOperator BindAssignment(SyntaxNode node, BoundExpression op1, BoundExpression op2, BindingDiagnosticBag diagnostics)
		{
			bool isError = false;
			op1 = AdjustAssignmentTarget(node, op1, diagnostics, ref isError);
			TypeSymbol type = op1.Type;
			op2 = (((object)type == null) ? MakeRValueAndIgnoreDiagnostics(op2) : ApplyImplicitConversion(op2.Syntax, type, op2, diagnostics));
			return new BoundAssignmentOperator(node, op1, op2, suppressObjectClone: false, isError);
		}

		private BoundAssignmentOperator BindCompoundAssignment(VisualBasicSyntaxNode node, BoundExpression left, BoundExpression right, SyntaxKind operatorTokenKind, BinaryOperatorKind operatorKind, BindingDiagnosticBag diagnostics)
		{
			bool isError = false;
			BoundExpression boundExpression = AdjustAssignmentTarget(node, left, diagnostics, ref isError);
			if (isError)
			{
				MakeRValueAndIgnoreDiagnostics(left);
			}
			else
			{
				isError = MakeRValue(left, diagnostics).HasErrors;
			}
			TypeSymbol type = boundExpression.Type;
			BoundCompoundAssignmentTargetPlaceholder boundCompoundAssignmentTargetPlaceholder = null;
			if (isError)
			{
				diagnostics = BindingDiagnosticBag.Discarded;
			}
			boundCompoundAssignmentTargetPlaceholder = BoundNodeExtensions.MakeCompilerGenerated(new BoundCompoundAssignmentTargetPlaceholder(left.Syntax, type));
			right = BindBinaryOperator(node, boundCompoundAssignmentTargetPlaceholder, right, operatorTokenKind, operatorKind, isOperandOfConditionalBranch: false, diagnostics);
			right.SetWasCompilerGenerated();
			right = ApplyImplicitConversion(node, type, right, diagnostics);
			left = BoundExpressionExtensions.SetGetSetAccessKindIfAppropriate(left);
			return new BoundAssignmentOperator(node, left, boundCompoundAssignmentTargetPlaceholder, right, suppressObjectClone: false, isError);
		}

		internal BoundBlock BindBlock(SyntaxNode syntax, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> stmtList, BindingDiagnosticBag diagnostics)
		{
			Binder binder = GetBinder(stmtList);
			return BindBlock(syntax, stmtList, diagnostics, binder);
		}

		internal BoundBlock BindBlock(SyntaxNode syntax, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> stmtList, BindingDiagnosticBag diagnostics, Binder stmtListBinder)
		{
			BoundStatement[] array = new BoundStatement[stmtList.Count - 1 + 1];
			ArrayBuilder<LocalSymbol> locals = null;
			int num = array.Length - 1;
			for (int i = 0; i <= num; i++)
			{
				BoundStatement boundStatement = (array[i] = stmtListBinder.BindStatement(stmtList[i], diagnostics));
				switch (boundStatement.Kind)
				{
				case BoundKind.LocalDeclaration:
				{
					BoundLocalDeclaration localDecl = (BoundLocalDeclaration)boundStatement;
					DeclareLocal(ref locals, localDecl);
					break;
				}
				case BoundKind.AsNewLocalDeclarations:
				{
					BoundAsNewLocalDeclarations localDecl2 = (BoundAsNewLocalDeclarations)boundStatement;
					DeclareLocal(ref locals, localDecl2);
					break;
				}
				case BoundKind.DimStatement:
				{
					ImmutableArray<BoundLocalDeclarationBase>.Enumerator enumerator = ((BoundDimStatement)boundStatement).LocalDeclarations.GetEnumerator();
					while (enumerator.MoveNext())
					{
						BoundLocalDeclarationBase current = enumerator.Current;
						DeclareLocal(ref locals, current);
					}
					break;
				}
				}
			}
			if (locals == null)
			{
				return new BoundBlock(syntax, stmtList, ImmutableArray<LocalSymbol>.Empty, array.AsImmutableOrNull());
			}
			return new BoundBlock(syntax, stmtList, locals.ToImmutableAndFree(), array.AsImmutableOrNull());
		}

		private static void DeclareLocal(ref ArrayBuilder<LocalSymbol> locals, BoundLocalDeclarationBase localDecl)
		{
			if (locals == null)
			{
				locals = ArrayBuilder<LocalSymbol>.GetInstance();
			}
			switch (localDecl.Kind)
			{
			case BoundKind.LocalDeclaration:
				locals.Add(((BoundLocalDeclaration)localDecl).LocalSymbol);
				break;
			case BoundKind.AsNewLocalDeclarations:
			{
				ImmutableArray<BoundLocalDeclaration>.Enumerator enumerator = ((BoundAsNewLocalDeclarations)localDecl).LocalDeclarations.GetEnumerator();
				while (enumerator.MoveNext())
				{
					BoundLocalDeclaration current = enumerator.Current;
					locals.Add(current.LocalSymbol);
				}
				break;
			}
			default:
				throw ExceptionUtilities.UnexpectedValue(localDecl.Kind);
			}
		}

		private BoundExpressionStatement BindAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax node, BindingDiagnosticBag diagnostics)
		{
			BoundExpression boundExpression = BindAssignmentTarget(node.Left, diagnostics);
			BoundExpression boundExpression2 = BindValue(node.Right, diagnostics);
			BoundAssignmentOperator @this;
			if (boundExpression.HasErrors || boundExpression2.HasErrors)
			{
				if (!boundExpression.HasErrors && node.Kind() == SyntaxKind.SimpleAssignmentStatement)
				{
					@this = new BoundAssignmentOperator(node, boundExpression, ApplyImplicitConversion(node.Right, boundExpression.Type, boundExpression2, diagnostics), suppressObjectClone: false, boundExpression.Type, hasErrors: true);
				}
				else
				{
					boundExpression2 = MakeRValueAndIgnoreDiagnostics(boundExpression2);
					@this = new BoundAssignmentOperator(node, boundExpression, boundExpression2, suppressObjectClone: false, boundExpression.Type, hasErrors: true);
				}
			}
			else if (node.Kind() == SyntaxKind.SimpleAssignmentStatement)
			{
				@this = BindAssignment(node, boundExpression, boundExpression2, diagnostics);
			}
			else
			{
				BinaryOperatorKind operatorKind;
				SyntaxKind operatorTokenKind;
				switch (node.Kind())
				{
				case SyntaxKind.AddAssignmentStatement:
					operatorKind = BinaryOperatorKind.Add;
					operatorTokenKind = SyntaxKind.PlusToken;
					break;
				case SyntaxKind.SubtractAssignmentStatement:
					operatorKind = BinaryOperatorKind.Subtract;
					operatorTokenKind = SyntaxKind.MinusToken;
					break;
				case SyntaxKind.MultiplyAssignmentStatement:
					operatorKind = BinaryOperatorKind.Multiply;
					operatorTokenKind = SyntaxKind.AsteriskToken;
					break;
				case SyntaxKind.DivideAssignmentStatement:
					operatorKind = BinaryOperatorKind.Divide;
					operatorTokenKind = SyntaxKind.SlashToken;
					break;
				case SyntaxKind.IntegerDivideAssignmentStatement:
					operatorKind = BinaryOperatorKind.IntegerDivide;
					operatorTokenKind = SyntaxKind.BackslashToken;
					break;
				case SyntaxKind.ExponentiateAssignmentStatement:
					operatorKind = BinaryOperatorKind.Power;
					operatorTokenKind = SyntaxKind.CaretToken;
					break;
				case SyntaxKind.LeftShiftAssignmentStatement:
					operatorKind = BinaryOperatorKind.LeftShift;
					operatorTokenKind = SyntaxKind.LessThanLessThanToken;
					break;
				case SyntaxKind.RightShiftAssignmentStatement:
					operatorKind = BinaryOperatorKind.RightShift;
					operatorTokenKind = SyntaxKind.GreaterThanGreaterThanToken;
					break;
				case SyntaxKind.ConcatenateAssignmentStatement:
					operatorKind = BinaryOperatorKind.Concatenate;
					operatorTokenKind = SyntaxKind.AmpersandToken;
					break;
				default:
					throw ExceptionUtilities.UnexpectedValue(node.Kind());
				}
				@this = BindCompoundAssignment(node, boundExpression, boundExpression2, operatorTokenKind, operatorKind, diagnostics);
			}
			return new BoundExpressionStatement(node, BoundNodeExtensions.MakeCompilerGenerated(@this));
		}

		private BoundExpressionStatement BindMidAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax node, BindingDiagnosticBag diagnostics)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax midExpressionSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax)node.Left;
			SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax> arguments = midExpressionSyntax.ArgumentList.Arguments;
			Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax)arguments[0]).Expression;
			BoundExpression boundExpression = BindAssignmentTarget(expression, diagnostics);
			NamedTypeSymbol specialType = GetSpecialType(SpecialType.System_Int32, midExpressionSyntax, diagnostics);
			Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression2 = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax)arguments[1]).Expression;
			BoundExpression start = ApplyImplicitConversion(expression2, specialType, BindValue(expression2, diagnostics), diagnostics);
			BoundExpression lengthOpt = null;
			if (arguments.Count > 2)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression3 = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax)arguments[2]).Expression;
				lengthOpt = ApplyImplicitConversion(expression3, specialType, BindValue(expression3, diagnostics), diagnostics);
			}
			NamedTypeSymbol specialType2 = GetSpecialType(SpecialType.System_String, midExpressionSyntax, diagnostics);
			VerifyTypeCharacterConsistency(midExpressionSyntax.Mid, specialType2, VisualBasicExtensions.GetTypeCharacter(midExpressionSyntax.Mid), diagnostics);
			BoundExpression source = ApplyImplicitConversion(node.Right, specialType2, BindValue(node.Right, diagnostics), diagnostics);
			bool isError = default(bool);
			BoundExpression boundExpression2 = AdjustAssignmentTarget(expression, boundExpression, diagnostics, ref isError);
			if (!isError)
			{
				isError = MakeRValue(boundExpression, diagnostics).HasErrors;
			}
			TypeSymbol type = boundExpression2.Type;
			BoundCompoundAssignmentTargetPlaceholder boundCompoundAssignmentTargetPlaceholder;
			BoundExpression boundExpression3;
			if (!isError)
			{
				boundCompoundAssignmentTargetPlaceholder = BoundNodeExtensions.MakeCompilerGenerated(new BoundCompoundAssignmentTargetPlaceholder(expression, type));
				boundExpression3 = ApplyImplicitConversion(expression, specialType2, boundCompoundAssignmentTargetPlaceholder, diagnostics);
			}
			else
			{
				boundCompoundAssignmentTargetPlaceholder = null;
				boundExpression3 = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(expression, specialType2));
			}
			BoundExpression boundExpression4 = BoundNodeExtensions.MakeCompilerGenerated(new BoundMidResult(node, new BoundParenthesized(midExpressionSyntax, boundExpression3, boundExpression3.Type), start, lengthOpt, source, specialType2));
			if (!isError)
			{
				boundExpression4 = BoundNodeExtensions.MakeCompilerGenerated(ApplyImplicitConversion(node, type, boundExpression4, diagnostics));
			}
			boundExpression = BoundExpressionExtensions.SetGetSetAccessKindIfAppropriate(boundExpression);
			return new BoundExpressionStatement(node, BoundNodeExtensions.MakeCompilerGenerated(new BoundAssignmentOperator(node, boundExpression, boundCompoundAssignmentTargetPlaceholder, boundExpression4, suppressObjectClone: false, Compilation.GetSpecialType(SpecialType.System_Void), isError)));
		}

		private BoundAddRemoveHandlerStatement BindAddRemoveHandlerStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax node, BindingDiagnosticBag diagnostics)
		{
			EventSymbol eventSymbol = null;
			BoundEventAccess actualEventAccess = null;
			BoundExpression eventAccess = BindEventAccess(node.EventExpression, diagnostics, out actualEventAccess, out eventSymbol);
			BoundExpression boundExpression = BindValue(node.DelegateExpression, diagnostics);
			bool flag = node.Kind() == SyntaxKind.RemoveHandlerStatement;
			if (flag && BoundExpressionExtensions.GetMostEnclosedParenthesizedExpression(boundExpression).Kind == BoundKind.UnboundLambda)
			{
				ReportDiagnostic(diagnostics, node.DelegateExpression, ERRID.WRN_LambdaPassedToRemoveHandler);
			}
			bool hasErrors = true;
			if ((object)eventSymbol != null)
			{
				MethodSymbol methodSymbol = ((node.Kind() == SyntaxKind.AddHandlerStatement) ? eventSymbol.AddMethod : eventSymbol.RemoveMethod);
				if ((object)methodSymbol == null)
				{
					if (eventSymbol.DeclaringCompilation != Compilation)
					{
						ReportDiagnostic(diagnostics, node.EventExpression, ErrorFactory.ErrorInfo(ERRID.ERR_UnsupportedEvent1, eventSymbol));
					}
				}
				else
				{
					TypeSymbol type = eventSymbol.Type;
					boundExpression = ApplyImplicitConversion(node.DelegateExpression, type, boundExpression, diagnostics);
					if (flag && boundExpression.Kind == BoundKind.DelegateCreationExpression && node.DelegateExpression.Kind() == SyntaxKind.AddressOfExpression && ((BoundDelegateCreationExpression)boundExpression).RelaxationLambdaOpt != null)
					{
						Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax unaryExpressionSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax)node.DelegateExpression;
						ReportDiagnostic(diagnostics, unaryExpressionSyntax.Operand, ERRID.WRN_RelDelegatePassedToRemoveHandler);
					}
					hasErrors = false;
					if (methodSymbol == ContainingMember && (methodSymbol.IsShared || BoundExpressionExtensions.IsMeReference(actualEventAccess.ReceiverOpt)))
					{
						ReportDiagnostic(diagnostics, node, ERRID.WRN_RecursiveAddHandlerCall, node.AddHandlerOrRemoveHandlerKeyword.ToString(), eventSymbol.Name);
					}
					if (!TypeSymbolExtensions.IsDelegateType(type))
					{
						if (eventSymbol.DeclaringCompilation != Compilation && !(type is MissingMetadataTypeSymbol))
						{
							ReportDiagnostic(diagnostics, node.EventExpression, ErrorFactory.ErrorInfo(ERRID.ERR_UnsupportedEvent1, eventSymbol));
						}
						hasErrors = true;
					}
					else
					{
						CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
						TypeSymbol accessThroughType = GetAccessThroughType(actualEventAccess.ReceiverOpt);
						if (!IsAccessible(methodSymbol, ref useSiteInfo, accessThroughType))
						{
							ReportDiagnostic(diagnostics, node.EventExpression, GetInaccessibleErrorInfo(methodSymbol));
						}
						((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)node.EventExpression, useSiteInfo);
						bool flag2 = false;
						if (eventSymbol.GetUseSiteInfo().DiagnosticInfo == null && ReportUseSite(diagnostics, node.EventExpression, methodSymbol.GetUseSiteInfo()))
						{
							hasErrors = true;
						}
						else if (methodSymbol.ParameterCount != 1 || methodSymbol.Parameters[0].IsByRef)
						{
							flag2 = true;
						}
						else if (eventSymbol.IsWindowsRuntimeEvent)
						{
							NamedTypeSymbol wellKnownType = Compilation.GetWellKnownType(WellKnownType.System_Runtime_InteropServices_WindowsRuntime_EventRegistrationToken);
							if (node.Kind() == SyntaxKind.AddHandlerStatement)
							{
								if (!TypeSymbolExtensions.IsSameTypeIgnoringAll(methodSymbol.Parameters[0].Type, type) || !TypeSymbolExtensions.IsSameTypeIgnoringAll(methodSymbol.ReturnType, wellKnownType))
								{
									flag2 = true;
								}
							}
							else if (!TypeSymbolExtensions.IsSameTypeIgnoringAll(methodSymbol.Parameters[0].Type, wellKnownType) || !methodSymbol.IsSub)
							{
								flag2 = true;
							}
						}
						else if (!TypeSymbolExtensions.IsSameTypeIgnoringAll(methodSymbol.Parameters[0].Type, type))
						{
							flag2 = true;
						}
						if (flag2)
						{
							if (eventSymbol.DeclaringCompilation != Compilation)
							{
								ReportDiagnostic(diagnostics, node.EventExpression, ErrorFactory.ErrorInfo(ERRID.ERR_UnsupportedMethod1, methodSymbol));
							}
							hasErrors = true;
						}
					}
				}
			}
			if (node.Kind() == SyntaxKind.AddHandlerStatement)
			{
				return new BoundAddHandlerStatement(node, eventAccess, boundExpression, hasErrors);
			}
			return new BoundRemoveHandlerStatement(node, eventAccess, boundExpression, hasErrors);
		}

		private BoundExpression BindEventAccess(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax node, BindingDiagnosticBag diagnostics, out BoundEventAccess actualEventAccess, out EventSymbol eventSymbol)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expressionSyntax = node;
			while (expressionSyntax.Kind() == SyntaxKind.ParenthesizedExpression)
			{
				expressionSyntax = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.ParenthesizedExpressionSyntax)expressionSyntax).Expression;
			}
			Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expressionSyntax2 = expressionSyntax;
			if (expressionSyntax2.Kind() == SyntaxKind.SimpleMemberAccessExpression)
			{
				expressionSyntax2 = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax)expressionSyntax2).Name;
			}
			if (expressionSyntax2.Kind() != SyntaxKind.IdentifierName)
			{
				ReportDiagnostic(diagnostics, expressionSyntax2, ERRID.ERR_AddOrRemoveHandlerEvent);
				return BindRValue(node, BindingDiagnosticBag.Discarded);
			}
			BoundExpression boundExpression;
			if (expressionSyntax.Kind() == SyntaxKind.IdentifierName)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax node2 = (Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)expressionSyntax;
				boundExpression = BindSimpleName(node2, isInvocationOrAddressOf: false, diagnostics, skipLocalsAndParameters: true);
			}
			else
			{
				boundExpression = BindExpression(node, isInvocationOrAddressOf: false, isOperandOfConditionalBranch: false, eventContext: true, diagnostics);
			}
			BoundExpression mostEnclosedParenthesizedExpression = BoundExpressionExtensions.GetMostEnclosedParenthesizedExpression(boundExpression);
			if (mostEnclosedParenthesizedExpression.Kind == BoundKind.EventAccess)
			{
				actualEventAccess = (BoundEventAccess)mostEnclosedParenthesizedExpression;
				eventSymbol = actualEventAccess.EventSymbol;
			}
			else
			{
				mostEnclosedParenthesizedExpression = MakeRValue(mostEnclosedParenthesizedExpression, diagnostics);
				if (!mostEnclosedParenthesizedExpression.HasErrors)
				{
					string valueText = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)expressionSyntax2).Identifier.ValueText;
					Symbol expressionSymbol = mostEnclosedParenthesizedExpression.ExpressionSymbol;
					Symbol symbol = (((object)expressionSymbol != null) ? expressionSymbol.ContainingSymbol : Compilation.GetSpecialType(SpecialType.System_Object));
					ReportDiagnostic(diagnostics, expressionSyntax2, ERRID.ERR_NameNotEvent2, valueText, symbol);
				}
			}
			return boundExpression;
		}

		private BoundStatement BindRaiseEventStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.RaiseEventStatementSyntax node, BindingDiagnosticBag diagnostics)
		{
			bool hasErrors = false;
			BoundExpression boundExpression = BindSimpleName(node.Name, isInvocationOrAddressOf: false, diagnostics, skipLocalsAndParameters: true);
			if (boundExpression.Kind != BoundKind.EventAccess)
			{
				if (!boundExpression.HasErrors)
				{
					ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_NameNotEvent2, node.Name.ToString(), ContainingType);
				}
				return new BoundBadStatement(node, ImmutableArray.Create((BoundNode)boundExpression), hasErrors: true);
			}
			BoundEventAccess boundEventAccess = (BoundEventAccess)boundExpression;
			ImmutableArray<BoundExpression> boundArguments = default(ImmutableArray<BoundExpression>);
			ImmutableArray<string> argumentNames = default(ImmutableArray<string>);
			ImmutableArray<Location> argumentNamesLocations = default(ImmutableArray<Location>);
			BindArgumentsAndNames(node.ArgumentList, ref boundArguments, ref argumentNames, ref argumentNamesLocations, diagnostics);
			EventSymbol eventSymbol = boundEventAccess.EventSymbol;
			BoundExpression boundExpression2;
			MethodSymbol methodSymbol;
			if (eventSymbol.HasAssociatedField)
			{
				FieldSymbol associatedField = eventSymbol.AssociatedField;
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
				if (!IsAccessible(associatedField, ref useSiteInfo, ContainingType))
				{
					ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_CantRaiseBaseEvent);
					hasErrors = true;
				}
				((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)node.Name, useSiteInfo);
				boundExpression2 = BoundNodeExtensions.MakeCompilerGenerated(new BoundFieldAccess(node.Name, boundEventAccess.ReceiverOpt, associatedField, isLValue: false, associatedField.Type));
				NamedTypeSymbol namedTypeSymbol = eventSymbol.Type as NamedTypeSymbol;
				if ((object)namedTypeSymbol == null || (object)namedTypeSymbol.DelegateInvokeMethod == null)
				{
					if ((object)namedTypeSymbol != null && TypeSymbolExtensions.IsDelegateType(namedTypeSymbol))
					{
						ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_EventTypeNotDelegate);
					}
					return new BoundBadStatement(node, StaticCast<BoundNode>.From(boundArguments).Add(boundExpression), hasErrors: true);
				}
				methodSymbol = namedTypeSymbol.DelegateInvokeMethod;
				if (ReportUseSite(diagnostics, node.Name, methodSymbol))
				{
					hasErrors = true;
				}
				if (!methodSymbol.IsSub)
				{
					ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_EventsCantBeFunctions);
					return new BoundBadStatement(node, StaticCast<BoundNode>.From(boundArguments).Add(boundExpression), hasErrors: true);
				}
			}
			else
			{
				boundExpression2 = boundEventAccess.ReceiverOpt;
				methodSymbol = eventSymbol.RaiseMethod;
				if ((object)methodSymbol == null)
				{
					ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_MissingRaiseEventDef1, node.Name.ToString());
					return new BoundBadStatement(node, StaticCast<BoundNode>.From(boundArguments).Add(boundExpression), hasErrors: true);
				}
				if (ReportUseSite(diagnostics, node.Name, methodSymbol))
				{
					hasErrors = true;
				}
				if (!methodSymbol.IsSub)
				{
					ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_EventsCantBeFunctions);
					return new BoundBadStatement(node, StaticCast<BoundNode>.From(boundArguments).Add(boundExpression), hasErrors: true);
				}
				if (!TypeSymbol.Equals(methodSymbol.ContainingType, ContainingType, TypeCompareKind.ConsiderEverything))
				{
					ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_CantRaiseBaseEvent, node.Name.ToString());
					return new BoundBadStatement(node, StaticCast<BoundNode>.From(boundArguments).Add(boundExpression), hasErrors: true);
				}
			}
			if (methodSymbol == ContainingMember && (methodSymbol.IsShared || BoundExpressionExtensions.IsMeReference(boundExpression2)))
			{
				ReportDiagnostic(diagnostics, node, ERRID.WRN_RecursiveAddHandlerCall, node.RaiseEventKeyword.ToString(), eventSymbol.Name);
			}
			BoundMethodGroup group = BoundNodeExtensions.MakeCompilerGenerated(new BoundMethodGroup(node, null, ImmutableArray.Create(methodSymbol), LookupResultKind.Good, boundExpression2, QualificationKind.QualifiedViaValue));
			BoundExpression eventInvocation = BoundNodeExtensions.MakeCompilerGenerated(BindInvocationExpression(node, node.Name, TypeCharacter.None, group, boundArguments, argumentNames, diagnostics, null, allowConstructorCall: false, suppressAbstractCallDiagnostics: false, isDefaultMemberAccess: false, eventSymbol));
			return new BoundRaiseEventStatement(node, eventSymbol, eventInvocation, hasErrors);
		}

		private BoundStatement BindExpressionStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionStatementSyntax statement, BindingDiagnosticBag diagnostics)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression = statement.Expression;
			BoundExpression boundExpression;
			switch (expression.Kind())
			{
			case SyntaxKind.InvocationExpression:
			case SyntaxKind.ConditionalAccessExpression:
				boundExpression = BindInvocationExpressionAsStatement(expression, diagnostics);
				break;
			case SyntaxKind.AwaitExpression:
				boundExpression = BindAwait((Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax)expression, diagnostics, bindAsStatement: true);
				break;
			default:
				boundExpression = BindRValue(expression, diagnostics);
				break;
			}
			WarnOnUnobservedCallThatReturnsAnAwaitable(statement, boundExpression, diagnostics);
			return new BoundExpressionStatement(statement, boundExpression);
		}

		private void WarnOnUnobservedCallThatReturnsAnAwaitable(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionStatementSyntax statement, BoundExpression boundExpression, BindingDiagnosticBag diagnostics)
		{
			if (boundExpression.Kind == BoundKind.ConditionalAccess)
			{
				WarnOnUnobservedCallThatReturnsAnAwaitable(statement, ((BoundConditionalAccess)boundExpression).AccessExpression, diagnostics);
			}
			else
			{
				if (boundExpression.HasErrors || boundExpression.Kind == BoundKind.AwaitOperator || TypeSymbolExtensions.IsErrorType(boundExpression.Type) || TypeSymbolExtensions.IsVoidType(boundExpression.Type) || TypeSymbolExtensions.IsObjectType(boundExpression.Type))
				{
					return;
				}
				bool flag = false;
				if (boundExpression.Kind == BoundKind.Call)
				{
					BoundCall boundCall = (BoundCall)boundExpression;
					flag = boundCall.Method.IsAsync && (object)boundCall.Method.ContainingAssembly == Compilation.Assembly;
				}
				if (!flag)
				{
					CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
					if (IsOrInheritsFromOrImplementsInterface(boundExpression.Type, WellKnownType.Windows_Foundation_IAsyncAction, ref useSiteInfo) || IsOrInheritsFromOrImplementsInterface(boundExpression.Type, WellKnownType.Windows_Foundation_IAsyncActionWithProgress_T, ref useSiteInfo) || IsOrInheritsFromOrImplementsInterface(boundExpression.Type, WellKnownType.Windows_Foundation_IAsyncOperation_T, ref useSiteInfo) || IsOrInheritsFromOrImplementsInterface(boundExpression.Type, WellKnownType.Windows_Foundation_IAsyncOperationWithProgress_T2, ref useSiteInfo))
					{
						diagnostics.AddDependencies(useSiteInfo);
						flag = true;
					}
					else if (IsInAsyncContext())
					{
						BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(withDiagnostics: true, diagnostics.AccumulatesDependencies);
						if (!BindAwait(statement, boundExpression, instance, bindAsStatement: true).HasErrors && !instance.HasAnyErrors())
						{
							diagnostics.AddDependencies(instance);
							flag = true;
						}
						instance.Free();
					}
				}
				if (flag)
				{
					ReportDiagnostic(diagnostics, statement, ERRID.WRN_UnobservedAwaitableExpression);
				}
			}
		}

		private bool IsOrInheritsFromOrImplementsInterface(TypeSymbol derivedType, WellKnownType interfaceType, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			NamedTypeSymbol wellKnownType = Compilation.GetWellKnownType(interfaceType);
			if (!TypeSymbolExtensions.IsErrorType(wellKnownType) && TypeSymbolExtensions.IsInterfaceType(wellKnownType))
			{
				return IsOrInheritsFromOrImplementsInterface(derivedType, wellKnownType, ref useSiteInfo);
			}
			return false;
		}

		private BoundStatement BindPrintStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.PrintStatementSyntax printStmt, BindingDiagnosticBag diagnostics)
		{
			BoundExpression expression = BindRValue(printStmt.Expression, diagnostics);
			return new BoundExpressionStatement(printStmt, expression);
		}

		private BoundStatement BindCallStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.CallStatementSyntax callStmt, BindingDiagnosticBag diagnostics)
		{
			BoundExpression expression = BindInvocationExpressionAsStatement(callStmt.Invocation, diagnostics);
			return new BoundExpressionStatement(callStmt, expression);
		}

		private BoundExpression BindInvocationExpressionAsStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, BindingDiagnosticBag diagnostics)
		{
			return ReclassifyInvocationExpressionAsStatement(BindExpression(expression, diagnostics), diagnostics);
		}

		internal BoundExpression ReclassifyInvocationExpressionAsStatement(BoundExpression boundInvocation, BindingDiagnosticBag diagnostics)
		{
			switch (boundInvocation.Kind)
			{
			case BoundKind.PropertyAccess:
				boundInvocation = MakeRValue(boundInvocation, diagnostics);
				if (!boundInvocation.HasErrors)
				{
					ReportDiagnostic(diagnostics, boundInvocation.Syntax, ERRID.ERR_PropertyAccessIgnored);
				}
				break;
			case BoundKind.LateMemberAccess:
				boundInvocation = ((BoundLateMemberAccess)boundInvocation).SetAccessKind(LateBoundAccessKind.Call);
				break;
			case BoundKind.LateInvocation:
			{
				BoundLateInvocation boundLateInvocation = ((BoundLateInvocation)boundInvocation).SetAccessKind(LateBoundAccessKind.Call);
				boundInvocation = boundLateInvocation;
				if (!boundLateInvocation.HasErrors && boundLateInvocation.MethodOrPropertyGroupOpt is BoundPropertyGroup)
				{
					ReportDiagnostic(diagnostics, boundInvocation.Syntax, ERRID.ERR_PropertyAccessIgnored);
				}
				break;
			}
			case BoundKind.ConditionalAccess:
			{
				BoundConditionalAccess boundConditionalAccess = (BoundConditionalAccess)boundInvocation;
				boundInvocation = boundConditionalAccess.Update(boundConditionalAccess.Receiver, boundConditionalAccess.Placeholder, ReclassifyInvocationExpressionAsStatement(boundConditionalAccess.AccessExpression, diagnostics), GetSpecialType(SpecialType.System_Void, boundConditionalAccess.Syntax, diagnostics));
				break;
			}
			}
			return boundInvocation;
		}

		private BoundStatement BindSingleLineIfStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineIfStatementSyntax node, BindingDiagnosticBag diagnostics)
		{
			BoundStatement alternativeOpt = null;
			BoundExpression condition = BindBooleanExpression(node.Condition, diagnostics);
			BoundBlock consequence = BoundNodeExtensions.MakeCompilerGenerated(BindBlock(node, node.Statements, diagnostics));
			if (node.ElseClause != null)
			{
				alternativeOpt = BindBlock(node.ElseClause, node.ElseClause.Statements, diagnostics);
			}
			return new BoundIfStatement(node, condition, consequence, alternativeOpt);
		}

		private BoundStatement BindMultiLineIfBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineIfBlockSyntax node, BindingDiagnosticBag diagnostics)
		{
			ArrayBuilder<BoundStatement> instance = ArrayBuilder<BoundStatement>.GetInstance();
			ArrayBuilder<BoundExpression> instance2 = ArrayBuilder<BoundExpression>.GetInstance();
			instance2.Add(BindBooleanExpression(node.IfStatement.Condition, diagnostics));
			instance.Add(BoundNodeExtensions.MakeCompilerGenerated(BindBlock(node, node.Statements, diagnostics)));
			int num = node.ElseIfBlocks.Count - 1;
			for (int i = 0; i <= num; i++)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfBlockSyntax elseIfBlockSyntax = node.ElseIfBlocks[i];
				instance2.Add(BindBooleanExpression(elseIfBlockSyntax.ElseIfStatement.Condition, diagnostics));
				instance.Add(BoundNodeExtensions.MakeCompilerGenerated(BindBlock(elseIfBlockSyntax, elseIfBlockSyntax.Statements, diagnostics)));
			}
			BoundStatement boundStatement = null;
			if (node.ElseBlock != null)
			{
				boundStatement = BindBlock(node.ElseBlock, node.ElseBlock.Statements, diagnostics);
			}
			for (int j = instance2.Count - 1; j >= 0; j += -1)
			{
				VisualBasicSyntaxNode syntax = ((j != 0) ? ((VisualBasicSyntaxNode)node.ElseIfBlocks[j - 1]) : ((VisualBasicSyntaxNode)node));
				boundStatement = new BoundIfStatement(syntax, instance2[j], instance[j], boundStatement);
			}
			instance.Free();
			instance2.Free();
			return boundStatement;
		}

		private BoundStatement BindDoLoop(Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax node, BindingDiagnosticBag diagnostics)
		{
			BoundExpression boundExpression = null;
			BoundExpression boundExpression2 = null;
			bool topConditionIsUntil = false;
			bool bottomConditionIsUntil = false;
			Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax whileOrUntilClause = node.DoStatement.WhileOrUntilClause;
			if (whileOrUntilClause != null)
			{
				boundExpression = BindBooleanExpression(whileOrUntilClause.Condition, diagnostics);
				topConditionIsUntil = whileOrUntilClause.Kind() == SyntaxKind.UntilClause;
			}
			Binder binder = GetBinder(node);
			BoundBlock body = BoundNodeExtensions.MakeCompilerGenerated(binder.BindBlock(node, node.Statements, diagnostics));
			Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax whileOrUntilClause2 = node.LoopStatement.WhileOrUntilClause;
			if (whileOrUntilClause2 != null)
			{
				boundExpression2 = BindBooleanExpression(whileOrUntilClause2.Condition, diagnostics);
				bottomConditionIsUntil = whileOrUntilClause2.Kind() == SyntaxKind.UntilClause;
			}
			return new BoundDoLoopStatement(node, boundExpression, boundExpression2, topConditionIsUntil, bottomConditionIsUntil, body, binder.GetContinueLabel(SyntaxKind.ContinueDoStatement), binder.GetExitLabel(SyntaxKind.ExitDoStatement), boundExpression != null && boundExpression2 != null);
		}

		private BoundStatement BindWhileBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileBlockSyntax node, BindingDiagnosticBag diagnostics)
		{
			BoundExpression condition = BindBooleanExpression(node.WhileStatement.Condition, diagnostics);
			Binder binder = GetBinder(node);
			BoundBlock body = BoundNodeExtensions.MakeCompilerGenerated(binder.BindBlock(node, node.Statements, diagnostics));
			return new BoundWhileStatement(node, condition, body, binder.GetContinueLabel(SyntaxKind.ContinueWhileStatement), binder.GetExitLabel(SyntaxKind.ExitWhileStatement));
		}

		public BoundStatement BindForToBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax node, BindingDiagnosticBag diagnostics)
		{
			Binder binder = GetBinder(node);
			LocalSymbol declaredOrInferredLocalOpt = null;
			bool isInferredLocal = false;
			BoundExpression controlVariable = null;
			bool flag = false;
			return binder.BindForToBlockParts(hasErrors: binder.BindForBlockParts(node, node.ForOrForEachStatement.ControlVariable, out declaredOrInferredLocalOpt, out controlVariable, out isInferredLocal, diagnostics), node: node, declaredOrInferredLocalOpt: declaredOrInferredLocalOpt, controlVariableOpt: controlVariable, isInferredLocal: isInferredLocal, diagnostics: diagnostics);
		}

		public BoundStatement BindForEachBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax node, BindingDiagnosticBag diagnostics)
		{
			Binder binder = GetBinder(node);
			LocalSymbol declaredOrInferredLocalOpt = null;
			bool isInferredLocal = false;
			BoundExpression controlVariable = null;
			binder.BindForBlockParts(node, ((Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax)node.ForOrForEachStatement).ControlVariable, out declaredOrInferredLocalOpt, out controlVariable, out isInferredLocal, diagnostics);
			return binder.BindForEachBlockParts(node, declaredOrInferredLocalOpt, controlVariable, isInferredLocal, diagnostics);
		}

		private bool BindForBlockParts(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax node, VisualBasicSyntaxNode controlVariableSyntax, out LocalSymbol declaredOrInferredLocalOpt, out BoundExpression controlVariable, out bool isInferredLocal, BindingDiagnosticBag diagnostics)
		{
			bool result = false;
			declaredOrInferredLocalOpt = null;
			isInferredLocal = false;
			if (controlVariableSyntax.Kind() == SyntaxKind.VariableDeclarator)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax variableDeclaratorSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax)controlVariableSyntax;
				result = !VerifyForControlVariableDeclaration(variableDeclaratorSyntax, diagnostics);
				Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClause = variableDeclaratorSyntax.AsClause;
				BoundLocalDeclaration boundLocalDeclaration = BindVariableDeclaration(variableDeclaratorSyntax, variableDeclaratorSyntax.Names[0], asClause, null, diagnostics);
				declaredOrInferredLocalOpt = boundLocalDeclaration.LocalSymbol;
				controlVariable = new BoundLocal(variableDeclaratorSyntax, declaredOrInferredLocalOpt, declaredOrInferredLocalOpt.Type);
			}
			else
			{
				if (controlVariableSyntax.Kind() == SyntaxKind.IdentifierName)
				{
					SyntaxToken identifier = ((Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)controlVariableSyntax).Identifier;
					string valueText = identifier.ValueText;
					LookupResult instance = LookupResult.GetInstance();
					CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
					Lookup(instance, valueText, 0, LookupOptions.AllMethodsOfAnyArity, ref useSiteInfo);
					((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)node, useSiteInfo);
					if (instance.IsGood && instance.Symbols[0].Kind == SymbolKind.Local)
					{
						LocalSymbol localSymbol = (LocalSymbol)instance.Symbols[0];
						if (localSymbol.IdentifierToken == identifier)
						{
							isInferredLocal = true;
							declaredOrInferredLocalOpt = localSymbol;
						}
					}
					instance.Free();
				}
				if (!isInferredLocal)
				{
					if (!TryBindLoopControlVariable(controlVariableSyntax, out controlVariable, diagnostics))
					{
						result = true;
					}
				}
				else
				{
					controlVariable = null;
				}
			}
			return result;
		}

		private void BindForLoopBodyAndNextControlVariables(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax node, out ImmutableArray<BoundExpression> nextVariables, out BoundBlock loopBody, BindingDiagnosticBag diagnostics)
		{
			loopBody = BoundNodeExtensions.MakeCompilerGenerated(BindBlock(node, node.Statements, diagnostics));
			nextVariables = default(ImmutableArray<BoundExpression>);
			Microsoft.CodeAnalysis.VisualBasic.Syntax.NextStatementSyntax nextStatement = node.NextStatement;
			if (nextStatement == null)
			{
				return;
			}
			SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax> controlVariables = nextStatement.ControlVariables;
			if (controlVariables.IsEmpty())
			{
				nextVariables = ImmutableArray<BoundExpression>.Empty;
				return;
			}
			if (controlVariables.Count == 1)
			{
				BoundExpression expr = BindExpression(controlVariables[0], diagnostics);
				expr = ReclassifyAsValue(expr, diagnostics);
				nextVariables = ImmutableArray.Create(expr);
				return;
			}
			int count = controlVariables.Count;
			ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
			Binder binder = this;
			int num = count - 1;
			for (int i = 0; i <= num; i++)
			{
				BoundExpression expr2 = binder.BindExpression(controlVariables[i], diagnostics);
				expr2 = ReclassifyAsValue(expr2, diagnostics);
				instance.Add(expr2);
				do
				{
					binder = binder.ContainingBinder;
				}
				while (binder != null && !(binder is StatementListBinder));
				if (binder != null)
				{
					binder = binder.ContainingBinder;
				}
				if (!(binder is ForOrForEachBlockBinder))
				{
					break;
				}
			}
			nextVariables = instance.ToImmutableAndFree();
		}

		private BoundForStatement BindForToBlockParts(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax node, LocalSymbol declaredOrInferredLocalOpt, BoundExpression controlVariableOpt, bool isInferredLocal, bool hasErrors, BindingDiagnosticBag diagnostics)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax forStatementSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax)node.ForOrForEachStatement;
			BoundExpression fromValueExpression = null;
			BoundExpression toValueExpression = null;
			BoundExpression stepValueExpression = null;
			if (isInferredLocal)
			{
				TypeSymbol type = InferForFromToVariableType(declaredOrInferredLocalOpt, forStatementSyntax.FromValue, forStatementSyntax.ToValue, forStatementSyntax.StepClause, out fromValueExpression, out toValueExpression, out stepValueExpression, diagnostics);
				SyntaxToken identifierToken = declaredOrInferredLocalOpt.IdentifierToken;
				VerifyLocalSymbolNameAndSetType(declaredOrInferredLocalOpt, type, (VisualBasicSyntaxNode)identifierToken.Parent, identifierToken, diagnostics);
				controlVariableOpt = new BoundLocal(forStatementSyntax.ControlVariable, declaredOrInferredLocalOpt, type);
			}
			TypeSymbol type2 = controlVariableOpt.Type;
			bool flag = false;
			if ((object)type2 != null && !TypeSymbolExtensions.IsErrorType(type2))
			{
				flag = IsValidForControlVariableType(node, TypeSymbolExtensions.GetEnumUnderlyingTypeOrSelf(type2), diagnostics);
				hasErrors = !flag || hasErrors;
			}
			if (fromValueExpression == null)
			{
				fromValueExpression = BindValue(forStatementSyntax.FromValue, diagnostics);
			}
			if (toValueExpression == null)
			{
				toValueExpression = BindValue(forStatementSyntax.ToValue, diagnostics);
			}
			if (stepValueExpression == null)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax stepClause = forStatementSyntax.StepClause;
				if (stepClause != null)
				{
					stepValueExpression = BindValue(stepClause.StepValue, diagnostics);
				}
				else
				{
					stepValueExpression = new BoundLiteral(node, ConstantValue.Create(1), GetSpecialType(SpecialType.System_Int32, forStatementSyntax, diagnostics));
					stepValueExpression.SetWasCompilerGenerated();
				}
			}
			if (flag)
			{
				fromValueExpression = ApplyImplicitConversion(fromValueExpression.Syntax, type2, fromValueExpression, diagnostics);
				toValueExpression = ApplyImplicitConversion(toValueExpression.Syntax, type2, toValueExpression, diagnostics);
				BoundExpression boundExpression = stepValueExpression;
				stepValueExpression = ApplyConversion(stepValueExpression.Syntax, type2, stepValueExpression, forStatementSyntax.StepClause == null, diagnostics);
				if (stepValueExpression != boundExpression && stepValueExpression.Kind == BoundKind.Conversion && forStatementSyntax.StepClause == null)
				{
					BoundNodeExtensions.MakeCompilerGenerated(stepValueExpression);
				}
			}
			else
			{
				fromValueExpression = MakeRValueAndIgnoreDiagnostics(fromValueExpression);
				toValueExpression = MakeRValueAndIgnoreDiagnostics(toValueExpression);
				stepValueExpression = MakeRValueAndIgnoreDiagnostics(stepValueExpression);
			}
			GetSpecialType(SpecialType.System_Int32, node, diagnostics);
			NamedTypeSymbol specialType = GetSpecialType(SpecialType.System_Boolean, node, diagnostics);
			BoundForToUserDefinedOperators operatorsOpt = null;
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
			if (!hasErrors && !fromValueExpression.HasErrors && !toValueExpression.HasErrors && !stepValueExpression.HasErrors && TypeSymbolExtensions.CanContainUserDefinedOperators(type2, ref useSiteInfo))
			{
				VisualBasicSyntaxNode forOrForEachStatement = node.ForOrForEachStatement;
				BoundRValuePlaceholder boundRValuePlaceholder = BoundNodeExtensions.MakeCompilerGenerated(new BoundRValuePlaceholder(forOrForEachStatement, type2));
				BoundRValuePlaceholder boundRValuePlaceholder2 = BoundNodeExtensions.MakeCompilerGenerated(new BoundRValuePlaceholder(forOrForEachStatement, type2));
				BoundUserDefinedBinaryOperator boundUserDefinedBinaryOperator = BindForLoopUserDefinedOperator(forOrForEachStatement, BinaryOperatorKind.Add, boundRValuePlaceholder, boundRValuePlaceholder2, diagnostics);
				BoundUserDefinedBinaryOperator boundUserDefinedBinaryOperator2 = BindForLoopUserDefinedOperator(forOrForEachStatement, BinaryOperatorKind.Subtract, boundRValuePlaceholder, boundRValuePlaceholder2, diagnostics);
				BoundExpression boundExpression2 = BindForLoopUserDefinedOperator(forOrForEachStatement, BinaryOperatorKind.LessThanOrEqual, boundRValuePlaceholder, boundRValuePlaceholder2, diagnostics);
				if (boundExpression2 != null)
				{
					boundExpression2 = BoundNodeExtensions.MakeCompilerGenerated(ApplyImplicitConversion(forOrForEachStatement, specialType, boundExpression2, diagnostics, isOperandOfConditionalBranch: true));
				}
				BoundExpression boundExpression3 = BindForLoopUserDefinedOperator(forOrForEachStatement, BinaryOperatorKind.GreaterThanOrEqual, boundRValuePlaceholder, boundRValuePlaceholder2, diagnostics);
				if (boundExpression3 != null)
				{
					boundExpression3 = BoundNodeExtensions.MakeCompilerGenerated(ApplyImplicitConversion(forOrForEachStatement, specialType, boundExpression3, (boundExpression2 != null && boundExpression2.HasErrors) ? BindingDiagnosticBag.Discarded : diagnostics, isOperandOfConditionalBranch: true));
				}
				if (boundUserDefinedBinaryOperator != null && boundUserDefinedBinaryOperator2 != null && boundExpression2 != null && boundExpression3 != null)
				{
					operatorsOpt = new BoundForToUserDefinedOperators(forOrForEachStatement, boundRValuePlaceholder, boundRValuePlaceholder2, boundUserDefinedBinaryOperator, boundUserDefinedBinaryOperator2, boundExpression2, boundExpression3);
				}
				else
				{
					hasErrors = true;
				}
			}
			((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)node, useSiteInfo);
			hasErrors = hasErrors || TypeSymbolExtensions.IsErrorType(type2) || fromValueExpression.HasErrors || stepValueExpression.HasErrors || controlVariableOpt.HasErrors;
			BoundBlock loopBody = null;
			ImmutableArray<BoundExpression> nextVariables = default(ImmutableArray<BoundExpression>);
			BindForLoopBodyAndNextControlVariables(node, out nextVariables, out loopBody, diagnostics);
			return new BoundForToStatement(node, fromValueExpression, toValueExpression, stepValueExpression, CheckOverflow, operatorsOpt, declaredOrInferredLocalOpt, controlVariableOpt, loopBody, nextVariables, GetContinueLabel(SyntaxKind.ContinueForStatement), GetExitLabel(SyntaxKind.ExitForStatement), hasErrors);
		}

		private BoundUserDefinedBinaryOperator BindForLoopUserDefinedOperator(VisualBasicSyntaxNode syntax, BinaryOperatorKind opCode, BoundExpression left, BoundExpression right, BindingDiagnosticBag diagnostics)
		{
			bool flag = opCode == BinaryOperatorKind.LessThanOrEqual || opCode == BinaryOperatorKind.GreaterThanOrEqual;
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
			OverloadResolution.OverloadResolutionResult userDefinedOperator = OverloadResolution.ResolveUserDefinedBinaryOperator(left, right, opCode, this, ref useSiteInfo);
			if (((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)syntax, useSiteInfo))
			{
				diagnostics = BindingDiagnosticBag.Discarded;
			}
			if (userDefinedOperator.ResolutionIsLateBound || !userDefinedOperator.BestResult.HasValue)
			{
				ReportDiagnostic(diagnostics, syntax, ERRID.ERR_ForLoopOperatorRequired2, left.Type, SyntaxFacts.GetText(OverloadResolution.GetOperatorTokenKind(opCode)));
				return null;
			}
			OverloadResolution.Candidate candidate = userDefinedOperator.BestResult.Value.Candidate;
			if (!TypeSymbolExtensions.IsSameTypeIgnoringAll(candidate.Parameters(0).Type, left.Type) || !TypeSymbolExtensions.IsSameTypeIgnoringAll(candidate.Parameters(1).Type, left.Type) || (!flag && !TypeSymbolExtensions.IsSameTypeIgnoringAll(candidate.ReturnType, left.Type)))
			{
				if (flag)
				{
					ReportDiagnostic(diagnostics, syntax, ERRID.ERR_UnacceptableForLoopRelOperator2, candidate.UnderlyingSymbol, candidate.IsLifted ? TypeSymbolExtensions.GetNullableUnderlyingTypeOrSelf(left.Type) : left.Type);
				}
				else
				{
					ReportDiagnostic(diagnostics, syntax, ERRID.ERR_UnacceptableForLoopOperator2, candidate.UnderlyingSymbol, candidate.IsLifted ? TypeSymbolExtensions.GetNullableUnderlyingTypeOrSelf(left.Type) : left.Type);
				}
				return null;
			}
			BoundUserDefinedBinaryOperator boundUserDefinedBinaryOperator = BoundNodeExtensions.MakeCompilerGenerated(BindUserDefinedNonShortCircuitingBinaryOperator(syntax, opCode, left, right, ref userDefinedOperator, diagnostics));
			BoundNodeExtensions.MakeCompilerGenerated(boundUserDefinedBinaryOperator.UnderlyingExpression);
			return boundUserDefinedBinaryOperator;
		}

		private bool IsValidForControlVariableType(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax node, TypeSymbol targetType, BindingDiagnosticBag diagnostics)
		{
			if (TypeSymbolExtensions.IsNullableType(targetType))
			{
				targetType = TypeSymbolExtensions.GetEnumUnderlyingTypeOrSelf(TypeSymbolExtensions.GetNullableUnderlyingType(targetType));
			}
			if (TypeSymbolExtensions.IsNumericType(targetType))
			{
				return true;
			}
			if (TypeSymbolExtensions.IsObjectType(targetType))
			{
				return true;
			}
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
			if (TypeSymbolExtensions.IsIntrinsicOrEnumType(targetType) || !TypeSymbolExtensions.CanContainUserDefinedOperators(targetType, ref useSiteInfo))
			{
				((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)((Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax)node.ForOrForEachStatement).ControlVariable, useSiteInfo);
				ReportDiagnostic(diagnostics, ((Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax)node.ForOrForEachStatement).ControlVariable, ERRID.ERR_ForLoopType1, targetType);
				return false;
			}
			((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)((Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax)node.ForOrForEachStatement).ControlVariable, useSiteInfo);
			return true;
		}

		private BoundForEachStatement BindForEachBlockParts(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax node, LocalSymbol declaredOrInferredLocalOpt, BoundExpression controlVariableOpt, bool isInferredLocal, BindingDiagnosticBag diagnostics)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax forEachStatementSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax)node.ForOrForEachStatement;
			TypeSymbol currentType = null;
			TypeSymbol elementType = null;
			bool isEnumerable = false;
			bool needToDispose = false;
			bool isOrInheritsFromOrImplementsIDisposable = false;
			BoundExpression boundGetEnumeratorCall = null;
			BoundLValuePlaceholder boundEnumeratorPlaceholder = null;
			BoundExpression boundMoveNextCall = null;
			BoundExpression boundCurrentAccess = null;
			BoundRValuePlaceholder collectionPlaceholder = null;
			BoundExpression disposeCondition = null;
			BoundExpression boundExpression = null;
			BoundExpression boundExpression2 = null;
			BoundRValuePlaceholder boundRValuePlaceholder = null;
			BoundExpression collectionExpression = null;
			if (isInferredLocal)
			{
				TypeSymbol type = InferForEachVariableType(declaredOrInferredLocalOpt, forEachStatementSyntax.Expression, out collectionExpression, out currentType, out elementType, out isEnumerable, out boundGetEnumeratorCall, out boundEnumeratorPlaceholder, out boundMoveNextCall, out boundCurrentAccess, out collectionPlaceholder, out needToDispose, out isOrInheritsFromOrImplementsIDisposable, diagnostics);
				SyntaxToken identifierToken = declaredOrInferredLocalOpt.IdentifierToken;
				VerifyLocalSymbolNameAndSetType(declaredOrInferredLocalOpt, type, (VisualBasicSyntaxNode)identifierToken.Parent, identifierToken, diagnostics);
				controlVariableOpt = new BoundLocal(forEachStatementSyntax.ControlVariable, declaredOrInferredLocalOpt, type);
			}
			if (collectionExpression == null)
			{
				collectionExpression = BindValue(forEachStatementSyntax.Expression, diagnostics);
				if (!collectionExpression.IsLValue && !BoundExpressionExtensions.IsNothingLiteral(collectionExpression))
				{
					collectionExpression = MakeRValue(collectionExpression, diagnostics);
				}
				collectionExpression = InterpretForEachStatementCollection(collectionExpression, out currentType, out elementType, out isEnumerable, out boundGetEnumeratorCall, out boundEnumeratorPlaceholder, out boundMoveNextCall, out boundCurrentAccess, out collectionPlaceholder, out needToDispose, out isOrInheritsFromOrImplementsIDisposable, diagnostics);
			}
			SyntaxNode syntax = collectionExpression.Syntax;
			if ((object)currentType != null && !controlVariableOpt.HasErrors)
			{
				TypeSymbol type2 = controlVariableOpt.Type;
				if (!TypeSymbolExtensions.IsErrorType(type2) && !TypeSymbolExtensions.IsErrorType(currentType) && !TypeSymbolExtensions.IsErrorType(elementType))
				{
					TypeSymbol source = elementType;
					TypeSymbol destination = currentType;
					CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
					BoundExpression boundExpression3;
					if (Conversions.IsIdentityConversion(Conversions.ClassifyConversion(source, destination, ref useSiteInfo).Key))
					{
						boundRValuePlaceholder = new BoundRValuePlaceholder(syntax, elementType);
						boundExpression3 = boundRValuePlaceholder;
					}
					else
					{
						boundRValuePlaceholder = new BoundRValuePlaceholder(syntax, currentType);
						boundExpression3 = ApplyConversion(syntax, elementType, boundRValuePlaceholder, isExplicit: true, diagnostics);
						boundExpression3.SetWasCompilerGenerated();
					}
					if (boundExpression3 != boundRValuePlaceholder)
					{
						TypeSymbol destination2 = elementType;
						useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
						if (Conversions.IsIdentityConversion(Conversions.ClassifyConversion(type2, destination2, ref useSiteInfo).Key))
						{
							boundExpression2 = boundExpression3;
							goto IL_01c3;
						}
					}
					boundExpression2 = ApplyConversion(syntax, type2, boundExpression3, isExplicit: true, diagnostics);
					boundExpression2.SetWasCompilerGenerated();
				}
			}
			goto IL_01c3;
			IL_01c3:
			if (needToDispose)
			{
				NamedTypeSymbol specialType = Compilation.GetSpecialType(SpecialType.System_IDisposable);
				TypeSymbol type3 = boundGetEnumeratorCall.Type;
				if (isOrInheritsFromOrImplementsIDisposable)
				{
					if (!type3.IsValueType)
					{
						disposeCondition = BindIsExpression(boundEnumeratorPlaceholder, new BoundLiteral(syntax, ConstantValue.Nothing, null), syntax, isNot: true, diagnostics);
						boundExpression = ApplyConversion(syntax, specialType, boundEnumeratorPlaceholder, isExplicit: true, diagnostics);
					}
				}
				else
				{
					CompoundUseSiteInfo<AssemblySymbol> useSiteInfo2 = GetNewCompoundUseSiteInfo(diagnostics);
					ConversionKind conversionKind = Conversions.ClassifyTryCastConversion(type3, specialType, ref useSiteInfo2);
					if (((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(syntax, useSiteInfo2))
					{
						diagnostics = BindingDiagnosticBag.Discarded;
					}
					boundExpression = new BoundTryCast(syntax, boundEnumeratorPlaceholder.MakeRValue(), conversionKind, specialType);
					disposeCondition = BindIsExpression(boundExpression, new BoundLiteral(syntax, ConstantValue.Nothing, null), syntax, isNot: true, diagnostics);
				}
			}
			BoundBlock loopBody = null;
			ImmutableArray<BoundExpression> nextVariables = default(ImmutableArray<BoundExpression>);
			BindForLoopBodyAndNextControlVariables(node, out nextVariables, out loopBody, diagnostics);
			ForEachEnumeratorInfo enumeratorInfo = new ForEachEnumeratorInfo(boundGetEnumeratorCall, boundMoveNextCall, boundCurrentAccess, elementType, needToDispose, isOrInheritsFromOrImplementsIDisposable, disposeCondition, boundExpression, boundExpression2, boundEnumeratorPlaceholder, boundRValuePlaceholder, collectionPlaceholder);
			return new BoundForEachStatement(node, collectionExpression, enumeratorInfo, declaredOrInferredLocalOpt, controlVariableOpt, loopBody, nextVariables, GetContinueLabel(SyntaxKind.ContinueForStatement), GetExitLabel(SyntaxKind.ExitForStatement));
		}

		private static bool VerifyForControlVariableDeclaration(Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax variableDeclarator, BindingDiagnosticBag diagnostics)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax modifiedIdentifierSyntax = variableDeclarator.Names[0];
			if (variableDeclarator.AsClause == null && modifiedIdentifierSyntax.Nullable.Node != null)
			{
				ReportDiagnostic(diagnostics, modifiedIdentifierSyntax, ERRID.ERR_NullableTypeInferenceNotSupported);
				return false;
			}
			if (modifiedIdentifierSyntax.ArrayBounds != null)
			{
				ReportDiagnostic(diagnostics, modifiedIdentifierSyntax, ERRID.ERR_ForCtlVarArraySizesSpecified);
				return false;
			}
			return true;
		}

		private bool TryBindLoopControlVariable(VisualBasicSyntaxNode controlVariableSyntax, out BoundExpression controlVariable, BindingDiagnosticBag diagnostics)
		{
			controlVariable = BindExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)controlVariableSyntax, diagnostics);
			controlVariable = ReclassifyAsValue(controlVariable, diagnostics);
			if (controlVariable.HasErrors)
			{
				controlVariable = BadExpression(controlVariable);
				return false;
			}
			if (!VerifyForLoopControlReference(controlVariable, diagnostics))
			{
				controlVariable = new BoundBadExpression(controlVariableSyntax, LookupResultKind.NotAVariable, ImmutableArray<Symbol>.Empty, ImmutableArray.Create(controlVariable), controlVariable.Type, hasErrors: true);
				return false;
			}
			return true;
		}

		private bool VerifyForLoopControlReference(BoundExpression controlVariable, BindingDiagnosticBag diagnostics)
		{
			if (BoundExpressionExtensions.IsPropertyOrXmlPropertyAccess(controlVariable))
			{
				ReportDiagnostic(diagnostics, controlVariable.Syntax, ERRID.ERR_LoopControlMustNotBeProperty);
				return false;
			}
			if (!controlVariable.IsLValue)
			{
				if (!controlVariable.HasErrors)
				{
					ReportAssignmentToRValue(controlVariable, diagnostics);
				}
				return false;
			}
			if (!controlVariable.HasErrors && IsInAsyncContext() && SeenAwaitVisitor.SeenAwaitIn(controlVariable, diagnostics))
			{
				ReportDiagnostic(diagnostics, controlVariable.Syntax, ERRID.ERR_LoopControlMustNotAwait);
				return false;
			}
			return true;
		}

		private BoundExpression InterpretForEachStatementCollection(BoundExpression collection, out TypeSymbol currentType, out TypeSymbol elementType, out bool isEnumerable, out BoundExpression boundGetEnumeratorCall, out BoundLValuePlaceholder boundEnumeratorPlaceholder, out BoundExpression boundMoveNextCall, out BoundExpression boundCurrentAccess, out BoundRValuePlaceholder collectionPlaceholder, out bool needToDispose, out bool isOrInheritsFromOrImplementsIDisposable, BindingDiagnosticBag diagnostics)
		{
			currentType = null;
			elementType = null;
			isEnumerable = false;
			needToDispose = false;
			isOrInheritsFromOrImplementsIDisposable = false;
			boundGetEnumeratorCall = null;
			boundEnumeratorPlaceholder = null;
			boundMoveNextCall = null;
			boundCurrentAccess = null;
			collectionPlaceholder = null;
			if (collection.HasErrors)
			{
				return collection;
			}
			TypeSymbol type = collection.Type;
			SyntaxNode syntax = collection.Syntax;
			NamedTypeSymbol namedTypeSymbol = null;
			SpecialType specialType = SpecialType.None;
			BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(withDiagnostics: true, diagnostics.AccumulatesDependencies);
			if (MatchesForEachCollectionDesignPattern(type, collection, out currentType, out boundGetEnumeratorCall, out boundEnumeratorPlaceholder, out boundMoveNextCall, out boundCurrentAccess, out collectionPlaceholder, instance))
			{
				diagnostics.AddRange(instance);
				elementType = currentType;
				isEnumerable = true;
			}
			else
			{
				BindingDiagnosticBag instance2 = BindingDiagnosticBag.GetInstance(diagnostics);
				NamedTypeSymbol specialType2 = GetSpecialType(SpecialType.System_Collections_Generic_IEnumerable_T, syntax, instance2);
				HashSet<NamedTypeSymbol> hashSet = new HashSet<NamedTypeSymbol>(EqualsIgnoringComparer.InstanceIgnoringTupleNames);
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
				if (!BoundExpressionExtensions.IsNothingLiteral(collection) && !TypeSymbolExtensions.IsArrayType(type) && IsOrInheritsFromOrImplementsInterface(type, specialType2, ref useSiteInfo, hashSet))
				{
					((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(syntax, useSiteInfo);
					isEnumerable = true;
					namedTypeSymbol = hashSet.ElementAtOrDefault(0);
					diagnostics.AddRange(instance2);
					instance2.Free();
					if (hashSet.Count > 1)
					{
						ReportDiagnostic(diagnostics, syntax, ErrorFactory.ErrorInfo(ERRID.ERR_ForEachAmbiguousIEnumerable1, type));
						instance.Free();
						return new BoundBadExpression(syntax, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, ImmutableArray.Create(collection), type, hasErrors: true);
					}
					specialType = SpecialType.System_Collections_Generic_IEnumerable_T;
				}
				else
				{
					instance2.Clear();
					NamedTypeSymbol specialType3 = GetSpecialType(SpecialType.System_Collections_IEnumerable, syntax, instance2);
					if (((!BoundExpressionExtensions.IsNothingLiteral(collection) && !TypeSymbolExtensions.IsObjectType(type)) || OptionStrict == OptionStrict.On) && (BoundExpressionExtensions.IsNothingLiteral(collection) || TypeSymbolExtensions.IsArrayType(type) || !IsOrInheritsFromOrImplementsInterface(type, specialType3, ref useSiteInfo, hashSet)))
					{
						((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(syntax, useSiteInfo);
						if (BoundExpressionExtensions.IsNothingLiteral(collection))
						{
							collection = MakeRValue(collection, diagnostics);
							type = collection.Type;
						}
						if (instance.HasAnyErrors())
						{
							diagnostics.AddRange(instance);
						}
						else
						{
							ReportDiagnostic(diagnostics, syntax, ErrorFactory.ErrorInfo(ERRID.ERR_ForEachCollectionDesignPattern1, type));
						}
						instance.Free();
						instance2.Free();
						return new BoundBadExpression(syntax, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, ImmutableArray.Create(collection), type, hasErrors: true);
					}
					((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(syntax, useSiteInfo);
					isEnumerable = true;
					namedTypeSymbol = specialType3;
					specialType = SpecialType.System_Collections_IEnumerable;
					diagnostics.AddRange(instance2);
					instance2.Free();
				}
			}
			instance.Free();
			if ((object)namedTypeSymbol != null)
			{
				collection = ApplyImplicitConversion(syntax, namedTypeSymbol, collection, diagnostics);
			}
			if (isEnumerable)
			{
				if (specialType != 0)
				{
					Symbol symbol;
					if (specialType == SpecialType.System_Collections_Generic_IEnumerable_T)
					{
						Symbol specialTypeMember = GetSpecialTypeMember(SpecialMember.System_Collections_Generic_IEnumerable_T__GetEnumerator, syntax, diagnostics);
						symbol = (((object)specialTypeMember == null || specialTypeMember.GetUseSiteInfo().DiagnosticInfo != null || TypeSymbolExtensions.IsErrorType(namedTypeSymbol)) ? null : ((SubstitutedNamedType)namedTypeSymbol).GetMemberForDefinition(specialTypeMember));
					}
					else
					{
						symbol = GetSpecialTypeMember(SpecialMember.System_Collections_IEnumerable__GetEnumerator, syntax, diagnostics);
					}
					UseSiteInfo<AssemblySymbol> useSiteInfo2 = symbol?.GetUseSiteInfo() ?? default(UseSiteInfo<AssemblySymbol>);
					if ((object)symbol != null && useSiteInfo2.DiagnosticInfo == null)
					{
						diagnostics.AddDependencies(useSiteInfo2);
						collectionPlaceholder = new BoundRValuePlaceholder(syntax, ((object)type != null && TypeSymbolExtensions.IsStringType(type)) ? type : collection.Type);
						BoundMethodOrPropertyGroup methodOrPropertyGroup = new BoundMethodGroup(syntax, null, ImmutableArray.Create((MethodSymbol)symbol), LookupResultKind.Good, collectionPlaceholder, QualificationKind.QualifiedViaValue);
						boundGetEnumeratorCall = CreateBoundInvocationExpressionFromMethodOrPropertyGroup(syntax, methodOrPropertyGroup, diagnostics);
						TypeSymbol type2 = boundGetEnumeratorCall.Type;
						boundEnumeratorPlaceholder = new BoundLValuePlaceholder(syntax, type2);
						symbol = GetSpecialTypeMember(SpecialMember.System_Collections_IEnumerator__MoveNext, syntax, diagnostics);
						useSiteInfo2 = symbol?.GetUseSiteInfo() ?? default(UseSiteInfo<AssemblySymbol>);
						if ((object)symbol != null && useSiteInfo2.DiagnosticInfo == null)
						{
							diagnostics.AddDependencies(useSiteInfo2);
							methodOrPropertyGroup = new BoundMethodGroup(syntax, null, ImmutableArray.Create((MethodSymbol)symbol), LookupResultKind.Good, boundEnumeratorPlaceholder, QualificationKind.QualifiedViaValue);
							boundMoveNextCall = CreateBoundInvocationExpressionFromMethodOrPropertyGroup(syntax, methodOrPropertyGroup, diagnostics);
						}
						if (specialType == SpecialType.System_Collections_Generic_IEnumerable_T)
						{
							Symbol specialTypeMember = GetSpecialTypeMember(SpecialMember.System_Collections_Generic_IEnumerator_T__Current, syntax, diagnostics);
							symbol = (((object)specialTypeMember == null || specialTypeMember.GetUseSiteInfo().DiagnosticInfo != null || TypeSymbolExtensions.IsErrorType(type2)) ? null : ((SubstitutedNamedType)type2).GetMemberForDefinition(specialTypeMember));
						}
						else
						{
							symbol = GetSpecialTypeMember(SpecialMember.System_Collections_IEnumerator__Current, syntax, diagnostics);
						}
						useSiteInfo2 = symbol?.GetUseSiteInfo() ?? default(UseSiteInfo<AssemblySymbol>);
						if ((object)symbol != null && useSiteInfo2.DiagnosticInfo == null)
						{
							diagnostics.AddDependencies(useSiteInfo2);
							methodOrPropertyGroup = new BoundPropertyGroup(syntax, ImmutableArray.Create((PropertySymbol)symbol), LookupResultKind.Good, boundEnumeratorPlaceholder, QualificationKind.QualifiedViaValue);
							boundCurrentAccess = CreateBoundInvocationExpressionFromMethodOrPropertyGroup(syntax, methodOrPropertyGroup, diagnostics);
							currentType = boundCurrentAccess.Type;
							elementType = currentType;
						}
					}
				}
				if ((object)type != null)
				{
					if (TypeSymbolExtensions.IsArrayType(type))
					{
						ArrayTypeSymbol arrayTypeSymbol = (ArrayTypeSymbol)type;
						elementType = arrayTypeSymbol.ElementType;
						if (arrayTypeSymbol.IsSZArray)
						{
							currentType = elementType;
						}
					}
					else if (TypeSymbolExtensions.IsStringType(type))
					{
						elementType = GetSpecialType(SpecialType.System_Char, syntax, diagnostics);
						currentType = elementType;
					}
				}
				NamedTypeSymbol specialType4 = GetSpecialType(SpecialType.System_IDisposable, syntax, diagnostics);
				if ((object)specialType4 != null && !TypeSymbolExtensions.IsErrorType(specialType4) && !boundGetEnumeratorCall.HasErrors && !TypeSymbolExtensions.IsErrorType(boundGetEnumeratorCall.Type))
				{
					TypeSymbol type3 = boundGetEnumeratorCall.Type;
					CompoundUseSiteInfo<AssemblySymbol> useSiteInfo3 = GetNewCompoundUseSiteInfo(diagnostics);
					ConversionKind conv = Conversions.ClassifyDirectCastConversion(type3, specialType4, ref useSiteInfo3);
					((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(syntax, useSiteInfo3);
					isOrInheritsFromOrImplementsIDisposable = Conversions.IsWideningConversion(conv);
					if ((isOrInheritsFromOrImplementsIDisposable || type3.SpecialType == SpecialType.System_Collections_IEnumerator) && ((object)type == null || !TypeSymbolExtensions.IsArrayType(type)))
					{
						needToDispose = true;
					}
				}
			}
			return collection;
		}

		private bool MatchesForEachCollectionDesignPattern(TypeSymbol collectionType, BoundExpression collection, out TypeSymbol currentType, out BoundExpression boundGetEnumeratorCall, out BoundLValuePlaceholder boundEnumeratorPlaceholder, out BoundExpression boundMoveNextCall, out BoundExpression boundCurrentAccess, out BoundRValuePlaceholder collectionPlaceholder, BindingDiagnosticBag temporaryDiagnostics)
		{
			currentType = null;
			boundGetEnumeratorCall = null;
			boundEnumeratorPlaceholder = null;
			boundMoveNextCall = null;
			boundCurrentAccess = null;
			SyntaxNode syntax = collection.Syntax;
			if (BoundExpressionExtensions.IsNothingLiteral(collection) || (collectionType.Kind != SymbolKind.ArrayType && collectionType.Kind != SymbolKind.NamedType && collectionType.Kind != SymbolKind.TypeParameter))
			{
				return false;
			}
			LookupResult lookupResult = new LookupResult();
			if (!GetMemberIfMatchesRequirements("GetEnumerator", collectionType, s_isFunctionWithoutArguments, lookupResult, syntax, temporaryDiagnostics))
			{
				return false;
			}
			collectionPlaceholder = new BoundRValuePlaceholder(syntax, collection.Type);
			BoundMethodOrPropertyGroup methodOrPropertyGroup = CreateBoundMethodGroup(syntax, lookupResult, LookupOptions.AllMethodsOfAnyArity, temporaryDiagnostics.AccumulatesDependencies, collectionPlaceholder, null, QualificationKind.QualifiedViaValue);
			boundGetEnumeratorCall = CreateBoundInvocationExpressionFromMethodOrPropertyGroup(syntax, methodOrPropertyGroup, temporaryDiagnostics);
			if (boundGetEnumeratorCall.HasErrors)
			{
				temporaryDiagnostics.Clear();
				return false;
			}
			TypeSymbol type = boundGetEnumeratorCall.Type;
			boundEnumeratorPlaceholder = new BoundLValuePlaceholder(syntax, type);
			if (!GetMemberIfMatchesRequirements("MoveNext", type, s_isFunctionWithoutArguments, lookupResult, syntax, temporaryDiagnostics))
			{
				return false;
			}
			methodOrPropertyGroup = CreateBoundMethodGroup(syntax, lookupResult, LookupOptions.AllMethodsOfAnyArity, temporaryDiagnostics.AccumulatesDependencies, boundEnumeratorPlaceholder, null, QualificationKind.QualifiedViaValue);
			boundMoveNextCall = CreateBoundInvocationExpressionFromMethodOrPropertyGroup(syntax, methodOrPropertyGroup, temporaryDiagnostics);
			if (boundMoveNextCall.HasErrors || boundMoveNextCall.Kind != BoundKind.Call || ((BoundCall)boundMoveNextCall).Method.OriginalDefinition.ReturnType.SpecialType != SpecialType.System_Boolean)
			{
				temporaryDiagnostics.Clear();
				return false;
			}
			if (!GetMemberIfMatchesRequirements("Current", type, s_isReadablePropertyWithoutArguments, lookupResult, syntax, temporaryDiagnostics))
			{
				return false;
			}
			methodOrPropertyGroup = new BoundPropertyGroup(syntax, lookupResult.Symbols.ToDowncastedImmutable<PropertySymbol>(), lookupResult.Kind, boundEnumeratorPlaceholder, QualificationKind.QualifiedViaValue);
			boundCurrentAccess = CreateBoundInvocationExpressionFromMethodOrPropertyGroup(syntax, methodOrPropertyGroup, temporaryDiagnostics);
			if (boundCurrentAccess.HasErrors)
			{
				return false;
			}
			currentType = boundCurrentAccess.Type;
			return true;
		}

		private BoundExpression CreateBoundInvocationExpressionFromMethodOrPropertyGroup(SyntaxNode syntax, BoundMethodOrPropertyGroup methodOrPropertyGroup, BindingDiagnosticBag diagnostics)
		{
			BoundExpression expr = BindInvocationExpression(syntax, syntax, TypeCharacter.None, methodOrPropertyGroup, ImmutableArray<BoundExpression>.Empty, default(ImmutableArray<string>), diagnostics, syntax);
			return MakeRValue(expr, diagnostics);
		}

		private bool GetMemberIfMatchesRequirements(string name, TypeSymbol container, Func<Symbol, bool> symbolChecker, LookupResult result, SyntaxNode syntax, BindingDiagnosticBag diagnostics)
		{
			result.Clear();
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
			LookupMember(result, container, name, 0, LookupOptions.AllMethodsOfAnyArity, ref useSiteInfo);
			((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(syntax, useSiteInfo);
			useSiteInfo = new CompoundUseSiteInfo<AssemblySymbol>(useSiteInfo);
			if (result.IsGood)
			{
				ArrayBuilder<Symbol>.Enumerator enumerator = result.Symbols.GetEnumerator();
				while (enumerator.MoveNext())
				{
					Symbol current = enumerator.Current;
					if (symbolChecker(current))
					{
						return true;
					}
				}
				if (result.Symbols[0].Kind == SymbolKind.Method && !((MethodSymbol)result.Symbols[0]).IsReducedExtensionMethod)
				{
					result.Clear();
					LookupExtensionMethods(result, container, name, 0, LookupOptions.AllMethodsOfAnyArity, ref useSiteInfo);
					((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(syntax, useSiteInfo);
					if (result.IsGood)
					{
						ArrayBuilder<Symbol>.Enumerator enumerator2 = result.Symbols.GetEnumerator();
						while (enumerator2.MoveNext())
						{
							Symbol current2 = enumerator2.Current;
							if (symbolChecker(current2))
							{
								return true;
							}
						}
					}
				}
			}
			else if (result.IsAmbiguous)
			{
				diagnostics.Clear();
				diagnostics.Add(new VBDiagnostic(result.Diagnostic, syntax.GetLocation()));
			}
			result.Clear();
			return false;
		}

		internal static bool IsOrInheritsFromOrImplementsInterface(TypeSymbol derivedType, NamedTypeSymbol interfaceType, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, HashSet<NamedTypeSymbol> matchingInterfaces = null)
		{
			if (TypeSymbolExtensions.IsTypeParameter(derivedType))
			{
				TypeParameterSymbol typeParameterSymbol = (TypeParameterSymbol)derivedType;
				if (typeParameterSymbol.HasValueTypeConstraint && IsOrInheritsFromOrImplementsInterface(interfaceType.ContainingAssembly.GetSpecialType(SpecialType.System_ValueType), interfaceType, ref useSiteInfo, matchingInterfaces) && matchingInterfaces == null)
				{
					return true;
				}
				ImmutableArray<TypeSymbol>.Enumerator enumerator = typeParameterSymbol.ConstraintTypesWithDefinitionUseSiteDiagnostics(ref useSiteInfo).GetEnumerator();
				while (enumerator.MoveNext())
				{
					if (IsOrInheritsFromOrImplementsInterface(enumerator.Current, interfaceType, ref useSiteInfo, matchingInterfaces) && matchingInterfaces == null)
					{
						return true;
					}
				}
			}
			else
			{
				if (TypeSymbol.Equals(derivedType.OriginalDefinition, interfaceType, TypeCompareKind.ConsiderEverything))
				{
					if (matchingInterfaces == null)
					{
						return true;
					}
					RecordMatchForIsOrInheritsFromOrImplementsInterface(matchingInterfaces, (NamedTypeSymbol)derivedType);
				}
				ImmutableArray<NamedTypeSymbol>.Enumerator enumerator2 = derivedType.AllInterfacesWithDefinitionUseSiteDiagnostics(ref useSiteInfo).GetEnumerator();
				while (enumerator2.MoveNext())
				{
					NamedTypeSymbol current = enumerator2.Current;
					if (TypeSymbol.Equals(current.OriginalDefinition, interfaceType, TypeCompareKind.ConsiderEverything))
					{
						if (matchingInterfaces == null)
						{
							return true;
						}
						RecordMatchForIsOrInheritsFromOrImplementsInterface(matchingInterfaces, current);
					}
				}
			}
			return matchingInterfaces != null && matchingInterfaces.Count > 0;
		}

		private static void RecordMatchForIsOrInheritsFromOrImplementsInterface(HashSet<NamedTypeSymbol> matchingInterfaces, NamedTypeSymbol interfaceOfDerived)
		{
			if (!matchingInterfaces.Add(interfaceOfDerived) && matchingInterfaces.Comparer == EqualsIgnoringComparer.InstanceIgnoringTupleNames && !interfaceOfDerived.IsDefinition)
			{
				matchingInterfaces.Remove(interfaceOfDerived);
				matchingInterfaces.Add(interfaceOfDerived);
			}
		}

		public BoundStatement BindWithBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.WithBlockSyntax node, BindingDiagnosticBag diagnostics)
		{
			Binder binder = GetBinder(node);
			return binder.CreateBoundWithBlock(node, binder, diagnostics);
		}

		protected virtual BoundStatement CreateBoundWithBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.WithBlockSyntax node, Binder boundBlockBinder, BindingDiagnosticBag diagnostics)
		{
			return ContainingBinder.CreateBoundWithBlock(node, boundBlockBinder, diagnostics);
		}

		public BoundStatement BindUsingBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingBlockSyntax node, BindingDiagnosticBag diagnostics)
		{
			Binder binder = GetBinder(node);
			ImmutableArray<BoundLocalDeclarationBase> resourceList = default(ImmutableArray<BoundLocalDeclarationBase>);
			BoundExpression boundExpression = null;
			Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax usingStatement = node.UsingStatement;
			SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax> variables = usingStatement.Variables;
			int count = variables.Count;
			NamedTypeSymbol specialType = GetSpecialType(SpecialType.System_IDisposable, node, diagnostics);
			Dictionary<TypeSymbol, (BoundRValuePlaceholder, BoundExpression, BoundExpression)> placeholderInfo = new Dictionary<TypeSymbol, (BoundRValuePlaceholder, BoundExpression, BoundExpression)>();
			if (count > 0)
			{
				resourceList = binder.BindVariableDeclarators(variables, diagnostics);
				int num = count - 1;
				for (int i = 0; i <= num; i++)
				{
					BoundLocalDeclarationBase boundLocalDeclarationBase = resourceList[i];
					SyntaxNode syntax = boundLocalDeclarationBase.Syntax;
					SyntaxNode syntaxNode;
					if (boundLocalDeclarationBase.Kind != BoundKind.AsNewLocalDeclarations)
					{
						syntaxNode = syntax.Parent;
						if (syntaxNode == null || ((Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax)syntaxNode).Names.Count > 1)
						{
							syntaxNode = syntax;
						}
					}
					else
					{
						syntaxNode = syntax;
					}
					if (boundLocalDeclarationBase.Kind == BoundKind.LocalDeclaration)
					{
						BoundLocalDeclaration boundLocalDeclaration = (BoundLocalDeclaration)boundLocalDeclarationBase;
						if (boundLocalDeclaration.InitializerOpt == null)
						{
							ReportDiagnostic(diagnostics, syntaxNode, ErrorFactory.ErrorInfo(ERRID.ERR_UsingResourceVarNeedsInitializer));
						}
						VerifyUsingVariableDeclarationAndBuildUsingInfo(syntaxNode, boundLocalDeclaration.LocalSymbol, specialType, placeholderInfo, diagnostics);
						continue;
					}
					BoundAsNewLocalDeclarations boundAsNewLocalDeclarations = (BoundAsNewLocalDeclarations)boundLocalDeclarationBase;
					int num2 = boundAsNewLocalDeclarations.LocalDeclarations.Length - 1;
					for (int j = 0; j <= num2; j++)
					{
						BoundLocalDeclaration boundLocalDeclaration2 = boundAsNewLocalDeclarations.LocalDeclarations[j];
						VerifyUsingVariableDeclarationAndBuildUsingInfo(boundLocalDeclaration2.Syntax, boundLocalDeclaration2.LocalSymbol, specialType, placeholderInfo, diagnostics);
					}
				}
			}
			else
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression = usingStatement.Expression;
				boundExpression = BindRValue(expression, diagnostics);
				if (!TypeSymbolExtensions.IsErrorType(boundExpression.Type) && !TypeSymbolExtensions.IsErrorType(specialType))
				{
					BuildAndVerifyUsingInfo(expression, boundExpression.Type, placeholderInfo, specialType, diagnostics);
				}
			}
			BoundBlock body = BoundNodeExtensions.MakeCompilerGenerated(BindBlock(node, node.Statements, diagnostics));
			UsingInfo usingInfo = new UsingInfo(node, placeholderInfo);
			ImmutableArray<LocalSymbol> usingBlockLocals = GetUsingBlockLocals(binder);
			return new BoundUsingStatement(node, resourceList, boundExpression, body, usingInfo, usingBlockLocals);
		}

		private ImmutableArray<LocalSymbol> GetUsingBlockLocals(Binder currentBinder)
		{
			do
			{
				if (currentBinder is UsingBlockBinder usingBlockBinder)
				{
					return usingBlockBinder.Locals;
				}
				currentBinder = currentBinder.ContainingBinder;
			}
			while (currentBinder != null);
			return ImmutableArray<LocalSymbol>.Empty;
		}

		private void VerifyUsingVariableDeclarationAndBuildUsingInfo(SyntaxNode syntaxNode, LocalSymbol localSymbol, TypeSymbol iDisposable, Dictionary<TypeSymbol, (BoundRValuePlaceholder, BoundExpression, BoundExpression)> placeholderInfo, BindingDiagnosticBag diagnostics)
		{
			TypeSymbol type = localSymbol.Type;
			if (TypeSymbolExtensions.IsArrayType(type))
			{
				ReportDiagnostic(diagnostics, syntaxNode, ErrorFactory.ErrorInfo(ERRID.ERR_UsingResourceVarCantBeArray));
			}
			else if (!TypeSymbolExtensions.IsErrorType(type) && !TypeSymbolExtensions.IsErrorType(iDisposable))
			{
				BuildAndVerifyUsingInfo(syntaxNode, type, placeholderInfo, iDisposable, diagnostics);
				ReportMutableStructureConstraintsInUsing(type, localSymbol.Name, syntaxNode, diagnostics);
			}
		}

		private void BuildAndVerifyUsingInfo(SyntaxNode syntaxNode, TypeSymbol resourceType, Dictionary<TypeSymbol, (BoundRValuePlaceholder, BoundExpression, BoundExpression)> placeholderInfo, TypeSymbol iDisposable, BindingDiagnosticBag diagnostics)
		{
			if (placeholderInfo.ContainsKey(resourceType))
			{
				return;
			}
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
			ConversionKind conv = Conversions.ClassifyDirectCastConversion(resourceType, iDisposable, ref useSiteInfo);
			if (((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add(syntaxNode, useSiteInfo))
			{
				diagnostics = BindingDiagnosticBag.Discarded;
			}
			if (Conversions.IsWideningConversion(conv) || (TypeSymbolExtensions.IsObjectType(resourceType) && OptionStrict != OptionStrict.On))
			{
				BoundRValuePlaceholder boundRValuePlaceholder = new BoundRValuePlaceholder(syntaxNode, resourceType);
				BoundExpression item = null;
				BoundExpression item2 = null;
				if (!resourceType.IsValueType)
				{
					item = ApplyImplicitConversion(syntaxNode, iDisposable, boundRValuePlaceholder, diagnostics);
					item2 = BindIsExpression(boundRValuePlaceholder, new BoundLiteral(syntaxNode, ConstantValue.Nothing, null), syntaxNode, isNot: true, diagnostics);
				}
				placeholderInfo.Add(resourceType, (boundRValuePlaceholder, item, item2));
			}
			else
			{
				ReportDiagnostic(diagnostics, syntaxNode, ErrorFactory.ErrorInfo(ERRID.ERR_UsingRequiresDisposePattern, resourceType));
			}
		}

		private void ReportMutableStructureConstraintsInUsing(TypeSymbol type, string symbolName, SyntaxNode syntaxNode, BindingDiagnosticBag diagnostics)
		{
			if (type.IsReferenceType)
			{
				return;
			}
			if (TypeSymbolExtensions.IsTypeParameter(type))
			{
				if (type.IsValueType)
				{
					_ = (TypeParameterSymbol)type;
					bool flag = false;
					ImmutableArray<TypeSymbol>.Enumerator enumerator = ((TypeParameterSymbol)type).ConstraintTypesNoUseSiteDiagnostics.GetEnumerator();
					while (enumerator.MoveNext())
					{
						TypeSymbol current = enumerator.Current;
						if (current.IsValueType)
						{
							flag = true;
							if (ShouldReportMutableStructureInUsing(current))
							{
								ReportDiagnostic(diagnostics, syntaxNode, ErrorFactory.ErrorInfo(ERRID.WRN_MutableStructureInUsing, symbolName));
								return;
							}
						}
					}
					if (!flag)
					{
						ReportDiagnostic(diagnostics, syntaxNode, ErrorFactory.ErrorInfo(ERRID.WRN_MutableStructureInUsing, symbolName));
					}
				}
				else
				{
					ReportDiagnostic(diagnostics, syntaxNode, ErrorFactory.ErrorInfo(ERRID.WRN_MutableGenericStructureInUsing, symbolName));
				}
			}
			else if (ShouldReportMutableStructureInUsing(type))
			{
				ReportDiagnostic(diagnostics, syntaxNode, ErrorFactory.ErrorInfo(ERRID.WRN_MutableStructureInUsing, symbolName));
			}
		}

		private static bool ShouldReportMutableStructureInUsing(TypeSymbol structureType)
		{
			if (structureType.Kind == SymbolKind.NamedType && TypeSymbolExtensions.IsStructureType(structureType) && !TypeSymbolExtensions.IsEnumType(structureType) && !TypeSymbolExtensions.IsIntrinsicType(structureType))
			{
				ImmutableArray<Symbol>.Enumerator enumerator = structureType.GetMembersUnordered().GetEnumerator();
				while (enumerator.MoveNext())
				{
					Symbol current = enumerator.Current;
					if (current.Kind == SymbolKind.Field && !current.IsShared && !((FieldSymbol)current).IsReadOnly)
					{
						return true;
					}
				}
			}
			return false;
		}

		public BoundSyncLockStatement BindSyncLockBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockBlockSyntax node, BindingDiagnosticBag diagnostics)
		{
			BoundExpression boundExpression = BindRValue(node.SyncLockStatement.Expression, diagnostics);
			TypeSymbol type = boundExpression.Type;
			if (!boundExpression.HasErrors && !type.IsReferenceType)
			{
				ReportDiagnostic(diagnostics, boundExpression.Syntax, ErrorFactory.ErrorInfo(ERRID.ERR_SyncLockRequiresReferenceType1, type));
			}
			BoundBlock body = BoundNodeExtensions.MakeCompilerGenerated(BindBlock(node, node.Statements, diagnostics));
			return new BoundSyncLockStatement(node, boundExpression, body);
		}

		public BoundTryStatement BindTryBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.TryBlockSyntax node, BindingDiagnosticBag diagnostics)
		{
			BoundBlock tryBlock = BoundNodeExtensions.MakeCompilerGenerated(BindBlock(node, node.Statements, diagnostics));
			ImmutableArray<BoundCatchBlock> catchBlocks = BindCatchBlocks(node.CatchBlocks, diagnostics);
			BoundBlock boundBlock = ((node.FinallyBlock == null) ? null : GetBinder(node.FinallyBlock).BindBlock(node.FinallyBlock, node.FinallyBlock.Statements, diagnostics));
			if (catchBlocks.IsEmpty && boundBlock == null)
			{
				ReportDiagnostic(diagnostics, node.TryStatement, ERRID.ERR_TryWithoutCatchOrFinally);
			}
			Binder binder = GetBinder(node);
			return new BoundTryStatement(node, tryBlock, catchBlocks, boundBlock, binder.GetExitLabel(SyntaxKind.ExitTryStatement));
		}

		public ImmutableArray<BoundCatchBlock> BindCatchBlocks(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax> catchClauses, BindingDiagnosticBag diagnostics)
		{
			int count = catchClauses.Count;
			if (count == 0)
			{
				return ImmutableArray<BoundCatchBlock>.Empty;
			}
			ArrayBuilder<BoundCatchBlock> instance = ArrayBuilder<BoundCatchBlock>.GetInstance(count);
			SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax>.Enumerator enumerator = catchClauses.GetEnumerator();
			while (enumerator.MoveNext())
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax current = enumerator.Current;
				BoundCatchBlock item = GetBinder(current).BindCatchBlock(current, instance, diagnostics);
				instance.Add(item);
			}
			return instance.ToImmutableAndFree();
		}

		private BoundCatchBlock BindCatchBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax node, ArrayBuilder<BoundCatchBlock> previousBlocks, BindingDiagnosticBag diagnostics)
		{
			LocalSymbol localOpt = null;
			BoundExpression boundExpression = null;
			BoundExpression exceptionFilterOpt = null;
			bool flag = false;
			Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax catchStatement = node.CatchStatement;
			Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax identifierName = catchStatement.IdentifierName;
			Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause = catchStatement.AsClause;
			if (asClause != null)
			{
				localOpt = ((BoundLocal)(boundExpression = BindCatchVariableDeclaration(identifierName, asClause, diagnostics))).LocalSymbol;
			}
			else if (identifierName != null)
			{
				boundExpression = BindSimpleName(identifierName, isInvocationOrAddressOf: false, diagnostics);
			}
			TypeSymbol typeSymbol;
			if (boundExpression != null)
			{
				BoundExpression boundExpression2 = boundExpression;
				if (!BoundExpressionExtensions.IsValue(boundExpression) || (object)boundExpression.Type == null || TypeSymbolExtensions.IsVoidType(boundExpression.Type))
				{
					boundExpression = BoundNodeExtensions.MakeCompilerGenerated(BadExpression(boundExpression.Syntax, boundExpression, ErrorTypeSymbol.UnknownResultType));
				}
				typeSymbol = boundExpression.Type;
				if (boundExpression2.HasErrors)
				{
					flag = true;
				}
				else
				{
					BoundKind kind = boundExpression.Kind;
					if (kind != BoundKind.Parameter && (kind != BoundKind.Local || ((BoundLocal)boundExpression).LocalSymbol.IsStatic))
					{
						ReportDiagnostic(diagnostics, identifierName, ERRID.ERR_CatchVariableNotLocal1, identifierName.ToString());
						flag = true;
					}
					else
					{
						CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
						if (TypeSymbolExtensions.IsErrorType(typeSymbol))
						{
							flag = true;
						}
						else if (!TypeSymbolExtensions.IsOrDerivedFromWellKnownClass(typeSymbol, WellKnownType.System_Exception, Compilation, ref useSiteInfo))
						{
							ReportDiagnostic(diagnostics, (asClause != null) ? asClause.Type : identifierName, ERRID.ERR_CatchNotException1, typeSymbol);
							flag = true;
						}
						((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)((asClause != null) ? asClause.Type : identifierName), useSiteInfo);
					}
				}
			}
			else
			{
				typeSymbol = GetWellKnownType(WellKnownType.System_Exception, node, diagnostics);
			}
			Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchFilterClauseSyntax whenClause = catchStatement.WhenClause;
			if (whenClause != null)
			{
				exceptionFilterOpt = BindBooleanExpression(whenClause.Filter, diagnostics);
			}
			if (!flag)
			{
				ArrayBuilder<BoundCatchBlock>.Enumerator enumerator = previousBlocks.GetEnumerator();
				while (enumerator.MoveNext())
				{
					BoundCatchBlock current = enumerator.Current;
					if (current.ExceptionFilterOpt != null)
					{
						continue;
					}
					TypeSymbol typeSymbol2 = ((current.ExceptionSourceOpt == null) ? Compilation.GetWellKnownType(WellKnownType.System_Exception) : current.ExceptionSourceOpt.Type);
					if (!TypeSymbolExtensions.IsErrorType(typeSymbol2))
					{
						if (TypeSymbol.Equals(typeSymbol2, typeSymbol, TypeCompareKind.ConsiderEverything))
						{
							ReportDiagnostic(diagnostics, catchStatement, ERRID.WRN_DuplicateCatch, typeSymbol);
							break;
						}
						CompoundUseSiteInfo<AssemblySymbol> useSiteInfo2 = GetNewCompoundUseSiteInfo(diagnostics);
						bool num = TypeSymbolExtensions.IsOrDerivedFrom(typeSymbol, typeSymbol2, ref useSiteInfo2);
						((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)catchStatement, useSiteInfo2);
						if (num)
						{
							ReportDiagnostic(diagnostics, catchStatement, ERRID.WRN_OverlappingCatch, typeSymbol, typeSymbol2);
							break;
						}
					}
				}
			}
			BoundBlock body = BoundNodeExtensions.MakeCompilerGenerated(BindBlock(node, node.Statements, diagnostics));
			return new BoundCatchBlock(node, localOpt, boundExpression, null, exceptionFilterOpt, body, isSynthesizedAsyncCatchAll: false, flag);
		}

		private BoundStatement BindExitStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax node, BindingDiagnosticBag diagnostics)
		{
			LabelSymbol exitLabel = GetExitLabel(node.Kind());
			if ((object)exitLabel == null)
			{
				ERRID id = default(ERRID);
				switch (node.Kind())
				{
				case SyntaxKind.ExitWhileStatement:
					id = ERRID.ERR_ExitWhileNotWithinWhile;
					break;
				case SyntaxKind.ExitTryStatement:
					id = ERRID.ERR_ExitTryNotWithinTry;
					break;
				case SyntaxKind.ExitDoStatement:
					id = ERRID.ERR_ExitDoNotWithinDo;
					break;
				case SyntaxKind.ExitForStatement:
					id = ERRID.ERR_ExitForNotWithinFor;
					break;
				case SyntaxKind.ExitSelectStatement:
					id = ERRID.ERR_ExitSelectNotWithinSelect;
					break;
				case SyntaxKind.ExitSubStatement:
					id = ERRID.ERR_ExitSubOfFunc;
					break;
				case SyntaxKind.ExitFunctionStatement:
					id = ERRID.ERR_ExitFuncOfSub;
					break;
				case SyntaxKind.ExitPropertyStatement:
					id = ERRID.ERR_ExitPropNot;
					break;
				default:
					ExceptionUtilities.UnexpectedValue(node.Kind());
					break;
				}
				ReportDiagnostic(diagnostics, node, id);
				return new BoundBadStatement(node, ImmutableArray<BoundNode>.Empty, hasErrors: true);
			}
			return new BoundExitStatement(node, exitLabel);
		}

		private BoundStatement BindContinueStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax node, BindingDiagnosticBag diagnostics)
		{
			LabelSymbol continueLabel = GetContinueLabel(node.Kind());
			if ((object)continueLabel == null)
			{
				ERRID id = default(ERRID);
				switch (node.Kind())
				{
				case SyntaxKind.ContinueWhileStatement:
					id = ERRID.ERR_ContinueWhileNotWithinWhile;
					break;
				case SyntaxKind.ContinueDoStatement:
					id = ERRID.ERR_ContinueDoNotWithinDo;
					break;
				case SyntaxKind.ContinueForStatement:
					id = ERRID.ERR_ContinueForNotWithinFor;
					break;
				default:
					ExceptionUtilities.UnexpectedValue(node.Kind());
					break;
				}
				ReportDiagnostic(diagnostics, node, id);
				return new BoundBadStatement(node, ImmutableArray<BoundNode>.Empty, hasErrors: true);
			}
			return new BoundContinueStatement(node, continueLabel);
		}

		private BoundExpression BindBooleanExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax node, BindingDiagnosticBag diagnostics)
		{
			BoundExpression expression = BindValue(node, diagnostics, isOperandOfConditionalBranch: true);
			NamedTypeSymbol specialType = GetSpecialType(SpecialType.System_Boolean, node, diagnostics);
			return ApplyImplicitConversion(node, specialType, expression, diagnostics, isOperandOfConditionalBranch: true);
		}

		private TypeSymbol GetCurrentReturnType(out bool isAsync, out bool isIterator, out TypeSymbol methodReturnType)
		{
			isAsync = false;
			isIterator = false;
			if (ContainingMember is MethodSymbol methodSymbol)
			{
				methodReturnType = methodSymbol.ReturnType;
				isAsync = methodSymbol.IsAsync;
				isIterator = !isAsync && methodSymbol.IsIterator;
				if (!methodSymbol.IsSub)
				{
					if (isAsync && methodSymbol.ReturnType.OriginalDefinition.Equals(Compilation.GetWellKnownType(WellKnownType.System_Threading_Tasks_Task_T)))
					{
						return ((NamedTypeSymbol)methodSymbol.ReturnType).TypeArgumentsNoUseSiteDiagnostics[0];
					}
					if (isAsync && methodSymbol.ReturnType.Equals(Compilation.GetWellKnownType(WellKnownType.System_Threading_Tasks_Task)))
					{
						return Compilation.GetSpecialType(SpecialType.System_Void);
					}
					if (isIterator)
					{
						return Compilation.GetSpecialType(SpecialType.System_Void);
					}
				}
				return methodReturnType;
			}
			methodReturnType = ErrorTypeSymbol.UnknownResultType;
			return methodReturnType;
		}

		private BoundStatement BindReturn(Microsoft.CodeAnalysis.VisualBasic.Syntax.ReturnStatementSyntax originalSyntax, BindingDiagnosticBag diagnostics)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression = originalSyntax.Expression;
			TypeSymbol methodReturnType = null;
			bool isAsync;
			bool isIterator;
			TypeSymbol currentReturnType = GetCurrentReturnType(out isAsync, out isIterator, out methodReturnType);
			LabelSymbol returnLabel = GetReturnLabel();
			if (BindingTopLevelScriptCode)
			{
				ReportDiagnostic(diagnostics, originalSyntax, ERRID.ERR_KeywordNotAllowedInScript, SyntaxFacts.GetText(SyntaxKind.ReturnKeyword));
				return new BoundReturnStatement(originalSyntax, null, null, returnLabel, hasErrors: true);
			}
			if (currentReturnType.SpecialType == SpecialType.System_Void)
			{
				if (expression != null)
				{
					ReportDiagnostic(diagnostics, originalSyntax, isIterator ? ERRID.ERR_BadReturnValueInIterator : ((isAsync && methodReturnType.SpecialType != SpecialType.System_Void) ? ERRID.ERR_ReturnFromNonGenericTaskAsync : ERRID.ERR_ReturnFromNonFunction));
					BoundExpression expr = BindValue(expression, diagnostics);
					expr = MakeRValueAndIgnoreDiagnostics(expr);
					return new BoundReturnStatement(originalSyntax, expr, null, returnLabel, hasErrors: true);
				}
				return new BoundReturnStatement(originalSyntax, null, null, returnLabel);
			}
			BoundExpression boundExpression = null;
			if (expression != null)
			{
				boundExpression = BindValue(expression, diagnostics);
			}
			if (boundExpression != null)
			{
				if ((object)currentReturnType == LambdaSymbol.ReturnTypeIsUnknown)
				{
					boundExpression = MakeRValueAndIgnoreDiagnostics(boundExpression);
				}
				else if ((object)currentReturnType != LambdaSymbol.ReturnTypeIsBeingInferred)
				{
					CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
					if (isAsync && !TypeSymbolExtensions.IsErrorType(currentReturnType) && methodReturnType.Equals(boundExpression.Type) && methodReturnType.OriginalDefinition.Equals(Compilation.GetWellKnownType(WellKnownType.System_Threading_Tasks_Task_T)) && !Conversions.ConversionExists(Conversions.ClassifyConversion(boundExpression, currentReturnType, this, ref useSiteInfo).Key))
					{
						if (!diagnostics.Add(boundExpression, useSiteInfo))
						{
							ReportDiagnostic(diagnostics, boundExpression.Syntax, ERRID.ERR_BadAsyncReturnOperand1, currentReturnType);
						}
						boundExpression = MakeRValueAndIgnoreDiagnostics(boundExpression);
					}
					else
					{
						diagnostics.Add(boundExpression, useSiteInfo);
						boundExpression = ApplyImplicitConversion(boundExpression.Syntax, currentReturnType, boundExpression, diagnostics);
					}
				}
			}
			if (boundExpression != null)
			{
				return new BoundReturnStatement(originalSyntax, boundExpression, GetLocalForFunctionValue(), returnLabel);
			}
			if (isAsync && (object)currentReturnType == LambdaSymbol.ReturnTypeIsBeingInferred)
			{
				return new BoundReturnStatement(originalSyntax, null, null, returnLabel);
			}
			ReportDiagnostic(diagnostics, originalSyntax, ERRID.ERR_ReturnWithoutValue);
			return new BoundReturnStatement(originalSyntax, null, null, returnLabel, hasErrors: true);
		}

		private TypeSymbol GetCurrentYieldType(Microsoft.CodeAnalysis.VisualBasic.Syntax.YieldStatementSyntax node, BindingDiagnosticBag diagnostics)
		{
			if (ContainingMember is MethodSymbol methodSymbol)
			{
				TypeSymbol returnType = methodSymbol.ReturnType;
				if (!methodSymbol.IsIterator)
				{
					ReportDiagnostic(diagnostics, node, ERRID.ERR_BadYieldInNonIteratorMethod);
				}
				if (!methodSymbol.IsSub)
				{
					switch ((returnType.OriginalDefinition is NamedTypeSymbol namedTypeSymbol) ? namedTypeSymbol.SpecialType : SpecialType.None)
					{
					case SpecialType.System_Collections_Generic_IEnumerable_T:
					case SpecialType.System_Collections_Generic_IEnumerator_T:
						return ((NamedTypeSymbol)returnType).TypeArgumentsNoUseSiteDiagnostics[0];
					case SpecialType.System_Collections_IEnumerable:
					case SpecialType.System_Collections_IEnumerator:
						return GetSpecialType(SpecialType.System_Object, node, diagnostics);
					}
				}
				if ((object)returnType == LambdaSymbol.ReturnTypeIsUnknown || (object)returnType == LambdaSymbol.ReturnTypeIsBeingInferred)
				{
					return returnType;
				}
			}
			return ErrorTypeSymbol.UnknownResultType;
		}

		private BoundStatement BindYield(Microsoft.CodeAnalysis.VisualBasic.Syntax.YieldStatementSyntax originalSyntax, BindingDiagnosticBag diagnostics)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression = originalSyntax.Expression;
			BoundExpression boundExpression = BindValue(expression, diagnostics);
			if (BindingTopLevelScriptCode)
			{
				ReportDiagnostic(diagnostics, originalSyntax, ERRID.ERR_KeywordNotAllowedInScript, SyntaxFacts.GetText(SyntaxKind.YieldKeyword));
				boundExpression = MakeRValueAndIgnoreDiagnostics(boundExpression);
				return new BoundYieldStatement(originalSyntax, boundExpression, hasErrors: true);
			}
			TypeSymbol currentYieldType = GetCurrentYieldType(originalSyntax, diagnostics);
			if ((object)currentYieldType == LambdaSymbol.ReturnTypeIsUnknown)
			{
				boundExpression = MakeRValueAndIgnoreDiagnostics(boundExpression);
			}
			else
			{
				if ((object)currentYieldType == LambdaSymbol.ReturnTypeIsBeingInferred)
				{
					return new BoundYieldStatement(originalSyntax, boundExpression, hasErrors: false, returnTypeIsBeingInferred: true);
				}
				boundExpression = ApplyImplicitConversion(boundExpression.Syntax, currentYieldType, boundExpression, diagnostics);
			}
			return new BoundYieldStatement(originalSyntax, boundExpression);
		}

		private BoundStatement BindThrow(Microsoft.CodeAnalysis.VisualBasic.Syntax.ThrowStatementSyntax node, BindingDiagnosticBag diagnostics)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression = node.Expression;
			bool hasErrors = false;
			if (expression == null)
			{
				VisualBasicSyntaxNode parent = node.Parent;
				bool flag = false;
				for (; parent != null; parent = parent.Parent)
				{
					switch (parent.Kind())
					{
					case SyntaxKind.CatchBlock:
						flag = true;
						break;
					default:
						if (!(parent is Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax))
						{
							continue;
						}
						break;
					case SyntaxKind.SingleLineFunctionLambdaExpression:
					case SyntaxKind.SingleLineSubLambdaExpression:
					case SyntaxKind.MultiLineFunctionLambdaExpression:
						continue;
					case SyntaxKind.FinallyBlock:
					case SyntaxKind.MultiLineSubLambdaExpression:
						break;
					}
					break;
				}
				if (!flag)
				{
					hasErrors = true;
					ReportDiagnostic(diagnostics, node, ERRID.ERR_MustBeInCatchToRethrow);
				}
				return new BoundThrowStatement(node, null, hasErrors);
			}
			BoundExpression boundExpression = BindRValue(expression, diagnostics);
			TypeSymbol type = boundExpression.Type;
			if (!TypeSymbolExtensions.IsErrorType(type))
			{
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
				if (!TypeSymbolExtensions.IsOrDerivedFromWellKnownClass(type, WellKnownType.System_Exception, Compilation, ref useSiteInfo))
				{
					hasErrors = true;
					ReportDiagnostic(diagnostics, node, ERRID.ERR_CantThrowNonException, type);
				}
				((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)node, useSiteInfo);
			}
			else
			{
				hasErrors = true;
			}
			return new BoundThrowStatement(node, boundExpression, hasErrors);
		}

		private BoundStatement BindError(Microsoft.CodeAnalysis.VisualBasic.Syntax.ErrorStatementSyntax node, BindingDiagnosticBag diagnostics)
		{
			BoundExpression expressionOpt = ApplyImplicitConversion(node.ErrorNumber, GetSpecialType(SpecialType.System_Int32, node.ErrorNumber, diagnostics), BindValue(node.ErrorNumber, diagnostics), diagnostics);
			return new BoundThrowStatement(node, expressionOpt);
		}

		private BoundResumeStatement BindResumeStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax node, BindingDiagnosticBag diagnostics)
		{
			if (IsInLambda)
			{
				ReportDiagnostic(diagnostics, node, ERRID.ERR_MultilineLambdasCannotContainOnError);
			}
			else if (IsInAsyncContext() || IsInIteratorContext())
			{
				ReportDiagnostic(diagnostics, node, ERRID.ERR_ResumablesCannotContainOnError);
			}
			switch (node.Kind())
			{
			case SyntaxKind.ResumeStatement:
				return new BoundResumeStatement(node);
			case SyntaxKind.ResumeNextStatement:
				return new BoundResumeStatement(node, isNext: true);
			case SyntaxKind.ResumeLabelStatement:
			{
				LabelSymbol labelSymbol = null;
				BoundExpression boundExpression = BindExpression(node.Label, diagnostics);
				if (boundExpression.Kind == BoundKind.Label)
				{
					BoundLabel boundLabel = (BoundLabel)boundExpression;
					labelSymbol = boundLabel.Label;
					return new BoundResumeStatement(node, labelSymbol, boundLabel, !IsValidLabelForGoto(labelSymbol, node.Label, diagnostics));
				}
				return new BoundResumeStatement(node, null, boundExpression, hasErrors: true);
			}
			default:
				throw ExceptionUtilities.UnexpectedValue(node.Kind());
			}
		}

		private BoundOnErrorStatement BindOnErrorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax node, BindingDiagnosticBag diagnostics)
		{
			if (IsInLambda)
			{
				ReportDiagnostic(diagnostics, node, ERRID.ERR_MultilineLambdasCannotContainOnError);
			}
			else if (IsInAsyncContext() || IsInIteratorContext())
			{
				ReportDiagnostic(diagnostics, node, ERRID.ERR_ResumablesCannotContainOnError);
			}
			switch (node.Kind())
			{
			case SyntaxKind.OnErrorGoToMinusOneStatement:
				return new BoundOnErrorStatement(node, OnErrorStatementKind.GoToMinusOne, null, null);
			case SyntaxKind.OnErrorGoToZeroStatement:
				return new BoundOnErrorStatement(node, OnErrorStatementKind.GoToZero, null, null);
			case SyntaxKind.OnErrorResumeNextStatement:
				return new BoundOnErrorStatement(node, OnErrorStatementKind.ResumeNext, null, null);
			case SyntaxKind.OnErrorGoToLabelStatement:
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax onErrorGoToStatementSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax)node;
				LabelSymbol labelSymbol = null;
				BoundExpression boundExpression = BindExpression(onErrorGoToStatementSyntax.Label, diagnostics);
				if (boundExpression.Kind == BoundKind.Label)
				{
					BoundLabel boundLabel = (BoundLabel)boundExpression;
					labelSymbol = boundLabel.Label;
					return new BoundOnErrorStatement(node, labelSymbol, boundLabel, !IsValidLabelForGoto(labelSymbol, onErrorGoToStatementSyntax.Label, diagnostics));
				}
				return new BoundOnErrorStatement(node, null, boundExpression, hasErrors: true);
			}
			default:
				throw ExceptionUtilities.UnexpectedValue(node.Kind());
			}
		}

		private BoundStatement BindStopStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.StopOrEndStatementSyntax stopStatementSyntax)
		{
			return new BoundStopStatement(stopStatementSyntax);
		}

		private BoundStatement BindEndStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.StopOrEndStatementSyntax endStatementSyntax, BindingDiagnosticBag diagnostics)
		{
			if (!Compilation.Options.OutputKind.IsApplication())
			{
				ReportDiagnostic(diagnostics, endStatementSyntax, ERRID.ERR_EndDisallowedInDllProjects);
			}
			return new BoundEndStatement(endStatementSyntax);
		}

		public TypeSymbol BindTypeSyntax(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax typeSyntax, BindingDiagnosticBag diagBag, bool suppressUseSiteError = false, bool inGetTypeContext = false, bool resolvingBaseType = false)
		{
			TypeSymbol typeSymbol = TypeBinder.BindTypeSyntax(typeSyntax, this, diagBag, suppressUseSiteError, resolvingBaseType);
			if (!inGetTypeContext)
			{
				ReportUseOfModuleOrVoidType(typeSyntax, typeSymbol, diagBag);
			}
			return typeSymbol;
		}

		internal Symbol BindTypeOrAliasSyntax(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax typeSyntax, BindingDiagnosticBag diagBag, bool suppressUseSiteError = false)
		{
			Symbol symbol = TypeBinder.BindTypeOrAliasSyntax(typeSyntax, this, diagBag, suppressUseSiteError, inGetTypeContext: false, resolvingBaseType: false);
			if (symbol is TypeSymbol type)
			{
				ReportUseOfModuleOrVoidType(typeSyntax, type, diagBag);
			}
			return symbol;
		}

		private static void ReportUseOfModuleOrVoidType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax typeSyntax, TypeSymbol type, BindingDiagnosticBag diagBag)
		{
			if (type.SpecialType == SpecialType.System_Void)
			{
				BadSymbolDiagnostic info = new BadSymbolDiagnostic(type, ERRID.ERR_BadUseOfVoid);
				ReportDiagnostic(diagBag, typeSyntax, info);
			}
			else if (TypeSymbolExtensions.IsModuleType(type))
			{
				BadSymbolDiagnostic info2 = new BadSymbolDiagnostic(type, ERRID.ERR_ModuleAsType1);
				ReportDiagnostic(diagBag, typeSyntax, info2);
			}
		}

		public NamespaceOrTypeSymbol BindNamespaceOrTypeSyntax(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax typeSyntax, BindingDiagnosticBag diagBag, bool suppressUseSiteError = false)
		{
			return TypeBinder.BindNamespaceOrTypeSyntax(typeSyntax, this, diagBag, suppressUseSiteError);
		}

		public Symbol BindNamespaceOrTypeOrAliasSyntax(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax typeSyntax, BindingDiagnosticBag diagBag, bool suppressUseSiteError = false)
		{
			return TypeBinder.BindNamespaceOrTypeOrAliasSyntax(typeSyntax, this, diagBag, suppressUseSiteError);
		}

		public NamedTypeSymbol ConstructAndValidateConstraints(NamedTypeSymbol genericType, ImmutableArray<TypeSymbol> typeArguments, VisualBasicSyntaxNode syntaxWhole, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax> syntaxArguments, BindingDiagnosticBag diagnostics)
		{
			if (genericType.Arity == 0)
			{
				return genericType;
			}
			bool flag;
			if (genericType.Arity != typeArguments.Length)
			{
				TypeSymbol[] array = new TypeSymbol[genericType.Arity - 1 + 1];
				int num = genericType.Arity - 1;
				for (int i = 0; i <= num; i++)
				{
					if (i < typeArguments.Length)
					{
						array[i] = typeArguments[i];
					}
					else
					{
						array[i] = genericType.TypeParameters[i].OriginalDefinition;
					}
				}
				typeArguments = array.AsImmutableOrNull();
				flag = false;
			}
			else
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax genericNameSyntax = null;
				switch (syntaxWhole.Kind())
				{
				case SyntaxKind.GenericName:
					genericNameSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax)syntaxWhole;
					break;
				case SyntaxKind.QualifiedName:
					genericNameSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax)((Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax)syntaxWhole).Right;
					break;
				}
				if (genericNameSyntax != null && SyntaxNodeExtensions.AllAreMissingIdentifierName(syntaxArguments) && IsUnboundTypeAllowed(genericNameSyntax))
				{
					return NamedTypeSymbolExtensions.AsUnboundGenericType(genericType);
				}
				flag = true;
			}
			NamedTypeSymbol namedTypeSymbol = genericType.Construct(typeArguments);
			if (flag && ShouldCheckConstraints)
			{
				ConstraintsHelper.CheckConstraintsForNonTuple(namedTypeSymbol, syntaxArguments, diagnostics, GetNewCompoundUseSiteInfo(diagnostics));
			}
			return (NamedTypeSymbol)TupleTypeSymbol.TransformToTupleIfCompatible(namedTypeSymbol);
		}

		internal static bool ReportUseSite(BindingDiagnosticBag diagBag, SyntaxNodeOrToken syntax, Symbol symbol)
		{
			UseSiteInfo<AssemblySymbol> useSiteInfo = symbol.GetUseSiteInfo();
			return ReportUseSite(diagBag, syntax, useSiteInfo);
		}

		internal ImmutableArray<MethodSymbol> GetAccessibleConstructors(NamedTypeSymbol type, [In][Out] ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
		{
			ImmutableArray<MethodSymbol> instanceConstructors = type.InstanceConstructors;
			if (instanceConstructors.IsEmpty)
			{
				return instanceConstructors;
			}
			ArrayBuilder<MethodSymbol> instance = ArrayBuilder<MethodSymbol>.GetInstance();
			ImmutableArray<MethodSymbol>.Enumerator enumerator = instanceConstructors.GetEnumerator();
			while (enumerator.MoveNext())
			{
				MethodSymbol current = enumerator.Current;
				if (IsAccessible(current, ref useSiteInfo))
				{
					instance.Add(current);
				}
			}
			return instance.ToImmutableAndFree();
		}

		public static void DisallowTypeCharacter(SyntaxToken identifier, BindingDiagnosticBag diagBag, ERRID errid = ERRID.ERR_TypecharNotallowed)
		{
			if (VisualBasicExtensions.GetTypeCharacter(identifier) != 0)
			{
				ReportDiagnostic(diagBag, identifier, errid);
			}
		}

		public static VarianceKind DecodeVariance(SyntaxToken varianceKeywordOpt)
		{
			return VisualBasicExtensions.Kind(varianceKeywordOpt) switch
			{
				SyntaxKind.None => VarianceKind.None, 
				SyntaxKind.InKeyword => VarianceKind.In, 
				SyntaxKind.OutKeyword => VarianceKind.Out, 
				_ => throw ExceptionUtilities.UnexpectedValue(VisualBasicExtensions.Kind(varianceKeywordOpt)), 
			};
		}

		public static SyntaxToken FindFirstKeyword(SyntaxTokenList syntax, params SyntaxKind[] keywordKinds)
		{
			SyntaxTokenList.Enumerator enumerator = syntax.GetEnumerator();
			while (enumerator.MoveNext())
			{
				SyntaxToken current = enumerator.Current;
				if (Array.IndexOf(keywordKinds, VisualBasicExtensions.Kind(current)) >= 0)
				{
					return current;
				}
			}
			return default(SyntaxToken);
		}

		public void ReportModifierError(SyntaxTokenList modifiers, ERRID errid, DiagnosticBag diagBag, params SyntaxKind[] keywordKinds)
		{
			SyntaxToken syntaxToken = FindFirstKeyword(modifiers, keywordKinds);
			if (VisualBasicExtensions.Kind(syntaxToken) == SyntaxKind.ProtectedKeyword)
			{
				SyntaxToken token = FindFirstKeyword(modifiers, s_friendKeyword);
				if (VisualBasicExtensions.Kind(token) != 0)
				{
					int num = Math.Min(syntaxToken.SpanStart, token.SpanStart);
					int num2 = Math.Max(syntaxToken.Span.End, token.Span.End);
					Location location = SyntaxTree.GetLocation(new TextSpan(num, num2 - num));
					ReportDiagnostic(diagBag, location, errid, syntaxToken.ToString() + " " + token);
					return;
				}
			}
			ReportDiagnostic(diagBag, syntaxToken, errid, syntaxToken.ToString());
		}

		internal static SourceMemberFlags MapKeywordToFlag(SyntaxToken syntax)
		{
			return VisualBasicExtensions.Kind(syntax) switch
			{
				SyntaxKind.PrivateKeyword => SourceMemberFlags.Private, 
				SyntaxKind.FriendKeyword => SourceMemberFlags.Friend, 
				SyntaxKind.ProtectedKeyword => SourceMemberFlags.Protected, 
				SyntaxKind.PublicKeyword => SourceMemberFlags.Public, 
				SyntaxKind.SharedKeyword => SourceMemberFlags.Shared, 
				SyntaxKind.ReadOnlyKeyword => SourceMemberFlags.ReadOnly, 
				SyntaxKind.WriteOnlyKeyword => SourceMemberFlags.WriteOnly, 
				SyntaxKind.OverloadsKeyword => SourceMemberFlags.Overloads, 
				SyntaxKind.OverridableKeyword => SourceMemberFlags.Overridable, 
				SyntaxKind.MustOverrideKeyword => SourceMemberFlags.MustOverride, 
				SyntaxKind.NotOverridableKeyword => SourceMemberFlags.NotOverridable, 
				SyntaxKind.OverridesKeyword => SourceMemberFlags.Overrides, 
				SyntaxKind.ShadowsKeyword => SourceMemberFlags.Shadows, 
				SyntaxKind.ConstKeyword => SourceMemberFlags.Const, 
				SyntaxKind.StaticKeyword => SourceMemberFlags.Static, 
				SyntaxKind.DefaultKeyword => SourceMemberFlags.Default, 
				SyntaxKind.WithEventsKeyword => SourceMemberFlags.WithEvents, 
				SyntaxKind.WideningKeyword => SourceMemberFlags.Widening, 
				SyntaxKind.NarrowingKeyword => SourceMemberFlags.Narrowing, 
				SyntaxKind.PartialKeyword => SourceMemberFlags.Partial, 
				SyntaxKind.DimKeyword => SourceMemberFlags.Dim, 
				SyntaxKind.MustInheritKeyword => SourceMemberFlags.MustInherit, 
				SyntaxKind.NotInheritableKeyword => SourceMemberFlags.NotInheritable, 
				SyntaxKind.AsyncKeyword => SourceMemberFlags.Async, 
				SyntaxKind.IteratorKeyword => SourceMemberFlags.Iterator, 
				_ => SourceMemberFlags.None, 
			};
		}

		public MemberModifiers DecodeModifiers(SyntaxTokenList syntax, SourceMemberFlags allowableModifiers, ERRID errIdBadModifier, Accessibility defaultAccessibility, DiagnosticBag diagBag)
		{
			SourceMemberFlags sourceMemberFlags = SourceMemberFlags.None;
			SyntaxToken syntaxToken = default(SyntaxToken);
			SyntaxToken syntaxToken2 = default(SyntaxToken);
			SyntaxToken syntaxToken3 = default(SyntaxToken);
			SyntaxToken syntaxToken4 = default(SyntaxToken);
			SyntaxTokenList.Enumerator enumerator = syntax.GetEnumerator();
			while (enumerator.MoveNext())
			{
				SyntaxToken current = enumerator.Current;
				SourceMemberFlags sourceMemberFlags2 = MapKeywordToFlag(current);
				if (sourceMemberFlags2 == SourceMemberFlags.None)
				{
					continue;
				}
				if ((sourceMemberFlags2 & allowableModifiers) == 0)
				{
					ReportDiagnostic(diagBag, current, errIdBadModifier, current.ToString());
				}
				else if ((sourceMemberFlags2 & sourceMemberFlags) != 0)
				{
					ReportDiagnostic(diagBag, current, ERRID.ERR_DuplicateSpecifier);
				}
				else if ((sourceMemberFlags2 & SourceMemberFlags.AllAccessibilityModifiers) != 0 && (sourceMemberFlags & SourceMemberFlags.AllAccessibilityModifiers) != 0 && ((sourceMemberFlags | sourceMemberFlags2) & SourceMemberFlags.AllAccessibilityModifiers) != (SourceMemberFlags.Protected | SourceMemberFlags.Friend) && ((sourceMemberFlags | sourceMemberFlags2) & SourceMemberFlags.AllAccessibilityModifiers) != (SourceMemberFlags.Private | SourceMemberFlags.Protected))
				{
					ReportDiagnostic(diagBag, current, ERRID.ERR_DuplicateAccessCategoryUsed);
				}
				else if ((sourceMemberFlags2 & SourceMemberFlags.AllOverrideModifiers) != 0 && (sourceMemberFlags & SourceMemberFlags.AllOverrideModifiers) != 0)
				{
					ReportDiagnostic(diagBag, current, ERRID.ERR_DuplicateModifierCategoryUsed);
				}
				else if ((sourceMemberFlags2 & SourceMemberFlags.AllWriteabilityModifiers) != 0 && (sourceMemberFlags & SourceMemberFlags.AllWriteabilityModifiers) != 0)
				{
					ReportDiagnostic(diagBag, current, ERRID.ERR_DuplicateWriteabilityCategoryUsed);
				}
				else if ((sourceMemberFlags2 & SourceMemberFlags.AllConversionModifiers) != 0 && (sourceMemberFlags & SourceMemberFlags.AllConversionModifiers) != 0)
				{
					ReportDiagnostic(diagBag, current, ERRID.ERR_DuplicateConversionCategoryUsed);
				}
				else if ((sourceMemberFlags2 & SourceMemberFlags.AllShadowingModifiers) != 0 && (sourceMemberFlags & SourceMemberFlags.AllShadowingModifiers) != 0)
				{
					ReportDiagnostic(diagBag, current, ERRID.ERR_BadSpecifierCombo2, "Overloads", "Shadows");
				}
				else if ((sourceMemberFlags2 & (SourceMemberFlags.Overrides | SourceMemberFlags.Overridable)) != 0 && (sourceMemberFlags & (SourceMemberFlags.Overrides | SourceMemberFlags.Overridable)) != 0)
				{
					ReportDiagnostic(diagBag, current, ERRID.ERR_OverridesImpliesOverridable);
				}
				else if ((sourceMemberFlags2 & SourceMemberFlags.PrivateOverridableModifiers) != 0 && (sourceMemberFlags & SourceMemberFlags.PrivateOverridableModifiers) != 0)
				{
					syntaxToken2 = current;
					sourceMemberFlags |= sourceMemberFlags2;
				}
				else if ((sourceMemberFlags2 & SourceMemberFlags.ShadowsAndOverrides) != 0 && (sourceMemberFlags & SourceMemberFlags.ShadowsAndOverrides) != 0)
				{
					ReportDiagnostic(diagBag, current, ERRID.ERR_BadSpecifierCombo2, "Overrides", "Shadows");
				}
				else if ((sourceMemberFlags2 & SourceMemberFlags.PrivateMustOverrideModifiers) != 0 && (sourceMemberFlags & SourceMemberFlags.PrivateMustOverrideModifiers) != 0)
				{
					syntaxToken3 = current;
					sourceMemberFlags |= sourceMemberFlags2;
				}
				else if ((sourceMemberFlags2 & SourceMemberFlags.PrivateNotOverridableModifiers) != 0 && (sourceMemberFlags & SourceMemberFlags.PrivateNotOverridableModifiers) != 0)
				{
					syntaxToken4 = current;
					sourceMemberFlags |= sourceMemberFlags2;
				}
				else if ((sourceMemberFlags2 & (SourceMemberFlags.WriteOnly | SourceMemberFlags.Iterator)) != 0 && (sourceMemberFlags & (SourceMemberFlags.WriteOnly | SourceMemberFlags.Iterator)) != 0)
				{
					ReportDiagnostic(diagBag, current, ERRID.ERR_BadSpecifierCombo2, "Iterator", "WriteOnly");
				}
				else if ((sourceMemberFlags2 & SourceMemberFlags.TypeInheritModifiers) != 0 && (sourceMemberFlags & SourceMemberFlags.TypeInheritModifiers) != 0)
				{
					ReportDiagnostic(diagBag, current, ERRID.ERR_BadSpecifierCombo2, "MustInherit", "NotInheritable");
					sourceMemberFlags |= sourceMemberFlags2;
				}
				else
				{
					if (sourceMemberFlags2 == SourceMemberFlags.Private || sourceMemberFlags2 == SourceMemberFlags.Protected)
					{
						syntaxToken = current;
					}
					sourceMemberFlags |= sourceMemberFlags2;
				}
			}
			Accessibility accessibility;
			if ((sourceMemberFlags & SourceMemberFlags.Public) != 0)
			{
				accessibility = Accessibility.Public;
			}
			else if ((sourceMemberFlags & (SourceMemberFlags.Protected | SourceMemberFlags.Friend)) == (SourceMemberFlags.Protected | SourceMemberFlags.Friend))
			{
				accessibility = Accessibility.ProtectedOrInternal;
			}
			else if ((sourceMemberFlags & (SourceMemberFlags.Private | SourceMemberFlags.Protected)) != (SourceMemberFlags.Private | SourceMemberFlags.Protected))
			{
				accessibility = (((sourceMemberFlags & SourceMemberFlags.Friend) != 0) ? Accessibility.Internal : (((sourceMemberFlags & SourceMemberFlags.Protected) != 0) ? Accessibility.Protected : (((sourceMemberFlags & SourceMemberFlags.Private) != 0) ? Accessibility.Private : defaultAccessibility)));
			}
			else
			{
				accessibility = Accessibility.ProtectedAndInternal;
				Parser.CheckFeatureAvailability(diagBag, syntaxToken.GetLocation(), ((VisualBasicSyntaxTree)syntaxToken.SyntaxTree).Options.LanguageVersion, Feature.PrivateProtected);
			}
			if (accessibility == Accessibility.Private)
			{
				if ((sourceMemberFlags & SourceMemberFlags.Overridable) != 0)
				{
					ReportDiagnostic(diagBag, syntaxToken2, ERRID.ERR_BadSpecifierCombo2, "Private", "Overridable");
				}
				else if ((sourceMemberFlags & SourceMemberFlags.MustOverride) != 0)
				{
					ReportDiagnostic(diagBag, syntaxToken3, ERRID.ERR_BadSpecifierCombo2, "Private", "MustOverride");
				}
				else if ((sourceMemberFlags & SourceMemberFlags.NotOverridable) != 0)
				{
					ReportDiagnostic(diagBag, syntaxToken4, ERRID.ERR_BadSpecifierCombo2, "Private", "NotOverridable");
				}
				sourceMemberFlags &= ~SourceMemberFlags.AllOverrideModifiers;
			}
			return new MemberModifiers(sourceMemberFlags, (SourceMemberFlags)accessibility);
		}

		private static SourceParameterFlags DecodeParameterModifiers(Symbol container, SyntaxTokenList modifiers, CheckParameterModifierDelegate checkModifier, BindingDiagnosticBag diagBag)
		{
			SourceParameterFlags sourceParameterFlags = (SourceParameterFlags)0;
			SyntaxTokenList.Enumerator enumerator = modifiers.GetEnumerator();
			SourceParameterFlags sourceParameterFlags2 = default(SourceParameterFlags);
			while (enumerator.MoveNext())
			{
				SyntaxToken current = enumerator.Current;
				switch (VisualBasicExtensions.Kind(current))
				{
				case SyntaxKind.ByRefKeyword:
					sourceParameterFlags2 = SourceParameterFlags.ByRef;
					break;
				case SyntaxKind.ByValKeyword:
					sourceParameterFlags2 = SourceParameterFlags.ByVal;
					break;
				case SyntaxKind.OptionalKeyword:
					sourceParameterFlags2 = SourceParameterFlags.Optional;
					break;
				case SyntaxKind.ParamArrayKeyword:
					sourceParameterFlags2 = SourceParameterFlags.ParamArray;
					break;
				}
				if (checkModifier != null)
				{
					sourceParameterFlags2 = checkModifier(container, current, sourceParameterFlags2, diagBag);
				}
				sourceParameterFlags |= sourceParameterFlags2;
			}
			return sourceParameterFlags;
		}

		public NamedTypeSymbol CreateNullableOf(TypeSymbol typeArgument, VisualBasicSyntaxNode syntax, VisualBasicSyntaxNode syntaxTypeArgument, BindingDiagnosticBag diagBag)
		{
			NamedTypeSymbol namedTypeSymbol = GetSpecialType(SpecialType.System_Nullable_T, syntax, diagBag).Construct(ImmutableArray.Create(typeArgument));
			if (ShouldCheckConstraints)
			{
				ArrayBuilder<TypeParameterDiagnosticInfo> instance = ArrayBuilder<TypeParameterDiagnosticInfo>.GetInstance();
				ArrayBuilder<TypeParameterDiagnosticInfo> useSiteDiagnosticsBuilder = null;
				ConstraintsHelper.CheckConstraints(namedTypeSymbol, instance, ref useSiteDiagnosticsBuilder, GetNewCompoundUseSiteInfo(diagBag));
				if (useSiteDiagnosticsBuilder != null)
				{
					instance.AddRange(useSiteDiagnosticsBuilder);
				}
				ArrayBuilder<TypeParameterDiagnosticInfo>.Enumerator enumerator = instance.GetEnumerator();
				while (enumerator.MoveNext())
				{
					diagBag.Add(enumerator.Current.UseSiteInfo, syntaxTypeArgument.GetLocation());
				}
				instance.Free();
			}
			return namedTypeSymbol;
		}

		public CompoundUseSiteInfo<AssemblySymbol> GetNewCompoundUseSiteInfo(BindingDiagnosticBag futureDestination)
		{
			return new CompoundUseSiteInfo<AssemblySymbol>(futureDestination, Compilation.Assembly);
		}

		public TypeSymbol ApplyArrayRankSpecifiersToType(TypeSymbol elementType, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax> arrayModifierSyntax, BindingDiagnosticBag diagnostics)
		{
			TypeSymbol typeSymbol = elementType;
			for (int i = arrayModifierSyntax.Count - 1; i >= 0; i += -1)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax arrayRankSpecifierSyntax = arrayModifierSyntax[i];
				if (arrayRankSpecifierSyntax.Rank > 32)
				{
					ReportDiagnostic(diagnostics, arrayRankSpecifierSyntax, ERRID.ERR_ArrayRankLimit);
				}
				typeSymbol = ArrayTypeSymbol.CreateVBArray(typeSymbol, default(ImmutableArray<CustomModifier>), arrayRankSpecifierSyntax.Rank, Compilation);
			}
			return typeSymbol;
		}

		public TypeSymbol ApplyArrayRankSpecifiersAndBoundsToType(TypeSymbol elementType, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax> arrayModifierSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax arrayBoundsOpt, BindingDiagnosticBag diagnostics)
		{
			TypeSymbol typeSymbol = elementType;
			typeSymbol = ApplyArrayRankSpecifiersToType(elementType, arrayModifierSyntax, diagnostics);
			if (arrayBoundsOpt != null)
			{
				int num = arrayBoundsOpt.Arguments.Count;
				if (num == 0)
				{
					num = 1;
				}
				if (num > 32)
				{
					ReportDiagnostic(diagnostics, arrayBoundsOpt, ERRID.ERR_ArrayRankLimit);
				}
				typeSymbol = ArrayTypeSymbol.CreateVBArray(typeSymbol, default(ImmutableArray<CustomModifier>), num, Compilation);
			}
			return typeSymbol;
		}

		public ArrayTypeSymbol CreateArrayOf(TypeSymbol elementType, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax> arrayModifierSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax arrayBoundsOpt, BindingDiagnosticBag diagnostics)
		{
			return (ArrayTypeSymbol)ApplyArrayRankSpecifiersAndBoundsToType(elementType, arrayModifierSyntax, arrayBoundsOpt, diagnostics);
		}

		private static bool HasDefaultType(SyntaxToken identifierSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClauseOptSyntax)
		{
			if (VisualBasicExtensions.GetTypeCharacter(identifierSyntax) == TypeCharacter.None)
			{
				return asClauseOptSyntax == null;
			}
			return false;
		}

		private static bool HasDefaultType(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax identifierSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClauseOptSyntax)
		{
			return HasDefaultType(identifierSyntax.Identifier, asClauseOptSyntax);
		}

		public static bool IsArrayType(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax identifierSyntax)
		{
			if (identifierSyntax.ArrayBounds == null)
			{
				return identifierSyntax.ArrayRankSpecifiers.Count > 0;
			}
			return true;
		}

		public TypeSymbol DecodeModifiedIdentifierType(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax modifiedIdentifier, TypeSymbol asClauseOrValueType, Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClauseSyntaxOpt, VisualBasicSyntaxNode initializerSyntaxOpt, Func<DiagnosticInfo> getRequireTypeDiagnosticInfoFunc, BindingDiagnosticBag diagBag, ModifiedIdentifierTypeDecoderContext decoderContext = ModifiedIdentifierTypeDecoderContext.None)
		{
			TypeSymbol typeSymbol = DecodeIdentifierType(modifiedIdentifier.Identifier, asClauseOrValueType, getRequireTypeDiagnosticInfoFunc, diagBag, decoderContext);
			if (modifiedIdentifier.Nullable.Node != null)
			{
				if (asClauseSyntaxOpt != null)
				{
					if (SyntaxExtensions.Type(asClauseSyntaxOpt).Kind() == SyntaxKind.NullableType)
					{
						ReportDiagnostic(diagBag, asClauseSyntaxOpt, ERRID.ERR_CantSpecifyNullableOnBoth);
						return typeSymbol;
					}
					if (asClauseSyntaxOpt.Kind() == SyntaxKind.AsNewClause)
					{
						ReportDiagnostic(diagBag, asClauseSyntaxOpt, ERRID.ERR_CantSpecifyAsNewAndNullable);
					}
					else
					{
						TypeSymbolExtensions.IsArrayType(asClauseOrValueType);
					}
				}
				if ((object)asClauseOrValueType == null && TypeSymbolExtensions.IsObjectType(typeSymbol))
				{
					if ((decoderContext & ModifiedIdentifierTypeDecoderContext.ParameterType) != 0)
					{
						ReportDiagnostic(diagBag, modifiedIdentifier, ERRID.ERR_NullableParameterMustSpecifyType);
					}
					else if ((decoderContext & ModifiedIdentifierTypeDecoderContext.LocalOrFieldType) != 0 && ((decoderContext & ModifiedIdentifierTypeDecoderContext.StaticLocalType) != 0 || (initializerSyntaxOpt == null && modifiedIdentifier.ArrayBounds == null)) && OptionInfer)
					{
						ReportDiagnostic(diagBag, modifiedIdentifier, ERRID.ERR_NullableImplicit);
					}
				}
				else if (!typeSymbol.IsValueType)
				{
					ReportDiagnostic(diagBag, modifiedIdentifier, ERRID.ERR_BadTypeArgForStructConstraintNull, typeSymbol);
				}
				else
				{
					typeSymbol = CreateNullableOf(typeSymbol, modifiedIdentifier, (asClauseSyntaxOpt != null) ? ((VisualBasicSyntaxNode)SyntaxExtensions.Type(asClauseSyntaxOpt)) : ((VisualBasicSyntaxNode)modifiedIdentifier), diagBag);
				}
			}
			if (IsArrayType(modifiedIdentifier))
			{
				if (asClauseSyntaxOpt != null)
				{
					if (SyntaxExtensions.Type(asClauseSyntaxOpt).Kind() == SyntaxKind.ArrayType)
					{
						ReportDiagnostic(diagBag, SyntaxExtensions.Type(asClauseSyntaxOpt), ERRID.ERR_CantSpecifyArraysOnBoth);
					}
					else if (SyntaxExtensions.Type(asClauseSyntaxOpt).Kind() != SyntaxKind.NullableType)
					{
					}
				}
				else if ((decoderContext & ModifiedIdentifierTypeDecoderContext.LambdaParameterType) == ModifiedIdentifierTypeDecoderContext.LambdaParameterType)
				{
					ReportDiagnostic(diagBag, modifiedIdentifier, ERRID.ERR_CantSpecifyParamsOnLambdaParamNoType);
				}
			}
			return ApplyArrayRankSpecifiersAndBoundsToType(typeSymbol, modifiedIdentifier.ArrayRankSpecifiers, modifiedIdentifier.ArrayBounds, diagBag);
		}

		public TypeSymbol DecodeModifiedIdentifierType(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax modifiedIdentifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClauseOpt, Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax initializerSyntaxOpt, Func<DiagnosticInfo> getRequireTypeDiagnosticInfoFunc, out TypeSymbol asClauseType, BindingDiagnosticBag diagBag, ModifiedIdentifierTypeDecoderContext decoderContext = ModifiedIdentifierTypeDecoderContext.None)
		{
			if (asClauseOpt != null)
			{
				asClauseType = BindTypeSyntax(SyntaxExtensions.Type(asClauseOpt), diagBag);
			}
			else
			{
				asClauseType = null;
			}
			return DecodeModifiedIdentifierType(modifiedIdentifier, asClauseType, asClauseOpt, initializerSyntaxOpt, getRequireTypeDiagnosticInfoFunc, diagBag, decoderContext);
		}

		public TypeSymbol DecodeModifiedIdentifierType(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax modifiedIdentifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClauseOpt, Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax initializerSyntaxOpt, Func<DiagnosticInfo> getRequireTypeDiagnosticInfoFunc, BindingDiagnosticBag diagBag, ModifiedIdentifierTypeDecoderContext decoderContext = ModifiedIdentifierTypeDecoderContext.None)
		{
			TypeSymbol asClauseType = null;
			return DecodeModifiedIdentifierType(modifiedIdentifier, asClauseOpt, initializerSyntaxOpt, getRequireTypeDiagnosticInfoFunc, out asClauseType, diagBag, decoderContext);
		}

		public TypeSymbol DecodeIdentifierType(SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClauseOpt, Func<DiagnosticInfo> getRequireTypeDiagnosticInfoFunc, ref TypeSymbol asClauseType, BindingDiagnosticBag diagBag)
		{
			if (asClauseOpt != null)
			{
				asClauseType = BindTypeSyntax(SyntaxExtensions.Type(asClauseOpt), diagBag);
			}
			else
			{
				asClauseType = null;
			}
			return DecodeIdentifierType(identifier, asClauseType, getRequireTypeDiagnosticInfoFunc, diagBag);
		}

		public TypeSymbol DecodeIdentifierType(SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClauseOpt, Func<DiagnosticInfo> getRequireTypeDiagnosticInfoFunc, BindingDiagnosticBag diagBag)
		{
			TypeSymbol asClauseType = null;
			return DecodeIdentifierType(identifier, asClauseOpt, getRequireTypeDiagnosticInfoFunc, ref asClauseType, diagBag);
		}

		public TypeSymbol DecodeIdentifierType(SyntaxToken identifier, TypeSymbol asClauseType, Func<DiagnosticInfo> getRequireTypeDiagnosticInfoFunc, BindingDiagnosticBag diagBag, ModifiedIdentifierTypeDecoderContext decoderContext = ModifiedIdentifierTypeDecoderContext.None)
		{
			TypeSymbol typeSymbol = null;
			string typeCharacterString = null;
			SpecialType specialTypeForTypeCharacter = GetSpecialTypeForTypeCharacter(VisualBasicExtensions.GetTypeCharacter(identifier), ref typeCharacterString);
			if (specialTypeForTypeCharacter != 0)
			{
				typeSymbol = GetSpecialType(specialTypeForTypeCharacter, identifier, diagBag);
			}
			if ((object)asClauseType != null)
			{
				if ((object)typeSymbol != null && (decoderContext & ModifiedIdentifierTypeDecoderContext.QueryRangeVariableType) == 0)
				{
					ReportDiagnostic(diagBag, identifier, ERRID.ERR_TypeCharWithType1, typeCharacterString);
				}
				return asClauseType;
			}
			if ((object)typeSymbol != null)
			{
				return typeSymbol;
			}
			if (getRequireTypeDiagnosticInfoFunc != null)
			{
				ReportDiagnostic(diagBag, identifier, getRequireTypeDiagnosticInfoFunc());
			}
			return GetSpecialType(SpecialType.System_Object, identifier, diagBag);
		}

		public static SpecialType GetSpecialTypeForTypeCharacter(TypeCharacter typeChar, ref string typeCharacterString)
		{
			SpecialType result = SpecialType.None;
			switch (typeChar)
			{
			case TypeCharacter.Decimal:
				result = SpecialType.System_Decimal;
				typeCharacterString = "@";
				break;
			case TypeCharacter.DecimalLiteral:
				result = SpecialType.System_Decimal;
				typeCharacterString = "D";
				break;
			case TypeCharacter.Double:
				result = SpecialType.System_Double;
				typeCharacterString = "#";
				break;
			case TypeCharacter.DoubleLiteral:
				result = SpecialType.System_Double;
				typeCharacterString = "R";
				break;
			case TypeCharacter.Integer:
				result = SpecialType.System_Int32;
				typeCharacterString = "%";
				break;
			case TypeCharacter.IntegerLiteral:
				result = SpecialType.System_Int32;
				typeCharacterString = "I";
				break;
			case TypeCharacter.Long:
				result = SpecialType.System_Int64;
				typeCharacterString = "&";
				break;
			case TypeCharacter.LongLiteral:
				result = SpecialType.System_Int64;
				typeCharacterString = "L";
				break;
			case TypeCharacter.ShortLiteral:
				result = SpecialType.System_Int16;
				typeCharacterString = "S";
				break;
			case TypeCharacter.Single:
				result = SpecialType.System_Single;
				typeCharacterString = "!";
				break;
			case TypeCharacter.SingleLiteral:
				result = SpecialType.System_Single;
				typeCharacterString = "F";
				break;
			case TypeCharacter.String:
				result = SpecialType.System_String;
				typeCharacterString = "$";
				break;
			case TypeCharacter.UIntegerLiteral:
				result = SpecialType.System_UInt32;
				typeCharacterString = "UI";
				break;
			case TypeCharacter.ULongLiteral:
				result = SpecialType.System_UInt64;
				typeCharacterString = "UL";
				break;
			case TypeCharacter.UShortLiteral:
				result = SpecialType.System_UInt16;
				typeCharacterString = "US";
				break;
			case TypeCharacter.None:
				typeCharacterString = null;
				break;
			default:
				throw ExceptionUtilities.UnexpectedValue(typeChar);
			}
			return result;
		}

		public static TypeCharacter ExtractTypeCharacter(SyntaxNode node)
		{
			TypeCharacter result = TypeCharacter.None;
			if (node != null)
			{
				switch (VisualBasicExtensions.Kind(node))
				{
				case SyntaxKind.IdentifierName:
					result = VisualBasicExtensions.GetTypeCharacter(((Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)node).Identifier);
					break;
				case SyntaxKind.GenericName:
					result = VisualBasicExtensions.GetTypeCharacter(((Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax)node).Identifier);
					break;
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
					result = ExtractTypeCharacter(((Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax)node).Name);
					break;
				}
			}
			return result;
		}

		public static bool DecodeOnOff(SyntaxToken keywordSyntax)
		{
			if (keywordSyntax.Node == null)
			{
				return true;
			}
			return VisualBasicExtensions.Kind(keywordSyntax) switch
			{
				SyntaxKind.OnKeyword => true, 
				SyntaxKind.OffKeyword => false, 
				_ => throw ExceptionUtilities.UnexpectedValue(VisualBasicExtensions.Kind(keywordSyntax)), 
			};
		}

		public static bool? DecodeTextBinary(SyntaxToken keywordSyntax)
		{
			return (keywordSyntax.Node == null) ? null : (VisualBasicExtensions.Kind(keywordSyntax) switch
			{
				SyntaxKind.TextKeyword => true, 
				SyntaxKind.BinaryKeyword => false, 
				_ => throw ExceptionUtilities.UnexpectedValue(VisualBasicExtensions.Kind(keywordSyntax)), 
			});
		}

		public ImmutableArray<ParameterSymbol> DecodeParameterListOfDelegateDeclaration(Symbol container, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax syntaxOpt, BindingDiagnosticBag diagBag)
		{
			if (syntaxOpt == null)
			{
				return ImmutableArray<ParameterSymbol>.Empty;
			}
			SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax> parameters = syntaxOpt.Parameters;
			ArrayBuilder<ParameterSymbol> instance = ArrayBuilder<ParameterSymbol>.GetInstance(parameters.Count);
			DecodeParameterList(container, isFromLambda: false, SourceMemberFlags.None, parameters, instance, s_checkDelegateParameterModifierCallback, diagBag);
			ImmutableArray<ParameterSymbol> result = instance.ToImmutable();
			instance.Free();
			return result;
		}

		public ImmutableArray<ParameterSymbol> DecodeParameterList(Symbol container, bool isFromLambda, SourceMemberFlags modifiers, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax syntaxOpt, BindingDiagnosticBag diagBag)
		{
			if (syntaxOpt == null)
			{
				return ImmutableArray<ParameterSymbol>.Empty;
			}
			ArrayBuilder<ParameterSymbol> instance = ArrayBuilder<ParameterSymbol>.GetInstance(syntaxOpt.Parameters.Count);
			MethodSymbol methodSymbol = container as MethodSymbol;
			CheckParameterModifierDelegate checkModifier = null;
			if ((object)methodSymbol != null && MethodSymbolExtensions.IsUserDefinedOperator(methodSymbol))
			{
				checkModifier = s_checkOperatorParameterModifierCallback;
			}
			DecodeParameterList(container, isFromLambda, modifiers, syntaxOpt.Parameters, instance, checkModifier, diagBag);
			ImmutableArray<TypeParameterSymbol> immutableArray = (((object)methodSymbol != null && !isFromLambda) ? methodSymbol.TypeParameters : ImmutableArray<TypeParameterSymbol>.Empty);
			int num = instance.Count - 1;
			for (int i = 0; i <= num; i++)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax parameterSyntax = syntaxOpt.Parameters[i];
				ParameterSymbol parameterSymbol = instance[i];
				if ((object)methodSymbol != null)
				{
					if (!methodSymbol.IsSub && !MethodSymbolExtensions.IsUserDefinedOperator(methodSymbol))
					{
						CheckReservedParameterName(container.Name, parameterSyntax, ERRID.ERR_ParamNameFunctionNameCollision, diagBag);
					}
					if (methodSymbol.MethodKind != MethodKind.DeclareMethod)
					{
						CheckParameterNameNotDuplicate(instance, i, parameterSyntax, parameterSymbol, diagBag);
					}
				}
				string name = parameterSymbol.Name;
				ImmutableArray<TypeParameterSymbol>.Enumerator enumerator = immutableArray.GetEnumerator();
				while (enumerator.MoveNext())
				{
					if (CaseInsensitiveComparison.Equals(enumerator.Current.Name, name))
					{
						ReportDiagnostic(diagBag, parameterSyntax.Identifier, ERRID.ERR_NameSameAsMethodTypeParam1, name);
						break;
					}
				}
			}
			ImmutableArray<ParameterSymbol> result = instance.ToImmutable();
			instance.Free();
			return result;
		}

		private static SourceParameterFlags CheckOperatorParameterModifier(Symbol container, SyntaxToken token, SourceParameterFlags flag, BindingDiagnosticBag diagnostics)
		{
			if ((flag & SourceParameterFlags.ByRef) != 0)
			{
				diagnostics.Add(ERRID.ERR_ByRefIllegal1, token.GetLocation(), SymbolExtensions.GetKindText(container));
				flag &= (SourceParameterFlags)253;
			}
			if ((flag & SourceParameterFlags.ParamArray) != 0)
			{
				diagnostics.Add(ERRID.ERR_ParamArrayIllegal1, token.GetLocation(), SymbolExtensions.GetKindText(container));
				flag &= (SourceParameterFlags)247;
			}
			if ((flag & SourceParameterFlags.Optional) != 0)
			{
				diagnostics.Add(ERRID.ERR_OptionalIllegal1, token.GetLocation(), SymbolExtensions.GetKindText(container));
				flag &= (SourceParameterFlags)251;
			}
			return flag;
		}

		public ImmutableArray<ParameterSymbol> DecodePropertyParameterList(PropertySymbol container, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax syntaxOpt, BindingDiagnosticBag diagBag)
		{
			if (syntaxOpt == null)
			{
				return ImmutableArray<ParameterSymbol>.Empty;
			}
			ArrayBuilder<ParameterSymbol> instance = ArrayBuilder<ParameterSymbol>.GetInstance(syntaxOpt.Parameters.Count);
			DecodeParameterList(container, isFromLambda: false, SourceMemberFlags.None, syntaxOpt.Parameters, instance, s_checkPropertyParameterModifierCallback, diagBag);
			int num = instance.Count - 1;
			for (int i = 0; i <= num; i++)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax syntax = syntaxOpt.Parameters[i];
				ParameterSymbol parameter = instance[i];
				if (CheckReservedParameterName("Value", syntax, ERRID.ERR_PropertySetParamCollisionWithValue, diagBag))
				{
					CheckReservedParameterName(container.Name, syntax, ERRID.ERR_ParamNameFunctionNameCollision, diagBag);
				}
				CheckParameterNameNotDuplicate(instance, i, syntax, parameter, diagBag);
			}
			ImmutableArray<ParameterSymbol> result = instance.ToImmutable();
			instance.Free();
			return result;
		}

		private static SourceParameterFlags CheckPropertyParameterModifier(Symbol container, SyntaxToken token, SourceParameterFlags flag, BindingDiagnosticBag diagnostics)
		{
			if (flag == SourceParameterFlags.ByRef)
			{
				Location location = token.GetLocation();
				diagnostics.Add(ERRID.ERR_ByRefIllegal1, location, SymbolExtensions.GetKindText(container), token.ToString());
				return flag & (SourceParameterFlags)253;
			}
			return flag;
		}

		private static bool CheckReservedParameterName(string reservedName, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax syntax, ERRID errorId, BindingDiagnosticBag diagnostics)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax identifier = syntax.Identifier;
			string valueText = identifier.Identifier.ValueText;
			if (CaseInsensitiveComparison.Equals(reservedName, valueText))
			{
				Location location = identifier.GetLocation();
				diagnostics.Add(errorId, location);
				return false;
			}
			return true;
		}

		internal static void CheckParameterNameNotDuplicate(ArrayBuilder<ParameterSymbol> @params, int nParams, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax syntax, ParameterSymbol parameter, BindingDiagnosticBag diagnostics)
		{
			string name = parameter.Name;
			int num = nParams - 1;
			for (int i = 0; i <= num; i++)
			{
				if (CaseInsensitiveComparison.Equals(@params[i].Name, name))
				{
					ReportDiagnostic(diagnostics, syntax.Identifier, ERRID.ERR_DuplicateParamName1, name);
					break;
				}
			}
		}

		public void DecodeParameterList(Symbol container, bool isFromLambda, SourceMemberFlags modifiers, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax> syntax, ArrayBuilder<ParameterSymbol> @params, CheckParameterModifierDelegate checkModifier, BindingDiagnosticBag diagBag)
		{
			int count = syntax.Count;
			int num = @params.Count;
			bool flag = false;
			bool flag2 = false;
			SourceParameterFlags sourceParameterFlags = (SourceParameterFlags)0;
			bool flag3 = false;
			int num2 = count - 1;
			for (int i = 0; i <= num2; i++)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax parameterSyntax = syntax[i];
				string valueText = parameterSyntax.Identifier.Identifier.ValueText;
				SourceParameterFlags sourceParameterFlags2 = (SourceParameterFlags)0;
				sourceParameterFlags2 = DecodeParameterModifiers(container, parameterSyntax.Modifiers, checkModifier, diagBag);
				if ((sourceParameterFlags & SourceParameterFlags.Optional) == SourceParameterFlags.Optional)
				{
					if ((sourceParameterFlags2 & SourceParameterFlags.ParamArray) == SourceParameterFlags.ParamArray && !flag3)
					{
						ReportDiagnostic(diagBag, parameterSyntax.Identifier.Identifier, ERRID.ERR_ParamArrayWithOptArgs);
						flag3 = true;
					}
					else if ((sourceParameterFlags2 & SourceParameterFlags.Optional) != SourceParameterFlags.Optional && !flag3)
					{
						ReportDiagnostic(diagBag, parameterSyntax.Identifier.Identifier, ERRID.ERR_ExpectedOptional);
						flag3 = true;
					}
				}
				if ((sourceParameterFlags & SourceParameterFlags.ParamArray) != 0 && !flag3)
				{
					ReportDiagnostic(diagBag, parameterSyntax, ERRID.ERR_ParamArrayMustBeLast);
					flag3 = true;
				}
				ParameterSymbol parameterSymbol = ((!isFromLambda) ? SourceComplexParameterSymbol.CreateFromSyntax(container, parameterSyntax, valueText, sourceParameterFlags2, num, this, checkModifier, diagBag) : UnboundLambdaParameterSymbol.CreateFromSyntax(parameterSyntax, valueText, sourceParameterFlags2, num, this, diagBag));
				num++;
				if (parameterSymbol.IsByRef && (modifiers & SourceMemberFlags.Async) == SourceMemberFlags.Async)
				{
					ReportDiagnostic(diagBag, parameterSyntax, ERRID.ERR_BadAsyncByRefParam);
				}
				else if (parameterSymbol.IsByRef && (modifiers & SourceMemberFlags.Iterator) == SourceMemberFlags.Iterator)
				{
					ReportDiagnostic(diagBag, parameterSyntax, ERRID.ERR_BadIteratorByRefParam);
				}
				else
				{
					TypeSymbol type = parameterSymbol.Type;
					if ((object)type != null)
					{
						if (TypeSymbolExtensions.IsArrayType(type))
						{
							TypeSymbol restrictedType = null;
							if (TypeSymbolExtensions.IsRestrictedArrayType(type, out restrictedType))
							{
								ReportDiagnostic(diagBag, parameterSyntax.AsClause.Type, ERRID.ERR_RestrictedType1, restrictedType);
							}
						}
						else if (parameterSymbol.IsByRef)
						{
							if (TypeSymbolExtensions.IsRestrictedType(type))
							{
								ReportDiagnostic(diagBag, parameterSyntax.AsClause.Type, ERRID.ERR_RestrictedType1, type);
							}
						}
						else if ((modifiers & (SourceMemberFlags.Async | SourceMemberFlags.Iterator)) != 0 && TypeSymbolExtensions.IsRestrictedType(type))
						{
							ReportDiagnostic(diagBag, parameterSyntax.AsClause.Type, ERRID.ERR_RestrictedResumableType1, type);
						}
					}
				}
				if (!isFromLambda && !TypeSymbolExtensions.IsErrorType(parameterSymbol.Type))
				{
					AccessCheck.VerifyAccessExposureForParameterType(container, parameterSymbol.Name, (parameterSyntax.AsClause != null) ? ((VisualBasicSyntaxNode)parameterSyntax.AsClause.Type) : ((VisualBasicSyntaxNode)parameterSyntax), parameterSymbol.Type, diagBag);
				}
				@params.Add(parameterSymbol);
				if (HasDefaultType(parameterSyntax.Identifier, parameterSyntax.AsClause))
				{
					flag = true;
				}
				else
				{
					flag2 = true;
				}
				sourceParameterFlags |= sourceParameterFlags2;
			}
			if (!flag || !flag2)
			{
				return;
			}
			int num3 = count - 1;
			for (int j = 0; j <= num3; j++)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax parameterSyntax2 = syntax[j];
				if (HasDefaultType(parameterSyntax2.Identifier, parameterSyntax2.AsClause))
				{
					ReportDiagnostic(diagBag, parameterSyntax2.Identifier, ERRID.ERR_ParamTypingInconsistency);
				}
			}
		}

		public MemberModifiers ValidateSharedPropertyAndMethodModifiers(SyntaxTokenList modifierList, MemberModifiers memberModifiers, bool isProperty, SourceMemberContainerTypeSymbol container, DiagnosticBag diagBag)
		{
			SourceMemberFlags sourceMemberFlags = memberModifiers.FoundFlags;
			if ((sourceMemberFlags & SourceMemberFlags.Shared) != 0 && (sourceMemberFlags & SourceMemberFlags.InvalidIfShared) != 0)
			{
				ReportModifierError(modifierList, isProperty ? ERRID.ERR_BadFlagsOnSharedProperty1 : ERRID.ERR_BadFlagsOnSharedMeth1, diagBag, InvalidModifiers.InvalidModifiersIfShared);
				sourceMemberFlags &= ~SourceMemberFlags.InvalidIfShared;
				memberModifiers = new MemberModifiers(sourceMemberFlags, memberModifiers.ComputedFlags);
			}
			switch (container.TypeKind)
			{
			case TypeKind.Module:
				if ((sourceMemberFlags & SourceMemberFlags.Overloads) != 0)
				{
					ReportModifierError(modifierList, ERRID.ERR_OverloadsModifierInModule, diagBag, SyntaxKind.OverloadsKeyword);
					sourceMemberFlags &= ~SourceMemberFlags.Overloads;
				}
				if ((sourceMemberFlags & SourceMemberFlags.InvalidInModule) != 0)
				{
					ReportModifierError(modifierList, isProperty ? ERRID.ERR_BadFlagsOnStdModuleProperty1 : ERRID.ERR_ModuleCantUseMethodSpecifier1, diagBag, InvalidModifiers.InvalidModifiersInModule);
					if ((sourceMemberFlags & SourceMemberFlags.Protected) != 0)
					{
						sourceMemberFlags &= ~SourceMemberFlags.Friend;
					}
					sourceMemberFlags &= ~SourceMemberFlags.InvalidInModule;
				}
				memberModifiers = new MemberModifiers(sourceMemberFlags, memberModifiers.ComputedFlags | SourceMemberFlags.Shared);
				break;
			case TypeKind.Interface:
				if ((sourceMemberFlags & SourceMemberFlags.InvalidInInterface) != 0)
				{
					ReportModifierError(modifierList, isProperty ? ERRID.ERR_BadInterfacePropertyFlags1 : ERRID.ERR_BadInterfaceMethodFlags1, diagBag, InvalidModifiers.InvalidModifiersInInterface);
					sourceMemberFlags &= ~SourceMemberFlags.InvalidInInterface;
				}
				memberModifiers = new MemberModifiers(sourceMemberFlags, memberModifiers.ComputedFlags | SourceMemberFlags.MustOverride);
				break;
			case TypeKind.Struct:
				if ((sourceMemberFlags & SourceMemberFlags.Protected) != 0 && (sourceMemberFlags & SourceMemberFlags.Overrides) == 0)
				{
					ReportModifierError(modifierList, isProperty ? ERRID.ERR_StructCantUseVarSpecifier1 : ERRID.ERR_StructureCantUseProtected, diagBag, SyntaxKind.ProtectedKeyword);
					sourceMemberFlags &= ~SourceMemberFlags.Protected;
					memberModifiers = new MemberModifiers(sourceMemberFlags, (memberModifiers.ComputedFlags & ~SourceMemberFlags.AccessibilityMask) | SourceMemberFlags.AccessibilityPrivate);
				}
				if ((sourceMemberFlags & SourceMemberFlags.AllOverrideModifiers) != 0)
				{
					ReportModifierError(modifierList, ERRID.ERR_StructCantUseVarSpecifier1, diagBag, SyntaxKind.OverridableKeyword, SyntaxKind.NotOverridableKeyword, SyntaxKind.MustOverrideKeyword);
					sourceMemberFlags &= ~SourceMemberFlags.AllOverrideModifiers;
				}
				break;
			}
			if (container.IsNotInheritable && (sourceMemberFlags & SourceMemberFlags.AllOverrideModifiers) != 0)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax containingTypeBlock = GetContainingTypeBlock(modifierList.First());
				if (containingTypeBlock != null && VisualBasicExtensions.Kind(FindFirstKeyword(containingTypeBlock.BlockStatement.Modifiers, s_notInheritableKeyword)) == SyntaxKind.None)
				{
					if ((sourceMemberFlags & SourceMemberFlags.MustOverride) != 0)
					{
						ReportModifierError(modifierList, ERRID.ERR_MustOverOnNotInheritPartClsMem1, diagBag, InvalidModifiers.InvalidModifiersInNotInheritableOtherPartialClass);
						sourceMemberFlags &= ~SourceMemberFlags.MustOverride;
					}
				}
				else
				{
					ReportModifierError(modifierList, ERRID.ERR_BadFlagsInNotInheritableClass1, diagBag, InvalidModifiers.InvalidModifiersInNotInheritableClass);
					sourceMemberFlags &= ~SourceMemberFlags.AllOverrideModifiers;
				}
				memberModifiers = new MemberModifiers(sourceMemberFlags, memberModifiers.ComputedFlags);
			}
			return memberModifiers;
		}

		public MemberModifiers ValidateEventModifiers(SyntaxTokenList modifierList, MemberModifiers memberModifiers, SourceMemberContainerTypeSymbol container, DiagnosticBag diagBag)
		{
			SourceMemberFlags sourceMemberFlags = memberModifiers.FoundFlags;
			switch (container.TypeKind)
			{
			case TypeKind.Module:
				if ((sourceMemberFlags & SourceMemberFlags.InvalidInModule) != 0)
				{
					ReportModifierError(modifierList, ERRID.ERR_ModuleCantUseEventSpecifier1, diagBag, InvalidModifiers.InvalidModifiersInModule);
					if ((sourceMemberFlags & SourceMemberFlags.Protected) != 0)
					{
						sourceMemberFlags &= ~SourceMemberFlags.Friend;
					}
					sourceMemberFlags &= ~SourceMemberFlags.InvalidInModule;
				}
				memberModifiers = new MemberModifiers(sourceMemberFlags, memberModifiers.ComputedFlags | SourceMemberFlags.Shared);
				break;
			case TypeKind.Interface:
				if ((sourceMemberFlags & SourceMemberFlags.InvalidInInterface) != 0)
				{
					ReportModifierError(modifierList, ERRID.ERR_InterfaceCantUseEventSpecifier1, diagBag, InvalidModifiers.InvalidModifiersInInterface);
					sourceMemberFlags &= ~SourceMemberFlags.InvalidInInterface;
				}
				memberModifiers = new MemberModifiers(sourceMemberFlags, memberModifiers.ComputedFlags | SourceMemberFlags.MustOverride);
				break;
			case TypeKind.Struct:
				if ((sourceMemberFlags & SourceMemberFlags.Protected) != 0)
				{
					ReportModifierError(modifierList, ERRID.ERR_StructureCantUseProtected, diagBag, SyntaxKind.ProtectedKeyword);
					sourceMemberFlags &= ~SourceMemberFlags.Protected;
					memberModifiers = new MemberModifiers(sourceMemberFlags, (memberModifiers.ComputedFlags & ~SourceMemberFlags.AccessibilityMask) | SourceMemberFlags.AccessibilityPrivate);
				}
				break;
			}
			return memberModifiers;
		}

		private static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax GetContainingTypeBlock(SyntaxToken modifierToken)
		{
			SyntaxNode parent = modifierToken.Parent;
			if (parent.Parent is Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax || parent.Parent is Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax)
			{
				parent = parent.Parent;
			}
			return parent.Parent as Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax;
		}

		public ConstantValue GetExpressionConstantValueIfAny(BoundExpression boundExpression, BindingDiagnosticBag diagnostics, ConstantContext context)
		{
			bool flag = false;
			while (true)
			{
				if (boundExpression.Kind == BoundKind.Local)
				{
					LocalSymbol localSymbol = ((BoundLocal)boundExpression).LocalSymbol;
					if (!localSymbol.IsConst)
					{
						ReportDiagnostic(diagnostics, boundExpression.Syntax, ERRID.ERR_RequiredConstExpr);
						return null;
					}
					return flag ? null : localSymbol.GetConstantValue(this);
				}
				if ((object)boundExpression.ConstantValueOpt != null)
				{
					break;
				}
				switch (boundExpression.Kind)
				{
				case BoundKind.DirectCast:
				{
					BoundDirectCast boundDirectCast = (BoundDirectCast)boundExpression;
					ConstantValue constantValue3 = CheckConversionForConstantExpression(boundDirectCast, boundDirectCast.Operand, diagnostics, context);
					return flag ? null : constantValue3;
				}
				case BoundKind.TryCast:
				{
					BoundTryCast boundTryCast = (BoundTryCast)boundExpression;
					ConstantValue constantValue2 = CheckConversionForConstantExpression(boundTryCast, boundTryCast.Operand, diagnostics, context);
					return flag ? null : constantValue2;
				}
				case BoundKind.Conversion:
				{
					BoundConversion boundConversion = (BoundConversion)boundExpression;
					ConstantValue constantValue = CheckConversionForConstantExpression(boundConversion, boundConversion.Operand, diagnostics, context);
					return flag ? null : constantValue;
				}
				case BoundKind.BinaryOperator:
				{
					BoundBinaryOperator boundBinaryOperator = (BoundBinaryOperator)boundExpression;
					GetExpressionConstantValueIfAny(boundBinaryOperator.Right, diagnostics, context);
					flag = true;
					boundExpression = boundBinaryOperator.Left;
					break;
				}
				case BoundKind.UnaryOperator:
					boundExpression = ((BoundUnaryOperator)boundExpression).Operand;
					break;
				case BoundKind.Parenthesized:
					boundExpression = ((BoundParenthesized)boundExpression).Expression;
					break;
				case BoundKind.BadExpression:
					return null;
				default:
					ReportDiagnostic(diagnostics, boundExpression.Syntax, ERRID.ERR_RequiredConstExpr);
					return null;
				}
			}
			return flag ? null : boundExpression.ConstantValueOpt;
		}

		private static bool IsNothingLiteralAllowedForAType(TypeSymbol type)
		{
			if (type.IsReferenceType)
			{
				return true;
			}
			if (TypeSymbolExtensions.IsEnumType(type))
			{
				return true;
			}
			SpecialType specialType = type.SpecialType;
			if ((uint)(specialType - 7) <= 9u || (uint)(specialType - 18) <= 1u)
			{
				return true;
			}
			return false;
		}

		private ConstantValue CheckConversionForConstantExpression(BoundExpression conv, BoundExpression operand, BindingDiagnosticBag diagnostics, ConstantContext context)
		{
			if (conv.HasErrors)
			{
				return null;
			}
			TypeSymbol type = conv.Type;
			TypeSymbol type2 = operand.Type;
			if (BoundExpressionExtensions.IsNothingLiteral(operand))
			{
				if (context == ConstantContext.Default && !IsNothingLiteralAllowedForAType(type))
				{
					ReportDiagnostic(diagnostics, operand.Syntax, ERRID.ERR_RequiredConstConversion2, type2 ?? GetSpecialType(SpecialType.System_Object, operand.Syntax, diagnostics), type);
					return null;
				}
				return operand.ConstantValueOpt;
			}
			ConstantValue expressionConstantValueIfAny = GetExpressionConstantValueIfAny(operand, diagnostics, context);
			if ((object)expressionConstantValueIfAny == null)
			{
				return null;
			}
			if (TypeSymbolExtensions.IsObjectType(type))
			{
				if (type2.IsReferenceType && expressionConstantValueIfAny.IsNothing)
				{
					return expressionConstantValueIfAny;
				}
				if (context == ConstantContext.ParameterDefaultValue && (IsNothingLiteralAllowedForAType(type2) || TypeSymbolExtensions.IsDateTimeType(type2) || TypeSymbolExtensions.IsDecimalType(type2)))
				{
					return expressionConstantValueIfAny;
				}
				ReportDiagnostic(diagnostics, operand.Syntax, ERRID.ERR_RequiredConstConversion2, type2, type);
				return null;
			}
			if (!expressionConstantValueIfAny.IsNothing)
			{
				if (context == ConstantContext.ParameterDefaultValue && TypeSymbolExtensions.IsNullableType(type))
				{
					if (TypeSymbolExtensions.IsSameTypeIgnoringAll(TypeSymbolExtensions.GetNullableUnderlyingType(type), type2))
					{
						return expressionConstantValueIfAny;
					}
					expressionConstantValueIfAny = ApplyConversion(operand.Syntax, TypeSymbolExtensions.GetNullableUnderlyingType(type), operand, isExplicit: true, BindingDiagnosticBag.Discarded).ConstantValueOpt;
					if ((object)expressionConstantValueIfAny != null)
					{
						return expressionConstantValueIfAny;
					}
				}
				ReportDiagnostic(diagnostics, operand.Syntax, ERRID.ERR_RequiredConstConversion2, type2, type);
				return null;
			}
			if (TypeSymbolExtensions.IsSameTypeIgnoringAll(type2, type))
			{
				return expressionConstantValueIfAny;
			}
			if (type2.IsReferenceType && (type.IsReferenceType || context == ConstantContext.ParameterDefaultValue))
			{
				return expressionConstantValueIfAny;
			}
			if (context == ConstantContext.ParameterDefaultValue && TypeSymbolExtensions.IsNullableType(type))
			{
				return expressionConstantValueIfAny;
			}
			ReportDiagnostic(diagnostics, operand.Syntax, ERRID.ERR_RequiredConstConversion2, type2, type);
			return null;
		}

		internal static string GetAccessorName(string name, MethodKind kind, bool isWinMd)
		{
			return kind switch
			{
				MethodKind.PropertyGet => "get_", 
				MethodKind.PropertySet => (!isWinMd) ? "set_" : "put_", 
				MethodKind.EventAdd => "add_", 
				MethodKind.EventRemove => "remove_", 
				MethodKind.EventRaise => "raise_", 
				_ => throw ExceptionUtilities.UnexpectedValue(kind), 
			} + name;
		}

		private BoundExpression BindXmlComment(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCommentSyntax syntax, XmlElementRootInfo rootInfoOpt, BindingDiagnosticBag diagnostics)
		{
			if (rootInfoOpt == null)
			{
				diagnostics = CheckXmlFeaturesAllowed(syntax, diagnostics);
			}
			BoundLiteral boundLiteral = CreateStringLiteral(syntax, GetXmlString(syntax.TextTokens), compilerGenerated: true, diagnostics);
			BoundExpression boundExpression = BindObjectCreationExpression(syntax, GetWellKnownType(WellKnownType.System_Xml_Linq_XComment, syntax, diagnostics), ImmutableArray.Create((BoundExpression)boundLiteral), diagnostics);
			return new BoundXmlComment(syntax, boundLiteral, boundExpression, boundExpression.Type);
		}

		private BoundExpression BindXmlDocument(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDocumentSyntax syntax, BindingDiagnosticBag diagnostics)
		{
			diagnostics = CheckXmlFeaturesAllowed(syntax, diagnostics);
			BoundExpression boundExpression = BindXmlDeclaration(syntax.Declaration, diagnostics);
			BoundExpression boundExpression2 = BindObjectCreationExpression(syntax, GetWellKnownType(WellKnownType.System_Xml_Linq_XDocument, syntax, diagnostics), ImmutableArray.Create(boundExpression, new BoundLiteral(syntax, ConstantValue.Nothing, null)), diagnostics);
			ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
			BindXmlContent(syntax.PrecedingMisc, instance, null, diagnostics);
			instance.Add(BindXmlContent(syntax.Root, null, diagnostics));
			BindXmlContent(syntax.FollowingMisc, instance, null, diagnostics);
			ImmutableArray<BoundExpression> childNodes = instance.ToImmutableAndFree();
			BoundXmlContainerRewriterInfo boundXmlContainerRewriterInfo = BindXmlContainerRewriterInfo(syntax, boundExpression2, childNodes, null, diagnostics);
			return new BoundXmlDocument(syntax, boundExpression, childNodes, boundXmlContainerRewriterInfo, boundExpression2.Type, boundXmlContainerRewriterInfo.HasErrors);
		}

		private BoundExpression BindXmlDeclaration(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax syntax, BindingDiagnosticBag diagnostics)
		{
			BoundLiteral boundLiteral = BindXmlDeclarationOption(syntax, syntax.Version, diagnostics);
			BoundLiteral boundLiteral2 = BindXmlDeclarationOption(syntax, syntax.Encoding, diagnostics);
			BoundLiteral boundLiteral3 = BindXmlDeclarationOption(syntax, syntax.Standalone, diagnostics);
			BoundExpression boundExpression = BindObjectCreationExpression(syntax, GetWellKnownType(WellKnownType.System_Xml_Linq_XDeclaration, syntax, diagnostics), ImmutableArray.Create((BoundExpression)boundLiteral, (BoundExpression)boundLiteral2, (BoundExpression)boundLiteral3), diagnostics);
			return new BoundXmlDeclaration(syntax, boundLiteral, boundLiteral2, boundLiteral3, boundExpression, boundExpression.Type);
		}

		private BoundLiteral BindXmlDeclarationOption(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax optionSyntax, BindingDiagnosticBag diagnostics)
		{
			if (optionSyntax == null)
			{
				return CreateStringLiteral(syntax, null, compilerGenerated: true, diagnostics);
			}
			Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax value = optionSyntax.Value;
			return CreateStringLiteral(value, GetXmlString(value.TextTokens), compilerGenerated: false, diagnostics);
		}

		private BoundExpression BindXmlProcessingInstruction(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlProcessingInstructionSyntax syntax, BindingDiagnosticBag diagnostics)
		{
			BoundLiteral boundLiteral = CreateStringLiteral(syntax, GetXmlName(syntax.Name), compilerGenerated: true, diagnostics);
			BoundLiteral boundLiteral2 = CreateStringLiteral(syntax, GetXmlString(syntax.TextTokens), compilerGenerated: true, diagnostics);
			BoundExpression boundExpression = BindObjectCreationExpression(syntax, GetWellKnownType(WellKnownType.System_Xml_Linq_XProcessingInstruction, syntax, diagnostics), ImmutableArray.Create((BoundExpression)boundLiteral, (BoundExpression)boundLiteral2), diagnostics);
			return new BoundXmlProcessingInstruction(syntax, boundLiteral, boundLiteral2, boundExpression, boundExpression.Type);
		}

		private BoundExpression BindXmlEmptyElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax syntax, XmlElementRootInfo rootInfoOpt, BindingDiagnosticBag diagnostics)
		{
			return BindXmlElement(syntax, syntax.Name, syntax.Attributes, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax>), rootInfoOpt, diagnostics);
		}

		private BoundExpression BindXmlElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax syntax, XmlElementRootInfo rootInfoOpt, BindingDiagnosticBag diagnostics)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementStartTagSyntax startTag = syntax.StartTag;
			return BindXmlElement(syntax, startTag.Name, startTag.Attributes, syntax.Content, rootInfoOpt, diagnostics);
		}

		private BoundExpression BindXmlElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax nameSyntax, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> attributes, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> content, XmlElementRootInfo rootInfoOpt, BindingDiagnosticBag diagnostics)
		{
			if (rootInfoOpt == null)
			{
				diagnostics = CheckXmlFeaturesAllowed(syntax, diagnostics);
				ArrayBuilder<KeyValuePair<string, string>> instance = ArrayBuilder<KeyValuePair<string, string>>.GetInstance();
				BoundExpression result = new XmlRootElementBinder(this).BindXmlElement(syntax, nameSyntax, attributes, content, new XmlElementRootInfo(this, syntax, instance), diagnostics);
				instance.Free();
				return result;
			}
			Dictionary<XmlName, BoundXmlAttribute> allAttributes = null;
			ArrayBuilder<BoundXmlAttribute> instance2 = ArrayBuilder<BoundXmlAttribute>.GetInstance();
			ArrayBuilder<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> instance3 = ArrayBuilder<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax>.GetInstance();
			Dictionary<string, string> dictionary = BindXmlnsAttributes(attributes, out allAttributes, instance2, instance3, rootInfoOpt.ImportedNamespaces, diagnostics);
			BoundExpression result2 = ((dictionary == null) ? this : new XmlElementBinder(this, dictionary)).BindXmlElementWithoutAddingNamespaces(syntax, nameSyntax, out allAttributes, instance2, instance3, content, rootInfoOpt, diagnostics);
			instance3.Free();
			instance2.Free();
			return result2;
		}

		private BoundExpression BindXmlElementWithoutAddingNamespaces(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax nameSyntax, out Dictionary<XmlName, BoundXmlAttribute> allAttributes, ArrayBuilder<BoundXmlAttribute> xmlnsAttributes, ArrayBuilder<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> otherAttributes, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> content, XmlElementRootInfo rootInfo, BindingDiagnosticBag diagnostics)
		{
			BoundExpression boundExpression;
			if (nameSyntax.Kind() == SyntaxKind.XmlEmbeddedExpression)
			{
				boundExpression = BindXmlEmbeddedExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax)nameSyntax, diagnostics);
			}
			else
			{
				bool fromImports = false;
				string prefix = null;
				string localName = null;
				string @namespace = null;
				boundExpression = BindXmlName((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax)nameSyntax, forElement: true, rootInfo, out fromImports, out prefix, out localName, out @namespace, diagnostics);
				if (fromImports)
				{
					AddImportedNamespaceIfNecessary(rootInfo.ImportedNamespaces, prefix, @namespace, forElement: true);
				}
			}
			if (TypeSymbolExtensions.IsObjectType(boundExpression.Type) && OptionStrict != OptionStrict.On)
			{
				NamedTypeSymbol wellKnownType = GetWellKnownType(WellKnownType.System_Xml_Linq_XName, syntax, diagnostics);
				boundExpression = ApplyDirectCastConversion(syntax, boundExpression, wellKnownType, diagnostics);
			}
			BoundExpression boundExpression2 = BindObjectCreationExpression(nameSyntax, GetWellKnownType(WellKnownType.System_Xml_Linq_XElement, nameSyntax, diagnostics), ImmutableArray.Create(boundExpression), diagnostics);
			ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
			ArrayBuilder<BoundXmlAttribute>.Enumerator enumerator = xmlnsAttributes.GetEnumerator();
			while (enumerator.MoveNext())
			{
				BoundXmlAttribute current = enumerator.Current;
				instance.Add(current);
			}
			BindXmlAttributes(out allAttributes, otherAttributes, instance, rootInfo, diagnostics);
			if (syntax.Kind() != SyntaxKind.XmlEmptyElement)
			{
				if (content.Count > 0)
				{
					BindXmlContent(content, instance, rootInfo, diagnostics);
				}
				else
				{
					instance.Add(CreateStringLiteral(syntax, string.Empty, compilerGenerated: true, diagnostics));
				}
			}
			ImmutableArray<BoundExpression> childNodes = instance.ToImmutableAndFree();
			BoundXmlContainerRewriterInfo boundXmlContainerRewriterInfo = BindXmlContainerRewriterInfo(syntax, boundExpression2, childNodes, rootInfo, diagnostics);
			return new BoundXmlElement(syntax, boundExpression, childNodes, boundXmlContainerRewriterInfo, boundExpression2.Type, boundXmlContainerRewriterInfo.HasErrors);
		}

		private BoundXmlContainerRewriterInfo BindXmlContainerRewriterInfo(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax syntax, BoundExpression objectCreation, ImmutableArray<BoundExpression> childNodes, XmlElementRootInfo rootInfoOpt, BindingDiagnosticBag diagnostics)
		{
			if (childNodes.Length == 0 && (rootInfoOpt == null || rootInfoOpt.ImportedNamespaces.Count == 0))
			{
				return new BoundXmlContainerRewriterInfo(objectCreation);
			}
			BoundRValuePlaceholder boundRValuePlaceholder = BoundNodeExtensions.MakeCompilerGenerated(new BoundRValuePlaceholder(syntax, objectCreation.Type));
			ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
			BoundMethodOrPropertyGroup xmlMethodOrPropertyGroup = GetXmlMethodOrPropertyGroup(syntax, GetWellKnownType(WellKnownType.System_Xml_Linq_XContainer, syntax, diagnostics), "Add", boundRValuePlaceholder, diagnostics);
			ImmutableArray<KeyValuePair<string, string>> inScopeXmlNamespaces = default(ImmutableArray<KeyValuePair<string, string>>);
			BoundRValuePlaceholder boundRValuePlaceholder2 = null;
			BoundRValuePlaceholder boundRValuePlaceholder3 = null;
			ImmutableArray<BoundExpression>.Enumerator enumerator = childNodes.GetEnumerator();
			while (enumerator.MoveNext())
			{
				BoundExpression current = enumerator.Current;
				if (current.Kind == BoundKind.XmlAttribute && ((BoundXmlAttribute)current).MatchesImport)
				{
					continue;
				}
				BoundExpression boundExpression = current;
				if (rootInfoOpt != null && boundExpression.Kind == BoundKind.XmlEmbeddedExpression && HasImportedXmlNamespaces && !TypeSymbolExtensions.IsIntrinsicOrEnumType(boundExpression.Type))
				{
					if (inScopeXmlNamespaces.IsDefault)
					{
						ArrayBuilder<KeyValuePair<string, string>> instance2 = ArrayBuilder<KeyValuePair<string, string>>.GetInstance();
						GetInScopeXmlNamespaces(instance2);
						inScopeXmlNamespaces = instance2.ToImmutableAndFree();
					}
					if (boundRValuePlaceholder2 == null)
					{
						ArrayTypeSymbol type = CreateArrayType(GetSpecialType(SpecialType.System_String, syntax, diagnostics));
						boundRValuePlaceholder2 = BoundNodeExtensions.MakeCompilerGenerated(new BoundRValuePlaceholder(syntax, type));
						ArrayTypeSymbol type2 = CreateArrayType(GetWellKnownType(WellKnownType.System_Xml_Linq_XNamespace, syntax, diagnostics));
						boundRValuePlaceholder3 = BoundNodeExtensions.MakeCompilerGenerated(new BoundRValuePlaceholder(syntax, type2));
					}
					boundExpression = rootInfoOpt.BindRemoveNamespaceAttributesInvocation(boundExpression, boundRValuePlaceholder2, boundRValuePlaceholder3, diagnostics);
				}
				instance.Add(BindInvocationExpressionIfGroupNotNothing(syntax, xmlMethodOrPropertyGroup, ImmutableArray.Create(boundExpression), diagnostics));
			}
			BoundRValuePlaceholder boundRValuePlaceholder4 = null;
			BoundExpression xmlnsAttributes = null;
			bool flag = rootInfoOpt != null && rootInfoOpt.Syntax == syntax;
			if (flag)
			{
				ArrayBuilder<KeyValuePair<string, string>> importedNamespaces = rootInfoOpt.ImportedNamespaces;
				for (int i = importedNamespaces.Count - 1; i >= 0; i += -1)
				{
					KeyValuePair<string, string> keyValuePair = importedNamespaces[i];
					BoundXmlAttribute item = BindXmlnsAttribute(syntax, keyValuePair.Key, keyValuePair.Value, diagnostics);
					instance.Add(BindInvocationExpressionIfGroupNotNothing(syntax, xmlMethodOrPropertyGroup, ImmutableArray.Create((BoundExpression)item), diagnostics));
				}
				boundRValuePlaceholder4 = rootInfoOpt.XmlnsAttributesPlaceholder;
				if (boundRValuePlaceholder4 != null)
				{
					xmlnsAttributes = BoundNodeExtensions.MakeCompilerGenerated(BindObjectCreationExpression(syntax, boundRValuePlaceholder4.Type, ImmutableArray<BoundExpression>.Empty, diagnostics));
					instance.Add(BindInvocationExpressionIfGroupNotNothing(syntax, xmlMethodOrPropertyGroup, ImmutableArray.Create((BoundExpression)boundRValuePlaceholder4), diagnostics));
				}
			}
			return new BoundXmlContainerRewriterInfo(flag, boundRValuePlaceholder, objectCreation, boundRValuePlaceholder4, xmlnsAttributes, boundRValuePlaceholder2, boundRValuePlaceholder3, flag ? rootInfoOpt.ImportedNamespaces.ToImmutable() : default(ImmutableArray<KeyValuePair<string, string>>), inScopeXmlNamespaces, instance.ToImmutableAndFree());
		}

		private BoundExpression BindRemoveNamespaceAttributesInvocation(VisualBasicSyntaxNode syntax, BoundExpression expr, BoundRValuePlaceholder prefixesPlaceholder, BoundRValuePlaceholder namespacesPlaceholder, out BoundRValuePlaceholder xmlnsAttributesPlaceholder, out BoundMethodOrPropertyGroup removeNamespacesGroup, BindingDiagnosticBag diagnostics)
		{
			if (xmlnsAttributesPlaceholder == null)
			{
				NamedTypeSymbol type = GetWellKnownType(WellKnownType.System_Collections_Generic_List_T, syntax, diagnostics).Construct(GetWellKnownType(WellKnownType.System_Xml_Linq_XAttribute, syntax, diagnostics));
				xmlnsAttributesPlaceholder = BoundNodeExtensions.MakeCompilerGenerated(new BoundRValuePlaceholder(syntax, type));
				removeNamespacesGroup = GetXmlMethodOrPropertyGroup(syntax, GetInternalXmlHelperType(syntax, diagnostics), "RemoveNamespaceAttributes", null, diagnostics);
			}
			return BoundNodeExtensions.MakeCompilerGenerated(BindInvocationExpressionIfGroupNotNothing(expr.Syntax, removeNamespacesGroup, ImmutableArray.Create(prefixesPlaceholder, namespacesPlaceholder, xmlnsAttributesPlaceholder, expr), diagnostics));
		}

		private ArrayTypeSymbol CreateArrayType(TypeSymbol elementType)
		{
			return ArrayTypeSymbol.CreateSZArray(elementType, ImmutableArray<CustomModifier>.Empty, Compilation);
		}

		private static XmlName GetXmlnsXmlName(string prefix)
		{
			string localName = (string.IsNullOrEmpty(prefix) ? "xmlns" : prefix);
			string @namespace = (string.IsNullOrEmpty(prefix) ? "" : "http://www.w3.org/2000/xmlns/");
			return new XmlName(localName, @namespace);
		}

		private BoundXmlAttribute BindXmlnsAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax syntax, string prefix, string namespaceName, BindingDiagnosticBag diagnostics)
		{
			BoundExpression prefix2 = BindXmlnsName(syntax, prefix, compilerGenerated: true, diagnostics);
			BoundExpression @namespace = BindXmlNamespace(syntax, CreateStringLiteral(syntax, namespaceName, compilerGenerated: true, diagnostics), diagnostics);
			return BindXmlnsAttribute(syntax, prefix2, @namespace, useConstructor: false, matchesImport: false, compilerGenerated: true, hasErrors: false, diagnostics);
		}

		private BoundExpression BindXmlnsName(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax syntax, string prefix, bool compilerGenerated, BindingDiagnosticBag diagnostics)
		{
			XmlName xmlnsXmlName = GetXmlnsXmlName(prefix);
			return BindXmlName(syntax, CreateStringLiteral(syntax, xmlnsXmlName.LocalName, compilerGenerated, diagnostics), CreateStringLiteral(syntax, xmlnsXmlName.XmlNamespace, compilerGenerated, diagnostics), diagnostics);
		}

		private BoundXmlAttribute BindXmlnsAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax syntax, BoundExpression prefix, BoundExpression @namespace, bool useConstructor, bool matchesImport, bool compilerGenerated, bool hasErrors, BindingDiagnosticBag diagnostics)
		{
			BoundExpression boundExpression;
			if (useConstructor)
			{
				boundExpression = BindObjectCreationExpression(syntax, GetWellKnownType(WellKnownType.System_Xml_Linq_XAttribute, syntax, diagnostics), ImmutableArray.Create(prefix, @namespace), diagnostics);
			}
			else
			{
				NamedTypeSymbol internalXmlHelperType = GetInternalXmlHelperType(syntax, diagnostics);
				BoundMethodOrPropertyGroup xmlMethodOrPropertyGroup = GetXmlMethodOrPropertyGroup(syntax, internalXmlHelperType, "CreateNamespaceAttribute", null, diagnostics);
				boundExpression = BindInvocationExpressionIfGroupNotNothing(syntax, xmlMethodOrPropertyGroup, ImmutableArray.Create(prefix, @namespace), diagnostics);
			}
			BoundXmlAttribute boundXmlAttribute = new BoundXmlAttribute(syntax, prefix, @namespace, matchesImport, boundExpression, boundExpression.Type, hasErrors);
			if (compilerGenerated)
			{
				boundXmlAttribute.SetWasCompilerGenerated();
			}
			return boundXmlAttribute;
		}

		private BoundXmlAttribute BindXmlAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax syntax, XmlElementRootInfo rootInfo, out XmlName xmlName, BindingDiagnosticBag diagnostics)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax name = syntax.Name;
			BoundExpression boundExpression;
			if (name.Kind() == SyntaxKind.XmlEmbeddedExpression)
			{
				boundExpression = BindXmlEmbeddedExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax)name, diagnostics);
				xmlName = default(XmlName);
			}
			else
			{
				bool fromImports = false;
				string prefix = null;
				string localName = null;
				string @namespace = null;
				boundExpression = BindXmlName((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax)name, forElement: false, rootInfo, out fromImports, out prefix, out localName, out @namespace, diagnostics);
				if (fromImports)
				{
					AddImportedNamespaceIfNecessary(rootInfo.ImportedNamespaces, prefix, @namespace, forElement: false);
				}
				xmlName = new XmlName(localName, @namespace);
			}
			Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax value = syntax.Value;
			bool matchesImport = false;
			BoundExpression boundExpression2;
			BoundExpression boundExpression3;
			if (value.Kind() == SyntaxKind.XmlEmbeddedExpression)
			{
				boundExpression2 = BindXmlEmbeddedExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax)value, diagnostics);
				BoundMethodOrPropertyGroup xmlMethodOrPropertyGroup = GetXmlMethodOrPropertyGroup(value, GetInternalXmlHelperType(syntax, diagnostics), "CreateAttribute", null, diagnostics);
				boundExpression3 = BindInvocationExpressionIfGroupNotNothing(value, xmlMethodOrPropertyGroup, ImmutableArray.Create(boundExpression, boundExpression2), diagnostics);
			}
			else
			{
				string xmlString = GetXmlString(((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax)value).TextTokens);
				matchesImport = name.Kind() == SyntaxKind.XmlName && MatchesXmlnsImport((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax)name, xmlString);
				boundExpression2 = CreateStringLiteral(value, xmlString, compilerGenerated: false, diagnostics);
				boundExpression3 = BindObjectCreationExpression(name, GetWellKnownType(WellKnownType.System_Xml_Linq_XAttribute, syntax, diagnostics), ImmutableArray.Create(boundExpression, boundExpression2), diagnostics);
			}
			return new BoundXmlAttribute(syntax, boundExpression, boundExpression2, matchesImport, boundExpression3, boundExpression3.Type);
		}

		private bool MatchesXmlnsImport(string prefix, string @namespace)
		{
			bool fromImports = false;
			string namespace2 = null;
			if (LookupXmlNamespace(prefix, ignoreXmlNodes: false, out namespace2, out fromImports) && fromImports)
			{
				return EmbeddedOperators.CompareString(@namespace, namespace2, TextCompare: false) == 0;
			}
			return false;
		}

		private bool MatchesXmlnsImport(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax name, string value)
		{
			string prefix = null;
			TryGetXmlnsPrefix(name, out prefix, BindingDiagnosticBag.Discarded);
			if (prefix == null)
			{
				return false;
			}
			return ContainingBinder.MatchesXmlnsImport(prefix, value);
		}

		private BoundExpression BindXmlEmbeddedExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax syntax, BindingDiagnosticBag diagnostics)
		{
			BoundExpression boundExpression = new XmlEmbeddedExpressionBinder(this).BindRValue(syntax.Expression, diagnostics);
			return new BoundXmlEmbeddedExpression(syntax, boundExpression, boundExpression.Type);
		}

		private void BindXmlAttributes(out Dictionary<XmlName, BoundXmlAttribute> allAttributes, ArrayBuilder<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> attributes, ArrayBuilder<BoundExpression> childNodeBuilder, XmlElementRootInfo rootInfo, BindingDiagnosticBag diagnostics)
		{
			ArrayBuilder<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax>.Enumerator enumerator = attributes.GetEnumerator();
			while (enumerator.MoveNext())
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax current = enumerator.Current;
				if (current.Kind() == SyntaxKind.XmlAttribute)
				{
					Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax xmlAttributeSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax)current;
					XmlName xmlName = default(XmlName);
					BoundXmlAttribute boundXmlAttribute = BindXmlAttribute(xmlAttributeSyntax, rootInfo, out xmlName, diagnostics);
					childNodeBuilder.Add(boundXmlAttribute);
					if (xmlName.LocalName != null)
					{
						AddXmlAttributeIfNotDuplicate(xmlAttributeSyntax.Name, xmlName, boundXmlAttribute, out allAttributes, diagnostics);
					}
				}
				else
				{
					BoundExpression item = BindXmlContent(current, rootInfo, diagnostics);
					childNodeBuilder.Add(item);
				}
			}
		}

		private void BindXmlContent(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> content, ArrayBuilder<BoundExpression> childNodeBuilder, XmlElementRootInfo rootInfoOpt, BindingDiagnosticBag diagnostics)
		{
			SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax>.Enumerator enumerator = content.GetEnumerator();
			while (enumerator.MoveNext())
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax current = enumerator.Current;
				childNodeBuilder.Add(BindXmlContent(current, rootInfoOpt, diagnostics));
			}
		}

		private BoundExpression BindXmlContent(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax syntax, XmlElementRootInfo rootInfoOpt, BindingDiagnosticBag diagnostics)
		{
			return syntax.Kind() switch
			{
				SyntaxKind.XmlProcessingInstruction => BindXmlProcessingInstruction((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlProcessingInstructionSyntax)syntax, diagnostics), 
				SyntaxKind.XmlComment => BindXmlComment((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCommentSyntax)syntax, rootInfoOpt, diagnostics), 
				SyntaxKind.XmlElement => BindXmlElement((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax)syntax, rootInfoOpt, diagnostics), 
				SyntaxKind.XmlEmptyElement => BindXmlEmptyElement((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax)syntax, rootInfoOpt, diagnostics), 
				SyntaxKind.XmlEmbeddedExpression => BindXmlEmbeddedExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax)syntax, diagnostics), 
				SyntaxKind.XmlCDataSection => BindXmlCData((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCDataSectionSyntax)syntax, rootInfoOpt, diagnostics), 
				SyntaxKind.XmlText => BindXmlText((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlTextSyntax)syntax, diagnostics), 
				_ => throw ExceptionUtilities.UnexpectedValue(syntax.Kind()), 
			};
		}

		private BoundExpression BindXmlAttributeAccess(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax syntax, BindingDiagnosticBag diagnostics)
		{
			diagnostics = CheckXmlFeaturesAllowed(syntax, diagnostics);
			BoundExpression boundExpression = BindXmlMemberAccessReceiver(syntax, diagnostics);
			Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax syntax2 = ((syntax.Name.Kind() == SyntaxKind.XmlName) ? ((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax)syntax.Name) : ((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlBracketedNameSyntax)syntax.Name).Name);
			BoundExpression item = BindXmlName(syntax2, forElement: false, diagnostics);
			TypeSymbol type = boundExpression.Type;
			BoundExpression boundExpression2 = null;
			if (type.SpecialType == SpecialType.System_Object)
			{
				ReportDiagnostic(diagnostics, syntax, ERRID.ERR_NoXmlAxesLateBinding);
			}
			else if (!TypeSymbolExtensions.IsErrorType(type))
			{
				BoundMethodOrPropertyGroup boundMethodOrPropertyGroup = null;
				NamedTypeSymbol wellKnownType = GetWellKnownType(WellKnownType.System_Xml_Linq_XElement, syntax, diagnostics);
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
				if (TypeSymbolExtensions.IsOrDerivedFrom(type, wellKnownType, ref useSiteInfo) || TypeSymbolExtensions.IsCompatibleWithGenericIEnumerableOfType(type, wellKnownType, ref useSiteInfo))
				{
					boundMethodOrPropertyGroup = GetXmlMethodOrPropertyGroup(syntax, GetInternalXmlHelperType(syntax, diagnostics), "AttributeValue", null, diagnostics);
				}
				((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)syntax, useSiteInfo);
				if (boundMethodOrPropertyGroup != null)
				{
					boundExpression2 = BindInvocationExpressionIfGroupNotNothing(syntax, boundMethodOrPropertyGroup, ImmutableArray.Create(boundExpression, item), diagnostics);
					boundExpression2 = MakeValue(boundExpression2, diagnostics);
				}
				else
				{
					ReportDiagnostic(diagnostics, syntax, ERRID.ERR_TypeDisallowsAttributes, type);
				}
			}
			if (boundExpression2 == null)
			{
				boundExpression2 = BadExpression(syntax, ImmutableArray.Create(boundExpression, item), Compilation.GetSpecialType(SpecialType.System_String));
			}
			return new BoundXmlMemberAccess(syntax, boundExpression2, boundExpression2.Type);
		}

		private BoundExpression BindXmlElementAccess(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax syntax, BindingDiagnosticBag diagnostics)
		{
			return BindXmlElementAccess(syntax, "Elements", ERRID.ERR_TypeDisallowsElements, diagnostics);
		}

		private BoundExpression BindXmlDescendantAccess(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax syntax, BindingDiagnosticBag diagnostics)
		{
			return BindXmlElementAccess(syntax, "Descendants", ERRID.ERR_TypeDisallowsDescendants, diagnostics);
		}

		private BoundExpression BindXmlElementAccess(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax syntax, string memberName, ERRID typeDisallowsError, BindingDiagnosticBag diagnostics)
		{
			diagnostics = CheckXmlFeaturesAllowed(syntax, diagnostics);
			BoundExpression boundExpression = BindXmlMemberAccessReceiver(syntax, diagnostics);
			BoundExpression boundExpression2 = BindXmlName(((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlBracketedNameSyntax)syntax.Name).Name, forElement: true, diagnostics);
			TypeSymbol type = boundExpression.Type;
			BoundExpression boundExpression3 = null;
			if (type.SpecialType == SpecialType.System_Object)
			{
				ReportDiagnostic(diagnostics, syntax, ERRID.ERR_NoXmlAxesLateBinding);
			}
			else if (!TypeSymbolExtensions.IsErrorType(type))
			{
				BoundMethodOrPropertyGroup boundMethodOrPropertyGroup = null;
				ImmutableArray<BoundExpression> arguments = default(ImmutableArray<BoundExpression>);
				NamedTypeSymbol wellKnownType = GetWellKnownType(WellKnownType.System_Xml_Linq_XContainer, syntax, diagnostics);
				CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
				if (TypeSymbolExtensions.IsOrDerivedFrom(type, wellKnownType, ref useSiteInfo))
				{
					boundMethodOrPropertyGroup = GetXmlMethodOrPropertyGroup(syntax, wellKnownType, memberName, boundExpression, diagnostics);
					arguments = ImmutableArray.Create(boundExpression2);
				}
				else if (TypeSymbolExtensions.IsCompatibleWithGenericIEnumerableOfType(type, wellKnownType, ref useSiteInfo))
				{
					boundMethodOrPropertyGroup = GetXmlMethodOrPropertyGroup(syntax, GetWellKnownType(WellKnownType.System_Xml_Linq_Extensions, syntax, diagnostics), memberName, null, diagnostics);
					arguments = ImmutableArray.Create(boundExpression, boundExpression2);
				}
				((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)syntax, useSiteInfo);
				if (boundMethodOrPropertyGroup != null)
				{
					boundExpression3 = BindInvocationExpressionIfGroupNotNothing(syntax, boundMethodOrPropertyGroup, arguments, diagnostics);
					boundExpression3 = MakeRValue(boundExpression3, diagnostics);
				}
				else
				{
					ReportDiagnostic(diagnostics, syntax, typeDisallowsError, type);
				}
			}
			if (boundExpression3 == null)
			{
				boundExpression3 = BadExpression(syntax, ImmutableArray.Create(boundExpression, boundExpression2), ErrorTypeSymbol.UnknownResultType);
			}
			return new BoundXmlMemberAccess(syntax, boundExpression3, boundExpression3.Type);
		}

		private BoundExpression BindXmlMemberAccessReceiver(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax syntax, BindingDiagnosticBag diagnostics)
		{
			if (syntax.Base == null)
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax correspondingConditionalAccessExpression = SyntaxNodeExtensions.GetCorrespondingConditionalAccessExpression(syntax);
				BoundExpression boundExpression = ((correspondingConditionalAccessExpression == null) ? TryBindOmittedLeftForXmlMemberAccess(syntax, diagnostics, this) : GetConditionalAccessReceiver(correspondingConditionalAccessExpression));
				if (boundExpression == null)
				{
					return ReportDiagnosticAndProduceBadExpression(diagnostics, syntax, ERRID.ERR_BadWithRef);
				}
				return boundExpression;
			}
			BoundExpression receiver = BindValue(syntax.Base, diagnostics);
			return AdjustReceiverValue(receiver, syntax, diagnostics);
		}

		private BoundExpression BindXmlName(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax syntax, bool forElement, BindingDiagnosticBag diagnostics)
		{
			bool fromImports = false;
			string prefix = null;
			string localName = null;
			string @namespace = null;
			return BindXmlName(syntax, forElement, null, out fromImports, out prefix, out localName, out @namespace, diagnostics);
		}

		private BoundExpression BindXmlName(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax syntax, bool forElement, XmlElementRootInfo rootInfoOpt, out bool fromImports, out string prefix, out string localName, out string @namespace, BindingDiagnosticBag diagnostics)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixSyntax prefix2 = syntax.Prefix;
			fromImports = false;
			localName = GetXmlName(syntax.LocalName);
			@namespace = null;
			BoundLiteral namespace2;
			if (prefix2 != null)
			{
				SyntaxToken name = prefix2.Name;
				prefix = GetXmlName(name);
				if (forElement && EmbeddedOperators.CompareString(prefix, "xmlns", TextCompare: false) == 0)
				{
					ReportDiagnostic(diagnostics, name, ERRID.ERR_IllegalXmlnsPrefix);
					return BadExpression(syntax, Compilation.GetSpecialType(SpecialType.System_String));
				}
				if (!LookupXmlNamespace(prefix, ignoreXmlNodes: false, out @namespace, out fromImports))
				{
					return ReportXmlNamespacePrefixNotDefined(syntax, prefix2.Name, prefix, compilerGenerated: false, diagnostics);
				}
				namespace2 = CreateStringLiteral(prefix2, @namespace, compilerGenerated: false, diagnostics);
			}
			else
			{
				prefix = "";
				if (forElement)
				{
					LookupXmlNamespace(prefix, ignoreXmlNodes: false, out @namespace, out fromImports);
				}
				else
				{
					@namespace = "";
				}
				namespace2 = CreateStringLiteral(syntax, @namespace, compilerGenerated: true, diagnostics);
			}
			BoundLiteral localName2 = CreateStringLiteral(syntax, localName, compilerGenerated: true, diagnostics);
			return BindXmlName(syntax, localName2, namespace2, diagnostics);
		}

		private static void AddImportedNamespaceIfNecessary(ArrayBuilder<KeyValuePair<string, string>> importedNamespaces, string prefix, string @namespace, bool forElement)
		{
			if (EmbeddedOperators.CompareString(@namespace, "", TextCompare: false) == 0)
			{
				if (!forElement || EmbeddedOperators.CompareString(prefix, "", TextCompare: false) == 0)
				{
					return;
				}
				prefix = "";
			}
			ArrayBuilder<KeyValuePair<string, string>>.Enumerator enumerator = importedNamespaces.GetEnumerator();
			do
			{
				if (!enumerator.MoveNext())
				{
					importedNamespaces.Add(new KeyValuePair<string, string>(prefix, @namespace));
					break;
				}
			}
			while (EmbeddedOperators.CompareString(enumerator.Current.Key, prefix, TextCompare: false) != 0);
		}

		private BoundExpression BindXmlName(VisualBasicSyntaxNode syntax, BoundExpression localName, BoundExpression @namespace, BindingDiagnosticBag diagnostics)
		{
			BoundMethodOrPropertyGroup xmlMethodOrPropertyGroup = GetXmlMethodOrPropertyGroup(syntax, GetWellKnownType(WellKnownType.System_Xml_Linq_XName, syntax, diagnostics), "Get", null, diagnostics);
			BoundExpression boundExpression = BindInvocationExpressionIfGroupNotNothing(syntax, xmlMethodOrPropertyGroup, ImmutableArray.Create(localName, @namespace), diagnostics);
			return new BoundXmlName(syntax, @namespace, localName, boundExpression, boundExpression.Type);
		}

		private BoundExpression BindGetXmlNamespace(Microsoft.CodeAnalysis.VisualBasic.Syntax.GetXmlNamespaceExpressionSyntax syntax, BindingDiagnosticBag diagnostics)
		{
			diagnostics = CheckXmlFeaturesAllowed(syntax, diagnostics);
			Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixNameSyntax name = syntax.Name;
			string @namespace = null;
			bool fromImports = false;
			BoundExpression namespace2;
			if (name != null)
			{
				SyntaxToken name2 = name.Name;
				string xmlName = GetXmlName(name2);
				namespace2 = ((!LookupXmlNamespace(xmlName, ignoreXmlNodes: false, out @namespace, out fromImports)) ? ((BoundExpression)ReportXmlNamespacePrefixNotDefined(name, name2, xmlName, compilerGenerated: false, diagnostics)) : ((BoundExpression)CreateStringLiteral(name, @namespace, compilerGenerated: false, diagnostics)));
			}
			else
			{
				LookupXmlNamespace("", ignoreXmlNodes: false, out @namespace, out fromImports);
				namespace2 = CreateStringLiteral(syntax, @namespace, compilerGenerated: true, diagnostics);
			}
			return BindXmlNamespace(syntax, namespace2, diagnostics);
		}

		private BoundExpression BindXmlNamespace(VisualBasicSyntaxNode syntax, BoundExpression @namespace, BindingDiagnosticBag diagnostics)
		{
			BoundMethodOrPropertyGroup xmlMethodOrPropertyGroup = GetXmlMethodOrPropertyGroup(syntax, GetWellKnownType(WellKnownType.System_Xml_Linq_XNamespace, syntax, diagnostics), "Get", null, diagnostics);
			BoundExpression boundExpression = BindInvocationExpressionIfGroupNotNothing(syntax, xmlMethodOrPropertyGroup, ImmutableArray.Create(@namespace), diagnostics);
			return new BoundXmlNamespace(syntax, @namespace, boundExpression, boundExpression.Type);
		}

		private BoundBadExpression ReportXmlNamespacePrefixNotDefined(VisualBasicSyntaxNode syntax, SyntaxToken prefixToken, string prefix, bool compilerGenerated, BindingDiagnosticBag diagnostics)
		{
			ReportDiagnostic(diagnostics, prefixToken, ERRID.ERR_UndefinedXmlPrefix, prefix);
			BoundBadExpression boundBadExpression = BadExpression(syntax, Compilation.GetSpecialType(SpecialType.System_String));
			if (compilerGenerated)
			{
				boundBadExpression.SetWasCompilerGenerated();
			}
			return boundBadExpression;
		}

		private BoundExpression BindXmlCData(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCDataSectionSyntax syntax, XmlElementRootInfo rootInfoOpt, BindingDiagnosticBag diagnostics)
		{
			if (rootInfoOpt == null)
			{
				diagnostics = CheckXmlFeaturesAllowed(syntax, diagnostics);
			}
			BoundLiteral boundLiteral = CreateStringLiteral(syntax, GetXmlString(syntax.TextTokens), compilerGenerated: true, diagnostics);
			BoundExpression boundExpression = BindObjectCreationExpression(syntax, GetWellKnownType(WellKnownType.System_Xml_Linq_XCData, syntax, diagnostics), ImmutableArray.Create((BoundExpression)boundLiteral), diagnostics);
			return new BoundXmlCData(syntax, boundLiteral, boundExpression, boundExpression.Type);
		}

		private BoundLiteral BindXmlText(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlTextSyntax syntax, BindingDiagnosticBag diagnostics)
		{
			return CreateStringLiteral(syntax, GetXmlString(syntax.TextTokens), compilerGenerated: false, diagnostics);
		}

		internal static string GetXmlString(SyntaxTokenList tokens)
		{
			switch (tokens.Count)
			{
			case 0:
				return string.Empty;
			case 1:
				return GetXmlString(tokens[0]);
			default:
			{
				PooledStringBuilder instance = PooledStringBuilder.GetInstance();
				StringBuilder builder = instance.Builder;
				SyntaxTokenList.Enumerator enumerator = tokens.GetEnumerator();
				while (enumerator.MoveNext())
				{
					SyntaxToken current = enumerator.Current;
					builder.Append(GetXmlString(current));
				}
				string result = builder.ToString();
				instance.Free();
				return result;
			}
			}
		}

		private static string GetXmlString(SyntaxToken token)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(token);
			if (syntaxKind - 695 <= SyntaxKind.List)
			{
				return token.ValueText;
			}
			throw ExceptionUtilities.UnexpectedValue(VisualBasicExtensions.Kind(token));
		}

		private BoundMethodOrPropertyGroup GetXmlMethodOrPropertyGroup(VisualBasicSyntaxNode syntax, NamedTypeSymbol type, string memberName, BoundExpression receiverOpt, BindingDiagnosticBag diagnostics)
		{
			if (TypeSymbolExtensions.IsErrorType(type))
			{
				return null;
			}
			BoundMethodOrPropertyGroup boundMethodOrPropertyGroup = null;
			LookupResult instance = LookupResult.GetInstance();
			CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
			LookupMember(instance, type, memberName, 0, LookupOptions.NoBaseClassLookup | LookupOptions.AllMethodsOfAnyArity | LookupOptions.IgnoreExtensionMethods, ref useSiteInfo);
			((BindingDiagnosticBag<AssemblySymbol>)diagnostics).Add((SyntaxNode)syntax, useSiteInfo);
			if (instance.IsGood)
			{
				_ = instance.Symbols[0];
				switch (instance.Symbols[0].Kind)
				{
				case SymbolKind.Method:
					boundMethodOrPropertyGroup = new BoundMethodGroup(syntax, null, instance.Symbols.ToDowncastedImmutable<MethodSymbol>(), instance.Kind, receiverOpt, QualificationKind.QualifiedViaValue);
					break;
				case SymbolKind.Property:
					boundMethodOrPropertyGroup = new BoundPropertyGroup(syntax, instance.Symbols.ToDowncastedImmutable<PropertySymbol>(), instance.Kind, receiverOpt, QualificationKind.QualifiedViaValue);
					break;
				}
			}
			if (boundMethodOrPropertyGroup == null)
			{
				ReportDiagnostic(diagnostics, syntax, instance.HasDiagnostic ? instance.Diagnostic : ErrorFactory.ErrorInfo(ERRID.ERR_NameNotMember2, memberName, type));
			}
			instance.Free();
			return boundMethodOrPropertyGroup;
		}

		private BoundExpression BindInvocationExpressionIfGroupNotNothing(SyntaxNode syntax, BoundMethodOrPropertyGroup groupOpt, ImmutableArray<BoundExpression> arguments, BindingDiagnosticBag diagnostics)
		{
			if (groupOpt == null)
			{
				return BadExpression(syntax, arguments, ErrorTypeSymbol.UnknownResultType);
			}
			return BindInvocationExpression(syntax, syntax, TypeCharacter.None, groupOpt, arguments, default(ImmutableArray<string>), diagnostics, null);
		}

		private BindingDiagnosticBag CheckXmlFeaturesAllowed(VisualBasicSyntaxNode syntax, BindingDiagnosticBag diagnostics)
		{
			if (TypeSymbolExtensions.IsErrorType(Compilation.GetWellKnownType(WellKnownType.System_Xml_Linq_XObject)))
			{
				ReportDiagnostic(diagnostics, syntax, ERRID.ERR_XmlFeaturesNotAvailable);
				return BindingDiagnosticBag.Discarded;
			}
			return diagnostics;
		}

		private BoundLiteral CreateStringLiteral(VisualBasicSyntaxNode syntax, string str, bool compilerGenerated, BindingDiagnosticBag diagnostics, bool hasErrors = false)
		{
			BoundLiteral boundLiteral = new BoundLiteral(syntax, ConstantValue.Create(str), GetSpecialType(SpecialType.System_String, syntax, diagnostics), hasErrors);
			if (compilerGenerated)
			{
				boundLiteral.SetWasCompilerGenerated();
			}
			return boundLiteral;
		}

		private Dictionary<string, string> BindXmlnsAttributes(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> attributes, out Dictionary<XmlName, BoundXmlAttribute> allAttributes, ArrayBuilder<BoundXmlAttribute> xmlnsAttributes, ArrayBuilder<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> otherAttributes, ArrayBuilder<KeyValuePair<string, string>> importedNamespaces, BindingDiagnosticBag diagnostics)
		{
			Dictionary<string, string> dictionary = null;
			SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax>.Enumerator enumerator = attributes.GetEnumerator();
			while (enumerator.MoveNext())
			{
				Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax current = enumerator.Current;
				Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax xmlAttributeSyntax = current as Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax;
				string prefix = null;
				string namespaceName = null;
				BoundExpression @namespace = null;
				bool hasErrors = false;
				if (xmlAttributeSyntax != null && TryGetXmlnsAttribute(xmlAttributeSyntax, out prefix, out namespaceName, out @namespace, out hasErrors, fromImport: false, diagnostics))
				{
					bool flag = !hasErrors && MatchesXmlnsImport(prefix, namespaceName);
					BoundXmlAttribute boundXmlAttribute = BindXmlnsAttribute(xmlAttributeSyntax, BindXmlnsName(xmlAttributeSyntax.Name, prefix, compilerGenerated: false, diagnostics), @namespace, useConstructor: true, flag, compilerGenerated: false, hasErrors, diagnostics);
					xmlnsAttributes.Add(boundXmlAttribute);
					if (hasErrors)
					{
						continue;
					}
					if (flag)
					{
						AddImportedNamespaceIfNecessary(importedNamespaces, prefix, namespaceName, forElement: false);
					}
					if (AddXmlAttributeIfNotDuplicate(xmlAttributeSyntax.Name, GetXmlnsXmlName(prefix), boundXmlAttribute, out allAttributes, diagnostics))
					{
						if (dictionary == null)
						{
							dictionary = new Dictionary<string, string>();
						}
						dictionary.Add(prefix, namespaceName);
					}
				}
				else
				{
					otherAttributes.Add(current);
				}
			}
			return dictionary;
		}

		private static bool AddXmlAttributeIfNotDuplicate(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax syntax, XmlName name, BoundXmlAttribute attribute, out Dictionary<XmlName, BoundXmlAttribute> allAttributes, BindingDiagnosticBag diagnostics)
		{
			if (allAttributes == null)
			{
				allAttributes = new Dictionary<XmlName, BoundXmlAttribute>(XmlNameComparer.Instance);
			}
			if (allAttributes.ContainsKey(name))
			{
				ReportDiagnostic(diagnostics, syntax, ERRID.ERR_DuplicateXmlAttribute, syntax.ToString());
				return false;
			}
			allAttributes.Add(name, attribute);
			return true;
		}

		private bool TryGetXmlnsAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax syntax, out string prefix, out string namespaceName, out BoundExpression @namespace, out bool hasErrors, bool fromImport, BindingDiagnosticBag diagnostics)
		{
			prefix = null;
			namespaceName = null;
			@namespace = null;
			hasErrors = false;
			if (syntax.Name.Kind() == SyntaxKind.XmlEmbeddedExpression)
			{
				return false;
			}
			Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax xmlNameSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax)syntax.Name;
			if (!TryGetXmlnsPrefix(xmlNameSyntax, out prefix, diagnostics))
			{
				return false;
			}
			Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax value = syntax.Value;
			if (value.Kind() != SyntaxKind.XmlString)
			{
				ReportDiagnostic(diagnostics, value, ERRID.ERR_EmbeddedExpression);
				hasErrors = true;
				if (!fromImport)
				{
					@namespace = BindXmlEmbeddedExpression((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax)value, diagnostics);
				}
			}
			else
			{
				namespaceName = GetXmlString(((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax)value).TextTokens);
				if (EmbeddedOperators.CompareString(prefix, "xmlns", TextCompare: false) == 0 || (EmbeddedOperators.CompareString(prefix, "xml", TextCompare: false) == 0 && EmbeddedOperators.CompareString(namespaceName, "http://www.w3.org/XML/1998/namespace", TextCompare: false) != 0))
				{
					ReportDiagnostic(diagnostics, xmlNameSyntax.LocalName, ERRID.ERR_ReservedXmlPrefix, prefix);
					hasErrors = true;
				}
				else if (!fromImport && string.IsNullOrEmpty(namespaceName) && !string.IsNullOrEmpty(prefix))
				{
					ReportDiagnostic(diagnostics, xmlNameSyntax.LocalName, ERRID.ERR_IllegalDefaultNamespace);
					hasErrors = true;
				}
				else if (RedefinesReservedXmlNamespace(syntax.Value, prefix, "xmlns", namespaceName, "http://www.w3.org/2000/xmlns/", diagnostics) || RedefinesReservedXmlNamespace(syntax.Value, prefix, "xml", namespaceName, "http://www.w3.org/XML/1998/namespace", diagnostics))
				{
					hasErrors = true;
				}
				if (!fromImport)
				{
					@namespace = CreateStringLiteral(value, namespaceName, compilerGenerated: false, diagnostics);
				}
			}
			return true;
		}

		private static bool RedefinesReservedXmlNamespace(VisualBasicSyntaxNode syntax, string prefix, string reservedPrefix, string @namespace, string reservedNamespace, BindingDiagnosticBag diagnostics)
		{
			if (EmbeddedOperators.CompareString(@namespace, reservedNamespace, TextCompare: false) == 0 && EmbeddedOperators.CompareString(prefix, reservedPrefix, TextCompare: false) != 0)
			{
				ReportDiagnostic(diagnostics, syntax, ERRID.ERR_ReservedXmlNamespace, prefix, reservedPrefix);
				return true;
			}
			return false;
		}

		private bool TryGetXmlnsPrefix(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax syntax, out string prefix, BindingDiagnosticBag diagnostics)
		{
			string xmlName = GetXmlName(syntax.LocalName);
			string text = null;
			if (syntax.Prefix != null)
			{
				text = GetXmlName(syntax.Prefix.Name);
				if (EmbeddedOperators.CompareString(text, "xmlns", TextCompare: false) == 0)
				{
					prefix = xmlName;
					return true;
				}
			}
			if (EmbeddedOperators.CompareString(xmlName, "xmlns", TextCompare: false) == 0)
			{
				if (!string.IsNullOrEmpty(text))
				{
					bool fromImports = false;
					string @namespace = null;
					if (!LookupXmlNamespace(text, ignoreXmlNodes: true, out @namespace, out fromImports) || EmbeddedOperators.CompareString(@namespace, "", TextCompare: false) != 0)
					{
						ReportDiagnostic(diagnostics, syntax, ERRID.WRN_PrefixAndXmlnsLocalName, text);
						prefix = null;
						return false;
					}
					ReportDiagnostic(diagnostics, syntax, ERRID.WRN_EmptyPrefixAndXmlnsLocalName);
				}
				prefix = string.Empty;
				return true;
			}
			prefix = null;
			return false;
		}

		private static string GetXmlName(SyntaxToken token)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(token);
			if (syntaxKind == SyntaxKind.XmlNameToken)
			{
				return token.ValueText;
			}
			throw ExceptionUtilities.UnexpectedValue(VisualBasicExtensions.Kind(token));
		}
	}
}
