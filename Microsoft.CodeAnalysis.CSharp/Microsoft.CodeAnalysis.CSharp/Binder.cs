using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;

using Microsoft.Cci;
using Microsoft.CodeAnalysis.CSharp.CodeGen;
using Microsoft.CodeAnalysis.CSharp.Emit.NoPia;
using Microsoft.CodeAnalysis.CSharp.Symbols;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.PooledObjects;
using Microsoft.CodeAnalysis.RuntimeMembers;
using Microsoft.CodeAnalysis.Text;

using Roslyn.Utilities;

#nullable enable

namespace Microsoft.CodeAnalysis.CSharp
{
    public class Binder
    {
        public readonly struct NamespaceOrTypeOrAliasSymbolWithAnnotations
        {
            private readonly TypeWithAnnotations _typeWithAnnotations;

            private readonly Symbol _symbol;

            private readonly bool _isNullableEnabled;

            internal TypeWithAnnotations TypeWithAnnotations => _typeWithAnnotations;

            internal Symbol Symbol => _symbol ?? TypeWithAnnotations.Type;

            internal bool IsType => !_typeWithAnnotations.IsDefault;

            internal bool IsAlias
            {
                get
                {
                    Symbol symbol = _symbol;
                    if ((object)symbol == null)
                    {
                        return false;
                    }
                    return symbol.Kind == SymbolKind.Alias;
                }
            }

            internal NamespaceOrTypeSymbol NamespaceOrTypeSymbol => Symbol as NamespaceOrTypeSymbol;

            internal bool IsDefault
            {
                get
                {
                    if (!_typeWithAnnotations.HasType)
                    {
                        return (object)_symbol == null;
                    }
                    return false;
                }
            }

            internal bool IsNullableEnabled => _isNullableEnabled;

            private NamespaceOrTypeOrAliasSymbolWithAnnotations(TypeWithAnnotations typeWithAnnotations)
            {
                _typeWithAnnotations = typeWithAnnotations;
                _symbol = null;
                _isNullableEnabled = false;
            }

            private NamespaceOrTypeOrAliasSymbolWithAnnotations(Symbol symbol, bool isNullableEnabled)
            {
                _typeWithAnnotations = default(TypeWithAnnotations);
                _symbol = symbol;
                _isNullableEnabled = isNullableEnabled;
            }

            internal static NamespaceOrTypeOrAliasSymbolWithAnnotations CreateUnannotated(bool isNullableEnabled, Symbol symbol)
            {
                if ((object)symbol == null)
                {
                    return default(NamespaceOrTypeOrAliasSymbolWithAnnotations);
                }
                if (symbol is TypeSymbol typeSymbol)
                {
                    return new NamespaceOrTypeOrAliasSymbolWithAnnotations(TypeWithAnnotations.Create(isNullableEnabled, typeSymbol));
                }
                return new NamespaceOrTypeOrAliasSymbolWithAnnotations(symbol, isNullableEnabled);
            }

            public static implicit operator NamespaceOrTypeOrAliasSymbolWithAnnotations(TypeWithAnnotations typeWithAnnotations)
            {
                return new NamespaceOrTypeOrAliasSymbolWithAnnotations(typeWithAnnotations);
            }
        }

        protected enum OverflowChecks
        {
            Implicit,
            Disabled,
            Enabled
        }

        private class QueryTranslationState
        {
            public BoundExpression fromExpression;

            public RangeVariableSymbol rangeVariable;

            public readonly Stack<QueryClauseSyntax> clauses = new Stack<QueryClauseSyntax>();

            public SelectOrGroupClauseSyntax selectOrGroup;

            public readonly Dictionary<RangeVariableSymbol, ArrayBuilder<string>> allRangeVariables = new Dictionary<RangeVariableSymbol, ArrayBuilder<string>>();

            private int _nextTransparentIdentifierNumber;

            public static RangeVariableMap RangeVariableMap(params RangeVariableSymbol[] parameters)
            {
                RangeVariableMap rangeVariableMap = new RangeVariableMap();
                foreach (RangeVariableSymbol key in parameters)
                {
                    rangeVariableMap.Add(key, ImmutableArray<string>.Empty);
                }
                return rangeVariableMap;
            }

            public RangeVariableMap RangeVariableMap()
            {
                RangeVariableMap rangeVariableMap = new RangeVariableMap();
                foreach (RangeVariableSymbol key in allRangeVariables.Keys)
                {
                    rangeVariableMap.Add(key, allRangeVariables[key].ToImmutable());
                }
                return rangeVariableMap;
            }

            internal RangeVariableSymbol AddRangeVariable(Binder binder, SyntaxToken identifier, BindingDiagnosticBag diagnostics)
            {
                string valueText = identifier.ValueText;
                RangeVariableSymbol rangeVariableSymbol = new RangeVariableSymbol(valueText, binder.ContainingMemberOrLambda, identifier.GetLocation());
                bool flag = false;
                foreach (RangeVariableSymbol key in allRangeVariables.Keys)
                {
                    if (key.Name == valueText)
                    {
                        diagnostics.Add(ErrorCode.ERR_QueryDuplicateRangeVariable, identifier.GetLocation(), valueText);
                        flag = true;
                    }
                }
                if (!flag)
                {
                    new LocalScopeBinder(binder).ValidateDeclarationNameConflictsInScope(rangeVariableSymbol, diagnostics);
                }
                allRangeVariables.Add(rangeVariableSymbol, ArrayBuilder<string>.GetInstance());
                return rangeVariableSymbol;
            }

            internal void AddTransparentIdentifier(string name)
            {
                foreach (ArrayBuilder<string> value in allRangeVariables.Values)
                {
                    value.Add(name);
                }
            }

            internal string TransparentRangeVariableName()
            {
                return "<>h__TransparentIdentifier" + _nextTransparentIdentifierNumber++;
            }

            internal RangeVariableSymbol TransparentRangeVariable(Binder binder)
            {
                return new RangeVariableSymbol(TransparentRangeVariableName(), binder.ContainingMemberOrLambda, null, isTransparent: true);
            }

            public void Clear()
            {
                fromExpression = null;
                rangeVariable = null;
                selectOrGroup = null;
                foreach (ArrayBuilder<string> value in allRangeVariables.Values)
                {
                    value.Free();
                }
                allRangeVariables.Clear();
                clauses.Clear();
            }

            public void Free()
            {
                Clear();
            }
        }

        private delegate BoundBlock LambdaBodyFactory(LambdaSymbol lambdaSymbol, Binder lambdaBodyBinder, BindingDiagnosticBag diagnostics);

        private sealed class QueryUnboundLambdaState : UnboundLambdaState
        {
            private readonly ImmutableArray<RangeVariableSymbol> _parameters;

            private readonly LambdaBodyFactory _bodyFactory;

            private readonly RangeVariableMap _rangeVariableMap;

            public override bool HasNames => true;

            public override bool HasSignature => true;

            public override bool HasExplicitlyTypedParameterList => false;

            public override int ParameterCount => _parameters.Length;

            public override bool IsAsync => false;

            public override bool IsStatic => false;

            public override MessageID MessageID => MessageID.IDS_FeatureQueryExpression;

            public QueryUnboundLambdaState(Binder binder, RangeVariableMap rangeVariableMap, ImmutableArray<RangeVariableSymbol> parameters, LambdaBodyFactory bodyFactory, bool includeCache = true)
                : base(binder, includeCache)
            {
                _parameters = parameters;
                _rangeVariableMap = rangeVariableMap;
                _bodyFactory = bodyFactory;
            }

            public override string ParameterName(int index)
            {
                return _parameters[index].Name;
            }

            public override bool ParameterIsDiscard(int index)
            {
                return false;
            }

            public override SyntaxList<AttributeListSyntax> ParameterAttributes(int index)
            {
                return default(SyntaxList<AttributeListSyntax>);
            }

            public override RefKind RefKind(int index)
            {
                return Microsoft.CodeAnalysis.RefKind.None;
            }

            public override Location ParameterLocation(int index)
            {
                return _parameters[index].Locations[0];
            }

            public override TypeWithAnnotations ParameterTypeWithAnnotations(int index)
            {
                throw new ArgumentException();
            }

            public override void GenerateAnonymousFunctionConversionError(BindingDiagnosticBag diagnostics, TypeSymbol targetType)
            {
                base.GenerateAnonymousFunctionConversionError(diagnostics, targetType);
            }

            public override Binder ParameterBinder(LambdaSymbol lambdaSymbol, Binder binder)
            {
                return new WithQueryLambdaParametersBinder(lambdaSymbol, _rangeVariableMap, binder);
            }

            protected override UnboundLambdaState WithCachingCore(bool includeCache)
            {
                return new QueryUnboundLambdaState(Binder, _rangeVariableMap, _parameters, _bodyFactory, includeCache);
            }

            protected override BoundExpression GetLambdaExpressionBody(BoundBlock body)
            {
                return null;
            }

            protected override BoundBlock CreateBlockFromLambdaExpressionBody(Binder lambdaBodyBinder, BoundExpression expression, BindingDiagnosticBag diagnostics)
            {
                throw ExceptionUtilities.Unreachable;
            }

            protected override BoundBlock BindLambdaBody(LambdaSymbol lambdaSymbol, Binder lambdaBodyBinder, BindingDiagnosticBag diagnostics)
            {
                return _bodyFactory(lambdaSymbol, lambdaBodyBinder, diagnostics);
            }
        }

        private class RangeVariableMap : Dictionary<RangeVariableSymbol, ImmutableArray<string>>
        {
        }

        [Flags()]
        public enum BindValueKind : ushort
        {
            RValue = 4,
            Assignable = 8,
            RefersToLocation = 0x10,
            RefAssignable = 0x20,
            RValueOrMethodGroup = 5,
            CompoundAssignment = 0xC,
            IncrementDecrement = 0xD,
            ReadonlyRef = 0x14,
            AddressOf = 0x15,
            FixedReceiver = 0x16,
            RefOrOut = 0x1C,
            RefReturn = 0x1D
        }

        internal enum AddressKind
        {
            Writeable,
            Constrained,
            ReadOnly,
            ReadOnlyStrict
        }

        private sealed class WithQueryLambdaParametersBinder : WithLambdaParametersBinder
        {
            private readonly RangeVariableMap _rangeVariableMap;

            private readonly MultiDictionary<string, RangeVariableSymbol> _parameterMap;

            public WithQueryLambdaParametersBinder(LambdaSymbol lambdaSymbol, RangeVariableMap rangeVariableMap, Binder next)
                : base(lambdaSymbol, next)
            {
                _rangeVariableMap = rangeVariableMap;
                _parameterMap = new MultiDictionary<string, RangeVariableSymbol>();
                foreach (RangeVariableSymbol key in rangeVariableMap.Keys)
                {
                    _parameterMap.Add(key.Name, key);
                }
            }

            protected override BoundExpression BindRangeVariable(SimpleNameSyntax node, RangeVariableSymbol qv, BindingDiagnosticBag diagnostics)
            {
                if (_rangeVariableMap.TryGetValue(qv, out var value))
                {
                    BoundExpression boundExpression;
                    if (value.IsEmpty)
                    {
                        boundExpression = new BoundParameter(node, parameterMap[qv.Name].Single());
                    }
                    else
                    {
                        boundExpression = new BoundParameter(node, lambdaSymbol.Parameters[0]);
                        for (int num = value.Length - 1; num >= 0; num--)
                        {
                            boundExpression.WasCompilerGenerated = true;
                            string name = value[num];
                            boundExpression = SelectField(node, boundExpression, name, diagnostics);
                        }
                    }
                    return new BoundRangeVariable(node, qv, boundExpression, boundExpression.Type);
                }
                return base.BindRangeVariable(node, qv, diagnostics);
            }

            private BoundExpression SelectField(SimpleNameSyntax node, BoundExpression receiver, string name, BindingDiagnosticBag diagnostics)
            {
                NamedTypeSymbol namedTypeSymbol = receiver.Type as NamedTypeSymbol;
                if ((object)namedTypeSymbol == null || !namedTypeSymbol.IsAnonymousType)
                {
                    CSDiagnosticInfo cSDiagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_UnsupportedTransparentIdentifierAccess, name, receiver.ExpressionSymbol ?? namedTypeSymbol);
                    TypeSymbol? type = receiver.Type;
                    if ((object)type == null || !type.IsErrorType())
                    {
                        Error(diagnostics, cSDiagnosticInfo, node);
                    }
                    return new BoundBadExpression(node, LookupResultKind.Empty, ImmutableArray.Create(receiver.ExpressionSymbol), ImmutableArray.Create(BindToTypeForErrorRecovery(receiver)), new ExtendedErrorTypeSymbol(base.Compilation, "", 0, cSDiagnosticInfo));
                }
                LookupResult instance = LookupResult.GetInstance();
                LookupOptions options = LookupOptions.MustBeInstance;
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                LookupMembersWithFallback(instance, receiver.Type, name, 0, ref useSiteInfo, null, options);
                diagnostics.Add(node, useSiteInfo);
                BoundExpression result = BindMemberOfType(node, node, name, 0, indexed: false, receiver, default(SeparatedSyntaxList<TypeSyntax>), default(ImmutableArray<TypeWithAnnotations>), instance, BoundMethodGroupFlags.None, diagnostics);
                instance.Free();
                return result;
            }

            internal override void LookupSymbolsInSingleBinder(LookupResult result, string name, int arity, ConsList<TypeSymbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
            {
                if ((options & LookupOptions.NamespaceAliasesOnly) != 0)
                {
                    return;
                }
                foreach (RangeVariableSymbol item in _parameterMap[name])
                {
                    result.MergeEqual(originalBinder.CheckViability(item, arity, options, null, diagnose, ref useSiteInfo));
                }
            }

            protected override void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo result, LookupOptions options, Binder originalBinder)
            {
                if (!options.CanConsiderMembers())
                {
                    return;
                }
                foreach (KeyValuePair<string, MultiDictionary<string, RangeVariableSymbol>.ValueSet> item in _parameterMap)
                {
                    result.AddSymbol(null, item.Key, 0);
                }
            }
        }

        private struct AttributeExpressionVisitor
        {
            private readonly Binder _binder;

            public AttributeExpressionVisitor(Binder binder)
            {
                _binder = binder;
            }

            public ImmutableArray<TypedConstant> VisitArguments(ImmutableArray<BoundExpression> arguments, BindingDiagnosticBag diagnostics, ref bool attrHasErrors, bool parentHasErrors = false)
            {
                ImmutableArray<TypedConstant> result = ImmutableArray<TypedConstant>.Empty;
                int length = arguments.Length;
                if (length > 0)
                {
                    ArrayBuilder<TypedConstant> instance = ArrayBuilder<TypedConstant>.GetInstance(length);
                    ImmutableArray<BoundExpression>.Enumerator enumerator = arguments.GetEnumerator();
                    while (enumerator.MoveNext())
                    {
                        BoundExpression current = enumerator.Current;
                        bool curArgumentHasErrors = parentHasErrors || current.HasAnyErrors;
                        instance.Add(VisitExpression(current, diagnostics, ref attrHasErrors, curArgumentHasErrors));
                    }
                    result = instance.ToImmutableAndFree();
                }
                return result;
            }

            public ImmutableArray<KeyValuePair<string, TypedConstant>> VisitNamedArguments(ImmutableArray<BoundAssignmentOperator> arguments, BindingDiagnosticBag diagnostics, ref bool attrHasErrors)
            {
                ArrayBuilder<KeyValuePair<string, TypedConstant>> arrayBuilder = null;
                ImmutableArray<BoundAssignmentOperator>.Enumerator enumerator = arguments.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    BoundAssignmentOperator current = enumerator.Current;
                    KeyValuePair<string, TypedConstant>? keyValuePair = VisitNamedArgument(current, diagnostics, ref attrHasErrors);
                    if (keyValuePair.HasValue)
                    {
                        if (arrayBuilder == null)
                        {
                            arrayBuilder = ArrayBuilder<KeyValuePair<string, TypedConstant>>.GetInstance();
                        }
                        arrayBuilder.Add(keyValuePair.Value);
                    }
                }
                return arrayBuilder?.ToImmutableAndFree() ?? ImmutableArray<KeyValuePair<string, TypedConstant>>.Empty;
            }

            private KeyValuePair<string, TypedConstant>? VisitNamedArgument(BoundAssignmentOperator assignment, BindingDiagnosticBag diagnostics, ref bool attrHasErrors)
            {
                KeyValuePair<string, TypedConstant>? result = null;
                switch (assignment.Left.Kind)
                {
                    case BoundKind.FieldAccess:
                        {
                            BoundFieldAccess boundFieldAccess = (BoundFieldAccess)assignment.Left;
                            result = new KeyValuePair<string, TypedConstant>(boundFieldAccess.FieldSymbol.Name, VisitExpression(assignment.Right, diagnostics, ref attrHasErrors, assignment.HasAnyErrors));
                            break;
                        }
                    case BoundKind.PropertyAccess:
                        {
                            BoundPropertyAccess boundPropertyAccess = (BoundPropertyAccess)assignment.Left;
                            result = new KeyValuePair<string, TypedConstant>(boundPropertyAccess.PropertySymbol.Name, VisitExpression(assignment.Right, diagnostics, ref attrHasErrors, assignment.HasAnyErrors));
                            break;
                        }
                }
                return result;
            }

            private TypedConstant VisitExpression(BoundExpression node, BindingDiagnosticBag diagnostics, ref bool attrHasErrors, bool curArgumentHasErrors)
            {
                TypedConstantKind attributeParameterTypedConstantKind = node.Type.GetAttributeParameterTypedConstantKind(_binder.Compilation);
                return VisitExpression(node, attributeParameterTypedConstantKind, diagnostics, ref attrHasErrors, curArgumentHasErrors || attributeParameterTypedConstantKind == TypedConstantKind.Error);
            }

            private TypedConstant VisitExpression(BoundExpression node, TypedConstantKind typedConstantKind, BindingDiagnosticBag diagnostics, ref bool attrHasErrors, bool curArgumentHasErrors)
            {
                ConstantValue constantValue = node.ConstantValue;
                if (constantValue != null)
                {
                    if (constantValue.IsBad)
                    {
                        typedConstantKind = TypedConstantKind.Error;
                    }
                    ConstantValueUtils.CheckLangVersionForConstantValue(node, diagnostics);
                    return CreateTypedConstant(node, typedConstantKind, diagnostics, ref attrHasErrors, curArgumentHasErrors, constantValue.Value);
                }
                return node.Kind switch
                {
                    BoundKind.Conversion => VisitConversion((BoundConversion)node, diagnostics, ref attrHasErrors, curArgumentHasErrors),
                    BoundKind.TypeOfOperator => VisitTypeOfExpression((BoundTypeOfOperator)node, diagnostics, ref attrHasErrors, curArgumentHasErrors),
                    BoundKind.ArrayCreation => VisitArrayCreation((BoundArrayCreation)node, diagnostics, ref attrHasErrors, curArgumentHasErrors),
                    _ => CreateTypedConstant(node, TypedConstantKind.Error, diagnostics, ref attrHasErrors, curArgumentHasErrors),
                };
            }

            private TypedConstant VisitConversion(BoundConversion node, BindingDiagnosticBag diagnostics, ref bool attrHasErrors, bool curArgumentHasErrors)
            {
                TypeSymbol type = node.Type;
                BoundExpression operand = node.Operand;
                TypeSymbol type2 = operand.Type;
                if ((object)type != null && (object)type2 != null && (type.SpecialType == SpecialType.System_Object || (type2.IsArray() && type.IsArray() && ((ArrayTypeSymbol)type).ElementType.SpecialType == SpecialType.System_Object)))
                {
                    TypedConstantKind attributeParameterTypedConstantKind = type2.GetAttributeParameterTypedConstantKind(_binder.Compilation);
                    return VisitExpression(operand, attributeParameterTypedConstantKind, diagnostics, ref attrHasErrors, curArgumentHasErrors);
                }
                return CreateTypedConstant(node, TypedConstantKind.Error, diagnostics, ref attrHasErrors, curArgumentHasErrors);
            }

            private static TypedConstant VisitTypeOfExpression(BoundTypeOfOperator node, BindingDiagnosticBag diagnostics, ref bool attrHasErrors, bool curArgumentHasErrors)
            {
                TypeSymbol type = node.SourceType.Type;
                if ((object)type != null)
                {
                    bool flag = true;
                    flag = type.Kind != SymbolKind.TypeParameter && (type.IsUnboundGenericType() || !type.ContainsTypeParameter());
                    if (!flag && !curArgumentHasErrors)
                    {
                        Error(diagnostics, ErrorCode.ERR_AttrArgWithTypeVars, node.Syntax, type.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat));
                        curArgumentHasErrors = true;
                        attrHasErrors = true;
                    }
                }
                return CreateTypedConstant(node, TypedConstantKind.Type, diagnostics, ref attrHasErrors, curArgumentHasErrors, node.SourceType.Type);
            }

            private TypedConstant VisitArrayCreation(BoundArrayCreation node, BindingDiagnosticBag diagnostics, ref bool attrHasErrors, bool curArgumentHasErrors)
            {
                ImmutableArray<BoundExpression> bounds = node.Bounds;
                int length = bounds.Length;
                if (length > 1)
                {
                    return CreateTypedConstant(node, TypedConstantKind.Error, diagnostics, ref attrHasErrors, curArgumentHasErrors);
                }
                TypedConstantKind attributeParameterTypedConstantKind = ((ArrayTypeSymbol)node.Type).GetAttributeParameterTypedConstantKind(_binder.Compilation);
                ImmutableArray<TypedConstant> arrayValue = ((node.InitializerOpt != null) ? VisitArguments(node.InitializerOpt!.Initializers, diagnostics, ref attrHasErrors, curArgumentHasErrors) : ((length == 0) ? ImmutableArray<TypedConstant>.Empty : ((!bounds[0].IsDefaultValue()) ? ImmutableArray.Create(CreateTypedConstant(node, TypedConstantKind.Error, diagnostics, ref attrHasErrors, curArgumentHasErrors)) : ImmutableArray<TypedConstant>.Empty)));
                return CreateTypedConstant(node, attributeParameterTypedConstantKind, diagnostics, ref attrHasErrors, curArgumentHasErrors, null, arrayValue);
            }

            private static TypedConstant CreateTypedConstant(BoundExpression node, TypedConstantKind typedConstantKind, BindingDiagnosticBag diagnostics, ref bool attrHasErrors, bool curArgumentHasErrors, object? simpleValue = null, ImmutableArray<TypedConstant> arrayValue = default(ImmutableArray<TypedConstant>))
            {
                TypeSymbol type = node.Type;
                if (typedConstantKind != 0 && type.ContainsTypeParameter())
                {
                    typedConstantKind = TypedConstantKind.Error;
                }
                switch (typedConstantKind)
                {
                    case TypedConstantKind.Error:
                        if (!curArgumentHasErrors)
                        {
                            Error(diagnostics, ErrorCode.ERR_BadAttributeArgument, node.Syntax);
                            attrHasErrors = true;
                        }
                        return new TypedConstant(type, TypedConstantKind.Error, null);
                    case TypedConstantKind.Array:
                        return new TypedConstant(type, arrayValue);
                    default:
                        return new TypedConstant(type, typedConstantKind, simpleValue);
                }
            }
        }

        private struct AnalyzedAttributeArguments
        {
            internal readonly AnalyzedArguments ConstructorArguments;

            internal readonly ArrayBuilder<BoundAssignmentOperator>? NamedArguments;

            internal AnalyzedAttributeArguments(AnalyzedArguments constructorArguments, ArrayBuilder<BoundAssignmentOperator>? namedArguments)
            {
                ConstructorArguments = constructorArguments;
                NamedArguments = namedArguments;
            }
        }

        [DebuggerDisplay("{GetDebuggerDisplay(),nq}")]
        internal sealed class DeconstructionVariable
        {
            internal readonly BoundExpression? Single;

            internal readonly ArrayBuilder<DeconstructionVariable>? NestedVariables;

            internal readonly CSharpSyntaxNode Syntax;

            internal DeconstructionVariable(BoundExpression variable, SyntaxNode syntax)
            {
                Single = variable;
                NestedVariables = null;
                Syntax = (CSharpSyntaxNode)syntax;
            }

            internal DeconstructionVariable(ArrayBuilder<DeconstructionVariable> variables, SyntaxNode syntax)
            {
                Single = null;
                NestedVariables = variables;
                Syntax = (CSharpSyntaxNode)syntax;
            }

            internal static void FreeDeconstructionVariables(ArrayBuilder<DeconstructionVariable> variables)
            {
                variables.FreeAll<DeconstructionVariable>((DeconstructionVariable v) => v.NestedVariables);
            }

            private string GetDebuggerDisplay()
            {
                if (Single != null)
                {
                    return Single!.GetDebuggerDisplay();
                }
                return $"Nested variables ({NestedVariables!.Count})";
            }
        }

        private sealed class BinderWithContainingMemberOrLambda : Binder
        {
            private readonly Symbol _containingMemberOrLambda;

            internal override Symbol ContainingMemberOrLambda => _containingMemberOrLambda;

            internal BinderWithContainingMemberOrLambda(Binder next, Symbol containingMemberOrLambda)
                : base(next)
            {
                _containingMemberOrLambda = containingMemberOrLambda;
            }

            internal BinderWithContainingMemberOrLambda(Binder next, BinderFlags flags, Symbol containingMemberOrLambda)
                : base(next, flags)
            {
                _containingMemberOrLambda = containingMemberOrLambda;
            }
        }

        private sealed class BinderWithConditionalReceiver : Binder
        {
            private readonly BoundExpression _receiverExpression;

            internal override BoundExpression ConditionalReceiverExpression => _receiverExpression;

            internal BinderWithConditionalReceiver(Binder next, BoundExpression receiverExpression)
                : base(next)
            {
                _receiverExpression = receiverExpression;
            }
        }

        internal struct ProcessedFieldInitializers
        {
            internal NullableWalker.VariableState AfterInitializersState;

            internal ImmutableArray<BoundInitializer> BoundInitializers { get; set; }

            internal BoundStatement? LoweredInitializers { get; set; }

            internal bool HasErrors { get; set; }

            internal ImportChain? FirstImportChain { get; set; }
        }

        private enum ConstraintContextualKeyword
        {
            None,
            Unmanaged,
            NotNull
        }

        private class ConsistentSymbolOrder : IComparer<Symbol>
        {
            public static readonly ConsistentSymbolOrder Instance = new ConsistentSymbolOrder();

            public int Compare(Symbol fst, Symbol snd)
            {
                if (snd == fst)
                {
                    return 0;
                }
                if ((object)fst == null)
                {
                    return -1;
                }
                if ((object)snd == null)
                {
                    return 1;
                }
                if (snd.Name != fst.Name)
                {
                    return string.CompareOrdinal(fst.Name, snd.Name);
                }
                if (snd.Kind != fst.Kind)
                {
                    return fst.Kind - snd.Kind;
                }
                int num = ((!snd.Locations.IsDefault) ? snd.Locations.Length : 0);
                int length = fst.Locations.Length;
                if (num != length)
                {
                    return num - length;
                }
                if (num == 0 && length == 0)
                {
                    return Compare(fst.ContainingSymbol, snd.ContainingSymbol);
                }
                Location location = snd.Locations[0];
                Location location2 = fst.Locations[0];
                if (location.IsInSource != location2.IsInSource)
                {
                    if (!location.IsInSource)
                    {
                        return -1;
                    }
                    return 1;
                }
                int num2 = Compare(fst.ContainingSymbol, snd.ContainingSymbol);
                if (!location.IsInSource)
                {
                    return num2;
                }
                if (num2 == 0 && location.SourceTree == location2.SourceTree)
                {
                    return location2.SourceSpan.Start - location.SourceSpan.Start;
                }
                return num2;
            }
        }

        [Flags()]
        private enum BestSymbolLocation
        {
            None = 0,
            FromSourceModule = 1,
            FromAddedModule = 2,
            FromReferencedAssembly = 3,
            FromCorLibrary = 4
        }

        [DebuggerDisplay("Location = {_location}, Index = {_index}")]
        private struct BestSymbolInfo
        {
            private readonly BestSymbolLocation _location;

            private readonly int _index;

            public int Index
            {
                get
                {
                    if (!IsNone)
                    {
                        return _index;
                    }
                    return -1;
                }
            }

            public bool IsFromSourceModule => _location == BestSymbolLocation.FromSourceModule;

            public bool IsFromAddedModule => _location == BestSymbolLocation.FromAddedModule;

            public bool IsFromCompilation
            {
                get
                {
                    if (_location != BestSymbolLocation.FromSourceModule)
                    {
                        return _location == BestSymbolLocation.FromAddedModule;
                    }
                    return true;
                }
            }

            public bool IsNone => _location == BestSymbolLocation.None;

            public bool IsFromCorLibrary => _location == BestSymbolLocation.FromCorLibrary;

            public BestSymbolInfo(BestSymbolLocation location, int index)
            {
                _location = location;
                _index = index;
            }

            public static bool Sort(ref BestSymbolInfo first, ref BestSymbolInfo second)
            {
                if (IsSecondLocationBetter(first._location, second._location))
                {
                    BestSymbolInfo bestSymbolInfo = first;
                    first = second;
                    second = bestSymbolInfo;
                    return true;
                }
                return false;
            }

            public static bool IsSecondLocationBetter(BestSymbolLocation firstLocation, BestSymbolLocation secondLocation)
            {
                if (firstLocation != 0)
                {
                    return firstLocation > secondLocation;
                }
                return true;
            }
        }

        internal readonly BinderFlags Flags;

        private Conversions? _lazyConversions;

        private OverloadResolution? _lazyOverloadResolution;

        internal const uint ExternalScope = 0u;

        internal const uint TopLevelScope = 1u;

        private const int ValueKindInsignificantBits = 2;

        private const BindValueKind ValueKindSignificantBitsMask = (BindValueKind)65532;

        private static readonly Func<PropertySymbol, bool> s_isIndexedPropertyWithNonOptionalArguments = (property) =>
        {
            if (property.IsIndexer || !property.IsIndexedProperty)
            {
                return false;
            }
            ParameterSymbol parameterSymbol = property.Parameters[0];
            return !parameterSymbol.IsOptional && !parameterSymbol.IsParams;
        };

        private static readonly SymbolDisplayFormat s_propertyGroupFormat = new SymbolDisplayFormat(SymbolDisplayGlobalNamespaceStyle.Omitted, SymbolDisplayTypeQualificationStyle.NameOnly, SymbolDisplayGenericsOptions.None, SymbolDisplayMemberOptions.IncludeContainingType, SymbolDisplayDelegateStyle.NameOnly, SymbolDisplayExtensionMethodStyle.Default, SymbolDisplayParameterOptions.None, SymbolDisplayPropertyStyle.NameOnly, SymbolDisplayLocalOptions.None, SymbolDisplayKindOptions.None, SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers);

        internal const int MaxParameterListsForErrorRecovery = 10;

        private const string transparentIdentifierPrefix = "<>h__TransparentIdentifier";

        private static readonly Func<Symbol, MethodSymbol> s_toMethodSymbolFunc = (Symbol s) => (MethodSymbol)s;

        private static readonly Func<Symbol, PropertySymbol> s_toPropertySymbolFunc = (Symbol s) => (PropertySymbol)s;

        internal CSharpCompilation Compilation { get; }

        internal bool IsSemanticModelBinder => Flags.Includes(BinderFlags.SemanticModel);

        internal bool IsEarlyAttributeBinder => Flags.Includes(BinderFlags.EarlyAttributeBinding);

        protected virtual SyntaxNode? EnclosingNameofArgument => null;

        private bool IsInsideNameof => EnclosingNameofArgument != null;

        protected internal Binder? Next { get; }

        protected internal Binder NextRequired => Next;

        protected OverflowChecks CheckOverflow
        {
            get
            {
                if (!Flags.Includes(BinderFlags.CheckedRegion))
                {
                    if (!Flags.Includes(BinderFlags.UncheckedRegion))
                    {
                        return OverflowChecks.Implicit;
                    }
                    return OverflowChecks.Disabled;
                }
                return OverflowChecks.Enabled;
            }
        }

        protected bool CheckOverflowAtRuntime => CheckOverflow switch
        {
            OverflowChecks.Implicit => Compilation.Options.CheckOverflow,
            OverflowChecks.Enabled => true,
            _ => false,
        };

        internal bool CheckOverflowAtCompileTime => CheckOverflow != OverflowChecks.Disabled;

        internal virtual SyntaxNode? ScopeDesignator => null;

        internal virtual bool IsLocalFunctionsScopeBinder => false;

        internal virtual bool IsLabelsScopeBinder => false;

        internal virtual bool IsNestedFunctionBinder => false;

        internal virtual Symbol? ContainingMemberOrLambda => Next!.ContainingMemberOrLambda;

        internal virtual bool IsInMethodBody => Next!.IsInMethodBody;

        internal virtual bool IsDirectlyInIterator => Next!.IsDirectlyInIterator;

        internal virtual bool IsIndirectlyInIterator => Next!.IsIndirectlyInIterator;

        internal virtual GeneratedLabelSymbol? BreakLabel => Next!.BreakLabel;

        internal virtual GeneratedLabelSymbol? ContinueLabel => Next!.ContinueLabel;

        internal virtual ImportChain? ImportChain => Next!.ImportChain;

        internal virtual QuickAttributeChecker QuickAttributeChecker => Next!.QuickAttributeChecker;

        protected virtual bool InExecutableBinder => Next!.InExecutableBinder;

        internal NamedTypeSymbol? ContainingType
        {
            get
            {
                Symbol containingMemberOrLambda = ContainingMemberOrLambda;
                if ((object)containingMemberOrLambda != null)
                {
                    if (containingMemberOrLambda is NamedTypeSymbol result)
                    {
                        return result;
                    }
                    return containingMemberOrLambda.ContainingType;
                }
                return null;
            }
        }

        internal bool BindingTopLevelScriptCode
        {
            get
            {
                Symbol containingMemberOrLambda = ContainingMemberOrLambda;
                return containingMemberOrLambda?.Kind switch
                {
                    SymbolKind.Method => ((MethodSymbol)containingMemberOrLambda).IsScriptInitializer,
                    SymbolKind.NamedType => ((NamedTypeSymbol)containingMemberOrLambda).IsScriptClass,
                    _ => false,
                };
            }
        }

        internal virtual ConstantFieldsInProgress ConstantFieldsInProgress => Next!.ConstantFieldsInProgress;

        internal virtual ConsList<FieldSymbol> FieldsBeingBound => Next!.FieldsBeingBound;

        internal virtual LocalSymbol? LocalInProgress => Next!.LocalInProgress;

        internal virtual BoundExpression? ConditionalReceiverExpression => Next!.ConditionalReceiverExpression;

        internal Conversions Conversions
        {
            get
            {
                if (_lazyConversions == null)
                {
                    Interlocked.CompareExchange(ref _lazyConversions, new Conversions(this), null);
                }
                return _lazyConversions;
            }
        }

        internal OverloadResolution OverloadResolution
        {
            get
            {
                if (_lazyOverloadResolution == null)
                {
                    Interlocked.CompareExchange(ref _lazyOverloadResolution, new OverloadResolution(this), null);
                }
                return _lazyOverloadResolution;
            }
        }

        private bool ContextForbidsAwait
        {
            get
            {
                if (!Flags.Includes(BinderFlags.InCatchFilter))
                {
                    return Flags.Includes(BinderFlags.InLockBody);
                }
                return true;
            }
        }

        internal bool InFieldInitializer => Flags.Includes(BinderFlags.FieldInitializer);

        internal bool InParameterDefaultValue => Flags.Includes(BinderFlags.ParameterDefaultValue);

        protected bool InConstructorInitializer => Flags.Includes(BinderFlags.ConstructorInitializer);

        internal bool InAttributeArgument => Flags.Includes(BinderFlags.AttributeArgument);

        internal bool InCref => Flags.Includes(BinderFlags.Cref);

        protected bool InCrefButNotParameterOrReturnType
        {
            get
            {
                if (InCref)
                {
                    return !Flags.Includes(BinderFlags.CrefParameterOrReturnType);
                }
                return false;
            }
        }

        internal virtual bool SupportsExtensionMethods => false;

        internal virtual ImmutableHashSet<Symbol> LockedOrDisposedVariables => Next!.LockedOrDisposedVariables;

        internal virtual uint LocalScopeDepth => Next!.LocalScopeDepth;

        internal virtual ImmutableArray<LocalSymbol> Locals => ImmutableArray<LocalSymbol>.Empty;

        internal virtual ImmutableArray<LocalFunctionSymbol> LocalFunctions => ImmutableArray<LocalFunctionSymbol>.Empty;

        internal virtual ImmutableArray<LabelSymbol> Labels => ImmutableArray<LabelSymbol>.Empty;

        internal virtual ImmutableArray<AliasAndExternAliasDirective> ExternAliases => default(ImmutableArray<AliasAndExternAliasDirective>);

        internal virtual ImmutableArray<AliasAndUsingDirective> UsingAliases => default(ImmutableArray<AliasAndUsingDirective>);

        private bool ShouldCheckConstraints => !Flags.Includes(BinderFlags.SuppressConstraintChecks);

        internal bool InUnsafeRegion => Flags.Includes(BinderFlags.UnsafeRegion);

        public Binder(CSharpCompilation compilation)
        {
            Flags = compilation.Options.TopLevelBinderFlags;
            Compilation = compilation;
        }

        public Binder(Binder next, Conversions? conversions = null)
        {
            Next = next;
            Flags = next.Flags;
            Compilation = next.Compilation;
            _lazyConversions = conversions;
        }

        protected Binder(Binder next, BinderFlags flags)
        {
            Next = next;
            Flags = flags;
            Compilation = next.Compilation;
        }

        internal virtual Binder? GetBinder(SyntaxNode node)
        {
            return Next!.GetBinder(node);
        }

        internal Binder GetRequiredBinder(SyntaxNode node)
        {
            return GetBinder(node);
        }

        internal virtual ImmutableArray<LocalSymbol> GetDeclaredLocalsForScope(SyntaxNode scopeDesignator)
        {
            return Next!.GetDeclaredLocalsForScope(scopeDesignator);
        }

        internal virtual ImmutableArray<LocalFunctionSymbol> GetDeclaredLocalFunctionsForScope(CSharpSyntaxNode scopeDesignator)
        {
            return Next!.GetDeclaredLocalFunctionsForScope(scopeDesignator);
        }

        internal bool AreNullableAnnotationsEnabled(SyntaxTree syntaxTree, int position)
        {
            CSharpSyntaxTree cSharpSyntaxTree = (CSharpSyntaxTree)syntaxTree;
            NullableContextState nullableContextState = cSharpSyntaxTree.GetNullableContextState(position);
            return nullableContextState.AnnotationsState switch
            {
                NullableContextState.State.Enabled => true,
                NullableContextState.State.Disabled => false,
                NullableContextState.State.ExplicitlyRestored => GetGlobalAnnotationState(),
                NullableContextState.State.Unknown => !cSharpSyntaxTree.IsGeneratedCode(Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None) && AreNullableAnnotationsGloballyEnabled(),
                _ => throw ExceptionUtilities.UnexpectedValue(nullableContextState.AnnotationsState),
            };
        }

        internal bool AreNullableAnnotationsEnabled(SyntaxToken token)
        {
            return AreNullableAnnotationsEnabled(token.SyntaxTree, token.SpanStart);
        }

        internal bool IsGeneratedCode(SyntaxToken token)
        {
            return ((CSharpSyntaxTree)token.SyntaxTree).IsGeneratedCode(Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None);
        }

        internal virtual bool AreNullableAnnotationsGloballyEnabled()
        {
            return Next!.AreNullableAnnotationsGloballyEnabled();
        }

        protected bool GetGlobalAnnotationState()
        {
            return Compilation.Options.NullableContextOptions switch
            {
                NullableContextOptions.Annotations or NullableContextOptions.Enable => true,
                NullableContextOptions.Disable or NullableContextOptions.Warnings => false,
                _ => throw ExceptionUtilities.UnexpectedValue(Compilation.Options.NullableContextOptions),
            };
        }

        internal virtual TypeWithAnnotations GetIteratorElementType()
        {
            return Next!.GetIteratorElementType();
        }

        internal static void Error(BindingDiagnosticBag diagnostics, DiagnosticInfo info, SyntaxNode syntax)
        {
            diagnostics.Add(new CSDiagnostic(info, syntax.Location));
        }

        internal static void Error(BindingDiagnosticBag diagnostics, DiagnosticInfo info, Location location)
        {
            diagnostics.Add(new CSDiagnostic(info, location));
        }

        internal static void Error(BindingDiagnosticBag diagnostics, ErrorCode code, CSharpSyntaxNode syntax)
        {
            diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(code), syntax.Location));
        }

        internal static void Error(BindingDiagnosticBag diagnostics, ErrorCode code, CSharpSyntaxNode syntax, params object[] args)
        {
            diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(code, args), syntax.Location));
        }

        internal static void Error(BindingDiagnosticBag diagnostics, ErrorCode code, SyntaxToken token)
        {
            diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(code), token.GetLocation()));
        }

        internal static void Error(BindingDiagnosticBag diagnostics, ErrorCode code, SyntaxToken token, params object[] args)
        {
            diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(code, args), token.GetLocation()));
        }

        internal static void Error(BindingDiagnosticBag diagnostics, ErrorCode code, SyntaxNodeOrToken syntax)
        {
            Location location = syntax.GetLocation();
            Error(diagnostics, code, location);
        }

        internal static void Error(BindingDiagnosticBag diagnostics, ErrorCode code, SyntaxNodeOrToken syntax, params object[] args)
        {
            Location location = syntax.GetLocation();
            Error(diagnostics, code, location, args);
        }

        internal static void Error(BindingDiagnosticBag diagnostics, ErrorCode code, Location location)
        {
            diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(code), location));
        }

        internal static void Error(BindingDiagnosticBag diagnostics, ErrorCode code, Location location, params object[] args)
        {
            diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(code, args), location));
        }

        internal void ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics, Symbol symbol, SyntaxNode node, bool hasBaseReceiver)
        {
            ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver);
        }

        internal void ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics, Symbol symbol, SyntaxNodeOrToken node, bool hasBaseReceiver)
        {
            switch (symbol.Kind)
            {
                case SymbolKind.Event:
                case SymbolKind.Field:
                case SymbolKind.Method:
                case SymbolKind.NamedType:
                case SymbolKind.Property:
                    ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, ContainingMemberOrLambda, ContainingType, Flags);
                    break;
            }
        }

        internal void ReportDiagnosticsIfObsolete(BindingDiagnosticBag diagnostics, Symbol symbol, SyntaxNodeOrToken node, bool hasBaseReceiver)
        {
            if (diagnostics.DiagnosticBag != null)
            {
                ReportDiagnosticsIfObsolete(diagnostics.DiagnosticBag, symbol, node, hasBaseReceiver);
            }
        }

        internal void ReportDiagnosticsIfObsolete(BindingDiagnosticBag diagnostics, Conversion conversion, SyntaxNodeOrToken node, bool hasBaseReceiver)
        {
            if (conversion.IsValid && (object)conversion.Method != null)
            {
                ReportDiagnosticsIfObsolete(diagnostics, conversion.Method, node, hasBaseReceiver);
            }
        }

        internal static void ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics, Symbol symbol, SyntaxNodeOrToken node, bool hasBaseReceiver, Symbol? containingMember, NamedTypeSymbol? containingType, BinderFlags location)
        {
            if (symbol.Kind == SymbolKind.Method)
            {
                symbol = ((MethodSymbol)symbol).ConstructedFrom;
            }
            Symbol leastOverriddenMember = symbol.GetLeastOverriddenMember(containingType);
            bool flag = hasBaseReceiver && (object)symbol != leastOverriddenMember;
            if (flag)
            {
                leastOverriddenMember.GetAttributes();
            }
            ObsoleteDiagnosticKind obsoleteDiagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenMember, node, containingMember, location);
            if ((obsoleteDiagnosticKind == ObsoleteDiagnosticKind.NotObsolete || obsoleteDiagnosticKind == ObsoleteDiagnosticKind.Lazy) && flag)
            {
                ReportDiagnosticsIfObsoleteInternal(diagnostics, symbol, node, containingMember, location);
            }
        }

        internal static void ReportDiagnosticsIfObsolete(BindingDiagnosticBag diagnostics, Symbol symbol, SyntaxNodeOrToken node, bool hasBaseReceiver, Symbol? containingMember, NamedTypeSymbol? containingType, BinderFlags location)
        {
            if (diagnostics.DiagnosticBag != null)
            {
                ReportDiagnosticsIfObsolete(diagnostics.DiagnosticBag, symbol, node, hasBaseReceiver, containingMember, containingType, location);
            }
        }

        internal static ObsoleteDiagnosticKind ReportDiagnosticsIfObsoleteInternal(DiagnosticBag diagnostics, Symbol symbol, SyntaxNodeOrToken node, Symbol? containingMember, BinderFlags location)
        {
            ObsoleteDiagnosticKind obsoleteDiagnosticKind = ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember);
            DiagnosticInfo diagnosticInfo = null;
            switch (obsoleteDiagnosticKind)
            {
                case ObsoleteDiagnosticKind.Diagnostic:
                    diagnosticInfo = ObsoleteAttributeHelpers.CreateObsoleteDiagnostic(symbol, location);
                    break;
                case ObsoleteDiagnosticKind.Lazy:
                case ObsoleteDiagnosticKind.LazyPotentiallySuppressed:
                    diagnosticInfo = new LazyObsoleteDiagnosticInfo(symbol, containingMember, location);
                    break;
            }
            if (diagnosticInfo != null)
            {
                diagnostics.Add(diagnosticInfo, node.GetLocation());
            }
            return obsoleteDiagnosticKind;
        }

        internal static void ReportDiagnosticsIfObsoleteInternal(BindingDiagnosticBag diagnostics, Symbol symbol, SyntaxNodeOrToken node, Symbol containingMember, BinderFlags location)
        {
            if (diagnostics.DiagnosticBag != null)
            {
                ReportDiagnosticsIfObsoleteInternal(diagnostics.DiagnosticBag, symbol, node, containingMember, location);
            }
        }

        internal static void ReportDiagnosticsIfUnmanagedCallersOnly(BindingDiagnosticBag diagnostics, MethodSymbol symbol, Location location, bool isDelegateConversion)
        {
            UnmanagedCallersOnlyAttributeData unmanagedCallersOnlyAttributeData = symbol.GetUnmanagedCallersOnlyAttributeData(forceComplete: false);
            if (unmanagedCallersOnlyAttributeData != null)
            {
                diagnostics.Add((unmanagedCallersOnlyAttributeData == UnmanagedCallersOnlyAttributeData.Uninitialized) ? new LazyUnmanagedCallersOnlyMethodCalledDiagnosticInfo(symbol, isDelegateConversion) : new CSDiagnosticInfo(isDelegateConversion ? ErrorCode.ERR_UnmanagedCallersOnlyMethodsCannotBeConvertedToDelegate : ErrorCode.ERR_UnmanagedCallersOnlyMethodsCannotBeCalledDirectly, symbol), location);
            }
        }

        internal static bool IsSymbolAccessibleConditional(Symbol symbol, AssemblySymbol within, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            return AccessCheck.IsSymbolAccessible(symbol, within, ref useSiteInfo);
        }

        internal bool IsSymbolAccessibleConditional(Symbol symbol, NamedTypeSymbol within, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, TypeSymbol? throughTypeOpt = null)
        {
            if (!Flags.Includes(BinderFlags.IgnoreAccessibility))
            {
                return AccessCheck.IsSymbolAccessible(symbol, within, ref useSiteInfo, throughTypeOpt);
            }
            return true;
        }

        internal bool IsSymbolAccessibleConditional(Symbol symbol, NamedTypeSymbol within, TypeSymbol throughTypeOpt, out bool failedThroughTypeCheck, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, ConsList<TypeSymbol>? basesBeingResolved = null)
        {
            if (Flags.Includes(BinderFlags.IgnoreAccessibility))
            {
                failedThroughTypeCheck = false;
                return true;
            }
            return AccessCheck.IsSymbolAccessible(symbol, within, throughTypeOpt, out failedThroughTypeCheck, ref useSiteInfo, basesBeingResolved);
        }

        internal static void ReportUseSiteDiagnosticForSynthesizedAttribute(CSharpCompilation compilation, WellKnownMember attributeMember, BindingDiagnosticBag diagnostics, Location? location = null, CSharpSyntaxNode? syntax = null)
        {
            bool isOptional = WellKnownMembers.IsSynthesizedAttributeOptional(attributeMember);
            GetWellKnownTypeMember(compilation, attributeMember, diagnostics, location, syntax, isOptional);
        }

        public CompoundUseSiteInfo<AssemblySymbol> GetNewCompoundUseSiteInfo(BindingDiagnosticBag futureDestination)
        {
            return new CompoundUseSiteInfo<AssemblySymbol>(futureDestination, Compilation.Assembly);
        }

        internal BoundExpression WrapWithVariablesIfAny(CSharpSyntaxNode scopeDesignator, BoundExpression expression)
        {
            BoundExpression expression2 = expression;
            ImmutableArray<LocalSymbol> declaredLocalsForScope = GetDeclaredLocalsForScope(scopeDesignator);
            if (!declaredLocalsForScope.IsEmpty)
            {
                return new BoundSequence(scopeDesignator, declaredLocalsForScope, ImmutableArray<BoundExpression>.Empty, expression2, getType())
                {
                    WasCompilerGenerated = true
                };
            }
            return expression2;
            TypeSymbol getType()
            {
                return expression2.Type;
            }
        }

        internal BoundStatement WrapWithVariablesIfAny(CSharpSyntaxNode scopeDesignator, BoundStatement statement)
        {
            ImmutableArray<LocalSymbol> declaredLocalsForScope = GetDeclaredLocalsForScope(scopeDesignator);
            if (declaredLocalsForScope.IsEmpty)
            {
                return statement;
            }
            return new BoundBlock(statement.Syntax, declaredLocalsForScope, ImmutableArray.Create(statement))
            {
                WasCompilerGenerated = true
            };
        }

        internal BoundStatement WrapWithVariablesAndLocalFunctionsIfAny(CSharpSyntaxNode scopeDesignator, BoundStatement statement)
        {
            ImmutableArray<LocalSymbol> declaredLocalsForScope = GetDeclaredLocalsForScope(scopeDesignator);
            ImmutableArray<LocalFunctionSymbol> declaredLocalFunctionsForScope = GetDeclaredLocalFunctionsForScope(scopeDesignator);
            if (declaredLocalsForScope.IsEmpty && declaredLocalFunctionsForScope.IsEmpty)
            {
                return statement;
            }
            return new BoundBlock(statement.Syntax, declaredLocalsForScope, declaredLocalFunctionsForScope, ImmutableArray.Create(statement))
            {
                WasCompilerGenerated = true
            };
        }

        internal string Dump()
        {
            return TreeDumper.DumpCompact(dumpAncestors());
            TreeDumperNode dumpAncestors()
            {
                TreeDumperNode treeDumperNode = null;
                for (Binder binder = this; binder != null; binder = binder.Next)
                {
                    (string description, string? snippet, string locals) tuple = print(binder);
                    string item3 = tuple.description;
                    string item4 = tuple.snippet;
                    string item5 = tuple.locals;
                    List<TreeDumperNode> list = new List<TreeDumperNode>();
                    if (!item5.IsEmpty())
                    {
                        list.Add(new TreeDumperNode("locals", item5, null));
                    }
                    Symbol containingMemberOrLambda = binder.ContainingMemberOrLambda;
                    if (containingMemberOrLambda != null && containingMemberOrLambda != binder.Next?.ContainingMemberOrLambda)
                    {
                        list.Add(new TreeDumperNode("containing symbol", containingMemberOrLambda.ToDisplayString(), null));
                    }
                    if (item4 != null)
                    {
                        list.Add(new TreeDumperNode("scope", $"{item4} ({binder.ScopeDesignator?.Kind()})", null));
                    }
                    if (treeDumperNode != null)
                    {
                        list.Add(treeDumperNode);
                    }
                    treeDumperNode = new TreeDumperNode(item3, null, list);
                }
                return treeDumperNode;
            }
            static (string description, string? snippet, string locals) print(Binder scope)
            {
                string item = string.Join(", ", scope.Locals.SelectAsArray((LocalSymbol s) => s.Name));
                string item2 = null;
                if (scope.ScopeDesignator != null)
                {
                    string[] array = scope.ScopeDesignator!.ToString().Split(new string[1] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries);
                    if (array.Length == 1)
                    {
                        item2 = array[0];
                    }
                    else
                    {
                        string text = array[0];
                        string text2 = array[^1].Trim();
                        int num = Math.Min(text2.Length, 12);
                        item2 = text.Substring(0, Math.Min(text.Length, 12)) + " ... " + text2.Substring(text2.Length - num, num);
                    }
                    item2 = (item2.IsEmpty() ? null : item2);
                }
                return (scope.GetType().Name, item2, item);
            }
        }

        private static bool RequiresRValueOnly(BindValueKind kind)
        {
            return (kind & (BindValueKind)65532) == BindValueKind.RValue;
        }

        private static bool RequiresAssignmentOnly(BindValueKind kind)
        {
            return (kind & (BindValueKind)65532) == BindValueKind.Assignable;
        }

        private static bool RequiresVariable(BindValueKind kind)
        {
            return !RequiresRValueOnly(kind);
        }

        private static bool RequiresReferenceToLocation(BindValueKind kind)
        {
            return (kind & BindValueKind.RefersToLocation) != 0;
        }

        private static bool RequiresAssignableVariable(BindValueKind kind)
        {
            return (kind & BindValueKind.Assignable) != 0;
        }

        private static bool RequiresRefAssignableVariable(BindValueKind kind)
        {
            return (kind & BindValueKind.RefAssignable) != 0;
        }

        private static bool RequiresRefOrOut(BindValueKind kind)
        {
            return (kind & BindValueKind.RefOrOut) == BindValueKind.RefOrOut;
        }

        private BoundIndexerAccess BindIndexerDefaultArguments(BoundIndexerAccess indexerAccess, BindValueKind valueKind, BindingDiagnosticBag diagnostics)
        {
            bool flag = valueKind == BindValueKind.Assignable && !indexerAccess.Indexer.ReturnsByRef;
            MethodSymbol methodSymbol = (flag ? indexerAccess.Indexer.GetOwnOrInheritedSetMethod() : indexerAccess.Indexer.GetOwnOrInheritedGetMethod());
            if ((object)methodSymbol != null)
            {
                ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance(methodSymbol.ParameterCount);
                instance.AddRange(indexerAccess.Arguments);
                ArrayBuilder<RefKind> arrayBuilder;
                if (!indexerAccess.ArgumentRefKindsOpt.IsDefaultOrEmpty)
                {
                    arrayBuilder = ArrayBuilder<RefKind>.GetInstance(methodSymbol.ParameterCount);
                    arrayBuilder.AddRange(indexerAccess.ArgumentRefKindsOpt);
                }
                else
                {
                    arrayBuilder = null;
                }
                ImmutableArray<int> argsToParamsOpt = indexerAccess.ArgsToParamsOpt;
                ImmutableArray<ParameterSymbol> parameters = methodSymbol.Parameters;
                if (flag)
                {
                    parameters = parameters.RemoveAt(parameters.Length - 1);
                }
                BitVector defaultArguments = default(BitVector);
                if (indexerAccess.OriginalIndexersOpt.IsDefault)
                {
                    BindDefaultArguments(indexerAccess.Syntax, parameters, instance, arrayBuilder, ref argsToParamsOpt, out defaultArguments, indexerAccess.Expanded, enableCallerInfo: true, diagnostics);
                }
                indexerAccess = indexerAccess.Update(indexerAccess.ReceiverOpt, indexerAccess.Indexer, instance.ToImmutableAndFree(), indexerAccess.ArgumentNamesOpt, arrayBuilder?.ToImmutableOrNull() ?? default(ImmutableArray<RefKind>), indexerAccess.Expanded, argsToParamsOpt, defaultArguments, indexerAccess.Type);
                arrayBuilder?.Free();
            }
            return indexerAccess;
        }

        private BoundExpression CheckValue(BoundExpression expr, BindValueKind valueKind, BindingDiagnosticBag diagnostics)
        {
            switch (expr.Kind)
            {
                case BoundKind.PropertyGroup:
                    expr = BindIndexedPropertyAccess((BoundPropertyGroup)expr, mustHaveAllOptionalParameters: false, diagnostics);
                    if (expr is BoundIndexerAccess indexerAccess)
                    {
                        expr = BindIndexerDefaultArguments(indexerAccess, valueKind, diagnostics);
                    }
                    break;
                case BoundKind.OutVariablePendingInference:
                case BoundKind.OutDeconstructVarPendingInference:
                    return expr;
                case BoundKind.DiscardExpression:
                    return expr;
                case BoundKind.IndexerAccess:
                    expr = BindIndexerDefaultArguments((BoundIndexerAccess)expr, valueKind, diagnostics);
                    break;
                case BoundKind.UnconvertedObjectCreationExpression:
                    if (valueKind == BindValueKind.RValue)
                    {
                        return expr;
                    }
                    break;
            }
            bool flag = false;
            if (expr.Kind == BoundKind.MethodGroup && valueKind != BindValueKind.RValueOrMethodGroup)
            {
                BoundMethodGroup boundMethodGroup = (BoundMethodGroup)expr;
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                CallingConventionInfo callingConventionInfo = default(CallingConventionInfo);
                MethodGroupResolution methodGroupResolution = ResolveMethodGroup(boundMethodGroup, null, isMethodGroupConversion: false, ref useSiteInfo, inferWithDynamic: false, RefKind.None, null, isFunctionPointerResolution: false, in callingConventionInfo);
                diagnostics.Add(expr.Syntax, useSiteInfo);
                Symbol symbol = null;
                bool num = methodGroupResolution.MethodGroup != null;
                if (!expr.HasAnyErrors)
                {
                    diagnostics.AddRange(methodGroupResolution.Diagnostics);
                }
                flag = methodGroupResolution.HasAnyErrors;
                if (flag)
                {
                    symbol = methodGroupResolution.OtherSymbol;
                }
                methodGroupResolution.Free();
                if (!num)
                {
                    BoundExpression boundExpression = boundMethodGroup.ReceiverOpt;
                    if ((object)symbol != null && boundExpression != null && boundExpression.Kind == BoundKind.TypeOrValueExpression)
                    {
                        BoundTypeOrValueExpression boundTypeOrValueExpression = (BoundTypeOrValueExpression)boundExpression;
                        boundExpression = (symbol.RequiresInstanceReceiver() ? boundTypeOrValueExpression.Data.ValueExpression : null);
                    }
                    return new BoundBadExpression(expr.Syntax, boundMethodGroup.ResultKind, ((object)symbol == null) ? ImmutableArray<Symbol>.Empty : ImmutableArray.Create(symbol), (boundExpression == null) ? ImmutableArray<BoundExpression>.Empty : ImmutableArray.Create(boundExpression), GetNonMethodMemberType(symbol));
                }
            }
            if ((!flag && CheckValueKind(expr.Syntax, expr, valueKind, checkingReceiver: false, diagnostics)) || (expr.HasAnyErrors && valueKind == BindValueKind.RValueOrMethodGroup))
            {
                return expr;
            }
            LookupResultKind resultKind = ((valueKind == BindValueKind.RValue || valueKind == BindValueKind.RValueOrMethodGroup) ? LookupResultKind.NotAValue : LookupResultKind.NotAVariable);
            return ToBadExpression(expr, resultKind);
        }

        internal static bool IsTypeOrValueExpression(BoundExpression expression)
        {
            BoundKind? boundKind = expression?.Kind;
            if (boundKind.HasValue)
            {
                BoundKind valueOrDefault = boundKind.GetValueOrDefault();
                if (valueOrDefault == BoundKind.TypeOrValueExpression || (valueOrDefault == BoundKind.QueryClause && ((BoundQueryClause)expression).Value.Kind == BoundKind.TypeOrValueExpression))
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// The purpose of this method is to determine if the expression satisfies desired capabilities. 
        /// If it is not then this code gives an appropriate error message.
        ///
        /// To determine the appropriate error message we need to know two things:
        ///
        /// (1) What capabilities we need - increment it, assign, return as a readonly reference, . . . ?
        ///
        /// (2) Are we trying to determine if the left hand side of a dot is a variable in order
        ///     to determine if the field or property on the right hand side of a dot is assignable?
        ///     
        /// (3) The syntax of the expression that started the analysis. (for error reporting purposes).
        /// </summary>
        internal bool CheckValueKind(SyntaxNode node, BoundExpression expr, BindValueKind valueKind, bool checkingReceiver, BindingDiagnosticBag diagnostics)
        {
            if (expr.HasAnyErrors)
            {
                return false;
            }

            switch (expr.Kind)
            {
                // we need to handle properties and event in a special way even in an RValue case because of getters
                case BoundKind.PropertyAccess:
                case BoundKind.IndexerAccess:
                    return CheckPropertyValueKind(node, expr, valueKind, checkingReceiver, diagnostics);

                case BoundKind.IndexOrRangePatternIndexerAccess:
                    var patternIndexer = ((BoundIndexOrRangePatternIndexerAccess)expr);
                    if (patternIndexer.PatternSymbol.Kind == SymbolKind.Property)
                    {
                        // If this is an Index indexer, PatternSymbol should be a property, pointing to the
                        // pattern indexer. If it's a Range access, it will be a method, pointing to a Slice method
                        // and it's handled below as part of invocations.
                        return CheckPropertyValueKind(node, expr, valueKind, checkingReceiver, diagnostics);
                    }
                    break;

                case BoundKind.EventAccess:
                    return CheckEventValueKind((BoundEventAccess)expr, valueKind, diagnostics);
            }

            // easy out for a very common RValue case.
            if (RequiresRValueOnly(valueKind))
            {
                return CheckNotNamespaceOrType(expr, diagnostics);
            }

            // constants/literals are strictly RValues
            // void is not even an RValue
            if ((expr.ConstantValue != null) || (expr.Type.GetSpecialTypeSafe() == SpecialType.System_Void))
            {
                Error(diagnostics, GetStandardLvalueError(valueKind), node);
                return false;
            }

            switch (expr.Kind)
            {
                case BoundKind.NamespaceExpression:
                    var ns = (BoundNamespaceExpression)expr;
                    Error(diagnostics, ErrorCode.ERR_BadSKknown, node, ns.NamespaceSymbol, MessageID.IDS_SK_NAMESPACE.Localize(), MessageID.IDS_SK_VARIABLE.Localize());
                    return false;

                case BoundKind.TypeExpression:
                    var type = (BoundTypeExpression)expr;
                    Error(diagnostics, ErrorCode.ERR_BadSKknown, node, type.Type, MessageID.IDS_SK_TYPE.Localize(), MessageID.IDS_SK_VARIABLE.Localize());
                    return false;

                case BoundKind.Lambda:
                case BoundKind.UnboundLambda:
                    // lambdas can only be used as RValues
                    Error(diagnostics, GetStandardLvalueError(valueKind), node);
                    return false;

                case BoundKind.UnconvertedAddressOfOperator:
                    var unconvertedAddressOf = (BoundUnconvertedAddressOfOperator)expr;
                    Error(diagnostics, GetMethodGroupOrFunctionPointerLvalueError(valueKind), node, unconvertedAddressOf.Operand.Name, MessageID.IDS_AddressOfMethodGroup.Localize());
                    return false;

                case BoundKind.MethodGroup when valueKind == BindValueKind.AddressOf:
                    // If the addressof operator is used not as an rvalue, that will get flagged when CheckValue
                    // is called on the parent BoundUnconvertedAddressOf node.
                    return true;

                case BoundKind.MethodGroup:
                    // method groups can only be used as RValues except when taking the address of one
                    var methodGroup = (BoundMethodGroup)expr;
                    Error(diagnostics, GetMethodGroupOrFunctionPointerLvalueError(valueKind), node, methodGroup.Name, MessageID.IDS_MethodGroup.Localize());
                    return false;

                case BoundKind.RangeVariable:
                    // range variables can only be used as RValues
                    var queryref = (BoundRangeVariable)expr;
                    Error(diagnostics, GetRangeLvalueError(valueKind), node, queryref.RangeVariableSymbol.Name);
                    return false;

                case BoundKind.Conversion:
                    var conversion = (BoundConversion)expr;
                    // conversions are strict RValues, but unboxing has a specific error
                    if (conversion.ConversionKind == ConversionKind.Unboxing)
                    {
                        Error(diagnostics, ErrorCode.ERR_UnboxNotLValue, node);
                        return false;
                    }
                    break;

                // array access is readwrite variable if the indexing expression is not System.Range
                case BoundKind.ArrayAccess:
                    {
                        if (RequiresRefAssignableVariable(valueKind))
                        {
                            Error(diagnostics, ErrorCode.ERR_RefLocalOrParamExpected, node);
                            return false;
                        }

                        var boundAccess = (BoundArrayAccess)expr;
                        if (boundAccess.Indices.Length == 1 &&
                            TypeSymbol.Equals(
                                boundAccess.Indices[0].Type,
                                Compilation.GetWellKnownType(WellKnownType.System_Range),
                                TypeCompareKind.ConsiderEverything))
                        {
                            // Range indexer is an rvalue
                            Error(diagnostics, GetStandardLvalueError(valueKind), node);
                            return false;
                        }
                        return true;
                    }

                // pointer dereferencing is a readwrite variable
                case BoundKind.PointerIndirectionOperator:
                // The undocumented __refvalue(tr, T) expression results in a variable of type T.
                case BoundKind.RefValueOperator:
                // dynamic expressions are readwrite, and can even be passed by ref (which is implemented via a temp)
                case BoundKind.DynamicMemberAccess:
                case BoundKind.DynamicIndexerAccess:
                    {
                        if (RequiresRefAssignableVariable(valueKind))
                        {
                            Error(diagnostics, ErrorCode.ERR_RefLocalOrParamExpected, node);
                            return false;
                        }

                        // These are readwrite variables
                        return true;
                    }

                case BoundKind.PointerElementAccess:
                    {
                        if (RequiresRefAssignableVariable(valueKind))
                        {
                            Error(diagnostics, ErrorCode.ERR_RefLocalOrParamExpected, node);
                            return false;
                        }

                        var receiver = ((BoundPointerElementAccess)expr).Expression;
                        if (receiver is BoundFieldAccess fieldAccess && fieldAccess.FieldSymbol.IsFixedSizeBuffer)
                        {
                            return CheckValueKind(node, fieldAccess.ReceiverOpt, valueKind, checkingReceiver: true, diagnostics);
                        }

                        return true;
                    }

                case BoundKind.Parameter:
                    var parameter = (BoundParameter)expr;
                    return CheckParameterValueKind(node, parameter, valueKind, checkingReceiver, diagnostics);

                case BoundKind.Local:
                    var local = (BoundLocal)expr;
                    return CheckLocalValueKind(node, local, valueKind, checkingReceiver, diagnostics);

                case BoundKind.ThisReference:
                    // `this` is never ref assignable
                    if (RequiresRefAssignableVariable(valueKind))
                    {
                        Error(diagnostics, ErrorCode.ERR_RefLocalOrParamExpected, node);
                        return false;
                    }

                    // We will already have given an error for "this" used outside of a constructor, 
                    // instance method, or instance accessor. Assume that "this" is a variable if it is in a struct.

                    // SPEC: when this is used in a primary-expression within an instance constructor of a struct, 
                    // SPEC: it is classified as a variable. 

                    // SPEC: When this is used in a primary-expression within an instance method or instance accessor
                    // SPEC: of a struct, it is classified as a variable. 

                    // Note: RValueOnly is checked at the beginning of this method. Since we are here we need more than readable.
                    // "this" is readonly in members marked "readonly" and in members of readonly structs, unless we are in a constructor.
                    var isValueType = ((BoundThisReference)expr).Type.IsValueType;
                    if (!isValueType || (RequiresAssignableVariable(valueKind) && (this.ContainingMemberOrLambda as MethodSymbol)?.IsEffectivelyReadOnly == true))
                    {
                        Error(diagnostics, GetThisLvalueError(valueKind, isValueType), node, node);
                        return false;
                    }

                    return true;

                case BoundKind.ImplicitReceiver:
                case BoundKind.ObjectOrCollectionValuePlaceholder:
                    return true;

                case BoundKind.Call:
                    var call = (BoundCall)expr;
                    return CheckCallValueKind(call, node, valueKind, checkingReceiver, diagnostics);

                case BoundKind.FunctionPointerInvocation:
                    return CheckMethodReturnValueKind(((BoundFunctionPointerInvocation)expr).FunctionPointer.Signature,
                        expr.Syntax,
                        node,
                        valueKind,
                        checkingReceiver,
                        diagnostics);

                case BoundKind.IndexOrRangePatternIndexerAccess:
                    var patternIndexer = (BoundIndexOrRangePatternIndexerAccess)expr;
                    // If we got here this should be a pattern indexer taking a Range,
                    // meaning that the pattern symbol must be a method (either Slice or Substring)
                    return CheckMethodReturnValueKind(
                        (MethodSymbol)patternIndexer.PatternSymbol,
                        patternIndexer.Syntax,
                        node,
                        valueKind,
                        checkingReceiver,
                        diagnostics);

                case BoundKind.ConditionalOperator:
                    var conditional = (BoundConditionalOperator)expr;

                    // byref conditional defers to its operands
                    if (conditional.IsRef &&
                        (CheckValueKind(conditional.Consequence.Syntax, conditional.Consequence, valueKind, checkingReceiver: false, diagnostics: diagnostics) &
                        CheckValueKind(conditional.Alternative.Syntax, conditional.Alternative, valueKind, checkingReceiver: false, diagnostics: diagnostics)))
                    {
                        return true;
                    }

                    // report standard lvalue error
                    break;

                case BoundKind.FieldAccess:
                    {
                        var fieldAccess = (BoundFieldAccess)expr;
                        return CheckFieldValueKind(node, fieldAccess, valueKind, checkingReceiver, diagnostics);
                    }

                case BoundKind.AssignmentOperator:
                    var assignment = (BoundAssignmentOperator)expr;
                    return CheckSimpleAssignmentValueKind(node, assignment, valueKind, diagnostics);
            }

            // At this point we should have covered all the possible cases for anything that is not a strict RValue.
            Error(diagnostics, GetStandardLvalueError(valueKind), node);
            return false;
        }

        private static bool CheckNotNamespaceOrType(BoundExpression expr, BindingDiagnosticBag diagnostics)
        {
            switch (expr.Kind)
            {
                case BoundKind.NamespaceExpression:
                    Error(diagnostics, ErrorCode.ERR_BadSKknown, expr.Syntax, ((BoundNamespaceExpression)expr).NamespaceSymbol, MessageID.IDS_SK_NAMESPACE.Localize(), MessageID.IDS_SK_VARIABLE.Localize());
                    return false;
                case BoundKind.TypeExpression:
                    Error(diagnostics, ErrorCode.ERR_BadSKunknown, expr.Syntax, expr.Type, MessageID.IDS_SK_TYPE.Localize());
                    return false;
                default:
                    return true;
            }
        }

        private bool CheckLocalValueKind(SyntaxNode node, BoundLocal local, BindValueKind valueKind, bool checkingReceiver, BindingDiagnosticBag diagnostics)
        {
            LocalSymbol localSymbol = local.LocalSymbol;
            if (RequiresAssignableVariable(valueKind))
            {
                if (LockedOrDisposedVariables.Contains(localSymbol))
                {
                    diagnostics.Add(ErrorCode.WRN_AssignmentToLockOrDispose, local.Syntax.Location, localSymbol);
                }
                if (localSymbol.RefKind == RefKind.In || (localSymbol.RefKind == RefKind.None && !localSymbol.IsWritableVariable))
                {
                    ReportReadonlyLocalError(node, localSymbol, valueKind, checkingReceiver, diagnostics);
                    return false;
                }
            }
            else if (RequiresRefAssignableVariable(valueKind))
            {
                if (localSymbol.RefKind == RefKind.None)
                {
                    diagnostics.Add(ErrorCode.ERR_RefLocalOrParamExpected, node.Location, localSymbol);
                    return false;
                }
                if (!localSymbol.IsWritableVariable)
                {
                    ReportReadonlyLocalError(node, localSymbol, valueKind, checkingReceiver, diagnostics);
                    return false;
                }
            }
            return true;
        }

        private static bool CheckLocalRefEscape(SyntaxNode node, BoundLocal local, uint escapeTo, bool checkingReceiver, BindingDiagnosticBag diagnostics)
        {
            LocalSymbol localSymbol = local.LocalSymbol;
            if (localSymbol.RefEscapeScope <= escapeTo)
            {
                return true;
            }
            if (escapeTo == 0)
            {
                if (localSymbol.RefKind == RefKind.None)
                {
                    if (checkingReceiver)
                    {
                        Error(diagnostics, ErrorCode.ERR_RefReturnLocal2, local.Syntax, localSymbol);
                    }
                    else
                    {
                        Error(diagnostics, ErrorCode.ERR_RefReturnLocal, node, localSymbol);
                    }
                    return false;
                }
                if (checkingReceiver)
                {
                    Error(diagnostics, ErrorCode.ERR_RefReturnNonreturnableLocal2, local.Syntax, localSymbol);
                }
                else
                {
                    Error(diagnostics, ErrorCode.ERR_RefReturnNonreturnableLocal, node, localSymbol);
                }
                return false;
            }
            Error(diagnostics, ErrorCode.ERR_EscapeLocal, node, localSymbol);
            return false;
        }

        private bool CheckParameterValueKind(SyntaxNode node, BoundParameter parameter, BindValueKind valueKind, bool checkingReceiver, BindingDiagnosticBag diagnostics)
        {
            ParameterSymbol parameterSymbol = parameter.ParameterSymbol;
            if (parameterSymbol.RefKind == RefKind.In && RequiresAssignableVariable(valueKind))
            {
                ReportReadOnlyError(parameterSymbol, node, valueKind, checkingReceiver, diagnostics);
                return false;
            }
            if (parameterSymbol.RefKind == RefKind.None && RequiresRefAssignableVariable(valueKind))
            {
                Error(diagnostics, ErrorCode.ERR_RefLocalOrParamExpected, node);
                return false;
            }
            if (LockedOrDisposedVariables.Contains(parameterSymbol))
            {
                diagnostics.Add(ErrorCode.WRN_AssignmentToLockOrDispose, parameter.Syntax.Location, parameterSymbol.Name);
            }
            return true;
        }

        private static bool CheckParameterRefEscape(SyntaxNode node, BoundParameter parameter, uint escapeTo, bool checkingReceiver, BindingDiagnosticBag diagnostics)
        {
            ParameterSymbol parameterSymbol = parameter.ParameterSymbol;
            if (escapeTo == 0 && parameterSymbol.RefKind == RefKind.None)
            {
                if (checkingReceiver)
                {
                    Error(diagnostics, ErrorCode.ERR_RefReturnParameter2, parameter.Syntax, parameterSymbol.Name);
                }
                else
                {
                    Error(diagnostics, ErrorCode.ERR_RefReturnParameter, node, parameterSymbol.Name);
                }
                return false;
            }
            return true;
        }

        private bool CheckFieldValueKind(SyntaxNode node, BoundFieldAccess fieldAccess, BindValueKind valueKind, bool checkingReceiver, BindingDiagnosticBag diagnostics)
        {
            FieldSymbol fieldSymbol = fieldAccess.FieldSymbol;
            bool isStatic = fieldSymbol.IsStatic;
            if (RequiresAssignableVariable(valueKind))
            {
                if (fieldSymbol.IsReadOnly)
                {
                    bool flag = false;
                    Symbol containingMemberOrLambda = ContainingMemberOrLambda;
                    if ((object)containingMemberOrLambda != null && isStatic == containingMemberOrLambda.IsStatic && (isStatic || fieldAccess.ReceiverOpt!.Kind == BoundKind.ThisReference) && (Compilation.FeatureStrictEnabled ? TypeSymbol.Equals(fieldSymbol.ContainingType, containingMemberOrLambda.ContainingType, TypeCompareKind.ConsiderEverything) : TypeSymbol.Equals(fieldSymbol.ContainingType.OriginalDefinition, containingMemberOrLambda.ContainingType.OriginalDefinition, TypeCompareKind.ConsiderEverything)))
                    {
                        if (containingMemberOrLambda.Kind == SymbolKind.Method)
                        {
                            MethodSymbol obj = (MethodSymbol)containingMemberOrLambda;
                            MethodKind methodKind = ((!isStatic) ? MethodKind.Constructor : MethodKind.StaticConstructor);
                            flag = obj.MethodKind == methodKind || isAssignedFromInitOnlySetterOnThis(fieldAccess.ReceiverOpt);
                        }
                        else if (containingMemberOrLambda.Kind == SymbolKind.Field)
                        {
                            flag = true;
                        }
                    }
                    if (!flag)
                    {
                        ReportReadOnlyFieldError(fieldSymbol, node, valueKind, checkingReceiver, diagnostics);
                        return false;
                    }
                }
                if (fieldSymbol.IsFixedSizeBuffer)
                {
                    Error(diagnostics, GetStandardLvalueError(valueKind), node);
                    return false;
                }
            }
            if (RequiresRefAssignableVariable(valueKind))
            {
                Error(diagnostics, ErrorCode.ERR_RefLocalOrParamExpected, node);
                return false;
            }
            if (isStatic || fieldSymbol.ContainingType.IsReferenceType)
            {
                return true;
            }
            return CheckIsValidReceiverForVariable(node, fieldAccess.ReceiverOpt, valueKind, diagnostics);
            bool isAssignedFromInitOnlySetterOnThis(BoundExpression receiver)
            {
                if (!(receiver is BoundThisReference))
                {
                    return false;
                }
                if (!(ContainingMemberOrLambda is MethodSymbol methodSymbol))
                {
                    return false;
                }
                return methodSymbol.IsInitOnly;
            }
        }

        private bool CheckSimpleAssignmentValueKind(SyntaxNode node, BoundAssignmentOperator assignment, BindValueKind valueKind, BindingDiagnosticBag diagnostics)
        {
            if (assignment.IsRef)
            {
                return CheckValueKind(node, assignment.Left, valueKind, checkingReceiver: false, diagnostics);
            }
            Error(diagnostics, GetStandardLvalueError(valueKind), node);
            return false;
        }

        private static bool CheckFieldRefEscape(SyntaxNode node, BoundFieldAccess fieldAccess, uint escapeFrom, uint escapeTo, BindingDiagnosticBag diagnostics)
        {
            FieldSymbol fieldSymbol = fieldAccess.FieldSymbol;
            if (fieldSymbol.IsStatic || fieldSymbol.ContainingType.IsReferenceType)
            {
                return true;
            }
            return CheckRefEscape(node, fieldAccess.ReceiverOpt, escapeFrom, escapeTo, checkingReceiver: true, diagnostics);
        }

        private static bool CheckFieldLikeEventRefEscape(SyntaxNode node, BoundEventAccess eventAccess, uint escapeFrom, uint escapeTo, BindingDiagnosticBag diagnostics)
        {
            EventSymbol eventSymbol = eventAccess.EventSymbol;
            if (eventSymbol.IsStatic || eventSymbol.ContainingType.IsReferenceType)
            {
                return true;
            }
            return CheckRefEscape(node, eventAccess.ReceiverOpt, escapeFrom, escapeTo, checkingReceiver: true, diagnostics);
        }

        private bool CheckEventValueKind(BoundEventAccess boundEvent, BindValueKind valueKind, BindingDiagnosticBag diagnostics)
        {
            BoundExpression receiverOpt = boundEvent.ReceiverOpt;
            SyntaxNode eventName = GetEventName(boundEvent);
            EventSymbol eventSymbol = boundEvent.EventSymbol;
            if (valueKind == BindValueKind.CompoundAssignment)
            {
                if (ReportUseSite(eventSymbol, diagnostics, eventName))
                {
                    return false;
                }
                return true;
            }
            if (!boundEvent.IsUsableAsField)
            {
                Error(diagnostics, GetBadEventUsageDiagnosticInfo(eventSymbol), eventName);
                return false;
            }
            if (ReportUseSite(eventSymbol, diagnostics, eventName))
            {
                if (!CheckIsValidReceiverForVariable(eventName, receiverOpt, BindValueKind.Assignable, diagnostics))
                {
                    return false;
                }
            }
            else if (RequiresVariable(valueKind))
            {
                if (eventSymbol.IsWindowsRuntimeEvent && valueKind != BindValueKind.Assignable)
                {
                    ErrorCode code = ((valueKind == BindValueKind.RefOrOut) ? ErrorCode.ERR_WinRtEventPassedByRef : GetStandardLvalueError(valueKind));
                    Error(diagnostics, code, eventName, eventSymbol);
                    return false;
                }
                if (RequiresVariableReceiver(receiverOpt, eventSymbol.AssociatedField) && !CheckIsValidReceiverForVariable(eventName, receiverOpt, valueKind, diagnostics))
                {
                    return false;
                }
            }
            return true;
        }

        private bool CheckIsValidReceiverForVariable(SyntaxNode node, BoundExpression receiver, BindValueKind kind, BindingDiagnosticBag diagnostics)
        {
            if (!Flags.Includes(BinderFlags.ObjectInitializerMember) || receiver.Kind != BoundKind.ObjectOrCollectionValuePlaceholder)
            {
                return CheckValueKind(node, receiver, kind, checkingReceiver: true, diagnostics);
            }
            return true;
        }

        private static bool RequiresVariableReceiver(BoundExpression receiver, Symbol symbol)
        {
            if (symbol.RequiresInstanceReceiver() && symbol.Kind != SymbolKind.Event)
            {
                if (receiver == null)
                {
                    return false;
                }
                return receiver.Type?.IsValueType == true;
            }
            return false;
        }

        private bool CheckCallValueKind(BoundCall call, SyntaxNode node, BindValueKind valueKind, bool checkingReceiver, BindingDiagnosticBag diagnostics)
        {
            return CheckMethodReturnValueKind(call.Method, call.Syntax, node, valueKind, checkingReceiver, diagnostics);
        }

        protected bool CheckMethodReturnValueKind(MethodSymbol methodSymbol, SyntaxNode callSyntaxOpt, SyntaxNode node, BindValueKind valueKind, bool checkingReceiver, BindingDiagnosticBag diagnostics)
        {
            if (RequiresVariable(valueKind) && methodSymbol.RefKind == RefKind.None)
            {
                if (checkingReceiver)
                {
                    Error(diagnostics, ErrorCode.ERR_ReturnNotLValue, callSyntaxOpt, methodSymbol);
                }
                else
                {
                    Error(diagnostics, GetStandardLvalueError(valueKind), node);
                }
                return false;
            }
            if (RequiresAssignableVariable(valueKind) && methodSymbol.RefKind == RefKind.In)
            {
                ReportReadOnlyError(methodSymbol, node, valueKind, checkingReceiver, diagnostics);
                return false;
            }
            if (RequiresRefAssignableVariable(valueKind))
            {
                Error(diagnostics, ErrorCode.ERR_RefLocalOrParamExpected, node);
                return false;
            }
            return true;
        }

        private bool CheckPropertyValueKind(SyntaxNode node, BoundExpression expr, BindValueKind valueKind, bool checkingReceiver, BindingDiagnosticBag diagnostics)
        {
            PropertySymbol propertySymbol = GetPropertySymbol(expr, out BoundExpression receiver2, out SyntaxNode propertySyntax);
            if ((RequiresReferenceToLocation(valueKind) || checkingReceiver) && propertySymbol.RefKind == RefKind.None)
            {
                if (checkingReceiver)
                {
                    Error(diagnostics, ErrorCode.ERR_ReturnNotLValue, expr.Syntax, propertySymbol);
                }
                else
                {
                    Error(diagnostics, (valueKind == BindValueKind.RefOrOut) ? ErrorCode.ERR_RefProperty : GetStandardLvalueError(valueKind), node, propertySymbol);
                }
                return false;
            }
            if (RequiresAssignableVariable(valueKind) && propertySymbol.RefKind == RefKind.In)
            {
                ReportReadOnlyError(propertySymbol, node, valueKind, checkingReceiver, diagnostics);
                return false;
            }
            if (RequiresAssignableVariable(valueKind) && propertySymbol.RefKind == RefKind.None)
            {
                MethodSymbol ownOrInheritedSetMethod = propertySymbol.GetOwnOrInheritedSetMethod();
                if ((object)ownOrInheritedSetMethod == null)
                {
                    Symbol containingMemberOrLambda = ContainingMemberOrLambda;
                    if (!AccessingAutoPropertyFromConstructor(receiver2, propertySymbol, containingMemberOrLambda))
                    {
                        Error(diagnostics, ErrorCode.ERR_AssgReadonlyProp, node, propertySymbol);
                        return false;
                    }
                }
                else
                {
                    if (ownOrInheritedSetMethod.IsInitOnly)
                    {
                        if (!isAllowedInitOnlySet(receiver2))
                        {
                            Error(diagnostics, ErrorCode.ERR_AssignmentInitOnly, node, propertySymbol);
                            return false;
                        }
                        if (ownOrInheritedSetMethod.DeclaringCompilation != Compilation)
                        {
                            CheckFeatureAvailability(node, MessageID.IDS_FeatureInitOnlySetters, diagnostics);
                        }
                    }
                    TypeSymbol accessThroughType = GetAccessThroughType(receiver2);
                    CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                    bool num = IsAccessible(ownOrInheritedSetMethod, accessThroughType, out bool failedThroughTypeCheck, ref useSiteInfo);
                    diagnostics.Add(node, useSiteInfo);
                    if (!num)
                    {
                        if (failedThroughTypeCheck)
                        {
                            Error(diagnostics, ErrorCode.ERR_BadProtectedAccess, node, propertySymbol, accessThroughType, ContainingType);
                        }
                        else
                        {
                            Error(diagnostics, ErrorCode.ERR_InaccessibleSetter, node, propertySymbol);
                        }
                        return false;
                    }
                    ReportDiagnosticsIfObsolete(diagnostics, ownOrInheritedSetMethod, node, receiver2 != null && receiver2.Kind == BoundKind.BaseReference);
                    BindValueKind kind = (ownOrInheritedSetMethod.IsEffectivelyReadOnly ? BindValueKind.RValue : BindValueKind.Assignable);
                    if (RequiresVariableReceiver(receiver2, ownOrInheritedSetMethod) && !CheckIsValidReceiverForVariable(node, receiver2, kind, diagnostics))
                    {
                        return false;
                    }
                    if (IsBadBaseAccess(node, receiver2, ownOrInheritedSetMethod, diagnostics, propertySymbol) || reportUseSite(ownOrInheritedSetMethod))
                    {
                        return false;
                    }
                    CheckRuntimeSupportForSymbolAccess(node, receiver2, ownOrInheritedSetMethod, diagnostics);
                }
            }
            if (!RequiresAssignmentOnly(valueKind) || propertySymbol.RefKind != 0)
            {
                MethodSymbol ownOrInheritedGetMethod = propertySymbol.GetOwnOrInheritedGetMethod();
                if ((object)ownOrInheritedGetMethod == null)
                {
                    Error(diagnostics, ErrorCode.ERR_PropertyLacksGet, node, propertySymbol);
                    return false;
                }
                TypeSymbol accessThroughType2 = GetAccessThroughType(receiver2);
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo2 = GetNewCompoundUseSiteInfo(diagnostics);
                bool num2 = IsAccessible(ownOrInheritedGetMethod, accessThroughType2, out bool failedThroughTypeCheck2, ref useSiteInfo2);
                diagnostics.Add(node, useSiteInfo2);
                if (!num2)
                {
                    if (failedThroughTypeCheck2)
                    {
                        Error(diagnostics, ErrorCode.ERR_BadProtectedAccess, node, propertySymbol, accessThroughType2, ContainingType);
                    }
                    else
                    {
                        Error(diagnostics, ErrorCode.ERR_InaccessibleGetter, node, propertySymbol);
                    }
                    return false;
                }
                CheckImplicitThisCopyInReadOnlyMember(receiver2, ownOrInheritedGetMethod, diagnostics);
                ReportDiagnosticsIfObsolete(diagnostics, ownOrInheritedGetMethod, node, receiver2 != null && receiver2.Kind == BoundKind.BaseReference);
                if (IsBadBaseAccess(node, receiver2, ownOrInheritedGetMethod, diagnostics, propertySymbol) || reportUseSite(ownOrInheritedGetMethod))
                {
                    return false;
                }
                CheckRuntimeSupportForSymbolAccess(node, receiver2, ownOrInheritedGetMethod, diagnostics);
            }
            if (RequiresRefAssignableVariable(valueKind))
            {
                Error(diagnostics, ErrorCode.ERR_RefLocalOrParamExpected, node);
                return false;
            }
            return true;
            bool isAllowedInitOnlySet(BoundExpression receiver)
            {
                if (receiver is BoundObjectOrCollectionValuePlaceholder boundObjectOrCollectionValuePlaceholder)
                {
                    return boundObjectOrCollectionValuePlaceholder.IsNewInstance;
                }
                if (!(receiver is BoundThisReference) && !(receiver is BoundBaseReference))
                {
                    return false;
                }
                if (!(ContainingMemberOrLambda is MethodSymbol methodSymbol))
                {
                    return false;
                }
                if (methodSymbol.MethodKind == MethodKind.Constructor || methodSymbol.IsInitOnly)
                {
                    return true;
                }
                return false;
            }
            bool reportUseSite(MethodSymbol accessor)
            {
                UseSiteInfo<AssemblySymbol> useSiteInfo3 = accessor.GetUseSiteInfo();
                if (!object.Equals(useSiteInfo3.DiagnosticInfo, propertySymbol.GetUseSiteInfo().DiagnosticInfo))
                {
                    return diagnostics.Add(useSiteInfo3, propertySyntax);
                }
                diagnostics.AddDependencies(useSiteInfo3);
                return false;
            }
        }

        private bool IsBadBaseAccess(SyntaxNode node, BoundExpression receiverOpt, Symbol member, BindingDiagnosticBag diagnostics, Symbol propertyOrEventSymbolOpt = null)
        {
            if (receiverOpt != null && receiverOpt.Kind == BoundKind.BaseReference && member.IsAbstract)
            {
                Error(diagnostics, ErrorCode.ERR_AbstractBaseCall, node, propertyOrEventSymbolOpt ?? member);
                return true;
            }
            return false;
        }

        /// <summary>
        /// Computes the scope to which the given invocation can escape
        /// NOTE: the escape scope for ref and val escapes is the same for invocations except for trivial cases (ordinary type returned by val) 
        ///       where escape is known otherwise. Therefore we do not vave two ref/val variants of this.
        ///       
        /// NOTE: we need scopeOfTheContainingExpression as some expressions such as optional <c>in</c> parameters or <c>ref dynamic</c> behave as 
        ///       local variables declared at the scope of the invocation.
        /// </summary>
        internal static uint GetInvocationEscapeScope(
            Symbol symbol,
            BoundExpression receiverOpt,
            ImmutableArray<ParameterSymbol> parameters,
            ImmutableArray<BoundExpression> argsOpt,
            ImmutableArray<RefKind> argRefKindsOpt,
            ImmutableArray<int> argsToParamsOpt,
            uint scopeOfTheContainingExpression,
            bool isRefEscape
        )
        {
            // SPEC: (also applies to the CheckInvocationEscape counterpart)
            //
            //            An lvalue resulting from a ref-returning method invocation e1.M(e2, ...) is ref-safe - to - escape the smallest of the following scopes:
            //	The entire enclosing method
            //	the ref-safe-to-escape of all ref/out/in argument expressions(excluding the receiver)
            //	the safe-to - escape of all argument expressions(including the receiver)
            //
            //            An rvalue resulting from a method invocation e1.M(e2, ...) is safe - to - escape from the smallest of the following scopes:
            //	The entire enclosing method
            //	the safe-to-escape of all argument expressions(including the receiver)
            //

            if (!symbol.RequiresInstanceReceiver())
            {
                // ignore receiver when symbol is static
                receiverOpt = null;
            }

            //by default it is safe to escape
            uint escapeScope = Binder.ExternalScope;

            ArrayBuilder<bool> inParametersMatchedWithArgs = null;

            if (!argsOpt.IsDefault)
            {
            moreArguments:
                for (var argIndex = 0; argIndex < argsOpt.Length; argIndex++)
                {
                    var argument = argsOpt[argIndex];
                    if (argument.Kind == BoundKind.ArgListOperator)
                    {
                        Debug.Assert(argIndex == argsOpt.Length - 1, "vararg must be the last");
                        var argList = (BoundArgListOperator)argument;

                        // unwrap varargs and process as more arguments
                        argsOpt = argList.Arguments;
                        // ref kinds of varargs are not interesting here. 
                        // __refvalue is not ref-returnable, so ref varargs can't come back from a call
                        argRefKindsOpt = default;
                        parameters = ImmutableArray<ParameterSymbol>.Empty;
                        argsToParamsOpt = default;

                        goto moreArguments;
                    }

                    RefKind effectiveRefKind = GetEffectiveRefKindAndMarkMatchedInParameter(argIndex, argRefKindsOpt, parameters, argsToParamsOpt, ref inParametersMatchedWithArgs);

                    // ref escape scope is the narrowest of 
                    // - ref escape of all byref arguments
                    // - val escape of all byval arguments  (ref-like values can be unwrapped into refs, so treat val escape of values as possible ref escape of the result)
                    //
                    // val escape scope is the narrowest of 
                    // - val escape of all byval arguments  (refs cannot be wrapped into values, so their ref escape is irrelevant, only use val escapes)

                    var argEscape = effectiveRefKind != RefKind.None && isRefEscape ?
                                        GetRefEscape(argument, scopeOfTheContainingExpression) :
                                        GetValEscape(argument, scopeOfTheContainingExpression);

                    escapeScope = Math.Max(escapeScope, argEscape);

                    if (escapeScope >= scopeOfTheContainingExpression)
                    {
                        // no longer needed
                        inParametersMatchedWithArgs?.Free();

                        // can't get any worse
                        return escapeScope;
                    }
                }
            }

            // handle omitted optional "in" parameters if there are any
            ParameterSymbol unmatchedInParameter = TryGetunmatchedInParameterAndFreeMatchedArgs(parameters, ref inParametersMatchedWithArgs);

            // unmatched "in" parameter is the same as a literal, its ref escape is scopeOfTheContainingExpression  (can't get any worse)
            //                                                    its val escape is ExternalScope                   (does not affect overall result)
            if (unmatchedInParameter != null && isRefEscape)
            {
                return scopeOfTheContainingExpression;
            }

            // check receiver if ref-like
            if (receiverOpt?.Type?.IsRefLikeType == true)
            {
                escapeScope = Math.Max(escapeScope, GetValEscape(receiverOpt, scopeOfTheContainingExpression));
            }

            return escapeScope;
        }

        /// <summary>
        /// Validates whether given invocation can allow its results to escape from <paramref name="escapeFrom"/> level to <paramref name="escapeTo"/> level.
        /// The result indicates whether the escape is possible. 
        /// Additionally, the method emits diagnostics (possibly more than one, recursively) that would help identify the cause for the failure.
        /// 
        /// NOTE: we need scopeOfTheContainingExpression as some expressions such as optional <c>in</c> parameters or <c>ref dynamic</c> behave as 
        ///       local variables declared at the scope of the invocation.
        /// </summary>
        private static bool CheckInvocationEscape(
            SyntaxNode syntax,
            Symbol symbol,
            BoundExpression receiverOpt,
            ImmutableArray<ParameterSymbol> parameters,
            ImmutableArray<BoundExpression> argsOpt,
            ImmutableArray<RefKind> argRefKindsOpt,
            ImmutableArray<int> argsToParamsOpt,
            bool checkingReceiver,
            uint escapeFrom,
            uint escapeTo,
            BindingDiagnosticBag diagnostics,
            bool isRefEscape
        )
        {
            // SPEC: 
            //            In a method invocation, the following constraints apply:
            //	If there is a ref or out argument to a ref struct type (including the receiver), with safe-to-escape E1, then
            //  o no ref or out argument(excluding the receiver and arguments of ref-like types) may have a narrower ref-safe-to-escape than E1; and
            //  o   no argument(including the receiver) may have a narrower safe-to-escape than E1.

            if (!symbol.RequiresInstanceReceiver())
            {
                // ignore receiver when symbol is static
                receiverOpt = null;
            }

            ArrayBuilder<bool> inParametersMatchedWithArgs = null;

            if (!argsOpt.IsDefault)
            {

            moreArguments:
                for (var argIndex = 0; argIndex < argsOpt.Length; argIndex++)
                {
                    var argument = argsOpt[argIndex];
                    if (argument.Kind == BoundKind.ArgListOperator)
                    {
                        Debug.Assert(argIndex == argsOpt.Length - 1, "vararg must be the last");
                        var argList = (BoundArgListOperator)argument;

                        // unwrap varargs and process as more arguments
                        argsOpt = argList.Arguments;
                        // ref kinds of varargs are not interesting here. 
                        // __refvalue is not ref-returnable, so ref varargs can't come back from a call
                        argRefKindsOpt = default;
                        parameters = ImmutableArray<ParameterSymbol>.Empty;
                        argsToParamsOpt = default;

                        goto moreArguments;
                    }

                    RefKind effectiveRefKind = GetEffectiveRefKindAndMarkMatchedInParameter(argIndex, argRefKindsOpt, parameters, argsToParamsOpt, ref inParametersMatchedWithArgs);

                    // ref escape scope is the narrowest of 
                    // - ref escape of all byref arguments
                    // - val escape of all byval arguments  (ref-like values can be unwrapped into refs, so treat val escape of values as possible ref escape of the result)
                    //
                    // val escape scope is the narrowest of 
                    // - val escape of all byval arguments  (refs cannot be wrapped into values, so their ref escape is irrelevant, only use val escapes)
                    var valid = effectiveRefKind != RefKind.None && isRefEscape ?
                                        CheckRefEscape(argument.Syntax, argument, escapeFrom, escapeTo, false, diagnostics) :
                                        CheckValEscape(argument.Syntax, argument, escapeFrom, escapeTo, false, diagnostics);

                    if (!valid)
                    {
                        // no longer needed
                        inParametersMatchedWithArgs?.Free();

                        ErrorCode errorCode = GetStandardCallEscapeError(checkingReceiver);

                        string parameterName;
                        if (parameters.Length > 0)
                        {
                            var paramIndex = argsToParamsOpt.IsDefault ? argIndex : argsToParamsOpt[argIndex];
                            parameterName = parameters[paramIndex].Name;

                            if (string.IsNullOrEmpty(parameterName))
                            {
                                parameterName = paramIndex.ToString();
                            }
                        }
                        else
                        {
                            parameterName = "__arglist";
                        }

                        Error(diagnostics, errorCode, syntax, symbol, parameterName);
                        return false;
                    }
                }
            }

            // handle omitted optional "in" parameters if there are any
            ParameterSymbol unmatchedInParameter = TryGetunmatchedInParameterAndFreeMatchedArgs(parameters, ref inParametersMatchedWithArgs);

            // unmatched "in" parameter is the same as a literal, its ref escape is scopeOfTheContainingExpression  (can't get any worse)
            //                                                    its val escape is ExternalScope                   (does not affect overall result)
            if (unmatchedInParameter != null && isRefEscape)
            {
                var parameterName = unmatchedInParameter.Name;
                if (string.IsNullOrEmpty(parameterName))
                {
                    parameterName = unmatchedInParameter.Ordinal.ToString();
                }
                Error(diagnostics, GetStandardCallEscapeError(checkingReceiver), syntax, symbol, parameterName);
                return false;
            }

            // check receiver if ref-like
            if (receiverOpt?.Type?.IsRefLikeType == true)
            {
                return CheckValEscape(receiverOpt.Syntax, receiverOpt, escapeFrom, escapeTo, false, diagnostics);
            }

            return true;
        }

        /// <summary>
        /// Validates whether the invocation is valid per no-mixing rules.
        /// Returns <see langword="false"/> when it is not valid and produces diagnostics (possibly more than one recursively) that helps to figure the reason.
        /// </summary>
        private static bool CheckInvocationArgMixing(
            SyntaxNode syntax,
            Symbol symbol,
            BoundExpression receiverOpt,
            ImmutableArray<ParameterSymbol> parameters,
            ImmutableArray<BoundExpression> argsOpt,
            ImmutableArray<int> argsToParamsOpt,
            uint scopeOfTheContainingExpression,
            BindingDiagnosticBag diagnostics)
        {
            // SPEC:
            // In a method invocation, the following constraints apply:
            // - If there is a ref or out argument of a ref struct type (including the receiver), with safe-to-escape E1, then
            // - no argument (including the receiver) may have a narrower safe-to-escape than E1.

            if (!symbol.RequiresInstanceReceiver())
            {
                // ignore receiver when symbol is static
                receiverOpt = null;
            }

            // widest possible escape via writeable ref-like receiver or ref/out argument.
            uint escapeTo = scopeOfTheContainingExpression;

            // collect all writeable ref-like arguments, including receiver
            var receiverType = receiverOpt?.Type;
            if (receiverType?.IsRefLikeType == true && !isReceiverRefReadOnly(symbol))
            {
                escapeTo = GetValEscape(receiverOpt, scopeOfTheContainingExpression);
            }

            if (!argsOpt.IsDefault)
            {
                BoundArgListOperator argList = null;
                for (var argIndex = 0; argIndex < argsOpt.Length; argIndex++)
                {
                    var argument = argsOpt[argIndex];
                    if (argument.Kind == BoundKind.ArgListOperator)
                    {
                        Debug.Assert(argIndex == argsOpt.Length - 1, "vararg must be the last");
                        argList = (BoundArgListOperator)argument;
                        break;
                    }

                    var paramIndex = argsToParamsOpt.IsDefault ? argIndex : argsToParamsOpt[argIndex];
                    if (parameters[paramIndex].RefKind.IsWritableReference() && argument.Type?.IsRefLikeType == true)
                    {
                        escapeTo = Math.Min(escapeTo, GetValEscape(argument, scopeOfTheContainingExpression));
                    }
                }

                if (argList != null)
                {
                    var argListArgs = argList.Arguments;
                    var argListRefKindsOpt = argList.ArgumentRefKindsOpt;

                    for (var argIndex = 0; argIndex < argListArgs.Length; argIndex++)
                    {
                        var argument = argListArgs[argIndex];
                        var refKind = argListRefKindsOpt.IsDefault ? RefKind.None : argListRefKindsOpt[argIndex];
                        if (refKind.IsWritableReference() && argument.Type?.IsRefLikeType == true)
                        {
                            escapeTo = Math.Min(escapeTo, GetValEscape(argument, scopeOfTheContainingExpression));
                        }
                    }
                }
            }

            if (escapeTo == scopeOfTheContainingExpression)
            {
                // cannot fail. common case.
                return true;
            }

            if (!argsOpt.IsDefault)
            {
            moreArguments:
                for (var argIndex = 0; argIndex < argsOpt.Length; argIndex++)
                {
                    // check val escape of all arguments
                    var argument = argsOpt[argIndex];
                    if (argument.Kind == BoundKind.ArgListOperator)
                    {
                        Debug.Assert(argIndex == argsOpt.Length - 1, "vararg must be the last");
                        var argList = (BoundArgListOperator)argument;

                        // unwrap varargs and process as more arguments
                        argsOpt = argList.Arguments;
                        parameters = ImmutableArray<ParameterSymbol>.Empty;
                        argsToParamsOpt = default;

                        goto moreArguments;
                    }

                    var valid = CheckValEscape(argument.Syntax, argument, scopeOfTheContainingExpression, escapeTo, false, diagnostics);

                    if (!valid)
                    {
                        string parameterName;
                        if (parameters.Length > 0)
                        {
                            var paramIndex = argsToParamsOpt.IsDefault ? argIndex : argsToParamsOpt[argIndex];
                            parameterName = parameters[paramIndex].Name;
                        }
                        else
                        {
                            parameterName = "__arglist";
                        }

                        Error(diagnostics, ErrorCode.ERR_CallArgMixing, syntax, symbol, parameterName);
                        return false;
                    }
                }
            }

            //NB: we do not care about unmatched "in" parameters here. 
            //    They have "outer" val escape, so cannot be worse than escapeTo.

            // check val escape of receiver if ref-like
            if (receiverOpt?.Type?.IsRefLikeType == true)
            {
                return CheckValEscape(receiverOpt.Syntax, receiverOpt, scopeOfTheContainingExpression, escapeTo, false, diagnostics);
            }

            return true;

            static bool isReceiverRefReadOnly(Symbol methodOrPropertySymbol) => methodOrPropertySymbol switch
            {
                MethodSymbol m => m.IsEffectivelyReadOnly,
                // TODO: val escape checks should be skipped for property accesses when
                // we can determine the only accessors being called are readonly.
                // For now we are pessimistic and check escape if any accessor is non-readonly.
                // Tracking in https://github.com/dotnet/roslyn/issues/35606
                PropertySymbol p => p.GetMethod?.IsEffectivelyReadOnly != false && p.SetMethod?.IsEffectivelyReadOnly != false,
                _ => throw ExceptionUtilities.UnexpectedValue(methodOrPropertySymbol)
            };
        }

        private static RefKind GetEffectiveRefKindAndMarkMatchedInParameter(int argIndex, ImmutableArray<RefKind> argRefKindsOpt, ImmutableArray<ParameterSymbol> parameters, ImmutableArray<int> argsToParamsOpt, ref ArrayBuilder<bool> inParametersMatchedWithArgs)
        {
            RefKind refKind = ((!argRefKindsOpt.IsDefault) ? argRefKindsOpt[argIndex] : RefKind.None);
            if ((refKind == RefKind.None || refKind == RefKind.In) && argIndex < parameters.Length)
            {
                int index = (argsToParamsOpt.IsDefault ? argIndex : argsToParamsOpt[argIndex]);
                if (parameters[index].RefKind == RefKind.In)
                {
                    refKind = RefKind.In;
                    inParametersMatchedWithArgs ??= ArrayBuilder<bool>.GetInstance(parameters.Length, fillWithValue: false);
                    inParametersMatchedWithArgs[index] = true;
                }
            }
            return refKind;
        }

        private static ParameterSymbol TryGetunmatchedInParameterAndFreeMatchedArgs(ImmutableArray<ParameterSymbol> parameters, ref ArrayBuilder<bool> inParametersMatchedWithArgs)
        {
            try
            {
                if (!parameters.IsDefault)
                {
                    for (int i = 0; i < parameters.Length; i++)
                    {
                        ParameterSymbol parameterSymbol = parameters[i];
                        if (parameterSymbol.IsParams)
                        {
                            break;
                        }
                        if (parameterSymbol.RefKind == RefKind.In)
                        {
                            ArrayBuilder<bool> obj = inParametersMatchedWithArgs;
                            if ((obj == null || !obj[i]) && !parameterSymbol.Type.IsRefLikeType)
                            {
                                return parameterSymbol;
                            }
                        }
                    }
                }
                return null;
            }
            finally
            {
                inParametersMatchedWithArgs?.Free();
                inParametersMatchedWithArgs = null;
            }
        }

        private static ErrorCode GetStandardCallEscapeError(bool checkingReceiver)
        {
            if (!checkingReceiver)
            {
                return ErrorCode.ERR_EscapeCall;
            }
            return ErrorCode.ERR_EscapeCall2;
        }

        private static void ReportReadonlyLocalError(SyntaxNode node, LocalSymbol local, BindValueKind kind, bool checkingReceiver, BindingDiagnosticBag diagnostics)
        {
            MessageID id;
            if (local.IsForEach)
            {
                id = MessageID.IDS_FOREACHLOCAL;
            }
            else if (local.IsUsing)
            {
                id = MessageID.IDS_USINGLOCAL;
            }
            else
            {
                if (!local.IsFixed)
                {
                    Error(diagnostics, GetStandardLvalueError(kind), node);
                    return;
                }
                id = MessageID.IDS_FIXEDLOCAL;
            }
            ErrorCode[] array = new ErrorCode[4]
            {
                ErrorCode.ERR_RefReadonlyLocalCause,
                ErrorCode.ERR_AssgReadonlyLocalCause,
                ErrorCode.ERR_RefReadonlyLocal2Cause,
                ErrorCode.ERR_AssgReadonlyLocal2Cause
            };
            int num = (checkingReceiver ? 2 : 0) + ((!RequiresRefOrOut(kind)) ? 1 : 0);
            Error(diagnostics, array[num], node, local, id.Localize());
        }

        private static ErrorCode GetThisLvalueError(BindValueKind kind, bool isValueType)
        {
            switch (kind)
            {
                case BindValueKind.Assignable:
                case BindValueKind.CompoundAssignment:
                    return ErrorCode.ERR_AssgReadonlyLocal;
                case BindValueKind.RefOrOut:
                    return ErrorCode.ERR_RefReadonlyLocal;
                case BindValueKind.AddressOf:
                    return ErrorCode.ERR_InvalidAddrOp;
                case BindValueKind.IncrementDecrement:
                    if (!isValueType)
                    {
                        return ErrorCode.ERR_IncrementLvalueExpected;
                    }
                    return ErrorCode.ERR_AssgReadonlyLocal;
                case BindValueKind.ReadonlyRef:
                case BindValueKind.RefReturn:
                    return ErrorCode.ERR_RefReturnThis;
                case BindValueKind.RefAssignable:
                    return ErrorCode.ERR_RefLocalOrParamExpected;
                default:
                    if (RequiresReferenceToLocation(kind))
                    {
                        return ErrorCode.ERR_RefLvalueExpected;
                    }
                    throw ExceptionUtilities.UnexpectedValue(kind);
            }
        }

        private static ErrorCode GetRangeLvalueError(BindValueKind kind)
        {
            switch (kind)
            {
                case BindValueKind.Assignable:
                case BindValueKind.CompoundAssignment:
                case BindValueKind.IncrementDecrement:
                    return ErrorCode.ERR_QueryRangeVariableReadOnly;
                case BindValueKind.AddressOf:
                    return ErrorCode.ERR_InvalidAddrOp;
                case BindValueKind.ReadonlyRef:
                case BindValueKind.RefReturn:
                    return ErrorCode.ERR_RefReturnRangeVariable;
                case BindValueKind.RefAssignable:
                    return ErrorCode.ERR_RefLocalOrParamExpected;
                default:
                    if (RequiresReferenceToLocation(kind))
                    {
                        return ErrorCode.ERR_QueryOutRefRangeVariable;
                    }
                    throw ExceptionUtilities.UnexpectedValue(kind);
            }
        }

        private static ErrorCode GetMethodGroupOrFunctionPointerLvalueError(BindValueKind valueKind)
        {
            if (RequiresReferenceToLocation(valueKind))
            {
                return ErrorCode.ERR_RefReadonlyLocalCause;
            }
            return ErrorCode.ERR_AssgReadonlyLocalCause;
        }

        private static ErrorCode GetStandardLvalueError(BindValueKind kind)
        {
            switch (kind)
            {
                case BindValueKind.Assignable:
                case BindValueKind.CompoundAssignment:
                    return ErrorCode.ERR_AssgLvalueExpected;
                case BindValueKind.AddressOf:
                    return ErrorCode.ERR_InvalidAddrOp;
                case BindValueKind.IncrementDecrement:
                    return ErrorCode.ERR_IncrementLvalueExpected;
                case BindValueKind.FixedReceiver:
                    return ErrorCode.ERR_FixedNeedsLvalue;
                case BindValueKind.ReadonlyRef:
                case BindValueKind.RefReturn:
                    return ErrorCode.ERR_RefReturnLvalueExpected;
                case BindValueKind.RefAssignable:
                    return ErrorCode.ERR_RefLocalOrParamExpected;
                default:
                    if (RequiresReferenceToLocation(kind))
                    {
                        return ErrorCode.ERR_RefLvalueExpected;
                    }
                    throw ExceptionUtilities.UnexpectedValue(kind);
            }
        }

        private static ErrorCode GetStandardRValueRefEscapeError(uint escapeTo)
        {
            if (escapeTo == 0)
            {
                return ErrorCode.ERR_RefReturnLvalueExpected;
            }
            return ErrorCode.ERR_EscapeOther;
        }

        private static void ReportReadOnlyFieldError(FieldSymbol field, SyntaxNode node, BindValueKind kind, bool checkingReceiver, BindingDiagnosticBag diagnostics)
        {
            if (kind == BindValueKind.AddressOf)
            {
                Error(diagnostics, ErrorCode.ERR_InvalidAddrOp, node);
                return;
            }
            ErrorCode[] array = new ErrorCode[12]
            {
                ErrorCode.ERR_RefReturnReadonly,
                ErrorCode.ERR_RefReadonly,
                ErrorCode.ERR_AssgReadonly,
                ErrorCode.ERR_RefReturnReadonlyStatic,
                ErrorCode.ERR_RefReadonlyStatic,
                ErrorCode.ERR_AssgReadonlyStatic,
                ErrorCode.ERR_RefReturnReadonly2,
                ErrorCode.ERR_RefReadonly2,
                ErrorCode.ERR_AssgReadonly2,
                ErrorCode.ERR_RefReturnReadonlyStatic2,
                ErrorCode.ERR_RefReadonlyStatic2,
                ErrorCode.ERR_AssgReadonlyStatic2
            };
            int num = (checkingReceiver ? 6 : 0) + (field.IsStatic ? 3 : 0) + ((kind != BindValueKind.RefReturn) ? (RequiresRefOrOut(kind) ? 1 : 2) : 0);
            if (checkingReceiver)
            {
                Error(diagnostics, array[num], node, field);
            }
            else
            {
                Error(diagnostics, array[num], node);
            }
        }

        private static void ReportReadOnlyError(Symbol symbol, SyntaxNode node, BindValueKind kind, bool checkingReceiver, BindingDiagnosticBag diagnostics)
        {
            if (kind == BindValueKind.AddressOf)
            {
                Error(diagnostics, ErrorCode.ERR_InvalidAddrOp, node);
                return;
            }
            LocalizableErrorArgument localizableErrorArgument = symbol.Kind.Localize();
            ErrorCode[] array = new ErrorCode[6]
            {
                ErrorCode.ERR_RefReturnReadonlyNotField,
                ErrorCode.ERR_RefReadonlyNotField,
                ErrorCode.ERR_AssignReadonlyNotField,
                ErrorCode.ERR_RefReturnReadonlyNotField2,
                ErrorCode.ERR_RefReadonlyNotField2,
                ErrorCode.ERR_AssignReadonlyNotField2
            };
            int num = (checkingReceiver ? 3 : 0) + ((kind != BindValueKind.RefReturn) ? (RequiresRefOrOut(kind) ? 1 : 2) : 0);
            Error(diagnostics, array[num], node, localizableErrorArgument, symbol);
        }

        internal BoundExpression ValidateEscape(BoundExpression expr, uint escapeTo, bool isByRef, BindingDiagnosticBag diagnostics)
        {
            if (isByRef)
            {
                if (CheckRefEscape(expr.Syntax, expr, LocalScopeDepth, escapeTo, checkingReceiver: false, diagnostics))
                {
                    return expr;
                }
            }
            else if (CheckValEscape(expr.Syntax, expr, LocalScopeDepth, escapeTo, checkingReceiver: false, diagnostics))
            {
                return expr;
            }
            return ToBadExpression(expr);
        }

        internal static uint GetRefEscape(BoundExpression expr, uint scopeOfTheContainingExpression)
        {
            if (expr.HasAnyErrors)
            {
                return 0u;
            }
            TypeSymbol? type = expr.Type;
            if ((object)type != null && type.GetSpecialTypeSafe() == SpecialType.System_Void)
            {
                return 0u;
            }
            if (expr.ConstantValue != null)
            {
                return scopeOfTheContainingExpression;
            }
            switch (expr.Kind)
            {
                case BoundKind.PointerIndirectionOperator:
                case BoundKind.PointerElementAccess:
                case BoundKind.ArrayAccess:
                    return 0u;
                case BoundKind.RefValueOperator:
                    return 1u;
                case BoundKind.Parameter:
                    if (((BoundParameter)expr).ParameterSymbol.RefKind != 0)
                    {
                        return 0u;
                    }
                    return 1u;
                case BoundKind.Local:
                    return ((BoundLocal)expr).LocalSymbol.RefEscapeScope;
                case BoundKind.ThisReference:
                    if (((BoundThisReference)expr).Type.IsValueType)
                    {
                        return 1u;
                    }
                    break;
                case BoundKind.ConditionalOperator:
                    {
                        BoundConditionalOperator boundConditionalOperator = (BoundConditionalOperator)expr;
                        if (boundConditionalOperator.IsRef)
                        {
                            return Math.Max(GetRefEscape(boundConditionalOperator.Consequence, scopeOfTheContainingExpression), GetRefEscape(boundConditionalOperator.Alternative, scopeOfTheContainingExpression));
                        }
                        break;
                    }
                case BoundKind.FieldAccess:
                    {
                        BoundFieldAccess boundFieldAccess = (BoundFieldAccess)expr;
                        FieldSymbol fieldSymbol = boundFieldAccess.FieldSymbol;
                        if (fieldSymbol.IsStatic || fieldSymbol.ContainingType.IsReferenceType)
                        {
                            return 0u;
                        }
                        return GetRefEscape(boundFieldAccess.ReceiverOpt, scopeOfTheContainingExpression);
                    }
                case BoundKind.EventAccess:
                    {
                        BoundEventAccess boundEventAccess = (BoundEventAccess)expr;
                        if (boundEventAccess.IsUsableAsField)
                        {
                            EventSymbol eventSymbol = boundEventAccess.EventSymbol;
                            if (eventSymbol.IsStatic || eventSymbol.ContainingType.IsReferenceType)
                            {
                                return 0u;
                            }
                            return GetRefEscape(boundEventAccess.ReceiverOpt, scopeOfTheContainingExpression);
                        }
                        break;
                    }
                case BoundKind.Call:
                    {
                        BoundCall boundCall = (BoundCall)expr;
                        MethodSymbol signature = boundCall.Method;
                        if (signature.RefKind != 0)
                        {
                            return GetInvocationEscapeScope(boundCall.Method, boundCall.ReceiverOpt, signature.Parameters, boundCall.Arguments, boundCall.ArgumentRefKindsOpt, boundCall.ArgsToParamsOpt, scopeOfTheContainingExpression, isRefEscape: true);
                        }
                        break;
                    }
                case BoundKind.FunctionPointerInvocation:
                    {
                        BoundFunctionPointerInvocation boundFunctionPointerInvocation = (BoundFunctionPointerInvocation)expr;
                        MethodSymbol signature = boundFunctionPointerInvocation.FunctionPointer.Signature;
                        if (signature.RefKind != 0)
                        {
                            return GetInvocationEscapeScope(signature, null, signature.Parameters, boundFunctionPointerInvocation.Arguments, boundFunctionPointerInvocation.ArgumentRefKindsOpt, default(ImmutableArray<int>), scopeOfTheContainingExpression, isRefEscape: true);
                        }
                        break;
                    }
                case BoundKind.IndexerAccess:
                    {
                        BoundIndexerAccess boundIndexerAccess = (BoundIndexerAccess)expr;
                        PropertySymbol indexer = boundIndexerAccess.Indexer;
                        return GetInvocationEscapeScope(indexer, boundIndexerAccess.ReceiverOpt, indexer.Parameters, boundIndexerAccess.Arguments, boundIndexerAccess.ArgumentRefKindsOpt, boundIndexerAccess.ArgsToParamsOpt, scopeOfTheContainingExpression, isRefEscape: true);
                    }
                case BoundKind.PropertyAccess:
                    {
                        BoundPropertyAccess boundPropertyAccess = (BoundPropertyAccess)expr;
                        return GetInvocationEscapeScope(boundPropertyAccess.PropertySymbol, boundPropertyAccess.ReceiverOpt, default(ImmutableArray<ParameterSymbol>), default(ImmutableArray<BoundExpression>), default(ImmutableArray<RefKind>), default(ImmutableArray<int>), scopeOfTheContainingExpression, isRefEscape: true);
                    }
                case BoundKind.AssignmentOperator:
                    {
                        BoundAssignmentOperator boundAssignmentOperator = (BoundAssignmentOperator)expr;
                        if (boundAssignmentOperator.IsRef)
                        {
                            return GetRefEscape(boundAssignmentOperator.Left, scopeOfTheContainingExpression);
                        }
                        break;
                    }
            }
            return scopeOfTheContainingExpression;
        }

        internal static bool CheckRefEscape(SyntaxNode node, BoundExpression expr, uint escapeFrom, uint escapeTo, bool checkingReceiver, BindingDiagnosticBag diagnostics)
        {
            if (escapeTo >= escapeFrom)
            {
                return true;
            }
            if (expr.HasAnyErrors)
            {
                return true;
            }
            TypeSymbol? type = expr.Type;
            if ((object)type != null && type.GetSpecialTypeSafe() == SpecialType.System_Void)
            {
                return true;
            }
            if (expr.ConstantValue != null)
            {
                Error(diagnostics, GetStandardRValueRefEscapeError(escapeTo), node);
                return false;
            }
            switch (expr.Kind)
            {
                case BoundKind.PointerIndirectionOperator:
                case BoundKind.PointerElementAccess:
                case BoundKind.ArrayAccess:
                    return true;
                case BoundKind.RefValueOperator:
                    if (escapeTo != 0)
                    {
                        return true;
                    }
                    break;
                case BoundKind.Parameter:
                    {
                        BoundParameter parameter = (BoundParameter)expr;
                        return CheckParameterRefEscape(node, parameter, escapeTo, checkingReceiver, diagnostics);
                    }
                case BoundKind.Local:
                    {
                        BoundLocal local = (BoundLocal)expr;
                        return CheckLocalRefEscape(node, local, escapeTo, checkingReceiver, diagnostics);
                    }
                case BoundKind.ThisReference:
                    if (((BoundThisReference)expr).Type.IsValueType)
                    {
                        if (escapeTo == 0)
                        {
                            Error(diagnostics, ErrorCode.ERR_RefReturnStructThis, node, "this");
                            return false;
                        }
                        return true;
                    }
                    break;
                case BoundKind.ConditionalOperator:
                    {
                        BoundConditionalOperator boundConditionalOperator = (BoundConditionalOperator)expr;
                        if (boundConditionalOperator.IsRef)
                        {
                            if (CheckRefEscape(boundConditionalOperator.Consequence.Syntax, boundConditionalOperator.Consequence, escapeFrom, escapeTo, checkingReceiver: false, diagnostics))
                            {
                                return CheckRefEscape(boundConditionalOperator.Alternative.Syntax, boundConditionalOperator.Alternative, escapeFrom, escapeTo, checkingReceiver: false, diagnostics);
                            }
                            return false;
                        }
                        break;
                    }
                case BoundKind.FieldAccess:
                    {
                        BoundFieldAccess fieldAccess = (BoundFieldAccess)expr;
                        return CheckFieldRefEscape(node, fieldAccess, escapeFrom, escapeTo, diagnostics);
                    }
                case BoundKind.EventAccess:
                    {
                        BoundEventAccess boundEventAccess = (BoundEventAccess)expr;
                        if (boundEventAccess.IsUsableAsField)
                        {
                            return CheckFieldLikeEventRefEscape(node, boundEventAccess, escapeFrom, escapeTo, diagnostics);
                        }
                        break;
                    }
                case BoundKind.Call:
                    {
                        BoundCall boundCall = (BoundCall)expr;
                        MethodSymbol method = boundCall.Method;
                        if (method.RefKind != 0)
                        {
                            return CheckInvocationEscape(boundCall.Syntax, method, boundCall.ReceiverOpt, method.Parameters, boundCall.Arguments, boundCall.ArgumentRefKindsOpt, boundCall.ArgsToParamsOpt, checkingReceiver, escapeFrom, escapeTo, diagnostics, isRefEscape: true);
                        }
                        break;
                    }
                case BoundKind.IndexerAccess:
                    {
                        BoundIndexerAccess boundIndexerAccess = (BoundIndexerAccess)expr;
                        PropertySymbol indexer = boundIndexerAccess.Indexer;
                        if (indexer.RefKind != 0)
                        {
                            return CheckInvocationEscape(boundIndexerAccess.Syntax, indexer, boundIndexerAccess.ReceiverOpt, indexer.Parameters, boundIndexerAccess.Arguments, boundIndexerAccess.ArgumentRefKindsOpt, boundIndexerAccess.ArgsToParamsOpt, checkingReceiver, escapeFrom, escapeTo, diagnostics, isRefEscape: true);
                        }
                        break;
                    }
                case BoundKind.IndexOrRangePatternIndexerAccess:
                    {
                        BoundIndexOrRangePatternIndexerAccess boundIndexOrRangePatternIndexerAccess = (BoundIndexOrRangePatternIndexerAccess)expr;
                        Symbol patternSymbol = boundIndexOrRangePatternIndexerAccess.PatternSymbol;
                        RefKind refKind;
                        ImmutableArray<ParameterSymbol> parameters;
                        if (!(patternSymbol is PropertySymbol propertySymbol2))
                        {
                            if (!(patternSymbol is MethodSymbol methodSymbol))
                            {
                                throw ExceptionUtilities.Unreachable;
                            }
                            refKind = methodSymbol.RefKind;
                            parameters = methodSymbol.Parameters;
                        }
                        else
                        {
                            refKind = propertySymbol2.RefKind;
                            parameters = propertySymbol2.Parameters;
                        }
                        if (refKind != 0)
                        {
                            return CheckInvocationEscape(boundIndexOrRangePatternIndexerAccess.Syntax, boundIndexOrRangePatternIndexerAccess.PatternSymbol, boundIndexOrRangePatternIndexerAccess.Receiver, parameters, ImmutableArray.Create(boundIndexOrRangePatternIndexerAccess.Argument), default(ImmutableArray<RefKind>), default(ImmutableArray<int>), checkingReceiver, escapeFrom, escapeTo, diagnostics, isRefEscape: true);
                        }
                        break;
                    }
                case BoundKind.FunctionPointerInvocation:
                    {
                        BoundFunctionPointerInvocation boundFunctionPointerInvocation = (BoundFunctionPointerInvocation)expr;
                        FunctionPointerMethodSymbol signature = boundFunctionPointerInvocation.FunctionPointer.Signature;
                        if (signature.RefKind != 0)
                        {
                            return CheckInvocationEscape(boundFunctionPointerInvocation.Syntax, signature, boundFunctionPointerInvocation.InvokedExpression, signature.Parameters, boundFunctionPointerInvocation.Arguments, boundFunctionPointerInvocation.ArgumentRefKindsOpt, default(ImmutableArray<int>), checkingReceiver, escapeFrom, escapeTo, diagnostics, isRefEscape: true);
                        }
                        break;
                    }
                case BoundKind.PropertyAccess:
                    {
                        BoundPropertyAccess boundPropertyAccess = (BoundPropertyAccess)expr;
                        PropertySymbol propertySymbol = boundPropertyAccess.PropertySymbol;
                        if (propertySymbol.RefKind != 0)
                        {
                            return CheckInvocationEscape(boundPropertyAccess.Syntax, propertySymbol, boundPropertyAccess.ReceiverOpt, default(ImmutableArray<ParameterSymbol>), default(ImmutableArray<BoundExpression>), default(ImmutableArray<RefKind>), default(ImmutableArray<int>), checkingReceiver, escapeFrom, escapeTo, diagnostics, isRefEscape: true);
                        }
                        break;
                    }
                case BoundKind.AssignmentOperator:
                    {
                        BoundAssignmentOperator boundAssignmentOperator = (BoundAssignmentOperator)expr;
                        if (boundAssignmentOperator.IsRef)
                        {
                            return CheckRefEscape(node, boundAssignmentOperator.Left, escapeFrom, escapeTo, checkingReceiver: false, diagnostics);
                        }
                        break;
                    }
            }
            Error(diagnostics, GetStandardRValueRefEscapeError(escapeTo), node);
            return false;
        }

        internal static uint GetBroadestValEscape(BoundTupleExpression expr, uint scopeOfTheContainingExpression)
        {
            uint num = scopeOfTheContainingExpression;
            ImmutableArray<BoundExpression>.Enumerator enumerator = expr.Arguments.GetEnumerator();
            while (enumerator.MoveNext())
            {
                BoundExpression current = enumerator.Current;
                uint val = ((!(current is BoundTupleExpression expr2)) ? GetValEscape(current, scopeOfTheContainingExpression) : GetBroadestValEscape(expr2, scopeOfTheContainingExpression));
                num = Math.Min(num, val);
            }
            return num;
        }

        internal static uint GetValEscape(BoundExpression expr, uint scopeOfTheContainingExpression)
        {
            if (expr.HasAnyErrors)
            {
                return 0u;
            }
            if (expr.ConstantValue != null)
            {
                return 0u;
            }
            TypeSymbol? type = expr.Type;
            if ((object)type == null || !type!.IsRefLikeType)
            {
                return 0u;
            }
            switch (expr.Kind)
            {
                case BoundKind.DefaultLiteral:
                case BoundKind.DefaultExpression:
                case BoundKind.ThisReference:
                case BoundKind.Parameter:
                    return 0u;
                case BoundKind.TupleLiteral:
                case BoundKind.ConvertedTupleLiteral:
                    return GetTupleValEscape(((BoundTupleExpression)expr).Arguments, scopeOfTheContainingExpression);
                case BoundKind.MakeRefOperator:
                case BoundKind.RefValueOperator:
                    return 0u;
                case BoundKind.DiscardExpression:
                    return 0u;
                case BoundKind.DeconstructValuePlaceholder:
                    return ((BoundDeconstructValuePlaceholder)expr).ValEscape;
                case BoundKind.Local:
                    return ((BoundLocal)expr).LocalSymbol.ValEscapeScope;
                case BoundKind.StackAllocArrayCreation:
                case BoundKind.ConvertedStackAllocExpression:
                    return 1u;
                case BoundKind.ConditionalOperator:
                    {
                        BoundConditionalOperator boundConditionalOperator = (BoundConditionalOperator)expr;
                        uint valEscape = GetValEscape(boundConditionalOperator.Consequence, scopeOfTheContainingExpression);
                        if (boundConditionalOperator.IsRef)
                        {
                            return valEscape;
                        }
                        return Math.Max(valEscape, GetValEscape(boundConditionalOperator.Alternative, scopeOfTheContainingExpression));
                    }
                case BoundKind.NullCoalescingOperator:
                    {
                        BoundNullCoalescingOperator boundNullCoalescingOperator = (BoundNullCoalescingOperator)expr;
                        return Math.Max(GetValEscape(boundNullCoalescingOperator.LeftOperand, scopeOfTheContainingExpression), GetValEscape(boundNullCoalescingOperator.RightOperand, scopeOfTheContainingExpression));
                    }
                case BoundKind.FieldAccess:
                    {
                        BoundFieldAccess boundFieldAccess = (BoundFieldAccess)expr;
                        FieldSymbol fieldSymbol = boundFieldAccess.FieldSymbol;
                        if (fieldSymbol.IsStatic || !fieldSymbol.ContainingType.IsRefLikeType)
                        {
                            return 0u;
                        }
                        return GetValEscape(boundFieldAccess.ReceiverOpt, scopeOfTheContainingExpression);
                    }
                case BoundKind.Call:
                    {
                        BoundCall boundCall = (BoundCall)expr;
                        return GetInvocationEscapeScope(boundCall.Method, boundCall.ReceiverOpt, boundCall.Method.Parameters, boundCall.Arguments, boundCall.ArgumentRefKindsOpt, boundCall.ArgsToParamsOpt, scopeOfTheContainingExpression, isRefEscape: false);
                    }
                case BoundKind.FunctionPointerInvocation:
                    {
                        BoundFunctionPointerInvocation boundFunctionPointerInvocation = (BoundFunctionPointerInvocation)expr;
                        FunctionPointerMethodSymbol signature = boundFunctionPointerInvocation.FunctionPointer.Signature;
                        return GetInvocationEscapeScope(signature, null, signature.Parameters, boundFunctionPointerInvocation.Arguments, boundFunctionPointerInvocation.ArgumentRefKindsOpt, default(ImmutableArray<int>), scopeOfTheContainingExpression, isRefEscape: false);
                    }
                case BoundKind.IndexerAccess:
                    {
                        BoundIndexerAccess boundIndexerAccess = (BoundIndexerAccess)expr;
                        PropertySymbol indexer = boundIndexerAccess.Indexer;
                        return GetInvocationEscapeScope(indexer, boundIndexerAccess.ReceiverOpt, indexer.Parameters, boundIndexerAccess.Arguments, boundIndexerAccess.ArgumentRefKindsOpt, boundIndexerAccess.ArgsToParamsOpt, scopeOfTheContainingExpression, isRefEscape: false);
                    }
                case BoundKind.IndexOrRangePatternIndexerAccess:
                    {
                        BoundIndexOrRangePatternIndexerAccess boundIndexOrRangePatternIndexerAccess = (BoundIndexOrRangePatternIndexerAccess)expr;
                        Symbol patternSymbol = boundIndexOrRangePatternIndexerAccess.PatternSymbol;
                        ImmutableArray<ParameterSymbol> parameters;
                        if (!(patternSymbol is PropertySymbol propertySymbol))
                        {
                            if (!(patternSymbol is MethodSymbol methodSymbol))
                            {
                                throw ExceptionUtilities.UnexpectedValue(boundIndexOrRangePatternIndexerAccess.PatternSymbol);
                            }
                            parameters = methodSymbol.Parameters;
                        }
                        else
                        {
                            parameters = propertySymbol.Parameters;
                        }
                        ImmutableArray<ParameterSymbol> parameters2 = parameters;
                        return GetInvocationEscapeScope(boundIndexOrRangePatternIndexerAccess.PatternSymbol, boundIndexOrRangePatternIndexerAccess.Receiver, parameters2, default(ImmutableArray<BoundExpression>), default(ImmutableArray<RefKind>), default(ImmutableArray<int>), scopeOfTheContainingExpression, isRefEscape: false);
                    }
                case BoundKind.PropertyAccess:
                    {
                        BoundPropertyAccess boundPropertyAccess = (BoundPropertyAccess)expr;
                        return GetInvocationEscapeScope(boundPropertyAccess.PropertySymbol, boundPropertyAccess.ReceiverOpt, default(ImmutableArray<ParameterSymbol>), default(ImmutableArray<BoundExpression>), default(ImmutableArray<RefKind>), default(ImmutableArray<int>), scopeOfTheContainingExpression, isRefEscape: false);
                    }
                case BoundKind.ObjectCreationExpression:
                    {
                        BoundObjectCreationExpression boundObjectCreationExpression = (BoundObjectCreationExpression)expr;
                        MethodSymbol constructor = boundObjectCreationExpression.Constructor;
                        uint num = GetInvocationEscapeScope(constructor, null, constructor.Parameters, boundObjectCreationExpression.Arguments, boundObjectCreationExpression.ArgumentRefKindsOpt, boundObjectCreationExpression.ArgsToParamsOpt, scopeOfTheContainingExpression, isRefEscape: false);
                        BoundObjectInitializerExpressionBase initializerExpressionOpt = boundObjectCreationExpression.InitializerExpressionOpt;
                        if (initializerExpressionOpt != null)
                        {
                            num = Math.Max(num, GetValEscape(initializerExpressionOpt, scopeOfTheContainingExpression));
                        }
                        return num;
                    }
                case BoundKind.WithExpression:
                    {
                        BoundWithExpression boundWithExpression = (BoundWithExpression)expr;
                        return Math.Max(GetValEscape(boundWithExpression.Receiver, scopeOfTheContainingExpression), GetValEscape(boundWithExpression.InitializerExpression, scopeOfTheContainingExpression));
                    }
                case BoundKind.UnaryOperator:
                    return GetValEscape(((BoundUnaryOperator)expr).Operand, scopeOfTheContainingExpression);
                case BoundKind.Conversion:
                    return GetValEscape(((BoundConversion)expr).Operand, scopeOfTheContainingExpression);
                case BoundKind.AssignmentOperator:
                    return GetValEscape(((BoundAssignmentOperator)expr).Right, scopeOfTheContainingExpression);
                case BoundKind.IncrementOperator:
                    return GetValEscape(((BoundIncrementOperator)expr).Operand, scopeOfTheContainingExpression);
                case BoundKind.CompoundAssignmentOperator:
                    {
                        BoundCompoundAssignmentOperator boundCompoundAssignmentOperator = (BoundCompoundAssignmentOperator)expr;
                        return Math.Max(GetValEscape(boundCompoundAssignmentOperator.Left, scopeOfTheContainingExpression), GetValEscape(boundCompoundAssignmentOperator.Right, scopeOfTheContainingExpression));
                    }
                case BoundKind.BinaryOperator:
                    {
                        BoundBinaryOperator boundBinaryOperator = (BoundBinaryOperator)expr;
                        return Math.Max(GetValEscape(boundBinaryOperator.Left, scopeOfTheContainingExpression), GetValEscape(boundBinaryOperator.Right, scopeOfTheContainingExpression));
                    }
                case BoundKind.UserDefinedConditionalLogicalOperator:
                    {
                        BoundUserDefinedConditionalLogicalOperator boundUserDefinedConditionalLogicalOperator = (BoundUserDefinedConditionalLogicalOperator)expr;
                        return Math.Max(GetValEscape(boundUserDefinedConditionalLogicalOperator.Left, scopeOfTheContainingExpression), GetValEscape(boundUserDefinedConditionalLogicalOperator.Right, scopeOfTheContainingExpression));
                    }
                case BoundKind.QueryClause:
                    return GetValEscape(((BoundQueryClause)expr).Value, scopeOfTheContainingExpression);
                case BoundKind.RangeVariable:
                    return GetValEscape(((BoundRangeVariable)expr).Value, scopeOfTheContainingExpression);
                case BoundKind.ObjectInitializerExpression:
                    return GetValEscapeOfObjectInitializer((BoundObjectInitializerExpression)expr, scopeOfTheContainingExpression);
                case BoundKind.CollectionInitializerExpression:
                    return GetValEscape(((BoundCollectionInitializerExpression)expr).Initializers, scopeOfTheContainingExpression);
                case BoundKind.CollectionElementInitializer:
                    return GetValEscape(((BoundCollectionElementInitializer)expr).Arguments, scopeOfTheContainingExpression);
                case BoundKind.ObjectInitializerMember:
                    return scopeOfTheContainingExpression;
                case BoundKind.ObjectOrCollectionValuePlaceholder:
                case BoundKind.ImplicitReceiver:
                    return scopeOfTheContainingExpression;
                case BoundKind.DisposableValuePlaceholder:
                    return scopeOfTheContainingExpression;
                case BoundKind.AwaitableValuePlaceholder:
                    return ((BoundAwaitableValuePlaceholder)expr).ValEscape;
                case BoundKind.PointerIndirectionOperator:
                case BoundKind.PointerElementAccess:
                    return 0u;
                case BoundKind.ArrayAccess:
                case BoundKind.AwaitExpression:
                case BoundKind.AsOperator:
                case BoundKind.ConditionalAccess:
                    return scopeOfTheContainingExpression;
                case BoundKind.UnconvertedSwitchExpression:
                case BoundKind.ConvertedSwitchExpression:
                    return GetValEscape(((BoundSwitchExpression)expr).SwitchArms.SelectAsArray((BoundSwitchExpressionArm a) => a.Value), scopeOfTheContainingExpression);
                default:
                    return scopeOfTheContainingExpression;
            }
        }

        private static uint GetTupleValEscape(ImmutableArray<BoundExpression> elements, uint scopeOfTheContainingExpression)
        {
            uint num = scopeOfTheContainingExpression;
            ImmutableArray<BoundExpression>.Enumerator enumerator = elements.GetEnumerator();
            while (enumerator.MoveNext())
            {
                BoundExpression current = enumerator.Current;
                num = Math.Max(num, GetValEscape(current, scopeOfTheContainingExpression));
            }
            return num;
        }

        private static uint GetValEscapeOfObjectInitializer(BoundObjectInitializerExpression initExpr, uint scopeOfTheContainingExpression)
        {
            uint num = 0u;
            ImmutableArray<BoundExpression>.Enumerator enumerator = initExpr.Initializers.GetEnumerator();
            while (enumerator.MoveNext())
            {
                BoundExpression current = enumerator.Current;
                if (current.Kind == BoundKind.AssignmentOperator)
                {
                    BoundAssignmentOperator boundAssignmentOperator = (BoundAssignmentOperator)current;
                    num = Math.Max(num, GetValEscape(boundAssignmentOperator.Right, scopeOfTheContainingExpression));
                    BoundObjectInitializerMember boundObjectInitializerMember = (BoundObjectInitializerMember)boundAssignmentOperator.Left;
                    num = Math.Max(num, GetValEscape(boundObjectInitializerMember.Arguments, scopeOfTheContainingExpression));
                }
                else
                {
                    num = Math.Max(num, GetValEscape(current, scopeOfTheContainingExpression));
                }
            }
            return num;
        }

        private static uint GetValEscape(ImmutableArray<BoundExpression> expressions, uint scopeOfTheContainingExpression)
        {
            uint num = 0u;
            ImmutableArray<BoundExpression>.Enumerator enumerator = expressions.GetEnumerator();
            while (enumerator.MoveNext())
            {
                BoundExpression current = enumerator.Current;
                num = Math.Max(num, GetValEscape(current, scopeOfTheContainingExpression));
            }
            return num;
        }

        internal static bool CheckValEscape(SyntaxNode node, BoundExpression expr, uint escapeFrom, uint escapeTo, bool checkingReceiver, BindingDiagnosticBag diagnostics)
        {
            if (escapeTo >= escapeFrom)
            {
                return true;
            }
            if (expr.HasAnyErrors)
            {
                return true;
            }
            if (expr.ConstantValue != null)
            {
                return true;
            }
            TypeSymbol? type = expr.Type;
            if ((object)type == null || !type!.IsRefLikeType)
            {
                return true;
            }
            switch (expr.Kind)
            {
                case BoundKind.DefaultLiteral:
                case BoundKind.DefaultExpression:
                case BoundKind.ThisReference:
                case BoundKind.Parameter:
                    return true;
                case BoundKind.TupleLiteral:
                case BoundKind.ConvertedTupleLiteral:
                    return CheckTupleValEscape(((BoundTupleExpression)expr).Arguments, escapeFrom, escapeTo, diagnostics);
                case BoundKind.MakeRefOperator:
                case BoundKind.RefValueOperator:
                    return true;
                case BoundKind.DiscardExpression:
                    return true;
                case BoundKind.DeconstructValuePlaceholder:
                    if (((BoundDeconstructValuePlaceholder)expr).ValEscape > escapeTo)
                    {
                        Error(diagnostics, ErrorCode.ERR_EscapeLocal, node, expr.Syntax);
                        return false;
                    }
                    return true;
                case BoundKind.AwaitableValuePlaceholder:
                    if (((BoundAwaitableValuePlaceholder)expr).ValEscape > escapeTo)
                    {
                        Error(diagnostics, ErrorCode.ERR_EscapeLocal, node, expr.Syntax);
                        return false;
                    }
                    return true;
                case BoundKind.Local:
                    {
                        LocalSymbol localSymbol = ((BoundLocal)expr).LocalSymbol;
                        if (localSymbol.ValEscapeScope > escapeTo)
                        {
                            Error(diagnostics, ErrorCode.ERR_EscapeLocal, node, localSymbol);
                            return false;
                        }
                        return true;
                    }
                case BoundKind.StackAllocArrayCreation:
                case BoundKind.ConvertedStackAllocExpression:
                    if (escapeTo < 1)
                    {
                        Error(diagnostics, ErrorCode.ERR_EscapeStackAlloc, node, expr.Type);
                        return false;
                    }
                    return true;
                case BoundKind.UnconvertedConditionalOperator:
                    {
                        BoundUnconvertedConditionalOperator boundUnconvertedConditionalOperator = (BoundUnconvertedConditionalOperator)expr;
                        if (CheckValEscape(boundUnconvertedConditionalOperator.Consequence.Syntax, boundUnconvertedConditionalOperator.Consequence, escapeFrom, escapeTo, checkingReceiver: false, diagnostics))
                        {
                            return CheckValEscape(boundUnconvertedConditionalOperator.Alternative.Syntax, boundUnconvertedConditionalOperator.Alternative, escapeFrom, escapeTo, checkingReceiver: false, diagnostics);
                        }
                        return false;
                    }
                case BoundKind.ConditionalOperator:
                    {
                        BoundConditionalOperator boundConditionalOperator = (BoundConditionalOperator)expr;
                        bool flag = CheckValEscape(boundConditionalOperator.Consequence.Syntax, boundConditionalOperator.Consequence, escapeFrom, escapeTo, checkingReceiver: false, diagnostics);
                        if (!flag || boundConditionalOperator.IsRef)
                        {
                            return flag;
                        }
                        return CheckValEscape(boundConditionalOperator.Alternative.Syntax, boundConditionalOperator.Alternative, escapeFrom, escapeTo, checkingReceiver: false, diagnostics);
                    }
                case BoundKind.NullCoalescingOperator:
                    {
                        BoundNullCoalescingOperator boundNullCoalescingOperator = (BoundNullCoalescingOperator)expr;
                        if (CheckValEscape(boundNullCoalescingOperator.LeftOperand.Syntax, boundNullCoalescingOperator.LeftOperand, escapeFrom, escapeTo, checkingReceiver, diagnostics))
                        {
                            return CheckValEscape(boundNullCoalescingOperator.RightOperand.Syntax, boundNullCoalescingOperator.RightOperand, escapeFrom, escapeTo, checkingReceiver, diagnostics);
                        }
                        return false;
                    }
                case BoundKind.FieldAccess:
                    {
                        BoundFieldAccess boundFieldAccess = (BoundFieldAccess)expr;
                        FieldSymbol fieldSymbol = boundFieldAccess.FieldSymbol;
                        if (fieldSymbol.IsStatic || !fieldSymbol.ContainingType.IsRefLikeType)
                        {
                            return true;
                        }
                        return CheckValEscape(node, boundFieldAccess.ReceiverOpt, escapeFrom, escapeTo, checkingReceiver: true, diagnostics);
                    }
                case BoundKind.Call:
                    {
                        BoundCall boundCall = (BoundCall)expr;
                        MethodSymbol method = boundCall.Method;
                        return CheckInvocationEscape(boundCall.Syntax, method, boundCall.ReceiverOpt, method.Parameters, boundCall.Arguments, boundCall.ArgumentRefKindsOpt, boundCall.ArgsToParamsOpt, checkingReceiver, escapeFrom, escapeTo, diagnostics, isRefEscape: false);
                    }
                case BoundKind.FunctionPointerInvocation:
                    {
                        BoundFunctionPointerInvocation boundFunctionPointerInvocation = (BoundFunctionPointerInvocation)expr;
                        FunctionPointerMethodSymbol signature = boundFunctionPointerInvocation.FunctionPointer.Signature;
                        return CheckInvocationEscape(boundFunctionPointerInvocation.Syntax, signature, null, signature.Parameters, boundFunctionPointerInvocation.Arguments, boundFunctionPointerInvocation.ArgumentRefKindsOpt, default(ImmutableArray<int>), checkingReceiver, escapeFrom, escapeTo, diagnostics, isRefEscape: false);
                    }
                case BoundKind.IndexerAccess:
                    {
                        BoundIndexerAccess boundIndexerAccess = (BoundIndexerAccess)expr;
                        PropertySymbol indexer = boundIndexerAccess.Indexer;
                        return CheckInvocationEscape(boundIndexerAccess.Syntax, indexer, boundIndexerAccess.ReceiverOpt, indexer.Parameters, boundIndexerAccess.Arguments, boundIndexerAccess.ArgumentRefKindsOpt, boundIndexerAccess.ArgsToParamsOpt, checkingReceiver, escapeFrom, escapeTo, diagnostics, isRefEscape: false);
                    }
                case BoundKind.IndexOrRangePatternIndexerAccess:
                    {
                        BoundIndexOrRangePatternIndexerAccess boundIndexOrRangePatternIndexerAccess = (BoundIndexOrRangePatternIndexerAccess)expr;
                        Symbol patternSymbol = boundIndexOrRangePatternIndexerAccess.PatternSymbol;
                        ImmutableArray<ParameterSymbol> parameters;
                        if (!(patternSymbol is PropertySymbol propertySymbol))
                        {
                            if (!(patternSymbol is MethodSymbol methodSymbol))
                            {
                                throw ExceptionUtilities.Unreachable;
                            }
                            parameters = methodSymbol.Parameters;
                        }
                        else
                        {
                            parameters = propertySymbol.Parameters;
                        }
                        ImmutableArray<ParameterSymbol> parameters2 = parameters;
                        return CheckInvocationEscape(boundIndexOrRangePatternIndexerAccess.Syntax, patternSymbol, boundIndexOrRangePatternIndexerAccess.Receiver, parameters2, ImmutableArray.Create(boundIndexOrRangePatternIndexerAccess.Argument), default(ImmutableArray<RefKind>), default(ImmutableArray<int>), checkingReceiver, escapeFrom, escapeTo, diagnostics, isRefEscape: false);
                    }
                case BoundKind.PropertyAccess:
                    {
                        BoundPropertyAccess boundPropertyAccess = (BoundPropertyAccess)expr;
                        return CheckInvocationEscape(boundPropertyAccess.Syntax, boundPropertyAccess.PropertySymbol, boundPropertyAccess.ReceiverOpt, default(ImmutableArray<ParameterSymbol>), default(ImmutableArray<BoundExpression>), default(ImmutableArray<RefKind>), default(ImmutableArray<int>), checkingReceiver, escapeFrom, escapeTo, diagnostics, isRefEscape: false);
                    }
                case BoundKind.ObjectCreationExpression:
                    {
                        BoundObjectCreationExpression boundObjectCreationExpression = (BoundObjectCreationExpression)expr;
                        MethodSymbol constructor = boundObjectCreationExpression.Constructor;
                        bool flag2 = CheckInvocationEscape(boundObjectCreationExpression.Syntax, constructor, null, constructor.Parameters, boundObjectCreationExpression.Arguments, boundObjectCreationExpression.ArgumentRefKindsOpt, boundObjectCreationExpression.ArgsToParamsOpt, checkingReceiver, escapeFrom, escapeTo, diagnostics, isRefEscape: false);
                        BoundObjectInitializerExpressionBase initializerExpressionOpt = boundObjectCreationExpression.InitializerExpressionOpt;
                        if (initializerExpressionOpt != null)
                        {
                            flag2 = flag2 && CheckValEscape(initializerExpressionOpt.Syntax, initializerExpressionOpt, escapeFrom, escapeTo, checkingReceiver: false, diagnostics);
                        }
                        return flag2;
                    }
                case BoundKind.WithExpression:
                    {
                        BoundWithExpression boundWithExpression = (BoundWithExpression)expr;
                        bool num = CheckValEscape(node, boundWithExpression.Receiver, escapeFrom, escapeTo, checkingReceiver: false, diagnostics);
                        BoundObjectInitializerExpressionBase initializerExpression = boundWithExpression.InitializerExpression;
                        if (num)
                        {
                            return CheckValEscape(initializerExpression.Syntax, initializerExpression, escapeFrom, escapeTo, checkingReceiver: false, diagnostics);
                        }
                        return false;
                    }
                case BoundKind.UnaryOperator:
                    {
                        BoundUnaryOperator boundUnaryOperator = (BoundUnaryOperator)expr;
                        return CheckValEscape(node, boundUnaryOperator.Operand, escapeFrom, escapeTo, checkingReceiver: false, diagnostics);
                    }
                case BoundKind.Conversion:
                    {
                        BoundConversion boundConversion = (BoundConversion)expr;
                        return CheckValEscape(node, boundConversion.Operand, escapeFrom, escapeTo, checkingReceiver: false, diagnostics);
                    }
                case BoundKind.AssignmentOperator:
                    {
                        BoundAssignmentOperator boundAssignmentOperator = (BoundAssignmentOperator)expr;
                        return CheckValEscape(node, boundAssignmentOperator.Left, escapeFrom, escapeTo, checkingReceiver: false, diagnostics);
                    }
                case BoundKind.IncrementOperator:
                    {
                        BoundIncrementOperator boundIncrementOperator = (BoundIncrementOperator)expr;
                        return CheckValEscape(node, boundIncrementOperator.Operand, escapeFrom, escapeTo, checkingReceiver: false, diagnostics);
                    }
                case BoundKind.CompoundAssignmentOperator:
                    {
                        BoundCompoundAssignmentOperator boundCompoundAssignmentOperator = (BoundCompoundAssignmentOperator)expr;
                        if (CheckValEscape(boundCompoundAssignmentOperator.Left.Syntax, boundCompoundAssignmentOperator.Left, escapeFrom, escapeTo, checkingReceiver: false, diagnostics))
                        {
                            return CheckValEscape(boundCompoundAssignmentOperator.Right.Syntax, boundCompoundAssignmentOperator.Right, escapeFrom, escapeTo, checkingReceiver: false, diagnostics);
                        }
                        return false;
                    }
                case BoundKind.BinaryOperator:
                    {
                        BoundBinaryOperator boundBinaryOperator = (BoundBinaryOperator)expr;
                        if (CheckValEscape(boundBinaryOperator.Left.Syntax, boundBinaryOperator.Left, escapeFrom, escapeTo, checkingReceiver: false, diagnostics))
                        {
                            return CheckValEscape(boundBinaryOperator.Right.Syntax, boundBinaryOperator.Right, escapeFrom, escapeTo, checkingReceiver: false, diagnostics);
                        }
                        return false;
                    }
                case BoundKind.UserDefinedConditionalLogicalOperator:
                    {
                        BoundUserDefinedConditionalLogicalOperator boundUserDefinedConditionalLogicalOperator = (BoundUserDefinedConditionalLogicalOperator)expr;
                        if (CheckValEscape(boundUserDefinedConditionalLogicalOperator.Left.Syntax, boundUserDefinedConditionalLogicalOperator.Left, escapeFrom, escapeTo, checkingReceiver: false, diagnostics))
                        {
                            return CheckValEscape(boundUserDefinedConditionalLogicalOperator.Right.Syntax, boundUserDefinedConditionalLogicalOperator.Right, escapeFrom, escapeTo, checkingReceiver: false, diagnostics);
                        }
                        return false;
                    }
                case BoundKind.QueryClause:
                    {
                        BoundExpression value3 = ((BoundQueryClause)expr).Value;
                        return CheckValEscape(value3.Syntax, value3, escapeFrom, escapeTo, checkingReceiver: false, diagnostics);
                    }
                case BoundKind.RangeVariable:
                    {
                        BoundExpression value2 = ((BoundRangeVariable)expr).Value;
                        return CheckValEscape(value2.Syntax, value2, escapeFrom, escapeTo, checkingReceiver: false, diagnostics);
                    }
                case BoundKind.ObjectInitializerExpression:
                    return CheckValEscapeOfObjectInitializer((BoundObjectInitializerExpression)expr, escapeFrom, escapeTo, diagnostics);
                case BoundKind.CollectionInitializerExpression:
                    return CheckValEscape(((BoundCollectionInitializerExpression)expr).Initializers, escapeFrom, escapeTo, diagnostics);
                case BoundKind.CollectionElementInitializer:
                    return CheckValEscape(((BoundCollectionElementInitializer)expr).Arguments, escapeFrom, escapeTo, diagnostics);
                case BoundKind.PointerElementAccess:
                    {
                        BoundExpression expression = ((BoundPointerElementAccess)expr).Expression;
                        return CheckValEscape(expression.Syntax, expression, escapeFrom, escapeTo, checkingReceiver, diagnostics);
                    }
                case BoundKind.PointerIndirectionOperator:
                    {
                        BoundExpression operand = ((BoundPointerIndirectionOperator)expr).Operand;
                        return CheckValEscape(operand.Syntax, operand, escapeFrom, escapeTo, checkingReceiver, diagnostics);
                    }
                case BoundKind.ArrayAccess:
                case BoundKind.AwaitExpression:
                case BoundKind.AsOperator:
                case BoundKind.ConditionalAccess:
                    return false;
                case BoundKind.UnconvertedSwitchExpression:
                case BoundKind.ConvertedSwitchExpression:
                    {
                        ImmutableArray<BoundSwitchExpressionArm>.Enumerator enumerator = ((BoundSwitchExpression)expr).SwitchArms.GetEnumerator();
                        while (enumerator.MoveNext())
                        {
                            BoundExpression value = enumerator.Current.Value;
                            if (!CheckValEscape(value.Syntax, value, escapeFrom, escapeTo, checkingReceiver: false, diagnostics))
                            {
                                return false;
                            }
                        }
                        return true;
                    }
                default:
                    diagnostics.Add(ErrorCode.ERR_InternalError, node.Location);
                    return false;
            }
        }

        private static bool CheckTupleValEscape(ImmutableArray<BoundExpression> elements, uint escapeFrom, uint escapeTo, BindingDiagnosticBag diagnostics)
        {
            ImmutableArray<BoundExpression>.Enumerator enumerator = elements.GetEnumerator();
            while (enumerator.MoveNext())
            {
                BoundExpression current = enumerator.Current;
                if (!CheckValEscape(current.Syntax, current, escapeFrom, escapeTo, checkingReceiver: false, diagnostics))
                {
                    return false;
                }
            }
            return true;
        }

        private static bool CheckValEscapeOfObjectInitializer(BoundObjectInitializerExpression initExpr, uint escapeFrom, uint escapeTo, BindingDiagnosticBag diagnostics)
        {
            ImmutableArray<BoundExpression>.Enumerator enumerator = initExpr.Initializers.GetEnumerator();
            while (enumerator.MoveNext())
            {
                BoundExpression current = enumerator.Current;
                if (current.Kind == BoundKind.AssignmentOperator)
                {
                    BoundAssignmentOperator boundAssignmentOperator = (BoundAssignmentOperator)current;
                    if (!CheckValEscape(current.Syntax, boundAssignmentOperator.Right, escapeFrom, escapeTo, checkingReceiver: false, diagnostics))
                    {
                        return false;
                    }
                    if (!CheckValEscape(((BoundObjectInitializerMember)boundAssignmentOperator.Left).Arguments, escapeFrom, escapeTo, diagnostics))
                    {
                        return false;
                    }
                }
                else if (!CheckValEscape(current.Syntax, current, escapeFrom, escapeTo, checkingReceiver: false, diagnostics))
                {
                    return false;
                }
            }
            return true;
        }

        private static bool CheckValEscape(ImmutableArray<BoundExpression> expressions, uint escapeFrom, uint escapeTo, BindingDiagnosticBag diagnostics)
        {
            ImmutableArray<BoundExpression>.Enumerator enumerator = expressions.GetEnumerator();
            while (enumerator.MoveNext())
            {
                BoundExpression current = enumerator.Current;
                if (!CheckValEscape(current.Syntax, current, escapeFrom, escapeTo, checkingReceiver: false, diagnostics))
                {
                    return false;
                }
            }
            return true;
        }

        internal static bool IsAnyReadOnly(AddressKind addressKind)
        {
            return addressKind >= AddressKind.ReadOnly;
        }

        internal static bool HasHome(BoundExpression expression, AddressKind addressKind, MethodSymbol method, bool peVerifyCompatEnabled, HashSet<LocalSymbol> stackLocalsOpt)
        {
            switch (expression.Kind)
            {
                case BoundKind.ArrayAccess:
                    if (addressKind == AddressKind.ReadOnly && !expression.Type!.IsValueType && peVerifyCompatEnabled)
                    {
                        return false;
                    }
                    return true;
                case BoundKind.PointerIndirectionOperator:
                case BoundKind.RefValueOperator:
                    return true;
                case BoundKind.ThisReference:
                    if (expression.Type!.IsReferenceType)
                    {
                        return true;
                    }
                    if (!IsAnyReadOnly(addressKind) && method.IsEffectivelyReadOnly)
                    {
                        return false;
                    }
                    return true;
                case BoundKind.ThrowExpression:
                    return true;
                case BoundKind.Parameter:
                    if (!IsAnyReadOnly(addressKind))
                    {
                        return ((BoundParameter)expression).ParameterSymbol.RefKind != RefKind.In;
                    }
                    return true;
                case BoundKind.Local:
                    {
                        LocalSymbol localSymbol = ((BoundLocal)expression).LocalSymbol;
                        if (!CodeGenerator.IsStackLocal(localSymbol, stackLocalsOpt) || localSymbol.RefKind != 0)
                        {
                            if (!IsAnyReadOnly(addressKind))
                            {
                                return localSymbol.RefKind != RefKind.In;
                            }
                            return true;
                        }
                        return false;
                    }
                case BoundKind.Call:
                    {
                        RefKind refKind3 = ((BoundCall)expression).Method.RefKind;
                        if (refKind3 != RefKind.Ref)
                        {
                            if (IsAnyReadOnly(addressKind))
                            {
                                return refKind3 == RefKind.In;
                            }
                            return false;
                        }
                        return true;
                    }
                case BoundKind.Dup:
                    {
                        RefKind refKind = ((BoundDup)expression).RefKind;
                        if (refKind != RefKind.Ref)
                        {
                            if (IsAnyReadOnly(addressKind))
                            {
                                return refKind == RefKind.In;
                            }
                            return false;
                        }
                        return true;
                    }
                case BoundKind.FieldAccess:
                    return HasHome((BoundFieldAccess)expression, addressKind, method, peVerifyCompatEnabled, stackLocalsOpt);
                case BoundKind.Sequence:
                    return HasHome(((BoundSequence)expression).Value, addressKind, method, peVerifyCompatEnabled, stackLocalsOpt);
                case BoundKind.AssignmentOperator:
                    {
                        BoundAssignmentOperator boundAssignmentOperator = (BoundAssignmentOperator)expression;
                        if (!boundAssignmentOperator.IsRef)
                        {
                            return false;
                        }
                        RefKind refKind2 = boundAssignmentOperator.Left.GetRefKind();
                        if (refKind2 != RefKind.Ref)
                        {
                            if (IsAnyReadOnly(addressKind))
                            {
                                return refKind2 == RefKind.In;
                            }
                            return false;
                        }
                        return true;
                    }
                case BoundKind.ConditionalReceiver:
                case BoundKind.ComplexConditionalReceiver:
                    return true;
                case BoundKind.ConditionalOperator:
                    {
                        BoundConditionalOperator boundConditionalOperator = (BoundConditionalOperator)expression;
                        if (!boundConditionalOperator.IsRef)
                        {
                            return false;
                        }
                        if (HasHome(boundConditionalOperator.Consequence, addressKind, method, peVerifyCompatEnabled, stackLocalsOpt))
                        {
                            return HasHome(boundConditionalOperator.Alternative, addressKind, method, peVerifyCompatEnabled, stackLocalsOpt);
                        }
                        return false;
                    }
                default:
                    return false;
            }
        }

        private static bool HasHome(BoundFieldAccess fieldAccess, AddressKind addressKind, MethodSymbol method, bool peVerifyCompatEnabled, HashSet<LocalSymbol> stackLocalsOpt)
        {
            FieldSymbol fieldSymbol = fieldAccess.FieldSymbol;
            if (fieldSymbol.IsConst)
            {
                return false;
            }
            switch (addressKind)
            {
                case AddressKind.ReadOnlyStrict:
                    return true;
                case AddressKind.ReadOnly:
                    if (!peVerifyCompatEnabled)
                    {
                        return true;
                    }
                    break;
            }
            if (fieldAccess.IsByValue)
            {
                return false;
            }
            if (!fieldSymbol.IsReadOnly)
            {
                if (!peVerifyCompatEnabled)
                {
                    BoundExpression receiverOpt = fieldAccess.ReceiverOpt;
                    if (receiverOpt != null && receiverOpt.Type!.IsValueType)
                    {
                        if (!HasHome(receiverOpt, addressKind, method, peVerifyCompatEnabled, stackLocalsOpt))
                        {
                            return !HasHome(receiverOpt, AddressKind.ReadOnly, method, peVerifyCompatEnabled, stackLocalsOpt);
                        }
                        return true;
                    }
                }
                return true;
            }
            if (!TypeSymbol.Equals(fieldSymbol.ContainingType, method.ContainingType, TypeCompareKind.AllIgnoreOptions))
            {
                return false;
            }
            if (fieldSymbol.IsStatic)
            {
                return method.MethodKind == MethodKind.StaticConstructor;
            }
            if (method.MethodKind == MethodKind.Constructor || method.IsInitOnly)
            {
                return fieldAccess.ReceiverOpt!.Kind == BoundKind.ThisReference;
            }
            return false;
        }

        private BoundExpression BindAnonymousObjectCreation(AnonymousObjectCreationExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers = node.Initializers;
            int count = initializers.Count;
            bool hasError = false;
            BoundExpression[] array = new BoundExpression[count];
            AnonymousTypeField[] array2 = new AnonymousTypeField[count];
            CSharpSyntaxNode[] array3 = new CSharpSyntaxNode[count];
            PooledHashSet<string> instance = PooledHashSet<string>.GetInstance();
            for (int i = 0; i < count; i++)
            {
                AnonymousObjectMemberDeclaratorSyntax anonymousObjectMemberDeclaratorSyntax = initializers[i];
                NameEqualsSyntax nameEquals = anonymousObjectMemberDeclaratorSyntax.NameEquals;
                ExpressionSyntax expression = anonymousObjectMemberDeclaratorSyntax.Expression;
                SyntaxToken syntaxToken = default(SyntaxToken);
                if (nameEquals != null)
                {
                    syntaxToken = nameEquals.Name.Identifier;
                }
                else
                {
                    if (!IsAnonymousTypeMemberExpression(expression))
                    {
                        hasError = true;
                        diagnostics.Add(ErrorCode.ERR_InvalidAnonymousTypeMemberDeclarator, expression.GetLocation());
                    }
                    syntaxToken = expression.ExtractAnonymousTypeMemberName();
                }
                hasError |= expression.HasErrors;
                array[i] = BindRValueWithoutTargetType(expression, diagnostics);
                string text = null;
                if (syntaxToken.Kind() == SyntaxKind.IdentifierToken)
                {
                    text = syntaxToken.ValueText;
                    if (!instance.Add(text))
                    {
                        Error(diagnostics, ErrorCode.ERR_AnonymousTypeDuplicatePropertyName, anonymousObjectMemberDeclaratorSyntax);
                        hasError = true;
                        text = null;
                    }
                }
                else
                {
                    hasError = true;
                }
                TypeSymbol anonymousTypeFieldType = GetAnonymousTypeFieldType(array[i], anonymousObjectMemberDeclaratorSyntax, diagnostics, ref hasError);
                array3[i] = ((syntaxToken.Kind() == SyntaxKind.IdentifierToken) ? ((CSharpSyntaxNode)syntaxToken.Parent) : anonymousObjectMemberDeclaratorSyntax);
                array2[i] = new AnonymousTypeField((text == null) ? ("$" + i) : text, array3[i].Location, TypeWithAnnotations.Create(anonymousTypeFieldType));
            }
            instance.Free();
            AnonymousTypeManager anonymousTypeManager = Compilation.AnonymousTypeManager;
            AnonymousTypeDescriptor typeDescr = new AnonymousTypeDescriptor(array2.AsImmutableOrNull(), node.NewKeyword.GetLocation());
            NamedTypeSymbol namedTypeSymbol = anonymousTypeManager.ConstructAnonymousTypeSymbol(typeDescr);
            ArrayBuilder<BoundAnonymousPropertyDeclaration> instance2 = ArrayBuilder<BoundAnonymousPropertyDeclaration>.GetInstance();
            for (int j = 0; j < count; j++)
            {
                if (initializers[j].NameEquals == null)
                {
                    continue;
                }
                AnonymousTypeField anonymousTypeField = array2[j];
                if (anonymousTypeField.Name == null)
                {
                    continue;
                }
                ImmutableArray<Symbol>.Enumerator enumerator = namedTypeSymbol.GetMembers(anonymousTypeField.Name).GetEnumerator();
                while (enumerator.MoveNext())
                {
                    Symbol current = enumerator.Current;
                    if (current.Kind == SymbolKind.Property)
                    {
                        instance2.Add(new BoundAnonymousPropertyDeclaration(array3[j], (PropertySymbol)current, anonymousTypeField.Type));
                        break;
                    }
                }
            }
            if (!IsAnonymousTypesAllowed())
            {
                Error(diagnostics, ErrorCode.ERR_AnonymousTypeNotAvailable, node.NewKeyword);
                hasError = true;
            }
            return new BoundAnonymousObjectCreationExpression(node, namedTypeSymbol.InstanceConstructors[0], array.AsImmutableOrNull(), instance2.ToImmutableAndFree(), namedTypeSymbol, hasError);
        }

        private static bool IsAnonymousTypeMemberExpression(ExpressionSyntax expr)
        {
            while (true)
            {
                switch (expr.Kind())
                {
                    case SyntaxKind.QualifiedName:
                        expr = ((QualifiedNameSyntax)expr).Right;
                        break;
                    case SyntaxKind.ConditionalAccessExpression:
                        expr = ((ConditionalAccessExpressionSyntax)expr).WhenNotNull;
                        if (expr.Kind() == SyntaxKind.MemberBindingExpression)
                        {
                            return true;
                        }
                        break;
                    case SyntaxKind.IdentifierName:
                    case SyntaxKind.SimpleMemberAccessExpression:
                        return true;
                    default:
                        return false;
                }
            }
        }

        private bool IsAnonymousTypesAllowed()
        {
            Symbol containingMemberOrLambda = ContainingMemberOrLambda;
            if ((object)containingMemberOrLambda == null)
            {
                return false;
            }
            return containingMemberOrLambda.Kind switch
            {
                SymbolKind.Method => true,
                SymbolKind.Field => !((FieldSymbol)containingMemberOrLambda).IsConst,
                SymbolKind.NamedType => ((NamedTypeSymbol)containingMemberOrLambda).IsScriptClass,
                _ => false,
            };
        }

        private TypeSymbol GetAnonymousTypeFieldType(BoundExpression expression, CSharpSyntaxNode errorSyntax, BindingDiagnosticBag diagnostics, ref bool hasError)
        {
            object obj = null;
            TypeSymbol typeSymbol = expression.Type;
            if (!expression.HasAnyErrors)
            {
                if (expression.HasExpressionType())
                {
                    if (typeSymbol.IsVoidType())
                    {
                        obj = typeSymbol;
                        typeSymbol = CreateErrorType(SyntaxFacts.GetText(SyntaxKind.VoidKeyword));
                    }
                    else if (typeSymbol.IsUnsafe())
                    {
                        obj = typeSymbol;
                    }
                    else if (typeSymbol.IsRestrictedType())
                    {
                        obj = typeSymbol;
                    }
                }
                else
                {
                    obj = expression.Display;
                }
            }
            if ((object)typeSymbol == null)
            {
                typeSymbol = CreateErrorType("error");
            }
            if (obj != null)
            {
                hasError = true;
                Error(diagnostics, ErrorCode.ERR_AnonymousTypePropertyAssignedBadValue, errorSyntax, obj);
            }
            return typeSymbol;
        }

        internal static void BindAttributeTypes(ImmutableArray<Binder> binders, ImmutableArray<AttributeSyntax> attributesToBind, Symbol ownerSymbol, NamedTypeSymbol[] boundAttributeTypes, BindingDiagnosticBag diagnostics)
        {
            for (int i = 0; i < attributesToBind.Length; i++)
            {
                if ((object)boundAttributeTypes[i] == null)
                {
                    Binder binder = binders[i];
                    boundAttributeTypes[i] = (NamedTypeSymbol)binder.BindType(attributesToBind[i].Name, diagnostics).Type;
                }
            }
        }

        internal static void GetAttributes(ImmutableArray<Binder> binders, ImmutableArray<AttributeSyntax> attributesToBind, ImmutableArray<NamedTypeSymbol> boundAttributeTypes, CSharpAttributeData?[] attributesBuilder, BindingDiagnosticBag diagnostics)
        {
            for (int i = 0; i < attributesToBind.Length; i++)
            {
                AttributeSyntax attributeSyntax = attributesToBind[i];
                NamedTypeSymbol boundAttributeType = boundAttributeTypes[i];
                Binder binder = binders[i];
                SourceAttributeData sourceAttributeData = (SourceAttributeData)attributesBuilder[i];
                if (sourceAttributeData == null)
                {
                    attributesBuilder[i] = binder.GetAttribute(attributeSyntax, boundAttributeType, diagnostics);
                    continue;
                }
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = binder.GetNewCompoundUseSiteInfo(diagnostics);
                bool isConditionallyOmitted = binder.IsAttributeConditionallyOmitted(sourceAttributeData.AttributeClass, attributeSyntax.SyntaxTree, ref useSiteInfo);
                diagnostics.Add(attributeSyntax, useSiteInfo);
                attributesBuilder[i] = sourceAttributeData.WithOmittedCondition(isConditionallyOmitted);
            }
        }

        internal CSharpAttributeData GetAttribute(AttributeSyntax node, NamedTypeSymbol boundAttributeType, BindingDiagnosticBag diagnostics)
        {
            BoundAttribute boundAttribute = new ExecutableCodeBinder(node, ContainingMemberOrLambda, this).BindAttribute(node, boundAttributeType, diagnostics);
            return GetAttribute(boundAttribute, diagnostics);
        }

        internal BoundAttribute BindAttribute(AttributeSyntax node, NamedTypeSymbol attributeType, BindingDiagnosticBag diagnostics)
        {
            return GetRequiredBinder(node).BindAttributeCore(node, attributeType, diagnostics);
        }

        private Binder SkipSemanticModelBinder()
        {
            Binder binder = this;
            while (binder.IsSemanticModelBinder)
            {
                binder = binder.Next;
            }
            return binder;
        }

        private BoundAttribute BindAttributeCore(AttributeSyntax node, NamedTypeSymbol attributeType, BindingDiagnosticBag diagnostics)
        {
            NamedTypeSymbol namedTypeSymbol = attributeType;
            LookupResultKind resultKind = LookupResultKind.Viable;
            if (namedTypeSymbol.IsErrorType())
            {
                ErrorTypeSymbol errorTypeSymbol = (ErrorTypeSymbol)namedTypeSymbol;
                resultKind = errorTypeSymbol.ResultKind;
                if (errorTypeSymbol.CandidateSymbols.Length == 1 && errorTypeSymbol.CandidateSymbols[0] is NamedTypeSymbol)
                {
                    namedTypeSymbol = (NamedTypeSymbol)errorTypeSymbol.CandidateSymbols[0];
                }
            }
            AttributeArgumentListSyntax argumentList = node.ArgumentList;
            Binder binder = WithAdditionalFlags(BinderFlags.AttributeArgument);
            AnalyzedAttributeArguments analyzedAttributeArguments = binder.BindAttributeArguments(argumentList, namedTypeSymbol, diagnostics);
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            ImmutableArray<int> argsToParamsOpt = default(ImmutableArray<int>);
            bool expanded = false;
            MethodSymbol methodSymbol = null;
            ImmutableArray<BoundExpression> constructorArguments;
            if (!namedTypeSymbol.IsErrorType())
            {
                methodSymbol = BindAttributeConstructor(node, namedTypeSymbol, analyzedAttributeArguments.ConstructorArguments, diagnostics, ref resultKind, attributeType.IsErrorType(), ref argsToParamsOpt, ref expanded, ref useSiteInfo, out constructorArguments);
            }
            else
            {
                constructorArguments = analyzedAttributeArguments.ConstructorArguments.Arguments.SelectAsArray((BoundExpression arg, Binder attributeArgumentBinder) => attributeArgumentBinder.BindToTypeForErrorRecovery(arg), binder);
            }
            diagnostics.Add(node, useSiteInfo);
            if ((object)methodSymbol != null)
            {
                ReportDiagnosticsIfObsolete(diagnostics, methodSymbol, node, hasBaseReceiver: false);
                if (methodSymbol.Parameters.Any((ParameterSymbol p) => p.RefKind == RefKind.In))
                {
                    Error(diagnostics, ErrorCode.ERR_AttributeCtorInParameter, node, methodSymbol.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat));
                }
            }
            ImmutableArray<string> names = analyzedAttributeArguments.ConstructorArguments.GetNames();
            ImmutableArray<BoundAssignmentOperator> namedArguments = analyzedAttributeArguments.NamedArguments?.ToImmutableAndFree() ?? ImmutableArray<BoundAssignmentOperator>.Empty;
            analyzedAttributeArguments.ConstructorArguments.Free();
            return new BoundAttribute(node, methodSymbol, constructorArguments, names, argsToParamsOpt, expanded, namedArguments, resultKind, attributeType, resultKind != LookupResultKind.Viable);
        }

        private CSharpAttributeData GetAttribute(BoundAttribute boundAttribute, BindingDiagnosticBag diagnostics)
        {
            NamedTypeSymbol namedTypeSymbol = (NamedTypeSymbol)boundAttribute.Type;
            MethodSymbol constructor = boundAttribute.Constructor;
            if (diagnostics.DiagnosticBag != null)
            {
                NullableWalker.AnalyzeIfNeeded(this, boundAttribute, boundAttribute.Syntax, diagnostics.DiagnosticBag);
            }
            bool hasErrors = boundAttribute.HasAnyErrors;
            if (namedTypeSymbol.IsErrorType() || namedTypeSymbol.IsAbstract || (object)constructor == null)
            {
                return new SourceAttributeData(boundAttribute.Syntax.GetReference(), namedTypeSymbol, constructor, hasErrors);
            }
            ValidateTypeForAttributeParameters(constructor.Parameters, ((AttributeSyntax)boundAttribute.Syntax).Name, diagnostics, ref hasErrors);
            AttributeExpressionVisitor attributeExpressionVisitor = new AttributeExpressionVisitor(this);
            ImmutableArray<BoundExpression> constructorArguments = boundAttribute.ConstructorArguments;
            ImmutableArray<TypedConstant> immutableArray = attributeExpressionVisitor.VisitArguments(constructorArguments, diagnostics, ref hasErrors);
            ImmutableArray<KeyValuePair<string, TypedConstant>> namedArguments = attributeExpressionVisitor.VisitNamedArguments(boundAttribute.NamedArguments, diagnostics, ref hasErrors);
            ImmutableArray<int> constructorArgumentsSourceIndices;
            ImmutableArray<TypedConstant> constructorArguments2;
            if (hasErrors || constructor.ParameterCount == 0)
            {
                constructorArgumentsSourceIndices = default(ImmutableArray<int>);
                constructorArguments2 = immutableArray;
            }
            else
            {
                constructorArguments2 = GetRewrittenAttributeConstructorArguments(out constructorArgumentsSourceIndices, constructor, immutableArray, boundAttribute.ConstructorArgumentNamesOpt, (AttributeSyntax)boundAttribute.Syntax, diagnostics, ref hasErrors);
            }
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            bool isConditionallyOmitted = IsAttributeConditionallyOmitted(namedTypeSymbol, boundAttribute.SyntaxTree, ref useSiteInfo);
            diagnostics.Add(boundAttribute.Syntax, useSiteInfo);
            return new SourceAttributeData(boundAttribute.Syntax.GetReference(), namedTypeSymbol, constructor, constructorArguments2, constructorArgumentsSourceIndices, namedArguments, hasErrors, isConditionallyOmitted);
        }

        private void ValidateTypeForAttributeParameters(ImmutableArray<ParameterSymbol> parameters, CSharpSyntaxNode syntax, BindingDiagnosticBag diagnostics, ref bool hasErrors)
        {
            ImmutableArray<ParameterSymbol>.Enumerator enumerator = parameters.GetEnumerator();
            while (enumerator.MoveNext())
            {
                ParameterSymbol current = enumerator.Current;
                TypeWithAnnotations typeWithAnnotations = current.TypeWithAnnotations;
                if (!typeWithAnnotations.Type.IsValidAttributeParameterType(Compilation))
                {
                    Error(diagnostics, ErrorCode.ERR_BadAttributeParamType, syntax, current.Name, typeWithAnnotations.Type);
                    hasErrors = true;
                }
            }
        }

        protected bool IsAttributeConditionallyOmitted(NamedTypeSymbol attributeType, SyntaxTree? syntaxTree, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            if (IsEarlyAttributeBinder)
            {
                return false;
            }
            if (attributeType.IsConditional)
            {
                ImmutableArray<string> appliedConditionalSymbols = attributeType.GetAppliedConditionalSymbols();
                if (syntaxTree.IsAnyPreprocessorSymbolDefined(appliedConditionalSymbols))
                {
                    return false;
                }
                NamedTypeSymbol namedTypeSymbol = attributeType.BaseTypeWithDefinitionUseSiteDiagnostics(ref useSiteInfo);
                if ((object)namedTypeSymbol != null && namedTypeSymbol.IsConditional)
                {
                    return IsAttributeConditionallyOmitted(namedTypeSymbol, syntaxTree, ref useSiteInfo);
                }
                return true;
            }
            return false;
        }

        private AnalyzedAttributeArguments BindAttributeArguments(AttributeArgumentListSyntax? attributeArgumentList, NamedTypeSymbol attributeType, BindingDiagnosticBag diagnostics)
        {
            AnalyzedArguments instance = AnalyzedArguments.GetInstance();
            ArrayBuilder<BoundAssignmentOperator> arrayBuilder = null;
            if (attributeArgumentList != null)
            {
                HashSet<string> hashSet = null;
                bool hadLangVersionError = false;
                bool flag = false;
                SeparatedSyntaxList<AttributeArgumentSyntax>.Enumerator enumerator = attributeArgumentList!.Arguments.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    AttributeArgumentSyntax current = enumerator.Current;
                    if (current.NameEquals == null)
                    {
                        if (flag)
                        {
                            diagnostics.Add(ErrorCode.ERR_NamedArgumentExpected, current.Expression.GetLocation());
                        }
                        BindArgumentAndName(instance, diagnostics, ref hadLangVersionError, current, BindArgumentExpression(diagnostics, current.Expression, RefKind.None, allowArglist: false), current.NameColon, RefKind.None);
                        continue;
                    }
                    flag = true;
                    string valueText = current.NameEquals!.Name.Identifier.ValueText;
                    if (arrayBuilder == null)
                    {
                        arrayBuilder = ArrayBuilder<BoundAssignmentOperator>.GetInstance();
                        hashSet = new HashSet<string>();
                    }
                    else if (hashSet.Contains(valueText))
                    {
                        Error(diagnostics, ErrorCode.ERR_DuplicateNamedAttributeArgument, current, valueText);
                    }
                    BoundAssignmentOperator item = BindNamedAttributeArgument(current, attributeType, diagnostics);
                    arrayBuilder.Add(item);
                    hashSet.Add(valueText);
                }
            }
            return new AnalyzedAttributeArguments(instance, arrayBuilder);
        }

        private BoundAssignmentOperator BindNamedAttributeArgument(AttributeArgumentSyntax namedArgument, NamedTypeSymbol attributeType, BindingDiagnosticBag diagnostics)
        {
            Symbol symbol = BindNamedAttributeArgumentName(namedArgument, attributeType, diagnostics, out bool wasError, out LookupResultKind resultKind);
            ReportDiagnosticsIfObsolete(diagnostics, symbol, namedArgument, hasBaseReceiver: false);
            if (symbol.Kind == SymbolKind.Property)
            {
                MethodSymbol ownOrInheritedSetMethod = ((PropertySymbol)symbol).GetOwnOrInheritedSetMethod();
                if (ownOrInheritedSetMethod != null)
                {
                    ReportDiagnosticsIfObsolete(diagnostics, ownOrInheritedSetMethod, namedArgument, hasBaseReceiver: false);
                    if (ownOrInheritedSetMethod.IsInitOnly && ownOrInheritedSetMethod.DeclaringCompilation != Compilation)
                    {
                        CheckFeatureAvailability(namedArgument, MessageID.IDS_FeatureInitOnlySetters, diagnostics);
                    }
                }
            }
            TypeSymbol typeSymbol = ((!wasError) ? BindNamedAttributeArgumentType(namedArgument, symbol, attributeType, diagnostics) : CreateErrorType());
            BoundExpression expression = BindValue(namedArgument.Expression, diagnostics, BindValueKind.RValue);
            expression = GenerateConversionForAssignment(typeSymbol, expression, diagnostics);
            FieldSymbol fieldSymbol = symbol as FieldSymbol;
            IdentifierNameSyntax name = namedArgument.NameEquals!.Name;
            BoundExpression left;
            if ((object)fieldSymbol == null)
            {
                left = ((!(symbol is PropertySymbol propertySymbol)) ? BadExpression(name, resultKind) : ((BoundExpression)new BoundPropertyAccess(name, null, propertySymbol, resultKind, typeSymbol)));
            }
            else
            {
                (fieldSymbol.ContainingAssembly as SourceAssemblySymbol)?.NoteFieldAccess(fieldSymbol, read: true, write: true);
                left = new BoundFieldAccess(name, null, fieldSymbol, null, resultKind, fieldSymbol.Type);
            }
            return new BoundAssignmentOperator(namedArgument, left, expression, typeSymbol);
        }

        private Symbol BindNamedAttributeArgumentName(AttributeArgumentSyntax namedArgument, NamedTypeSymbol attributeType, BindingDiagnosticBag diagnostics, out bool wasError, out LookupResultKind resultKind)
        {
            IdentifierNameSyntax name = namedArgument.NameEquals!.Name;
            string valueText = name.Identifier.ValueText;
            LookupResult instance = LookupResult.GetInstance();
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            LookupMembersWithFallback(instance, attributeType, valueText, 0, ref useSiteInfo);
            diagnostics.Add(name, useSiteInfo);
            Symbol result = ResultSymbol(instance, valueText, 0, name, diagnostics, suppressUseSiteDiagnostics: false, out wasError, null);
            resultKind = instance.Kind;
            instance.Free();
            return result;
        }

        private TypeSymbol BindNamedAttributeArgumentType(AttributeArgumentSyntax namedArgument, Symbol namedArgumentNameSymbol, NamedTypeSymbol attributeType, BindingDiagnosticBag diagnostics)
        {
            if (namedArgumentNameSymbol.Kind == SymbolKind.ErrorType)
            {
                return (TypeSymbol)namedArgumentNameSymbol;
            }
            bool flag = false;
            TypeSymbol typeSymbol = null;
            flag |= namedArgumentNameSymbol.DeclaredAccessibility != Accessibility.Public;
            flag |= namedArgumentNameSymbol.IsStatic;
            if (!flag)
            {
                switch (namedArgumentNameSymbol.Kind)
                {
                    case SymbolKind.Field:
                        {
                            FieldSymbol fieldSymbol = (FieldSymbol)namedArgumentNameSymbol;
                            typeSymbol = fieldSymbol.Type;
                            flag |= fieldSymbol.IsReadOnly;
                            flag |= fieldSymbol.IsConst;
                            break;
                        }
                    case SymbolKind.Property:
                        {
                            PropertySymbol leastOverriddenProperty = ((PropertySymbol)namedArgumentNameSymbol).GetLeastOverriddenProperty(ContainingType);
                            typeSymbol = leastOverriddenProperty.Type;
                            flag |= leastOverriddenProperty.IsReadOnly;
                            MethodSymbol getMethod = leastOverriddenProperty.GetMethod;
                            MethodSymbol setMethod = leastOverriddenProperty.SetMethod;
                            flag = flag || (object)getMethod == null || (object)setMethod == null;
                            if (!flag)
                            {
                                flag = getMethod.DeclaredAccessibility != Accessibility.Public || setMethod.DeclaredAccessibility != Accessibility.Public;
                            }
                            break;
                        }
                    default:
                        flag = true;
                        break;
                }
            }
            if (flag)
            {
                return new ExtendedErrorTypeSymbol(attributeType, namedArgumentNameSymbol, LookupResultKind.NotAVariable, diagnostics.Add(ErrorCode.ERR_BadNamedAttributeArgument, namedArgument.NameEquals!.Name.Location, namedArgumentNameSymbol.Name));
            }
            if (!typeSymbol.IsValidAttributeParameterType(Compilation))
            {
                return new ExtendedErrorTypeSymbol(attributeType, namedArgumentNameSymbol, LookupResultKind.NotAVariable, diagnostics.Add(ErrorCode.ERR_BadNamedAttributeArgumentType, namedArgument.NameEquals!.Name.Location, namedArgumentNameSymbol.Name));
            }
            return typeSymbol;
        }

        protected MethodSymbol BindAttributeConstructor(AttributeSyntax node, NamedTypeSymbol attributeType, AnalyzedArguments boundConstructorArguments, BindingDiagnosticBag diagnostics, ref LookupResultKind resultKind, bool suppressErrors, ref ImmutableArray<int> argsToParamsOpt, ref bool expanded, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, out ImmutableArray<BoundExpression> constructorArguments)
        {
            if (!TryPerformConstructorOverloadResolution(attributeType, boundConstructorArguments, attributeType.Name, node.Location, suppressErrors, diagnostics, out var memberResolutionResult, out var candidateConstructors, allowProtectedConstructorsOfBaseType: true))
            {
                resultKind = resultKind.WorseResultKind((memberResolutionResult.IsValid && !IsConstructorAccessible(memberResolutionResult.Member, ref useSiteInfo)) ? LookupResultKind.Inaccessible : LookupResultKind.OverloadResolutionFailure);
                constructorArguments = BuildArgumentsForErrorRecovery(boundConstructorArguments, candidateConstructors);
            }
            else
            {
                constructorArguments = boundConstructorArguments.Arguments.ToImmutable();
            }
            argsToParamsOpt = memberResolutionResult.Result.ArgsToParamsOpt;
            expanded = memberResolutionResult.Result.Kind == MemberResolutionKind.ApplicableInExpandedForm;
            return memberResolutionResult.Member;
        }

        private ImmutableArray<TypedConstant> GetRewrittenAttributeConstructorArguments(out ImmutableArray<int> constructorArgumentsSourceIndices, MethodSymbol attributeConstructor, ImmutableArray<TypedConstant> constructorArgsArray, ImmutableArray<string> constructorArgumentNamesOpt, AttributeSyntax syntax, BindingDiagnosticBag diagnostics, ref bool hasErrors)
        {
            int length = constructorArgsArray.Length;
            int argsConsumedCount = 0;
            bool flag = !constructorArgumentNamesOpt.IsDefault;
            int num = -1;
            ImmutableArray<ParameterSymbol> parameters = attributeConstructor.Parameters;
            int length2 = parameters.Length;
            TypedConstant[] array = new TypedConstant[length2];
            int[] array2 = null;
            for (int i = 0; i < length2; i++)
            {
                ParameterSymbol parameterSymbol = parameters[i];
                TypedConstant typedConstant;
                if (parameterSymbol.IsParams && parameterSymbol.Type.IsSZArray() && i + 1 == length2)
                {
                    typedConstant = GetParamArrayArgument(parameterSymbol, constructorArgsArray, constructorArgumentNamesOpt, length, argsConsumedCount, Conversions, out var foundNamed);
                    if (!foundNamed)
                    {
                        array2 ??= CreateSourceIndicesArray(i, length2);
                    }
                }
                else if (argsConsumedCount < length)
                {
                    if (!flag || constructorArgumentNamesOpt[argsConsumedCount] == null)
                    {
                        typedConstant = constructorArgsArray[argsConsumedCount];
                        if (array2 != null)
                        {
                            array2[i] = argsConsumedCount;
                        }
                        argsConsumedCount++;
                    }
                    else
                    {
                        if (num == -1)
                        {
                            num = argsConsumedCount;
                        }
                        typedConstant = GetMatchingNamedOrOptionalConstructorArgument(out var matchingArgumentIndex, constructorArgsArray, constructorArgumentNamesOpt, parameterSymbol, num, length, ref argsConsumedCount, syntax, diagnostics);
                        array2 ??= CreateSourceIndicesArray(i, length2);
                        array2[i] = matchingArgumentIndex;
                    }
                }
                else
                {
                    typedConstant = GetDefaultValueArgument(parameterSymbol, syntax, diagnostics);
                    array2 ??= CreateSourceIndicesArray(i, length2);
                }
                if (!hasErrors)
                {
                    if (typedConstant.Kind == TypedConstantKind.Error)
                    {
                        hasErrors = true;
                    }
                    else if (typedConstant.Kind == TypedConstantKind.Array && parameterSymbol.Type.TypeKind == TypeKind.Array && !((TypeSymbol)typedConstant.TypeInternal).Equals(parameterSymbol.Type, TypeCompareKind.AllIgnoreOptions))
                    {
                        diagnostics.Add(ErrorCode.ERR_BadAttributeArgument, syntax.Location);
                        hasErrors = true;
                    }
                }
                array[i] = typedConstant;
            }
            constructorArgumentsSourceIndices = array2?.AsImmutableOrNull() ?? default(ImmutableArray<int>);
            return array.AsImmutableOrNull();
        }

        private static int[] CreateSourceIndicesArray(int paramIndex, int parameterCount)
        {
            int[] array = new int[parameterCount];
            for (int i = 0; i < paramIndex; i++)
            {
                array[i] = i;
            }
            for (int j = paramIndex; j < parameterCount; j++)
            {
                array[j] = -1;
            }
            return array;
        }

        private TypedConstant GetMatchingNamedOrOptionalConstructorArgument(out int matchingArgumentIndex, ImmutableArray<TypedConstant> constructorArgsArray, ImmutableArray<string> constructorArgumentNamesOpt, ParameterSymbol parameter, int startIndex, int argumentsCount, ref int argsConsumedCount, AttributeSyntax syntax, BindingDiagnosticBag diagnostics)
        {
            int matchingNamedConstructorArgumentIndex = GetMatchingNamedConstructorArgumentIndex(parameter.Name, constructorArgumentNamesOpt, startIndex, argumentsCount);
            if (matchingNamedConstructorArgumentIndex < argumentsCount)
            {
                argsConsumedCount++;
                matchingArgumentIndex = matchingNamedConstructorArgumentIndex;
                return constructorArgsArray[matchingNamedConstructorArgumentIndex];
            }
            matchingArgumentIndex = -1;
            return GetDefaultValueArgument(parameter, syntax, diagnostics);
        }

        private static int GetMatchingNamedConstructorArgumentIndex(string parameterName, ImmutableArray<string> argumentNamesOpt, int startIndex, int argumentsCount)
        {
            if (parameterName.IsEmpty() || !argumentNamesOpt.Any())
            {
                return argumentsCount;
            }
            int i;
            for (i = startIndex; i < argumentsCount && !string.Equals(argumentNamesOpt[i], parameterName, StringComparison.Ordinal); i++)
            {
            }
            return i;
        }

        private TypedConstant GetDefaultValueArgument(ParameterSymbol parameter, AttributeSyntax syntax, BindingDiagnosticBag diagnostics)
        {
            TypeSymbol typeSymbol = parameter.Type;
            ConstantValue constantValue = (parameter.IsOptional ? parameter.ExplicitDefaultConstantValue : null);
            object value = null;
            TypedConstantKind typedConstantKind;
            if (!IsEarlyAttributeBinder && parameter.IsCallerLineNumber)
            {
                int displayLineNumber = syntax.SyntaxTree.GetDisplayLineNumber(syntax.Name.Span);
                typedConstantKind = TypedConstantKind.Primitive;
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                Conversion callerLineNumberConversion = Conversions.GetCallerLineNumberConversion(typeSymbol, ref useSiteInfo);
                diagnostics.Add(syntax, useSiteInfo);
                if (callerLineNumberConversion.IsNumeric || callerLineNumberConversion.IsConstantExpression)
                {
                    value = ((typeSymbol.SpecialType == SpecialType.System_Single) ? displayLineNumber : DoUncheckedConversion(typeSymbol.SpecialType, ConstantValue.Create(displayLineNumber)));
                }
                else
                {
                    typeSymbol = Compilation.GetSpecialType(SpecialType.System_Int32);
                    value = displayLineNumber;
                }
            }
            else if (!IsEarlyAttributeBinder && parameter.IsCallerFilePath)
            {
                typeSymbol = Compilation.GetSpecialType(SpecialType.System_String);
                typedConstantKind = TypedConstantKind.Primitive;
                value = syntax.SyntaxTree.GetDisplayPath(syntax.Name.Span, Compilation.Options.SourceReferenceResolver);
            }
            else if (!IsEarlyAttributeBinder && parameter.IsCallerMemberName && (object)((ContextualAttributeBinder)this).AttributedMember != null)
            {
                typeSymbol = Compilation.GetSpecialType(SpecialType.System_String);
                typedConstantKind = TypedConstantKind.Primitive;
                value = ((ContextualAttributeBinder)this).AttributedMember.GetMemberCallerName();
            }
            else if (constantValue == null)
            {
                if (typeSymbol.SpecialType == SpecialType.System_Object)
                {
                    diagnostics.Add(ErrorCode.ERR_BadAttributeParamDefaultArgument, syntax.Name.Location, parameter.Name);
                    typedConstantKind = TypedConstantKind.Error;
                }
                else
                {
                    typedConstantKind = TypedConstant.GetTypedConstantKind(typeSymbol, Compilation);
                    constantValue = typeSymbol.GetDefaultValue();
                    if (constantValue != null)
                    {
                        value = constantValue.Value;
                    }
                }
            }
            else if (constantValue.IsBad)
            {
                typedConstantKind = TypedConstantKind.Error;
            }
            else if (typeSymbol.SpecialType == SpecialType.System_Object && !constantValue.IsNull)
            {
                diagnostics.Add(ErrorCode.ERR_NotNullRefDefaultParameter, syntax.Location, parameter.Name, typeSymbol);
                typedConstantKind = TypedConstantKind.Error;
            }
            else
            {
                typedConstantKind = TypedConstant.GetTypedConstantKind(typeSymbol, Compilation);
                value = constantValue.Value;
            }
            if (typedConstantKind == TypedConstantKind.Array)
            {
                return new TypedConstant(typeSymbol, default(ImmutableArray<TypedConstant>));
            }
            return new TypedConstant(typeSymbol, typedConstantKind, value);
        }

        private static TypedConstant GetParamArrayArgument(ParameterSymbol parameter, ImmutableArray<TypedConstant> constructorArgsArray, ImmutableArray<string> constructorArgumentNamesOpt, int argumentsCount, int argsConsumedCount, Conversions conversions, out bool foundNamed)
        {
            if (!constructorArgumentNamesOpt.IsDefault)
            {
                int num = constructorArgumentNamesOpt.IndexOf(parameter.Name);
                if (num >= 0)
                {
                    foundNamed = true;
                    if (TryGetNormalParamValue(parameter, constructorArgsArray, num, conversions, out var result))
                    {
                        return result;
                    }
                    return new TypedConstant(parameter.Type, ImmutableArray.Create(constructorArgsArray[num]));
                }
            }
            int num2 = argumentsCount - argsConsumedCount;
            foundNamed = false;
            switch (num2)
            {
                case 0:
                    return new TypedConstant(parameter.Type, ImmutableArray<TypedConstant>.Empty);
                case 1:
                    {
                        if (TryGetNormalParamValue(parameter, constructorArgsArray, argsConsumedCount, conversions, out var result2))
                        {
                            return result2;
                        }
                        break;
                    }
            }
            TypedConstant[] array = new TypedConstant[num2];
            for (int i = 0; i < num2; i++)
            {
                array[i] = constructorArgsArray[argsConsumedCount++];
            }
            return new TypedConstant(parameter.Type, array.AsImmutableOrNull());
        }

        private static bool TryGetNormalParamValue(ParameterSymbol parameter, ImmutableArray<TypedConstant> constructorArgsArray, int argIndex, Conversions conversions, out TypedConstant result)
        {
            TypedConstant typedConstant = constructorArgsArray[argIndex];
            if (typedConstant.Kind != TypedConstantKind.Array)
            {
                result = default(TypedConstant);
                return false;
            }
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
            Conversion conversion = conversions.ClassifyBuiltInConversion((TypeSymbol)typedConstant.TypeInternal, parameter.Type, ref useSiteInfo);
            if (conversion.IsValid && (conversion.Kind == ConversionKind.ImplicitReference || conversion.Kind == ConversionKind.Identity))
            {
                result = typedConstant;
                return true;
            }
            result = default(TypedConstant);
            return false;
        }

        private BoundExpression BindAwait(AwaitExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            BoundExpression expression = BindRValueWithoutTargetType(node.Expression, diagnostics);
            return BindAwait(expression, node, diagnostics);
        }

        private BoundAwaitExpression BindAwait(BoundExpression expression, SyntaxNode node, BindingDiagnosticBag diagnostics)
        {
            bool hasErrors = false;
            BoundAwaitableValuePlaceholder placeholder = new BoundAwaitableValuePlaceholder(expression.Syntax, GetValEscape(expression, LocalScopeDepth), expression.Type);
            ReportBadAwaitDiagnostics(node, node.Location, diagnostics, ref hasErrors);
            BoundAwaitableInfo boundAwaitableInfo = BindAwaitInfo(placeholder, node, diagnostics, ref hasErrors, expression);
            TypeSymbol type = boundAwaitableInfo.GetResult?.ReturnType ?? (hasErrors ? CreateErrorType() : Compilation.DynamicType);
            return new BoundAwaitExpression(node, expression, boundAwaitableInfo, type, hasErrors);
        }

        internal void ReportBadAwaitDiagnostics(SyntaxNode node, Location location, BindingDiagnosticBag diagnostics, ref bool hasErrors)
        {
            hasErrors |= ReportBadAwaitWithoutAsync(location, diagnostics);
            hasErrors |= ReportBadAwaitContext(node, location, diagnostics);
        }

        internal BoundAwaitableInfo BindAwaitInfo(BoundAwaitableValuePlaceholder placeholder, SyntaxNode node, BindingDiagnosticBag diagnostics, ref bool hasErrors, BoundExpression? expressionOpt = null)
        {
            bool flag = !GetAwaitableExpressionInfo(expressionOpt ?? placeholder, placeholder, out bool isDynamic, out BoundExpression getAwaiter, out PropertySymbol isCompleted, out MethodSymbol getResult, out BoundExpression getAwaiterGetResultCall, node, diagnostics);
            hasErrors |= flag;
            return new BoundAwaitableInfo(node, placeholder, isDynamic, getAwaiter, isCompleted, getResult, flag)
            {
                WasCompilerGenerated = true
            };
        }

        private bool CouldBeAwaited(BoundExpression expression)
        {
            if (expression.Kind != BoundKind.Call)
            {
                return false;
            }
            TypeSymbol type = expression.Type;
            if ((object)type == null || type.IsDynamic() || type.IsVoidType())
            {
                return false;
            }
            BoundCall boundCall = (BoundCall)expression;
            if ((object)boundCall.Method != null && boundCall.Method.IsAsync)
            {
                return true;
            }
            if (ImplementsWinRTAsyncInterface(boundCall.Type))
            {
                return true;
            }
            if (!(ContainingMemberOrLambda is MethodSymbol methodSymbol) || !methodSymbol.IsAsync)
            {
                return false;
            }
            if (ContextForbidsAwait)
            {
                return false;
            }
            return !BindAwait(expression, expression.Syntax, BindingDiagnosticBag.Discarded).HasAnyErrors;
        }

        private bool ReportBadAwaitWithoutAsync(Location location, BindingDiagnosticBag diagnostics)
        {
            DiagnosticInfo diagnosticInfo = null;
            Symbol containingMemberOrLambda = ContainingMemberOrLambda;
            if ((object)containingMemberOrLambda != null)
            {
                switch (containingMemberOrLambda.Kind)
                {
                    case SymbolKind.Field:
                        if (containingMemberOrLambda.ContainingType.IsScriptClass)
                        {
                            if (!((FieldSymbol)containingMemberOrLambda).IsStatic)
                            {
                                return false;
                            }
                            diagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAwaitInStaticVariableInitializer);
                        }
                        break;
                    case SymbolKind.Method:
                        {
                            MethodSymbol methodSymbol = (MethodSymbol)containingMemberOrLambda;
                            if (methodSymbol.IsAsync)
                            {
                                return false;
                            }
                            diagnosticInfo = ((methodSymbol.MethodKind != 0) ? (methodSymbol.ReturnsVoid ? new CSDiagnosticInfo(ErrorCode.ERR_BadAwaitWithoutVoidAsyncMethod) : new CSDiagnosticInfo(ErrorCode.ERR_BadAwaitWithoutAsyncMethod, methodSymbol.ReturnType)) : (methodSymbol.IsImplicitlyDeclared ? new CSDiagnosticInfo(ErrorCode.ERR_BadAwaitInQuery) : new CSDiagnosticInfo(ErrorCode.ERR_BadAwaitWithoutAsyncLambda, ((LambdaSymbol)methodSymbol).MessageID.Localize())));
                            break;
                        }
                }
            }
            if (diagnosticInfo == null)
            {
                diagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAwaitWithoutAsync);
            }
            Error(diagnostics, diagnosticInfo, location);
            return true;
        }

        private bool ReportBadAwaitContext(SyntaxNode node, Location location, BindingDiagnosticBag diagnostics)
        {
            if (InUnsafeRegion && !Flags.Includes(BinderFlags.AllowAwaitInUnsafeContext))
            {
                Error(diagnostics, ErrorCode.ERR_AwaitInUnsafeContext, location);
                return true;
            }
            if (Flags.Includes(BinderFlags.InLockBody))
            {
                Error(diagnostics, ErrorCode.ERR_BadAwaitInLock, location);
                return true;
            }
            if (Flags.Includes(BinderFlags.InCatchFilter))
            {
                Error(diagnostics, ErrorCode.ERR_BadAwaitInCatchFilter, location);
                return true;
            }
            if (Flags.Includes(BinderFlags.InFinallyBlock))
            {
                CSharpSyntaxTree obj = node.SyntaxTree as CSharpSyntaxTree;
                if (obj != null && obj.Options?.IsFeatureEnabled(MessageID.IDS_AwaitInCatchAndFinally) == false)
                {
                    Error(diagnostics, ErrorCode.ERR_BadAwaitInFinally, location);
                    return true;
                }
            }
            if (Flags.Includes(BinderFlags.InCatchBlock))
            {
                CSharpSyntaxTree obj2 = node.SyntaxTree as CSharpSyntaxTree;
                if (obj2 != null && obj2.Options?.IsFeatureEnabled(MessageID.IDS_AwaitInCatchAndFinally) == false)
                {
                    Error(diagnostics, ErrorCode.ERR_BadAwaitInCatch, location);
                    return true;
                }
            }
            return false;
        }

        internal bool GetAwaitableExpressionInfo(BoundExpression expression, out BoundExpression? getAwaiterGetResultCall, SyntaxNode node, BindingDiagnosticBag diagnostics)
        {
            return GetAwaitableExpressionInfo(expression, expression, out bool isDynamic, out BoundExpression getAwaiter, out PropertySymbol isCompleted, out MethodSymbol getResult, out getAwaiterGetResultCall, node, diagnostics);
        }

        private bool GetAwaitableExpressionInfo(BoundExpression expression, BoundExpression getAwaiterArgument, out bool isDynamic, out BoundExpression? getAwaiter, out PropertySymbol? isCompleted, out MethodSymbol? getResult, out BoundExpression? getAwaiterGetResultCall, SyntaxNode node, BindingDiagnosticBag diagnostics)
        {
            isDynamic = false;
            getAwaiter = null;
            isCompleted = null;
            getResult = null;
            getAwaiterGetResultCall = null;
            if (!ValidateAwaitedExpression(expression, node, diagnostics))
            {
                return false;
            }
            if (expression.HasDynamicType())
            {
                isDynamic = true;
                return true;
            }
            if (!GetGetAwaiterMethod(getAwaiterArgument, node, diagnostics, out getAwaiter))
            {
                return false;
            }
            TypeSymbol type = getAwaiter!.Type;
            if (GetIsCompletedProperty(type, node, expression.Type, diagnostics, out isCompleted) && AwaiterImplementsINotifyCompletion(type, node, diagnostics))
            {
                return GetGetResultMethod(getAwaiter, node, expression.Type, diagnostics, out getResult, out getAwaiterGetResultCall);
            }
            return false;
        }

        private static bool ValidateAwaitedExpression(BoundExpression expression, SyntaxNode node, BindingDiagnosticBag diagnostics)
        {
            if (expression.HasAnyErrors)
            {
                return false;
            }
            if ((object)expression.Type == null)
            {
                Error(diagnostics, ErrorCode.ERR_BadAwaitArgIntrinsic, node, expression.Display);
                return false;
            }
            return true;
        }

        private bool GetGetAwaiterMethod(BoundExpression expression, SyntaxNode node, BindingDiagnosticBag diagnostics, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out BoundExpression? getAwaiterCall)
        {
            if (expression.Type.IsVoidType())
            {
                Error(diagnostics, ErrorCode.ERR_BadAwaitArgVoidCall, node);
                getAwaiterCall = null;
                return false;
            }
            getAwaiterCall = MakeInvocationExpression(node, expression, "GetAwaiter", ImmutableArray<BoundExpression>.Empty, diagnostics);
            if (getAwaiterCall!.HasAnyErrors)
            {
                getAwaiterCall = null;
                return false;
            }
            if (getAwaiterCall!.Kind != BoundKind.Call)
            {
                Error(diagnostics, ErrorCode.ERR_BadAwaitArg, node, expression.Type);
                getAwaiterCall = null;
                return false;
            }
            MethodSymbol method = ((BoundCall)getAwaiterCall).Method;
            if (method is ErrorMethodSymbol || HasOptionalOrVariableParameters(method) || method.ReturnsVoid)
            {
                Error(diagnostics, ErrorCode.ERR_BadAwaitArg, node, expression.Type);
                getAwaiterCall = null;
                return false;
            }
            return true;
        }

        private bool GetIsCompletedProperty(TypeSymbol awaiterType, SyntaxNode node, TypeSymbol awaitedExpressionType, BindingDiagnosticBag diagnostics, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out PropertySymbol? isCompletedProperty)
        {
            BoundLiteral boundLeft = new BoundLiteral(node, ConstantValue.Null, awaiterType);
            string rightName = "IsCompleted";
            BoundExpression boundExpression = BindInstanceMemberAccess(node, node, boundLeft, rightName, 0, default(SeparatedSyntaxList<TypeSyntax>), default(ImmutableArray<TypeWithAnnotations>), invoked: false, indexed: false, diagnostics);
            if (boundExpression.HasAnyErrors)
            {
                isCompletedProperty = null;
                return false;
            }
            if (boundExpression.Kind != BoundKind.PropertyAccess)
            {
                Error(diagnostics, ErrorCode.ERR_NoSuchMember, node, awaiterType, "IsCompleted");
                isCompletedProperty = null;
                return false;
            }
            isCompletedProperty = ((BoundPropertyAccess)boundExpression).PropertySymbol;
            if (isCompletedProperty!.IsWriteOnly)
            {
                Error(diagnostics, ErrorCode.ERR_PropertyLacksGet, node, isCompletedProperty);
                isCompletedProperty = null;
                return false;
            }
            if (isCompletedProperty!.Type.SpecialType != SpecialType.System_Boolean)
            {
                Error(diagnostics, ErrorCode.ERR_BadAwaiterPattern, node, awaiterType, awaitedExpressionType);
                isCompletedProperty = null;
                return false;
            }
            return true;
        }

        private bool AwaiterImplementsINotifyCompletion(TypeSymbol awaiterType, SyntaxNode node, BindingDiagnosticBag diagnostics)
        {
            NamedTypeSymbol wellKnownType = GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_INotifyCompletion, diagnostics, node);
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            if (!Conversions.ClassifyImplicitConversionFromType(awaiterType, wellKnownType, ref useSiteInfo).IsImplicit)
            {
                diagnostics.Add(node, useSiteInfo);
                Error(diagnostics, ErrorCode.ERR_DoesntImplementAwaitInterface, node, awaiterType, wellKnownType);
                return false;
            }
            return true;
        }

        private bool GetGetResultMethod(BoundExpression awaiterExpression, SyntaxNode node, TypeSymbol awaitedExpressionType, BindingDiagnosticBag diagnostics, out MethodSymbol? getResultMethod, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out BoundExpression? getAwaiterGetResultCall)
        {
            TypeSymbol type = awaiterExpression.Type;
            getAwaiterGetResultCall = MakeInvocationExpression(node, awaiterExpression, "GetResult", ImmutableArray<BoundExpression>.Empty, diagnostics);
            if (getAwaiterGetResultCall!.HasAnyErrors)
            {
                getResultMethod = null;
                getAwaiterGetResultCall = null;
                return false;
            }
            if (getAwaiterGetResultCall!.Kind != BoundKind.Call)
            {
                Error(diagnostics, ErrorCode.ERR_NoSuchMember, node, type, "GetResult");
                getResultMethod = null;
                getAwaiterGetResultCall = null;
                return false;
            }
            getResultMethod = ((BoundCall)getAwaiterGetResultCall).Method;
            if (getResultMethod!.IsExtensionMethod)
            {
                Error(diagnostics, ErrorCode.ERR_NoSuchMember, node, type, "GetResult");
                getResultMethod = null;
                getAwaiterGetResultCall = null;
                return false;
            }
            if (HasOptionalOrVariableParameters(getResultMethod) || getResultMethod!.IsConditional)
            {
                Error(diagnostics, ErrorCode.ERR_BadAwaiterPattern, node, type, awaitedExpressionType);
                getResultMethod = null;
                getAwaiterGetResultCall = null;
                return false;
            }
            return true;
        }

        private static bool HasOptionalOrVariableParameters(MethodSymbol method)
        {
            if (method.ParameterCount != 0)
            {
                ParameterSymbol parameterSymbol = method.Parameters[method.ParameterCount - 1];
                if (!parameterSymbol.IsOptional)
                {
                    return parameterSymbol.IsParams;
                }
                return true;
            }
            return false;
        }

        internal ImmutableArray<TypeParameterConstraintClause> BindTypeParameterConstraintClauses(Symbol containingSymbol, ImmutableArray<TypeParameterSymbol> typeParameters, TypeParameterListSyntax typeParameterList, SyntaxList<TypeParameterConstraintClauseSyntax> clauses, BindingDiagnosticBag diagnostics, bool performOnlyCycleSafeValidation, bool isForOverride = false)
        {
            int length = typeParameters.Length;
            Dictionary<string, int> dictionary = new Dictionary<string, int>(length, StringOrdinalComparer.Instance);
            ImmutableArray<TypeParameterSymbol>.Enumerator enumerator = typeParameters.GetEnumerator();
            while (enumerator.MoveNext())
            {
                string name = enumerator.Current.Name;
                if (!dictionary.ContainsKey(name))
                {
                    dictionary.Add(name, dictionary.Count);
                }
            }
            ArrayBuilder<TypeParameterConstraintClause> instance = ArrayBuilder<TypeParameterConstraintClause>.GetInstance(length, null);
            ArrayBuilder<ArrayBuilder<TypeConstraintSyntax>> instance2 = ArrayBuilder<ArrayBuilder<TypeConstraintSyntax>>.GetInstance(length, null);
            SyntaxList<TypeParameterConstraintClauseSyntax>.Enumerator enumerator2 = clauses.GetEnumerator();
            while (enumerator2.MoveNext())
            {
                TypeParameterConstraintClauseSyntax current = enumerator2.Current;
                string valueText = current.Name.Identifier.ValueText;
                if (dictionary.TryGetValue(valueText, out var value))
                {
                    var (value2, arrayBuilder) = BindTypeParameterConstraints(typeParameterList.Parameters[value], current, isForOverride, diagnostics);
                    if (instance[value] == null)
                    {
                        instance[value] = value2;
                        instance2[value] = arrayBuilder;
                    }
                    else
                    {
                        diagnostics.Add(ErrorCode.ERR_DuplicateConstraintClause, current.Name.Location, valueText);
                        arrayBuilder?.Free();
                    }
                }
                else
                {
                    diagnostics.Add(ErrorCode.ERR_TyVarNotFoundInConstraint, current.Name.Location, valueText, containingSymbol.ConstructedFrom());
                }
            }
            for (int i = 0; i < length; i++)
            {
                if (instance[i] == null)
                {
                    instance[i] = GetDefaultTypeParameterConstraintClause(typeParameterList.Parameters[i], isForOverride);
                }
            }
            RemoveInvalidConstraints(typeParameters, instance, instance2, performOnlyCycleSafeValidation, diagnostics);
            ArrayBuilder<ArrayBuilder<TypeConstraintSyntax>>.Enumerator enumerator3 = instance2.GetEnumerator();
            while (enumerator3.MoveNext())
            {
                enumerator3.Current?.Free();
            }
            instance2.Free();
            return instance.ToImmutableAndFree();
        }

        private (TypeParameterConstraintClause, ArrayBuilder<TypeConstraintSyntax>?) BindTypeParameterConstraints(TypeParameterSyntax typeParameterSyntax, TypeParameterConstraintClauseSyntax constraintClauseSyntax, bool isForOverride, BindingDiagnosticBag diagnostics)
        {
            TypeParameterConstraintKind typeParameterConstraintKind = TypeParameterConstraintKind.None;
            ArrayBuilder<TypeWithAnnotations> arrayBuilder = null;
            ArrayBuilder<TypeConstraintSyntax> arrayBuilder2 = null;
            SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints = constraintClauseSyntax.Constraints;
            bool flag = false;
            bool reportedOverrideWithConstraints2 = false;
            int i = 0;
            for (int count = constraints.Count; i < count; i++)
            {
                TypeParameterConstraintSyntax typeParameterConstraintSyntax = constraints[i];
                switch (typeParameterConstraintSyntax.Kind())
                {
                    case SyntaxKind.ClassConstraint:
                        {
                            flag = true;
                            if (i != 0)
                            {
                                if (!reportedOverrideWithConstraints2)
                                {
                                    reportTypeConstraintsMustBeUniqueAndFirst(typeParameterConstraintSyntax, diagnostics);
                                }
                                if (isForOverride && (typeParameterConstraintKind & (TypeParameterConstraintKind.ReferenceType | TypeParameterConstraintKind.ValueType)) != 0)
                                {
                                    break;
                                }
                            }
                            ClassOrStructConstraintSyntax classOrStructConstraintSyntax = (ClassOrStructConstraintSyntax)typeParameterConstraintSyntax;
                            SyntaxToken questionToken = classOrStructConstraintSyntax.QuestionToken;
                            if (questionToken.IsKind(SyntaxKind.QuestionToken))
                            {
                                typeParameterConstraintKind |= TypeParameterConstraintKind.NullableReferenceType;
                                if (isForOverride)
                                {
                                    reportOverrideWithConstraints(ref reportedOverrideWithConstraints2, typeParameterConstraintSyntax, diagnostics);
                                    break;
                                }
                                DiagnosticBag diagnosticBag = diagnostics.DiagnosticBag;
                                if (diagnosticBag != null)
                                {
                                    LazyMissingNonNullTypesContextDiagnosticInfo.ReportNullableReferenceTypesIfNeeded(AreNullableAnnotationsEnabled(questionToken), IsGeneratedCode(questionToken), questionToken.GetLocation(), diagnosticBag);
                                }
                            }
                            else
                            {
                                typeParameterConstraintKind = ((!isForOverride && !AreNullableAnnotationsEnabled(classOrStructConstraintSyntax.ClassOrStructKeyword)) ? (typeParameterConstraintKind | TypeParameterConstraintKind.ReferenceType) : (typeParameterConstraintKind | TypeParameterConstraintKind.NotNullableReferenceType));
                            }
                            break;
                        }
                    case SyntaxKind.StructConstraint:
                        flag = true;
                        if (i != 0)
                        {
                            if (!reportedOverrideWithConstraints2)
                            {
                                reportTypeConstraintsMustBeUniqueAndFirst(typeParameterConstraintSyntax, diagnostics);
                            }
                            if (isForOverride && (typeParameterConstraintKind & (TypeParameterConstraintKind.ReferenceType | TypeParameterConstraintKind.ValueType)) != 0)
                            {
                                break;
                            }
                        }
                        typeParameterConstraintKind |= TypeParameterConstraintKind.ValueType;
                        break;
                    case SyntaxKind.ConstructorConstraint:
                        if (isForOverride)
                        {
                            reportOverrideWithConstraints(ref reportedOverrideWithConstraints2, typeParameterConstraintSyntax, diagnostics);
                            break;
                        }
                        if ((typeParameterConstraintKind & TypeParameterConstraintKind.ValueType) != 0)
                        {
                            diagnostics.Add(ErrorCode.ERR_NewBoundWithVal, typeParameterConstraintSyntax.GetFirstToken().GetLocation());
                        }
                        if ((typeParameterConstraintKind & TypeParameterConstraintKind.Unmanaged) != 0)
                        {
                            diagnostics.Add(ErrorCode.ERR_NewBoundWithUnmanaged, typeParameterConstraintSyntax.GetFirstToken().GetLocation());
                        }
                        if (i != count - 1)
                        {
                            diagnostics.Add(ErrorCode.ERR_NewBoundMustBeLast, typeParameterConstraintSyntax.GetFirstToken().GetLocation());
                        }
                        typeParameterConstraintKind |= TypeParameterConstraintKind.Constructor;
                        break;
                    case SyntaxKind.DefaultConstraint:
                        if (!isForOverride)
                        {
                            diagnostics.Add(ErrorCode.ERR_DefaultConstraintOverrideOnly, typeParameterConstraintSyntax.GetLocation());
                        }
                        if (i != 0)
                        {
                            if (!reportedOverrideWithConstraints2)
                            {
                                reportTypeConstraintsMustBeUniqueAndFirst(typeParameterConstraintSyntax, diagnostics);
                            }
                            if (isForOverride && (typeParameterConstraintKind & (TypeParameterConstraintKind.ReferenceType | TypeParameterConstraintKind.ValueType)) != 0)
                            {
                                break;
                            }
                        }
                        typeParameterConstraintKind |= TypeParameterConstraintKind.Default;
                        break;
                    case SyntaxKind.TypeConstraint:
                        {
                            if (isForOverride)
                            {
                                reportOverrideWithConstraints(ref reportedOverrideWithConstraints2, typeParameterConstraintSyntax, diagnostics);
                                break;
                            }
                            flag = true;
                            if (arrayBuilder == null)
                            {
                                arrayBuilder = ArrayBuilder<TypeWithAnnotations>.GetInstance();
                                arrayBuilder2 = ArrayBuilder<TypeConstraintSyntax>.GetInstance();
                            }
                            TypeConstraintSyntax typeConstraintSyntax = (TypeConstraintSyntax)typeParameterConstraintSyntax;
                            TypeSyntax type = typeConstraintSyntax.Type;
                            TypeWithAnnotations item = BindTypeOrConstraintKeyword(type, diagnostics, out ConstraintContextualKeyword keyword);
                            switch (keyword)
                            {
                                case ConstraintContextualKeyword.Unmanaged:
                                    if (i != 0)
                                    {
                                        reportTypeConstraintsMustBeUniqueAndFirst(type, diagnostics);
                                        break;
                                    }
                                    GetWellKnownType(WellKnownType.System_Runtime_InteropServices_UnmanagedType, diagnostics, type);
                                    GetSpecialType(SpecialType.System_ValueType, diagnostics, type);
                                    typeParameterConstraintKind |= TypeParameterConstraintKind.Unmanaged;
                                    break;
                                case ConstraintContextualKeyword.NotNull:
                                    if (i != 0)
                                    {
                                        reportTypeConstraintsMustBeUniqueAndFirst(type, diagnostics);
                                    }
                                    typeParameterConstraintKind |= TypeParameterConstraintKind.NotNull;
                                    break;
                                default:
                                    throw ExceptionUtilities.UnexpectedValue(keyword);
                                case ConstraintContextualKeyword.None:
                                    arrayBuilder.Add(item);
                                    arrayBuilder2.Add(typeConstraintSyntax);
                                    break;
                            }
                            break;
                        }
                    default:
                        throw ExceptionUtilities.UnexpectedValue(typeParameterConstraintSyntax.Kind());
                }
            }
            if (!isForOverride && !flag && !AreNullableAnnotationsEnabled(typeParameterSyntax.Identifier))
            {
                typeParameterConstraintKind |= TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType;
            }
            return (TypeParameterConstraintClause.Create(typeParameterConstraintKind, arrayBuilder?.ToImmutableAndFree() ?? ImmutableArray<TypeWithAnnotations>.Empty), arrayBuilder2);
            static void reportOverrideWithConstraints(ref bool reportedOverrideWithConstraints, TypeParameterConstraintSyntax syntax, BindingDiagnosticBag diagnostics)
            {
                if (!reportedOverrideWithConstraints)
                {
                    diagnostics.Add(ErrorCode.ERR_OverrideWithConstraints, syntax.GetLocation());
                    reportedOverrideWithConstraints = true;
                }
            }
            static void reportTypeConstraintsMustBeUniqueAndFirst(CSharpSyntaxNode syntax, BindingDiagnosticBag diagnostics)
            {
                diagnostics.Add(ErrorCode.ERR_TypeConstraintsMustBeUniqueAndFirst, syntax.GetLocation());
            }
        }

        internal ImmutableArray<TypeParameterConstraintClause> GetDefaultTypeParameterConstraintClauses(TypeParameterListSyntax typeParameterList)
        {
            ArrayBuilder<TypeParameterConstraintClause> instance = ArrayBuilder<TypeParameterConstraintClause>.GetInstance(typeParameterList.Parameters.Count);
            SeparatedSyntaxList<TypeParameterSyntax>.Enumerator enumerator = typeParameterList.Parameters.GetEnumerator();
            while (enumerator.MoveNext())
            {
                TypeParameterSyntax current = enumerator.Current;
                instance.Add(GetDefaultTypeParameterConstraintClause(current));
            }
            return instance.ToImmutableAndFree();
        }

        private TypeParameterConstraintClause GetDefaultTypeParameterConstraintClause(TypeParameterSyntax typeParameterSyntax, bool isForOverride = false)
        {
            if (!isForOverride && !AreNullableAnnotationsEnabled(typeParameterSyntax.Identifier))
            {
                return TypeParameterConstraintClause.ObliviousNullabilityIfReferenceType;
            }
            return TypeParameterConstraintClause.Empty;
        }

        private static void RemoveInvalidConstraints(ImmutableArray<TypeParameterSymbol> typeParameters, ArrayBuilder<TypeParameterConstraintClause> constraintClauses, ArrayBuilder<ArrayBuilder<TypeConstraintSyntax>?> syntaxNodes, bool performOnlyCycleSafeValidation, BindingDiagnosticBag diagnostics)
        {
            int length = typeParameters.Length;
            for (int i = 0; i < length; i++)
            {
                constraintClauses[i] = RemoveInvalidConstraints(typeParameters[i], constraintClauses[i], syntaxNodes[i], performOnlyCycleSafeValidation, diagnostics);
            }
        }

        private static TypeParameterConstraintClause RemoveInvalidConstraints(TypeParameterSymbol typeParameter, TypeParameterConstraintClause constraintClause, ArrayBuilder<TypeConstraintSyntax>? syntaxNodesOpt, bool performOnlyCycleSafeValidation, BindingDiagnosticBag diagnostics)
        {
            if (syntaxNodesOpt != null)
            {
                ImmutableArray<TypeWithAnnotations> constraintTypes = constraintClause.ConstraintTypes;
                Symbol containingSymbol = typeParameter.ContainingSymbol;
                ArrayBuilder<TypeWithAnnotations> instance = ArrayBuilder<TypeWithAnnotations>.GetInstance();
                int length = constraintTypes.Length;
                for (int i = 0; i < length; i++)
                {
                    TypeWithAnnotations typeWithAnnotations = constraintTypes[i];
                    TypeConstraintSyntax typeConstraintSyntax = syntaxNodesOpt![i];
                    if (IsValidConstraint(typeParameter, typeConstraintSyntax, typeWithAnnotations, constraintClause.Constraints, instance, performOnlyCycleSafeValidation, diagnostics))
                    {
                        if (!performOnlyCycleSafeValidation)
                        {
                            CheckConstraintTypeVisibility(containingSymbol, typeConstraintSyntax.Location, typeWithAnnotations, diagnostics);
                        }
                        instance.Add(typeWithAnnotations);
                    }
                }
                if (instance.Count < length)
                {
                    return TypeParameterConstraintClause.Create(constraintClause.Constraints, instance.ToImmutableAndFree());
                }
                instance.Free();
            }
            return constraintClause;
        }

        private static void CheckConstraintTypeVisibility(Symbol containingSymbol, Location location, TypeWithAnnotations constraintType, BindingDiagnosticBag diagnostics)
        {
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = new CompoundUseSiteInfo<AssemblySymbol>(diagnostics, containingSymbol.ContainingAssembly);
            if (!containingSymbol.IsNoMoreVisibleThan(constraintType, ref useSiteInfo))
            {
                diagnostics.Add(ErrorCode.ERR_BadVisBound, location, containingSymbol, constraintType.Type);
            }
            diagnostics.Add(location, useSiteInfo);
        }

        private static bool IsValidConstraint(TypeParameterSymbol typeParameter, TypeConstraintSyntax syntax, TypeWithAnnotations type, TypeParameterConstraintKind constraints, ArrayBuilder<TypeWithAnnotations> constraintTypes, bool performOnlyCycleSafeValidation, BindingDiagnosticBag diagnostics)
        {
            if (!isValidConstraintType(typeParameter, syntax, type, performOnlyCycleSafeValidation, diagnostics))
            {
                return false;
            }
            if (!performOnlyCycleSafeValidation && constraintTypes.Contains((TypeWithAnnotations c) => type.Equals(c, TypeCompareKind.AllIgnoreOptions)))
            {
                Error(diagnostics, ErrorCode.ERR_DuplicateBound, syntax, type.Type.SetUnknownNullabilityForReferenceTypes(), typeParameter.Name);
                return false;
            }
            if (!type.DefaultType.IsTypeParameter() && type.TypeKind == TypeKind.Class)
            {
                if (constraintTypes.Count > 0)
                {
                    Error(diagnostics, ErrorCode.ERR_ClassBoundNotFirst, syntax, type.Type);
                    return false;
                }
                if ((constraints & TypeParameterConstraintKind.ReferenceType) != 0)
                {
                    SpecialType specialType = type.SpecialType;
                    if ((uint)(specialType - 2) > 2u)
                    {
                        Error(diagnostics, ErrorCode.ERR_RefValBoundWithClass, syntax, type.Type);
                        return false;
                    }
                }
                else if (type.SpecialType != SpecialType.System_Enum)
                {
                    if ((constraints & TypeParameterConstraintKind.ValueType) != 0)
                    {
                        Error(diagnostics, ErrorCode.ERR_RefValBoundWithClass, syntax, type.Type);
                        return false;
                    }
                    if ((constraints & TypeParameterConstraintKind.Unmanaged) != 0)
                    {
                        Error(diagnostics, ErrorCode.ERR_UnmanagedBoundWithClass, syntax, type.Type);
                        return false;
                    }
                }
            }
            return true;
            static bool isValidConstraintType(TypeParameterSymbol typeParameter, TypeConstraintSyntax syntax, TypeWithAnnotations typeWithAnnotations, bool performOnlyCycleSafeValidation, BindingDiagnosticBag diagnostics)
            {
                if (typeWithAnnotations.NullableAnnotation == NullableAnnotation.Annotated && performOnlyCycleSafeValidation && typeWithAnnotations.DefaultType is TypeParameterSymbol typeParameterSymbol && (object)typeParameterSymbol.ContainingSymbol == typeParameter.ContainingSymbol)
                {
                    return true;
                }
                TypeSymbol type2 = typeWithAnnotations.Type;
                switch (type2.SpecialType)
                {
                    case SpecialType.System_Enum:
                        CheckFeatureAvailability(syntax, MessageID.IDS_FeatureEnumGenericTypeConstraint, diagnostics);
                        break;
                    case SpecialType.System_MulticastDelegate:
                    case SpecialType.System_Delegate:
                        CheckFeatureAvailability(syntax, MessageID.IDS_FeatureDelegateGenericTypeConstraint, diagnostics);
                        break;
                    case SpecialType.System_Object:
                    case SpecialType.System_ValueType:
                    case SpecialType.System_Array:
                        Error(diagnostics, ErrorCode.ERR_SpecialTypeAsBound, syntax, type2);
                        return false;
                }
                switch (type2.TypeKind)
                {
                    case TypeKind.Error:
                    case TypeKind.TypeParameter:
                        return true;
                    case TypeKind.Dynamic:
                        Error(diagnostics, ErrorCode.ERR_DynamicTypeAsBound, syntax);
                        return false;
                    case TypeKind.Class:
                        if (!type2.IsSealed)
                        {
                            if (type2.IsStatic)
                            {
                                Error(diagnostics, ErrorCode.ERR_ConstraintIsStaticClass, syntax, type2);
                                return false;
                            }
                            break;
                        }
                        goto case TypeKind.Delegate;
                    case TypeKind.Delegate:
                    case TypeKind.Enum:
                    case TypeKind.Struct:
                        Error(diagnostics, ErrorCode.ERR_BadBoundType, syntax, type2);
                        return false;
                    case TypeKind.Array:
                    case TypeKind.Pointer:
                    case TypeKind.FunctionPointer:
                        Error(diagnostics, ErrorCode.ERR_BadConstraintType, syntax.GetLocation());
                        return false;
                    default:
                        throw ExceptionUtilities.UnexpectedValue(type2.TypeKind);
                    case TypeKind.Interface:
                        break;
                }
                if (type2.ContainsDynamic())
                {
                    Error(diagnostics, ErrorCode.ERR_ConstructedDynamicTypeAsBound, syntax, type2);
                    return false;
                }
                return true;
            }
        }

        internal BoundExpression CreateConversion(BoundExpression source, TypeSymbol destination, BindingDiagnosticBag diagnostics)
        {
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            Conversion conversion = Conversions.ClassifyConversionFromExpression(source, destination, ref useSiteInfo);
            diagnostics.Add(source.Syntax, useSiteInfo);
            return CreateConversion(source.Syntax, source, conversion, isCast: false, null, destination, diagnostics);
        }

        internal BoundExpression CreateConversion(BoundExpression source, Conversion conversion, TypeSymbol destination, BindingDiagnosticBag diagnostics)
        {
            return CreateConversion(source.Syntax, source, conversion, isCast: false, null, destination, diagnostics);
        }

        internal BoundExpression CreateConversion(SyntaxNode syntax, BoundExpression source, Conversion conversion, bool isCast, ConversionGroup? conversionGroupOpt, TypeSymbol destination, BindingDiagnosticBag diagnostics)
        {
            return CreateConversion(syntax, source, conversion, isCast, conversionGroupOpt, source.WasCompilerGenerated, destination, diagnostics);
        }

        protected BoundExpression CreateConversion(SyntaxNode syntax, BoundExpression source, Conversion conversion, bool isCast, ConversionGroup? conversionGroupOpt, bool wasCompilerGenerated, TypeSymbol destination, BindingDiagnosticBag diagnostics, bool hasErrors = false)
        {
            if (conversion.IsIdentity)
            {
                if (source is BoundTupleLiteral literal)
                {
                    NamedTypeSymbol.ReportTupleNamesMismatchesIfAny(destination, literal, diagnostics);
                }
                source = BindToNaturalType(source, diagnostics);
                if (!isCast && source.Type!.Equals(destination, TypeCompareKind.IgnoreNullableModifiersForReferenceTypes))
                {
                    return source;
                }
            }
            if (conversion.IsMethodGroup)
            {
                return CreateMethodGroupConversion(syntax, source, conversion, isCast, conversionGroupOpt, destination, diagnostics);
            }
            ReportDiagnosticsIfObsolete(diagnostics, conversion, syntax, hasBaseReceiver: false);
            if (conversion.IsAnonymousFunction && source.Kind == BoundKind.UnboundLambda)
            {
                return CreateAnonymousFunctionConversion(syntax, source, conversion, isCast, conversionGroupOpt, destination, diagnostics);
            }
            if (conversion.IsStackAlloc)
            {
                return CreateStackAllocConversion(syntax, source, conversion, isCast, conversionGroupOpt, destination, diagnostics);
            }
            if (conversion.IsTupleLiteralConversion || (conversion.IsNullable && conversion.UnderlyingConversions[0].IsTupleLiteralConversion))
            {
                return CreateTupleLiteralConversion(syntax, (BoundTupleLiteral)source, conversion, isCast, conversionGroupOpt, destination, diagnostics);
            }
            if (conversion.Kind == ConversionKind.SwitchExpression)
            {
                BoundExpression boundExpression = ConvertSwitchExpression((BoundUnconvertedSwitchExpression)source, destination, conversion, diagnostics);
                return new BoundConversion(syntax, boundExpression, conversion, CheckOverflowAtRuntime, isCast && !wasCompilerGenerated, conversionGroupOpt, boundExpression.ConstantValue, destination, hasErrors);
            }
            if (conversion.Kind == ConversionKind.ConditionalExpression)
            {
                BoundExpression boundExpression2 = ConvertConditionalExpression((BoundUnconvertedConditionalOperator)source, destination, conversion, diagnostics);
                return new BoundConversion(syntax, boundExpression2, conversion, CheckOverflowAtRuntime, isCast && !wasCompilerGenerated, conversionGroupOpt, boundExpression2.ConstantValue, destination, hasErrors);
            }
            if (conversion.Kind == ConversionKind.InterpolatedString)
            {
                BoundUnconvertedInterpolatedString boundUnconvertedInterpolatedString = (BoundUnconvertedInterpolatedString)source;
                source = new BoundInterpolatedString(boundUnconvertedInterpolatedString.Syntax, boundUnconvertedInterpolatedString.Parts, boundUnconvertedInterpolatedString.ConstantValue, boundUnconvertedInterpolatedString.Type, boundUnconvertedInterpolatedString.HasErrors);
            }
            if (source.Kind == BoundKind.UnconvertedSwitchExpression)
            {
                TypeSymbol typeSymbol = source.Type;
                if ((object)typeSymbol == null)
                {
                    typeSymbol = CreateErrorType();
                    hasErrors = true;
                }
                source = ConvertSwitchExpression((BoundUnconvertedSwitchExpression)source, typeSymbol, null, diagnostics, hasErrors);
                if (destination.Equals(typeSymbol, TypeCompareKind.ConsiderEverything) && wasCompilerGenerated)
                {
                    return source;
                }
            }
            if (conversion.IsObjectCreation)
            {
                return ConvertObjectCreationExpression(syntax, (BoundUnconvertedObjectCreationExpression)source, isCast, destination, diagnostics);
            }
            if (source.Kind == BoundKind.UnconvertedConditionalOperator)
            {
                TypeSymbol typeSymbol2 = source.Type;
                if ((object)typeSymbol2 == null)
                {
                    typeSymbol2 = CreateErrorType();
                    hasErrors = true;
                }
                source = ConvertConditionalExpression((BoundUnconvertedConditionalOperator)source, typeSymbol2, null, diagnostics, hasErrors);
                if (destination.Equals(typeSymbol2, TypeCompareKind.ConsiderEverything) && wasCompilerGenerated)
                {
                    return source;
                }
            }
            if (conversion.IsUserDefined)
            {
                return CreateUserDefinedConversion(syntax, source, conversion, isCast, conversionGroupOpt ?? new ConversionGroup(conversion), destination, diagnostics, hasErrors);
            }
            ConstantValue constantValueOpt = FoldConstantConversion(syntax, source, conversion, destination, diagnostics);
            if (conversion.Kind == ConversionKind.DefaultLiteral)
            {
                source = new BoundDefaultExpression(source.Syntax, null, constantValueOpt, destination).WithSuppression(source.IsSuppressed);
            }
            return new BoundConversion(syntax, BindToNaturalType(source, diagnostics), conversion, CheckOverflowAtRuntime, isCast && !wasCompilerGenerated, conversionGroupOpt, constantValueOpt, destination, hasErrors)
            {
                WasCompilerGenerated = wasCompilerGenerated
            };
        }

        private BoundExpression ConvertObjectCreationExpression(SyntaxNode syntax, BoundUnconvertedObjectCreationExpression node, bool isCast, TypeSymbol destination, BindingDiagnosticBag diagnostics)
        {
            AnalyzedArguments instance = AnalyzedArguments.GetInstance(node.Arguments, node.ArgumentRefKindsOpt, node.ArgumentNamesOpt);
            BoundExpression boundExpression = BindObjectCreationExpression(node, destination.StrippedType(), instance, diagnostics);
            if (destination.IsNullableType())
            {
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                Conversion conversion = Conversions.ClassifyStandardConversion(null, boundExpression.Type, destination, ref useSiteInfo);
                boundExpression = new BoundConversion(node.Syntax, boundExpression, conversion, @checked: false, isCast, new ConversionGroup(conversion), boundExpression.ConstantValue, destination);
                diagnostics.Add(syntax, useSiteInfo);
            }
            instance.Free();
            return boundExpression;
        }

        private BoundExpression BindObjectCreationExpression(BoundUnconvertedObjectCreationExpression node, TypeSymbol type, AnalyzedArguments arguments, BindingDiagnosticBag diagnostics)
        {
            SyntaxNode syntax = node.Syntax;
            TypeKind typeKind = type.TypeKind;
            switch (typeKind)
            {
                case TypeKind.Class:
                    if (!type.IsAnonymousType)
                    {
                        goto case TypeKind.Enum;
                    }
                    goto case TypeKind.Array;
                case TypeKind.Enum:
                case TypeKind.Struct:
                    return BindClassCreationExpression(syntax, type.Name, syntax, (NamedTypeSymbol)type, arguments, diagnostics, node.InitializerOpt, null, wasTargetTyped: true);
                case TypeKind.TypeParameter:
                    return BindTypeParameterCreationExpression(syntax, (TypeParameterSymbol)type, arguments, node.InitializerOpt, syntax, diagnostics);
                case TypeKind.Delegate:
                    return BindDelegateCreationExpression(syntax, (NamedTypeSymbol)type, arguments, node.InitializerOpt, diagnostics);
                case TypeKind.Interface:
                    return BindInterfaceCreationExpression(syntax, (NamedTypeSymbol)type, diagnostics, syntax, arguments, node.InitializerOpt, wasTargetTyped: true);
                case TypeKind.Array:
                case TypeKind.Dynamic:
                    Error(diagnostics, ErrorCode.ERR_ImplicitObjectCreationIllegalTargetType, syntax, type);
                    goto case TypeKind.Error;
                case TypeKind.Pointer:
                case TypeKind.FunctionPointer:
                    Error(diagnostics, ErrorCode.ERR_UnsafeTypeInObjectCreation, syntax, type);
                    goto case TypeKind.Error;
                case TypeKind.Error:
                    return MakeBadExpressionForObjectCreation(syntax, type, arguments, node.InitializerOpt, syntax, diagnostics);
                default:
                    throw ExceptionUtilities.UnexpectedValue(typeKind);
            }
        }

        private BoundExpression ConvertConditionalExpression(BoundUnconvertedConditionalOperator source, TypeSymbol destination, Conversion? conversionIfTargetTyped, BindingDiagnosticBag diagnostics, bool hasErrors = false)
        {
            bool hasValue = conversionIfTargetTyped.HasValue;
            ImmutableArray<Conversion> underlyingConversions = conversionIfTargetTyped.GetValueOrDefault().UnderlyingConversions;
            BoundExpression condition = source.Condition;
            hasErrors |= source.HasErrors || destination.IsErrorType();
            BoundExpression boundExpression = (hasValue ? CreateConversion(source.Consequence.Syntax, source.Consequence, underlyingConversions[0], isCast: false, null, destination, diagnostics) : GenerateConversionForAssignment(destination, source.Consequence, diagnostics));
            BoundExpression boundExpression2 = (hasValue ? CreateConversion(source.Alternative.Syntax, source.Alternative, underlyingConversions[1], isCast: false, null, destination, diagnostics) : GenerateConversionForAssignment(destination, source.Alternative, diagnostics));
            ConstantValue constantValue = FoldConditionalOperator(condition, boundExpression, boundExpression2);
            hasErrors |= constantValue?.IsBad ?? false;
            if (hasValue && !destination.IsErrorType())
            {
                MessageID.IDS_FeatureTargetTypedConditional.CheckFeatureAvailability(diagnostics, source.Syntax);
            }
            return new BoundConditionalOperator(source.Syntax, isRef: false, condition, boundExpression, boundExpression2, constantValue, source.Type, hasValue, destination, hasErrors).WithSuppression(source.IsSuppressed);
        }

        private BoundExpression ConvertSwitchExpression(BoundUnconvertedSwitchExpression source, TypeSymbol destination, Conversion? conversionIfTargetTyped, BindingDiagnosticBag diagnostics, bool hasErrors = false)
        {
            bool hasValue = conversionIfTargetTyped.HasValue;
            Conversion conversion = conversionIfTargetTyped ?? Conversion.Identity;
            ImmutableArray<Conversion> underlyingConversions = conversion.UnderlyingConversions;
            ArrayBuilder<BoundSwitchExpressionArm> instance = ArrayBuilder<BoundSwitchExpressionArm>.GetInstance(source.SwitchArms.Length);
            int i = 0;
            for (int length = source.SwitchArms.Length; i < length; i++)
            {
                BoundSwitchExpressionArm boundSwitchExpressionArm = source.SwitchArms[i];
                BoundExpression value = boundSwitchExpressionArm.Value;
                BoundExpression boundExpression = (hasValue ? CreateConversion(value.Syntax, value, underlyingConversions[i], isCast: false, null, destination, diagnostics) : GenerateConversionForAssignment(destination, value, diagnostics));
                BoundSwitchExpressionArm item = ((value == boundExpression) ? boundSwitchExpressionArm : new BoundSwitchExpressionArm(boundSwitchExpressionArm.Syntax, boundSwitchExpressionArm.Locals, boundSwitchExpressionArm.Pattern, boundSwitchExpressionArm.WhenClause, boundExpression, boundSwitchExpressionArm.Label, boundSwitchExpressionArm.HasErrors));
                instance.Add(item);
            }
            ImmutableArray<BoundSwitchExpressionArm> switchArms = instance.ToImmutableAndFree();
            return new BoundConvertedSwitchExpression(source.Syntax, source.Type, hasValue, conversion, source.Expression, switchArms, source.DecisionDag, source.DefaultLabel, source.ReportedNotExhaustive, destination, hasErrors || source.HasErrors);
        }

        private BoundExpression CreateUserDefinedConversion(SyntaxNode syntax, BoundExpression source, Conversion conversion, bool isCast, ConversionGroup conversionGroup, TypeSymbol destination, BindingDiagnosticBag diagnostics, bool hasErrors)
        {
            if (!conversion.IsValid)
            {
                if (!hasErrors)
                {
                    GenerateImplicitConversionError(diagnostics, syntax, conversion, source, destination);
                }
                return new BoundConversion(syntax, source, conversion, CheckOverflowAtRuntime, isCast, conversionGroup, null, destination, hasErrors: true)
                {
                    WasCompilerGenerated = source.WasCompilerGenerated
                };
            }
            BoundExpression boundExpression = CreateConversion(source.Syntax, source, conversion.UserDefinedFromConversion, isCast: false, conversionGroup, wasCompilerGenerated: false, conversion.BestUserDefinedConversionAnalysis!.FromType, diagnostics);
            TypeSymbol parameterType = conversion.BestUserDefinedConversionAnalysis!.Operator.GetParameterType(0);
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            if (conversion.BestUserDefinedConversionAnalysis!.Kind == UserDefinedConversionAnalysisKind.ApplicableInNormalForm && !TypeSymbol.Equals(conversion.BestUserDefinedConversionAnalysis!.FromType, parameterType, TypeCompareKind.ConsiderEverything))
            {
                boundExpression = CreateConversion(syntax, boundExpression, Conversions.ClassifyStandardConversion(null, boundExpression.Type, parameterType, ref useSiteInfo), isCast: false, conversionGroup, wasCompilerGenerated: true, parameterType, diagnostics);
            }
            TypeSymbol returnType = conversion.BestUserDefinedConversionAnalysis!.Operator.ReturnType;
            TypeSymbol toType = conversion.BestUserDefinedConversionAnalysis!.ToType;
            Conversion conversion2 = conversion.UserDefinedToConversion;
            BoundExpression source2;
            if (conversion.BestUserDefinedConversionAnalysis!.Kind == UserDefinedConversionAnalysisKind.ApplicableInNormalForm && !TypeSymbol.Equals(toType, returnType, TypeCompareKind.ConsiderEverything))
            {
                source2 = new BoundConversion(syntax, boundExpression, conversion, @checked: false, isCast, conversionGroup, null, returnType)
                {
                    WasCompilerGenerated = true
                };
                if (toType.IsNullableType() && TypeSymbol.Equals(toType.GetNullableUnderlyingType(), returnType, TypeCompareKind.ConsiderEverything))
                {
                    conversion2 = Conversions.ClassifyConversionFromType(returnType, destination, ref useSiteInfo);
                }
                else
                {
                    source2 = CreateConversion(syntax, source2, Conversions.ClassifyStandardConversion(null, returnType, toType, ref useSiteInfo), isCast: false, conversionGroup, wasCompilerGenerated: true, toType, diagnostics);
                }
            }
            else
            {
                source2 = new BoundConversion(syntax, boundExpression, conversion, @checked: false, isCast, conversionGroup, null, toType)
                {
                    WasCompilerGenerated = true
                };
            }
            diagnostics.Add(syntax, useSiteInfo);
            BoundExpression boundExpression2 = CreateConversion(syntax, source2, conversion2, isCast: false, conversionGroup, wasCompilerGenerated: true, destination, diagnostics);
            boundExpression2.ResetCompilerGenerated(source.WasCompilerGenerated);
            return boundExpression2;
        }

        private BoundExpression CreateAnonymousFunctionConversion(SyntaxNode syntax, BoundExpression source, Conversion conversion, bool isCast, ConversionGroup? conversionGroup, TypeSymbol destination, BindingDiagnosticBag diagnostics)
        {
            UnboundLambda unboundLambda = (UnboundLambda)source;
            if ((destination.SpecialType == SpecialType.System_Delegate || destination.IsNonGenericExpressionType()) && syntax.IsFeatureEnabled(MessageID.IDS_FeatureInferredDelegateType))
            {
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                NamedTypeSymbol namedTypeSymbol = unboundLambda.InferDelegateType(ref useSiteInfo);
                BoundLambda boundLambda2;
                if ((object)namedTypeSymbol != null)
                {
                    if (destination.IsNonGenericExpressionType())
                    {
                        namedTypeSymbol = Compilation.GetWellKnownType(WellKnownType.System_Linq_Expressions_Expression_T).Construct(namedTypeSymbol);
                        namedTypeSymbol.AddUseSiteInfo(ref useSiteInfo);
                    }
                    boundLambda2 = unboundLambda.Bind(namedTypeSymbol);
                }
                else
                {
                    diagnostics.Add(ErrorCode.ERR_CannotInferDelegateType, syntax.GetLocation());
                    namedTypeSymbol = CreateErrorType();
                    boundLambda2 = unboundLambda.BindForErrorRecovery();
                }
                diagnostics.AddRange(boundLambda2.Diagnostics);
                BoundConversion boundConversion = createAnonymousFunctionConversion(syntax, source, boundLambda2, conversion, isCast, conversionGroup, namedTypeSymbol);
                conversion = Conversions.ClassifyConversionFromExpression(boundConversion, destination, ref useSiteInfo);
                diagnostics.Add(syntax, useSiteInfo);
                return CreateConversion(syntax, boundConversion, conversion, isCast, conversionGroup, destination, diagnostics);
            }
            BoundLambda boundLambda3 = unboundLambda.Bind((NamedTypeSymbol)destination);
            diagnostics.AddRange(boundLambda3.Diagnostics);
            return createAnonymousFunctionConversion(syntax, source, boundLambda3, conversion, isCast, conversionGroup, destination);
            static BoundConversion createAnonymousFunctionConversion(SyntaxNode syntax, BoundExpression source, BoundLambda boundLambda, Conversion conversion, bool isCast, ConversionGroup? conversionGroup, TypeSymbol destination)
            {
                return new BoundConversion(syntax, boundLambda, conversion, @checked: false, isCast, conversionGroup, null, destination)
                {
                    WasCompilerGenerated = source.WasCompilerGenerated
                };
            }
        }

        private BoundExpression CreateMethodGroupConversion(SyntaxNode syntax, BoundExpression source, Conversion conversion, bool isCast, ConversionGroup? conversionGroup, TypeSymbol destination, BindingDiagnosticBag diagnostics)
        {
            var (originalGroup, isAddressOf) = source switch
            {
                BoundMethodGroup m => (m, false),
                BoundUnconvertedAddressOfOperator { Operand: { } m } => (m, true),
                _ => throw ExceptionUtilities.UnexpectedValue(source),
            };
            BoundMethodGroup group = FixMethodGroupWithTypeOrValue(originalGroup, conversion, diagnostics);
            bool hasErrors = false;

            if (MethodGroupConversionHasErrors(syntax, conversion, group.ReceiverOpt, conversion.IsExtensionMethod, isAddressOf, destination, diagnostics))
            {
                hasErrors = true;
            }

            if (destination.SpecialType == SpecialType.System_Delegate &&
                syntax.IsFeatureEnabled(MessageID.IDS_FeatureInferredDelegateType))
            {
                // https://github.com/dotnet/roslyn/issues/52869: Avoid calculating the delegate type multiple times during conversion.
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                var delegateType = GetMethodGroupDelegateType(group, ref useSiteInfo);
                var expr = createMethodGroupConversion(syntax, group, conversion, isCast, conversionGroup, delegateType!, hasErrors);
                conversion = Conversions.ClassifyConversionFromExpression(expr, destination, ref useSiteInfo);
                diagnostics.Add(syntax, useSiteInfo);
                return CreateConversion(syntax, expr, conversion, isCast, conversionGroup, destination, diagnostics);
            }

#if DEBUG
            // Test inferring a delegate type for all callers.
            var discardedUseSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
            _ = GetMethodGroupDelegateType(group, ref discardedUseSiteInfo);
#endif
            return createMethodGroupConversion(syntax, group, conversion, isCast, conversionGroup, destination, hasErrors);

            static BoundConversion createMethodGroupConversion(SyntaxNode syntax, BoundMethodGroup group, Conversion conversion, bool isCast, ConversionGroup? conversionGroup, TypeSymbol destination, bool hasErrors)
            {
                return new BoundConversion(syntax, group, conversion, @checked: false, explicitCastInCode: isCast, conversionGroup, constantValueOpt: ConstantValue.NotAvailable, type: destination, hasErrors: hasErrors) { WasCompilerGenerated = group.WasCompilerGenerated };
            }
        }

        private BoundExpression CreateStackAllocConversion(SyntaxNode syntax, BoundExpression source, Conversion conversion, bool isCast, ConversionGroup? conversionGroup, TypeSymbol destination, BindingDiagnosticBag diagnostics)
        {
            BoundStackAllocArrayCreation boundStackAllocArrayCreation = (BoundStackAllocArrayCreation)source;
            TypeSymbol elementType = boundStackAllocArrayCreation.ElementType;
            TypeSymbol type;
            switch (conversion.Kind)
            {
                case ConversionKind.StackAllocToPointerType:
                    ReportUnsafeIfNotAllowed(syntax.Location, diagnostics);
                    type = new PointerTypeSymbol(TypeWithAnnotations.Create(elementType));
                    break;
                case ConversionKind.StackAllocToSpanType:
                    CheckFeatureAvailability(syntax, MessageID.IDS_FeatureRefStructs, diagnostics);
                    type = Compilation.GetWellKnownType(WellKnownType.System_Span_T).Construct(elementType);
                    break;
                default:
                    throw ExceptionUtilities.UnexpectedValue(conversion.Kind);
            }
            BoundConvertedStackAllocExpression source2 = new BoundConvertedStackAllocExpression(syntax, elementType, boundStackAllocArrayCreation.Count, boundStackAllocArrayCreation.InitializerOpt, type, boundStackAllocArrayCreation.HasErrors);
            Conversion conversion2 = conversion.UnderlyingConversions.Single();
            return CreateConversion(syntax, source2, conversion2, isCast, conversionGroup, destination, diagnostics);
        }

        private BoundExpression CreateTupleLiteralConversion(SyntaxNode syntax, BoundTupleLiteral sourceTuple, Conversion conversion, bool isCast, ConversionGroup? conversionGroup, TypeSymbol destination, BindingDiagnosticBag diagnostics)
        {
            TypeSymbol typeSymbol = destination;
            Conversion conversion2 = conversion;
            if (conversion.IsNullable)
            {
                typeSymbol = destination.GetNullableUnderlyingType();
                conversion2 = conversion.UnderlyingConversions[0];
            }
            NamedTypeSymbol namedTypeSymbol = (NamedTypeSymbol)typeSymbol;
            if (namedTypeSymbol.IsTupleType)
            {
                NamedTypeSymbol.ReportTupleNamesMismatchesIfAny(namedTypeSymbol, sourceTuple, diagnostics);
                if (sourceTuple.Type is NamedTypeSymbol namedTypeSymbol2 && namedTypeSymbol2.IsTupleType)
                {
                    namedTypeSymbol = namedTypeSymbol.WithTupleDataFrom(namedTypeSymbol2);
                }
                else
                {
                    TupleExpressionSyntax tupleExpressionSyntax = (TupleExpressionSyntax)sourceTuple.Syntax;
                    ArrayBuilder<Location> instance = ArrayBuilder<Location>.GetInstance();
                    SeparatedSyntaxList<ArgumentSyntax>.Enumerator enumerator = tupleExpressionSyntax.Arguments.GetEnumerator();
                    while (enumerator.MoveNext())
                    {
                        ArgumentSyntax current = enumerator.Current;
                        instance.Add(current.NameColon?.Name.Location);
                    }
                    namedTypeSymbol = namedTypeSymbol.WithElementNames(sourceTuple.ArgumentNamesOpt, instance.ToImmutableAndFree(), default(ImmutableArray<bool>), ImmutableArray.Create(tupleExpressionSyntax.Location));
                }
            }
            ImmutableArray<BoundExpression> arguments = sourceTuple.Arguments;
            ArrayBuilder<BoundExpression> instance2 = ArrayBuilder<BoundExpression>.GetInstance(arguments.Length);
            ImmutableArray<TypeWithAnnotations> tupleElementTypesWithAnnotations = namedTypeSymbol.TupleElementTypesWithAnnotations;
            ImmutableArray<Conversion> underlyingConversions = conversion2.UnderlyingConversions;
            for (int i = 0; i < arguments.Length; i++)
            {
                BoundExpression boundExpression = arguments[i];
                TypeWithAnnotations explicitType = tupleElementTypesWithAnnotations[i];
                Conversion conversion3 = underlyingConversions[i];
                ConversionGroup conversionGroupOpt = (isCast ? new ConversionGroup(conversion3, explicitType) : null);
                instance2.Add(CreateConversion(boundExpression.Syntax, boundExpression, conversion3, isCast, conversionGroupOpt, explicitType.Type, diagnostics));
            }
            BoundExpression boundExpression2 = new BoundConvertedTupleLiteral(sourceTuple.Syntax, sourceTuple, wasTargetTyped: true, instance2.ToImmutableAndFree(), sourceTuple.ArgumentNamesOpt, sourceTuple.InferredNamesOpt, namedTypeSymbol).WithSuppression(sourceTuple.IsSuppressed);
            if (!TypeSymbol.Equals(sourceTuple.Type, destination, TypeCompareKind.ConsiderEverything))
            {
                boundExpression2 = new BoundConversion(sourceTuple.Syntax, boundExpression2, conversion, @checked: false, isCast, conversionGroup, null, destination);
            }
            if (isCast)
            {
                boundExpression2 = new BoundConversion(syntax, boundExpression2, Conversion.Identity, @checked: false, isCast, conversionGroup, null, destination);
            }
            return boundExpression2;
        }

        private static bool IsMethodGroupWithTypeOrValueReceiver(BoundNode node)
        {
            if (node.Kind != BoundKind.MethodGroup)
            {
                return false;
            }
            return IsTypeOrValueExpression(((BoundMethodGroup)node).ReceiverOpt);
        }

        private BoundMethodGroup FixMethodGroupWithTypeOrValue(BoundMethodGroup group, Conversion conversion, BindingDiagnosticBag diagnostics)
        {
            if (!IsMethodGroupWithTypeOrValueReceiver(group))
            {
                return group;
            }
            BoundExpression receiverOpt = group.ReceiverOpt;
            BoundExpression receiver = receiverOpt;
            MethodSymbol? method = conversion.Method;
            receiverOpt = ReplaceTypeOrValueReceiver(receiver, (object)method != null && !method!.RequiresInstanceReceiver && !conversion.IsExtensionMethod, diagnostics);
            return group.Update(group.TypeArgumentsOpt, group.Name, group.Methods, group.LookupSymbolOpt, group.LookupError, group.Flags, receiverOpt, group.ResultKind);
        }

        private bool MemberGroupFinalValidation(BoundExpression? receiverOpt, MethodSymbol methodSymbol, SyntaxNode node, BindingDiagnosticBag diagnostics, bool invokedAsExtensionMethod)
        {
            if (!IsBadBaseAccess(node, receiverOpt, methodSymbol, diagnostics))
            {
                CheckRuntimeSupportForSymbolAccess(node, receiverOpt, methodSymbol, diagnostics);
            }
            if (MemberGroupFinalValidationAccessibilityChecks(receiverOpt, methodSymbol, node, diagnostics, invokedAsExtensionMethod))
            {
                return true;
            }
            ConstraintsHelper.CheckConstraintsArgs args = new ConstraintsHelper.CheckConstraintsArgs(Compilation, Conversions, includeNullability: false, node.Location, diagnostics);
            return !methodSymbol.CheckConstraints(in args);
        }

        private bool MemberGroupFinalValidationAccessibilityChecks(BoundExpression? receiverOpt, Symbol memberSymbol, SyntaxNode node, BindingDiagnosticBag diagnostics, bool invokedAsExtensionMethod)
        {
            if (!IsTypeOrValueExpression(receiverOpt))
            {
                if (!memberSymbol.RequiresInstanceReceiver())
                {
                    if (invokedAsExtensionMethod)
                    {
                        if (IsMemberAccessedThroughType(receiverOpt))
                        {
                            if (receiverOpt!.Kind == BoundKind.QueryClause)
                            {
                                diagnostics.Add(ErrorCode.ERR_QueryNoProvider, node.Location, receiverOpt!.Type, memberSymbol.Name);
                            }
                            else
                            {
                                diagnostics.Add(ErrorCode.ERR_ObjectRequired, node.Location, memberSymbol);
                            }
                            return true;
                        }
                    }
                    else if (!WasImplicitReceiver(receiverOpt) && IsMemberAccessedThroughVariableOrValue(receiverOpt))
                    {
                        if (Flags.Includes(BinderFlags.CollectionInitializerAddMethod))
                        {
                            diagnostics.Add(ErrorCode.ERR_InitializerAddHasWrongSignature, node.Location, memberSymbol);
                        }
                        else if (node.Kind() == SyntaxKind.AwaitExpression && memberSymbol.Name == "GetAwaiter")
                        {
                            diagnostics.Add(ErrorCode.ERR_BadAwaitArg, node.Location, receiverOpt!.Type);
                        }
                        else
                        {
                            diagnostics.Add(ErrorCode.ERR_ObjectProhibited, node.Location, memberSymbol);
                        }
                        return true;
                    }
                }
                else
                {
                    if (IsMemberAccessedThroughType(receiverOpt))
                    {
                        diagnostics.Add(ErrorCode.ERR_ObjectRequired, node.Location, memberSymbol);
                        return true;
                    }
                    if (WasImplicitReceiver(receiverOpt))
                    {
                        if ((InFieldInitializer && !ContainingType!.IsScriptClass) || InConstructorInitializer || InAttributeArgument)
                        {
                            SyntaxNode syntaxNode = node;
                            if (node.Parent != null && node.Parent.Kind() == SyntaxKind.InvocationExpression)
                            {
                                syntaxNode = node.Parent;
                            }
                            ErrorCode code = (InFieldInitializer ? ErrorCode.ERR_FieldInitRefNonstatic : ErrorCode.ERR_ObjectRequired);
                            diagnostics.Add(code, syntaxNode.Location, memberSymbol);
                            return true;
                        }
                        if (receiverOpt == null || ContainingMember().IsStatic)
                        {
                            Error(diagnostics, ErrorCode.ERR_ObjectRequired, node, memberSymbol);
                            return true;
                        }
                    }
                }
            }
            NamedTypeSymbol containingType = ContainingType;
            if ((object)containingType != null)
            {
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                bool num = IsSymbolAccessibleConditional(memberSymbol.GetTypeOrReturnType().Type, containingType, ref useSiteInfo);
                diagnostics.Add(node, useSiteInfo);
                if (!num)
                {
                    Error(diagnostics, ErrorCode.ERR_BadAccess, node, memberSymbol);
                    return true;
                }
            }
            return false;
        }

        private static bool IsMemberAccessedThroughVariableOrValue(BoundExpression? receiverOpt)
        {
            if (receiverOpt == null)
            {
                return false;
            }
            return !IsMemberAccessedThroughType(receiverOpt);
        }

        internal static bool IsMemberAccessedThroughType([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] BoundExpression? receiverOpt)
        {
            if (receiverOpt == null)
            {
                return false;
            }
            while (receiverOpt!.Kind == BoundKind.QueryClause)
            {
                receiverOpt = ((BoundQueryClause)receiverOpt).Value;
            }
            return receiverOpt!.Kind == BoundKind.TypeExpression;
        }

        internal static bool WasImplicitReceiver([System.Diagnostics.CodeAnalysis.NotNullWhen(false)] BoundExpression? receiverOpt)
        {
            if (receiverOpt == null)
            {
                return true;
            }
            if (!receiverOpt!.WasCompilerGenerated)
            {
                return false;
            }
            BoundKind kind = receiverOpt!.Kind;
            if (kind - 97 <= BoundKind.ParameterEqualsValue)
            {
                return true;
            }
            return false;
        }

        /// <summary>
        /// This method implements the checks in spec section 15.2.
        /// </summary>
        internal bool MethodIsCompatibleWithDelegateOrFunctionPointer(BoundExpression? receiverOpt, bool isExtensionMethod, MethodSymbol method, TypeSymbol delegateType, Location errorLocation, BindingDiagnosticBag diagnostics)
        {
            Debug.Assert(delegateType is NamedTypeSymbol { TypeKind: TypeKind.Delegate, DelegateInvokeMethod: { HasUseSiteError: false } }
                           || delegateType.TypeKind == TypeKind.FunctionPointer,
                         "This method should only be called for valid delegate or function pointer types.");

            MethodSymbol delegateOrFuncPtrMethod = delegateType switch
            {
                NamedTypeSymbol { DelegateInvokeMethod: { } invokeMethod } => invokeMethod,
                FunctionPointerTypeSymbol { Signature: { } signature } => signature,
                _ => throw ExceptionUtilities.UnexpectedValue(delegateType),
            };

            Debug.Assert(!isExtensionMethod || (receiverOpt != null));

            // - Argument types "match", and
            var delegateOrFuncPtrParameters = delegateOrFuncPtrMethod.Parameters;
            var methodParameters = method.Parameters;
            int numParams = delegateOrFuncPtrParameters.Length;

            if (methodParameters.Length != numParams + (isExtensionMethod ? 1 : 0))
            {
                // This can happen if "method" has optional parameters.
                Debug.Assert(methodParameters.Length > numParams + (isExtensionMethod ? 1 : 0));
                Error(diagnostics, getMethodMismatchErrorCode(delegateType.TypeKind), errorLocation, method, delegateType);
                return false;
            }

            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);

            // If this is an extension method delegate, the caller should have verified the
            // receiver is compatible with the "this" parameter of the extension method.
            Debug.Assert(!isExtensionMethod ||
                (Conversions.ConvertExtensionMethodThisArg(methodParameters[0].Type, receiverOpt!.Type, ref useSiteInfo).Exists && useSiteInfo.Diagnostics.IsNullOrEmpty()));

            useSiteInfo = new CompoundUseSiteInfo<AssemblySymbol>(useSiteInfo);

            for (int i = 0; i < numParams; i++)
            {
                var delegateParameter = delegateOrFuncPtrParameters[i];
                var methodParameter = methodParameters[isExtensionMethod ? i + 1 : i];

                // The delegate compatibility checks are stricter than the checks on applicable functions: it's possible
                // to get here with a method that, while all the parameters are applicable, is not actually delegate
                // compatible. This is because the Applicable function member spec requires that:
                //  * Every value parameter (non-ref or similar) from the delegate type has an implicit conversion to the corresponding
                //    target parameter
                //  * Every ref or similar parameter has an identity conversion to the corresponding target parameter
                // However, the delegate compatibility requirements are stricter:
                //  * Every value parameter (non-ref or similar) from the delegate type has an implicit _reference_ conversion to the
                //    corresponding target parameter.
                //  * Every ref or similar parameter has an identity conversion to the corresponding target parameter
                // Note the addition of the reference requirement: it means that for delegate type void D(int i), void M(long l) is
                // _applicable_, but not _compatible_.
                if (!hasConversion(delegateType.TypeKind, Conversions, delegateParameter.Type, methodParameter.Type, delegateParameter.RefKind, methodParameter.RefKind, ref useSiteInfo))
                {
                    // No overload for '{0}' matches delegate '{1}'
                    Error(diagnostics, getMethodMismatchErrorCode(delegateType.TypeKind), errorLocation, method, delegateType);
                    diagnostics.Add(errorLocation, useSiteInfo);
                    return false;
                }
            }

            if (delegateOrFuncPtrMethod.RefKind != method.RefKind)
            {
                Error(diagnostics, getRefMismatchErrorCode(delegateType.TypeKind), errorLocation, method, delegateType);
                diagnostics.Add(errorLocation, useSiteInfo);
                return false;
            }

            var methodReturnType = method.ReturnType;
            var delegateReturnType = delegateOrFuncPtrMethod.ReturnType;
            bool returnsMatch = delegateOrFuncPtrMethod switch
            {
                { RefKind: RefKind.None, ReturnsVoid: true } => method.ReturnsVoid,
                { RefKind: var destinationRefKind } => hasConversion(delegateType.TypeKind, Conversions, methodReturnType, delegateReturnType, method.RefKind, destinationRefKind, ref useSiteInfo),
            };

            if (!returnsMatch)
            {
                Error(diagnostics, ErrorCode.ERR_BadRetType, errorLocation, method, method.ReturnType);
                diagnostics.Add(errorLocation, useSiteInfo);
                return false;
            }

            if (delegateType.IsFunctionPointer())
            {
                if (isExtensionMethod)
                {
                    Error(diagnostics, ErrorCode.ERR_CannotUseReducedExtensionMethodInAddressOf, errorLocation);
                    diagnostics.Add(errorLocation, useSiteInfo);
                    return false;
                }

                if (!method.IsStatic)
                {
                    // This check is here purely for completeness of implementing the spec. It should
                    // never be hit, as static methods should be eliminated as candidates in overload
                    // resolution and should never make it to this point.
                    Debug.Fail("This method should have been eliminated in overload resolution!");
                    Error(diagnostics, ErrorCode.ERR_FuncPtrMethMustBeStatic, errorLocation, method);
                    diagnostics.Add(errorLocation, useSiteInfo);
                    return false;
                }
            }

            diagnostics.Add(errorLocation, useSiteInfo);
            return true;

            static bool hasConversion(TypeKind targetKind, Conversions conversions, TypeSymbol source, TypeSymbol destination,
                RefKind sourceRefKind, RefKind destinationRefKind, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
            {
                if (sourceRefKind != destinationRefKind)
                {
                    return false;
                }

                if (sourceRefKind != RefKind.None)
                {
                    return ConversionsBase.HasIdentityConversion(source, destination);
                }

                if (conversions.HasIdentityOrImplicitReferenceConversion(source, destination, ref useSiteInfo))
                {
                    return true;
                }

                return targetKind == TypeKind.FunctionPointer
                       && (ConversionsBase.HasImplicitPointerToVoidConversion(source, destination)
                           || conversions.HasImplicitPointerConversion(source, destination, ref useSiteInfo));
            }

            static ErrorCode getMethodMismatchErrorCode(TypeKind type)
                => type switch
                {
                    TypeKind.Delegate => ErrorCode.ERR_MethDelegateMismatch,
                    TypeKind.FunctionPointer => ErrorCode.ERR_MethFuncPtrMismatch,
                    _ => throw ExceptionUtilities.UnexpectedValue(type)
                };

            static ErrorCode getRefMismatchErrorCode(TypeKind type)
                => type switch
                {
                    TypeKind.Delegate => ErrorCode.ERR_DelegateRefMismatch,
                    TypeKind.FunctionPointer => ErrorCode.ERR_FuncPtrRefMismatch,
                    _ => throw ExceptionUtilities.UnexpectedValue(type)
                };
        }

        private bool MethodGroupConversionHasErrors(SyntaxNode syntax, Conversion conversion, BoundExpression? receiverOpt, bool isExtensionMethod, bool isAddressOf, TypeSymbol delegateOrFuncPtrType, BindingDiagnosticBag diagnostics)
        {
            MethodSymbol method = conversion.Method;
            Location location = syntax.Location;
            if (delegateOrFuncPtrType.SpecialType != SpecialType.System_Delegate && (!MethodIsCompatibleWithDelegateOrFunctionPointer(receiverOpt, isExtensionMethod, method, delegateOrFuncPtrType, location, diagnostics) || MemberGroupFinalValidation(receiverOpt, method, syntax, diagnostics, isExtensionMethod)))
            {
                return true;
            }
            if (method.IsConditional)
            {
                Error(diagnostics, ErrorCode.ERR_DelegateOnConditional, location, method);
                return true;
            }
            if (method is SourceOrdinaryMethodSymbol sourceOrdinaryMethodSymbol && sourceOrdinaryMethodSymbol.IsPartialWithoutImplementation)
            {
                Error(diagnostics, ErrorCode.ERR_PartialMethodToDelegate, location, method);
                return true;
            }
            if ((method.HasUnsafeParameter() || method.ReturnType.IsUnsafe()) && ReportUnsafeIfNotAllowed(syntax, diagnostics))
            {
                return true;
            }
            if (!isAddressOf)
            {
                ReportDiagnosticsIfUnmanagedCallersOnly(diagnostics, method, location, isDelegateConversion: true);
            }
            ReportDiagnosticsIfObsolete(diagnostics, method, syntax, hasBaseReceiver: false);
            return false;
        }

        private bool MethodGroupConversionDoesNotExistOrHasErrors(BoundMethodGroup boundMethodGroup, NamedTypeSymbol delegateType, Location delegateMismatchLocation, BindingDiagnosticBag diagnostics, out Conversion conversion)
        {
            if (ReportDelegateInvokeUseSiteDiagnostic(diagnostics, delegateType, delegateMismatchLocation))
            {
                conversion = Conversion.NoConversion;
                return true;
            }
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            conversion = Conversions.GetMethodGroupDelegateConversion(boundMethodGroup, delegateType, ref useSiteInfo);
            diagnostics.Add(delegateMismatchLocation, useSiteInfo);
            if (!conversion.Exists)
            {
                if (!Conversions.ReportDelegateOrFunctionPointerMethodGroupDiagnostics(this, boundMethodGroup, delegateType, diagnostics))
                {
                    diagnostics.Add(ErrorCode.ERR_MethDelegateMismatch, delegateMismatchLocation, boundMethodGroup.Name, delegateType);
                }
                return true;
            }
            return MethodGroupConversionHasErrors(boundMethodGroup.Syntax, conversion, boundMethodGroup.ReceiverOpt, conversion.IsExtensionMethod, isAddressOf: false, delegateType, diagnostics);
        }

        public ConstantValue? FoldConstantConversion(SyntaxNode syntax, BoundExpression source, Conversion conversion, TypeSymbol destination, BindingDiagnosticBag diagnostics)
        {
            ConstantValue constantValue = source.ConstantValue;
            if (constantValue == null)
            {
                if (conversion.Kind == ConversionKind.DefaultLiteral)
                {
                    return destination.GetDefaultValue();
                }
                return constantValue;
            }
            if (constantValue.IsBad)
            {
                return constantValue;
            }
            if (source.HasAnyErrors)
            {
                return null;
            }
            switch (conversion.Kind)
            {
                case ConversionKind.Identity:
                    return destination.SpecialType switch
                    {
                        SpecialType.System_Single => ConstantValue.Create(constantValue.SingleValue),
                        SpecialType.System_Double => ConstantValue.Create(constantValue.DoubleValue),
                        _ => constantValue,
                    };
                case ConversionKind.NullLiteral:
                    return constantValue;
                case ConversionKind.ImplicitConstant:
                    return FoldConstantNumericConversion(syntax, constantValue, destination, diagnostics);
                case ConversionKind.ImplicitNumeric:
                case ConversionKind.ImplicitEnumeration:
                case ConversionKind.ExplicitNumeric:
                case ConversionKind.ExplicitEnumeration:
                    if (destination.IsNullableType())
                    {
                        return null;
                    }
                    return FoldConstantNumericConversion(syntax, constantValue, destination, diagnostics);
                case ConversionKind.ImplicitReference:
                case ConversionKind.ExplicitReference:
                    if (!constantValue.IsNull)
                    {
                        return null;
                    }
                    return constantValue;
                default:
                    return null;
            }
        }

        private ConstantValue? FoldConstantNumericConversion(SyntaxNode syntax, ConstantValue sourceValue, TypeSymbol destination, BindingDiagnosticBag diagnostics)
        {
            SpecialType specialType = (((object)destination == null || !destination.IsEnumType()) ? destination.GetSpecialTypeSafe() : ((NamedTypeSymbol)destination).EnumUnderlyingType.SpecialType);
            bool maySucceedAtRuntime;
            if (sourceValue.IsDecimal)
            {
                if (!CheckConstantBounds(specialType, sourceValue, out maySucceedAtRuntime))
                {
                    Error(diagnostics, ErrorCode.ERR_ConstOutOfRange, syntax, sourceValue.Value?.ToString() + "M", destination);
                    return ConstantValue.Bad;
                }
            }
            else if (specialType == SpecialType.System_Decimal)
            {
                if (!CheckConstantBounds(specialType, sourceValue, out maySucceedAtRuntime))
                {
                    Error(diagnostics, ErrorCode.ERR_ConstOutOfRange, syntax, sourceValue.Value, destination);
                    return ConstantValue.Bad;
                }
            }
            else if (CheckOverflowAtCompileTime)
            {
                if (!CheckConstantBounds(specialType, sourceValue, out var maySucceedAtRuntime2))
                {
                    if (maySucceedAtRuntime2)
                    {
                        Error(diagnostics, ErrorCode.WRN_ConstOutOfRangeChecked, syntax, sourceValue.Value, destination);
                        return null;
                    }
                    Error(diagnostics, ErrorCode.ERR_ConstOutOfRangeChecked, syntax, sourceValue.Value, destination);
                    return ConstantValue.Bad;
                }
            }
            else if ((specialType == SpecialType.System_IntPtr || specialType == SpecialType.System_UIntPtr) && !CheckConstantBounds(specialType, sourceValue, out maySucceedAtRuntime))
            {
                return null;
            }
            return ConstantValue.Create(DoUncheckedConversion(specialType, sourceValue), specialType);
        }

        private static object DoUncheckedConversion(SpecialType destinationType, ConstantValue value)
        {
            bool maySucceedAtRuntime;
            switch (value.Discriminator)
            {
                case ConstantValueTypeDiscriminator.Byte:
                    {
                        byte byteValue = value.ByteValue;
                        return destinationType switch
                        {
                            SpecialType.System_Byte => byteValue,
                            SpecialType.System_Char => (char)byteValue,
                            SpecialType.System_UInt16 => (ushort)byteValue,
                            SpecialType.System_UInt32 => (uint)byteValue,
                            SpecialType.System_UInt64 => (ulong)byteValue,
                            SpecialType.System_SByte => (sbyte)byteValue,
                            SpecialType.System_Int16 => (short)byteValue,
                            SpecialType.System_Int32 => (int)byteValue,
                            SpecialType.System_Int64 => (long)byteValue,
                            SpecialType.System_IntPtr => (int)byteValue,
                            SpecialType.System_UIntPtr => (uint)byteValue,
                            SpecialType.System_Single or SpecialType.System_Double => (double)byteValue,
                            SpecialType.System_Decimal => (decimal)byteValue,
                            _ => throw ExceptionUtilities.UnexpectedValue(destinationType),
                        };
                    }
                case ConstantValueTypeDiscriminator.Char:
                    {
                        char charValue = value.CharValue;
                        return destinationType switch
                        {
                            SpecialType.System_Byte => (byte)charValue,
                            SpecialType.System_Char => charValue,
                            SpecialType.System_UInt16 => (ushort)charValue,
                            SpecialType.System_UInt32 => (uint)charValue,
                            SpecialType.System_UInt64 => (ulong)charValue,
                            SpecialType.System_SByte => (sbyte)charValue,
                            SpecialType.System_Int16 => (short)charValue,
                            SpecialType.System_Int32 => (int)charValue,
                            SpecialType.System_Int64 => (long)charValue,
                            SpecialType.System_IntPtr => (int)charValue,
                            SpecialType.System_UIntPtr => (uint)charValue,
                            SpecialType.System_Single or SpecialType.System_Double => (double)charValue,
                            SpecialType.System_Decimal => (decimal)charValue,
                            _ => throw ExceptionUtilities.UnexpectedValue(destinationType),
                        };
                    }
                case ConstantValueTypeDiscriminator.UInt16:
                    {
                        ushort uInt16Value = value.UInt16Value;
                        return destinationType switch
                        {
                            SpecialType.System_Byte => (byte)uInt16Value,
                            SpecialType.System_Char => (char)uInt16Value,
                            SpecialType.System_UInt16 => uInt16Value,
                            SpecialType.System_UInt32 => (uint)uInt16Value,
                            SpecialType.System_UInt64 => (ulong)uInt16Value,
                            SpecialType.System_SByte => (sbyte)uInt16Value,
                            SpecialType.System_Int16 => (short)uInt16Value,
                            SpecialType.System_Int32 => (int)uInt16Value,
                            SpecialType.System_Int64 => (long)uInt16Value,
                            SpecialType.System_IntPtr => (int)uInt16Value,
                            SpecialType.System_UIntPtr => (uint)uInt16Value,
                            SpecialType.System_Single or SpecialType.System_Double => (double)uInt16Value,
                            SpecialType.System_Decimal => (decimal)uInt16Value,
                            _ => throw ExceptionUtilities.UnexpectedValue(destinationType),
                        };
                    }
                case ConstantValueTypeDiscriminator.UInt32:
                    {
                        uint uInt32Value = value.UInt32Value;
                        return destinationType switch
                        {
                            SpecialType.System_Byte => (byte)uInt32Value,
                            SpecialType.System_Char => (char)uInt32Value,
                            SpecialType.System_UInt16 => (ushort)uInt32Value,
                            SpecialType.System_UInt32 => uInt32Value,
                            SpecialType.System_UInt64 => (ulong)uInt32Value,
                            SpecialType.System_SByte => (sbyte)uInt32Value,
                            SpecialType.System_Int16 => (short)uInt32Value,
                            SpecialType.System_Int32 => (int)uInt32Value,
                            SpecialType.System_Int64 => (long)uInt32Value,
                            SpecialType.System_IntPtr => (int)uInt32Value,
                            SpecialType.System_UIntPtr => uInt32Value,
                            SpecialType.System_Single => (double)(float)uInt32Value,
                            SpecialType.System_Double => (double)uInt32Value,
                            SpecialType.System_Decimal => (decimal)uInt32Value,
                            _ => throw ExceptionUtilities.UnexpectedValue(destinationType),
                        };
                    }
                case ConstantValueTypeDiscriminator.UInt64:
                    {
                        ulong uInt64Value = value.UInt64Value;
                        return destinationType switch
                        {
                            SpecialType.System_Byte => (byte)uInt64Value,
                            SpecialType.System_Char => (char)uInt64Value,
                            SpecialType.System_UInt16 => (ushort)uInt64Value,
                            SpecialType.System_UInt32 => (uint)uInt64Value,
                            SpecialType.System_UInt64 => uInt64Value,
                            SpecialType.System_SByte => (sbyte)uInt64Value,
                            SpecialType.System_Int16 => (short)uInt64Value,
                            SpecialType.System_Int32 => (int)uInt64Value,
                            SpecialType.System_Int64 => (long)uInt64Value,
                            SpecialType.System_IntPtr => (int)uInt64Value,
                            SpecialType.System_UIntPtr => (uint)uInt64Value,
                            SpecialType.System_Single => (double)(float)uInt64Value,
                            SpecialType.System_Double => (double)uInt64Value,
                            SpecialType.System_Decimal => (decimal)uInt64Value,
                            _ => throw ExceptionUtilities.UnexpectedValue(destinationType),
                        };
                    }
                case ConstantValueTypeDiscriminator.NUInt:
                    {
                        uint uInt32Value2 = value.UInt32Value;
                        return destinationType switch
                        {
                            SpecialType.System_Byte => (byte)uInt32Value2,
                            SpecialType.System_Char => (char)uInt32Value2,
                            SpecialType.System_UInt16 => (ushort)uInt32Value2,
                            SpecialType.System_UInt32 => uInt32Value2,
                            SpecialType.System_UInt64 => (ulong)uInt32Value2,
                            SpecialType.System_SByte => (sbyte)uInt32Value2,
                            SpecialType.System_Int16 => (short)uInt32Value2,
                            SpecialType.System_Int32 => (int)uInt32Value2,
                            SpecialType.System_Int64 => (long)uInt32Value2,
                            SpecialType.System_IntPtr => (int)uInt32Value2,
                            SpecialType.System_Single => (double)(float)uInt32Value2,
                            SpecialType.System_Double => (double)uInt32Value2,
                            SpecialType.System_Decimal => (decimal)uInt32Value2,
                            _ => throw ExceptionUtilities.UnexpectedValue(destinationType),
                        };
                    }
                case ConstantValueTypeDiscriminator.SByte:
                    {
                        sbyte sByteValue = value.SByteValue;
                        return destinationType switch
                        {
                            SpecialType.System_Byte => (byte)sByteValue,
                            SpecialType.System_Char => (char)sByteValue,
                            SpecialType.System_UInt16 => (ushort)sByteValue,
                            SpecialType.System_UInt32 => (uint)sByteValue,
                            SpecialType.System_UInt64 => (ulong)sByteValue,
                            SpecialType.System_SByte => sByteValue,
                            SpecialType.System_Int16 => (short)sByteValue,
                            SpecialType.System_Int32 => (int)sByteValue,
                            SpecialType.System_Int64 => (long)sByteValue,
                            SpecialType.System_IntPtr => (int)sByteValue,
                            SpecialType.System_UIntPtr => (uint)sByteValue,
                            SpecialType.System_Single or SpecialType.System_Double => (double)sByteValue,
                            SpecialType.System_Decimal => (decimal)sByteValue,
                            _ => throw ExceptionUtilities.UnexpectedValue(destinationType),
                        };
                    }
                case ConstantValueTypeDiscriminator.Int16:
                    {
                        short int16Value = value.Int16Value;
                        return destinationType switch
                        {
                            SpecialType.System_Byte => (byte)int16Value,
                            SpecialType.System_Char => (char)int16Value,
                            SpecialType.System_UInt16 => (ushort)int16Value,
                            SpecialType.System_UInt32 => (uint)int16Value,
                            SpecialType.System_UInt64 => (ulong)int16Value,
                            SpecialType.System_SByte => (sbyte)int16Value,
                            SpecialType.System_Int16 => int16Value,
                            SpecialType.System_Int32 => (int)int16Value,
                            SpecialType.System_Int64 => (long)int16Value,
                            SpecialType.System_IntPtr => (int)int16Value,
                            SpecialType.System_UIntPtr => (uint)int16Value,
                            SpecialType.System_Single or SpecialType.System_Double => (double)int16Value,
                            SpecialType.System_Decimal => (decimal)int16Value,
                            _ => throw ExceptionUtilities.UnexpectedValue(destinationType),
                        };
                    }
                case ConstantValueTypeDiscriminator.Int32:
                    {
                        int int32Value2 = value.Int32Value;
                        return destinationType switch
                        {
                            SpecialType.System_Byte => (byte)int32Value2,
                            SpecialType.System_Char => (char)int32Value2,
                            SpecialType.System_UInt16 => (ushort)int32Value2,
                            SpecialType.System_UInt32 => (uint)int32Value2,
                            SpecialType.System_UInt64 => (ulong)int32Value2,
                            SpecialType.System_SByte => (sbyte)int32Value2,
                            SpecialType.System_Int16 => (short)int32Value2,
                            SpecialType.System_Int32 => int32Value2,
                            SpecialType.System_Int64 => (long)int32Value2,
                            SpecialType.System_IntPtr => int32Value2,
                            SpecialType.System_UIntPtr => (uint)int32Value2,
                            SpecialType.System_Single => (double)(float)int32Value2,
                            SpecialType.System_Double => (double)int32Value2,
                            SpecialType.System_Decimal => (decimal)int32Value2,
                            _ => throw ExceptionUtilities.UnexpectedValue(destinationType),
                        };
                    }
                case ConstantValueTypeDiscriminator.Int64:
                    {
                        long int64Value = value.Int64Value;
                        return destinationType switch
                        {
                            SpecialType.System_Byte => (byte)int64Value,
                            SpecialType.System_Char => (char)int64Value,
                            SpecialType.System_UInt16 => (ushort)int64Value,
                            SpecialType.System_UInt32 => (uint)int64Value,
                            SpecialType.System_UInt64 => (ulong)int64Value,
                            SpecialType.System_SByte => (sbyte)int64Value,
                            SpecialType.System_Int16 => (short)int64Value,
                            SpecialType.System_Int32 => (int)int64Value,
                            SpecialType.System_Int64 => int64Value,
                            SpecialType.System_IntPtr => (int)int64Value,
                            SpecialType.System_UIntPtr => (uint)int64Value,
                            SpecialType.System_Single => (double)(float)int64Value,
                            SpecialType.System_Double => (double)int64Value,
                            SpecialType.System_Decimal => (decimal)int64Value,
                            _ => throw ExceptionUtilities.UnexpectedValue(destinationType),
                        };
                    }
                case ConstantValueTypeDiscriminator.NInt:
                    {
                        int int32Value = value.Int32Value;
                        return destinationType switch
                        {
                            SpecialType.System_Byte => (byte)int32Value,
                            SpecialType.System_Char => (char)int32Value,
                            SpecialType.System_UInt16 => (ushort)int32Value,
                            SpecialType.System_UInt32 => (uint)int32Value,
                            SpecialType.System_UInt64 => (ulong)int32Value,
                            SpecialType.System_SByte => (sbyte)int32Value,
                            SpecialType.System_Int16 => (short)int32Value,
                            SpecialType.System_Int32 => int32Value,
                            SpecialType.System_Int64 => (long)int32Value,
                            SpecialType.System_IntPtr => int32Value,
                            SpecialType.System_UIntPtr => (uint)int32Value,
                            SpecialType.System_Single => (double)(float)int32Value,
                            SpecialType.System_Double => (double)int32Value,
                            SpecialType.System_Decimal => (decimal)int32Value,
                            _ => throw ExceptionUtilities.UnexpectedValue(destinationType),
                        };
                    }
                case ConstantValueTypeDiscriminator.Single:
                case ConstantValueTypeDiscriminator.Double:
                    {
                        double num2 = (CheckConstantBounds(destinationType, value.DoubleValue, out maySucceedAtRuntime) ? value.DoubleValue : 0.0);
                        return destinationType switch
                        {
                            SpecialType.System_Byte => (byte)num2,
                            SpecialType.System_Char => (char)num2,
                            SpecialType.System_UInt16 => (ushort)num2,
                            SpecialType.System_UInt32 => (uint)num2,
                            SpecialType.System_UInt64 => (ulong)num2,
                            SpecialType.System_SByte => (sbyte)num2,
                            SpecialType.System_Int16 => (short)num2,
                            SpecialType.System_Int32 => (int)num2,
                            SpecialType.System_Int64 => (long)num2,
                            SpecialType.System_IntPtr => (int)num2,
                            SpecialType.System_UIntPtr => (uint)num2,
                            SpecialType.System_Single => (double)(float)num2,
                            SpecialType.System_Double => num2,
                            SpecialType.System_Decimal => (value.Discriminator == ConstantValueTypeDiscriminator.Single) ? ((decimal)(float)num2) : ((decimal)num2),
                            _ => throw ExceptionUtilities.UnexpectedValue(destinationType),
                        };
                    }
                case ConstantValueTypeDiscriminator.Decimal:
                    {
                        decimal num = (CheckConstantBounds(destinationType, value.DecimalValue, out maySucceedAtRuntime) ? value.DecimalValue : 0m);
                        return destinationType switch
                        {
                            SpecialType.System_Byte => (byte)num,
                            SpecialType.System_Char => (char)num,
                            SpecialType.System_UInt16 => (ushort)num,
                            SpecialType.System_UInt32 => (uint)num,
                            SpecialType.System_UInt64 => (ulong)num,
                            SpecialType.System_SByte => (sbyte)num,
                            SpecialType.System_Int16 => (short)num,
                            SpecialType.System_Int32 => (int)num,
                            SpecialType.System_Int64 => (long)num,
                            SpecialType.System_IntPtr => (int)num,
                            SpecialType.System_UIntPtr => (uint)num,
                            SpecialType.System_Single => (double)(float)num,
                            SpecialType.System_Double => (double)num,
                            SpecialType.System_Decimal => num,
                            _ => throw ExceptionUtilities.UnexpectedValue(destinationType),
                        };
                    }
                default:
                    throw ExceptionUtilities.UnexpectedValue(value.Discriminator);
            }
        }

        public static bool CheckConstantBounds(SpecialType destinationType, ConstantValue value, out bool maySucceedAtRuntime)
        {
            if (value.IsBad)
            {
                maySucceedAtRuntime = false;
                return true;
            }
            object obj = CanonicalizeConstant(value);
            if (!(obj is decimal))
            {
                return CheckConstantBounds(destinationType, (double)obj, out maySucceedAtRuntime);
            }
            return CheckConstantBounds(destinationType, (decimal)obj, out maySucceedAtRuntime);
        }

        private static bool CheckConstantBounds(SpecialType destinationType, double value, out bool maySucceedAtRuntime)
        {
            maySucceedAtRuntime = false;
            switch (destinationType)
            {
                case SpecialType.System_Byte:
                    if (-1.0 < value)
                    {
                        return value < 256.0;
                    }
                    return false;
                case SpecialType.System_Char:
                    if (-1.0 < value)
                    {
                        return value < 65536.0;
                    }
                    return false;
                case SpecialType.System_UInt16:
                    if (-1.0 < value)
                    {
                        return value < 65536.0;
                    }
                    return false;
                case SpecialType.System_UInt32:
                    if (-1.0 < value)
                    {
                        return value < 4294967296.0;
                    }
                    return false;
                case SpecialType.System_UInt64:
                    if (-1.0 < value)
                    {
                        return value < 1.8446744073709552E+19;
                    }
                    return false;
                case SpecialType.System_SByte:
                    if (-129.0 < value)
                    {
                        return value < 128.0;
                    }
                    return false;
                case SpecialType.System_Int16:
                    if (-32769.0 < value)
                    {
                        return value < 32768.0;
                    }
                    return false;
                case SpecialType.System_Int32:
                    if (-2147483649.0 < value)
                    {
                        return value < 2147483648.0;
                    }
                    return false;
                case SpecialType.System_Int64:
                    if (-9.2233720368547758E+18 <= value)
                    {
                        return value < 9.2233720368547758E+18;
                    }
                    return false;
                case SpecialType.System_Decimal:
                    if (-7.9228162514264338E+28 < value)
                    {
                        return value < 7.9228162514264338E+28;
                    }
                    return false;
                case SpecialType.System_IntPtr:
                    maySucceedAtRuntime = -9.2233720368547758E+18 < value && value < 9.2233720368547758E+18;
                    if (-2147483649.0 < value)
                    {
                        return value < 2147483648.0;
                    }
                    return false;
                case SpecialType.System_UIntPtr:
                    maySucceedAtRuntime = -1.0 < value && value < 1.8446744073709552E+19;
                    if (-1.0 < value)
                    {
                        return value < 4294967296.0;
                    }
                    return false;
                default:
                    return true;
            }
        }

        private static bool CheckConstantBounds(SpecialType destinationType, decimal value, out bool maySucceedAtRuntime)
        {
            maySucceedAtRuntime = false;
            switch (destinationType)
            {
                case SpecialType.System_Byte:
                    if (-1m < value)
                    {
                        return value < 256m;
                    }
                    return false;
                case SpecialType.System_Char:
                    if (-1m < value)
                    {
                        return value < 65536m;
                    }
                    return false;
                case SpecialType.System_UInt16:
                    if (-1m < value)
                    {
                        return value < 65536m;
                    }
                    return false;
                case SpecialType.System_UInt32:
                    if (-1m < value)
                    {
                        return value < new decimal(4294967296L);
                    }
                    return false;
                case SpecialType.System_UInt64:
                    if (-1m < value)
                    {
                        return value < 18446744073709551616m;
                    }
                    return false;
                case SpecialType.System_SByte:
                    if (-129m < value)
                    {
                        return value < 128m;
                    }
                    return false;
                case SpecialType.System_Int16:
                    if (-32769m < value)
                    {
                        return value < 32768m;
                    }
                    return false;
                case SpecialType.System_Int32:
                    if (new decimal(-2147483649L) < value)
                    {
                        return value < -2147483648m;
                    }
                    return false;
                case SpecialType.System_Int64:
                    if (-9223372036854775809m < value)
                    {
                        return value < new decimal(9223372036854775808uL);
                    }
                    return false;
                case SpecialType.System_IntPtr:
                    maySucceedAtRuntime = -9223372036854775809m < value && value < new decimal(9223372036854775808uL);
                    if (new decimal(-2147483649L) < value)
                    {
                        return value < -2147483648m;
                    }
                    return false;
                case SpecialType.System_UIntPtr:
                    maySucceedAtRuntime = -1m < value && value < 18446744073709551616m;
                    if (-1m < value)
                    {
                        return value < new decimal(4294967296L);
                    }
                    return false;
                default:
                    return true;
            }
        }

        private static object CanonicalizeConstant(ConstantValue value)
        {
            return value.Discriminator switch
            {
                ConstantValueTypeDiscriminator.SByte => (decimal)value.SByteValue,
                ConstantValueTypeDiscriminator.Int16 => (decimal)value.Int16Value,
                ConstantValueTypeDiscriminator.Int32 => (decimal)value.Int32Value,
                ConstantValueTypeDiscriminator.Int64 => (decimal)value.Int64Value,
                ConstantValueTypeDiscriminator.NInt => (decimal)value.Int32Value,
                ConstantValueTypeDiscriminator.Byte => (decimal)value.ByteValue,
                ConstantValueTypeDiscriminator.Char => (decimal)value.CharValue,
                ConstantValueTypeDiscriminator.UInt16 => (decimal)value.UInt16Value,
                ConstantValueTypeDiscriminator.UInt32 => (decimal)value.UInt32Value,
                ConstantValueTypeDiscriminator.UInt64 => (decimal)value.UInt64Value,
                ConstantValueTypeDiscriminator.NUInt => (decimal)value.UInt32Value,
                ConstantValueTypeDiscriminator.Single or ConstantValueTypeDiscriminator.Double => value.DoubleValue,
                ConstantValueTypeDiscriminator.Decimal => value.DecimalValue,
                _ => throw ExceptionUtilities.UnexpectedValue(value.Discriminator),
            };
        }

        internal ImmutableArray<Symbol> BindCref(CrefSyntax syntax, out Symbol? ambiguityWinner, BindingDiagnosticBag diagnostics)
        {
            return BindCrefInternal(syntax, out ambiguityWinner, diagnostics);
        }

        private ImmutableArray<Symbol> BindCrefInternal(CrefSyntax syntax, out Symbol? ambiguityWinner, BindingDiagnosticBag diagnostics)
        {
            return syntax.Kind() switch
            {
                SyntaxKind.TypeCref => BindTypeCref((TypeCrefSyntax)syntax, out ambiguityWinner, diagnostics),
                SyntaxKind.QualifiedCref => BindQualifiedCref((QualifiedCrefSyntax)syntax, out ambiguityWinner, diagnostics),
                SyntaxKind.NameMemberCref or SyntaxKind.IndexerMemberCref or SyntaxKind.OperatorMemberCref or SyntaxKind.ConversionOperatorMemberCref => BindMemberCref((MemberCrefSyntax)syntax, null, out ambiguityWinner, diagnostics),
                _ => throw ExceptionUtilities.UnexpectedValue(syntax.Kind()),
            };
        }

        private ImmutableArray<Symbol> BindTypeCref(TypeCrefSyntax syntax, out Symbol? ambiguityWinner, BindingDiagnosticBag diagnostics)
        {
            NamespaceOrTypeSymbol namespaceOrTypeSymbol = BindNamespaceOrTypeSymbolInCref(syntax.Type);
            if (namespaceOrTypeSymbol.Kind == SymbolKind.ErrorType)
            {
                TypeCrefSyntax typeCrefSyntax = syntax.WithLeadingTrivia(null).WithTrailingTrivia(null);
                diagnostics.Add(ErrorCode.WRN_BadXMLRef, syntax.Location, typeCrefSyntax.ToFullString());
            }
            ambiguityWinner = null;
            return ImmutableArray.Create((Symbol)namespaceOrTypeSymbol);
        }

        private ImmutableArray<Symbol> BindQualifiedCref(QualifiedCrefSyntax syntax, out Symbol? ambiguityWinner, BindingDiagnosticBag diagnostics)
        {
            NamespaceOrTypeSymbol containerOpt = BindNamespaceOrTypeSymbolInCref(syntax.Container);
            return BindMemberCref(syntax.Member, containerOpt, out ambiguityWinner, diagnostics);
        }

        private NamespaceOrTypeSymbol BindNamespaceOrTypeSymbolInCref(TypeSyntax syntax)
        {
            return BindNamespaceOrTypeSymbol(syntax, BindingDiagnosticBag.Discarded).NamespaceOrTypeSymbol;
        }

        private ImmutableArray<Symbol> BindMemberCref(MemberCrefSyntax syntax, NamespaceOrTypeSymbol? containerOpt, out Symbol? ambiguityWinner, BindingDiagnosticBag diagnostics)
        {
            if ((object)containerOpt != null && containerOpt!.Kind == SymbolKind.TypeParameter)
            {
                CrefSyntax rootCrefSyntax = GetRootCrefSyntax(syntax);
                MemberCrefSyntax memberCrefSyntax = syntax.WithLeadingTrivia(null).WithTrailingTrivia(null);
                diagnostics.Add(ErrorCode.WRN_BadXMLRef, rootCrefSyntax.Location, memberCrefSyntax.ToFullString());
                ambiguityWinner = null;
                return ImmutableArray<Symbol>.Empty;
            }
            ImmutableArray<Symbol> immutableArray = syntax.Kind() switch
            {
                SyntaxKind.NameMemberCref => BindNameMemberCref((NameMemberCrefSyntax)syntax, containerOpt, out ambiguityWinner, diagnostics),
                SyntaxKind.IndexerMemberCref => BindIndexerMemberCref((IndexerMemberCrefSyntax)syntax, containerOpt, out ambiguityWinner, diagnostics),
                SyntaxKind.OperatorMemberCref => BindOperatorMemberCref((OperatorMemberCrefSyntax)syntax, containerOpt, out ambiguityWinner, diagnostics),
                SyntaxKind.ConversionOperatorMemberCref => BindConversionOperatorMemberCref((ConversionOperatorMemberCrefSyntax)syntax, containerOpt, out ambiguityWinner, diagnostics),
                _ => throw ExceptionUtilities.UnexpectedValue(syntax.Kind()),
            };
            if (!immutableArray.Any())
            {
                CrefSyntax rootCrefSyntax2 = GetRootCrefSyntax(syntax);
                MemberCrefSyntax memberCrefSyntax2 = syntax.WithLeadingTrivia(null).WithTrailingTrivia(null);
                diagnostics.Add(ErrorCode.WRN_BadXMLRef, rootCrefSyntax2.Location, memberCrefSyntax2.ToFullString());
            }
            return immutableArray;
        }

        private ImmutableArray<Symbol> BindNameMemberCref(NameMemberCrefSyntax syntax, NamespaceOrTypeSymbol? containerOpt, out Symbol? ambiguityWinner, BindingDiagnosticBag diagnostics)
        {
            SimpleNameSyntax simpleNameSyntax = syntax.Name as SimpleNameSyntax;
            int num;
            string text;
            if (simpleNameSyntax != null)
            {
                num = simpleNameSyntax.Arity;
                text = simpleNameSyntax.Identifier.ValueText;
            }
            else
            {
                containerOpt = BindNamespaceOrTypeSymbolInCref(syntax.Name);
                num = 0;
                text = ".ctor";
            }
            if (string.IsNullOrEmpty(text))
            {
                ambiguityWinner = null;
                return ImmutableArray<Symbol>.Empty;
            }
            ImmutableArray<Symbol> symbols = ComputeSortedCrefMembers(syntax, containerOpt, text, num, syntax.Parameters != null, diagnostics);
            if (symbols.IsEmpty)
            {
                ambiguityWinner = null;
                return ImmutableArray<Symbol>.Empty;
            }
            return ProcessCrefMemberLookupResults(symbols, num, syntax, (num == 0) ? null : ((GenericNameSyntax)simpleNameSyntax).TypeArgumentList, syntax.Parameters, out ambiguityWinner, diagnostics);
        }

        private ImmutableArray<Symbol> BindIndexerMemberCref(IndexerMemberCrefSyntax syntax, NamespaceOrTypeSymbol? containerOpt, out Symbol? ambiguityWinner, BindingDiagnosticBag diagnostics)
        {
            ImmutableArray<Symbol> symbols = ComputeSortedCrefMembers(syntax, containerOpt, "this[]", 0, syntax.Parameters != null, diagnostics);
            if (symbols.IsEmpty)
            {
                ambiguityWinner = null;
                return ImmutableArray<Symbol>.Empty;
            }
            return ProcessCrefMemberLookupResults(symbols, 0, syntax, null, syntax.Parameters, out ambiguityWinner, diagnostics);
        }

        private ImmutableArray<Symbol> BindOperatorMemberCref(OperatorMemberCrefSyntax syntax, NamespaceOrTypeSymbol? containerOpt, out Symbol? ambiguityWinner, BindingDiagnosticBag diagnostics)
        {
            CrefParameterListSyntax parameters = syntax.Parameters;
            SyntaxKind kind = syntax.OperatorToken.Kind();
            string text = ((parameters != null && parameters.Parameters.Count == 1) ? null : OperatorFacts.BinaryOperatorNameFromSyntaxKindIfAny(kind));
            text ??= OperatorFacts.UnaryOperatorNameFromSyntaxKindIfAny(kind);
            if (text == null)
            {
                ambiguityWinner = null;
                return ImmutableArray<Symbol>.Empty;
            }
            ImmutableArray<Symbol> symbols = ComputeSortedCrefMembers(syntax, containerOpt, text, 0, syntax.Parameters != null, diagnostics);
            if (symbols.IsEmpty)
            {
                ambiguityWinner = null;
                return ImmutableArray<Symbol>.Empty;
            }
            return ProcessCrefMemberLookupResults(symbols, 0, syntax, null, parameters, out ambiguityWinner, diagnostics);
        }

        private ImmutableArray<Symbol> BindConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax syntax, NamespaceOrTypeSymbol? containerOpt, out Symbol? ambiguityWinner, BindingDiagnosticBag diagnostics)
        {
            string memberName = ((syntax.ImplicitOrExplicitKeyword.Kind() == SyntaxKind.ImplicitKeyword) ? "op_Implicit" : "op_Explicit");
            ImmutableArray<Symbol> array = ComputeSortedCrefMembers(syntax, containerOpt, memberName, 0, syntax.Parameters != null, diagnostics);
            if (array.IsEmpty)
            {
                ambiguityWinner = null;
                return ImmutableArray<Symbol>.Empty;
            }
            TypeSymbol arg = BindCrefParameterOrReturnType(syntax.Type, syntax, diagnostics);
            array = array.WhereAsArray((Symbol symbol, TypeSymbol returnType) => symbol.Kind != SymbolKind.Method || TypeSymbol.Equals(((MethodSymbol)symbol).ReturnType, returnType, TypeCompareKind.ConsiderEverything), arg);
            if (!array.Any())
            {
                ambiguityWinner = null;
                return ImmutableArray<Symbol>.Empty;
            }
            return ProcessCrefMemberLookupResults(array, 0, syntax, null, syntax.Parameters, out ambiguityWinner, diagnostics);
        }

        private ImmutableArray<Symbol> ComputeSortedCrefMembers(CSharpSyntaxNode syntax, NamespaceOrTypeSymbol? containerOpt, string memberName, int arity, bool hasParameterList, BindingDiagnosticBag diagnostics)
        {
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            ImmutableArray<Symbol> result = ComputeSortedCrefMembers(containerOpt, memberName, arity, hasParameterList, ref useSiteInfo);
            diagnostics.Add(syntax, useSiteInfo);
            return result;
        }

        private ImmutableArray<Symbol> ComputeSortedCrefMembers(NamespaceOrTypeSymbol? containerOpt, string memberName, int arity, bool hasParameterList, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            LookupResult instance = LookupResult.GetInstance();
            LookupSymbolsOrMembersInternal(instance, containerOpt, memberName, arity, null, LookupOptions.AllMethodsOnArityZero, diagnose: false, ref useSiteInfo);
            ArrayBuilder<Symbol> instance2;
            if (instance.IsMultiViable)
            {
                instance2 = ArrayBuilder<Symbol>.GetInstance();
                instance2.AddRange(instance.Symbols);
                instance.Free();
            }
            else
            {
                instance.Free();
                NamedTypeSymbol namedTypeSymbol = null;
                if (arity == 0)
                {
                    if (containerOpt is NamedTypeSymbol namedTypeSymbol2)
                    {
                        if (namedTypeSymbol2.Name == memberName && (hasParameterList || namedTypeSymbol2.Arity == 0 || !TypeSymbol.Equals(ContainingType, namedTypeSymbol2.OriginalDefinition, TypeCompareKind.ConsiderEverything)))
                        {
                            namedTypeSymbol = namedTypeSymbol2;
                        }
                    }
                    else if ((object)containerOpt == null && hasParameterList)
                    {
                        NamedTypeSymbol containingType = ContainingType;
                        if ((object)containingType != null && memberName == containingType.Name)
                        {
                            namedTypeSymbol = containingType;
                        }
                    }
                }
                if ((object)namedTypeSymbol == null)
                {
                    return ImmutableArray<Symbol>.Empty;
                }
                ImmutableArray<MethodSymbol> instanceConstructors = namedTypeSymbol.InstanceConstructors;
                int length = instanceConstructors.Length;
                if (length == 0)
                {
                    return ImmutableArray<Symbol>.Empty;
                }
                instance2 = ArrayBuilder<Symbol>.GetInstance(length);
                instance2.AddRange(instanceConstructors);
            }
            if (instance2.Count > 1)
            {
                instance2.Sort(ConsistentSymbolOrder.Instance);
            }
            return instance2.ToImmutableAndFree();
        }

        private ImmutableArray<Symbol> ProcessCrefMemberLookupResults(ImmutableArray<Symbol> symbols, int arity, MemberCrefSyntax memberSyntax, TypeArgumentListSyntax? typeArgumentListSyntax, BaseCrefParameterListSyntax? parameterListSyntax, out Symbol? ambiguityWinner, BindingDiagnosticBag diagnostics)
        {
            if (parameterListSyntax == null)
            {
                return ProcessParameterlessCrefMemberLookupResults(symbols, arity, memberSyntax, typeArgumentListSyntax, out ambiguityWinner, diagnostics);
            }
            ArrayBuilder<Symbol> instance = ArrayBuilder<Symbol>.GetInstance();
            GetCrefOverloadResolutionCandidates(symbols, arity, typeArgumentListSyntax, instance);
            ImmutableArray<ParameterSymbol> parameterSymbols = BindCrefParameters(parameterListSyntax, diagnostics);
            ImmutableArray<Symbol> result = PerformCrefOverloadResolution(instance, parameterSymbols, arity, memberSyntax, out ambiguityWinner, diagnostics);
            instance.Free();
            if (result.Length == 0)
            {
                for (int i = 0; i < parameterSymbols.Length; i++)
                {
                    if (ContainsNestedTypeOfUnconstructedGenericType(parameterSymbols[i].Type))
                    {
                        diagnostics.Add(ErrorCode.WRN_UnqualifiedNestedTypeInCref, parameterListSyntax!.Parameters[i].Location);
                        break;
                    }
                }
            }
            return result;
        }

        private static bool ContainsNestedTypeOfUnconstructedGenericType(TypeSymbol type)
        {
            switch (type.TypeKind)
            {
                case TypeKind.Array:
                    return ContainsNestedTypeOfUnconstructedGenericType(((ArrayTypeSymbol)type).ElementType);
                case TypeKind.Pointer:
                    return ContainsNestedTypeOfUnconstructedGenericType(((PointerTypeSymbol)type).PointedAtType);
                case TypeKind.FunctionPointer:
                    {
                        MethodSymbol signature = ((FunctionPointerTypeSymbol)type).Signature;
                        if (ContainsNestedTypeOfUnconstructedGenericType(signature.ReturnType))
                        {
                            return true;
                        }
                        ImmutableArray<ParameterSymbol>.Enumerator enumerator2 = signature.Parameters.GetEnumerator();
                        while (enumerator2.MoveNext())
                        {
                            if (ContainsNestedTypeOfUnconstructedGenericType(enumerator2.Current.Type))
                            {
                                return true;
                            }
                        }
                        return false;
                    }
                case TypeKind.Class:
                case TypeKind.Delegate:
                case TypeKind.Enum:
                case TypeKind.Error:
                case TypeKind.Interface:
                case TypeKind.Struct:
                    {
                        NamedTypeSymbol namedTypeSymbol = (NamedTypeSymbol)type;
                        if (IsNestedTypeOfUnconstructedGenericType(namedTypeSymbol))
                        {
                            return true;
                        }
                        ImmutableArray<TypeWithAnnotations>.Enumerator enumerator = namedTypeSymbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.GetEnumerator();
                        while (enumerator.MoveNext())
                        {
                            if (ContainsNestedTypeOfUnconstructedGenericType(enumerator.Current.Type))
                            {
                                return true;
                            }
                        }
                        return false;
                    }
                case TypeKind.Dynamic:
                case TypeKind.TypeParameter:
                    return false;
                default:
                    throw ExceptionUtilities.UnexpectedValue(type.TypeKind);
            }
        }

        private static bool IsNestedTypeOfUnconstructedGenericType(NamedTypeSymbol type)
        {
            NamedTypeSymbol containingType = type.ContainingType;
            while ((object)containingType != null)
            {
                if (containingType.Arity > 0 && containingType.IsDefinition)
                {
                    return true;
                }
                containingType = containingType.ContainingType;
            }
            return false;
        }

        private ImmutableArray<Symbol> ProcessParameterlessCrefMemberLookupResults(ImmutableArray<Symbol> symbols, int arity, MemberCrefSyntax memberSyntax, TypeArgumentListSyntax? typeArgumentListSyntax, out Symbol? ambiguityWinner, BindingDiagnosticBag diagnostics)
        {
            TypeArgumentListSyntax typeArgumentListSyntax2 = typeArgumentListSyntax;
            if (symbols.Length > 1 && arity == 0)
            {
                bool flag = false;
                bool flag2 = false;
                ImmutableArray<Symbol>.Enumerator enumerator = symbols.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    Symbol current = enumerator.Current;
                    if (current.Kind == SymbolKind.Method)
                    {
                        if (((MethodSymbol)current).Arity == 0)
                        {
                            flag = true;
                        }
                        else
                        {
                            flag2 = true;
                        }
                        if (flag2 && flag)
                        {
                            break;
                        }
                    }
                }
                if (flag && flag2)
                {
                    symbols = symbols.WhereAsArray((Symbol s) => s.Kind != SymbolKind.Method || ((MethodSymbol)s).Arity == 0);
                }
            }
            Symbol symbol = symbols[0];
            if (symbols.Length > 1)
            {
                ArrayBuilder<Symbol> instance = ArrayBuilder<Symbol>.GetInstance(symbols.Length);
                ImmutableArray<Symbol>.Enumerator enumerator = symbols.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    Symbol current2 = enumerator.Current;
                    instance.Add(UnwrapAliasNoDiagnostics(current2));
                }
                BestSymbolInfo bestSymbolInfo = GetBestSymbolInfo(instance, out BestSymbolInfo secondBest);
                instance.Free();
                int num = 0;
                if (bestSymbolInfo.IsFromCompilation)
                {
                    num = bestSymbolInfo.Index;
                    symbol = symbols[num];
                }
                if (symbol.Kind == SymbolKind.TypeParameter)
                {
                    CrefSyntax rootCrefSyntax = GetRootCrefSyntax(memberSyntax);
                    diagnostics.Add(ErrorCode.WRN_BadXMLRefTypeVar, rootCrefSyntax.Location, rootCrefSyntax.ToString());
                }
                else if (secondBest.IsFromCompilation == bestSymbolInfo.IsFromCompilation)
                {
                    CrefSyntax rootCrefSyntax2 = GetRootCrefSyntax(memberSyntax);
                    int index = ((num == 0) ? 1 : 0);
                    diagnostics.Add(ErrorCode.WRN_AmbiguousXMLReference, rootCrefSyntax2.Location, rootCrefSyntax2.ToString(), symbol, symbols[index]);
                    ambiguityWinner = ConstructWithCrefTypeParameters(arity, typeArgumentListSyntax2, symbol);
                    return symbols.SelectAsArray((Symbol sym) => ConstructWithCrefTypeParameters(arity, typeArgumentListSyntax2, sym));
                }
            }
            else if (symbol.Kind == SymbolKind.TypeParameter)
            {
                CrefSyntax rootCrefSyntax3 = GetRootCrefSyntax(memberSyntax);
                diagnostics.Add(ErrorCode.WRN_BadXMLRefTypeVar, rootCrefSyntax3.Location, rootCrefSyntax3.ToString());
            }
            ambiguityWinner = null;
            return ImmutableArray.Create(ConstructWithCrefTypeParameters(arity, typeArgumentListSyntax2, symbol));
        }

        private void GetCrefOverloadResolutionCandidates(ImmutableArray<Symbol> symbols, int arity, TypeArgumentListSyntax? typeArgumentListSyntax, ArrayBuilder<Symbol> candidates)
        {
            ImmutableArray<Symbol>.Enumerator enumerator = symbols.GetEnumerator();
            while (enumerator.MoveNext())
            {
                Symbol current = enumerator.Current;
                Symbol symbol = ConstructWithCrefTypeParameters(arity, typeArgumentListSyntax, current);
                if (!(symbol is NamedTypeSymbol namedTypeSymbol))
                {
                    candidates.Add(symbol);
                }
                else
                {
                    candidates.AddRange(namedTypeSymbol.InstanceConstructors);
                }
            }
        }

        private static ImmutableArray<Symbol> PerformCrefOverloadResolution(ArrayBuilder<Symbol> candidates, ImmutableArray<ParameterSymbol> parameterSymbols, int arity, MemberCrefSyntax memberSyntax, out Symbol? ambiguityWinner, BindingDiagnosticBag diagnostics)
        {
            ArrayBuilder<Symbol> arrayBuilder = null;
            ArrayBuilder<Symbol>.Enumerator enumerator = candidates.GetEnumerator();
            while (enumerator.MoveNext())
            {
                Symbol current = enumerator.Current;
                SymbolKind kind = current.Kind;
                Symbol member;
                if (kind != SymbolKind.Method)
                {
                    if (kind == SymbolKind.NamedType)
                    {
                        throw ExceptionUtilities.UnexpectedValue(current.Kind);
                    }
                    if (kind != SymbolKind.Property)
                    {
                        continue;
                    }
                    member = new SignatureOnlyPropertySymbol(null, null, parameterSymbols, RefKind.None, default(TypeWithAnnotations), ImmutableArray<CustomModifier>.Empty, isStatic: false, ImmutableArray<PropertySymbol>.Empty);
                }
                else
                {
                    MethodSymbol methodSymbol = (MethodSymbol)current;
                    MethodKind methodKind = methodSymbol.MethodKind;
                    bool isVararg = methodSymbol.IsVararg;
                    int count = ((methodKind != MethodKind.Constructor) ? ((arity == 0) ? methodSymbol.Arity : arity) : 0);
                    member = new SignatureOnlyMethodSymbol(null, null, methodKind, typeParameters: IndexedTypeParameterSymbol.TakeSymbols(count), parameters: parameterSymbols, callingConvention: isVararg ? CallingConvention.ExtraArguments : CallingConvention.HasThis, refKind: RefKind.None, isInitOnly: false, returnType: default(TypeWithAnnotations), refCustomModifiers: ImmutableArray<CustomModifier>.Empty, explicitInterfaceImplementations: ImmutableArray<MethodSymbol>.Empty);
                }
                if (!MemberSignatureComparer.CrefComparer.Equals(member, current))
                {
                    continue;
                }
                if (arrayBuilder == null)
                {
                    arrayBuilder = ArrayBuilder<Symbol>.GetInstance();
                    arrayBuilder.Add(current);
                    continue;
                }
                bool flag = arrayBuilder[0].GetMemberArity() == 0;
                bool flag2 = current.GetMemberArity() == 0;
                if (!flag || flag2)
                {
                    if (!flag && flag2)
                    {
                        arrayBuilder.Clear();
                    }
                    arrayBuilder.Add(current);
                }
            }
            if (arrayBuilder == null)
            {
                ambiguityWinner = null;
                return ImmutableArray<Symbol>.Empty;
            }
            if (arrayBuilder.Count > 1)
            {
                ambiguityWinner = arrayBuilder[0];
                CrefSyntax rootCrefSyntax = GetRootCrefSyntax(memberSyntax);
                diagnostics.Add(ErrorCode.WRN_AmbiguousXMLReference, rootCrefSyntax.Location, rootCrefSyntax.ToString(), ambiguityWinner, arrayBuilder[1]);
            }
            else
            {
                ambiguityWinner = null;
            }
            return arrayBuilder.ToImmutableAndFree();
        }

        private Symbol ConstructWithCrefTypeParameters(int arity, TypeArgumentListSyntax? typeArgumentListSyntax, Symbol symbol)
        {
            if (arity > 0)
            {
                SeparatedSyntaxList<TypeSyntax> arguments = typeArgumentListSyntax!.Arguments;
                ArrayBuilder<TypeWithAnnotations> instance = ArrayBuilder<TypeWithAnnotations>.GetInstance(arity);
                BindingDiagnosticBag discarded = BindingDiagnosticBag.Discarded;
                for (int i = 0; i < arity; i++)
                {
                    TypeSyntax syntax = arguments[i];
                    TypeWithAnnotations item = BindType(syntax, discarded);
                    instance.Add(item);
                }
                symbol = ((symbol.Kind != SymbolKind.Method) ? ((NamedTypeSymbol)symbol).Construct(instance.ToImmutableAndFree()) : ((Symbol)((MethodSymbol)symbol).Construct(instance.ToImmutableAndFree())));
            }
            return symbol;
        }

        private ImmutableArray<ParameterSymbol> BindCrefParameters(BaseCrefParameterListSyntax parameterListSyntax, BindingDiagnosticBag diagnostics)
        {
            ArrayBuilder<ParameterSymbol> instance = ArrayBuilder<ParameterSymbol>.GetInstance(parameterListSyntax.Parameters.Count);
            SeparatedSyntaxList<CrefParameterSyntax>.Enumerator enumerator = parameterListSyntax.Parameters.GetEnumerator();
            while (enumerator.MoveNext())
            {
                CrefParameterSyntax current = enumerator.Current;
                RefKind refKind = current.RefKindKeyword.Kind().GetRefKind();
                TypeSymbol typeSymbol = BindCrefParameterOrReturnType(current.Type, (MemberCrefSyntax)parameterListSyntax.Parent, diagnostics);
                instance.Add(new SignatureOnlyParameterSymbol(TypeWithAnnotations.Create(typeSymbol), ImmutableArray<CustomModifier>.Empty, isParams: false, refKind));
            }
            return instance.ToImmutableAndFree();
        }

        private TypeSymbol BindCrefParameterOrReturnType(TypeSyntax typeSyntax, MemberCrefSyntax memberCrefSyntax, BindingDiagnosticBag diagnostics)
        {
            Binder binder = WithAdditionalFlags(BinderFlags.CrefParameterOrReturnType);
            BindingDiagnosticBag bindingDiagnosticBag = new BindingDiagnosticBag(DiagnosticBag.GetInstance(), diagnostics.DependenciesBag);
            TypeSymbol type = binder.BindType(typeSyntax, bindingDiagnosticBag).Type;
            if (bindingDiagnosticBag.HasAnyErrors() && HasNonObsoleteError(bindingDiagnosticBag.DiagnosticBag))
            {
                ErrorCode code = ((typeSyntax.Parent!.Kind() == SyntaxKind.ConversionOperatorMemberCref) ? ErrorCode.WRN_BadXMLRefReturnType : ErrorCode.WRN_BadXMLRefParamType);
                CrefSyntax rootCrefSyntax = GetRootCrefSyntax(memberCrefSyntax);
                diagnostics.Add(code, typeSyntax.Location, typeSyntax.ToString(), rootCrefSyntax.ToString());
            }
            bindingDiagnosticBag.DiagnosticBag!.Free();
            return type;
        }

        private static bool HasNonObsoleteError(DiagnosticBag unusedDiagnostics)
        {
            foreach (Diagnostic item in unusedDiagnostics.AsEnumerable())
            {
                ErrorCode code = (ErrorCode)item.Code;
                if (code != ErrorCode.ERR_DeprecatedSymbolStr && code != ErrorCode.ERR_DeprecatedCollectionInitAddStr && item.Severity == DiagnosticSeverity.Error)
                {
                    return true;
                }
            }
            return false;
        }

        private static CrefSyntax GetRootCrefSyntax(MemberCrefSyntax syntax)
        {
            SyntaxNode parent = syntax.Parent;
            if (parent != null && !parent.IsKind(SyntaxKind.XmlCrefAttribute))
            {
                return (CrefSyntax)parent;
            }
            return syntax;
        }

        internal BoundExpression BindDeconstruction(AssignmentExpressionSyntax node, BindingDiagnosticBag diagnostics, bool resultIsUsedOverride = false)
        {
            ExpressionSyntax left = node.Left;
            ExpressionSyntax right = node.Right;
            DeclarationExpressionSyntax declaration = null;
            ExpressionSyntax expression = null;
            BoundDeconstructionAssignmentOperator result = BindDeconstruction(node, left, right, diagnostics, ref declaration, ref expression, resultIsUsedOverride);
            if (declaration != null)
            {
                switch (node.Parent?.Kind())
                {
                    case null:
                    case SyntaxKind.ExpressionStatement:
                        if (expression != null)
                        {
                            MessageID.IDS_FeatureMixedDeclarationsAndExpressionsInDeconstruction.CheckFeatureAvailability(diagnostics, Compilation, node.Location);
                        }
                        break;
                    case SyntaxKind.ForStatement:
                        if (((ForStatementSyntax)node.Parent).Initializers.Contains(node))
                        {
                            if (expression != null)
                            {
                                MessageID.IDS_FeatureMixedDeclarationsAndExpressionsInDeconstruction.CheckFeatureAvailability(diagnostics, Compilation, node.Location);
                            }
                        }
                        else
                        {
                            Error(diagnostics, ErrorCode.ERR_DeclarationExpressionNotPermitted, declaration);
                        }
                        break;
                    default:
                        Error(diagnostics, ErrorCode.ERR_DeclarationExpressionNotPermitted, declaration);
                        break;
                }
            }
            return result;
        }

        internal BoundDeconstructionAssignmentOperator BindDeconstruction(CSharpSyntaxNode deconstruction, ExpressionSyntax left, ExpressionSyntax right, BindingDiagnosticBag diagnostics, ref DeclarationExpressionSyntax? declaration, ref ExpressionSyntax? expression, bool resultIsUsedOverride = false, BoundDeconstructValuePlaceholder? rightPlaceholder = null)
        {
            DeconstructionVariable deconstructionVariable = BindDeconstructionVariables(left, diagnostics, ref declaration, ref expression);
            BindingDiagnosticBag bindingDiagnosticBag = new BindingDiagnosticBag(new DiagnosticBag(), diagnostics.DependenciesBag);
            BoundExpression boundRHS = rightPlaceholder ?? BindValue(right, bindingDiagnosticBag, BindValueKind.RValue);
            boundRHS = FixTupleLiteral(deconstructionVariable.NestedVariables, boundRHS, deconstruction, bindingDiagnosticBag);
            boundRHS = BindToNaturalType(boundRHS, diagnostics);
            bool resultIsUsed = resultIsUsedOverride || IsDeconstructionResultUsed(left);
            BoundDeconstructionAssignmentOperator result = BindDeconstructionAssignment(deconstruction, left, boundRHS, deconstructionVariable.NestedVariables, resultIsUsed, bindingDiagnosticBag);
            DeconstructionVariable.FreeDeconstructionVariables(deconstructionVariable.NestedVariables);
            diagnostics.AddRange(bindingDiagnosticBag.DiagnosticBag);
            return result;
        }

        private BoundDeconstructionAssignmentOperator BindDeconstructionAssignment(CSharpSyntaxNode node, ExpressionSyntax left, BoundExpression boundRHS, ArrayBuilder<DeconstructionVariable> checkedVariables, bool resultIsUsed, BindingDiagnosticBag diagnostics)
        {
            uint valEscape = GetValEscape(boundRHS, LocalScopeDepth);
            if ((object)boundRHS.Type == null || boundRHS.Type.IsErrorType())
            {
                FailRemainingInferencesAndSetValEscape(checkedVariables, diagnostics, valEscape);
                NamedTypeSymbol specialType = GetSpecialType(SpecialType.System_Void, diagnostics, node);
                TypeSymbol type = boundRHS.Type ?? specialType;
                return new BoundDeconstructionAssignmentOperator(node, DeconstructionVariablesAsTuple(left, checkedVariables, diagnostics, ignoreDiagnosticsFromTuple: true), new BoundConversion(boundRHS.Syntax, boundRHS, Conversion.Deconstruction, @checked: false, explicitCastInCode: false, null, null, type, hasErrors: true), resultIsUsed, specialType, hasErrors: true);
            }
            bool flag = !MakeDeconstructionConversion(boundRHS.Type, node, boundRHS.Syntax, diagnostics, checkedVariables, out Conversion conversion);
            if (conversion.Method != null)
            {
                CheckImplicitThisCopyInReadOnlyMember(boundRHS, conversion.Method, diagnostics);
            }
            FailRemainingInferencesAndSetValEscape(checkedVariables, diagnostics, valEscape);
            BoundTupleExpression boundTupleExpression = DeconstructionVariablesAsTuple(left, checkedVariables, diagnostics, diagnostics.HasAnyErrors() || !resultIsUsed);
            TypeSymbol type2 = (flag ? CreateErrorType() : boundTupleExpression.Type);
            uint broadestValEscape = GetBroadestValEscape(boundTupleExpression, LocalScopeDepth);
            boundRHS = ValidateEscape(boundRHS, broadestValEscape, isByRef: false, diagnostics);
            BoundConversion right = new BoundConversion(boundRHS.Syntax, boundRHS, conversion, @checked: false, explicitCastInCode: false, null, null, type2, flag)
            {
                WasCompilerGenerated = true
            };
            return new BoundDeconstructionAssignmentOperator(node, boundTupleExpression, right, resultIsUsed, type2);
        }

        private static bool IsDeconstructionResultUsed(ExpressionSyntax left)
        {
            CSharpSyntaxNode parent = left.Parent;
            if (parent == null || parent.Kind() == SyntaxKind.ForEachVariableStatement)
            {
                return false;
            }
            CSharpSyntaxNode parent2 = parent.Parent;
            if (parent2 == null)
            {
                return false;
            }
            switch (parent2.Kind())
            {
                case SyntaxKind.ExpressionStatement:
                    return ((ExpressionStatementSyntax)parent2).Expression != parent;
                case SyntaxKind.ForStatement:
                    {
                        ForStatementSyntax forStatementSyntax = (ForStatementSyntax)parent2;
                        if (!forStatementSyntax.Incrementors.Contains(parent))
                        {
                            return !forStatementSyntax.Initializers.Contains(parent);
                        }
                        return false;
                    }
                default:
                    return true;
            }
        }

        private BoundExpression FixTupleLiteral(ArrayBuilder<DeconstructionVariable> checkedVariables, BoundExpression boundRHS, CSharpSyntaxNode syntax, BindingDiagnosticBag diagnostics)
        {
            if (boundRHS.Kind == BoundKind.TupleLiteral)
            {
                bool flag = diagnostics.HasAnyErrors();
                TypeSymbol typeSymbol = MakeMergedTupleType(checkedVariables, (BoundTupleLiteral)boundRHS, syntax, flag ? null : diagnostics);
                if ((object)typeSymbol != null)
                {
                    boundRHS = GenerateConversionForAssignment(typeSymbol, boundRHS, diagnostics);
                }
            }
            else if ((object)boundRHS.Type == null)
            {
                Error(diagnostics, ErrorCode.ERR_DeconstructRequiresExpression, boundRHS.Syntax);
            }
            return boundRHS;
        }

        private bool MakeDeconstructionConversion(TypeSymbol type, SyntaxNode syntax, SyntaxNode rightSyntax, BindingDiagnosticBag diagnostics, ArrayBuilder<DeconstructionVariable> variables, out Conversion conversion)
        {
            conversion = Conversion.Deconstruction;
            DeconstructMethodInfo deconstructMethodInfo = default(DeconstructMethodInfo);
            ImmutableArray<TypeSymbol> foundTypes;
            if (type.IsTupleType)
            {
                foundTypes = type.TupleElementTypesWithAnnotations.SelectAsArray(TypeMap.AsTypeSymbol);
                SetInferredTypes(variables, foundTypes, diagnostics);
                if (variables.Count != foundTypes.Length)
                {
                    Error(diagnostics, ErrorCode.ERR_DeconstructWrongCardinality, syntax, foundTypes.Length, variables.Count);
                    return false;
                }
            }
            else
            {
                if (variables.Count < 2)
                {
                    Error(diagnostics, ErrorCode.ERR_DeconstructTooFewElements, syntax);
                    return false;
                }
                BoundDeconstructValuePlaceholder boundDeconstructValuePlaceholder = new BoundDeconstructValuePlaceholder(syntax, LocalScopeDepth, type);
                BoundExpression boundExpression = MakeDeconstructInvocationExpression(variables.Count, boundDeconstructValuePlaceholder, rightSyntax, diagnostics, out ImmutableArray<BoundDeconstructValuePlaceholder> outPlaceholders, out bool anyApplicableCandidates);
                if (boundExpression.HasAnyErrors)
                {
                    return false;
                }
                deconstructMethodInfo = new DeconstructMethodInfo(boundExpression, boundDeconstructValuePlaceholder, outPlaceholders);
                foundTypes = outPlaceholders.SelectAsArray((BoundDeconstructValuePlaceholder p) => p.Type);
                SetInferredTypes(variables, foundTypes, diagnostics);
            }
            bool flag = false;
            int count = variables.Count;
            ArrayBuilder<Conversion> instance = ArrayBuilder<Conversion>.GetInstance(count);
            for (int i = 0; i < count; i++)
            {
                DeconstructionVariable deconstructionVariable = variables[i];
                Conversion conversion2;
                if (deconstructionVariable.NestedVariables != null)
                {
                    SyntaxNode syntax2 = ((syntax.Kind() == SyntaxKind.TupleExpression) ? ((TupleExpressionSyntax)syntax).Arguments[i] : syntax);
                    flag |= !MakeDeconstructionConversion(foundTypes[i], syntax2, rightSyntax, diagnostics, deconstructionVariable.NestedVariables, out conversion2);
                }
                else
                {
                    BoundExpression single = deconstructionVariable.Single;
                    CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                    conversion2 = Conversions.ClassifyConversionFromType(foundTypes[i], single.Type, ref useSiteInfo);
                    diagnostics.Add(single.Syntax, useSiteInfo);
                    if (!conversion2.IsImplicit)
                    {
                        flag = true;
                        GenerateImplicitConversionError(diagnostics, Compilation, single.Syntax, conversion2, foundTypes[i], single.Type);
                    }
                }
                instance.Add(conversion2);
            }
            conversion = new Conversion(ConversionKind.Deconstruction, deconstructMethodInfo, instance.ToImmutableAndFree());
            return !flag;
        }

        private void SetInferredTypes(ArrayBuilder<DeconstructionVariable> variables, ImmutableArray<TypeSymbol> foundTypes, BindingDiagnosticBag diagnostics)
        {
            int num = Math.Min(variables.Count, foundTypes.Length);
            for (int i = 0; i < num; i++)
            {
                DeconstructionVariable deconstructionVariable = variables[i];
                BoundExpression single = deconstructionVariable.Single;
                if (single != null && (object)single.Type == null)
                {
                    variables[i] = new DeconstructionVariable(SetInferredType(single, foundTypes[i], diagnostics), deconstructionVariable.Syntax);
                }
            }
        }

        private BoundExpression SetInferredType(BoundExpression expression, TypeSymbol type, BindingDiagnosticBag diagnostics)
        {
            return expression.Kind switch
            {
                BoundKind.DeconstructionVariablePendingInference => ((DeconstructionVariablePendingInference)expression).SetInferredTypeWithAnnotations(TypeWithAnnotations.Create(type), this, diagnostics),
                BoundKind.DiscardExpression => ((BoundDiscardExpression)expression).SetInferredTypeWithAnnotations(TypeWithAnnotations.Create(type)),
                _ => throw ExceptionUtilities.UnexpectedValue(expression.Kind),
            };
        }

        private void FailRemainingInferencesAndSetValEscape(ArrayBuilder<DeconstructionVariable> variables, BindingDiagnosticBag diagnostics, uint rhsValEscape)
        {
            int count = variables.Count;
            for (int i = 0; i < count; i++)
            {
                DeconstructionVariable deconstructionVariable = variables[i];
                if (deconstructionVariable.NestedVariables != null)
                {
                    FailRemainingInferencesAndSetValEscape(deconstructionVariable.NestedVariables, diagnostics, rhsValEscape);
                    continue;
                }
                switch (deconstructionVariable.Single!.Kind)
                {
                    case BoundKind.Local:
                        {
                            BoundLocal boundLocal = (BoundLocal)deconstructionVariable.Single;
                            if (boundLocal.DeclarationKind != 0)
                            {
                                ((SourceLocalSymbol)boundLocal.LocalSymbol).SetValEscape(rhsValEscape);
                            }
                            break;
                        }
                    case BoundKind.DeconstructionVariablePendingInference:
                        {
                            BoundExpression boundExpression = ((DeconstructionVariablePendingInference)deconstructionVariable.Single).FailInference(this, diagnostics);
                            variables[i] = new DeconstructionVariable(boundExpression, boundExpression.Syntax);
                            break;
                        }
                    case BoundKind.DiscardExpression:
                        {
                            BoundDiscardExpression boundDiscardExpression = (BoundDiscardExpression)deconstructionVariable.Single;
                            if ((object)boundDiscardExpression.Type == null)
                            {
                                Error(diagnostics, ErrorCode.ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable, boundDiscardExpression.Syntax, "_");
                                variables[i] = new DeconstructionVariable(boundDiscardExpression.FailInference(this, diagnostics), boundDiscardExpression.Syntax);
                            }
                            break;
                        }
                }
            }
        }

        private TypeSymbol? MakeMergedTupleType(ArrayBuilder<DeconstructionVariable> lhsVariables, BoundTupleLiteral rhsLiteral, CSharpSyntaxNode syntax, BindingDiagnosticBag? diagnostics)
        {
            int count = lhsVariables.Count;
            int length = rhsLiteral.Arguments.Length;
            ArrayBuilder<TypeWithAnnotations> instance = ArrayBuilder<TypeWithAnnotations>.GetInstance(count);
            ArrayBuilder<Location> instance2 = ArrayBuilder<Location>.GetInstance(count);
            for (int i = 0; i < length; i++)
            {
                BoundExpression boundExpression = rhsLiteral.Arguments[i];
                TypeSymbol typeSymbol = boundExpression.Type;
                if (i < count)
                {
                    DeconstructionVariable deconstructionVariable = lhsVariables[i];
                    if (deconstructionVariable.NestedVariables != null)
                    {
                        if (boundExpression.Kind == BoundKind.TupleLiteral)
                        {
                            typeSymbol = MakeMergedTupleType(deconstructionVariable.NestedVariables, (BoundTupleLiteral)boundExpression, syntax, diagnostics);
                        }
                        else if ((object)typeSymbol == null && diagnostics != null)
                        {
                            Error(diagnostics, ErrorCode.ERR_DeconstructRequiresExpression, boundExpression.Syntax);
                        }
                    }
                    else if ((object)deconstructionVariable.Single!.Type != null)
                    {
                        typeSymbol = deconstructionVariable.Single!.Type;
                    }
                }
                else if ((object)typeSymbol == null && diagnostics != null)
                {
                    Error(diagnostics, ErrorCode.ERR_DeconstructRequiresExpression, boundExpression.Syntax);
                }
                instance.Add(TypeWithAnnotations.Create(typeSymbol));
                instance2.Add(boundExpression.Syntax.Location);
            }
            if (instance.Any((TypeWithAnnotations t) => !t.HasType))
            {
                instance.Free();
                instance2.Free();
                return null;
            }
            return NamedTypeSymbol.CreateTuple(null, instance.ToImmutableAndFree(), instance2.ToImmutableAndFree(), default(ImmutableArray<string>), Compilation, shouldCheckConstraints: true, includeNullability: false, default(ImmutableArray<bool>), syntax, diagnostics);
        }

        private BoundTupleExpression DeconstructionVariablesAsTuple(CSharpSyntaxNode syntax, ArrayBuilder<DeconstructionVariable> variables, BindingDiagnosticBag diagnostics, bool ignoreDiagnosticsFromTuple)
        {
            int count = variables.Count;
            ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance(count);
            ArrayBuilder<TypeWithAnnotations> instance2 = ArrayBuilder<TypeWithAnnotations>.GetInstance(count);
            ArrayBuilder<Location> instance3 = ArrayBuilder<Location>.GetInstance(count);
            ArrayBuilder<string> inferredElementNames = ArrayBuilder<string>.GetInstance(count);
            ArrayBuilder<DeconstructionVariable>.Enumerator enumerator = variables.GetEnumerator();
            while (enumerator.MoveNext())
            {
                DeconstructionVariable current = enumerator.Current;
                BoundExpression boundExpression;
                if (current.NestedVariables != null)
                {
                    boundExpression = DeconstructionVariablesAsTuple(current.Syntax, current.NestedVariables, diagnostics, ignoreDiagnosticsFromTuple);
                    inferredElementNames.Add(null);
                }
                else
                {
                    boundExpression = current.Single;
                    inferredElementNames.Add(ExtractDeconstructResultElementName(boundExpression));
                }
                instance.Add(boundExpression);
                instance2.Add(TypeWithAnnotations.Create(boundExpression.Type));
                instance3.Add(current.Syntax.Location);
            }
            ImmutableArray<BoundExpression> arguments = instance.ToImmutableAndFree();
            PooledHashSet<string> instance4 = PooledHashSet<string>.GetInstance();
            RemoveDuplicateInferredTupleNamesAndFreeIfEmptied(ref inferredElementNames, instance4);
            instance4.Free();
            ImmutableArray<string> immutableArray = inferredElementNames?.ToImmutableAndFree() ?? default(ImmutableArray<string>);
            ImmutableArray<bool> immutableArray2 = (immutableArray.IsDefault ? default(ImmutableArray<bool>) : immutableArray.SelectAsArray((string n) => n != null));
            bool flag = Compilation.LanguageVersion.DisallowInferredTupleElementNames();
            NamedTypeSymbol type = NamedTypeSymbol.CreateTuple(syntax.Location, instance2.ToImmutableAndFree(), instance3.ToImmutableAndFree(), immutableArray, Compilation, !ignoreDiagnosticsFromTuple, includeNullability: false, flag ? immutableArray2 : default(ImmutableArray<bool>), syntax, ignoreDiagnosticsFromTuple ? null : diagnostics);
            return (BoundTupleExpression)BindToNaturalType(new BoundTupleLiteral(syntax, arguments, immutableArray, immutableArray2, type), diagnostics);
        }

        private static string? ExtractDeconstructResultElementName(BoundExpression expression)
        {
            if (expression.Kind == BoundKind.DiscardExpression)
            {
                return null;
            }
            return InferTupleElementName(expression.Syntax);
        }

        private BoundExpression MakeDeconstructInvocationExpression(int numCheckedVariables, BoundExpression receiver, SyntaxNode rightSyntax, BindingDiagnosticBag diagnostics, out ImmutableArray<BoundDeconstructValuePlaceholder> outPlaceholders, out bool anyApplicableCandidates)
        {
            anyApplicableCandidates = false;
            CSharpSyntaxNode cSharpSyntaxNode = (CSharpSyntaxNode)receiver.Syntax;
            TypeSymbol? type = receiver.Type;
            if ((object)type != null && type.IsDynamic())
            {
                Error(diagnostics, ErrorCode.ERR_CannotDeconstructDynamic, rightSyntax);
                outPlaceholders = default(ImmutableArray<BoundDeconstructValuePlaceholder>);
                return BadExpression(cSharpSyntaxNode, receiver);
            }
            receiver = BindToNaturalType(receiver, diagnostics);
            AnalyzedArguments instance = AnalyzedArguments.GetInstance();
            ArrayBuilder<OutDeconstructVarPendingInference> instance2 = ArrayBuilder<OutDeconstructVarPendingInference>.GetInstance(numCheckedVariables);
            try
            {
                for (int i = 0; i < numCheckedVariables; i++)
                {
                    OutDeconstructVarPendingInference item = new OutDeconstructVarPendingInference(cSharpSyntaxNode);
                    instance.Arguments.Add(item);
                    instance.RefKinds.Add(RefKind.Out);
                    instance2.Add(item);
                }
                BoundExpression expr = BindInstanceMemberAccess(rightSyntax, cSharpSyntaxNode, receiver, "Deconstruct", 0, default(SeparatedSyntaxList<TypeSyntax>), default(ImmutableArray<TypeWithAnnotations>), invoked: true, indexed: false, diagnostics);
                expr = CheckValue(expr, BindValueKind.RValueOrMethodGroup, diagnostics);
                expr.WasCompilerGenerated = true;
                if (expr.Kind != BoundKind.MethodGroup)
                {
                    return MissingDeconstruct(receiver, rightSyntax, numCheckedVariables, diagnostics, out outPlaceholders, receiver);
                }
                BoundExpression boundExpression = BindMethodGroupInvocation(rightSyntax, rightSyntax, "Deconstruct", (BoundMethodGroup)expr, instance, diagnostics, null, allowUnexpandedForm: true, out anyApplicableCandidates);
                boundExpression.WasCompilerGenerated = true;
                if (!anyApplicableCandidates)
                {
                    return MissingDeconstruct(receiver, rightSyntax, numCheckedVariables, diagnostics, out outPlaceholders, boundExpression);
                }
                MethodSymbol method = ((BoundCall)boundExpression).Method;
                ImmutableArray<ParameterSymbol> parameters = method.Parameters;
                for (int j = (method.IsExtensionMethod ? 1 : 0); j < parameters.Length; j++)
                {
                    if (parameters[j].RefKind != RefKind.Out)
                    {
                        return MissingDeconstruct(receiver, rightSyntax, numCheckedVariables, diagnostics, out outPlaceholders, boundExpression);
                    }
                }
                if (method.ReturnType.GetSpecialTypeSafe() != SpecialType.System_Void)
                {
                    return MissingDeconstruct(receiver, rightSyntax, numCheckedVariables, diagnostics, out outPlaceholders, boundExpression);
                }
                if (instance2.Any((OutDeconstructVarPendingInference v) => v.Placeholder == null))
                {
                    return MissingDeconstruct(receiver, rightSyntax, numCheckedVariables, diagnostics, out outPlaceholders, boundExpression);
                }
                outPlaceholders = instance2.SelectAsArray((OutDeconstructVarPendingInference v) => v.Placeholder);
                return boundExpression;
            }
            finally
            {
                instance.Free();
                instance2.Free();
            }
        }

        private BoundBadExpression MissingDeconstruct(BoundExpression receiver, SyntaxNode rightSyntax, int numParameters, BindingDiagnosticBag diagnostics, out ImmutableArray<BoundDeconstructValuePlaceholder> outPlaceholders, BoundExpression childNode)
        {
            TypeSymbol? type = receiver.Type;
            if ((object)type != null && !type.IsErrorType())
            {
                Error(diagnostics, ErrorCode.ERR_MissingDeconstruct, rightSyntax, receiver.Type, numParameters);
            }
            outPlaceholders = default(ImmutableArray<BoundDeconstructValuePlaceholder>);
            return BadExpression(rightSyntax, childNode);
        }

        private DeconstructionVariable BindDeconstructionVariables(ExpressionSyntax node, BindingDiagnosticBag diagnostics, ref DeclarationExpressionSyntax? declaration, ref ExpressionSyntax? expression)
        {
            switch (node.Kind())
            {
                case SyntaxKind.DeclarationExpression:
                    {
                        DeclarationExpressionSyntax declarationExpressionSyntax = (DeclarationExpressionSyntax)node;
                        if (declaration == null)
                        {
                            declaration = declarationExpressionSyntax;
                        }
                        bool isConst = false;
                        TypeWithAnnotations declTypeWithAnnotations = BindVariableTypeWithAnnotations(declarationExpressionSyntax.Designation, diagnostics, declarationExpressionSyntax.Type, ref isConst, out bool isVar, out AliasSymbol alias);
                        if (declarationExpressionSyntax.Designation.Kind() == SyntaxKind.ParenthesizedVariableDesignation && !isVar)
                        {
                            Error(diagnostics, ErrorCode.ERR_DeconstructionVarFormDisallowsSpecificType, declarationExpressionSyntax.Designation);
                        }
                        return BindDeconstructionVariables(declTypeWithAnnotations, declarationExpressionSyntax.Designation, declarationExpressionSyntax, diagnostics);
                    }
                case SyntaxKind.TupleExpression:
                    {
                        TupleExpressionSyntax obj = (TupleExpressionSyntax)node;
                        ArrayBuilder<DeconstructionVariable> instance = ArrayBuilder<DeconstructionVariable>.GetInstance(obj.Arguments.Count);
                        SeparatedSyntaxList<ArgumentSyntax>.Enumerator enumerator = obj.Arguments.GetEnumerator();
                        while (enumerator.MoveNext())
                        {
                            ArgumentSyntax current = enumerator.Current;
                            if (current.NameColon != null)
                            {
                                Error(diagnostics, ErrorCode.ERR_TupleElementNamesInDeconstruction, current.NameColon);
                            }
                            instance.Add(BindDeconstructionVariables(current.Expression, diagnostics, ref declaration, ref expression));
                        }
                        return new DeconstructionVariable(instance, node);
                    }
                default:
                    {
                        BoundExpression expr = BindExpression(node, diagnostics, invoked: false, indexed: false);
                        BoundExpression boundExpression = CheckValue(expr, BindValueKind.Assignable, diagnostics);
                        if (expression == null && boundExpression.Kind != BoundKind.DiscardExpression)
                        {
                            expression = node;
                        }
                        return new DeconstructionVariable(boundExpression, node);
                    }
            }
        }

        private DeconstructionVariable BindDeconstructionVariables(TypeWithAnnotations declTypeWithAnnotations, VariableDesignationSyntax node, CSharpSyntaxNode syntax, BindingDiagnosticBag diagnostics)
        {
            switch (node.Kind())
            {
                case SyntaxKind.SingleVariableDesignation:
                    {
                        SingleVariableDesignationSyntax designation = (SingleVariableDesignationSyntax)node;
                        return new DeconstructionVariable(BindDeconstructionVariable(declTypeWithAnnotations, designation, syntax, diagnostics), syntax);
                    }
                case SyntaxKind.DiscardDesignation:
                    _ = (DiscardDesignationSyntax)node;
                    return new DeconstructionVariable(BindDiscardExpression(syntax, declTypeWithAnnotations), syntax);
                case SyntaxKind.ParenthesizedVariableDesignation:
                    {
                        ParenthesizedVariableDesignationSyntax obj = (ParenthesizedVariableDesignationSyntax)node;
                        ArrayBuilder<DeconstructionVariable> instance = ArrayBuilder<DeconstructionVariable>.GetInstance();
                        SeparatedSyntaxList<VariableDesignationSyntax>.Enumerator enumerator = obj.Variables.GetEnumerator();
                        while (enumerator.MoveNext())
                        {
                            VariableDesignationSyntax current = enumerator.Current;
                            instance.Add(BindDeconstructionVariables(declTypeWithAnnotations, current, current, diagnostics));
                        }
                        return new DeconstructionVariable(instance, syntax);
                    }
                default:
                    throw ExceptionUtilities.UnexpectedValue(node.Kind());
            }
        }

        private static BoundDiscardExpression BindDiscardExpression(SyntaxNode syntax, TypeWithAnnotations declTypeWithAnnotations)
        {
            return new BoundDiscardExpression(syntax, declTypeWithAnnotations.Type);
        }

        private BoundExpression BindDeconstructionVariable(TypeWithAnnotations declTypeWithAnnotations, SingleVariableDesignationSyntax designation, CSharpSyntaxNode syntax, BindingDiagnosticBag diagnostics)
        {
            SourceLocalSymbol sourceLocalSymbol = LookupLocal(designation.Identifier);
            if ((object)sourceLocalSymbol != null)
            {
                bool hasErrors = sourceLocalSymbol.ScopeBinder.ValidateDeclarationNameConflictsInScope(sourceLocalSymbol, diagnostics);
                if (declTypeWithAnnotations.HasType)
                {
                    return new BoundLocal(syntax, sourceLocalSymbol, BoundLocalDeclarationKind.WithExplicitType, null, isNullableUnknown: false, declTypeWithAnnotations.Type, hasErrors);
                }
                return new DeconstructionVariablePendingInference(syntax, sourceLocalSymbol, null);
            }
            GlobalExpressionVariable globalExpressionVariable = LookupDeclaredField(designation);
            if ((object)globalExpressionVariable == null)
            {
                throw ExceptionUtilities.Unreachable;
            }
            BoundThisReference boundThisReference = ThisReference(designation, ContainingType, hasErrors: false, wasCompilerGenerated: true);
            if (declTypeWithAnnotations.HasType)
            {
                return new BoundFieldAccess(syntax, boundThisReference, globalExpressionVariable, null, LookupResultKind.Viable, isDeclaration: true, globalExpressionVariable.GetFieldType(FieldsBeingBound).Type);
            }
            return new DeconstructionVariablePendingInference(syntax, globalExpressionVariable, boundThisReference);
        }

        internal bool HasThis(bool isExplicit, out bool inStaticContext)
        {
            Symbol symbol = ContainingMemberOrLambda?.ContainingNonLambdaMember();
            if ((object)symbol != null && symbol.IsStatic)
            {
                inStaticContext = symbol.Kind == SymbolKind.Field || symbol.Kind == SymbolKind.Method || symbol.Kind == SymbolKind.Property;
                return false;
            }
            inStaticContext = false;
            if (InConstructorInitializer || InAttributeArgument)
            {
                return false;
            }
            bool flag = (symbol?.ContainingType)?.IsScriptClass ?? false;
            if (InFieldInitializer && !flag)
            {
                return false;
            }
            if (flag)
            {
                return !isExplicit;
            }
            return true;
        }

        protected virtual bool IsUnboundTypeAllowed(GenericNameSyntax syntax)
        {
            return Next!.IsUnboundTypeAllowed(syntax);
        }

        private BoundBadExpression BadExpression(SyntaxNode syntax)
        {
            return BadExpression(syntax, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty);
        }

        private BoundBadExpression BadExpression(SyntaxNode syntax, BoundExpression childNode)
        {
            return BadExpression(syntax, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, childNode);
        }

        private BoundBadExpression BadExpression(SyntaxNode syntax, ImmutableArray<BoundExpression> childNodes)
        {
            return BadExpression(syntax, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, childNodes);
        }

        protected BoundBadExpression BadExpression(SyntaxNode syntax, LookupResultKind lookupResultKind)
        {
            return BadExpression(syntax, lookupResultKind, ImmutableArray<Symbol>.Empty);
        }

        protected BoundBadExpression BadExpression(SyntaxNode syntax, LookupResultKind lookupResultKind, BoundExpression childNode)
        {
            return BadExpression(syntax, lookupResultKind, ImmutableArray<Symbol>.Empty, childNode);
        }

        private BoundBadExpression BadExpression(SyntaxNode syntax, LookupResultKind resultKind, ImmutableArray<Symbol> symbols)
        {
            return new BoundBadExpression(syntax, resultKind, symbols, ImmutableArray<BoundExpression>.Empty, CreateErrorType());
        }

        private BoundBadExpression BadExpression(SyntaxNode syntax, LookupResultKind resultKind, ImmutableArray<Symbol> symbols, BoundExpression childNode)
        {
            return new BoundBadExpression(syntax, resultKind, symbols, ImmutableArray.Create(BindToTypeForErrorRecovery(childNode)), CreateErrorType());
        }

        private BoundBadExpression BadExpression(SyntaxNode syntax, LookupResultKind resultKind, ImmutableArray<Symbol> symbols, ImmutableArray<BoundExpression> childNodes)
        {
            return new BoundBadExpression(syntax, resultKind, symbols, childNodes.SelectAsArray((BoundExpression e, Binder self) => self.BindToTypeForErrorRecovery(e), this), CreateErrorType());
        }

        private BoundExpression ToBadExpression(BoundExpression expr, LookupResultKind resultKind = LookupResultKind.Empty)
        {
            TypeSymbol type = expr.Type;
            BoundKind kind = expr.Kind;
            if (expr.HasAnyErrors && ((object)type != null || kind == BoundKind.UnboundLambda || kind == BoundKind.DefaultLiteral))
            {
                return expr;
            }
            if (kind == BoundKind.BadExpression)
            {
                BoundBadExpression boundBadExpression = (BoundBadExpression)expr;
                return boundBadExpression.Update(resultKind, boundBadExpression.Symbols, boundBadExpression.ChildBoundNodes, type);
            }
            ArrayBuilder<Symbol> instance = ArrayBuilder<Symbol>.GetInstance();
            expr.GetExpressionSymbols(instance, null, this);
            return new BoundBadExpression(expr.Syntax, resultKind, instance.ToImmutableAndFree(), ImmutableArray.Create(BindToTypeForErrorRecovery(expr)), type ?? CreateErrorType());
        }

        internal NamedTypeSymbol CreateErrorType(string name = "")
        {
            return new ExtendedErrorTypeSymbol(Compilation, name, 0, null);
        }

        internal BoundExpression BindValue(ExpressionSyntax node, BindingDiagnosticBag diagnostics, BindValueKind valueKind)
        {
            BoundExpression expr = BindExpression(node, diagnostics, invoked: false, indexed: false);
            return CheckValue(expr, valueKind, diagnostics);
        }

        internal BoundExpression BindRValueWithoutTargetType(ExpressionSyntax node, BindingDiagnosticBag diagnostics, bool reportNoTargetType = true)
        {
            return BindToNaturalType(BindValue(node, diagnostics, BindValueKind.RValue), diagnostics, reportNoTargetType);
        }

        internal BoundExpression BindTypeOrRValue(ExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            BoundExpression boundExpression = BindExpression(node, diagnostics, invoked: false, indexed: false);
            if (boundExpression.Kind == BoundKind.TypeExpression)
            {
                return boundExpression;
            }
            return CheckValue(boundExpression, BindValueKind.RValue, diagnostics);
        }

        internal BoundExpression BindToTypeForErrorRecovery(BoundExpression expression, TypeSymbol type = null)
        {
            if (expression == null)
            {
                return null;
            }
            if (expression.NeedsToBeConverted())
            {
                if ((object)type != null)
                {
                    return GenerateConversionForAssignment(type, expression, BindingDiagnosticBag.Discarded);
                }
                return BindToNaturalType(expression, BindingDiagnosticBag.Discarded, reportNoTargetType: false);
            }
            return expression;
        }

        /// <summary>
        /// Bind an rvalue expression to its natural type.  For example, a switch expression that has not been
        /// converted to another type has to be converted to its own natural type by applying a conversion to
        /// that type to each of the arms of the switch expression.  This method is a bottleneck for ensuring
        /// that such a conversion occurs when needed.  It also handles tuple expressions which need to be
        /// converted to their own natural type because they may contain switch expressions.
        /// </summary>
        internal BoundExpression BindToNaturalType(BoundExpression expression, BindingDiagnosticBag diagnostics, bool reportNoTargetType = true)
        {
            if (!expression.NeedsToBeConverted())
                return expression;

            BoundExpression result;
            switch (expression)
            {
                case BoundUnconvertedSwitchExpression expr:
                    {
                        var commonType = expr.Type;
                        var exprSyntax = (SwitchExpressionSyntax)expr.Syntax;
                        bool hasErrors = expression.HasErrors;
                        if (commonType is null)
                        {
                            diagnostics.Add(ErrorCode.ERR_SwitchExpressionNoBestType, exprSyntax.SwitchKeyword.GetLocation());
                            commonType = CreateErrorType();
                            hasErrors = true;
                        }
                        result = ConvertSwitchExpression(expr, commonType, conversionIfTargetTyped: null, diagnostics, hasErrors);
                    }
                    break;
                case BoundUnconvertedConditionalOperator op:
                    {
                        TypeSymbol type = op.Type;
                        bool hasErrors = op.HasErrors;
                        if (type is null)
                        {
                            Debug.Assert(op.NoCommonTypeError != 0);
                            type = CreateErrorType();
                            hasErrors = true;
                            object trueArg = op.Consequence.Display;
                            object falseArg = op.Alternative.Display;
                            if (op.NoCommonTypeError == ErrorCode.ERR_InvalidQM && trueArg is Symbol trueSymbol && falseArg is Symbol falseSymbol)
                            {
                                // ERR_InvalidQM is an error that there is no conversion between the two types. They might be the same
                                // type name from different assemblies, so we disambiguate the display.
                                SymbolDistinguisher distinguisher = new SymbolDistinguisher(this.Compilation, trueSymbol, falseSymbol);
                                trueArg = distinguisher.First;
                                falseArg = distinguisher.Second;
                            }

                            diagnostics.Add(op.NoCommonTypeError, op.Syntax.Location, trueArg, falseArg);
                        }

                        result = ConvertConditionalExpression(op, type, conversionIfTargetTyped: null, diagnostics, hasErrors);
                    }
                    break;
                case BoundTupleLiteral sourceTuple:
                    {
                        var boundArgs = ArrayBuilder<BoundExpression>.GetInstance(sourceTuple.Arguments.Length);
                        foreach (var arg in sourceTuple.Arguments)
                        {
                            boundArgs.Add(BindToNaturalType(arg, diagnostics, reportNoTargetType));
                        }
                        result = new BoundConvertedTupleLiteral(
                            sourceTuple.Syntax,
                            sourceTuple,
                            wasTargetTyped: false,
                            boundArgs.ToImmutableAndFree(),
                            sourceTuple.ArgumentNamesOpt,
                            sourceTuple.InferredNamesOpt,
                            sourceTuple.Type, // same type to keep original element names
                            sourceTuple.HasErrors).WithSuppression(sourceTuple.IsSuppressed);
                    }
                    break;
                case BoundDefaultLiteral defaultExpr:
                    {
                        if (reportNoTargetType)
                        {
                            // In some cases, we let the caller report the error
                            diagnostics.Add(ErrorCode.ERR_DefaultLiteralNoTargetType, defaultExpr.Syntax.GetLocation());
                        }

                        result = new BoundDefaultExpression(
                            defaultExpr.Syntax,
                            targetType: null,
                            defaultExpr.ConstantValue,
                            CreateErrorType(),
                            hasErrors: true).WithSuppression(defaultExpr.IsSuppressed);
                    }
                    break;
                case BoundStackAllocArrayCreation { Type: null } boundStackAlloc:
                    {
                        // This is a context in which the stackalloc could be either a pointer
                        // or a span.  For backward compatibility we treat it as a pointer.
                        var type = new PointerTypeSymbol(TypeWithAnnotations.Create(boundStackAlloc.ElementType));
                        result = GenerateConversionForAssignment(type, boundStackAlloc, diagnostics);
                    }
                    break;
                case BoundUnconvertedObjectCreationExpression expr:
                    {
                        if (reportNoTargetType && !expr.HasAnyErrors)
                        {
                            diagnostics.Add(ErrorCode.ERR_ImplicitObjectCreationNoTargetType, expr.Syntax.GetLocation(), expr.Display);
                        }

                        result = BindObjectCreationForErrorRecovery(expr, diagnostics);
                    }
                    break;
                case BoundUnconvertedInterpolatedString unconvertedInterpolatedString:
                    {
                        // We determine the best method of emitting as a string (either via Concat, Format, or the builder pattern)
                        // during lowering, and it's not part of the publicly-visible API, unlike conversion to a builder type.
                        result = new BoundInterpolatedString(
                            unconvertedInterpolatedString.Syntax,
                            unconvertedInterpolatedString.Parts,
                            unconvertedInterpolatedString.ConstantValue,
                            unconvertedInterpolatedString.Type,
                            unconvertedInterpolatedString.HasErrors);
                    }
                    break;
                default:
                    result = expression;
                    break;
            }

            return result?.WithWasConverted();
        }

        internal BoundExpression BindValueAllowArgList(ExpressionSyntax node, BindingDiagnosticBag diagnostics, BindValueKind valueKind)
        {
            BoundExpression expr = BindExpressionAllowArgList(node, diagnostics);
            return CheckValue(expr, valueKind, diagnostics);
        }

        internal BoundFieldEqualsValue BindFieldInitializer(FieldSymbol field, EqualsValueClauseSyntax initializerOpt, BindingDiagnosticBag diagnostics)
        {
            if (initializerOpt == null)
            {
                return null;
            }
            Binder binder = GetBinder(initializerOpt);
            BoundExpression value = binder.BindVariableOrAutoPropInitializerValue(initializerOpt, RefKind.None, field.GetFieldType(binder.FieldsBeingBound).Type, diagnostics);
            return new BoundFieldEqualsValue(initializerOpt, field, binder.GetDeclaredLocalsForScope(initializerOpt), value);
        }

        internal BoundExpression BindVariableOrAutoPropInitializerValue(EqualsValueClauseSyntax initializerOpt, RefKind refKind, TypeSymbol varType, BindingDiagnosticBag diagnostics)
        {
            if (initializerOpt == null)
            {
                return null;
            }
            IsInitializerRefKindValid(initializerOpt, initializerOpt, refKind, diagnostics, out var valueKind, out var value);
            BoundExpression expression = BindPossibleArrayInitializer(value, varType, valueKind, diagnostics);
            return GenerateConversionForAssignment(varType, expression, diagnostics);
        }

        internal Binder CreateBinderForParameterDefaultValue(ParameterSymbol parameter, EqualsValueClauseSyntax defaultValueSyntax)
        {
            LocalScopeBinder next = new LocalScopeBinder(WithContainingMemberOrLambda(parameter.ContainingSymbol).WithAdditionalFlags(BinderFlags.ParameterDefaultValue));
            return new ExecutableCodeBinder(defaultValueSyntax, parameter.ContainingSymbol, next);
        }

        internal BoundParameterEqualsValue BindParameterDefaultValue(EqualsValueClauseSyntax defaultValueSyntax, ParameterSymbol parameter, BindingDiagnosticBag diagnostics, out BoundExpression valueBeforeConversion)
        {
            Binder binder = GetBinder(defaultValueSyntax);
            valueBeforeConversion = binder.BindValue(defaultValueSyntax.Value, diagnostics, BindValueKind.RValue);
            return new BoundParameterEqualsValue(defaultValueSyntax, parameter, binder.GetDeclaredLocalsForScope(defaultValueSyntax), binder.GenerateConversionForAssignment(parameter.Type, valueBeforeConversion, diagnostics, isDefaultParameter: true));
        }

        internal BoundFieldEqualsValue BindEnumConstantInitializer(SourceEnumConstantSymbol symbol, EqualsValueClauseSyntax equalsValueSyntax, BindingDiagnosticBag diagnostics)
        {
            Binder binder = GetBinder(equalsValueSyntax);
            BoundExpression expression = binder.BindValue(equalsValueSyntax.Value, diagnostics, BindValueKind.RValue);
            expression = binder.GenerateConversionForAssignment(symbol.ContainingType.EnumUnderlyingType, expression, diagnostics);
            return new BoundFieldEqualsValue(equalsValueSyntax, symbol, binder.GetDeclaredLocalsForScope(equalsValueSyntax), expression);
        }

        public BoundExpression BindExpression(ExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            return BindExpression(node, diagnostics, invoked: false, indexed: false);
        }

        protected BoundExpression BindExpression(ExpressionSyntax node, BindingDiagnosticBag diagnostics, bool invoked, bool indexed)
        {
            BoundExpression boundExpression = BindExpressionInternal(node, diagnostics, invoked, indexed);
            VerifyUnchecked(node, diagnostics, boundExpression);
            if (boundExpression.Kind == BoundKind.ArgListOperator)
            {
                Error(diagnostics, ErrorCode.ERR_IllegalArglist, node);
                boundExpression = ToBadExpression(boundExpression);
            }
            return boundExpression;
        }

        protected BoundExpression BindExpressionAllowArgList(ExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            BoundExpression boundExpression = BindExpressionInternal(node, diagnostics, invoked: false, indexed: false);
            VerifyUnchecked(node, diagnostics, boundExpression);
            return boundExpression;
        }

        private void VerifyUnchecked(ExpressionSyntax node, BindingDiagnosticBag diagnostics, BoundExpression expr)
        {
            if (!expr.HasAnyErrors && !IsInsideNameof)
            {
                TypeSymbol type = expr.Type;
                if ((object)type != null && type.IsUnsafe())
                {
                    ReportUnsafeIfNotAllowed(node, diagnostics);
                }
            }
        }

        private BoundExpression BindExpressionInternal(ExpressionSyntax node, BindingDiagnosticBag diagnostics, bool invoked, bool indexed)
        {
            if (IsEarlyAttributeBinder && !EarlyWellKnownAttributeBinder.CanBeValidAttributeArgument(node, this))
            {
                return BadExpression(node, LookupResultKind.NotAValue);
            }
            switch (node.Kind())
            {
                case SyntaxKind.AnonymousMethodExpression:
                case SyntaxKind.SimpleLambdaExpression:
                case SyntaxKind.ParenthesizedLambdaExpression:
                    return BindAnonymousFunction((AnonymousFunctionExpressionSyntax)node, diagnostics);
                case SyntaxKind.ThisExpression:
                    return BindThis((ThisExpressionSyntax)node, diagnostics);
                case SyntaxKind.BaseExpression:
                    return BindBase((BaseExpressionSyntax)node, diagnostics);
                case SyntaxKind.InvocationExpression:
                    return BindInvocationExpression((InvocationExpressionSyntax)node, diagnostics);
                case SyntaxKind.ArrayInitializerExpression:
                    return BindUnexpectedArrayInitializer((InitializerExpressionSyntax)node, diagnostics, ErrorCode.ERR_ArrayInitInBadPlace);
                case SyntaxKind.ArrayCreationExpression:
                    return BindArrayCreationExpression((ArrayCreationExpressionSyntax)node, diagnostics);
                case SyntaxKind.ImplicitArrayCreationExpression:
                    return BindImplicitArrayCreationExpression((ImplicitArrayCreationExpressionSyntax)node, diagnostics);
                case SyntaxKind.StackAllocArrayCreationExpression:
                    return BindStackAllocArrayCreationExpression((StackAllocArrayCreationExpressionSyntax)node, diagnostics);
                case SyntaxKind.ImplicitStackAllocArrayCreationExpression:
                    return BindImplicitStackAllocArrayCreationExpression((ImplicitStackAllocArrayCreationExpressionSyntax)node, diagnostics);
                case SyntaxKind.ObjectCreationExpression:
                    return BindObjectCreationExpression((ObjectCreationExpressionSyntax)node, diagnostics);
                case SyntaxKind.ImplicitObjectCreationExpression:
                    return BindImplicitObjectCreationExpression((ImplicitObjectCreationExpressionSyntax)node, diagnostics);
                case SyntaxKind.IdentifierName:
                case SyntaxKind.GenericName:
                    return BindIdentifier((SimpleNameSyntax)node, invoked, indexed, diagnostics);
                case SyntaxKind.SimpleMemberAccessExpression:
                case SyntaxKind.PointerMemberAccessExpression:
                    return BindMemberAccess((MemberAccessExpressionSyntax)node, invoked, indexed, diagnostics);
                case SyntaxKind.SimpleAssignmentExpression:
                    return BindAssignment((AssignmentExpressionSyntax)node, diagnostics);
                case SyntaxKind.CastExpression:
                    return BindCast((CastExpressionSyntax)node, diagnostics);
                case SyntaxKind.ElementAccessExpression:
                    return BindElementAccess((ElementAccessExpressionSyntax)node, diagnostics);
                case SyntaxKind.AddExpression:
                case SyntaxKind.SubtractExpression:
                case SyntaxKind.MultiplyExpression:
                case SyntaxKind.DivideExpression:
                case SyntaxKind.ModuloExpression:
                case SyntaxKind.LeftShiftExpression:
                case SyntaxKind.RightShiftExpression:
                case SyntaxKind.BitwiseOrExpression:
                case SyntaxKind.BitwiseAndExpression:
                case SyntaxKind.ExclusiveOrExpression:
                case SyntaxKind.EqualsExpression:
                case SyntaxKind.NotEqualsExpression:
                case SyntaxKind.LessThanExpression:
                case SyntaxKind.LessThanOrEqualExpression:
                case SyntaxKind.GreaterThanExpression:
                case SyntaxKind.GreaterThanOrEqualExpression:
                    return BindSimpleBinaryOperator((BinaryExpressionSyntax)node, diagnostics);
                case SyntaxKind.LogicalOrExpression:
                case SyntaxKind.LogicalAndExpression:
                    return BindConditionalLogicalOperator((BinaryExpressionSyntax)node, diagnostics);
                case SyntaxKind.CoalesceExpression:
                    return BindNullCoalescingOperator((BinaryExpressionSyntax)node, diagnostics);
                case SyntaxKind.ConditionalAccessExpression:
                    return BindConditionalAccessExpression((ConditionalAccessExpressionSyntax)node, diagnostics);
                case SyntaxKind.MemberBindingExpression:
                    return BindMemberBindingExpression((MemberBindingExpressionSyntax)node, invoked, indexed, diagnostics);
                case SyntaxKind.ElementBindingExpression:
                    return BindElementBindingExpression((ElementBindingExpressionSyntax)node, diagnostics);
                case SyntaxKind.IsExpression:
                    return BindIsOperator((BinaryExpressionSyntax)node, diagnostics);
                case SyntaxKind.AsExpression:
                    return BindAsOperator((BinaryExpressionSyntax)node, diagnostics);
                case SyntaxKind.UnaryPlusExpression:
                case SyntaxKind.UnaryMinusExpression:
                case SyntaxKind.BitwiseNotExpression:
                case SyntaxKind.LogicalNotExpression:
                    return BindUnaryOperator((PrefixUnaryExpressionSyntax)node, diagnostics);
                case SyntaxKind.IndexExpression:
                    return BindFromEndIndexExpression((PrefixUnaryExpressionSyntax)node, diagnostics);
                case SyntaxKind.RangeExpression:
                    return BindRangeExpression((RangeExpressionSyntax)node, diagnostics);
                case SyntaxKind.AddressOfExpression:
                    return BindAddressOfExpression((PrefixUnaryExpressionSyntax)node, diagnostics);
                case SyntaxKind.PointerIndirectionExpression:
                    return BindPointerIndirectionExpression((PrefixUnaryExpressionSyntax)node, diagnostics);
                case SyntaxKind.PostIncrementExpression:
                case SyntaxKind.PostDecrementExpression:
                    return BindIncrementOperator(node, ((PostfixUnaryExpressionSyntax)node).Operand, ((PostfixUnaryExpressionSyntax)node).OperatorToken, diagnostics);
                case SyntaxKind.PreIncrementExpression:
                case SyntaxKind.PreDecrementExpression:
                    return BindIncrementOperator(node, ((PrefixUnaryExpressionSyntax)node).Operand, ((PrefixUnaryExpressionSyntax)node).OperatorToken, diagnostics);
                case SyntaxKind.ConditionalExpression:
                    return BindConditionalOperator((ConditionalExpressionSyntax)node, diagnostics);
                case SyntaxKind.SwitchExpression:
                    return BindSwitchExpression((SwitchExpressionSyntax)node, diagnostics);
                case SyntaxKind.NumericLiteralExpression:
                case SyntaxKind.StringLiteralExpression:
                case SyntaxKind.CharacterLiteralExpression:
                case SyntaxKind.TrueLiteralExpression:
                case SyntaxKind.FalseLiteralExpression:
                case SyntaxKind.NullLiteralExpression:
                    return BindLiteralConstant((LiteralExpressionSyntax)node, diagnostics);
                case SyntaxKind.DefaultLiteralExpression:
                    return new BoundDefaultLiteral(node);
                case SyntaxKind.ParenthesizedExpression:
                    return BindParenthesizedExpression(((ParenthesizedExpressionSyntax)node).Expression, diagnostics);
                case SyntaxKind.CheckedExpression:
                case SyntaxKind.UncheckedExpression:
                    return BindCheckedExpression((CheckedExpressionSyntax)node, diagnostics);
                case SyntaxKind.DefaultExpression:
                    return BindDefaultExpression((DefaultExpressionSyntax)node, diagnostics);
                case SyntaxKind.TypeOfExpression:
                    return BindTypeOf((TypeOfExpressionSyntax)node, diagnostics);
                case SyntaxKind.SizeOfExpression:
                    return BindSizeOf((SizeOfExpressionSyntax)node, diagnostics);
                case SyntaxKind.AddAssignmentExpression:
                case SyntaxKind.SubtractAssignmentExpression:
                case SyntaxKind.MultiplyAssignmentExpression:
                case SyntaxKind.DivideAssignmentExpression:
                case SyntaxKind.ModuloAssignmentExpression:
                case SyntaxKind.AndAssignmentExpression:
                case SyntaxKind.ExclusiveOrAssignmentExpression:
                case SyntaxKind.OrAssignmentExpression:
                case SyntaxKind.LeftShiftAssignmentExpression:
                case SyntaxKind.RightShiftAssignmentExpression:
                    return BindCompoundAssignment((AssignmentExpressionSyntax)node, diagnostics);
                case SyntaxKind.CoalesceAssignmentExpression:
                    return BindNullCoalescingAssignmentOperator((AssignmentExpressionSyntax)node, diagnostics);
                case SyntaxKind.AliasQualifiedName:
                case SyntaxKind.PredefinedType:
                    return BindNamespaceOrType(node, diagnostics);
                case SyntaxKind.QueryExpression:
                    return BindQuery((QueryExpressionSyntax)node, diagnostics);
                case SyntaxKind.AnonymousObjectCreationExpression:
                    return BindAnonymousObjectCreation((AnonymousObjectCreationExpressionSyntax)node, diagnostics);
                case SyntaxKind.QualifiedName:
                    return BindQualifiedName((QualifiedNameSyntax)node, diagnostics);
                case SyntaxKind.ComplexElementInitializerExpression:
                    return BindUnexpectedComplexElementInitializer((InitializerExpressionSyntax)node, diagnostics);
                case SyntaxKind.ArgListExpression:
                    return BindArgList(node, diagnostics);
                case SyntaxKind.RefTypeExpression:
                    return BindRefType((RefTypeExpressionSyntax)node, diagnostics);
                case SyntaxKind.MakeRefExpression:
                    return BindMakeRef((MakeRefExpressionSyntax)node, diagnostics);
                case SyntaxKind.RefValueExpression:
                    return BindRefValue((RefValueExpressionSyntax)node, diagnostics);
                case SyntaxKind.AwaitExpression:
                    return BindAwait((AwaitExpressionSyntax)node, diagnostics);
                case SyntaxKind.OmittedTypeArgument:
                case SyntaxKind.ObjectInitializerExpression:
                case SyntaxKind.OmittedArraySizeExpression:
                    return BadExpression(node);
                case SyntaxKind.NullableType:
                    return BadExpression(node);
                case SyntaxKind.InterpolatedStringExpression:
                    return BindInterpolatedString((InterpolatedStringExpressionSyntax)node, diagnostics);
                case SyntaxKind.IsPatternExpression:
                    return BindIsPatternExpression((IsPatternExpressionSyntax)node, diagnostics);
                case SyntaxKind.TupleExpression:
                    return BindTupleExpression((TupleExpressionSyntax)node, diagnostics);
                case SyntaxKind.ThrowExpression:
                    return BindThrowExpression((ThrowExpressionSyntax)node, diagnostics);
                case SyntaxKind.RefType:
                    return BindRefType(node, diagnostics);
                case SyntaxKind.RefExpression:
                    return BindRefExpression(node, diagnostics);
                case SyntaxKind.DeclarationExpression:
                    return BindDeclarationExpressionAsError((DeclarationExpressionSyntax)node, diagnostics);
                case SyntaxKind.SuppressNullableWarningExpression:
                    return BindSuppressNullableWarningExpression((PostfixUnaryExpressionSyntax)node, diagnostics);
                case SyntaxKind.WithExpression:
                    return BindWithExpression((WithExpressionSyntax)node, diagnostics);
                default:
                    diagnostics.Add(ErrorCode.ERR_InternalError, node.Location);
                    return BadExpression(node);
            }
        }

        internal virtual BoundSwitchExpressionArm BindSwitchExpressionArm(SwitchExpressionArmSyntax node, TypeSymbol switchGoverningType, uint switchGoverningValEscape, BindingDiagnosticBag diagnostics)
        {
            return NextRequired.BindSwitchExpressionArm(node, switchGoverningType, switchGoverningValEscape, diagnostics);
        }

        private BoundExpression BindRefExpression(ExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            SyntaxToken firstToken = node.GetFirstToken();
            diagnostics.Add(ErrorCode.ERR_UnexpectedToken, firstToken.GetLocation(), firstToken.ValueText);
            return new BoundBadExpression(node, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, ImmutableArray<BoundExpression>.Empty, CreateErrorType("ref"));
        }

        private BoundExpression BindRefType(ExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            SyntaxToken firstToken = node.GetFirstToken();
            diagnostics.Add(ErrorCode.ERR_UnexpectedToken, firstToken.GetLocation(), firstToken.ValueText);
            return new BoundTypeExpression(node, null, CreateErrorType("ref"));
        }

        private BoundExpression BindThrowExpression(ThrowExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            bool hasErrors = node.HasErrors;
            if (!IsThrowExpressionInProperContext(node))
            {
                diagnostics.Add(ErrorCode.ERR_ThrowMisplaced, node.ThrowKeyword.GetLocation());
                hasErrors = true;
            }
            BoundExpression expression = BindThrownExpression(node.Expression, diagnostics, ref hasErrors);
            return new BoundThrowExpression(node, expression, null, hasErrors);
        }

        private static bool IsThrowExpressionInProperContext(ThrowExpressionSyntax node)
        {
            CSharpSyntaxNode parent = node.Parent;
            if (parent == null || node.HasErrors)
            {
                return true;
            }
            switch (parent.Kind())
            {
                case SyntaxKind.ConditionalExpression:
                    {
                        ConditionalExpressionSyntax conditionalExpressionSyntax = (ConditionalExpressionSyntax)parent;
                        if (node != conditionalExpressionSyntax.WhenTrue)
                        {
                            return node == conditionalExpressionSyntax.WhenFalse;
                        }
                        return true;
                    }
                case SyntaxKind.CoalesceExpression:
                    {
                        BinaryExpressionSyntax binaryExpressionSyntax = (BinaryExpressionSyntax)parent;
                        return node == binaryExpressionSyntax.Right;
                    }
                case SyntaxKind.SimpleLambdaExpression:
                case SyntaxKind.ParenthesizedLambdaExpression:
                case SyntaxKind.ArrowExpressionClause:
                case SyntaxKind.SwitchExpressionArm:
                    return true;
                default:
                    return false;
            }
        }

        private BoundExpression BindDeclarationExpressionAsError(DeclarationExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            bool isConst = false;
            TypeWithAnnotations declTypeWithAnnotations = BindVariableTypeWithAnnotations(node.Designation, diagnostics, node.Type, ref isConst, out bool isVar, out AliasSymbol alias);
            Error(diagnostics, ErrorCode.ERR_DeclarationExpressionNotPermitted, node);
            return BindDeclarationVariablesForErrorRecovery(declTypeWithAnnotations, node.Designation, node, diagnostics);
        }

        private BoundExpression BindDeclarationVariablesForErrorRecovery(TypeWithAnnotations declTypeWithAnnotations, VariableDesignationSyntax node, CSharpSyntaxNode syntax, BindingDiagnosticBag diagnostics)
        {
            declTypeWithAnnotations = (declTypeWithAnnotations.HasType ? declTypeWithAnnotations : TypeWithAnnotations.Create(CreateErrorType("var")));
            switch (node.Kind())
            {
                case SyntaxKind.SingleVariableDesignation:
                    {
                        SingleVariableDesignationSyntax designation = (SingleVariableDesignationSyntax)node;
                        BoundExpression expression = BindDeconstructionVariable(declTypeWithAnnotations, designation, syntax, diagnostics);
                        return BindToTypeForErrorRecovery(expression);
                    }
                case SyntaxKind.DiscardDesignation:
                    return BindDiscardExpression(syntax, declTypeWithAnnotations);
                case SyntaxKind.ParenthesizedVariableDesignation:
                    {
                        ParenthesizedVariableDesignationSyntax obj = (ParenthesizedVariableDesignationSyntax)node;
                        int count = obj.Variables.Count;
                        ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance(count);
                        ArrayBuilder<string> inferredElementNames = ArrayBuilder<string>.GetInstance(count);
                        SeparatedSyntaxList<VariableDesignationSyntax>.Enumerator enumerator = obj.Variables.GetEnumerator();
                        while (enumerator.MoveNext())
                        {
                            VariableDesignationSyntax current = enumerator.Current;
                            instance.Add(BindDeclarationVariablesForErrorRecovery(declTypeWithAnnotations, current, current, diagnostics));
                            inferredElementNames.Add(InferTupleElementName(current));
                        }
                        ImmutableArray<BoundExpression> immutableArray = instance.ToImmutableAndFree();
                        PooledHashSet<string> instance2 = PooledHashSet<string>.GetInstance();
                        RemoveDuplicateInferredTupleNamesAndFreeIfEmptied(ref inferredElementNames, instance2);
                        instance2.Free();
                        ImmutableArray<string> immutableArray2 = inferredElementNames?.ToImmutableAndFree() ?? default(ImmutableArray<string>);
                        ImmutableArray<bool> immutableArray3 = (immutableArray2.IsDefault ? default(ImmutableArray<bool>) : immutableArray2.SelectAsArray((string n) => n != null));
                        bool flag = Compilation.LanguageVersion.DisallowInferredTupleElementNames();
                        NamedTypeSymbol type = NamedTypeSymbol.CreateTuple(null, immutableArray.SelectAsArray((BoundExpression e) => TypeWithAnnotations.Create(e.Type)), default(ImmutableArray<Location>), immutableArray2, Compilation, shouldCheckConstraints: false, includeNullability: false, flag ? immutableArray3 : default(ImmutableArray<bool>));
                        return new BoundConvertedTupleLiteral(syntax, null, wasTargetTyped: true, immutableArray, immutableArray2, immutableArray3, type);
                    }
                default:
                    throw ExceptionUtilities.UnexpectedValue(node.Kind());
            }
        }

        private BoundExpression BindTupleExpression(TupleExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            SeparatedSyntaxList<ArgumentSyntax> arguments = node.Arguments;
            int count = arguments.Count;
            if (count < 2)
            {
                ImmutableArray<BoundExpression> childNodes = ((count == 1) ? ImmutableArray.Create(BindValue(arguments[0].Expression, diagnostics, BindValueKind.RValue)) : ImmutableArray<BoundExpression>.Empty);
                return BadExpression(node, childNodes);
            }
            bool flag = true;
            ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance(arguments.Count);
            ArrayBuilder<TypeWithAnnotations> instance2 = ArrayBuilder<TypeWithAnnotations>.GetInstance(arguments.Count);
            ArrayBuilder<Location> instance3 = ArrayBuilder<Location>.GetInstance(arguments.Count);
            (ImmutableArray<string> elementNamesArray, ImmutableArray<bool> inferredArray, bool hasErrors) tuple = ExtractTupleElementNames(arguments, diagnostics);
            ImmutableArray<string> item = tuple.elementNamesArray;
            ImmutableArray<bool> item2 = tuple.inferredArray;
            bool item3 = tuple.hasErrors;
            for (int i = 0; i < count; i++)
            {
                ArgumentSyntax argumentSyntax = arguments[i];
                IdentifierNameSyntax identifierNameSyntax = argumentSyntax.NameColon?.Name;
                if (identifierNameSyntax != null)
                {
                    instance3.Add(identifierNameSyntax.Location);
                }
                else
                {
                    instance3.Add(argumentSyntax.Location);
                }
                BoundExpression boundExpression = BindValue(argumentSyntax.Expression, diagnostics, BindValueKind.RValue);
                TypeSymbol? type = boundExpression.Type;
                if ((object)type != null && type!.SpecialType == SpecialType.System_Void)
                {
                    diagnostics.Add(ErrorCode.ERR_VoidInTuple, argumentSyntax.Location);
                    boundExpression = new BoundBadExpression(argumentSyntax, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, ImmutableArray.Create(boundExpression), CreateErrorType("void"));
                }
                instance.Add(boundExpression);
                TypeWithAnnotations item4 = TypeWithAnnotations.Create(boundExpression.Type);
                instance2.Add(item4);
                if (!item4.HasType)
                {
                    flag = false;
                }
            }
            NamedTypeSymbol type2 = null;
            ImmutableArray<TypeWithAnnotations> immutableArray = instance2.ToImmutableAndFree();
            ImmutableArray<Location> immutableArray2 = instance3.ToImmutableAndFree();
            if (flag)
            {
                bool flag2 = Compilation.LanguageVersion.DisallowInferredTupleElementNames();
                type2 = NamedTypeSymbol.CreateTuple(node.Location, immutableArray, immutableArray2, item, Compilation, shouldCheckConstraints: true, includeNullability: false, syntax: node, diagnostics: diagnostics, errorPositions: flag2 ? item2 : default(ImmutableArray<bool>));
            }
            else
            {
                NamedTypeSymbol.VerifyTupleTypePresent(immutableArray.Length, node, Compilation, diagnostics);
            }
            return new BoundTupleLiteral(node, instance.ToImmutableAndFree(), item, item2, type2, item3);
        }

        private static (ImmutableArray<string> elementNamesArray, ImmutableArray<bool> inferredArray, bool hasErrors) ExtractTupleElementNames(SeparatedSyntaxList<ArgumentSyntax> arguments, BindingDiagnosticBag diagnostics)
        {
            bool item = false;
            int count = arguments.Count;
            PooledHashSet<string> instance = PooledHashSet<string>.GetInstance();
            ArrayBuilder<string> elementNames = null;
            ArrayBuilder<string> inferredElementNames = null;
            for (int i = 0; i < count; i++)
            {
                ArgumentSyntax argumentSyntax = arguments[i];
                IdentifierNameSyntax identifierNameSyntax = argumentSyntax.NameColon?.Name;
                string name = null;
                string name2 = null;
                if (identifierNameSyntax != null)
                {
                    name = identifierNameSyntax.Identifier.ValueText;
                    if (diagnostics != null && !CheckTupleMemberName(name, i, argumentSyntax.NameColon!.Name, diagnostics, instance))
                    {
                        item = true;
                    }
                }
                else
                {
                    name2 = InferTupleElementName(argumentSyntax.Expression);
                }
                CollectTupleFieldMemberName(name, i, count, ref elementNames);
                CollectTupleFieldMemberName(name2, i, count, ref inferredElementNames);
            }
            RemoveDuplicateInferredTupleNamesAndFreeIfEmptied(ref inferredElementNames, instance);
            instance.Free();
            (ImmutableArray<string>, ImmutableArray<bool>) tuple = MergeTupleElementNames(elementNames, inferredElementNames);
            elementNames?.Free();
            inferredElementNames?.Free();
            return (tuple.Item1, tuple.Item2, item);
        }

        private static (ImmutableArray<string> names, ImmutableArray<bool> inferred) MergeTupleElementNames(ArrayBuilder<string> elementNames, ArrayBuilder<string> inferredElementNames)
        {
            if (elementNames == null)
            {
                if (inferredElementNames == null)
                {
                    return (default(ImmutableArray<string>), default(ImmutableArray<bool>));
                }
                ImmutableArray<string> immutableArray = inferredElementNames.ToImmutable();
                return (immutableArray, immutableArray.SelectAsArray((string n) => n != null));
            }
            if (inferredElementNames == null)
            {
                return (elementNames.ToImmutable(), default(ImmutableArray<bool>));
            }
            ArrayBuilder<bool> instance = ArrayBuilder<bool>.GetInstance(elementNames.Count);
            for (int i = 0; i < elementNames.Count; i++)
            {
                string text = inferredElementNames[i];
                if (elementNames[i] == null && text != null)
                {
                    elementNames[i] = text;
                    instance.Add(item: true);
                }
                else
                {
                    instance.Add(item: false);
                }
            }
            return (elementNames.ToImmutable(), instance.ToImmutableAndFree());
        }

        private static void RemoveDuplicateInferredTupleNamesAndFreeIfEmptied(ref ArrayBuilder<string> inferredElementNames, HashSet<string> uniqueFieldNames)
        {
            if (inferredElementNames == null)
            {
                return;
            }
            PooledHashSet<string> instance = PooledHashSet<string>.GetInstance();
            ArrayBuilder<string>.Enumerator enumerator = inferredElementNames.GetEnumerator();
            while (enumerator.MoveNext())
            {
                string current = enumerator.Current;
                if (current != null && !uniqueFieldNames.Add(current))
                {
                    instance.Add(current);
                }
            }
            for (int i = 0; i < inferredElementNames.Count; i++)
            {
                string text = inferredElementNames[i];
                if (text != null && instance.Contains(text))
                {
                    inferredElementNames[i] = null;
                }
            }
            instance.Free();
            if (inferredElementNames.All((string n) => n == null))
            {
                inferredElementNames.Free();
                inferredElementNames = null;
            }
        }

        private static string InferTupleElementName(SyntaxNode syntax)
        {
            string text = syntax.TryGetInferredMemberName();
            if (text == null || NamedTypeSymbol.IsTupleElementNameReserved(text) != -1)
            {
                return null;
            }
            return text;
        }

        private BoundExpression BindRefValue(RefValueExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            BoundExpression boundExpression = BindValue(node.Expression, diagnostics, BindValueKind.RValue);
            bool hasErrors = boundExpression.HasAnyErrors;
            TypeSymbol specialType = Compilation.GetSpecialType(SpecialType.System_TypedReference);
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            Conversion conversion = Conversions.ClassifyConversionFromExpression(boundExpression, specialType, ref useSiteInfo);
            diagnostics.Add(node, useSiteInfo);
            if (!conversion.IsImplicit || !conversion.IsValid)
            {
                hasErrors = true;
                GenerateImplicitConversionError(diagnostics, node, conversion, boundExpression, specialType);
            }
            boundExpression = CreateConversion(boundExpression, conversion, specialType, diagnostics);
            TypeWithAnnotations typeWithAnnotations = BindType(node.Type, diagnostics);
            return new BoundRefValueOperator(node, typeWithAnnotations.NullableAnnotation, boundExpression, typeWithAnnotations.Type, hasErrors);
        }

        private BoundExpression BindMakeRef(MakeRefExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            BoundExpression boundExpression = BindValue(node.Expression, diagnostics, BindValueKind.RefOrOut);
            bool hasErrors = boundExpression.HasAnyErrors;
            TypeSymbol specialType = GetSpecialType(SpecialType.System_TypedReference, diagnostics, node);
            if ((object)boundExpression.Type != null && boundExpression.Type.IsRestrictedType())
            {
                Error(diagnostics, ErrorCode.ERR_MethodArgCantBeRefAny, node, boundExpression.Type);
                hasErrors = true;
            }
            return new BoundMakeRefOperator(node, boundExpression, specialType, hasErrors);
        }

        private BoundExpression BindRefType(RefTypeExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            BoundExpression boundExpression = BindValue(node.Expression, diagnostics, BindValueKind.RValue);
            bool hasErrors = boundExpression.HasAnyErrors;
            TypeSymbol specialType = Compilation.GetSpecialType(SpecialType.System_TypedReference);
            TypeSymbol wellKnownType = GetWellKnownType(WellKnownType.System_Type, diagnostics, node);
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            Conversion conversion = Conversions.ClassifyConversionFromExpression(boundExpression, specialType, ref useSiteInfo);
            diagnostics.Add(node, useSiteInfo);
            if (!conversion.IsImplicit || !conversion.IsValid)
            {
                hasErrors = true;
                GenerateImplicitConversionError(diagnostics, node, conversion, boundExpression, specialType);
            }
            boundExpression = CreateConversion(boundExpression, conversion, specialType, diagnostics);
            return new BoundRefTypeOperator(node, boundExpression, null, wellKnownType, hasErrors);
        }

        private BoundExpression BindArgList(CSharpSyntaxNode node, BindingDiagnosticBag diagnostics)
        {
            TypeSymbol specialType = GetSpecialType(SpecialType.System_RuntimeArgumentHandle, diagnostics, node);
            MethodSymbol methodSymbol = ContainingMember() as MethodSymbol;
            bool hasErrors = false;
            if ((object)methodSymbol == null || !methodSymbol.IsVararg)
            {
                Error(diagnostics, ErrorCode.ERR_ArgsInvalid, node);
                hasErrors = true;
            }
            else if (ContainingMemberOrLambda != methodSymbol)
            {
                Error(diagnostics, ErrorCode.ERR_SpecialByRefInLambda, node, specialType);
                hasErrors = true;
            }
            return new BoundArgList(node, specialType, hasErrors);
        }

        private BoundExpression BindQualifiedName(QualifiedNameSyntax node, BindingDiagnosticBag diagnostics)
        {
            return BindMemberAccessWithBoundLeft(node, BindLeftOfPotentialColorColorMemberAccess(node.Left, diagnostics), node.Right, node.DotToken, invoked: false, indexed: false, diagnostics);
        }

        private BoundExpression BindParenthesizedExpression(ExpressionSyntax innerExpression, BindingDiagnosticBag diagnostics)
        {
            BoundExpression boundExpression = BindExpression(innerExpression, diagnostics);
            CheckNotNamespaceOrType(boundExpression, diagnostics);
            return boundExpression;
        }

        private BoundExpression BindTypeOf(TypeOfExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            ExpressionSyntax type = node.Type;
            TypeWithAnnotations typeWithAnnotations = new TypeofBinder(type, this).BindType(type, diagnostics, out AliasSymbol alias);
            TypeSymbol type2 = typeWithAnnotations.Type;
            bool hasErrors = false;
            if (type2.IsDynamic())
            {
                diagnostics.Add(ErrorCode.ERR_BadDynamicTypeof, node.Location);
                hasErrors = true;
            }
            else if (typeWithAnnotations.NullableAnnotation.IsAnnotated() && type2.IsReferenceType)
            {
                diagnostics.Add(ErrorCode.ERR_BadNullableTypeof, node.Location);
                hasErrors = true;
            }
            else if (InAttributeArgument && type2.ContainsFunctionPointer())
            {
                diagnostics.Add(ErrorCode.ERR_FunctionPointerTypesInAttributeNotSupported, node.Location);
                hasErrors = true;
            }
            BoundTypeExpression sourceType = new BoundTypeExpression(type, alias, typeWithAnnotations, type2.IsErrorType());
            return new BoundTypeOfOperator(node, sourceType, null, GetWellKnownType(WellKnownType.System_Type, diagnostics, node), hasErrors);
        }

        private BoundExpression BindSizeOf(SizeOfExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            ExpressionSyntax type = node.Type;
            TypeWithAnnotations typeWithAnnotations = BindType(type, diagnostics, out AliasSymbol alias);
            TypeSymbol type2 = typeWithAnnotations.Type;
            bool hasErrors = type2.IsErrorType() || CheckManagedAddr(Compilation, type2, node.Location, diagnostics);
            BoundTypeExpression sourceType = new BoundTypeExpression(type, alias, typeWithAnnotations, hasErrors);
            ConstantValue constantSizeOf = GetConstantSizeOf(type2);
            bool hasErrors2 = (object)constantSizeOf == null && ReportUnsafeIfNotAllowed(node, diagnostics, type2);
            return new BoundSizeOfOperator(node, sourceType, constantSizeOf, GetSpecialType(SpecialType.System_Int32, diagnostics, node), hasErrors2);
        }

        internal static bool CheckManagedAddr(CSharpCompilation compilation, TypeSymbol type, Location location, BindingDiagnosticBag diagnostics)
        {
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = new CompoundUseSiteInfo<AssemblySymbol>(diagnostics, compilation.Assembly);
            ManagedKind managedKind = type.GetManagedKind(ref useSiteInfo);
            diagnostics.Add(location, useSiteInfo);
            return CheckManagedAddr(compilation, type, managedKind, location, diagnostics);
        }

        internal static bool CheckManagedAddr(CSharpCompilation compilation, TypeSymbol type, ManagedKind managedKind, Location location, BindingDiagnosticBag diagnostics)
        {
            switch (managedKind)
            {
                case ManagedKind.Managed:
                    diagnostics.Add(ErrorCode.ERR_ManagedAddr, location, type);
                    return true;
                case ManagedKind.UnmanagedWithGenerics:
                    {
                        CSDiagnosticInfo featureAvailabilityDiagnosticInfo = MessageID.IDS_FeatureUnmanagedConstructedTypes.GetFeatureAvailabilityDiagnosticInfo(compilation);
                        if (featureAvailabilityDiagnosticInfo != null)
                        {
                            diagnostics.Add(featureAvailabilityDiagnosticInfo, location);
                            return true;
                        }
                        break;
                    }
                case ManagedKind.Unknown:
                    throw ExceptionUtilities.UnexpectedValue(managedKind);
            }
            return false;
        }

        internal static ConstantValue GetConstantSizeOf(TypeSymbol type)
        {
            return ConstantValue.CreateSizeOf((type.GetEnumUnderlyingType() ?? type).SpecialType);
        }

        private BoundExpression BindDefaultExpression(DefaultExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            TypeWithAnnotations typeWithAnnotations = BindType(node.Type, diagnostics, out AliasSymbol alias);
            BoundTypeExpression targetType = new BoundTypeExpression(node.Type, alias, typeWithAnnotations);
            TypeSymbol type = typeWithAnnotations.Type;
            return new BoundDefaultExpression(node, targetType, type.GetDefaultValue(), type);
        }

        private BoundExpression BindIdentifier(SimpleNameSyntax node, bool invoked, bool indexed, BindingDiagnosticBag diagnostics)
        {
            if (node.IsMissing)
            {
                return BadExpression(node);
            }
            int arity = node.Arity;
            bool flag = arity > 0;
            SeparatedSyntaxList<TypeSyntax> separatedSyntaxList = ((node.Kind() == SyntaxKind.GenericName) ? ((GenericNameSyntax)node).TypeArgumentList.Arguments : default(SeparatedSyntaxList<TypeSyntax>));
            ImmutableArray<TypeWithAnnotations> typeArguments = (flag ? BindTypeArguments(separatedSyntaxList, diagnostics) : default(ImmutableArray<TypeWithAnnotations>));
            LookupResult instance = LookupResult.GetInstance();
            LookupOptions lookupOptions = LookupOptions.AllMethodsOnArityZero;
            if (invoked)
            {
                lookupOptions |= LookupOptions.MustBeInvocableIfMember;
            }
            if (!IsInMethodBody && !IsInsideNameof)
            {
                lookupOptions |= LookupOptions.MustNotBeMethodTypeParameter;
            }
            string valueText = node.Identifier.ValueText;
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            LookupSymbolsWithFallback(instance, valueText, arity, ref useSiteInfo, null, lookupOptions);
            diagnostics.Add(node, useSiteInfo);
            BoundExpression boundExpression2;
            if (instance.Kind != 0)
            {
                ArrayBuilder<Symbol> instance2 = ArrayBuilder<Symbol>.GetInstance();
                Symbol symbol = GetSymbolOrMethodOrPropertyGroup(instance, node, valueText, node.Arity, instance2, diagnostics, out bool wasError, null);
                if ((object)symbol == null)
                {
                    BoundExpression boundExpression = SynthesizeMethodGroupReceiver(node, instance2);
                    boundExpression2 = ConstructBoundMemberGroupAndReportOmittedTypeArguments(node, separatedSyntaxList, typeArguments, boundExpression, valueText, instance2, instance, (boundExpression != null) ? BoundMethodGroupFlags.HasImplicitReceiver : BoundMethodGroupFlags.None, wasError, diagnostics);
                    ReportSimpleProgramLocalReferencedOutsideOfTopLevelStatement(node, instance2[0], diagnostics);
                }
                else
                {
                    bool flag2 = symbol.Kind == SymbolKind.NamedType || symbol.Kind == SymbolKind.ErrorType;
                    if (flag && flag2)
                    {
                        symbol = ConstructNamedTypeUnlessTypeArgumentOmitted(node, (NamedTypeSymbol)symbol, separatedSyntaxList, typeArguments, diagnostics);
                    }
                    boundExpression2 = BindNonMethod(node, symbol, diagnostics, instance.Kind, indexed, wasError);
                    if (!flag2 && (flag || node.Kind() == SyntaxKind.GenericName))
                    {
                        boundExpression2 = new BoundBadExpression(node, LookupResultKind.WrongArity, ImmutableArray.Create(symbol), ImmutableArray.Create(BindToTypeForErrorRecovery(boundExpression2)), boundExpression2.Type, wasError);
                    }
                }
                instance2.Free();
            }
            else
            {
                boundExpression2 = null;
                if (node is IdentifierNameSyntax node2)
                {
                    NamedTypeSymbol namedTypeSymbol = BindNativeIntegerSymbolIfAny(node2, diagnostics);
                    if ((object)namedTypeSymbol != null)
                    {
                        boundExpression2 = new BoundTypeExpression(node, null, namedTypeSymbol);
                    }
                    else if (FallBackOnDiscard(node2, diagnostics))
                    {
                        boundExpression2 = new BoundDiscardExpression(node, null);
                    }
                }
                if (boundExpression2 == null)
                {
                    boundExpression2 = BadExpression(node);
                    if (instance.Error != null)
                    {
                        Error(diagnostics, instance.Error, node);
                    }
                    else if (IsJoinRangeVariableInLeftKey(node))
                    {
                        Error(diagnostics, ErrorCode.ERR_QueryOuterKey, node, valueText);
                    }
                    else if (IsInJoinRightKey(node))
                    {
                        Error(diagnostics, ErrorCode.ERR_QueryInnerKey, node, valueText);
                    }
                    else
                    {
                        Error(diagnostics, ErrorCode.ERR_NameNotInContext, node, valueText);
                    }
                }
            }
            instance.Free();
            return boundExpression2;
        }

        /// <summary>
        /// Is this is an _ identifier in a context where discards are allowed?
        /// </summary>
        private static bool FallBackOnDiscard(IdentifierNameSyntax node, BindingDiagnosticBag diagnostics)
        {
            if (!node.Identifier.IsUnderscoreToken())
            {
                return false;
            }

            CSharpSyntaxNode containingDeconstruction = node.GetContainingDeconstruction();
            bool isDiscard = containingDeconstruction != null || IsOutVarDiscardIdentifier(node);
            if (isDiscard)
            {
                CheckFeatureAvailability(node, MessageID.IDS_FeatureDiscards, diagnostics);
            }

            return isDiscard;
        }

        private static bool IsOutVarDiscardIdentifier(SimpleNameSyntax node)
        {
            CSharpSyntaxNode parent = node.Parent;
            if (parent != null && parent.Kind() == SyntaxKind.Argument)
            {
                return ((ArgumentSyntax)parent).RefOrOutKeyword.Kind() == SyntaxKind.OutKeyword;
            }
            return false;
        }

        private BoundExpression SynthesizeMethodGroupReceiver(CSharpSyntaxNode syntax, ArrayBuilder<Symbol> members)
        {
            NamedTypeSymbol containingType = ContainingType;
            if ((object)containingType == null)
            {
                return null;
            }
            NamedTypeSymbol containingType2 = members[0].ContainingType;
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
            if (containingType.IsEqualToOrDerivedFrom(containingType2, TypeCompareKind.ConsiderEverything, ref useSiteInfo) || (containingType.IsInterface && (containingType2.IsObjectType() || containingType.AllInterfacesNoUseSiteDiagnostics.Contains(containingType2))))
            {
                return ThisReference(syntax, containingType, hasErrors: false, wasCompilerGenerated: true);
            }
            return TryBindInteractiveReceiver(syntax, containingType2);
        }

        private bool IsBadLocalOrParameterCapture(Symbol symbol, TypeSymbol type, RefKind refKind)
        {
            if ((refKind != 0 || type.IsRefLikeType) && ContainingMemberOrLambda is MethodSymbol methodSymbol && (object)symbol.ContainingSymbol != methodSymbol)
            {
                if (methodSymbol.MethodKind == MethodKind.AnonymousFunction || methodSymbol.MethodKind == MethodKind.LocalFunction)
                {
                    return !IsInsideNameof;
                }
                return false;
            }
            return false;
        }

        private BoundExpression BindNonMethod(SimpleNameSyntax node, Symbol symbol, BindingDiagnosticBag diagnostics, LookupResultKind resultKind, bool indexed, bool isError)
        {
            // Events are handled later as we don't know yet if we are binding to the event or it's backing field.
            if (symbol.Kind != SymbolKind.Event)
            {
                ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver: false);
            }

            switch (symbol.Kind)
            {
                case SymbolKind.Local:
                    {
                        var localSymbol = (LocalSymbol)symbol;
                        TypeSymbol type;
                        bool isNullableUnknown;

                        if (ReportSimpleProgramLocalReferencedOutsideOfTopLevelStatement(node, localSymbol, diagnostics))
                        {
                            type = new ExtendedErrorTypeSymbol(
                                this.Compilation, name: "var", arity: 0, errorInfo: null, variableUsedBeforeDeclaration: true);
                            isNullableUnknown = true;
                        }
                        else if (isUsedBeforeDeclaration(node, localSymbol))
                        {
                            // Here we report a local variable being used before its declaration
                            //
                            // There are two possible diagnostics for this:
                            //
                            // CS0841: ERR_VariableUsedBeforeDeclaration
                            // Cannot use local variable 'x' before it is declared
                            //
                            // CS0844: ERR_VariableUsedBeforeDeclarationAndHidesField
                            // Cannot use local variable 'x' before it is declared. The 
                            // declaration of the local variable hides the field 'C.x'.
                            //
                            // There are two situations in which we give these errors.
                            //
                            // First, the scope of a local variable -- that is, the region of program 
                            // text in which it can be looked up by name -- is throughout the entire
                            // block which declares it. It is therefore possible to use a local
                            // before it is declared, which is an error.
                            //
                            // As an additional help to the user, we give a special error for this
                            // scenario:
                            //
                            // class C { 
                            //  int x; 
                            //  void M() { 
                            //    Print(x); 
                            //    int x = 5;
                            //  } }
                            //
                            // Because a too-clever C++ user might be attempting to deliberately
                            // bind to "this.x" in the "Print". (In C++ the local does not come
                            // into scope until its declaration.)
                            //
                            FieldSymbol possibleField = null;
                            var lookupResult = LookupResult.GetInstance();
                            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                            this.LookupMembersInType(
                                lookupResult,
                                ContainingType,
                                localSymbol.Name,
                                arity: 0,
                                basesBeingResolved: null,
                                options: LookupOptions.Default,
                                originalBinder: this,
                                diagnose: false,
                                useSiteInfo: ref useSiteInfo);
                            diagnostics.Add(node, useSiteInfo);
                            possibleField = lookupResult.SingleSymbolOrDefault as FieldSymbol;
                            lookupResult.Free();
                            if ((object)possibleField != null)
                            {
                                Error(diagnostics, ErrorCode.ERR_VariableUsedBeforeDeclarationAndHidesField, node, node, possibleField);
                            }
                            else
                            {
                                Error(diagnostics, ErrorCode.ERR_VariableUsedBeforeDeclaration, node, node);
                            }

                            type = new ExtendedErrorTypeSymbol(
                                this.Compilation, name: "var", arity: 0, errorInfo: null, variableUsedBeforeDeclaration: true);
                            isNullableUnknown = true;
                        }
                        else if ((localSymbol as SourceLocalSymbol)?.IsVar == true && localSymbol.ForbiddenZone?.Contains(node) == true)
                        {
                            // A var (type-inferred) local variable has been used in its own initialization (the "forbidden zone").
                            // There are many cases where this occurs, including:
                            //
                            // 1. var x = M(out x);
                            // 2. M(out var x, out x);
                            // 3. var (x, y) = (y, x);
                            //
                            // localSymbol.ForbiddenDiagnostic provides a suitable diagnostic for whichever case applies.
                            //
                            diagnostics.Add(localSymbol.ForbiddenDiagnostic, node.Location, node);
                            type = new ExtendedErrorTypeSymbol(
                                this.Compilation, name: "var", arity: 0, errorInfo: null, variableUsedBeforeDeclaration: true);
                            isNullableUnknown = true;
                        }
                        else
                        {
                            type = localSymbol.Type;
                            isNullableUnknown = false;
                            if (IsBadLocalOrParameterCapture(localSymbol, type, localSymbol.RefKind))
                            {
                                isError = true;
                                Error(diagnostics, ErrorCode.ERR_AnonDelegateCantUseLocal, node, localSymbol);
                            }
                        }

                        var constantValueOpt = localSymbol.IsConst && !IsInsideNameof && !type.IsErrorType()
                            ? localSymbol.GetConstantValue(node, this.LocalInProgress, diagnostics) : null;
                        return new BoundLocal(node, localSymbol, BoundLocalDeclarationKind.None, constantValueOpt: constantValueOpt, isNullableUnknown: isNullableUnknown, type: type, hasErrors: isError);
                    }

                case SymbolKind.Parameter:
                    {
                        var parameter = (ParameterSymbol)symbol;
                        if (IsBadLocalOrParameterCapture(parameter, parameter.Type, parameter.RefKind))
                        {
                            isError = true;
                            Error(diagnostics, ErrorCode.ERR_AnonDelegateCantUse, node, parameter.Name);
                        }
                        return new BoundParameter(node, parameter, hasErrors: isError);
                    }

                case SymbolKind.NamedType:
                case SymbolKind.ErrorType:
                case SymbolKind.TypeParameter:
                    // If I identifies a type, then the result is that type constructed with the
                    // given type arguments. UNDONE: Construct the child type if it is generic!
                    return new BoundTypeExpression(node, null, (TypeSymbol)symbol, hasErrors: isError);

                case SymbolKind.Property:
                    {
                        BoundExpression receiver = SynthesizeReceiver(node, symbol, diagnostics);
                        return BindPropertyAccess(node, receiver, (PropertySymbol)symbol, diagnostics, resultKind, hasErrors: isError);
                    }

                case SymbolKind.Event:
                    {
                        BoundExpression receiver = SynthesizeReceiver(node, symbol, diagnostics);
                        return BindEventAccess(node, receiver, (EventSymbol)symbol, diagnostics, resultKind, hasErrors: isError);
                    }

                case SymbolKind.Field:
                    {
                        BoundExpression receiver = SynthesizeReceiver(node, symbol, diagnostics);
                        return BindFieldAccess(node, receiver, (FieldSymbol)symbol, diagnostics, resultKind, indexed, hasErrors: isError);
                    }

                case SymbolKind.Namespace:
                    return new BoundNamespaceExpression(node, (NamespaceSymbol)symbol, hasErrors: isError);

                case SymbolKind.Alias:
                    {
                        var alias = (AliasSymbol)symbol;
                        symbol = alias.Target;
                        switch (symbol.Kind)
                        {
                            case SymbolKind.NamedType:
                            case SymbolKind.ErrorType:
                                return new BoundTypeExpression(node, alias, (NamedTypeSymbol)symbol, hasErrors: isError);
                            case SymbolKind.Namespace:
                                return new BoundNamespaceExpression(node, (NamespaceSymbol)symbol, alias, hasErrors: isError);
                            default:
                                throw ExceptionUtilities.UnexpectedValue(symbol.Kind);
                        }
                    }

                case SymbolKind.RangeVariable:
                    return BindRangeVariable(node, (RangeVariableSymbol)symbol, diagnostics);

                default:
                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);
            }

            bool isUsedBeforeDeclaration(SimpleNameSyntax node, LocalSymbol localSymbol)
            {
                Location localSymbolLocation = localSymbol.Locations[0];

                if (node.SyntaxTree == localSymbolLocation.SourceTree)
                {
                    return node.SpanStart < localSymbolLocation.SourceSpan.Start;
                }

                return false;
            }
        }

        private static bool ReportSimpleProgramLocalReferencedOutsideOfTopLevelStatement(SimpleNameSyntax node, Symbol symbol, BindingDiagnosticBag diagnostics)
        {
            if (symbol.ContainingSymbol is SynthesizedSimpleProgramEntryPointSymbol && !SyntaxFacts.IsTopLevelStatement(node.Ancestors(ascendOutOfTrivia: false).OfType<GlobalStatementSyntax>().FirstOrDefault()))
            {
                Error(diagnostics, ErrorCode.ERR_SimpleProgramLocalIsReferencedOutsideOfTopLevelStatement, node, node);
                return true;
            }
            return false;
        }

        protected virtual BoundExpression BindRangeVariable(SimpleNameSyntax node, RangeVariableSymbol qv, BindingDiagnosticBag diagnostics)
        {
            return Next!.BindRangeVariable(node, qv, diagnostics);
        }

        private BoundExpression SynthesizeReceiver(SyntaxNode node, Symbol member, BindingDiagnosticBag diagnostics)
        {
            if (!member.RequiresInstanceReceiver())
            {
                return null;
            }
            NamedTypeSymbol containingType = ContainingType;
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
            NamedTypeSymbol containingType2 = member.ContainingType;
            if (containingType.IsEqualToOrDerivedFrom(containingType2, TypeCompareKind.ConsiderEverything, ref useSiteInfo) || (containingType.IsInterface && (containingType2.IsObjectType() || containingType.AllInterfacesNoUseSiteDiagnostics.Contains(containingType2))))
            {
                bool flag = false;
                if (EnclosingNameofArgument != node)
                {
                    if (InFieldInitializer && !containingType.IsScriptClass)
                    {
                        Error(diagnostics, ErrorCode.ERR_FieldInitRefNonstatic, node, member);
                        flag = true;
                    }
                    else if (InConstructorInitializer || InAttributeArgument)
                    {
                        Error(diagnostics, ErrorCode.ERR_ObjectRequired, node, member);
                        flag = true;
                    }
                    else
                    {
                        Symbol symbol = ContainingMember();
                        if (symbol.IsStatic || (symbol.Kind == SymbolKind.NamedType && !containingType.IsScriptClass))
                        {
                            Error(diagnostics, ErrorCode.ERR_ObjectRequired, node, member);
                            flag = true;
                        }
                    }
                    flag = flag || IsRefOrOutThisParameterCaptured(node, diagnostics);
                }
                return ThisReference(node, containingType, flag, wasCompilerGenerated: true);
            }
            return TryBindInteractiveReceiver(node, containingType2);
        }

        internal Symbol ContainingMember()
        {
            return ContainingMemberOrLambda.ContainingNonLambdaMember();
        }

        private BoundExpression TryBindInteractiveReceiver(SyntaxNode syntax, NamedTypeSymbol memberDeclaringType)
        {
            if (ContainingType!.TypeKind == TypeKind.Submission && isInstanceContext())
            {
                if (memberDeclaringType.TypeKind == TypeKind.Submission)
                {
                    return new BoundPreviousSubmissionReference(syntax, memberDeclaringType)
                    {
                        WasCompilerGenerated = true
                    };
                }
                TypeSymbol hostObjectTypeSymbol = Compilation.GetHostObjectTypeSymbol();
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
                if ((object)hostObjectTypeSymbol != null && hostObjectTypeSymbol.IsEqualToOrDerivedFrom(memberDeclaringType, TypeCompareKind.ConsiderEverything, ref useSiteInfo))
                {
                    return new BoundHostObjectMemberReference(syntax, hostObjectTypeSymbol)
                    {
                        WasCompilerGenerated = true
                    };
                }
            }
            return null;
            bool isInstanceContext()
            {
                Symbol symbol = ContainingMemberOrLambda;
                do
                {
                    if (symbol.IsStatic)
                    {
                        return false;
                    }
                    if (symbol.Kind == SymbolKind.NamedType)
                    {
                        break;
                    }
                    symbol = symbol.ContainingSymbol;
                }
                while ((object)symbol != null);
                return true;
            }
        }

        public BoundExpression BindNamespaceOrTypeOrExpression(ExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            if (node.Kind() == SyntaxKind.PredefinedType)
            {
                return BindNamespaceOrType(node, diagnostics);
            }
            if (SyntaxFacts.IsName(node.Kind()))
            {
                if (SyntaxFacts.IsNamespaceAliasQualifier(node))
                {
                    return BindNamespaceAlias((IdentifierNameSyntax)node, diagnostics);
                }
                if (SyntaxFacts.IsInNamespaceOrTypeContext(node))
                {
                    return BindNamespaceOrType(node, diagnostics);
                }
            }
            else if (SyntaxFacts.IsTypeSyntax(node.Kind()))
            {
                return BindNamespaceOrType(node, diagnostics);
            }
            return BindExpression(node, diagnostics, SyntaxFacts.IsInvoked(node), SyntaxFacts.IsIndexed(node));
        }

        public BoundExpression BindLabel(ExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            if (!(node is IdentifierNameSyntax identifierNameSyntax))
            {
                return BadExpression(node, LookupResultKind.NotLabel);
            }
            LookupResult instance = LookupResult.GetInstance();
            string valueText = identifierNameSyntax.Identifier.ValueText;
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            LookupSymbolsWithFallback(instance, valueText, 0, ref useSiteInfo, null, LookupOptions.LabelsOnly);
            diagnostics.Add(node, useSiteInfo);
            if (!instance.IsMultiViable)
            {
                Error(diagnostics, ErrorCode.ERR_LabelNotFound, node, valueText);
                instance.Free();
                return BadExpression(node, instance.Kind);
            }
            LabelSymbol label = (LabelSymbol)instance.Symbols.First();
            instance.Free();
            return new BoundLabel(node, label, null);
        }

        public BoundExpression BindNamespaceOrType(ExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            return CreateBoundNamespaceOrTypeExpression(node, BindNamespaceOrTypeOrAliasSymbol(node, diagnostics, null, suppressUseSiteDiagnostics: false).Symbol);
        }

        public BoundExpression BindNamespaceAlias(IdentifierNameSyntax node, BindingDiagnosticBag diagnostics)
        {
            Symbol symbol = BindNamespaceAliasSymbol(node, diagnostics);
            return CreateBoundNamespaceOrTypeExpression(node, symbol);
        }

        private static BoundExpression CreateBoundNamespaceOrTypeExpression(ExpressionSyntax node, Symbol symbol)
        {
            AliasSymbol aliasSymbol = symbol as AliasSymbol;
            if ((object)aliasSymbol != null)
            {
                symbol = aliasSymbol.Target;
            }
            if (symbol is TypeSymbol type)
            {
                return new BoundTypeExpression(node, aliasSymbol, type);
            }
            if (symbol is NamespaceSymbol namespaceSymbol)
            {
                return new BoundNamespaceExpression(node, namespaceSymbol, aliasSymbol);
            }
            throw ExceptionUtilities.UnexpectedValue(symbol);
        }

        private BoundThisReference BindThis(ThisExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            bool hasErrors = true;
            if (!HasThis(isExplicit: true, out var inStaticContext))
            {
                Error(diagnostics, inStaticContext ? ErrorCode.ERR_ThisInStaticMeth : ErrorCode.ERR_ThisInBadContext, node);
            }
            else
            {
                hasErrors = IsRefOrOutThisParameterCaptured(node.Token, diagnostics);
            }
            return ThisReference(node, ContainingType, hasErrors);
        }

        private BoundThisReference ThisReference(SyntaxNode node, NamedTypeSymbol thisTypeOpt, bool hasErrors = false, bool wasCompilerGenerated = false)
        {
            return new BoundThisReference(node, thisTypeOpt ?? CreateErrorType(), hasErrors)
            {
                WasCompilerGenerated = wasCompilerGenerated
            };
        }

        private bool IsRefOrOutThisParameterCaptured(SyntaxNodeOrToken thisOrBaseToken, BindingDiagnosticBag diagnostics)
        {
            ParameterSymbol parameterSymbol = ContainingMemberOrLambda.EnclosingThisSymbol();
            if ((object)parameterSymbol != null && parameterSymbol.ContainingSymbol != ContainingMemberOrLambda && parameterSymbol.RefKind != 0)
            {
                Error(diagnostics, ErrorCode.ERR_ThisStructNotInAnonMeth, thisOrBaseToken);
                return true;
            }
            return false;
        }

        private BoundBaseReference BindBase(BaseExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            bool hasErrors = false;
            TypeSymbol typeSymbol = (((object)ContainingType == null) ? null : ContainingType!.BaseTypeNoUseSiteDiagnostics);
            if (!HasThis(isExplicit: true, out var inStaticContext))
            {
                Error(diagnostics, inStaticContext ? ErrorCode.ERR_BaseInStaticMeth : ErrorCode.ERR_BaseInBadContext, node.Token);
                hasErrors = true;
            }
            else if ((object)typeSymbol == null)
            {
                Error(diagnostics, ErrorCode.ERR_NoBaseClass, node);
                hasErrors = true;
            }
            else if ((object)ContainingType == null || node.Parent == null || (node.Parent!.Kind() != SyntaxKind.SimpleMemberAccessExpression && node.Parent!.Kind() != SyntaxKind.ElementAccessExpression))
            {
                Error(diagnostics, ErrorCode.ERR_BaseIllegal, node.Token);
                hasErrors = true;
            }
            else if (IsRefOrOutThisParameterCaptured(node.Token, diagnostics))
            {
                hasErrors = true;
            }
            return new BoundBaseReference(node, typeSymbol, hasErrors);
        }

        private BoundExpression BindCast(CastExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            BoundExpression boundExpression = BindValue(node.Expression, diagnostics, BindValueKind.RValue);
            TypeWithAnnotations targetTypeWithAnnotations = BindType(node.Type, diagnostics);
            TypeSymbol type = targetTypeWithAnnotations.Type;
            if (type.IsNullableType() && !boundExpression.HasAnyErrors && (object)boundExpression.Type != null && !boundExpression.Type.IsNullableType() && !TypeSymbol.Equals(type.GetNullableUnderlyingType(), boundExpression.Type, TypeCompareKind.ConsiderEverything))
            {
                return BindExplicitNullableCastFromNonNullable(node, boundExpression, targetTypeWithAnnotations, diagnostics);
            }
            return BindCastCore(node, boundExpression, targetTypeWithAnnotations, boundExpression.WasCompilerGenerated, diagnostics);
        }

        private BoundExpression BindFromEndIndexExpression(PrefixUnaryExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            CheckFeatureAvailability(node, MessageID.IDS_FeatureIndexOperator, diagnostics);
            GetSpecialType(SpecialType.System_Boolean, diagnostics, node);
            BoundExpression boundExpression = BindValue(node.Operand, diagnostics, BindValueKind.RValue);
            TypeSymbol typeSymbol = GetSpecialType(SpecialType.System_Int32, diagnostics, node);
            TypeSymbol typeSymbol2 = GetWellKnownType(WellKnownType.System_Index, diagnostics, node);
            if ((object)boundExpression.Type != null && boundExpression.Type.IsNullableType())
            {
                GetSpecialTypeMember(SpecialMember.System_Nullable_T__ctor, diagnostics, node);
                NamedTypeSymbol specialType = GetSpecialType(SpecialType.System_Nullable_T, diagnostics, node);
                if (!typeSymbol2.IsNonNullableValueType())
                {
                    Error(diagnostics, ErrorCode.ERR_ValConstraintNotSatisfied, node, specialType, specialType.TypeParameters.Single(), typeSymbol2);
                }
                typeSymbol = specialType.Construct(typeSymbol);
                typeSymbol2 = specialType.Construct(typeSymbol2);
            }
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            Conversion conversion = Conversions.ClassifyImplicitConversionFromExpression(boundExpression, typeSymbol, ref useSiteInfo);
            diagnostics.Add(node, useSiteInfo);
            if (!conversion.IsValid)
            {
                GenerateImplicitConversionError(diagnostics, node, conversion, boundExpression, typeSymbol);
            }
            BoundExpression operand = CreateConversion(boundExpression, conversion, typeSymbol, diagnostics);
            MethodSymbol methodOpt = GetWellKnownTypeMember(WellKnownMember.System_Index__ctor, diagnostics, null, node) as MethodSymbol;
            return new BoundFromEndIndexExpression(node, operand, methodOpt, typeSymbol2);
        }

        private BoundExpression BindRangeExpression(RangeExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            CheckFeatureAvailability(node, MessageID.IDS_FeatureRangeOperator, diagnostics);
            TypeSymbol typeSymbol = GetWellKnownType(WellKnownType.System_Range, diagnostics, node);
            MethodSymbol methodSymbol = null;
            if (!typeSymbol.IsErrorType())
            {
                WellKnownMember? wellKnownMember = null;
                if (node.LeftOperand == null && node.RightOperand == null)
                {
                    wellKnownMember = WellKnownMember.System_Range__get_All;
                }
                else if (node.LeftOperand == null)
                {
                    wellKnownMember = WellKnownMember.System_Range__EndAt;
                }
                else if (node.RightOperand == null)
                {
                    wellKnownMember = WellKnownMember.System_Range__StartAt;
                }
                if (wellKnownMember.HasValue)
                {
                    methodSymbol = (MethodSymbol)GetWellKnownTypeMember(wellKnownMember.GetValueOrDefault(), diagnostics, null, node, isOptional: true);
                }
                if ((object)methodSymbol == null)
                {
                    methodSymbol = (MethodSymbol)GetWellKnownTypeMember(WellKnownMember.System_Range__ctor, diagnostics, null, node);
                }
            }
            BoundExpression boundExpression = BindRangeExpressionOperand(node.LeftOperand, diagnostics);
            BoundExpression boundExpression2 = BindRangeExpressionOperand(node.RightOperand, diagnostics);
            if ((boundExpression != null && boundExpression.Type.IsNullableType()) || (boundExpression2 != null && boundExpression2.Type.IsNullableType()))
            {
                GetSpecialType(SpecialType.System_Boolean, diagnostics, node);
                GetSpecialTypeMember(SpecialMember.System_Nullable_T__ctor, diagnostics, node);
                NamedTypeSymbol specialType = GetSpecialType(SpecialType.System_Nullable_T, diagnostics, node);
                if (!typeSymbol.IsNonNullableValueType())
                {
                    Error(diagnostics, ErrorCode.ERR_ValConstraintNotSatisfied, node, specialType, specialType.TypeParameters.Single(), typeSymbol);
                }
                typeSymbol = specialType.Construct(typeSymbol);
            }
            return new BoundRangeExpression(node, boundExpression, boundExpression2, methodSymbol, typeSymbol);
        }

        private BoundExpression BindRangeExpressionOperand(ExpressionSyntax operand, BindingDiagnosticBag diagnostics)
        {
            if (operand == null)
            {
                return null;
            }
            BoundExpression boundExpression = BindValue(operand, diagnostics, BindValueKind.RValue);
            TypeSymbol typeSymbol = GetWellKnownType(WellKnownType.System_Index, diagnostics, operand);
            TypeSymbol? type = boundExpression.Type;
            if ((object)type != null && type.IsNullableType())
            {
                GetSpecialTypeMember(SpecialMember.System_Nullable_T__ctor, diagnostics, operand);
                NamedTypeSymbol specialType = GetSpecialType(SpecialType.System_Nullable_T, diagnostics, operand);
                if (!typeSymbol.IsNonNullableValueType())
                {
                    Error(diagnostics, ErrorCode.ERR_ValConstraintNotSatisfied, operand, specialType, specialType.TypeParameters.Single(), typeSymbol);
                }
                typeSymbol = specialType.Construct(typeSymbol);
            }
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            Conversion conversion = Conversions.ClassifyImplicitConversionFromExpression(boundExpression, typeSymbol, ref useSiteInfo);
            diagnostics.Add(operand, useSiteInfo);
            if (!conversion.IsValid)
            {
                GenerateImplicitConversionError(diagnostics, operand, conversion, boundExpression, typeSymbol);
            }
            return CreateConversion(boundExpression, conversion, typeSymbol, diagnostics);
        }

        private BoundExpression BindCastCore(ExpressionSyntax node, BoundExpression operand, TypeWithAnnotations targetTypeWithAnnotations, bool wasCompilerGenerated, BindingDiagnosticBag diagnostics)
        {
            TypeSymbol type = targetTypeWithAnnotations.Type;
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            Conversion conversion = Conversions.ClassifyConversionFromExpression(operand, type, ref useSiteInfo, forCast: true);
            diagnostics.Add(node, useSiteInfo);
            ConversionGroup conversionGroupOpt = new ConversionGroup(conversion, targetTypeWithAnnotations);
            bool flag = operand.HasAnyErrors || type.IsErrorType();
            bool flag2 = !conversion.IsValid || type.IsStatic;
            if (flag2 && !flag)
            {
                GenerateExplicitConversionErrors(diagnostics, node, conversion, operand, type);
            }
            return CreateConversion(node, operand, conversion, isCast: true, conversionGroupOpt, wasCompilerGenerated, type, diagnostics, flag2 || flag);
        }

        private void GenerateExplicitConversionErrors(
            BindingDiagnosticBag diagnostics,
            SyntaxNode syntax,
            Conversion conversion,
            BoundExpression operand,
            TypeSymbol targetType)
        {
            // Make sure that errors within the unbound lambda don't get lost.
            if (operand.Kind == BoundKind.UnboundLambda)
            {
                GenerateAnonymousFunctionConversionError(diagnostics, operand.Syntax, (UnboundLambda)operand, targetType);
                return;
            }

            if (operand.HasAnyErrors || targetType.IsErrorType())
            {
                // an error has already been reported elsewhere
                return;
            }

            if (targetType.IsStatic)
            {
                // The specification states in the section titled "Referencing Static
                // Class Types" that it is always illegal to have a static class in a
                // cast operator.
                diagnostics.Add(ErrorCode.ERR_ConvertToStaticClass, syntax.Location, targetType);
                return;
            }

            if (!targetType.IsReferenceType && !targetType.IsNullableType() && operand.IsLiteralNull())
            {
                diagnostics.Add(ErrorCode.ERR_ValueCantBeNull, syntax.Location, targetType);
                return;
            }

            if (conversion.ResultKind == LookupResultKind.OverloadResolutionFailure)
            {
                ImmutableArray<MethodSymbol> originalUserDefinedConversions = conversion.OriginalUserDefinedConversions;
                if (originalUserDefinedConversions.Length > 1)
                {
                    diagnostics.Add(ErrorCode.ERR_AmbigUDConv, syntax.Location, originalUserDefinedConversions[0], originalUserDefinedConversions[1], operand.Display, targetType);
                }
                else
                {
                    SymbolDistinguisher distinguisher1 = new SymbolDistinguisher(this.Compilation, operand.Type, targetType);
                    diagnostics.Add(ErrorCode.ERR_NoExplicitConv, syntax.Location, distinguisher1.First, distinguisher1.Second);
                }

                return;
            }

            switch (operand.Kind)
            {
                case BoundKind.MethodGroup:
                    {
                        if (targetType.TypeKind != TypeKind.Delegate ||
                            !MethodGroupConversionDoesNotExistOrHasErrors((BoundMethodGroup)operand, (NamedTypeSymbol)targetType, syntax.Location, diagnostics, out _))
                        {
                            diagnostics.Add(ErrorCode.ERR_NoExplicitConv, syntax.Location, MessageID.IDS_SK_METHOD.Localize(), targetType);
                        }

                        return;
                    }
                case BoundKind.TupleLiteral:
                    {
                        var tuple = (BoundTupleLiteral)operand;
                        var targetElementTypesWithAnnotations = default(ImmutableArray<TypeWithAnnotations>);

                        // If target is a tuple or compatible type with the same number of elements,
                        // report errors for tuple arguments that failed to convert, which would be more useful.
                        if (targetType.TryGetElementTypesWithAnnotationsIfTupleType(out targetElementTypesWithAnnotations) &&
                            targetElementTypesWithAnnotations.Length == tuple.Arguments.Length)
                        {
                            GenerateExplicitConversionErrorsForTupleLiteralArguments(diagnostics, tuple.Arguments, targetElementTypesWithAnnotations);
                            return;
                        }

                        // target is not compatible with source and source does not have a type
                        if ((object)tuple.Type == null)
                        {
                            Error(diagnostics, ErrorCode.ERR_ConversionNotTupleCompatible, syntax, tuple.Arguments.Length, targetType);
                            return;
                        }

                        // Otherwise it is just a regular conversion failure from T1 to T2.
                        break;
                    }
                case BoundKind.StackAllocArrayCreation:
                    {
                        var stackAllocExpression = (BoundStackAllocArrayCreation)operand;
                        Error(diagnostics, ErrorCode.ERR_StackAllocConversionNotPossible, syntax, stackAllocExpression.ElementType, targetType);
                        return;
                    }
                case BoundKind.UnconvertedConditionalOperator when operand.Type is null:
                case BoundKind.UnconvertedSwitchExpression when operand.Type is null:
                    {
                        GenerateImplicitConversionError(diagnostics, operand.Syntax, conversion, operand, targetType);
                        return;
                    }
                case BoundKind.UnconvertedAddressOfOperator:
                    {
                        var errorCode = targetType.TypeKind switch
                        {
                            TypeKind.FunctionPointer => ErrorCode.ERR_MethFuncPtrMismatch,
                            TypeKind.Delegate => ErrorCode.ERR_CannotConvertAddressOfToDelegate,
                            _ => ErrorCode.ERR_AddressOfToNonFunctionPointer
                        };

                        diagnostics.Add(errorCode, syntax.Location, ((BoundUnconvertedAddressOfOperator)operand).Operand.Name, targetType);
                        return;
                    }
            }

            SymbolDistinguisher distinguisher = new SymbolDistinguisher(this.Compilation, operand.Type, targetType);
            diagnostics.Add(ErrorCode.ERR_NoExplicitConv, syntax.Location, distinguisher.First, distinguisher.Second);
        }

        private void GenerateExplicitConversionErrorsForTupleLiteralArguments(BindingDiagnosticBag diagnostics, ImmutableArray<BoundExpression> tupleArguments, ImmutableArray<TypeWithAnnotations> targetElementTypesWithAnnotations)
        {
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
            for (int i = 0; i < targetElementTypesWithAnnotations.Length; i++)
            {
                BoundExpression boundExpression = tupleArguments[i];
                TypeSymbol type = targetElementTypesWithAnnotations[i].Type;
                Conversion conversion = Conversions.ClassifyConversionFromExpression(boundExpression, type, ref useSiteInfo);
                if (!conversion.IsValid)
                {
                    GenerateExplicitConversionErrors(diagnostics, boundExpression.Syntax, conversion, boundExpression, type);
                }
            }
        }

        private BoundExpression BindExplicitNullableCastFromNonNullable(ExpressionSyntax node, BoundExpression operand, TypeWithAnnotations targetTypeWithAnnotations, BindingDiagnosticBag diagnostics)
        {
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
            TypeWithAnnotations nullableUnderlyingTypeWithAnnotations = targetTypeWithAnnotations.Type.GetNullableUnderlyingTypeWithAnnotations();
            if (!Conversions.ClassifyBuiltInConversion(operand.Type, nullableUnderlyingTypeWithAnnotations.Type, ref useSiteInfo).Exists)
            {
                return BindCastCore(node, operand, targetTypeWithAnnotations, operand.WasCompilerGenerated, diagnostics);
            }
            BindingDiagnosticBag bindingDiagnosticBag = new BindingDiagnosticBag(DiagnosticBag.GetInstance(), diagnostics.DependenciesBag);
            try
            {
                BoundExpression boundExpression = BindCastCore(node, operand, nullableUnderlyingTypeWithAnnotations, wasCompilerGenerated: false, bindingDiagnosticBag);
                if (boundExpression.HasErrors || bindingDiagnosticBag.HasAnyErrors())
                {
                    Error(diagnostics, ErrorCode.ERR_NoExplicitConv, node, operand.Type, targetTypeWithAnnotations.Type);
                    return new BoundConversion(node, operand, Conversion.NoConversion, CheckOverflowAtRuntime, explicitCastInCode: true, new ConversionGroup(Conversion.NoConversion, targetTypeWithAnnotations), null, targetTypeWithAnnotations.Type, hasErrors: true);
                }
                if (boundExpression.ConstantValue != null)
                {
                    boundExpression.WasCompilerGenerated = true;
                    return BindCastCore(node, boundExpression, targetTypeWithAnnotations, operand.WasCompilerGenerated, diagnostics);
                }
                return BindCastCore(node, operand, targetTypeWithAnnotations, operand.WasCompilerGenerated, diagnostics);
            }
            finally
            {
                bindingDiagnosticBag.DiagnosticBag!.Free();
            }
        }

        private static NameSyntax GetNameSyntax(SyntaxNode syntax)
        {
            return GetNameSyntax(syntax, out string nameString);
        }

        internal static NameSyntax GetNameSyntax(SyntaxNode syntax, out string nameString)
        {
            nameString = string.Empty;
            while (true)
            {
                switch (syntax.Kind())
                {
                    case SyntaxKind.PredefinedType:
                        nameString = ((PredefinedTypeSyntax)syntax).Keyword.ValueText;
                        return null;
                    case SyntaxKind.SimpleLambdaExpression:
                        nameString = MessageID.IDS_Lambda.Localize().ToString();
                        return null;
                    case SyntaxKind.ParenthesizedExpression:
                        syntax = ((ParenthesizedExpressionSyntax)syntax).Expression;
                        break;
                    case SyntaxKind.CastExpression:
                        syntax = ((CastExpressionSyntax)syntax).Expression;
                        break;
                    case SyntaxKind.SimpleMemberAccessExpression:
                    case SyntaxKind.PointerMemberAccessExpression:
                        return ((MemberAccessExpressionSyntax)syntax).Name;
                    case SyntaxKind.MemberBindingExpression:
                        return ((MemberBindingExpressionSyntax)syntax).Name;
                    default:
                        return syntax as NameSyntax;
                }
            }
        }

        private static string GetName(ExpressionSyntax syntax)
        {
            NameSyntax nameSyntax = GetNameSyntax(syntax, out string nameString);
            if (nameSyntax != null)
            {
                return nameSyntax.GetUnqualifiedName().Identifier.ValueText;
            }
            return nameString;
        }

        private void BindArgumentsAndNames(ArgumentListSyntax argumentListOpt, BindingDiagnosticBag diagnostics, AnalyzedArguments result, bool allowArglist = false, bool isDelegateCreation = false)
        {
            if (argumentListOpt != null)
            {
                BindArgumentsAndNames(argumentListOpt.Arguments, diagnostics, result, allowArglist, isDelegateCreation);
            }
        }

        private void BindArgumentsAndNames(BracketedArgumentListSyntax argumentListOpt, BindingDiagnosticBag diagnostics, AnalyzedArguments result)
        {
            if (argumentListOpt != null)
            {
                BindArgumentsAndNames(argumentListOpt.Arguments, diagnostics, result, allowArglist: false);
            }
        }

        private void BindArgumentsAndNames(SeparatedSyntaxList<ArgumentSyntax> arguments, BindingDiagnosticBag diagnostics, AnalyzedArguments result, bool allowArglist, bool isDelegateCreation = false)
        {
            bool hadError = false;
            bool hadLangVersionError = false;
            SeparatedSyntaxList<ArgumentSyntax>.Enumerator enumerator = arguments.GetEnumerator();
            while (enumerator.MoveNext())
            {
                ArgumentSyntax current = enumerator.Current;
                BindArgumentAndName(result, diagnostics, ref hadError, ref hadLangVersionError, current, allowArglist, isDelegateCreation);
            }
        }

        private bool RefMustBeObeyed(bool isDelegateCreation, ArgumentSyntax argumentSyntax)
        {
            if (Compilation.FeatureStrictEnabled || !isDelegateCreation)
            {
                return true;
            }
            switch (argumentSyntax.Expression.Kind())
            {
                case SyntaxKind.ParenthesizedExpression:
                case SyntaxKind.InvocationExpression:
                case SyntaxKind.AnonymousMethodExpression:
                case SyntaxKind.SimpleLambdaExpression:
                case SyntaxKind.ParenthesizedLambdaExpression:
                case SyntaxKind.ObjectCreationExpression:
                case SyntaxKind.ImplicitObjectCreationExpression:
                case SyntaxKind.DeclarationExpression:
                    return true;
                default:
                    return false;
            }
        }

        private void BindArgumentAndName(AnalyzedArguments result, BindingDiagnosticBag diagnostics, ref bool hadError, ref bool hadLangVersionError, ArgumentSyntax argumentSyntax, bool allowArglist, bool isDelegateCreation = false)
        {
            RefKind refKind = argumentSyntax.RefOrOutKeyword.Kind().GetRefKind();
            RefKind refKind2 = ((refKind == RefKind.None || RefMustBeObeyed(isDelegateCreation, argumentSyntax)) ? refKind : RefKind.None);
            BoundExpression boundArgumentExpression = BindArgumentValue(diagnostics, argumentSyntax, allowArglist, refKind2);
            BindArgumentAndName(result, diagnostics, ref hadLangVersionError, argumentSyntax, boundArgumentExpression, argumentSyntax.NameColon, refKind2);
            if (!hadError && isDelegateCreation && refKind != 0 && result.Arguments.Count == 1)
            {
                BoundExpression boundExpression = result.Argument(0);
                BoundKind kind = boundExpression.Kind;
                if (kind == BoundKind.PropertyAccess || kind == BoundKind.IndexerAccess)
                {
                    BindValueKind valueKind = ((refKind == RefKind.In) ? BindValueKind.ReadonlyRef : BindValueKind.RefOrOut);
                    hadError = !CheckValueKind(argumentSyntax, boundExpression, valueKind, checkingReceiver: false, diagnostics);
                    return;
                }
            }
            if (argumentSyntax.RefOrOutKeyword.Kind() != 0)
            {
                argumentSyntax.Expression.CheckDeconstructionCompatibleArgument(diagnostics);
            }
        }

        private BoundExpression BindArgumentValue(BindingDiagnosticBag diagnostics, ArgumentSyntax argumentSyntax, bool allowArglist, RefKind refKind)
        {
            if (argumentSyntax.Expression.Kind() == SyntaxKind.DeclarationExpression)
            {
                DeclarationExpressionSyntax declarationExpressionSyntax = (DeclarationExpressionSyntax)argumentSyntax.Expression;
                if (declarationExpressionSyntax.IsOutDeclaration())
                {
                    return BindOutDeclarationArgument(declarationExpressionSyntax, diagnostics);
                }
            }
            return BindArgumentExpression(diagnostics, argumentSyntax.Expression, refKind, allowArglist);
        }

        private BoundExpression BindOutDeclarationArgument(DeclarationExpressionSyntax declarationExpression, BindingDiagnosticBag diagnostics)
        {
            TypeSyntax type = declarationExpression.Type;
            VariableDesignationSyntax designation = declarationExpression.Designation;
            if (type.GetRefKind() != 0)
            {
                diagnostics.Add(ErrorCode.ERR_OutVariableCannotBeByRef, declarationExpression.Type.Location);
            }
            switch (designation.Kind())
            {
                case SyntaxKind.DiscardDesignation:
                    {
                        bool isConst = false;
                        return new BoundDiscardExpression(declarationExpression, BindVariableTypeWithAnnotations(designation, diagnostics, type, ref isConst, out bool isVar, out AliasSymbol alias).Type);
                    }
                case SyntaxKind.SingleVariableDesignation:
                    return BindOutVariableDeclarationArgument(declarationExpression, diagnostics);
                default:
                    throw ExceptionUtilities.UnexpectedValue(designation.Kind());
            }
        }

        private BoundExpression BindOutVariableDeclarationArgument(DeclarationExpressionSyntax declarationExpression, BindingDiagnosticBag diagnostics)
        {
            SingleVariableDesignationSyntax singleVariableDesignationSyntax = (SingleVariableDesignationSyntax)declarationExpression.Designation;
            TypeSyntax type = declarationExpression.Type;
            SourceLocalSymbol sourceLocalSymbol = LookupLocal(singleVariableDesignationSyntax.Identifier);
            bool isVar;
            if ((object)sourceLocalSymbol != null)
            {
                if ((InConstructorInitializer || InFieldInitializer) && ContainingMemberOrLambda!.ContainingSymbol.Kind == SymbolKind.NamedType)
                {
                    CheckFeatureAvailability(declarationExpression, MessageID.IDS_FeatureExpressionVariablesInQueriesAndInitializers, diagnostics);
                }
                bool isConst = false;
                TypeWithAnnotations typeWithAnnotations = BindVariableTypeWithAnnotations(declarationExpression, diagnostics, type, ref isConst, out isVar, out AliasSymbol alias);
                sourceLocalSymbol.ScopeBinder.ValidateDeclarationNameConflictsInScope(sourceLocalSymbol, diagnostics);
                if (isVar)
                {
                    return new OutVariablePendingInference(declarationExpression, sourceLocalSymbol, null);
                }
                CheckRestrictedTypeInAsyncMethod(ContainingMemberOrLambda, typeWithAnnotations.Type, diagnostics, type);
                return new BoundLocal(declarationExpression, sourceLocalSymbol, BoundLocalDeclarationKind.WithExplicitType, null, isNullableUnknown: false, typeWithAnnotations.Type);
            }
            GlobalExpressionVariable globalExpressionVariable = LookupDeclaredField(singleVariableDesignationSyntax);
            if ((object)globalExpressionVariable == null)
            {
                throw ExceptionUtilities.Unreachable;
            }
            BoundExpression boundExpression = SynthesizeReceiver(singleVariableDesignationSyntax, globalExpressionVariable, diagnostics);
            if (type.IsVar)
            {
                BindTypeOrAliasOrVarKeyword(type, BindingDiagnosticBag.Discarded, out isVar);
                if (isVar)
                {
                    return new OutVariablePendingInference(declarationExpression, globalExpressionVariable, boundExpression);
                }
            }
            TypeSymbol type2 = globalExpressionVariable.GetFieldType(FieldsBeingBound).Type;
            return new BoundFieldAccess(declarationExpression, boundExpression, globalExpressionVariable, null, LookupResultKind.Viable, isDeclaration: true, type2);
        }

        internal static bool CheckRestrictedTypeInAsyncMethod(Symbol containingSymbol, TypeSymbol type, BindingDiagnosticBag diagnostics, SyntaxNode syntax)
        {
            if (containingSymbol.Kind == SymbolKind.Method && ((MethodSymbol)containingSymbol).IsAsync && type.IsRestrictedType())
            {
                Error(diagnostics, ErrorCode.ERR_BadSpecialByRefLocal, syntax, type);
                return true;
            }
            return false;
        }

        internal GlobalExpressionVariable LookupDeclaredField(SingleVariableDesignationSyntax variableDesignator)
        {
            return LookupDeclaredField(variableDesignator, variableDesignator.Identifier.ValueText);
        }

        internal GlobalExpressionVariable LookupDeclaredField(SyntaxNode node, string identifier)
        {
            ImmutableArray<Symbol>.Enumerator enumerator = (ContainingType?.GetMembers(identifier) ?? ImmutableArray<Symbol>.Empty).GetEnumerator();
            while (enumerator.MoveNext())
            {
                Symbol current = enumerator.Current;
                GlobalExpressionVariable globalExpressionVariable;
                if (current.Kind == SymbolKind.Field && (globalExpressionVariable = current as GlobalExpressionVariable)?.SyntaxTree == node.SyntaxTree && globalExpressionVariable.SyntaxNode == node)
                {
                    return globalExpressionVariable;
                }
            }
            return null;
        }

        private void BindArgumentAndName(AnalyzedArguments result, BindingDiagnosticBag diagnostics, ref bool hadLangVersionError, CSharpSyntaxNode argumentSyntax, BoundExpression boundArgumentExpression, NameColonSyntax nameColonSyntax, RefKind refKind)
        {
            bool flag = result.RefKinds.Any();
            if (refKind != 0 && !flag)
            {
                flag = true;
                int count = result.Arguments.Count;
                for (int i = 0; i < count; i++)
                {
                    result.RefKinds.Add(RefKind.None);
                }
            }
            if (flag)
            {
                result.RefKinds.Add(refKind);
            }
            bool flag2 = result.Names.Any();
            if (nameColonSyntax != null)
            {
                if (!flag2)
                {
                    flag2 = true;
                    int count2 = result.Arguments.Count;
                    for (int j = 0; j < count2; j++)
                    {
                        result.Names.Add(null);
                    }
                }
                result.Names.Add(nameColonSyntax.Name);
            }
            else if (flag2)
            {
                if (!hadLangVersionError && !Compilation.LanguageVersion.AllowNonTrailingNamedArguments())
                {
                    Error(diagnostics, ErrorCode.ERR_NamedArgumentSpecificationBeforeFixedArgument, argumentSyntax, new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNonTrailingNamedArguments.RequiredVersion()));
                    hadLangVersionError = true;
                }
                result.Names.Add(null);
            }
            result.Arguments.Add(boundArgumentExpression);
        }

        private BoundExpression BindArgumentExpression(BindingDiagnosticBag diagnostics, ExpressionSyntax argumentExpression, RefKind refKind, bool allowArglist)
        {
            BindValueKind valueKind = refKind switch
            {
                RefKind.In => BindValueKind.ReadonlyRef,
                RefKind.None => BindValueKind.RValue,
                _ => BindValueKind.RefOrOut,
            };
            if (allowArglist)
            {
                return BindValueAllowArgList(argumentExpression, diagnostics, valueKind);
            }
            return BindValue(argumentExpression, diagnostics, valueKind);
        }

        private void CoerceArguments<TMember>(MemberResolutionResult<TMember> methodResult, ArrayBuilder<BoundExpression> arguments, BindingDiagnosticBag diagnostics) where TMember : Symbol
        {
            MemberAnalysisResult result = methodResult.Result;
            ImmutableArray<ParameterSymbol> parameters = methodResult.LeastOverriddenMember.GetParameters();
            for (int i = 0; i < arguments.Count; i++)
            {
                Conversion conversion = result.ConversionForArg(i);
                BoundExpression boundExpression = arguments[i];
                if (!conversion.IsIdentity)
                {
                    TypeWithAnnotations correspondingParameterTypeWithAnnotations = GetCorrespondingParameterTypeWithAnnotations(ref result, parameters, i);
                    if (!methodResult.Member.IsIndexer() && !boundExpression.HasAnyErrors && correspondingParameterTypeWithAnnotations.Type.IsUnsafe())
                    {
                        ReportUnsafeIfNotAllowed(boundExpression.Syntax, diagnostics);
                    }
                    arguments[i] = CreateConversion(boundExpression.Syntax, boundExpression, conversion, isCast: false, null, correspondingParameterTypeWithAnnotations.Type, diagnostics);
                }
                else if (boundExpression.Kind == BoundKind.OutVariablePendingInference)
                {
                    TypeWithAnnotations correspondingParameterTypeWithAnnotations2 = GetCorrespondingParameterTypeWithAnnotations(ref result, parameters, i);
                    arguments[i] = ((OutVariablePendingInference)boundExpression).SetInferredTypeWithAnnotations(correspondingParameterTypeWithAnnotations2, diagnostics);
                }
                else if (boundExpression.Kind == BoundKind.OutDeconstructVarPendingInference)
                {
                    TypeWithAnnotations correspondingParameterTypeWithAnnotations3 = GetCorrespondingParameterTypeWithAnnotations(ref result, parameters, i);
                    arguments[i] = ((OutDeconstructVarPendingInference)boundExpression).SetInferredTypeWithAnnotations(correspondingParameterTypeWithAnnotations3, this, success: true);
                }
                else if (boundExpression.Kind == BoundKind.DiscardExpression && !boundExpression.HasExpressionType())
                {
                    TypeWithAnnotations correspondingParameterTypeWithAnnotations4 = GetCorrespondingParameterTypeWithAnnotations(ref result, parameters, i);
                    arguments[i] = ((BoundDiscardExpression)boundExpression).SetInferredTypeWithAnnotations(correspondingParameterTypeWithAnnotations4);
                }
                else if (boundExpression.NeedsToBeConverted())
                {
                    if (boundExpression is BoundTupleLiteral)
                    {
                        arguments[i] = CreateConversion(destination: GetCorrespondingParameterTypeWithAnnotations(ref result, parameters, i).Type, syntax: boundExpression.Syntax, source: boundExpression, conversion: conversion, isCast: false, conversionGroupOpt: null, diagnostics: diagnostics);
                    }
                    else
                    {
                        arguments[i] = BindToNaturalType(boundExpression, diagnostics);
                    }
                }
            }
        }

        private static TypeWithAnnotations GetCorrespondingParameterTypeWithAnnotations(ref MemberAnalysisResult result, ImmutableArray<ParameterSymbol> parameters, int arg)
        {
            int num = result.ParameterFromArgument(arg);
            TypeWithAnnotations result2 = parameters[num].TypeWithAnnotations;
            if (num == parameters.Length - 1 && result.Kind == MemberResolutionKind.ApplicableInExpandedForm)
            {
                result2 = ((ArrayTypeSymbol)result2.Type).ElementTypeWithAnnotations;
            }
            return result2;
        }

        private BoundExpression BindArrayCreationExpression(ArrayCreationExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            ArrayTypeSymbol type = (ArrayTypeSymbol)BindArrayType(node.Type, diagnostics, permitDimensions: true, null, disallowRestrictedTypes: true).Type;
            ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
            ArrayRankSpecifierSyntax arrayRankSpecifierSyntax = node.Type.RankSpecifiers[0];
            bool hasErrors = false;
            SeparatedSyntaxList<ExpressionSyntax>.Enumerator enumerator = arrayRankSpecifierSyntax.Sizes.GetEnumerator();
            while (enumerator.MoveNext())
            {
                ExpressionSyntax current = enumerator.Current;
                BoundExpression boundExpression = BindArrayDimension(current, diagnostics, ref hasErrors);
                if (boundExpression != null)
                {
                    instance.Add(boundExpression);
                }
                else if (node.Initializer == null && current == arrayRankSpecifierSyntax.Sizes[0])
                {
                    Error(diagnostics, ErrorCode.ERR_MissingArraySize, arrayRankSpecifierSyntax);
                    hasErrors = true;
                }
            }
            for (int i = 1; i < node.Type.RankSpecifiers.Count; i++)
            {
                enumerator = node.Type.RankSpecifiers[i].Sizes.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    ExpressionSyntax current2 = enumerator.Current;
                    if (current2.Kind() != SyntaxKind.OmittedArraySizeExpression)
                    {
                        BoundExpression item = BindRValueWithoutTargetType(current2, diagnostics);
                        Error(diagnostics, ErrorCode.ERR_InvalidArray, current2);
                        hasErrors = true;
                        instance.Add(item);
                    }
                }
            }
            ImmutableArray<BoundExpression> immutableArray = instance.ToImmutableAndFree();
            if (node.Initializer != null)
            {
                InitializerExpressionSyntax? initializer = node.Initializer;
                bool hasErrors2 = hasErrors;
                return BindArrayCreationWithInitializer(diagnostics, node, initializer, type, immutableArray, default(ImmutableArray<BoundExpression>), hasErrors2);
            }
            return new BoundArrayCreation(node, immutableArray, null, type, hasErrors);
        }

        private BoundExpression BindArrayDimension(ExpressionSyntax dimension, BindingDiagnosticBag diagnostics, ref bool hasErrors)
        {
            if (dimension.Kind() != SyntaxKind.OmittedArraySizeExpression)
            {
                BoundExpression boundExpression = BindValue(dimension, diagnostics, BindValueKind.RValue);
                if (!boundExpression.HasAnyErrors)
                {
                    boundExpression = ConvertToArrayIndex(boundExpression, dimension, diagnostics, allowIndexAndRange: false);
                    if (IsNegativeConstantForArraySize(boundExpression))
                    {
                        Error(diagnostics, ErrorCode.ERR_NegativeArraySize, dimension);
                        hasErrors = true;
                    }
                }
                else
                {
                    boundExpression = BindToTypeForErrorRecovery(boundExpression);
                }
                return boundExpression;
            }
            return null;
        }

        private BoundExpression BindImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            InitializerExpressionSyntax initializer = node.Initializer;
            int rank = node.Commas.Count + 1;
            ImmutableArray<BoundExpression> immutableArray = BindArrayInitializerExpressions(initializer, diagnostics, 1, rank);
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            TypeSymbol typeSymbol = BestTypeInferrer.InferBestType(immutableArray, Conversions, ref useSiteInfo);
            diagnostics.Add(node, useSiteInfo);
            if ((object)typeSymbol == null || typeSymbol.IsVoidType())
            {
                Error(diagnostics, ErrorCode.ERR_ImplicitlyTypedArrayNoBestType, node);
                typeSymbol = CreateErrorType();
            }
            if (typeSymbol.IsRestrictedType())
            {
                Error(diagnostics, ErrorCode.ERR_ArrayElementCantBeRefAny, node, typeSymbol);
            }
            ArrayTypeSymbol type = ArrayTypeSymbol.CreateCSharpArray(Compilation.Assembly, TypeWithAnnotations.Create(typeSymbol), rank);
            return BindArrayCreationWithInitializer(diagnostics, node, initializer, type, ImmutableArray<BoundExpression>.Empty, immutableArray);
        }

        private BoundExpression BindImplicitStackAllocArrayCreationExpression(ImplicitStackAllocArrayCreationExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            InitializerExpressionSyntax initializer = node.Initializer;
            ImmutableArray<BoundExpression> immutableArray = BindArrayInitializerExpressions(initializer, diagnostics, 1, 1);
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            TypeSymbol typeSymbol = BestTypeInferrer.InferBestType(immutableArray, Conversions, ref useSiteInfo);
            diagnostics.Add(node, useSiteInfo);
            if ((object)typeSymbol == null || typeSymbol.IsVoidType())
            {
                Error(diagnostics, ErrorCode.ERR_ImplicitlyTypedArrayNoBestType, node);
                typeSymbol = CreateErrorType();
            }
            if (!typeSymbol.IsErrorType())
            {
                CheckManagedAddr(Compilation, typeSymbol, node.Location, diagnostics);
            }
            return BindStackAllocWithInitializer(node, initializer, GetStackAllocType(node, TypeWithAnnotations.Create(typeSymbol), diagnostics, out bool hasErrors), typeSymbol, null, diagnostics, hasErrors, immutableArray);
        }

        private ImmutableArray<BoundExpression> BindArrayInitializerExpressions(InitializerExpressionSyntax initializer, BindingDiagnosticBag diagnostics, int dimension, int rank)
        {
            ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
            BindArrayInitializerExpressions(initializer, instance, diagnostics, dimension, rank);
            return instance.ToImmutableAndFree();
        }

        private void BindArrayInitializerExpressions(InitializerExpressionSyntax initializer, ArrayBuilder<BoundExpression> exprBuilder, BindingDiagnosticBag diagnostics, int dimension, int rank)
        {
            SeparatedSyntaxList<ExpressionSyntax>.Enumerator enumerator;
            if (dimension == rank)
            {
                enumerator = initializer.Expressions.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    ExpressionSyntax current = enumerator.Current;
                    BoundExpression item = BindValue(current, diagnostics, BindValueKind.RValue);
                    exprBuilder.Add(item);
                }
                return;
            }
            enumerator = initializer.Expressions.GetEnumerator();
            while (enumerator.MoveNext())
            {
                ExpressionSyntax current2 = enumerator.Current;
                if (current2.Kind() == SyntaxKind.ArrayInitializerExpression)
                {
                    BindArrayInitializerExpressions((InitializerExpressionSyntax)current2, exprBuilder, diagnostics, dimension + 1, rank);
                    continue;
                }
                BoundExpression boundExpression = BindValue(current2, diagnostics, BindValueKind.RValue);
                if ((object)boundExpression.Type == null || !boundExpression.Type.IsErrorType())
                {
                    if (!boundExpression.HasAnyErrors)
                    {
                        Error(diagnostics, ErrorCode.ERR_ArrayInitializerExpected, current2);
                    }
                    boundExpression = BadExpression(current2, LookupResultKind.Empty, ImmutableArray.Create(boundExpression.ExpressionSymbol), ImmutableArray.Create(boundExpression));
                }
                exprBuilder.Add(boundExpression);
            }
        }

        private BoundArrayInitialization ConvertAndBindArrayInitialization(BindingDiagnosticBag diagnostics, InitializerExpressionSyntax node, ArrayTypeSymbol type, int?[] knownSizes, int dimension, ImmutableArray<BoundExpression> boundInitExpr, ref int boundInitExprIndex)
        {
            ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
            if (dimension == type.Rank)
            {
                TypeSymbol elementType = type.ElementType;
                SeparatedSyntaxList<ExpressionSyntax>.Enumerator enumerator = node.Expressions.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    _ = enumerator.Current;
                    BoundExpression expression = boundInitExpr[boundInitExprIndex];
                    boundInitExprIndex++;
                    BoundExpression item = GenerateConversionForAssignment(elementType, expression, diagnostics);
                    instance.Add(item);
                }
            }
            else
            {
                SeparatedSyntaxList<ExpressionSyntax>.Enumerator enumerator = node.Expressions.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    ExpressionSyntax current = enumerator.Current;
                    BoundExpression boundExpression = null;
                    if (current.Kind() == SyntaxKind.ArrayInitializerExpression)
                    {
                        boundExpression = ConvertAndBindArrayInitialization(diagnostics, (InitializerExpressionSyntax)current, type, knownSizes, dimension + 1, boundInitExpr, ref boundInitExprIndex);
                    }
                    else
                    {
                        boundExpression = boundInitExpr[boundInitExprIndex];
                        boundInitExprIndex++;
                    }
                    instance.Add(boundExpression);
                }
            }
            bool hasErrors = false;
            int? num = knownSizes[dimension - 1];
            if (!num.HasValue)
            {
                knownSizes[dimension - 1] = instance.Count;
            }
            else if (num != instance.Count && num >= 0)
            {
                Error(diagnostics, ErrorCode.ERR_ArrayInitializerIncorrectLength, node, num.Value);
                hasErrors = true;
            }
            return new BoundArrayInitialization(node, instance.ToImmutableAndFree(), hasErrors);
        }

        private BoundArrayInitialization BindArrayInitializerList(BindingDiagnosticBag diagnostics, InitializerExpressionSyntax node, ArrayTypeSymbol type, int?[] knownSizes, int dimension, ImmutableArray<BoundExpression> boundInitExprOpt = default(ImmutableArray<BoundExpression>))
        {
            if (boundInitExprOpt.IsDefault)
            {
                boundInitExprOpt = BindArrayInitializerExpressions(node, diagnostics, dimension, type.Rank);
            }
            int boundInitExprIndex = 0;
            return ConvertAndBindArrayInitialization(diagnostics, node, type, knownSizes, dimension, boundInitExprOpt, ref boundInitExprIndex);
        }

        private BoundArrayInitialization BindUnexpectedArrayInitializer(InitializerExpressionSyntax node, BindingDiagnosticBag diagnostics, ErrorCode errorCode, CSharpSyntaxNode errorNode = null)
        {
            BoundArrayInitialization boundArrayInitialization = BindArrayInitializerList(diagnostics, node, Compilation.CreateArrayTypeSymbol(GetSpecialType(SpecialType.System_Object, diagnostics, node)), new int?[1], 1);
            if (!boundArrayInitialization.HasAnyErrors)
            {
                boundArrayInitialization = new BoundArrayInitialization(node, boundArrayInitialization.Initializers, hasErrors: true);
            }
            Error(diagnostics, errorCode, errorNode ?? node);
            return boundArrayInitialization;
        }

        private BoundArrayCreation BindArrayCreationWithInitializer(BindingDiagnosticBag diagnostics, ExpressionSyntax creationSyntax, InitializerExpressionSyntax initSyntax, ArrayTypeSymbol type, ImmutableArray<BoundExpression> sizes, ImmutableArray<BoundExpression> boundInitExprOpt = default(ImmutableArray<BoundExpression>), bool hasErrors = false)
        {
            int rank = type.Rank;
            int length = sizes.Length;
            int?[] array = new int?[Math.Max(rank, length)];
            for (int i = 0; i < length; i++)
            {
                BoundExpression boundExpression = sizes[i];
                array[i] = GetIntegerConstantForArraySize(boundExpression);
                if (!boundExpression.HasAnyErrors && !array[i].HasValue)
                {
                    Error(diagnostics, ErrorCode.ERR_ConstantExpected, boundExpression.Syntax);
                    hasErrors = true;
                }
            }
            BoundArrayInitialization boundArrayInitialization = BindArrayInitializerList(diagnostics, initSyntax, type, array, 1, boundInitExprOpt);
            hasErrors = hasErrors || boundArrayInitialization.HasAnyErrors;
            bool flag = creationSyntax != null;
            CSharpSyntaxNode cSharpSyntaxNode = creationSyntax ?? initSyntax;
            if (length == 0)
            {
                BoundExpression[] array2 = new BoundExpression[rank];
                for (int j = 0; j < rank; j++)
                {
                    array2[j] = new BoundLiteral(cSharpSyntaxNode, ConstantValue.Create(array[j].GetValueOrDefault()), GetSpecialType(SpecialType.System_Int32, diagnostics, cSharpSyntaxNode))
                    {
                        WasCompilerGenerated = true
                    };
                }
                sizes = array2.AsImmutableOrNull();
            }
            else if (!hasErrors && rank != length)
            {
                Error(diagnostics, ErrorCode.ERR_BadIndexCount, cSharpSyntaxNode, type.Rank);
                hasErrors = true;
            }
            return new BoundArrayCreation(cSharpSyntaxNode, sizes, boundArrayInitialization, type, hasErrors)
            {
                WasCompilerGenerated = (!flag && (initSyntax.Parent == null || initSyntax.Parent!.Kind() != SyntaxKind.EqualsValueClause || ((EqualsValueClauseSyntax)initSyntax.Parent).Value != initSyntax))
            };
        }

        private BoundExpression BindStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            TypeSyntax type = node.Type;
            if (type.Kind() != SyntaxKind.ArrayType)
            {
                Error(diagnostics, ErrorCode.ERR_BadStackAllocExpr, type);
                return new BoundBadExpression(node, LookupResultKind.NotCreatable, ImmutableArray<Symbol>.Empty, ImmutableArray<BoundExpression>.Empty, new PointerTypeSymbol(BindType(type, diagnostics)));
            }
            ArrayTypeSyntax arrayTypeSyntax = (ArrayTypeSyntax)type;
            TypeSyntax elementType = arrayTypeSyntax.ElementType;
            TypeWithAnnotations elementTypeWithAnnotations = ((ArrayTypeSymbol)BindArrayType(arrayTypeSyntax, diagnostics, permitDimensions: true, null, disallowRestrictedTypes: false).Type).ElementTypeWithAnnotations;
            TypeSymbol stackAllocType = GetStackAllocType(node, elementTypeWithAnnotations, diagnostics, out bool hasErrors);
            if (!elementTypeWithAnnotations.Type.IsErrorType())
            {
                hasErrors = hasErrors || CheckManagedAddr(Compilation, elementTypeWithAnnotations.Type, elementType.Location, diagnostics);
            }
            SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers = arrayTypeSyntax.RankSpecifiers;
            if (rankSpecifiers.Count != 1 || rankSpecifiers[0].Sizes.Count != 1)
            {
                Error(diagnostics, ErrorCode.ERR_BadStackAllocExpr, type);
                ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
                SyntaxList<ArrayRankSpecifierSyntax>.Enumerator enumerator = rankSpecifiers.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    SeparatedSyntaxList<ExpressionSyntax>.Enumerator enumerator2 = enumerator.Current.Sizes.GetEnumerator();
                    while (enumerator2.MoveNext())
                    {
                        ExpressionSyntax current = enumerator2.Current;
                        if (current.Kind() != SyntaxKind.OmittedArraySizeExpression)
                        {
                            instance.Add(BindExpression(current, BindingDiagnosticBag.Discarded));
                        }
                    }
                }
                return new BoundBadExpression(node, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, instance.ToImmutableAndFree(), new PointerTypeSymbol(elementTypeWithAnnotations));
            }
            ExpressionSyntax expressionSyntax = rankSpecifiers[0].Sizes[0];
            BoundExpression boundExpression = null;
            if (expressionSyntax.Kind() != SyntaxKind.OmittedArraySizeExpression)
            {
                boundExpression = BindValue(expressionSyntax, diagnostics, BindValueKind.RValue);
                boundExpression = GenerateConversionForAssignment(GetSpecialType(SpecialType.System_Int32, diagnostics, node), boundExpression, diagnostics);
                if (IsNegativeConstantForArraySize(boundExpression))
                {
                    Error(diagnostics, ErrorCode.ERR_NegativeStackAllocSize, expressionSyntax);
                    hasErrors = true;
                }
            }
            else if (node.Initializer == null)
            {
                Error(diagnostics, ErrorCode.ERR_MissingArraySize, rankSpecifiers[0]);
                boundExpression = BadExpression(expressionSyntax);
                hasErrors = true;
            }
            if (node.Initializer != null)
            {
                return BindStackAllocWithInitializer(node, node.Initializer, stackAllocType, elementTypeWithAnnotations.Type, boundExpression, diagnostics, hasErrors);
            }
            return new BoundStackAllocArrayCreation(node, elementTypeWithAnnotations.Type, boundExpression, null, stackAllocType, hasErrors);
        }

        private bool ReportBadStackAllocPosition(SyntaxNode node, BindingDiagnosticBag diagnostics)
        {
            bool flag = true;
            if (MessageID.IDS_FeatureNestedStackalloc.RequiredVersion() > Compilation.LanguageVersion)
            {
                flag = (IsInMethodBody || IsLocalFunctionsScopeBinder) && node.IsLegalCSharp73SpanStackAllocPosition();
                if (!flag)
                {
                    MessageID.IDS_FeatureNestedStackalloc.CheckFeatureAvailability(diagnostics, node, node.GetFirstToken().GetLocation());
                }
            }
            if (Flags.IncludesAny(BinderFlags.InCatchBlock | BinderFlags.InFinallyBlock | BinderFlags.InCatchFilter))
            {
                Error(diagnostics, ErrorCode.ERR_StackallocInCatchFinally, node);
            }
            return flag;
        }

        private TypeSymbol GetStackAllocType(SyntaxNode node, TypeWithAnnotations elementTypeWithAnnotations, BindingDiagnosticBag diagnostics, out bool hasErrors)
        {
            bool flag = ReportBadStackAllocPosition(node, diagnostics);
            hasErrors = !flag;
            if (flag && !isStackallocTargetTyped(node))
            {
                CheckFeatureAvailability(node, MessageID.IDS_FeatureRefStructs, diagnostics);
                NamedTypeSymbol wellKnownType = GetWellKnownType(WellKnownType.System_Span_T, diagnostics, node);
                return ConstructNamedType(wellKnownType, (node.Kind() == SyntaxKind.StackAllocArrayCreationExpression) ? ((StackAllocArrayCreationExpressionSyntax)node).Type : node, default(SeparatedSyntaxList<TypeSyntax>), ImmutableArray.Create(elementTypeWithAnnotations), null, diagnostics);
            }
            return null;
            static bool isStackallocTargetTyped(SyntaxNode node)
            {
                SyntaxNode parent = node.Parent;
                if (!parent.IsKind(SyntaxKind.EqualsValueClause))
                {
                    return false;
                }
                SyntaxNode parent2 = parent.Parent;
                if (!parent2.IsKind(SyntaxKind.VariableDeclarator))
                {
                    return false;
                }
                SyntaxNode parent3 = parent2.Parent;
                if (!parent3.IsKind(SyntaxKind.VariableDeclaration))
                {
                    return false;
                }
                if (!parent3.Parent.IsKind(SyntaxKind.LocalDeclarationStatement))
                {
                    return parent3.Parent.IsKind(SyntaxKind.ForStatement);
                }
                return true;
            }
        }

        private BoundExpression BindStackAllocWithInitializer(SyntaxNode node, InitializerExpressionSyntax initSyntax, TypeSymbol type, TypeSymbol elementType, BoundExpression sizeOpt, BindingDiagnosticBag diagnostics, bool hasErrors, ImmutableArray<BoundExpression> boundInitExprOpt = default(ImmutableArray<BoundExpression>))
        {
            if (boundInitExprOpt.IsDefault)
            {
                boundInitExprOpt = BindArrayInitializerExpressions(initSyntax, diagnostics, 1, 1);
            }
            boundInitExprOpt = boundInitExprOpt.SelectAsArray((BoundExpression expr, (TypeSymbol elementType, BindingDiagnosticBag diagnostics) t) => GenerateConversionForAssignment(t.elementType, expr, t.diagnostics), (elementType, diagnostics));
            if (sizeOpt != null)
            {
                if (!sizeOpt.HasAnyErrors)
                {
                    int? integerConstantForArraySize = GetIntegerConstantForArraySize(sizeOpt);
                    if (!integerConstantForArraySize.HasValue)
                    {
                        Error(diagnostics, ErrorCode.ERR_ConstantExpected, sizeOpt.Syntax);
                        hasErrors = true;
                    }
                    else if (boundInitExprOpt.Length != integerConstantForArraySize)
                    {
                        Error(diagnostics, ErrorCode.ERR_ArrayInitializerIncorrectLength, node, integerConstantForArraySize.Value);
                        hasErrors = true;
                    }
                }
            }
            else
            {
                sizeOpt = new BoundLiteral(node, ConstantValue.Create(boundInitExprOpt.Length), GetSpecialType(SpecialType.System_Int32, diagnostics, node))
                {
                    WasCompilerGenerated = true
                };
            }
            return new BoundStackAllocArrayCreation(node, elementType, sizeOpt, new BoundArrayInitialization(initSyntax, boundInitExprOpt), type, hasErrors);
        }

        private static int? GetIntegerConstantForArraySize(BoundExpression expression)
        {
            if (expression.HasAnyErrors)
            {
                return null;
            }
            ConstantValue constantValue = expression.ConstantValue;
            if (constantValue == null || constantValue.IsBad || expression.Type!.SpecialType != SpecialType.System_Int32)
            {
                return null;
            }
            return constantValue.Int32Value;
        }

        private static bool IsNegativeConstantForArraySize(BoundExpression expression)
        {
            if (expression.HasAnyErrors)
            {
                return false;
            }
            ConstantValue constantValue = expression.ConstantValue;
            if (constantValue == null || constantValue.IsBad)
            {
                return false;
            }
            return expression.Type!.SpecialType switch
            {
                SpecialType.System_Int32 => constantValue.Int32Value < 0,
                SpecialType.System_Int64 => constantValue.Int64Value < 0,
                _ => false,
            };
        }

        internal BoundExpression BindConstructorInitializer(ArgumentListSyntax initializerArgumentListOpt, MethodSymbol constructor, BindingDiagnosticBag diagnostics)
        {
            Binder binder = null;
            if (initializerArgumentListOpt != null)
            {
                binder = GetBinder(initializerArgumentListOpt);
            }
            BoundExpression boundExpression = (binder ?? this).BindConstructorInitializerCore(initializerArgumentListOpt, constructor, diagnostics);
            if (binder != null)
            {
                boundExpression = binder.WrapWithVariablesIfAny(initializerArgumentListOpt, boundExpression);
            }
            return boundExpression;
        }

        private BoundExpression BindConstructorInitializerCore(ArgumentListSyntax initializerArgumentListOpt, MethodSymbol constructor, BindingDiagnosticBag diagnostics)
        {
            NamedTypeSymbol containingType = constructor.ContainingType;
            if ((containingType.TypeKind == TypeKind.Enum || containingType.TypeKind == TypeKind.Struct) && initializerArgumentListOpt == null)
            {
                return null;
            }
            AnalyzedArguments instance = AnalyzedArguments.GetInstance();
            try
            {
                TypeSymbol returnType = constructor.ReturnType;
                NamedTypeSymbol baseTypeNoUseSiteDiagnostics = containingType.BaseTypeNoUseSiteDiagnostics;
                if (initializerArgumentListOpt != null)
                {
                    BindArgumentsAndNames(initializerArgumentListOpt, diagnostics, instance, allowArglist: true);
                }
                NamedTypeSymbol namedTypeSymbol = containingType;
                bool flag = initializerArgumentListOpt == null || initializerArgumentListOpt.Parent!.Kind() != SyntaxKind.ThisConstructorInitializer;
                if (flag)
                {
                    namedTypeSymbol = namedTypeSymbol.BaseTypeNoUseSiteDiagnostics;
                    if ((object)namedTypeSymbol == null || containingType.SpecialType == SpecialType.System_Object)
                    {
                        if (initializerArgumentListOpt == null)
                        {
                            return null;
                        }
                        diagnostics.Add(ErrorCode.ERR_ObjectCallingBaseConstructor, constructor.Locations[0], containingType);
                        return new BoundBadExpression(initializerArgumentListOpt.Parent, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, BuildArgumentsForErrorRecovery(instance), returnType);
                    }
                    if (initializerArgumentListOpt != null && containingType.TypeKind == TypeKind.Struct)
                    {
                        diagnostics.Add(ErrorCode.ERR_StructWithBaseConstructorCall, constructor.Locations[0], containingType);
                        return new BoundBadExpression(initializerArgumentListOpt.Parent, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, BuildArgumentsForErrorRecovery(instance), returnType);
                    }
                }
                CSharpSyntaxNode cSharpSyntaxNode = initializerArgumentListOpt?.Parent;
                CSharpSyntaxNode cSharpSyntaxNode2;
                Location location;
                bool enableCallerInfo;
                if (!(cSharpSyntaxNode is ConstructorInitializerSyntax constructorInitializerSyntax))
                {
                    if (cSharpSyntaxNode is PrimaryConstructorBaseTypeSyntax primaryConstructorBaseTypeSyntax)
                    {
                        cSharpSyntaxNode2 = primaryConstructorBaseTypeSyntax;
                        location = initializerArgumentListOpt.GetLocation();
                        enableCallerInfo = true;
                    }
                    else
                    {
                        cSharpSyntaxNode2 = constructor.GetNonNullSyntaxNode();
                        location = constructor.Locations[0];
                        enableCallerInfo = false;
                    }
                }
                else
                {
                    cSharpSyntaxNode2 = constructorInitializerSyntax;
                    location = constructorInitializerSyntax.ThisOrBaseKeyword.GetLocation();
                    enableCallerInfo = true;
                }
                if (initializerArgumentListOpt != null && instance.HasDynamicArgument)
                {
                    diagnostics.Add(ErrorCode.ERR_NoDynamicPhantomOnBaseCtor, location);
                    return new BoundBadExpression(initializerArgumentListOpt.Parent, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, BuildArgumentsForErrorRecovery(instance), returnType);
                }
                BoundExpression boundExpression = ThisReference(cSharpSyntaxNode2, namedTypeSymbol, hasErrors: false, wasCompilerGenerated: true);
                bool num = TryPerformConstructorOverloadResolution(namedTypeSymbol, instance, ".ctor", location, suppressResultDiagnostics: false, diagnostics, out MemberResolutionResult<MethodSymbol> memberResolutionResult, out ImmutableArray<MethodSymbol> candidateConstructors, allowProtectedConstructorsOfBaseType: true);
                MethodSymbol member = memberResolutionResult.Member;
                validateRecordCopyConstructor(constructor, baseTypeNoUseSiteDiagnostics, member, location, diagnostics);
                if (num)
                {
                    bool flag2 = false;
                    if (member == constructor)
                    {
                        diagnostics.Add(ErrorCode.ERR_RecursiveConstructorCall, location, constructor);
                        flag2 = true;
                    }
                    else if (member.HasUnsafeParameter())
                    {
                        flag2 = ReportUnsafeIfNotAllowed(location, diagnostics);
                    }
                    ReportDiagnosticsIfObsolete(diagnostics, member, cSharpSyntaxNode2, flag);
                    bool expanded = memberResolutionResult.Result.Kind == MemberResolutionKind.ApplicableInExpandedForm;
                    ImmutableArray<int> argsToParamsOpt = memberResolutionResult.Result.ArgsToParamsOpt;
                    BindDefaultArguments(cSharpSyntaxNode2, member.Parameters, instance.Arguments, instance.RefKinds, ref argsToParamsOpt, out var defaultArguments, expanded, enableCallerInfo, diagnostics);
                    ImmutableArray<BoundExpression> immutableArray = instance.Arguments.ToImmutable();
                    ImmutableArray<RefKind> argumentRefKindsOpt = instance.RefKinds.ToImmutableOrNull();
                    if (!flag2)
                    {
                        flag2 = !CheckInvocationArgMixing(cSharpSyntaxNode2, member, boundExpression, member.Parameters, immutableArray, argsToParamsOpt, LocalScopeDepth, diagnostics);
                    }
                    return new BoundCall(cSharpSyntaxNode2, boundExpression, member, immutableArray, instance.GetNames(), argumentRefKindsOpt, isDelegateCall: false, expanded, invokedAsExtensionMethod: false, argsToParamsOpt, defaultArguments, LookupResultKind.Viable, returnType, flag2)
                    {
                        WasCompilerGenerated = (initializerArgumentListOpt == null)
                    };
                }
                BoundCall boundCall = CreateBadCall(cSharpSyntaxNode2, ".ctor", boundExpression, candidateConstructors, LookupResultKind.OverloadResolutionFailure, ImmutableArray<TypeWithAnnotations>.Empty, instance, invokedAsExtensionMethod: false, isDelegate: false);
                boundCall.WasCompilerGenerated = initializerArgumentListOpt == null;
                return boundCall;
            }
            finally
            {
                instance.Free();
            }
            static void validateRecordCopyConstructor(MethodSymbol constructor, NamedTypeSymbol baseType, MethodSymbol resultMember, Location errorLocation, BindingDiagnosticBag diagnostics)
            {
                if (IsUserDefinedRecordCopyConstructor(constructor))
                {
                    if (baseType.SpecialType == SpecialType.System_Object)
                    {
                        if ((object)resultMember == null || resultMember.ContainingType.SpecialType != SpecialType.System_Object)
                        {
                            diagnostics.Add(ErrorCode.ERR_CopyConstructorMustInvokeBaseCopyConstructor, errorLocation);
                        }
                    }
                    else if ((object)resultMember == null || !SynthesizedRecordCopyCtor.HasCopyConstructorSignature(resultMember))
                    {
                        diagnostics.Add(ErrorCode.ERR_CopyConstructorMustInvokeBaseCopyConstructor, errorLocation);
                    }
                }
            }
        }

        internal static bool IsUserDefinedRecordCopyConstructor(MethodSymbol constructor)
        {
            if (constructor.ContainingType is SourceNamedTypeSymbol sourceNamedTypeSymbol && sourceNamedTypeSymbol.IsRecord && !(constructor is SynthesizedRecordConstructor))
            {
                return SynthesizedRecordCopyCtor.HasCopyConstructorSignature(constructor);
            }
            return false;
        }

        private BoundExpression BindImplicitObjectCreationExpression(ImplicitObjectCreationExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            AnalyzedArguments instance = AnalyzedArguments.GetInstance();
            BindArgumentsAndNames(node.ArgumentList, diagnostics, instance, allowArglist: true);
            BoundUnconvertedObjectCreationExpression result = new BoundUnconvertedObjectCreationExpression(node, instance.Arguments.ToImmutable(), instance.Names.ToImmutableOrNull(), instance.RefKinds.ToImmutableOrNull(), node.Initializer);
            instance.Free();
            return result;
        }

        protected BoundExpression BindObjectCreationExpression(ObjectCreationExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            TypeWithAnnotations typeWithAnnotations = BindType(node.Type, diagnostics);
            TypeSymbol typeSymbol = typeWithAnnotations.Type;
            TypeSymbol initializerType = typeSymbol;
            if (typeWithAnnotations.NullableAnnotation.IsAnnotated() && !typeSymbol.IsNullableType())
            {
                diagnostics.Add(ErrorCode.ERR_AnnotationDisallowedInObjectCreation, node.Location, typeSymbol);
            }
            switch (typeSymbol.TypeKind)
            {
                case TypeKind.Class:
                case TypeKind.Enum:
                case TypeKind.Error:
                case TypeKind.Struct:
                    return BindClassCreationExpression(node, (NamedTypeSymbol)typeSymbol, GetName(node.Type), diagnostics, initializerType);
                case TypeKind.Delegate:
                    return BindDelegateCreationExpression(node, (NamedTypeSymbol)typeSymbol, diagnostics);
                case TypeKind.Interface:
                    return BindInterfaceCreationExpression(node, (NamedTypeSymbol)typeSymbol, diagnostics);
                case TypeKind.TypeParameter:
                    return BindTypeParameterCreationExpression(node, (TypeParameterSymbol)typeSymbol, diagnostics);
                case TypeKind.Submission:
                    throw ExceptionUtilities.UnexpectedValue(typeSymbol.TypeKind);
                case TypeKind.Pointer:
                case TypeKind.FunctionPointer:
                    typeSymbol = new ExtendedErrorTypeSymbol(typeSymbol, LookupResultKind.NotCreatable, diagnostics.Add(ErrorCode.ERR_UnsafeTypeInObjectCreation, node.Location, typeSymbol));
                    goto case TypeKind.Class;
                case TypeKind.Array:
                case TypeKind.Dynamic:
                    typeSymbol = new ExtendedErrorTypeSymbol(typeSymbol, LookupResultKind.NotCreatable, diagnostics.Add(ErrorCode.ERR_InvalidObjectCreation, node.Type.Location, typeSymbol));
                    goto case TypeKind.Class;
                default:
                    throw ExceptionUtilities.UnexpectedValue(typeSymbol.TypeKind);
            }
        }

        private BoundExpression BindDelegateCreationExpression(ObjectCreationExpressionSyntax node, NamedTypeSymbol type, BindingDiagnosticBag diagnostics)
        {
            AnalyzedArguments instance = AnalyzedArguments.GetInstance();
            BindArgumentsAndNames(node.ArgumentList, diagnostics, instance, allowArglist: false, isDelegateCreation: true);
            BoundExpression result = BindDelegateCreationExpression(node, type, instance, node.Initializer, diagnostics);
            instance.Free();
            return result;
        }

        private BoundExpression BindDelegateCreationExpression(SyntaxNode node, NamedTypeSymbol type, AnalyzedArguments analyzedArguments, InitializerExpressionSyntax initializerOpt, BindingDiagnosticBag diagnostics)
        {
            bool flag = false;
            if (!analyzedArguments.HasErrors)
            {
                if (analyzedArguments.Arguments.Count == 0)
                {
                    diagnostics.Add(ErrorCode.ERR_BadCtorArgCount, node.Location, type, 0);
                    flag = true;
                }
                else if (analyzedArguments.Names.Count != 0 || analyzedArguments.RefKinds.Count != 0 || analyzedArguments.Arguments.Count != 1)
                {
                    SyntaxNode syntax = analyzedArguments.Arguments[0].Syntax;
                    int spanStart = syntax.SpanStart;
                    int end = analyzedArguments.Arguments[analyzedArguments.Arguments.Count - 1].Syntax.Span.End;
                    SourceLocation location = new SourceLocation(span: new TextSpan(spanStart, end - spanStart), syntaxTree: syntax.SyntaxTree);
                    diagnostics.Add(ErrorCode.ERR_MethodNameExpected, location);
                    flag = true;
                }
            }
            if (initializerOpt != null)
            {
                Error(diagnostics, ErrorCode.ERR_ObjectOrCollectionInitializerWithDelegateCreation, node);
                flag = true;
            }
            BoundExpression boundExpression = ((analyzedArguments.Arguments.Count >= 1) ? BindToNaturalType(analyzedArguments.Arguments[0], diagnostics) : null);
            if (!flag)
            {
                if (boundExpression is UnboundLambda unboundLambda)
                {
                    CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                    Conversion conversion = Conversions.ClassifyConversionFromExpression(unboundLambda, type, ref useSiteInfo);
                    diagnostics.Add(node, useSiteInfo);
                    BoundLambda boundLambda = unboundLambda.Bind(type);
                    if (!conversion.IsImplicit || !conversion.IsValid)
                    {
                        GenerateImplicitConversionError(diagnostics, unboundLambda.Syntax, conversion, unboundLambda, type);
                    }
                    else
                    {
                        diagnostics.AddRange(boundLambda.Diagnostics);
                    }
                    return new BoundDelegateCreationExpression(node, boundLambda, null, isExtensionMethod: false, type, !conversion.IsImplicit);
                }
                if (!analyzedArguments.HasErrors)
                {
                    if (boundExpression.Kind == BoundKind.MethodGroup)
                    {
                        BoundMethodGroup boundMethodGroup = (BoundMethodGroup)boundExpression;
                        flag = MethodGroupConversionDoesNotExistOrHasErrors(boundMethodGroup, type, node.Location, diagnostics, out var conversion2);
                        boundMethodGroup = FixMethodGroupWithTypeOrValue(boundMethodGroup, conversion2, diagnostics);
                        return new BoundDelegateCreationExpression(node, boundMethodGroup, conversion2.Method, conversion2.IsExtensionMethod, type, flag);
                    }
                    if ((object)boundExpression.Type == null)
                    {
                        diagnostics.Add(ErrorCode.ERR_MethodNameExpected, boundExpression.Syntax.Location);
                    }
                    else
                    {
                        if (boundExpression.HasDynamicType())
                        {
                            return new BoundDelegateCreationExpression(node, boundExpression, null, isExtensionMethod: false, type);
                        }
                        if (boundExpression.Type!.TypeKind == TypeKind.Delegate)
                        {
                            NamedTypeSymbol namedTypeSymbol = (NamedTypeSymbol)boundExpression.Type;
                            MethodGroup instance = MethodGroup.GetInstance();
                            try
                            {
                                if (ReportDelegateInvokeUseSiteDiagnostic(diagnostics, boundExpression.Type, null, node))
                                {
                                    return new BoundBadExpression(node, LookupResultKind.NotInvocable, StaticCast<Symbol>.From(type.InstanceConstructors), ImmutableArray.Create(boundExpression), type);
                                }
                                instance.PopulateWithSingleMethod(boundExpression, namedTypeSymbol.DelegateInvokeMethod);
                                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo2 = GetNewCompoundUseSiteInfo(diagnostics);
                                Conversion conversion3 = Conversions.MethodGroupConversion(boundExpression.Syntax, instance, type, ref useSiteInfo2);
                                diagnostics.Add(node, useSiteInfo2);
                                if (!conversion3.Exists)
                                {
                                    BoundMethodGroup expr = new BoundMethodGroup(boundExpression.Syntax, default(ImmutableArray<TypeWithAnnotations>), "Invoke", ImmutableArray.Create(namedTypeSymbol.DelegateInvokeMethod), namedTypeSymbol.DelegateInvokeMethod, null, BoundMethodGroupFlags.None, boundExpression, LookupResultKind.Viable);
                                    if (!Conversions.ReportDelegateOrFunctionPointerMethodGroupDiagnostics(this, expr, type, diagnostics))
                                    {
                                        diagnostics.Add(ErrorCode.ERR_MethDelegateMismatch, node.Location, namedTypeSymbol.DelegateInvokeMethod, type);
                                    }
                                }
                                else if (!MethodGroupConversionHasErrors(boundExpression.Syntax, conversion3, boundExpression, conversion3.IsExtensionMethod, isAddressOf: false, type, diagnostics))
                                {
                                    return new BoundDelegateCreationExpression(node, boundExpression, null, isExtensionMethod: false, type);
                                }
                            }
                            finally
                            {
                                instance.Free();
                            }
                        }
                        else
                        {
                            diagnostics.Add(ErrorCode.ERR_MethodNameExpected, boundExpression.Syntax.Location);
                        }
                    }
                }
            }
            ImmutableArray<BoundExpression> childBoundNodes = BuildArgumentsForErrorRecovery(analyzedArguments);
            return new BoundBadExpression(node, LookupResultKind.OverloadResolutionFailure, StaticCast<Symbol>.From(type.InstanceConstructors), childBoundNodes, type);
        }

        private BoundExpression BindClassCreationExpression(ObjectCreationExpressionSyntax node, NamedTypeSymbol type, string typeName, BindingDiagnosticBag diagnostics, TypeSymbol initializerType = null)
        {
            AnalyzedArguments instance = AnalyzedArguments.GetInstance();
            try
            {
                BindArgumentsAndNames(node.ArgumentList, diagnostics, instance, allowArglist: true);
                if (type.IsStatic)
                {
                    diagnostics.Add(ErrorCode.ERR_InstantiatingStaticClass, node.Location, type);
                    return MakeBadExpressionForObjectCreation(node, type, instance, diagnostics);
                }
                if (node.Type.Kind() == SyntaxKind.TupleType)
                {
                    diagnostics.Add(ErrorCode.ERR_NewWithTupleTypeSyntax, node.Type.GetLocation());
                    return MakeBadExpressionForObjectCreation(node, type, instance, diagnostics);
                }
                return BindClassCreationExpression(node, typeName, node.Type, type, instance, diagnostics, node.Initializer, initializerType);
            }
            finally
            {
                instance.Free();
            }
        }

        internal BoundExpression BindObjectCreationForErrorRecovery(BoundUnconvertedObjectCreationExpression node, BindingDiagnosticBag diagnostics)
        {
            AnalyzedArguments instance = AnalyzedArguments.GetInstance(node.Arguments, node.ArgumentRefKindsOpt, node.ArgumentNamesOpt);
            BoundExpression result = MakeBadExpressionForObjectCreation(node.Syntax, CreateErrorType(), instance, node.InitializerOpt, node.Syntax, diagnostics);
            instance.Free();
            return result;
        }

        private BoundExpression MakeBadExpressionForObjectCreation(ObjectCreationExpressionSyntax node, TypeSymbol type, AnalyzedArguments analyzedArguments, BindingDiagnosticBag diagnostics)
        {
            return MakeBadExpressionForObjectCreation(node, type, analyzedArguments, node.Initializer, node.Type, diagnostics);
        }

        private BoundExpression MakeBadExpressionForObjectCreation(SyntaxNode node, TypeSymbol type, AnalyzedArguments analyzedArguments, InitializerExpressionSyntax initializerOpt, SyntaxNode typeSyntax, BindingDiagnosticBag diagnostics)
        {
            ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
            instance.AddRange(BuildArgumentsForErrorRecovery(analyzedArguments));
            if (initializerOpt != null)
            {
                BoundObjectInitializerExpressionBase item = BindInitializerExpression(initializerOpt, type, typeSyntax, isForNewInstance: true, diagnostics);
                instance.Add(item);
            }
            return new BoundBadExpression(node, LookupResultKind.NotCreatable, ImmutableArray.Create((Symbol)type), instance.ToImmutableAndFree(), type);
        }

        private BoundObjectInitializerExpressionBase BindInitializerExpression(InitializerExpressionSyntax syntax, TypeSymbol type, SyntaxNode typeSyntax, bool isForNewInstance, BindingDiagnosticBag diagnostics)
        {
            BoundObjectOrCollectionValuePlaceholder implicitReceiver = new BoundObjectOrCollectionValuePlaceholder(typeSyntax, isForNewInstance, type)
            {
                WasCompilerGenerated = true
            };
            return syntax.Kind() switch
            {
                SyntaxKind.ObjectInitializerExpression => BindObjectInitializerExpression(syntax, type, diagnostics, implicitReceiver, useObjectInitDiagnostics: true),
                SyntaxKind.WithInitializerExpression => BindObjectInitializerExpression(syntax, type, diagnostics, implicitReceiver, useObjectInitDiagnostics: false),
                SyntaxKind.CollectionInitializerExpression => BindCollectionInitializerExpression(syntax, type, diagnostics, implicitReceiver),
                _ => throw ExceptionUtilities.Unreachable,
            };
        }

        private BoundExpression BindInitializerExpressionOrValue(ExpressionSyntax syntax, TypeSymbol type, SyntaxNode typeSyntax, BindingDiagnosticBag diagnostics)
        {
            SyntaxKind syntaxKind = syntax.Kind();
            if (syntaxKind - 8644 <= SyntaxKind.List)
            {
                return BindInitializerExpression((InitializerExpressionSyntax)syntax, type, typeSyntax, isForNewInstance: false, diagnostics);
            }
            return BindValue(syntax, diagnostics, BindValueKind.RValue);
        }

        private BoundObjectInitializerExpression BindObjectInitializerExpression(InitializerExpressionSyntax initializerSyntax, TypeSymbol initializerType, BindingDiagnosticBag diagnostics, BoundObjectOrCollectionValuePlaceholder implicitReceiver, bool useObjectInitDiagnostics)
        {
            Binder objectInitializerMemberBinder = (useObjectInitDiagnostics ? WithAdditionalFlags(BinderFlags.ObjectInitializerMember) : this);
            ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance(initializerSyntax.Expressions.Count);
            PooledHashSet<string> instance2 = PooledHashSet<string>.GetInstance();
            SeparatedSyntaxList<ExpressionSyntax>.Enumerator enumerator = initializerSyntax.Expressions.GetEnumerator();
            while (enumerator.MoveNext())
            {
                ExpressionSyntax current = enumerator.Current;
                BoundExpression boundExpression = BindInitializerMemberAssignment(current, initializerType, objectInitializerMemberBinder, diagnostics, implicitReceiver);
                instance.Add(boundExpression);
                ReportDuplicateObjectMemberInitializers(boundExpression, instance2, diagnostics);
            }
            return new BoundObjectInitializerExpression(initializerSyntax, implicitReceiver, instance.ToImmutableAndFree(), initializerType);
        }

        private BoundExpression BindInitializerMemberAssignment(ExpressionSyntax memberInitializer, TypeSymbol initializerType, Binder objectInitializerMemberBinder, BindingDiagnosticBag diagnostics, BoundObjectOrCollectionValuePlaceholder implicitReceiver)
        {
            if (memberInitializer.Kind() == SyntaxKind.SimpleAssignmentExpression)
            {
                AssignmentExpressionSyntax assignmentExpressionSyntax = (AssignmentExpressionSyntax)memberInitializer;
                BoundExpression boundExpression = null;
                ExpressionSyntax left = assignmentExpressionSyntax.Left;
                if (initializerType.IsDynamic() && left.Kind() == SyntaxKind.IdentifierName)
                {
                    string text = ((IdentifierNameSyntax)left).Identifier.Text;
                    boundExpression = new BoundDynamicObjectInitializerMember(left, text, implicitReceiver.Type, initializerType, hasErrors: false);
                }
                else
                {
                    boundExpression = objectInitializerMemberBinder.BindObjectInitializerMember(assignmentExpressionSyntax, implicitReceiver, diagnostics);
                }
                if (boundExpression != null)
                {
                    BoundExpression op = BindInitializerExpressionOrValue(assignmentExpressionSyntax.Right, boundExpression.Type, boundExpression.Syntax, diagnostics);
                    return BindAssignment(assignmentExpressionSyntax, boundExpression, op, isRef: false, diagnostics);
                }
            }
            BoundExpression expr = BindValue(memberInitializer, diagnostics, BindValueKind.RValue);
            Error(diagnostics, ErrorCode.ERR_InvalidInitializerElementInitializer, memberInitializer);
            return ToBadExpression(expr, LookupResultKind.NotAValue);
        }

        private BoundExpression BindObjectInitializerMember(AssignmentExpressionSyntax namedAssignment, BoundObjectOrCollectionValuePlaceholder implicitReceiver, BindingDiagnosticBag diagnostics)
        {
            BoundExpression boundExpression;
            LookupResultKind resultKind;
            bool flag;
            if (namedAssignment.Left.Kind() == SyntaxKind.IdentifierName)
            {
                IdentifierNameSyntax identifierNameSyntax = (IdentifierNameSyntax)namedAssignment.Left;
                boundExpression = BindInstanceMemberAccess(identifierNameSyntax, identifierNameSyntax, implicitReceiver, identifierNameSyntax.Identifier.ValueText, 0, default(SeparatedSyntaxList<TypeSyntax>), default(ImmutableArray<TypeWithAnnotations>), invoked: false, indexed: false, diagnostics);
                resultKind = boundExpression.ResultKind;
                flag = boundExpression.HasAnyErrors || implicitReceiver.HasAnyErrors;
                if (boundExpression.Kind == BoundKind.PropertyGroup)
                {
                    boundExpression = BindIndexedPropertyAccess((BoundPropertyGroup)boundExpression, mustHaveAllOptionalParameters: true, diagnostics);
                    if (boundExpression.HasAnyErrors)
                    {
                        flag = true;
                    }
                }
            }
            else
            {
                if (namedAssignment.Left.Kind() != SyntaxKind.ImplicitElementAccess)
                {
                    return null;
                }
                ImplicitElementAccessSyntax implicitElementAccessSyntax = (ImplicitElementAccessSyntax)namedAssignment.Left;
                boundExpression = BindElementAccess(implicitElementAccessSyntax, implicitReceiver, implicitElementAccessSyntax.ArgumentList, diagnostics);
                resultKind = boundExpression.ResultKind;
                flag = boundExpression.HasAnyErrors || implicitReceiver.HasAnyErrors;
            }
            BoundKind kind = boundExpression.Kind;
            SyntaxKind syntaxKind = namedAssignment.Right.Kind();
            bool flag2 = syntaxKind == SyntaxKind.ObjectInitializerExpression || syntaxKind == SyntaxKind.CollectionInitializerExpression;
            BindValueKind valueKind = (flag2 ? BindValueKind.RValue : BindValueKind.Assignable);
            ImmutableArray<BoundExpression> arguments = ImmutableArray<BoundExpression>.Empty;
            ImmutableArray<string> argumentNamesOpt = default(ImmutableArray<string>);
            ImmutableArray<int> argsToParamsOpt = default(ImmutableArray<int>);
            ImmutableArray<RefKind> argumentRefKindsOpt = default(ImmutableArray<RefKind>);
            BitVector defaultArguments = default(BitVector);
            bool expanded = false;
            switch (kind)
            {
                case BoundKind.FieldAccess:
                    {
                        FieldSymbol fieldSymbol = ((BoundFieldAccess)boundExpression).FieldSymbol;
                        if (flag2 && fieldSymbol.IsReadOnly && fieldSymbol.Type.IsValueType)
                        {
                            if (!flag)
                            {
                                Error(diagnostics, ErrorCode.ERR_ReadonlyValueTypeInObjectInitializer, namedAssignment.Left, fieldSymbol, fieldSymbol.Type);
                                flag = true;
                            }
                            resultKind = LookupResultKind.NotAValue;
                        }
                        break;
                    }
                case BoundKind.PropertyAccess:
                    flag |= flag2 && !CheckNestedObjectInitializerPropertySymbol(((BoundPropertyAccess)boundExpression).PropertySymbol, namedAssignment.Left, diagnostics, flag, ref resultKind);
                    break;
                case BoundKind.IndexerAccess:
                    {
                        BoundIndexerAccess boundIndexerAccess = BindIndexerDefaultArguments((BoundIndexerAccess)boundExpression, valueKind, diagnostics);
                        boundExpression = boundIndexerAccess;
                        flag |= flag2 && !CheckNestedObjectInitializerPropertySymbol(boundIndexerAccess.Indexer, namedAssignment.Left, diagnostics, flag, ref resultKind);
                        arguments = boundIndexerAccess.Arguments;
                        argumentNamesOpt = boundIndexerAccess.ArgumentNamesOpt;
                        argsToParamsOpt = boundIndexerAccess.ArgsToParamsOpt;
                        argumentRefKindsOpt = boundIndexerAccess.ArgumentRefKindsOpt;
                        defaultArguments = boundIndexerAccess.DefaultArguments;
                        expanded = boundIndexerAccess.Expanded;
                        break;
                    }
                case BoundKind.DynamicIndexerAccess:
                    {
                        BoundDynamicIndexerAccess obj = (BoundDynamicIndexerAccess)boundExpression;
                        arguments = obj.Arguments;
                        argumentNamesOpt = obj.ArgumentNamesOpt;
                        argumentRefKindsOpt = obj.ArgumentRefKindsOpt;
                        break;
                    }
                case BoundKind.PointerElementAccess:
                case BoundKind.ArrayAccess:
                    return boundExpression;
                default:
                    return BadObjectInitializerMemberAccess(boundExpression, implicitReceiver, namedAssignment.Left, diagnostics, valueKind, flag);
                case BoundKind.EventAccess:
                    break;
            }
            if (!flag && !CheckValueKind(boundExpression.Syntax, boundExpression, valueKind, checkingReceiver: false, diagnostics))
            {
                flag = true;
                resultKind = (flag2 ? LookupResultKind.NotAValue : LookupResultKind.NotAVariable);
            }
            return new BoundObjectInitializerMember(namedAssignment.Left, boundExpression.ExpressionSymbol, arguments, argumentNamesOpt, argumentRefKindsOpt, expanded, argsToParamsOpt, defaultArguments, resultKind, implicitReceiver.Type, boundExpression.Type, flag);
        }

        private static bool CheckNestedObjectInitializerPropertySymbol(PropertySymbol propertySymbol, ExpressionSyntax memberNameSyntax, BindingDiagnosticBag diagnostics, bool suppressErrors, ref LookupResultKind resultKind)
        {
            bool flag = false;
            if (propertySymbol.Type.IsValueType)
            {
                if (!suppressErrors)
                {
                    Error(diagnostics, ErrorCode.ERR_ValueTypePropertyInObjectInitializer, memberNameSyntax, propertySymbol, propertySymbol.Type);
                    flag = true;
                }
                resultKind = LookupResultKind.NotAValue;
            }
            return !flag;
        }

        private BoundExpression BadObjectInitializerMemberAccess(BoundExpression boundMember, BoundObjectOrCollectionValuePlaceholder implicitReceiver, ExpressionSyntax memberNameSyntax, BindingDiagnosticBag diagnostics, BindValueKind valueKind, bool suppressErrors)
        {
            if (!suppressErrors)
            {
                string text = ((!(memberNameSyntax is IdentifierNameSyntax identifierNameSyntax)) ? memberNameSyntax.ToString() : identifierNameSyntax.Identifier.ValueText);
                switch (boundMember.ResultKind)
                {
                    case LookupResultKind.Empty:
                        Error(diagnostics, ErrorCode.ERR_NoSuchMember, memberNameSyntax, implicitReceiver.Type, text);
                        break;
                    case LookupResultKind.Inaccessible:
                        boundMember = CheckValue(boundMember, valueKind, diagnostics);
                        break;
                    default:
                        Error(diagnostics, ErrorCode.ERR_MemberCannotBeInitialized, memberNameSyntax, text);
                        break;
                }
            }
            return ToBadExpression(boundMember, (valueKind == BindValueKind.RValue) ? LookupResultKind.NotAValue : LookupResultKind.NotAVariable);
        }

        private static void ReportDuplicateObjectMemberInitializers(BoundExpression boundMemberInitializer, HashSet<string> memberNameMap, BindingDiagnosticBag diagnostics)
        {
            if (!boundMemberInitializer.HasAnyErrors && ((AssignmentExpressionSyntax)boundMemberInitializer.Syntax).Left is IdentifierNameSyntax identifierNameSyntax)
            {
                string valueText = identifierNameSyntax.Identifier.ValueText;
                if (!memberNameMap.Add(valueText))
                {
                    Error(diagnostics, ErrorCode.ERR_MemberAlreadyInitialized, identifierNameSyntax, valueText);
                }
            }
        }

        private BoundCollectionInitializerExpression BindCollectionInitializerExpression(InitializerExpressionSyntax initializerSyntax, TypeSymbol initializerType, BindingDiagnosticBag diagnostics, BoundObjectOrCollectionValuePlaceholder implicitReceiver)
        {
            ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
            bool flag = CollectionInitializerTypeImplementsIEnumerable(initializerType, initializerSyntax, diagnostics);
            if (!flag && !initializerSyntax.HasErrors && !initializerType.IsErrorType())
            {
                Error(diagnostics, ErrorCode.ERR_CollectionInitRequiresIEnumerable, initializerSyntax, initializerType);
            }
            Binder collectionInitializerAddMethodBinder = WithAdditionalFlags(BinderFlags.CollectionInitializerAddMethod);
            SeparatedSyntaxList<ExpressionSyntax>.Enumerator enumerator = initializerSyntax.Expressions.GetEnumerator();
            while (enumerator.MoveNext())
            {
                ExpressionSyntax current = enumerator.Current;
                BoundExpression item = BindCollectionInitializerElement(current, initializerType, flag, collectionInitializerAddMethodBinder, diagnostics, implicitReceiver);
                instance.Add(item);
            }
            return new BoundCollectionInitializerExpression(initializerSyntax, implicitReceiver, instance.ToImmutableAndFree(), initializerType);
        }

        private bool CollectionInitializerTypeImplementsIEnumerable(TypeSymbol initializerType, CSharpSyntaxNode node, BindingDiagnosticBag diagnostics)
        {
            if (initializerType.IsDynamic())
            {
                return true;
            }
            if (!initializerType.IsErrorType())
            {
                TypeSymbol specialType = GetSpecialType(SpecialType.System_Collections_IEnumerable, diagnostics, node);
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                bool isValid = Conversions.ClassifyImplicitConversionFromType(initializerType, specialType, ref useSiteInfo).IsValid;
                diagnostics.Add(node, useSiteInfo);
                return isValid;
            }
            return false;
        }

        private BoundExpression BindCollectionInitializerElement(ExpressionSyntax elementInitializer, TypeSymbol initializerType, bool hasEnumerableInitializerType, Binder collectionInitializerAddMethodBinder, BindingDiagnosticBag diagnostics, BoundObjectOrCollectionValuePlaceholder implicitReceiver)
        {
            if (elementInitializer.Kind() == SyntaxKind.ComplexElementInitializerExpression)
            {
                return BindComplexElementInitializerExpression((InitializerExpressionSyntax)elementInitializer, diagnostics, hasEnumerableInitializerType, collectionInitializerAddMethodBinder, implicitReceiver);
            }
            if (SyntaxFacts.IsAssignmentExpression(elementInitializer.Kind()))
            {
                Error(diagnostics, ErrorCode.ERR_InvalidInitializerElementInitializer, elementInitializer);
            }
            BoundExpression item = BindInitializerExpressionOrValue(elementInitializer, initializerType, implicitReceiver.Syntax, diagnostics);
            BoundExpression boundExpression = BindCollectionInitializerElementAddMethod(elementInitializer, ImmutableArray.Create(item), hasEnumerableInitializerType, collectionInitializerAddMethodBinder, diagnostics, implicitReceiver);
            boundExpression.WasCompilerGenerated = true;
            return boundExpression;
        }

        private BoundExpression BindComplexElementInitializerExpression(InitializerExpressionSyntax elementInitializer, BindingDiagnosticBag diagnostics, bool hasEnumerableInitializerType, Binder collectionInitializerAddMethodBinder = null, BoundObjectOrCollectionValuePlaceholder implicitReceiver = null)
        {
            SeparatedSyntaxList<ExpressionSyntax> expressions = elementInitializer.Expressions;
            if (expressions.Any())
            {
                ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
                SeparatedSyntaxList<ExpressionSyntax>.Enumerator enumerator = expressions.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    ExpressionSyntax current = enumerator.Current;
                    instance.Add(BindValue(current, diagnostics, BindValueKind.RValue));
                }
                return BindCollectionInitializerElementAddMethod(elementInitializer, instance.ToImmutableAndFree(), hasEnumerableInitializerType, collectionInitializerAddMethodBinder, diagnostics, implicitReceiver);
            }
            Error(diagnostics, ErrorCode.ERR_EmptyElementInitializer, elementInitializer);
            return BadExpression(elementInitializer, LookupResultKind.NotInvocable);
        }

        private BoundExpression BindUnexpectedComplexElementInitializer(InitializerExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            return BindComplexElementInitializerExpression(node, diagnostics, hasEnumerableInitializerType: false);
        }

        private BoundExpression BindCollectionInitializerElementAddMethod(ExpressionSyntax elementInitializer, ImmutableArray<BoundExpression> boundElementInitializerExpressions, bool hasEnumerableInitializerType, Binder collectionInitializerAddMethodBinder, BindingDiagnosticBag diagnostics, BoundObjectOrCollectionValuePlaceholder implicitReceiver)
        {
            if (!hasEnumerableInitializerType)
            {
                return BadExpression(elementInitializer, LookupResultKind.NotInvocable, ImmutableArray<Symbol>.Empty, boundElementInitializerExpressions);
            }
            if (implicitReceiver.Type.IsDynamic())
            {
                bool hasErrors = ReportBadDynamicArguments(elementInitializer, boundElementInitializerExpressions, default(ImmutableArray<RefKind>), diagnostics, null);
                return new BoundDynamicCollectionElementInitializer(elementInitializer, ImmutableArray<MethodSymbol>.Empty, implicitReceiver, boundElementInitializerExpressions.SelectAsArray((BoundExpression e) => BindToNaturalType(e, diagnostics)), GetSpecialType(SpecialType.System_Void, diagnostics, elementInitializer), hasErrors);
            }
            BoundExpression boundExpression = collectionInitializerAddMethodBinder.MakeInvocationExpression(elementInitializer, implicitReceiver, "Add", boundElementInitializerExpressions, diagnostics);
            if (boundExpression.Kind == BoundKind.DynamicInvocation)
            {
                BoundDynamicInvocation boundDynamicInvocation = (BoundDynamicInvocation)boundExpression;
                return new BoundDynamicCollectionElementInitializer(elementInitializer, boundDynamicInvocation.ApplicableMethods, implicitReceiver, boundDynamicInvocation.Arguments, boundDynamicInvocation.Type, boundDynamicInvocation.HasAnyErrors);
            }
            if (boundExpression.Kind == BoundKind.Call)
            {
                BoundCall boundCall = (BoundCall)boundExpression;
                if (boundCall.HasErrors && !boundCall.OriginalMethodsOpt.IsDefault)
                {
                    return boundCall;
                }
                return new BoundCollectionElementInitializer(elementInitializer, boundCall.Method, boundCall.Arguments, boundCall.ReceiverOpt, boundCall.Expanded, boundCall.ArgsToParamsOpt, boundCall.DefaultArguments, boundCall.InvokedAsExtensionMethod, boundCall.ResultKind, boundCall.Type, boundCall.HasAnyErrors)
                {
                    WasCompilerGenerated = true
                };
            }
            return boundExpression;
        }

        internal ImmutableArray<MethodSymbol> FilterInaccessibleConstructors(ImmutableArray<MethodSymbol> constructors, bool allowProtectedConstructorsOfBaseType, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            ArrayBuilder<MethodSymbol> arrayBuilder = null;
            for (int i = 0; i < constructors.Length; i++)
            {
                MethodSymbol methodSymbol = constructors[i];
                if (!IsConstructorAccessible(methodSymbol, ref useSiteInfo, allowProtectedConstructorsOfBaseType))
                {
                    if (arrayBuilder == null)
                    {
                        arrayBuilder = ArrayBuilder<MethodSymbol>.GetInstance();
                        arrayBuilder.AddRange(constructors, i);
                    }
                }
                else
                {
                    arrayBuilder?.Add(methodSymbol);
                }
            }
            return arrayBuilder?.ToImmutableAndFree() ?? constructors;
        }

        private bool IsConstructorAccessible(MethodSymbol constructor, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, bool allowProtectedConstructorsOfBaseType = false)
        {
            NamedTypeSymbol containingType = ContainingType;
            if ((object)containingType != null)
            {
                if (!allowProtectedConstructorsOfBaseType)
                {
                    return IsSymbolAccessibleConditional(constructor, containingType, ref useSiteInfo, constructor.ContainingType);
                }
                return IsAccessible(constructor, ref useSiteInfo);
            }
            return IsSymbolAccessibleConditional(constructor, Compilation.Assembly, ref useSiteInfo);
        }

        protected BoundExpression BindClassCreationExpression(SyntaxNode node, string typeName, SyntaxNode typeNode, NamedTypeSymbol type, AnalyzedArguments analyzedArguments, BindingDiagnosticBag diagnostics, InitializerExpressionSyntax initializerSyntaxOpt = null, TypeSymbol initializerTypeOpt = null, bool wasTargetTyped = false)
        {
            BoundExpression boundExpression = null;
            bool flag = type.IsErrorType();
            if (type.IsAbstract)
            {
                diagnostics.Add(ErrorCode.ERR_NoNewAbstract, node.Location, type);
                flag = true;
            }
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            BoundObjectInitializerExpressionBase boundObjectInitializerExpressionBase = null;
            if (analyzedArguments.HasDynamicArgument)
            {
                OverloadResolutionResult<MethodSymbol> instance = OverloadResolutionResult<MethodSymbol>.GetInstance();
                OverloadResolution.ObjectCreationOverloadResolution(GetAccessibleConstructorsForOverloadResolution(type, ref useSiteInfo), analyzedArguments, instance, ref useSiteInfo);
                diagnostics.Add(node, useSiteInfo);
                useSiteInfo = new CompoundUseSiteInfo<AssemblySymbol>(useSiteInfo);
                if (instance.HasAnyApplicableMember)
                {
                    ImmutableArray<BoundExpression> arguments = BuildArgumentsForDynamicInvocation(analyzedArguments, diagnostics);
                    ImmutableArray<RefKind> immutableArray = analyzedArguments.RefKinds.ToImmutableOrNull();
                    flag &= ReportBadDynamicArguments(node, arguments, immutableArray, diagnostics, null);
                    boundObjectInitializerExpressionBase = makeBoundInitializerOpt();
                    boundExpression = new BoundDynamicObjectCreationExpression(node, typeName, arguments, analyzedArguments.GetNames(), immutableArray, boundObjectInitializerExpressionBase, instance.GetAllApplicableMembers(), type, flag);
                }
                instance.Free();
                if (boundExpression != null)
                {
                    return boundExpression;
                }
            }
            if (TryPerformConstructorOverloadResolution(type, analyzedArguments, typeName, typeNode.Location, flag, diagnostics, out var memberResolutionResult, out var candidateConstructors, allowProtectedConstructorsOfBaseType: false))
            {
                MethodSymbol member = memberResolutionResult.Member;
                bool flag2 = false;
                if (member.HasUnsafeParameter())
                {
                    flag2 = ReportUnsafeIfNotAllowed(node, diagnostics) || flag2;
                }
                ReportDiagnosticsIfObsolete(diagnostics, member, node, hasBaseReceiver: false);
                ConstantValue constantValueOpt = ((initializerSyntaxOpt == null && member.IsDefaultValueTypeConstructor()) ? FoldParameterlessValueTypeConstructor(type) : null);
                bool expanded = memberResolutionResult.Result.Kind == MemberResolutionKind.ApplicableInExpandedForm;
                ImmutableArray<int> argsToParamsOpt = memberResolutionResult.Result.ArgsToParamsOpt;
                BindDefaultArguments(node, member.Parameters, analyzedArguments.Arguments, analyzedArguments.RefKinds, ref argsToParamsOpt, out var defaultArguments, expanded, enableCallerInfo: true, diagnostics);
                ImmutableArray<BoundExpression> immutableArray2 = analyzedArguments.Arguments.ToImmutable();
                ImmutableArray<RefKind> argumentRefKindsOpt = analyzedArguments.RefKinds.ToImmutableOrNull();
                if (!flag2)
                {
                    flag2 = !CheckInvocationArgMixing(node, member, null, member.Parameters, immutableArray2, argsToParamsOpt, LocalScopeDepth, diagnostics);
                }
                boundObjectInitializerExpressionBase = makeBoundInitializerOpt();
                boundExpression = new BoundObjectCreationExpression(node, member, candidateConstructors, immutableArray2, analyzedArguments.GetNames(), argumentRefKindsOpt, expanded, argsToParamsOpt, defaultArguments, constantValueOpt, boundObjectInitializerExpressionBase, wasTargetTyped, type, flag2);
                if (type.IsAbstract)
                {
                    boundExpression = BadExpression(node, LookupResultKind.NotCreatable, boundExpression);
                }
                return boundExpression;
            }
            LookupResultKind resultKind = (type.IsAbstract ? LookupResultKind.NotCreatable : ((!memberResolutionResult.IsValid || IsConstructorAccessible(memberResolutionResult.Member, ref useSiteInfo)) ? LookupResultKind.OverloadResolutionFailure : LookupResultKind.Inaccessible));
            diagnostics.Add(node, useSiteInfo);
            ArrayBuilder<Symbol> instance2 = ArrayBuilder<Symbol>.GetInstance();
            instance2.AddRange(candidateConstructors);
            ArrayBuilder<BoundExpression> instance3 = ArrayBuilder<BoundExpression>.GetInstance();
            instance3.AddRange(BuildArgumentsForErrorRecovery(analyzedArguments, candidateConstructors));
            if (initializerSyntaxOpt != null)
            {
                instance3.Add(boundObjectInitializerExpressionBase ?? makeBoundInitializerOpt());
            }
            return new BoundBadExpression(node, resultKind, instance2.ToImmutableAndFree(), instance3.ToImmutableAndFree(), type);
            BoundObjectInitializerExpressionBase makeBoundInitializerOpt()
            {
                if (initializerSyntaxOpt != null)
                {
                    return BindInitializerExpression(initializerSyntaxOpt, initializerTypeOpt ?? type, typeNode, isForNewInstance: true, diagnostics);
                }
                return null;
            }
        }

        private BoundExpression BindInterfaceCreationExpression(ObjectCreationExpressionSyntax node, NamedTypeSymbol type, BindingDiagnosticBag diagnostics)
        {
            AnalyzedArguments instance = AnalyzedArguments.GetInstance();
            BindArgumentsAndNames(node.ArgumentList, diagnostics, instance);
            BoundExpression result = BindInterfaceCreationExpression(node, type, diagnostics, node.Type, instance, node.Initializer, wasTargetTyped: false);
            instance.Free();
            return result;
        }

        private BoundExpression BindInterfaceCreationExpression(SyntaxNode node, NamedTypeSymbol type, BindingDiagnosticBag diagnostics, SyntaxNode typeNode, AnalyzedArguments analyzedArguments, InitializerExpressionSyntax initializerOpt, bool wasTargetTyped)
        {
            if (!InAttributeArgument && type.IsComImport)
            {
                NamedTypeSymbol comImportCoClass = type.ComImportCoClass;
                if ((object)comImportCoClass != null)
                {
                    return BindComImportCoClassCreationExpression(node, type, comImportCoClass, diagnostics, typeNode, analyzedArguments, initializerOpt, wasTargetTyped);
                }
            }
            diagnostics.Add(ErrorCode.ERR_NoNewAbstract, node.Location, type);
            return MakeBadExpressionForObjectCreation(node, type, analyzedArguments, initializerOpt, typeNode, diagnostics);
        }

        private BoundExpression BindComImportCoClassCreationExpression(SyntaxNode node, NamedTypeSymbol interfaceType, NamedTypeSymbol coClassType, BindingDiagnosticBag diagnostics, SyntaxNode typeNode, AnalyzedArguments analyzedArguments, InitializerExpressionSyntax initializerOpt, bool wasTargetTyped)
        {
            if (coClassType.IsErrorType())
            {
                Error(diagnostics, ErrorCode.ERR_MissingCoClass, node, coClassType, interfaceType);
            }
            else
            {
                if (!coClassType.IsUnboundGenericType)
                {
                    if (interfaceType.ContainingAssembly.IsLinked)
                    {
                        return BindNoPiaObjectCreationExpression(node, interfaceType, coClassType, diagnostics, typeNode, analyzedArguments, initializerOpt);
                    }
                    BoundExpression boundExpression = BindClassCreationExpression(node, coClassType.Name, typeNode, coClassType, analyzedArguments, diagnostics, initializerOpt, interfaceType, wasTargetTyped);
                    CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                    Conversion conversion = Conversions.ClassifyConversionFromExpression(boundExpression, interfaceType, ref useSiteInfo, forCast: true);
                    diagnostics.Add(node, useSiteInfo);
                    if (!conversion.IsValid)
                    {
                        SymbolDistinguisher symbolDistinguisher = new SymbolDistinguisher(Compilation, coClassType, interfaceType);
                        Error(diagnostics, ErrorCode.ERR_NoExplicitConv, node, symbolDistinguisher.First, symbolDistinguisher.Second);
                    }
                    CreateConversion(boundExpression, conversion, interfaceType, diagnostics);
                    switch (boundExpression.Kind)
                    {
                        case BoundKind.ObjectCreationExpression:
                            {
                                BoundObjectCreationExpression boundObjectCreationExpression = (BoundObjectCreationExpression)boundExpression;
                                return boundObjectCreationExpression.Update(boundObjectCreationExpression.Constructor, boundObjectCreationExpression.ConstructorsGroup, boundObjectCreationExpression.Arguments, boundObjectCreationExpression.ArgumentNamesOpt, boundObjectCreationExpression.ArgumentRefKindsOpt, boundObjectCreationExpression.Expanded, boundObjectCreationExpression.ArgsToParamsOpt, boundObjectCreationExpression.DefaultArguments, boundObjectCreationExpression.ConstantValueOpt, boundObjectCreationExpression.InitializerExpressionOpt, interfaceType);
                            }
                        case BoundKind.BadExpression:
                            {
                                BoundBadExpression boundBadExpression = (BoundBadExpression)boundExpression;
                                return boundBadExpression.Update(boundBadExpression.ResultKind, boundBadExpression.Symbols, boundBadExpression.ChildBoundNodes, interfaceType);
                            }
                        default:
                            throw ExceptionUtilities.UnexpectedValue(boundExpression.Kind);
                    }
                }
                Error(diagnostics, ErrorCode.ERR_BadCoClassSig, node, coClassType, interfaceType);
            }
            return MakeBadExpressionForObjectCreation(node, interfaceType, analyzedArguments, initializerOpt, typeNode, diagnostics);
        }

        private BoundExpression BindNoPiaObjectCreationExpression(SyntaxNode node, NamedTypeSymbol interfaceType, NamedTypeSymbol coClassType, BindingDiagnosticBag diagnostics, SyntaxNode typeNode, AnalyzedArguments analyzedArguments, InitializerExpressionSyntax initializerOpt)
        {
            if (!coClassType.GetGuidString(out var guidString))
            {
                guidString = Guid.Empty.ToString("D");
            }
            BoundObjectInitializerExpressionBase initializerExpressionOpt = ((initializerOpt == null) ? null : BindInitializerExpression(initializerOpt, interfaceType, typeNode, isForNewInstance: true, diagnostics));
            BoundNoPiaObjectCreationExpression boundNoPiaObjectCreationExpression = new BoundNoPiaObjectCreationExpression(node, guidString, initializerExpressionOpt, interfaceType);
            if (analyzedArguments.Arguments.Count > 0)
            {
                diagnostics.Add(ErrorCode.ERR_BadCtorArgCount, typeNode.Location, interfaceType, analyzedArguments.Arguments.Count);
                ImmutableArray<BoundExpression> childBoundNodes = BuildArgumentsForErrorRecovery(analyzedArguments).Add(boundNoPiaObjectCreationExpression);
                return new BoundBadExpression(node, LookupResultKind.OverloadResolutionFailure, ImmutableArray<Symbol>.Empty, childBoundNodes, boundNoPiaObjectCreationExpression.Type);
            }
            return boundNoPiaObjectCreationExpression;
        }

        private BoundExpression BindTypeParameterCreationExpression(ObjectCreationExpressionSyntax node, TypeParameterSymbol typeParameter, BindingDiagnosticBag diagnostics)
        {
            AnalyzedArguments instance = AnalyzedArguments.GetInstance();
            BindArgumentsAndNames(node.ArgumentList, diagnostics, instance);
            BoundExpression result = BindTypeParameterCreationExpression(node, typeParameter, instance, node.Initializer, node.Type, diagnostics);
            instance.Free();
            return result;
        }

        private BoundExpression BindTypeParameterCreationExpression(SyntaxNode node, TypeParameterSymbol typeParameter, AnalyzedArguments analyzedArguments, InitializerExpressionSyntax initializerOpt, SyntaxNode typeSyntax, BindingDiagnosticBag diagnostics)
        {
            if (!typeParameter.HasConstructorConstraint && !typeParameter.IsValueType)
            {
                diagnostics.Add(ErrorCode.ERR_NoNewTyvar, node.Location, typeParameter);
            }
            else
            {
                if (analyzedArguments.Arguments.Count <= 0)
                {
                    BoundObjectInitializerExpressionBase initializerExpressionOpt = ((initializerOpt == null) ? null : BindInitializerExpression(initializerOpt, typeParameter, typeSyntax, isForNewInstance: true, diagnostics));
                    return new BoundNewT(node, initializerExpressionOpt, typeParameter);
                }
                diagnostics.Add(ErrorCode.ERR_NewTyvarWithArgs, node.Location, typeParameter);
            }
            return MakeBadExpressionForObjectCreation(node, typeParameter, analyzedArguments, initializerOpt, typeSyntax, diagnostics);
        }

        private bool TryPerformConstructorOverloadResolution(NamedTypeSymbol typeContainingConstructors, AnalyzedArguments analyzedArguments, string errorName, Location errorLocation, bool suppressResultDiagnostics, BindingDiagnosticBag diagnostics, out MemberResolutionResult<MethodSymbol> memberResolutionResult, out ImmutableArray<MethodSymbol> candidateConstructors, bool allowProtectedConstructorsOfBaseType)
        {
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            candidateConstructors = GetAccessibleConstructorsForOverloadResolution(typeContainingConstructors, allowProtectedConstructorsOfBaseType, out var allInstanceConstructors, ref useSiteInfo);
            OverloadResolutionResult<MethodSymbol> overloadResolutionResult = OverloadResolutionResult<MethodSymbol>.GetInstance();
            bool flag = false;
            bool flag2 = false;
            if (candidateConstructors.Any())
            {
                OverloadResolution.ObjectCreationOverloadResolution(candidateConstructors, analyzedArguments, overloadResolutionResult, ref useSiteInfo);
                if (overloadResolutionResult.Succeeded)
                {
                    flag = true;
                    flag2 = true;
                }
            }
            if (!flag && allInstanceConstructors.Length > candidateConstructors.Length)
            {
                OverloadResolutionResult<MethodSymbol> instance = OverloadResolutionResult<MethodSymbol>.GetInstance();
                OverloadResolution.ObjectCreationOverloadResolution(allInstanceConstructors, analyzedArguments, instance, ref useSiteInfo);
                if (instance.Succeeded)
                {
                    flag2 = true;
                    candidateConstructors = allInstanceConstructors;
                    overloadResolutionResult.Free();
                    overloadResolutionResult = instance;
                }
                else
                {
                    instance.Free();
                }
            }
            diagnostics.Add(errorLocation, useSiteInfo);
            if (flag2)
            {
                CoerceArguments(overloadResolutionResult.ValidResult, analyzedArguments.Arguments, diagnostics);
            }
            memberResolutionResult = (flag2 ? overloadResolutionResult.ValidResult : default(MemberResolutionResult<MethodSymbol>));
            if (!flag && !suppressResultDiagnostics)
            {
                if (flag2)
                {
                    diagnostics.Add(ErrorCode.ERR_BadAccess, errorLocation, overloadResolutionResult.ValidResult.Member);
                }
                else
                {
                    overloadResolutionResult.ReportDiagnostics(this, errorLocation, null, diagnostics, errorName, null, null, analyzedArguments, candidateConstructors, typeContainingConstructors, null);
                }
            }
            overloadResolutionResult.Free();
            return flag;
        }

        private ImmutableArray<MethodSymbol> GetAccessibleConstructorsForOverloadResolution(NamedTypeSymbol type, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            return GetAccessibleConstructorsForOverloadResolution(type, allowProtectedConstructorsOfBaseType: false, out ImmutableArray<MethodSymbol> allInstanceConstructors, ref useSiteInfo);
        }

        private ImmutableArray<MethodSymbol> GetAccessibleConstructorsForOverloadResolution(NamedTypeSymbol type, bool allowProtectedConstructorsOfBaseType, out ImmutableArray<MethodSymbol> allInstanceConstructors, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            if (type.IsErrorType())
            {
                type = (type.GetNonErrorGuess() as NamedTypeSymbol) ?? type;
            }
            allInstanceConstructors = type.InstanceConstructors;
            return FilterInaccessibleConstructors(allInstanceConstructors, allowProtectedConstructorsOfBaseType, ref useSiteInfo);
        }

        private static ConstantValue FoldParameterlessValueTypeConstructor(NamedTypeSymbol type)
        {
            SpecialType specialType = type.SpecialType;
            if (type.TypeKind == TypeKind.Enum)
            {
                specialType = type.EnumUnderlyingType.SpecialType;
            }
            if ((uint)(specialType - 7) <= 12u)
            {
                return ConstantValue.Default(specialType);
            }
            return null;
        }

        private BoundLiteral BindLiteralConstant(LiteralExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            object value = node.Token.Value;
            TypeSymbol type = null;
            ConstantValue constantValueOpt;
            if (value == null)
            {
                constantValueOpt = ConstantValue.Null;
            }
            else
            {
                SpecialType specialType = SpecialTypeExtensions.FromRuntimeTypeOfLiteralValue(value);
                constantValueOpt = ConstantValue.Create(value, specialType);
                type = GetSpecialType(specialType, diagnostics, node);
            }
            return new BoundLiteral(node, constantValueOpt, type);
        }

        private BoundExpression BindCheckedExpression(CheckedExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            return WithCheckedOrUncheckedRegion(node.Kind() == SyntaxKind.CheckedExpression).BindParenthesizedExpression(node.Expression, diagnostics);
        }

        private BoundExpression BindMemberAccess(MemberAccessExpressionSyntax node, bool invoked, bool indexed, BindingDiagnosticBag diagnostics)
        {
            ExpressionSyntax expression = node.Expression;
            BoundExpression boundLeft;
            if (node.Kind() == SyntaxKind.SimpleMemberAccessExpression)
            {
                boundLeft = BindLeftOfPotentialColorColorMemberAccess(expression, diagnostics);
            }
            else
            {
                boundLeft = BindRValueWithoutTargetType(expression, diagnostics);
                BindPointerIndirectionExpressionInternal(node, boundLeft, diagnostics, out var pointedAtType, out var hasErrors);
                boundLeft = (((object)pointedAtType != null) ? new BoundPointerIndirectionOperator(expression, boundLeft, pointedAtType, hasErrors)
                {
                    WasCompilerGenerated = true
                } : ToBadExpression(boundLeft));
            }
            return BindMemberAccessWithBoundLeft(node, boundLeft, node.Name, node.OperatorToken, invoked, indexed, diagnostics);
        }

        private BoundExpression BindLeftOfPotentialColorColorMemberAccess(ExpressionSyntax left, BindingDiagnosticBag diagnostics)
        {
            if (left is IdentifierNameSyntax left2)
            {
                return BindLeftIdentifierOfPotentialColorColorMemberAccess(left2, diagnostics);
            }
            return BindExpression(left, diagnostics);
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private BoundExpression BindLeftIdentifierOfPotentialColorColorMemberAccess(IdentifierNameSyntax left, BindingDiagnosticBag diagnostics)
        {
            BindingDiagnosticBag bindingDiagnosticBag = BindingDiagnosticBag.Create(diagnostics);
            BoundExpression boundExpression = BindIdentifier(left, invoked: false, indexed: false, bindingDiagnosticBag);
            Symbol symbol = ((boundExpression.Kind != BoundKind.Conversion) ? boundExpression.ExpressionSymbol : ((BoundConversion)boundExpression).Operand.ExpressionSymbol);
            if ((object)symbol != null)
            {
                switch (symbol.Kind)
                {
                    case SymbolKind.Field:
                    case SymbolKind.Local:
                    case SymbolKind.Parameter:
                    case SymbolKind.Property:
                    case SymbolKind.RangeVariable:
                        {
                            TypeSymbol type = boundExpression.Type;
                            string valueText = left.Identifier.ValueText;
                            if (type.Name == valueText || IsUsingAliasInScope(valueText))
                            {
                                BindingDiagnosticBag bindingDiagnosticBag2 = BindingDiagnosticBag.Create(diagnostics);
                                BoundExpression boundExpression2 = BindNamespaceOrType(left, bindingDiagnosticBag2);
                                if (TypeSymbol.Equals(boundExpression2.Type, type, TypeCompareKind.ConsiderEverything))
                                {
                                    boundExpression = BindToNaturalType(boundExpression, bindingDiagnosticBag);
                                    return new BoundTypeOrValueExpression(left, new BoundTypeOrValueData(symbol, boundExpression, bindingDiagnosticBag, boundExpression2, bindingDiagnosticBag2), type);
                                }
                            }
                            break;
                        }
                }
            }
            diagnostics.AddRange(bindingDiagnosticBag);
            return boundExpression;
        }

        private bool IsUsingAliasInScope(string name)
        {
            bool isSemanticModelBinder = IsSemanticModelBinder;
            for (ImportChain importChain = ImportChain; importChain != null; importChain = importChain.ParentOpt)
            {
                if (IsUsingAlias(importChain.Imports.UsingAliases, name, isSemanticModelBinder))
                {
                    return true;
                }
            }
            return false;
        }

        private BoundExpression BindDynamicMemberAccess(ExpressionSyntax node, BoundExpression boundLeft, SimpleNameSyntax right, bool invoked, bool indexed, BindingDiagnosticBag diagnostics)
        {
            SeparatedSyntaxList<TypeSyntax> typeArguments = ((right.Kind() == SyntaxKind.GenericName) ? ((GenericNameSyntax)right).TypeArgumentList.Arguments : default(SeparatedSyntaxList<TypeSyntax>));
            bool flag = typeArguments.Count > 0;
            ImmutableArray<TypeWithAnnotations> typeArgumentsOpt = (flag ? BindTypeArguments(typeArguments, diagnostics) : default(ImmutableArray<TypeWithAnnotations>));
            bool hasErrors = false;
            if (!invoked && flag)
            {
                Error(diagnostics, ErrorCode.ERR_TypeArgsNotAllowed, right, right.Identifier.Text, SymbolKind.Property.Localize());
                hasErrors = true;
            }
            if (flag)
            {
                for (int i = 0; i < typeArgumentsOpt.Length; i++)
                {
                    TypeWithAnnotations typeWithAnnotations = typeArgumentsOpt[i];
                    if (typeWithAnnotations.Type.IsPointerOrFunctionPointer() || typeWithAnnotations.Type.IsRestrictedType())
                    {
                        Error(diagnostics, ErrorCode.ERR_BadTypeArgument, typeArguments[i], typeWithAnnotations.Type);
                        hasErrors = true;
                    }
                }
            }
            return new BoundDynamicMemberAccess(node, boundLeft, typeArgumentsOpt, right.Identifier.ValueText, invoked, indexed, Compilation.DynamicType, hasErrors);
        }

        private BoundExpression BindMemberAccessWithBoundLeft(ExpressionSyntax node, BoundExpression boundLeft, SimpleNameSyntax right, SyntaxToken operatorToken, bool invoked, bool indexed, BindingDiagnosticBag diagnostics)
        {
            boundLeft = MakeMemberAccessValue(boundLeft, diagnostics);
            TypeSymbol type = boundLeft.Type;
            if ((object)type != null && type.IsDynamic())
            {
                boundLeft = CheckValue(boundLeft, BindValueKind.RValue, diagnostics);
                return BindDynamicMemberAccess(node, boundLeft, right, invoked, indexed, diagnostics);
            }
            if ((object)type != null && type.IsVoidType())
            {
                diagnostics.Add(ErrorCode.ERR_BadUnaryOp, operatorToken.GetLocation(), SyntaxFacts.GetText(operatorToken.Kind()), type);
                return BadExpression(node, boundLeft);
            }
            if (boundLeft.IsLiteralDefault())
            {
                DiagnosticInfo info = new CSDiagnosticInfo(ErrorCode.ERR_BadOpOnNullOrDefaultOrNew, SyntaxFacts.GetText(operatorToken.Kind()), boundLeft.Display);
                diagnostics.Add(new CSDiagnostic(info, operatorToken.GetLocation()));
                return BadExpression(node, boundLeft);
            }
            if (boundLeft.Kind == BoundKind.UnboundLambda)
            {
                MessageID messageID = ((UnboundLambda)boundLeft).MessageID;
                diagnostics.Add(ErrorCode.ERR_BadUnaryOp, node.Location, SyntaxFacts.GetText(operatorToken.Kind()), messageID.Localize());
                return BadExpression(node, boundLeft);
            }
            boundLeft = BindToNaturalType(boundLeft, diagnostics);
            type = boundLeft.Type;
            LookupResult instance = LookupResult.GetInstance();
            try
            {
                LookupOptions lookupOptions = LookupOptions.AllMethodsOnArityZero;
                if (invoked)
                {
                    lookupOptions |= LookupOptions.MustBeInvocableIfMember;
                }
                SeparatedSyntaxList<TypeSyntax> separatedSyntaxList = ((right.Kind() == SyntaxKind.GenericName) ? ((GenericNameSyntax)right).TypeArgumentList.Arguments : default(SeparatedSyntaxList<TypeSyntax>));
                bool flag = separatedSyntaxList.Count > 0;
                ImmutableArray<TypeWithAnnotations> immutableArray = (flag ? BindTypeArguments(separatedSyntaxList, diagnostics) : default(ImmutableArray<TypeWithAnnotations>));
                string valueText = right.Identifier.ValueText;
                int arity = right.Arity;
                switch (boundLeft.Kind)
                {
                    case BoundKind.NamespaceExpression:
                        {
                            NamespaceSymbol namespaceSymbol = ((BoundNamespaceExpression)boundLeft).NamespaceSymbol;
                            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                            LookupMembersWithFallback(instance, namespaceSymbol, valueText, arity, ref useSiteInfo, null, lookupOptions);
                            diagnostics.Add(right, useSiteInfo);
                            ArrayBuilder<Symbol> symbols = instance.Symbols;
                            if (instance.IsMultiViable)
                            {
                                Symbol symbol = ResultSymbol(instance, valueText, arity, node, diagnostics, suppressUseSiteDiagnostics: false, out bool wasError, namespaceSymbol, lookupOptions);
                                if (wasError)
                                {
                                    return new BoundBadExpression(node, LookupResultKind.Ambiguous, instance.Symbols.AsImmutable(), ImmutableArray.Create(boundLeft), CreateErrorType(valueText), hasErrors: true);
                                }
                                if (symbol.Kind == SymbolKind.Namespace)
                                {
                                    return new BoundNamespaceExpression(node, (NamespaceSymbol)symbol);
                                }
                                NamedTypeSymbol namedTypeSymbol = (NamedTypeSymbol)symbol;
                                if (flag)
                                {
                                    namedTypeSymbol = ConstructNamedTypeUnlessTypeArgumentOmitted(right, namedTypeSymbol, separatedSyntaxList, immutableArray, diagnostics);
                                }
                                ReportDiagnosticsIfObsolete(diagnostics, namedTypeSymbol, node, hasBaseReceiver: false);
                                return new BoundTypeExpression(node, null, namedTypeSymbol);
                            }
                            if (instance.Kind == LookupResultKind.WrongArity)
                            {
                                Error(diagnostics, instance.Error, right);
                                return new BoundTypeExpression(node, null, new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0]), symbols.ToImmutable(), instance.Kind, instance.Error, arity));
                            }
                            if (instance.Kind == LookupResultKind.Empty)
                            {
                                NotFound(node, valueText, arity, valueText, diagnostics, null, namespaceSymbol, lookupOptions);
                                return new BoundBadExpression(node, instance.Kind, symbols.AsImmutable(), ImmutableArray.Create(boundLeft), CreateErrorType(valueText), hasErrors: true);
                            }
                            break;
                        }
                    case BoundKind.TypeExpression:
                        {
                            if (type.TypeKind == TypeKind.TypeParameter)
                            {
                                Error(diagnostics, ErrorCode.ERR_BadSKunknown, boundLeft.Syntax, type, MessageID.IDS_SK_TYVAR.Localize());
                                return BadExpression(node, LookupResultKind.NotAValue, boundLeft);
                            }
                            if (EnclosingNameofArgument == node)
                            {
                                return BindInstanceMemberAccess(node, right, boundLeft, valueText, arity, separatedSyntaxList, immutableArray, invoked, indexed, diagnostics);
                            }
                            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo2 = GetNewCompoundUseSiteInfo(diagnostics);
                            LookupMembersWithFallback(instance, type, valueText, arity, ref useSiteInfo2, null, lookupOptions);
                            diagnostics.Add(right, useSiteInfo2);
                            if (instance.IsMultiViable)
                            {
                                return BindMemberOfType(node, right, valueText, arity, indexed, boundLeft, separatedSyntaxList, immutableArray, instance, BoundMethodGroupFlags.None, diagnostics);
                            }
                            break;
                        }
                    case BoundKind.TypeOrValueExpression:
                        return BindInstanceMemberAccess(node, right, boundLeft, valueText, arity, separatedSyntaxList, immutableArray, invoked, indexed, diagnostics);
                    default:
                        if (boundLeft.Kind == BoundKind.Literal && ((BoundLiteral)boundLeft).ConstantValueOpt == ConstantValue.Null)
                        {
                            if (!boundLeft.HasAnyErrors)
                            {
                                Error(diagnostics, ErrorCode.ERR_BadUnaryOp, node, operatorToken.Text, boundLeft.Display);
                            }
                            return BadExpression(node, boundLeft);
                        }
                        if ((object)type != null)
                        {
                            boundLeft = CheckValue(boundLeft, BindValueKind.RValue, diagnostics);
                            boundLeft = BindToNaturalType(boundLeft, diagnostics);
                            return BindInstanceMemberAccess(node, right, boundLeft, valueText, arity, separatedSyntaxList, immutableArray, invoked, indexed, diagnostics);
                        }
                        break;
                }
                BindMemberAccessReportError(node, right, valueText, boundLeft, instance.Error, diagnostics);
                return BindMemberAccessBadResult(node, valueText, boundLeft, instance.Error, instance.Symbols.ToImmutable(), instance.Kind);
            }
            finally
            {
                instance.Free();
            }
        }

        private void WarnOnAccessOfOffDefault(SyntaxNode node, BoundExpression boundLeft, BindingDiagnosticBag diagnostics)
        {
            if ((boundLeft is BoundDefaultLiteral || boundLeft is BoundDefaultExpression) && boundLeft.ConstantValue == ConstantValue.Null && Compilation.LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())
            {
                Error(diagnostics, ErrorCode.WRN_DotOnDefault, node, boundLeft.Type);
            }
        }

        private BoundExpression MakeMemberAccessValue(BoundExpression expr, BindingDiagnosticBag diagnostics)
        {
            switch (expr.Kind)
            {
                case BoundKind.MethodGroup:
                    {
                        BoundMethodGroup boundMethodGroup = (BoundMethodGroup)expr;
                        CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                        CallingConventionInfo callingConventionInfo = default(CallingConventionInfo);
                        MethodGroupResolution methodGroupResolution = ResolveMethodGroup(boundMethodGroup, null, isMethodGroupConversion: false, ref useSiteInfo, inferWithDynamic: false, RefKind.None, null, isFunctionPointerResolution: false, in callingConventionInfo);
                        diagnostics.Add(expr.Syntax, useSiteInfo);
                        if (!expr.HasAnyErrors)
                        {
                            diagnostics.AddRange(methodGroupResolution.Diagnostics);
                            if (methodGroupResolution.MethodGroup != null && !methodGroupResolution.HasAnyErrors)
                            {
                                MethodSymbol methodSymbol = methodGroupResolution.MethodGroup.Methods[0];
                                Error(diagnostics, ErrorCode.ERR_BadSKunknown, boundMethodGroup.NameSyntax, methodSymbol, MessageID.IDS_SK_METHOD.Localize());
                            }
                        }
                        expr = BindMemberAccessBadResult(boundMethodGroup);
                        methodGroupResolution.Free();
                        return expr;
                    }
                case BoundKind.PropertyGroup:
                    return BindIndexedPropertyAccess((BoundPropertyGroup)expr, mustHaveAllOptionalParameters: false, diagnostics);
                default:
                    return BindToNaturalType(expr, diagnostics);
            }
        }

        private BoundExpression BindInstanceMemberAccess(SyntaxNode node, SyntaxNode right, BoundExpression boundLeft, string rightName, int rightArity, SeparatedSyntaxList<TypeSyntax> typeArgumentsSyntax, ImmutableArray<TypeWithAnnotations> typeArgumentsWithAnnotations, bool invoked, bool indexed, BindingDiagnosticBag diagnostics)
        {
            TypeSymbol type = boundLeft.Type;
            LookupOptions lookupOptions = LookupOptions.AllMethodsOnArityZero;
            if (invoked)
            {
                lookupOptions |= LookupOptions.MustBeInvocableIfMember;
            }
            LookupResult instance = LookupResult.GetInstance();
            try
            {
                bool num = boundLeft.Kind == BoundKind.BaseReference;
                if (num)
                {
                    lookupOptions |= LookupOptions.UseBaseReferenceAccessibility;
                }
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                LookupMembersWithFallback(instance, type, rightName, rightArity, ref useSiteInfo, null, lookupOptions);
                diagnostics.Add(right, useSiteInfo);
                bool flag = !num;
                BoundMethodGroupFlags boundMethodGroupFlags = BoundMethodGroupFlags.None;
                if (flag)
                {
                    boundMethodGroupFlags |= BoundMethodGroupFlags.SearchExtensionMethods;
                }
                if (instance.IsMultiViable)
                {
                    return BindMemberOfType(node, right, rightName, rightArity, indexed, boundLeft, typeArgumentsSyntax, typeArgumentsWithAnnotations, instance, boundMethodGroupFlags, diagnostics);
                }
                if (flag)
                {
                    BoundMethodGroup boundMethodGroup = new BoundMethodGroup(node, typeArgumentsWithAnnotations, boundLeft, rightName, instance.Symbols.All((Symbol s) => s.Kind == SymbolKind.Method) ? instance.Symbols.SelectAsArray(s_toMethodSymbolFunc) : ImmutableArray<MethodSymbol>.Empty, instance, boundMethodGroupFlags);
                    if (!boundMethodGroup.HasErrors && typeArgumentsSyntax.Any(SyntaxKind.OmittedTypeArgument))
                    {
                        Error(diagnostics, ErrorCode.ERR_OmittedTypeArgument, node);
                    }
                    return boundMethodGroup;
                }
                BindMemberAccessReportError(node, right, rightName, boundLeft, instance.Error, diagnostics);
                return BindMemberAccessBadResult(node, rightName, boundLeft, instance.Error, instance.Symbols.ToImmutable(), instance.Kind);
            }
            finally
            {
                instance.Free();
            }
        }

        private void BindMemberAccessReportError(BoundMethodGroup node, BindingDiagnosticBag diagnostics)
        {
            SyntaxNode nameSyntax = node.NameSyntax;
            SyntaxNode node2 = node.MemberAccessExpressionSyntax ?? nameSyntax;
            BindMemberAccessReportError(node2, nameSyntax, node.Name, node.ReceiverOpt, node.LookupError, diagnostics);
        }

        private void BindMemberAccessReportError(SyntaxNode node, SyntaxNode name, string plainName, BoundExpression boundLeft, DiagnosticInfo lookupError, BindingDiagnosticBag diagnostics)
        {
            if (!boundLeft.HasAnyErrors || boundLeft.Kind == BoundKind.TypeOrValueExpression)
            {
                if (lookupError != null)
                {
                    diagnostics.Add(new CSDiagnostic(lookupError, name.Location));
                }
                else if (node.IsQuery())
                {
                    ReportQueryLookupFailed(node, boundLeft, plainName, ImmutableArray<Symbol>.Empty, diagnostics);
                }
                else if ((object)boundLeft.Type == null)
                {
                    Error(diagnostics, ErrorCode.ERR_NoSuchMember, name, boundLeft.Display, plainName);
                }
                else if (boundLeft.Kind == BoundKind.TypeExpression || boundLeft.Kind == BoundKind.BaseReference || (node.Kind() == SyntaxKind.AwaitExpression && plainName == "GetResult"))
                {
                    Error(diagnostics, ErrorCode.ERR_NoSuchMember, name, boundLeft.Type, plainName);
                }
                else if (WouldUsingSystemFindExtension(boundLeft.Type, plainName))
                {
                    Error(diagnostics, ErrorCode.ERR_NoSuchMemberOrExtensionNeedUsing, name, boundLeft.Type, plainName, "System");
                }
                else
                {
                    Error(diagnostics, ErrorCode.ERR_NoSuchMemberOrExtension, name, boundLeft.Type, plainName);
                }
            }
        }

        private bool WouldUsingSystemFindExtension(TypeSymbol receiver, string methodName)
        {
            if (methodName == "GetAwaiter")
            {
                return ImplementsWinRTAsyncInterface(receiver);
            }
            return false;
        }

        private bool ImplementsWinRTAsyncInterface(TypeSymbol type)
        {
            if (!IsWinRTAsyncInterface(type))
            {
                return type.AllInterfacesNoUseSiteDiagnostics.Any((NamedTypeSymbol i) => IsWinRTAsyncInterface(i));
            }
            return true;
        }

        private bool IsWinRTAsyncInterface(TypeSymbol type)
        {
            if (!type.IsInterfaceType())
            {
                return false;
            }
            NamedTypeSymbol constructedFrom = ((NamedTypeSymbol)type).ConstructedFrom;
            if (!TypeSymbol.Equals(constructedFrom, Compilation.GetWellKnownType(WellKnownType.Windows_Foundation_IAsyncAction), TypeCompareKind.ConsiderEverything) && !TypeSymbol.Equals(constructedFrom, Compilation.GetWellKnownType(WellKnownType.Windows_Foundation_IAsyncActionWithProgress_T), TypeCompareKind.ConsiderEverything) && !TypeSymbol.Equals(constructedFrom, Compilation.GetWellKnownType(WellKnownType.Windows_Foundation_IAsyncOperation_T), TypeCompareKind.ConsiderEverything))
            {
                return TypeSymbol.Equals(constructedFrom, Compilation.GetWellKnownType(WellKnownType.Windows_Foundation_IAsyncOperationWithProgress_T2), TypeCompareKind.ConsiderEverything);
            }
            return true;
        }

        private BoundExpression BindMemberAccessBadResult(BoundMethodGroup node)
        {
            SyntaxNode nameSyntax = node.NameSyntax;
            SyntaxNode node2 = node.MemberAccessExpressionSyntax ?? nameSyntax;
            return BindMemberAccessBadResult(node2, node.Name, node.ReceiverOpt, node.LookupError, StaticCast<Symbol>.From(node.Methods), node.ResultKind);
        }

        private BoundExpression BindMemberAccessBadResult(SyntaxNode node, string nameString, BoundExpression boundLeft, DiagnosticInfo lookupError, ImmutableArray<Symbol> symbols, LookupResultKind lookupKind)
        {
            if (symbols.Length > 0 && symbols[0].Kind == SymbolKind.Method)
            {
                ArrayBuilder<MethodSymbol> instance = ArrayBuilder<MethodSymbol>.GetInstance();
                ImmutableArray<Symbol>.Enumerator enumerator = symbols.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    if (enumerator.Current is MethodSymbol item)
                    {
                        instance.Add(item);
                    }
                }
                ImmutableArray<MethodSymbol> methods = instance.ToImmutableAndFree();
                return new BoundMethodGroup(node, default(ImmutableArray<TypeWithAnnotations>), nameString, methods, (methods.Length == 1) ? methods[0] : null, lookupError, BoundMethodGroupFlags.None, boundLeft, lookupKind, hasErrors: true);
            }
            Symbol symbol = ((symbols.Length == 1) ? symbols[0] : null);
            return new BoundBadExpression(node, lookupKind, ((object)symbol == null) ? ImmutableArray<Symbol>.Empty : ImmutableArray.Create(symbol), (boundLeft == null) ? ImmutableArray<BoundExpression>.Empty : ImmutableArray.Create(BindToTypeForErrorRecovery(boundLeft)), GetNonMethodMemberType(symbol));
        }

        private TypeSymbol GetNonMethodMemberType(Symbol symbolOpt)
        {
            TypeSymbol typeSymbol = null;
            if ((object)symbolOpt != null)
            {
                switch (symbolOpt.Kind)
                {
                    case SymbolKind.Field:
                        typeSymbol = ((FieldSymbol)symbolOpt).GetFieldType(FieldsBeingBound).Type;
                        break;
                    case SymbolKind.Property:
                        typeSymbol = ((PropertySymbol)symbolOpt).Type;
                        break;
                    case SymbolKind.Event:
                        typeSymbol = ((EventSymbol)symbolOpt).Type;
                        break;
                }
            }
            return typeSymbol ?? CreateErrorType();
        }

        private static void CombineExtensionMethodArguments(BoundExpression receiver, AnalyzedArguments originalArguments, AnalyzedArguments extensionMethodArguments)
        {
            extensionMethodArguments.IsExtensionMethodInvocation = true;
            extensionMethodArguments.Arguments.Add(receiver);
            extensionMethodArguments.Arguments.AddRange(originalArguments.Arguments);
            if (originalArguments.Names.Count > 0)
            {
                extensionMethodArguments.Names.Add(null);
                extensionMethodArguments.Names.AddRange(originalArguments.Names);
            }
            if (originalArguments.RefKinds.Count > 0)
            {
                extensionMethodArguments.RefKinds.Add(RefKind.None);
                extensionMethodArguments.RefKinds.AddRange(originalArguments.RefKinds);
            }
        }

        private BoundExpression BindMemberOfType(SyntaxNode node, SyntaxNode right, string plainName, int arity, bool indexed, BoundExpression left, SeparatedSyntaxList<TypeSyntax> typeArgumentsSyntax, ImmutableArray<TypeWithAnnotations> typeArgumentsWithAnnotations, LookupResult lookupResult, BoundMethodGroupFlags methodGroupFlags, BindingDiagnosticBag diagnostics)
        {
            ArrayBuilder<Symbol> instance = ArrayBuilder<Symbol>.GetInstance();
            Symbol symbolOrMethodOrPropertyGroup = GetSymbolOrMethodOrPropertyGroup(lookupResult, right, plainName, arity, instance, diagnostics, out bool wasError, (left is BoundTypeExpression boundTypeExpression) ? boundTypeExpression.Type : null);
            BoundExpression result;
            if ((object)symbolOrMethodOrPropertyGroup == null)
            {
                result = ConstructBoundMemberGroupAndReportOmittedTypeArguments(node, typeArgumentsSyntax, typeArgumentsWithAnnotations, left, plainName, instance, lookupResult, methodGroupFlags, wasError, diagnostics);
            }
            else
            {
                left = ReplaceTypeOrValueReceiver(left, symbolOrMethodOrPropertyGroup.IsStatic || symbolOrMethodOrPropertyGroup.Kind == SymbolKind.NamedType, diagnostics);
                if (symbolOrMethodOrPropertyGroup.Kind != SymbolKind.Event)
                {
                    ReportDiagnosticsIfObsolete(diagnostics, symbolOrMethodOrPropertyGroup, node, left.Kind == BoundKind.BaseReference);
                }
                switch (symbolOrMethodOrPropertyGroup.Kind)
                {
                    case SymbolKind.ErrorType:
                    case SymbolKind.NamedType:
                        {
                            if (IsInstanceReceiver(left) == true && !wasError)
                            {
                                Error(diagnostics, ErrorCode.ERR_BadTypeReference, right, plainName, symbolOrMethodOrPropertyGroup);
                                wasError = true;
                            }
                            NamedTypeSymbol namedTypeSymbol = (NamedTypeSymbol)symbolOrMethodOrPropertyGroup;
                            if (!typeArgumentsWithAnnotations.IsDefault)
                            {
                                namedTypeSymbol = ConstructNamedTypeUnlessTypeArgumentOmitted(right, namedTypeSymbol, typeArgumentsSyntax, typeArgumentsWithAnnotations, diagnostics);
                            }
                            result = new BoundTypeExpression(node, null, left as BoundTypeExpression, ImmutableArray<BoundExpression>.Empty, TypeWithAnnotations.Create(namedTypeSymbol));
                            break;
                        }
                    case SymbolKind.Property:
                        result = BindPropertyAccess(node, left, (PropertySymbol)symbolOrMethodOrPropertyGroup, diagnostics, lookupResult.Kind, wasError);
                        break;
                    case SymbolKind.Event:
                        result = BindEventAccess(node, left, (EventSymbol)symbolOrMethodOrPropertyGroup, diagnostics, lookupResult.Kind, wasError);
                        break;
                    case SymbolKind.Field:
                        result = BindFieldAccess(node, left, (FieldSymbol)symbolOrMethodOrPropertyGroup, diagnostics, lookupResult.Kind, indexed, wasError);
                        break;
                    default:
                        throw ExceptionUtilities.UnexpectedValue(symbolOrMethodOrPropertyGroup.Kind);
                }
            }
            instance.Free();
            return result;
        }

        protected MethodGroupResolution BindExtensionMethod(SyntaxNode expression, string methodName, AnalyzedArguments analyzedArguments, BoundExpression left, ImmutableArray<TypeWithAnnotations> typeArgumentsWithAnnotations, bool isMethodGroupConversion, RefKind returnRefKind, TypeSymbol returnType, bool withDependencies)
        {
            MethodGroupResolution result = default(MethodGroupResolution);
            AnalyzedArguments analyzedArguments2 = null;
            ExtensionMethodScopeEnumerator enumerator = new ExtensionMethodScopes(this).GetEnumerator();
            while (enumerator.MoveNext())
            {
                ExtensionMethodScope current = enumerator.Current;
                MethodGroup instance = MethodGroup.GetInstance();
                BindingDiagnosticBag instance2 = BindingDiagnosticBag.GetInstance(withDiagnostics: true, withDependencies);
                PopulateExtensionMethodsFromSingleBinder(current, instance, expression, left, methodName, typeArgumentsWithAnnotations, instance2);
                if (analyzedArguments == null)
                {
                    if (expression == EnclosingNameofArgument)
                    {
                        for (int num = instance.Methods.Count - 1; num >= 0; num--)
                        {
                            if ((object)instance.Methods[num].ReduceExtensionMethod(left.Type, Compilation) == null)
                            {
                                instance.Methods.RemoveAt(num);
                            }
                        }
                    }
                    if (instance.Methods.Count != 0)
                    {
                        return new MethodGroupResolution(instance, instance2.ToReadOnlyAndFree());
                    }
                }
                if (instance.Methods.Count == 0)
                {
                    instance.Free();
                    instance2.Free();
                    continue;
                }
                if (analyzedArguments2 == null)
                {
                    analyzedArguments2 = AnalyzedArguments.GetInstance();
                    CombineExtensionMethodArguments(left, analyzedArguments, analyzedArguments2);
                }
                OverloadResolutionResult<MethodSymbol> instance3 = OverloadResolutionResult<MethodSymbol>.GetInstance();
                bool allowRefOmittedArguments = instance.Receiver.IsExpressionOfComImportType();
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(instance2);
                OverloadResolution overloadResolution = OverloadResolution;
                ArrayBuilder<MethodSymbol> methods = instance.Methods;
                ArrayBuilder<TypeWithAnnotations> typeArguments = instance.TypeArguments;
                BoundExpression receiver = instance.Receiver;
                AnalyzedArguments arguments = analyzedArguments2;
                CallingConventionInfo callingConventionInfo = default(CallingConventionInfo);
                overloadResolution.MethodInvocationOverloadResolution(methods, typeArguments, receiver, arguments, instance3, ref useSiteInfo, isMethodGroupConversion, allowRefOmittedArguments, inferWithDynamic: false, allowUnexpandedForm: true, returnRefKind, returnType, isFunctionPointerResolution: false, in callingConventionInfo);
                instance2.Add(expression, useSiteInfo);
                ImmutableBindingDiagnostic<AssemblySymbol> diagnostics = instance2.ToReadOnlyAndFree();
                MethodGroupResolution methodGroupResolution = new MethodGroupResolution(instance, null, instance3, AnalyzedArguments.GetInstance(analyzedArguments2), instance.ResultKind, diagnostics);
                if (methodGroupResolution.HasAnyApplicableMethod)
                {
                    if (!result.IsEmpty)
                    {
                        result.MethodGroup.Free();
                        result.OverloadResolutionResult.Free();
                    }
                    return methodGroupResolution;
                }
                if (result.IsEmpty)
                {
                    result = methodGroupResolution;
                    continue;
                }
                instance3.Free();
                instance.Free();
            }
            analyzedArguments2?.Free();
            return result;
        }

        private void PopulateExtensionMethodsFromSingleBinder(ExtensionMethodScope scope, MethodGroup methodGroup, SyntaxNode node, BoundExpression left, string rightName, ImmutableArray<TypeWithAnnotations> typeArgumentsWithAnnotations, BindingDiagnosticBag diagnostics)
        {
            int arity;
            LookupOptions options;
            if (typeArgumentsWithAnnotations.IsDefault)
            {
                arity = 0;
                options = LookupOptions.AllMethodsOnArityZero;
            }
            else
            {
                arity = typeArgumentsWithAnnotations.Length;
                options = LookupOptions.Default;
            }
            LookupResult instance = LookupResult.GetInstance();
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            LookupExtensionMethodsInSingleBinder(scope, instance, rightName, arity, options, ref useSiteInfo);
            diagnostics.Add(node, useSiteInfo);
            if (instance.IsMultiViable)
            {
                ArrayBuilder<Symbol> instance2 = ArrayBuilder<Symbol>.GetInstance();
                GetSymbolOrMethodOrPropertyGroup(instance, node, rightName, arity, instance2, diagnostics, out var _, null);
                methodGroup.PopulateWithExtensionMethods(left, instance2, typeArgumentsWithAnnotations, instance.Kind);
                instance2.Free();
            }
            instance.Free();
        }

        protected BoundExpression BindFieldAccess(SyntaxNode node, BoundExpression receiver, FieldSymbol fieldSymbol, BindingDiagnosticBag diagnostics, LookupResultKind resultKind, bool indexed, bool hasErrors)
        {
            bool flag = false;
            NamedTypeSymbol containingType = fieldSymbol.ContainingType;
            bool flag2 = fieldSymbol.IsStatic && containingType.IsEnumType();
            if (flag2 && !containingType.IsValidEnumType())
            {
                Error(diagnostics, ErrorCode.ERR_BindToBogus, node, fieldSymbol);
                flag = true;
            }
            if (!flag)
            {
                flag = CheckInstanceOrStatic(node, receiver, fieldSymbol, ref resultKind, diagnostics);
            }
            if (!flag && fieldSymbol.IsFixedSizeBuffer && !IsInsideNameof)
            {
                TypeSymbol type = receiver.Type;
                flag = (object)type == null || !type.IsValueType;
                if (!flag)
                {
                    bool flag3 = SyntaxFacts.IsFixedStatementExpression(node);
                    if (IsMoveableVariable(receiver, out var _) != flag3)
                    {
                        if (indexed)
                        {
                            CheckFeatureAvailability(node, MessageID.IDS_FeatureIndexingMovableFixedBuffers, diagnostics);
                        }
                        else
                        {
                            Error(diagnostics, flag3 ? ErrorCode.ERR_FixedNotNeeded : ErrorCode.ERR_FixedBufferNotFixed, node);
                            hasErrors = (flag = true);
                        }
                    }
                }
                if (!flag)
                {
                    flag = !CheckValueKind(node, receiver, BindValueKind.FixedReceiver, checkingReceiver: false, diagnostics);
                }
            }
            ConstantValue constantValue = null;
            if (fieldSymbol.IsConst && !IsInsideNameof)
            {
                constantValue = fieldSymbol.GetConstantValue(ConstantFieldsInProgress, IsEarlyAttributeBinder);
                if (constantValue == ConstantValue.Unset)
                {
                    constantValue = ConstantValue.Bad;
                }
            }
            if (!fieldSymbol.IsStatic)
            {
                WarnOnAccessOfOffDefault(node, receiver, diagnostics);
            }
            if (!IsBadBaseAccess(node, receiver, fieldSymbol, diagnostics))
            {
                CheckRuntimeSupportForSymbolAccess(node, receiver, fieldSymbol, diagnostics);
            }
            TypeSymbol type2 = fieldSymbol.GetFieldType(FieldsBeingBound).Type;
            BoundExpression boundExpression = new BoundFieldAccess(node, receiver, fieldSymbol, constantValue, resultKind, type2, hasErrors || flag);
            if (InEnumMemberInitializer())
            {
                NamedTypeSymbol namedTypeSymbol = null;
                if (flag2)
                {
                    namedTypeSymbol = containingType;
                }
                else if (constantValue != null && type2.IsEnumType())
                {
                    namedTypeSymbol = (NamedTypeSymbol)type2;
                }
                if ((object)namedTypeSymbol != null)
                {
                    NamedTypeSymbol enumUnderlyingType = namedTypeSymbol.EnumUnderlyingType;
                    boundExpression = new BoundConversion(node, boundExpression, Conversion.ImplicitNumeric, @checked: true, explicitCastInCode: false, null, boundExpression.ConstantValue, enumUnderlyingType);
                }
            }
            return boundExpression;
        }

        private bool InEnumMemberInitializer()
        {
            NamedTypeSymbol containingType = ContainingType;
            if (InFieldInitializer && (object)containingType != null)
            {
                return containingType.IsEnumType();
            }
            return false;
        }

        private BoundExpression BindPropertyAccess(SyntaxNode node, BoundExpression receiver, PropertySymbol propertySymbol, BindingDiagnosticBag diagnostics, LookupResultKind lookupResult, bool hasErrors)
        {
            bool flag = CheckInstanceOrStatic(node, receiver, propertySymbol, ref lookupResult, diagnostics);
            if (!propertySymbol.IsStatic)
            {
                WarnOnAccessOfOffDefault(node, receiver, diagnostics);
            }
            return new BoundPropertyAccess(node, receiver, propertySymbol, lookupResult, propertySymbol.Type, hasErrors || flag);
        }

        private void CheckRuntimeSupportForSymbolAccess(SyntaxNode node, BoundExpression receiverOpt, Symbol symbol, BindingDiagnosticBag diagnostics)
        {
            NamedTypeSymbol containingType = symbol.ContainingType;
            if ((object)containingType == null || !containingType.IsInterface || Compilation.Assembly.RuntimeSupportsDefaultInterfaceImplementation || !(Compilation.SourceModule != symbol.ContainingModule))
            {
                return;
            }
            if (!symbol.IsStatic && !(symbol is TypeSymbol) && !symbol.IsImplementableInterfaceMember())
            {
                Error(diagnostics, ErrorCode.ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation, node);
                return;
            }
            Accessibility declaredAccessibility = symbol.DeclaredAccessibility;
            if ((uint)(declaredAccessibility - 2) <= 1u || declaredAccessibility == Accessibility.ProtectedOrInternal)
            {
                Error(diagnostics, ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember, node);
            }
        }

        private BoundExpression BindEventAccess(SyntaxNode node, BoundExpression receiver, EventSymbol eventSymbol, BindingDiagnosticBag diagnostics, LookupResultKind lookupResult, bool hasErrors)
        {
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            bool isUsableAsField = eventSymbol.HasAssociatedField && IsAccessible(eventSymbol.AssociatedField, ref useSiteInfo, receiver?.Type);
            diagnostics.Add(node, useSiteInfo);
            bool flag = CheckInstanceOrStatic(node, receiver, eventSymbol, ref lookupResult, diagnostics);
            if (!eventSymbol.IsStatic)
            {
                WarnOnAccessOfOffDefault(node, receiver, diagnostics);
            }
            return new BoundEventAccess(node, receiver, eventSymbol, isUsableAsField, lookupResult, eventSymbol.Type, hasErrors || flag);
        }

        private static bool? IsInstanceReceiver(BoundExpression receiver)
        {
            if (receiver == null)
            {
                return false;
            }
            return receiver.Kind switch
            {
                BoundKind.PreviousSubmissionReference => null,
                BoundKind.TypeExpression => false,
                BoundKind.QueryClause => IsInstanceReceiver(((BoundQueryClause)receiver).Value),
                _ => true,
            };
        }

        private bool CheckInstanceOrStatic(SyntaxNode node, BoundExpression receiver, Symbol symbol, ref LookupResultKind resultKind, BindingDiagnosticBag diagnostics)
        {
            bool? flag = IsInstanceReceiver(receiver);
            if (!symbol.RequiresInstanceReceiver())
            {
                if (flag == true)
                {
                    ErrorCode code = (Flags.Includes(BinderFlags.ObjectInitializerMember) ? ErrorCode.ERR_StaticMemberInObjectInitializer : ErrorCode.ERR_ObjectProhibited);
                    Error(diagnostics, code, node, symbol);
                    resultKind = LookupResultKind.StaticInstanceMismatch;
                    return true;
                }
            }
            else if (flag == false && !IsInsideNameof)
            {
                Error(diagnostics, ErrorCode.ERR_ObjectRequired, node, symbol);
                resultKind = LookupResultKind.StaticInstanceMismatch;
                return true;
            }
            return false;
        }

        private Symbol GetSymbolOrMethodOrPropertyGroup(LookupResult result, SyntaxNode node, string plainName, int arity, ArrayBuilder<Symbol> methodOrPropertyGroup, BindingDiagnosticBag diagnostics, out bool wasError, NamespaceOrTypeSymbol qualifierOpt)
        {
            node = GetNameSyntax(node) ?? node;
            wasError = false;
            Symbol symbol = null;
            ArrayBuilder<Symbol>.Enumerator enumerator = result.Symbols.GetEnumerator();
            while (enumerator.MoveNext())
            {
                Symbol current = enumerator.Current;
                SymbolKind kind = current.Kind;
                if (methodOrPropertyGroup.Count > 0)
                {
                    SymbolKind kind2 = methodOrPropertyGroup[0].Kind;
                    if (kind2 != kind)
                    {
                        if (kind2 == SymbolKind.Method || (kind2 == SymbolKind.Property && kind != SymbolKind.Method))
                        {
                            symbol = current;
                            continue;
                        }
                        symbol = methodOrPropertyGroup[0];
                        methodOrPropertyGroup.Clear();
                    }
                }
                if (kind == SymbolKind.Method || kind == SymbolKind.Property)
                {
                    methodOrPropertyGroup.Add(current);
                }
                else
                {
                    symbol = current;
                }
            }
            if (methodOrPropertyGroup.Count > 0 && IsMethodOrPropertyGroup(methodOrPropertyGroup) && (methodOrPropertyGroup[0].Kind == SymbolKind.Method || (object)symbol == null))
            {
                if (result.Error != null)
                {
                    Error(diagnostics, result.Error, node);
                    wasError = result.Error.Severity == DiagnosticSeverity.Error;
                }
                return null;
            }
            methodOrPropertyGroup.Clear();
            return ResultSymbol(result, plainName, arity, node, diagnostics, suppressUseSiteDiagnostics: false, out wasError, qualifierOpt);
        }

        private static bool IsMethodOrPropertyGroup(ArrayBuilder<Symbol> members)
        {
            Symbol symbol = members[0];
            switch (symbol.Kind)
            {
                case SymbolKind.Method:
                    return true;
                case SymbolKind.Property:
                    {
                        ArrayBuilder<Symbol>.Enumerator enumerator = members.GetEnumerator();
                        while (enumerator.MoveNext())
                        {
                            if (((PropertySymbol)enumerator.Current).IsIndexedProperty)
                            {
                                return true;
                            }
                        }
                        return false;
                    }
                default:
                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);
            }
        }

        private BoundExpression BindElementAccess(ElementAccessExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            BoundExpression receiver = BindExpression(node.Expression, diagnostics, invoked: false, indexed: true);
            return BindElementAccess(node, receiver, node.ArgumentList, diagnostics);
        }

        private BoundExpression BindElementAccess(ExpressionSyntax node, BoundExpression receiver, BracketedArgumentListSyntax argumentList, BindingDiagnosticBag diagnostics)
        {
            AnalyzedArguments instance = AnalyzedArguments.GetInstance();
            try
            {
                BindArgumentsAndNames(argumentList, diagnostics, instance);
                if (receiver.Kind == BoundKind.PropertyGroup)
                {
                    BoundPropertyGroup boundPropertyGroup = (BoundPropertyGroup)receiver;
                    return BindIndexedPropertyAccess(node, boundPropertyGroup.ReceiverOpt, boundPropertyGroup.Properties, instance, diagnostics);
                }
                receiver = CheckValue(receiver, BindValueKind.RValue, diagnostics);
                receiver = BindToNaturalType(receiver, diagnostics);
                return BindElementOrIndexerAccess(node, receiver, instance, diagnostics);
            }
            finally
            {
                instance.Free();
            }
        }

        private BoundExpression BindElementOrIndexerAccess(ExpressionSyntax node, BoundExpression expr, AnalyzedArguments analyzedArguments, BindingDiagnosticBag diagnostics)
        {
            if ((object)expr.Type == null)
            {
                return BadIndexerExpression(node, expr, analyzedArguments, null, diagnostics);
            }
            WarnOnAccessOfOffDefault(node, expr, diagnostics);
            if (analyzedArguments.HasErrors || expr.HasAnyErrors)
            {
                return BindElementAccessCore(node, expr, analyzedArguments, BindingDiagnosticBag.Discarded);
            }
            return BindElementAccessCore(node, expr, analyzedArguments, diagnostics);
        }

        private BoundExpression BadIndexerExpression(ExpressionSyntax node, BoundExpression expr, AnalyzedArguments analyzedArguments, DiagnosticInfo errorOpt, BindingDiagnosticBag diagnostics)
        {
            if (!expr.HasAnyErrors)
            {
                diagnostics.Add(errorOpt ?? new CSDiagnosticInfo(ErrorCode.ERR_BadIndexLHS, expr.Display), node.Location);
            }
            ImmutableArray<BoundExpression> childBoundNodes = BuildArgumentsForErrorRecovery(analyzedArguments).Add(expr);
            return new BoundBadExpression(node, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, childBoundNodes, CreateErrorType(), hasErrors: true);
        }

        private BoundExpression BindElementAccessCore(ExpressionSyntax node, BoundExpression expr, AnalyzedArguments arguments, BindingDiagnosticBag diagnostics)
        {
            switch (expr.Type!.TypeKind)
            {
                case TypeKind.Array:
                    return BindArrayAccess(node, expr, arguments, diagnostics);
                case TypeKind.Dynamic:
                    return BindDynamicIndexer(node, expr, arguments, ImmutableArray<PropertySymbol>.Empty, diagnostics);
                case TypeKind.Pointer:
                    return BindPointerElementAccess(node, expr, arguments, diagnostics);
                case TypeKind.Class:
                case TypeKind.Interface:
                case TypeKind.Struct:
                case TypeKind.TypeParameter:
                    return BindIndexerAccess(node, expr, arguments, diagnostics);
                default:
                    return BadIndexerExpression(node, expr, arguments, null, diagnostics);
            }
        }

        private BoundExpression BindArrayAccess(ExpressionSyntax node, BoundExpression expr, AnalyzedArguments arguments, BindingDiagnosticBag diagnostics)
        {
            if (arguments.Names.Count > 0)
            {
                Error(diagnostics, ErrorCode.ERR_NamedArgumentForArray, node);
            }
            bool flag = ReportRefOrOutArgument(arguments, diagnostics);
            ArrayTypeSymbol arrayTypeSymbol = (ArrayTypeSymbol)expr.Type;
            int rank = arrayTypeSymbol.Rank;
            if (arguments.Arguments.Count != rank)
            {
                Error(diagnostics, ErrorCode.ERR_BadIndexCount, node, rank);
                return new BoundArrayAccess(node, expr, BuildArgumentsForErrorRecovery(arguments), arrayTypeSymbol.ElementType, hasErrors: true);
            }
            BoundExpression[] array = new BoundExpression[arguments.Arguments.Count];
            for (int i = 0; i < arguments.Arguments.Count; i++)
            {
                BoundExpression index = arguments.Arguments[i];
                BoundExpression boundExpression = (array[i] = ConvertToArrayIndex(index, node, diagnostics, rank == 1));
                if (rank == 1 && !boundExpression.HasAnyErrors)
                {
                    ConstantValue constantValue = boundExpression.ConstantValue;
                    if (constantValue != null && constantValue.IsNegativeNumeric)
                    {
                        Error(diagnostics, ErrorCode.WRN_NegativeArrayIndex, boundExpression.Syntax);
                    }
                }
            }
            TypeSymbol type = ((rank == 1 && TypeSymbol.Equals(array[0].Type, Compilation.GetWellKnownType(WellKnownType.System_Range), TypeCompareKind.ConsiderEverything)) ? arrayTypeSymbol : arrayTypeSymbol.ElementType);
            if (!flag)
            {
                return new BoundArrayAccess(node, expr, array.AsImmutableOrNull(), type);
            }
            return new BoundArrayAccess(node, BindToTypeForErrorRecovery(expr), array.Select((BoundExpression e) => BindToTypeForErrorRecovery(e)).AsImmutableOrNull(), type, hasErrors: true);
        }

        private BoundExpression ConvertToArrayIndex(BoundExpression index, SyntaxNode node, BindingDiagnosticBag diagnostics, bool allowIndexAndRange)
        {
            if (index.Kind == BoundKind.OutVariablePendingInference)
            {
                return ((OutVariablePendingInference)index).FailInference(this, diagnostics);
            }
            if (index.Kind == BoundKind.DiscardExpression && !index.HasExpressionType())
            {
                return ((BoundDiscardExpression)index).FailInference(this, diagnostics);
            }
            BoundExpression boundExpression = TryImplicitConversionToArrayIndex(index, SpecialType.System_Int32, node, diagnostics) ?? TryImplicitConversionToArrayIndex(index, SpecialType.System_UInt32, node, diagnostics) ?? TryImplicitConversionToArrayIndex(index, SpecialType.System_Int64, node, diagnostics) ?? TryImplicitConversionToArrayIndex(index, SpecialType.System_UInt64, node, diagnostics);
            if (boundExpression == null && allowIndexAndRange)
            {
                boundExpression = TryImplicitConversionToArrayIndex(index, WellKnownType.System_Index, node, diagnostics);
                if (boundExpression == null)
                {
                    boundExpression = TryImplicitConversionToArrayIndex(index, WellKnownType.System_Range, node, diagnostics);
                    if (boundExpression != null)
                    {
                        GetWellKnownTypeMember(WellKnownMember.System_Runtime_CompilerServices_RuntimeHelpers__GetSubArray_T, diagnostics, null, node);
                    }
                }
                else
                {
                    GetWellKnownTypeMember(WellKnownMember.System_Index__GetOffset, diagnostics, null, node);
                }
            }
            if (boundExpression == null)
            {
                NamedTypeSymbol specialType = GetSpecialType(SpecialType.System_Int32, diagnostics, node);
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                Conversion conversion = Conversions.ClassifyConversionFromExpression(index, specialType, ref useSiteInfo);
                diagnostics.Add(node, useSiteInfo);
                GenerateImplicitConversionError(diagnostics, node, conversion, index, specialType);
                return CreateConversion(index.Syntax, index, conversion, isCast: false, null, specialType, BindingDiagnosticBag.Discarded);
            }
            return boundExpression;
        }

        private BoundExpression TryImplicitConversionToArrayIndex(BoundExpression expr, WellKnownType wellKnownType, SyntaxNode node, BindingDiagnosticBag diagnostics)
        {
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            TypeSymbol wellKnownType2 = GetWellKnownType(wellKnownType, ref useSiteInfo);
            if (wellKnownType2.IsErrorType())
            {
                return null;
            }
            BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(diagnostics);
            BoundExpression boundExpression = TryImplicitConversionToArrayIndex(expr, wellKnownType2, node, instance);
            if (boundExpression != null)
            {
                diagnostics.Add(node, useSiteInfo);
                diagnostics.AddRange(instance);
            }
            instance.Free();
            return boundExpression;
        }

        private BoundExpression TryImplicitConversionToArrayIndex(BoundExpression expr, SpecialType specialType, SyntaxNode node, BindingDiagnosticBag diagnostics)
        {
            BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(diagnostics);
            TypeSymbol specialType2 = GetSpecialType(specialType, instance, node);
            BoundExpression boundExpression = TryImplicitConversionToArrayIndex(expr, specialType2, node, instance);
            if (boundExpression != null)
            {
                diagnostics.AddRange(instance);
            }
            instance.Free();
            return boundExpression;
        }

        private BoundExpression TryImplicitConversionToArrayIndex(BoundExpression expr, TypeSymbol targetType, SyntaxNode node, BindingDiagnosticBag diagnostics)
        {
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            Conversion conversion = Conversions.ClassifyImplicitConversionFromExpression(expr, targetType, ref useSiteInfo);
            diagnostics.Add(node, useSiteInfo);
            if (!conversion.Exists)
            {
                return null;
            }
            if (conversion.IsDynamic)
            {
                conversion = conversion.SetArrayIndexConversionForDynamic();
            }
            return CreateConversion(expr.Syntax, expr, conversion, isCast: false, null, targetType, diagnostics);
        }

        private BoundExpression BindPointerElementAccess(ExpressionSyntax node, BoundExpression expr, AnalyzedArguments analyzedArguments, BindingDiagnosticBag diagnostics)
        {
            bool flag = false;
            if (analyzedArguments.Names.Count > 0)
            {
                Error(diagnostics, ErrorCode.ERR_NamedArgumentForArray, node);
                flag = true;
            }
            flag = flag || ReportRefOrOutArgument(analyzedArguments, diagnostics);
            TypeSymbol pointedAtType = ((PointerTypeSymbol)expr.Type).PointedAtType;
            ArrayBuilder<BoundExpression> arguments = analyzedArguments.Arguments;
            if (arguments.Count != 1)
            {
                if (!flag)
                {
                    Error(diagnostics, ErrorCode.ERR_PtrIndexSingle, node);
                }
                return new BoundPointerElementAccess(node, expr, BadExpression(node, BuildArgumentsForErrorRecovery(analyzedArguments)).MakeCompilerGenerated(), CheckOverflowAtRuntime, pointedAtType, hasErrors: true);
            }
            if (pointedAtType.IsVoidType())
            {
                Error(diagnostics, ErrorCode.ERR_VoidError, expr.Syntax);
                flag = true;
            }
            BoundExpression boundExpression = arguments[0];
            boundExpression = ConvertToArrayIndex(boundExpression, boundExpression.Syntax, diagnostics, allowIndexAndRange: false);
            return new BoundPointerElementAccess(node, expr, boundExpression, CheckOverflowAtRuntime, pointedAtType, flag);
        }

        private static bool ReportRefOrOutArgument(AnalyzedArguments analyzedArguments, BindingDiagnosticBag diagnostics)
        {
            int count = analyzedArguments.Arguments.Count;
            for (int i = 0; i < count; i++)
            {
                RefKind refKind = analyzedArguments.RefKind(i);
                if (refKind != 0)
                {
                    Error(diagnostics, ErrorCode.ERR_BadArgExtraRef, analyzedArguments.Argument(i).Syntax, i + 1, refKind.ToArgumentDisplayString());
                    return true;
                }
            }
            return false;
        }

        private BoundExpression BindIndexerAccess(ExpressionSyntax node, BoundExpression expr, AnalyzedArguments analyzedArguments, BindingDiagnosticBag diagnostics)
        {
            LookupResult instance = LookupResult.GetInstance();
            LookupOptions options = ((expr.Kind == BoundKind.BaseReference) ? LookupOptions.UseBaseReferenceAccessibility : LookupOptions.Default);
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            LookupMembersWithFallback(instance, expr.Type, "this[]", 0, ref useSiteInfo, null, options);
            diagnostics.Add(node, useSiteInfo);
            BoundExpression result;
            if (!instance.IsMultiViable)
            {
                result = ((!TryBindIndexOrRangeIndexer(node, expr, analyzedArguments, diagnostics, out var patternIndexerAccess)) ? BadIndexerExpression(node, expr, analyzedArguments, instance.Error, diagnostics) : patternIndexerAccess);
            }
            else
            {
                ArrayBuilder<PropertySymbol> instance2 = ArrayBuilder<PropertySymbol>.GetInstance();
                ArrayBuilder<Symbol>.Enumerator enumerator = instance.Symbols.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    Symbol current = enumerator.Current;
                    instance2.Add((PropertySymbol)current);
                }
                result = BindIndexerOrIndexedPropertyAccess(node, expr, instance2, analyzedArguments, diagnostics);
                instance2.Free();
            }
            instance.Free();
            return result;
        }

        private BoundExpression BindIndexedPropertyAccess(BoundPropertyGroup propertyGroup, bool mustHaveAllOptionalParameters, BindingDiagnosticBag diagnostics)
        {
            SyntaxNode syntax = propertyGroup.Syntax;
            BoundExpression receiverOpt = propertyGroup.ReceiverOpt;
            ImmutableArray<PropertySymbol> properties = propertyGroup.Properties;
            if (properties.All(s_isIndexedPropertyWithNonOptionalArguments))
            {
                Error(diagnostics, mustHaveAllOptionalParameters ? ErrorCode.ERR_IndexedPropertyMustHaveAllOptionalParams : ErrorCode.ERR_IndexedPropertyRequiresParams, syntax, properties[0].ToDisplayString(s_propertyGroupFormat));
                return BoundIndexerAccess.ErrorAccess(syntax, receiverOpt, CreateErrorPropertySymbol(properties), ImmutableArray<BoundExpression>.Empty, default(ImmutableArray<string>), default(ImmutableArray<RefKind>), properties);
            }
            AnalyzedArguments instance = AnalyzedArguments.GetInstance();
            BoundExpression result = BindIndexedPropertyAccess(syntax, receiverOpt, properties, instance, diagnostics);
            instance.Free();
            return result;
        }

        private BoundExpression BindIndexedPropertyAccess(SyntaxNode syntax, BoundExpression receiverOpt, ImmutableArray<PropertySymbol> propertyGroup, AnalyzedArguments arguments, BindingDiagnosticBag diagnostics)
        {
            ArrayBuilder<PropertySymbol> instance = ArrayBuilder<PropertySymbol>.GetInstance();
            instance.AddRange(propertyGroup);
            BoundExpression result = BindIndexerOrIndexedPropertyAccess(syntax, receiverOpt, instance, arguments, diagnostics);
            instance.Free();
            return result;
        }

        private BoundExpression BindDynamicIndexer(SyntaxNode syntax, BoundExpression receiver, AnalyzedArguments arguments, ImmutableArray<PropertySymbol> applicableProperties, BindingDiagnosticBag diagnostics)
        {
            bool flag = false;
            switch (receiver.Kind)
            {
                case BoundKind.BaseReference:
                    Error(diagnostics, ErrorCode.ERR_NoDynamicPhantomOnBaseIndexer, syntax);
                    flag = true;
                    break;
                case BoundKind.TypeOrValueExpression:
                    {
                        BoundTypeOrValueExpression boundTypeOrValueExpression = (BoundTypeOrValueExpression)receiver;
                        bool useType = IsInstance(boundTypeOrValueExpression.Data.ValueSymbol) && !HasThis(isExplicit: false, out bool inStaticContext);
                        receiver = ReplaceTypeOrValueReceiver(boundTypeOrValueExpression, useType, diagnostics);
                        break;
                    }
            }
            ImmutableArray<BoundExpression> arguments2 = BuildArgumentsForDynamicInvocation(arguments, diagnostics);
            ImmutableArray<RefKind> immutableArray = arguments.RefKinds.ToImmutableOrNull();
            flag &= ReportBadDynamicArguments(syntax, arguments2, immutableArray, diagnostics, null);
            return new BoundDynamicIndexerAccess(syntax, receiver, arguments2, arguments.GetNames(), immutableArray, applicableProperties, AssemblySymbol.DynamicType, flag);
        }

        private BoundExpression BindIndexerOrIndexedPropertyAccess(SyntaxNode syntax, BoundExpression receiverOpt, ArrayBuilder<PropertySymbol> propertyGroup, AnalyzedArguments analyzedArguments, BindingDiagnosticBag diagnostics)
        {
            OverloadResolutionResult<PropertySymbol> instance = OverloadResolutionResult<PropertySymbol>.GetInstance();
            bool allowRefOmittedArguments = receiverOpt.IsExpressionOfComImportType();
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            OverloadResolution.PropertyOverloadResolution(propertyGroup, receiverOpt, analyzedArguments, instance, allowRefOmittedArguments, ref useSiteInfo);
            diagnostics.Add(syntax, useSiteInfo);
            if (analyzedArguments.HasDynamicArgument && instance.HasAnyApplicableMember)
            {
                ImmutableArray<PropertySymbol> candidatesPassingFinalValidation = GetCandidatesPassingFinalValidation(syntax, instance, receiverOpt, default(ImmutableArray<TypeWithAnnotations>), diagnostics);
                instance.Free();
                return BindDynamicIndexer(syntax, receiverOpt, analyzedArguments, candidatesPassingFinalValidation, diagnostics);
            }
            ImmutableArray<string> names = analyzedArguments.GetNames();
            ImmutableArray<RefKind> immutableArray = analyzedArguments.RefKinds.ToImmutableOrNull();
            BoundExpression result;
            if (!instance.Succeeded)
            {
                ImmutableArray<PropertySymbol> immutableArray2 = propertyGroup.ToImmutable();
                if (!analyzedArguments.HasErrors)
                {
                    if (TryBindIndexOrRangeIndexer(syntax, receiverOpt, analyzedArguments, diagnostics, out var patternIndexerAccess))
                    {
                        return patternIndexerAccess;
                    }
                    PropertySymbol propertySymbol = immutableArray2[0];
                    string name = (propertySymbol.IsIndexer ? SyntaxFacts.GetText(SyntaxKind.ThisKeyword) : propertySymbol.Name);
                    instance.ReportDiagnostics(this, syntax.Location, syntax, diagnostics, name, null, null, analyzedArguments, immutableArray2, null, null);
                }
                ImmutableArray<BoundExpression> arguments = BuildArgumentsForErrorRecovery(analyzedArguments, immutableArray2);
                PropertySymbol indexer = ((immutableArray2.Length == 1) ? immutableArray2[0] : CreateErrorPropertySymbol(immutableArray2));
                result = BoundIndexerAccess.ErrorAccess(syntax, receiverOpt, indexer, arguments, names, immutableArray, immutableArray2);
            }
            else
            {
                MemberResolutionResult<PropertySymbol> validResult = instance.ValidResult;
                PropertySymbol member = validResult.Member;
                CoerceArguments(validResult, analyzedArguments.Arguments, diagnostics);
                bool expanded = validResult.Result.Kind == MemberResolutionKind.ApplicableInExpandedForm;
                ImmutableArray<int> argsToParamsOpt = validResult.Result.ArgsToParamsOpt;
                ReportDiagnosticsIfObsolete(diagnostics, member, syntax, receiverOpt != null && receiverOpt.Kind == BoundKind.BaseReference);
                bool flag = MemberGroupFinalValidationAccessibilityChecks(receiverOpt, member, syntax, diagnostics, invokedAsExtensionMethod: false);
                BoundExpression boundExpression = ReplaceTypeOrValueReceiver(receiverOpt, member.IsStatic, diagnostics);
                if (!flag && boundExpression != null && boundExpression.Kind == BoundKind.ThisReference && boundExpression.WasCompilerGenerated)
                {
                    flag = IsRefOrOutThisParameterCaptured(syntax, diagnostics);
                }
                ImmutableArray<BoundExpression> immutableArray3 = analyzedArguments.Arguments.ToImmutable();
                if (!flag)
                {
                    flag = !CheckInvocationArgMixing(syntax, member, boundExpression, member.Parameters, immutableArray3, argsToParamsOpt, LocalScopeDepth, diagnostics);
                }
                result = new BoundIndexerAccess(syntax, boundExpression, member, immutableArray3, names, immutableArray, expanded, argsToParamsOpt, default(BitVector), member.Type, flag);
            }
            instance.Free();
            return result;
        }

        private bool TryBindIndexOrRangeIndexer(SyntaxNode syntax, BoundExpression receiverOpt, AnalyzedArguments arguments, BindingDiagnosticBag diagnostics, out BoundIndexOrRangePatternIndexerAccess patternIndexerAccess)
        {
            patternIndexerAccess = null;
            if (arguments.Arguments.Count != 1)
            {
                return false;
            }
            BoundExpression boundExpression = arguments.Arguments[0];
            TypeSymbol type = boundExpression.Type;
            bool flag = TypeSymbol.Equals(type, Compilation.GetWellKnownType(WellKnownType.System_Index), TypeCompareKind.ConsiderEverything);
            bool flag2 = !flag && TypeSymbol.Equals(type, Compilation.GetWellKnownType(WellKnownType.System_Range), TypeCompareKind.ConsiderEverything);
            TypeSymbol receiverType;
            LookupResult lookupResult2;
            CompoundUseSiteInfo<AssemblySymbol> discardedUseSiteInfo;
            if (flag || flag2)
            {
                receiverType = receiverOpt?.Type;
                if ((object)receiverType != null)
                {
                    lookupResult2 = LookupResult.GetInstance();
                    discardedUseSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
                    if (!tryLookupLengthOrCount("Length", out var valid2) && !tryLookupLengthOrCount("Count", out valid2))
                    {
                        return false;
                    }
                    if (flag)
                    {
                        LookupMembersInType(lookupResult2, receiverType, "this[]", 0, null, LookupOptions.Default, this, diagnose: false, ref discardedUseSiteInfo);
                        if (lookupResult2.IsMultiViable)
                        {
                            ArrayBuilder<Symbol>.Enumerator enumerator = lookupResult2.Symbols.GetEnumerator();
                            while (enumerator.MoveNext())
                            {
                                Symbol current = enumerator.Current;
                                if (!current.IsStatic && current is PropertySymbol propertySymbol && IsAccessible(propertySymbol, ref discardedUseSiteInfo))
                                {
                                    PropertySymbol originalDefinition = propertySymbol.OriginalDefinition;
                                    if ((object)originalDefinition != null && originalDefinition.ParameterCount == 1 && isIntNotByRef(originalDefinition.Parameters[0]))
                                    {
                                        CheckImplicitThisCopyInReadOnlyMember(receiverOpt, valid2.GetMethod, diagnostics);
                                        patternIndexerAccess = new BoundIndexOrRangePatternIndexerAccess(syntax, receiverOpt, valid2, propertySymbol, BindToNaturalType(boundExpression, diagnostics), propertySymbol.Type);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    else if (receiverType.SpecialType == SpecialType.System_String)
                    {
                        MethodSymbol methodSymbol = (MethodSymbol)Compilation.GetSpecialTypeMember(SpecialMember.System_String__Substring);
                        if ((object)methodSymbol != null)
                        {
                            patternIndexerAccess = new BoundIndexOrRangePatternIndexerAccess(syntax, receiverOpt, valid2, methodSymbol, BindToNaturalType(boundExpression, diagnostics), methodSymbol.ReturnType);
                            checkWellKnown(WellKnownMember.System_Range__get_Start);
                            checkWellKnown(WellKnownMember.System_Range__get_End);
                        }
                    }
                    else
                    {
                        LookupMembersInType(lookupResult2, receiverType, "Slice", 0, null, LookupOptions.Default, this, diagnose: false, ref discardedUseSiteInfo);
                        if (lookupResult2.IsMultiViable)
                        {
                            ArrayBuilder<Symbol>.Enumerator enumerator = lookupResult2.Symbols.GetEnumerator();
                            while (enumerator.MoveNext())
                            {
                                Symbol current2 = enumerator.Current;
                                if (!current2.IsStatic && IsAccessible(current2, ref discardedUseSiteInfo) && current2 is MethodSymbol methodSymbol2)
                                {
                                    MethodSymbol originalDefinition2 = methodSymbol2.OriginalDefinition;
                                    if (originalDefinition2.ParameterCount == 2 && isIntNotByRef(originalDefinition2.Parameters[0]) && isIntNotByRef(originalDefinition2.Parameters[1]))
                                    {
                                        CheckImplicitThisCopyInReadOnlyMember(receiverOpt, valid2.GetMethod, diagnostics);
                                        CheckImplicitThisCopyInReadOnlyMember(receiverOpt, methodSymbol2, diagnostics);
                                        patternIndexerAccess = new BoundIndexOrRangePatternIndexerAccess(syntax, receiverOpt, valid2, methodSymbol2, BindToNaturalType(boundExpression, diagnostics), methodSymbol2.ReturnType);
                                        checkWellKnown(WellKnownMember.System_Range__get_Start);
                                        checkWellKnown(WellKnownMember.System_Range__get_End);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    cleanup(lookupResult2);
                    if (patternIndexerAccess == null)
                    {
                        return false;
                    }
                    MessageID.IDS_FeatureIndexOperator.CheckFeatureAvailability(diagnostics, syntax);
                    checkWellKnown(WellKnownMember.System_Index__GetOffset);
                    if (arguments.Names.Count > 0)
                    {
                        diagnostics.Add(flag2 ? ErrorCode.ERR_ImplicitRangeIndexerWithName : ErrorCode.ERR_ImplicitIndexIndexerWithName, arguments.Names[0].GetLocation());
                    }
                    return true;
                }
            }
            return false;
            void checkWellKnown(WellKnownMember member)
            {
                GetWellKnownTypeMember(member, diagnostics, null, syntax);
            }
            static void cleanup(LookupResult lookupResult)
            {
                lookupResult.Free();
            }
            static bool isIntNotByRef(ParameterSymbol param)
            {
                if (param.Type.SpecialType == SpecialType.System_Int32)
                {
                    return param.RefKind == RefKind.None;
                }
                return false;
            }
            bool tryLookupLengthOrCount(string propertyName, out PropertySymbol valid)
            {
                LookupMembersInType(lookupResult2, receiverType, propertyName, 0, null, LookupOptions.Default, this, diagnose: false, ref discardedUseSiteInfo);
                if (lookupResult2.IsSingleViable && lookupResult2.Symbols[0] is PropertySymbol propertySymbol2)
                {
                    MethodSymbol methodSymbol3 = propertySymbol2.GetOwnOrInheritedGetMethod()?.OriginalDefinition;
                    if ((object)methodSymbol3 != null && methodSymbol3.ReturnType.SpecialType == SpecialType.System_Int32 && methodSymbol3.RefKind == RefKind.None && !methodSymbol3.IsStatic && IsAccessible(methodSymbol3, ref discardedUseSiteInfo))
                    {
                        lookupResult2.Clear();
                        valid = propertySymbol2;
                        return true;
                    }
                }
                lookupResult2.Clear();
                valid = null;
                return false;
            }
        }

        private ErrorPropertySymbol CreateErrorPropertySymbol(ImmutableArray<PropertySymbol> propertyGroup)
        {
            TypeSymbol type = GetCommonTypeOrReturnType(propertyGroup) ?? CreateErrorType();
            PropertySymbol propertySymbol = propertyGroup[0];
            return new ErrorPropertySymbol(propertySymbol.ContainingType, type, propertySymbol.Name, propertySymbol.IsIndexer, propertySymbol.IsIndexedProperty);
        }

        internal MethodGroupResolution ResolveMethodGroup(BoundMethodGroup node, AnalyzedArguments analyzedArguments, bool isMethodGroupConversion, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, bool inferWithDynamic = false, RefKind returnRefKind = RefKind.None, TypeSymbol returnType = null, bool isFunctionPointerResolution = false, in CallingConventionInfo callingConventionInfo = default(CallingConventionInfo))
        {
            return ResolveMethodGroup(node, node.Syntax, node.Name, analyzedArguments, isMethodGroupConversion, ref useSiteInfo, inferWithDynamic, allowUnexpandedForm: true, returnRefKind, returnType, isFunctionPointerResolution, in callingConventionInfo);
        }

        internal MethodGroupResolution ResolveMethodGroup(BoundMethodGroup node, SyntaxNode expression, string methodName, AnalyzedArguments analyzedArguments, bool isMethodGroupConversion, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, bool inferWithDynamic = false, bool allowUnexpandedForm = true, RefKind returnRefKind = RefKind.None, TypeSymbol returnType = null, bool isFunctionPointerResolution = false, in CallingConventionInfo callingConventionInfo = default(CallingConventionInfo))
        {
            MethodGroupResolution result = ResolveMethodGroupInternal(node, expression, methodName, analyzedArguments, isMethodGroupConversion, ref useSiteInfo, inferWithDynamic, allowUnexpandedForm, returnRefKind, returnType, isFunctionPointerResolution, in callingConventionInfo);
            if (result.IsEmpty && !result.HasAnyErrors)
            {
                BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(withDiagnostics: true, useSiteInfo.AccumulatesDependencies);
                instance.AddRange(result.Diagnostics);
                BindMemberAccessReportError(node, instance);
                return new MethodGroupResolution(result.MethodGroup, result.OtherSymbol, result.OverloadResolutionResult, result.AnalyzedArguments, result.ResultKind, instance.ToReadOnlyAndFree());
            }
            return result;
        }

        internal MethodGroupResolution ResolveMethodGroupForFunctionPointer(BoundMethodGroup methodGroup, AnalyzedArguments analyzedArguments, TypeSymbol returnType, RefKind returnRefKind, in CallingConventionInfo callingConventionInfo, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            return ResolveDefaultMethodGroup(methodGroup, analyzedArguments, isMethodGroupConversion: true, ref useSiteInfo, inferWithDynamic: false, allowUnexpandedForm: true, returnRefKind, returnType, isFunctionPointerResolution: true, in callingConventionInfo);
        }

        private MethodGroupResolution ResolveMethodGroupInternal(BoundMethodGroup methodGroup, SyntaxNode expression, string methodName, AnalyzedArguments analyzedArguments, bool isMethodGroupConversion, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, bool inferWithDynamic = false, bool allowUnexpandedForm = true, RefKind returnRefKind = RefKind.None, TypeSymbol returnType = null, bool isFunctionPointerResolution = false, in CallingConventionInfo callingConvention = default(CallingConventionInfo))
        {
            MethodGroupResolution result = ResolveDefaultMethodGroup(methodGroup, analyzedArguments, isMethodGroupConversion, ref useSiteInfo, inferWithDynamic, allowUnexpandedForm, returnRefKind, returnType, isFunctionPointerResolution, in callingConvention);
            if (!methodGroup.SearchExtensionMethods || result.HasAnyApplicableMethod || methodGroup.MethodGroupReceiverIsDynamic())
            {
                return result;
            }
            MethodGroupResolution result2 = BindExtensionMethod(expression, methodName, analyzedArguments, methodGroup.ReceiverOpt, methodGroup.TypeArgumentsOpt, isMethodGroupConversion, returnRefKind, returnType, useSiteInfo.AccumulatesDependencies);
            bool flag = false;
            if (result2.HasAnyApplicableMethod)
            {
                flag = true;
            }
            else if (result2.IsEmpty)
            {
                flag = false;
            }
            else if (result.IsEmpty)
            {
                flag = true;
            }
            else
            {
                LookupResultKind resultKind = result.ResultKind;
                LookupResultKind resultKind2 = result2.ResultKind;
                if (resultKind != resultKind2 && resultKind == resultKind2.WorseResultKind(resultKind))
                {
                    flag = true;
                }
            }
            if (flag)
            {
                result.Free();
                return result2;
            }
            result2.Free();
            return result;
        }

        private MethodGroupResolution ResolveDefaultMethodGroup(BoundMethodGroup node, AnalyzedArguments analyzedArguments, bool isMethodGroupConversion, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, bool inferWithDynamic = false, bool allowUnexpandedForm = true, RefKind returnRefKind = RefKind.None, TypeSymbol returnType = null, bool isFunctionPointerResolution = false, in CallingConventionInfo callingConvention = default(CallingConventionInfo))
        {
            ImmutableArray<MethodSymbol> methods = node.Methods;
            if (methods.Length == 0 && node.LookupSymbolOpt is MethodSymbol item)
            {
                methods = ImmutableArray.Create(item);
            }
            ImmutableBindingDiagnostic<AssemblySymbol> diagnostics = ImmutableBindingDiagnostic<AssemblySymbol>.Empty;
            if (node.LookupError != null)
            {
                BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(withDiagnostics: true, withDependencies: false);
                Error(instance, node.LookupError, node.NameSyntax);
                diagnostics = instance.ToReadOnlyAndFree();
            }
            if (methods.Length == 0)
            {
                return new MethodGroupResolution(node.LookupSymbolOpt, node.ResultKind, diagnostics);
            }
            MethodGroup instance2 = MethodGroup.GetInstance();
            instance2.PopulateWithNonExtensionMethods(node.ReceiverOpt, methods, node.TypeArgumentsOpt, node.ResultKind, node.LookupError);
            if (node.LookupError != null)
            {
                return new MethodGroupResolution(instance2, diagnostics);
            }
            if (analyzedArguments == null)
            {
                return new MethodGroupResolution(instance2, diagnostics);
            }
            OverloadResolutionResult<MethodSymbol> instance3 = OverloadResolutionResult<MethodSymbol>.GetInstance();
            bool allowRefOmittedArguments = instance2.Receiver.IsExpressionOfComImportType();
            OverloadResolution.MethodInvocationOverloadResolution(instance2.Methods, instance2.TypeArguments, instance2.Receiver, analyzedArguments, instance3, ref useSiteInfo, isMethodGroupConversion, allowRefOmittedArguments, inferWithDynamic, allowUnexpandedForm, returnRefKind, returnType, isFunctionPointerResolution, in callingConvention);
            return new MethodGroupResolution(instance2, null, instance3, AnalyzedArguments.GetInstance(analyzedArguments), instance2.ResultKind, diagnostics);
        }

        internal NamedTypeSymbol? GetMethodGroupDelegateType(BoundMethodGroup node, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            MethodSymbol uniqueSignatureFromMethodGroup = GetUniqueSignatureFromMethodGroup(node);
            if ((object)uniqueSignatureFromMethodGroup != null)
            {
                NamedTypeSymbol methodGroupOrLambdaDelegateType = GetMethodGroupOrLambdaDelegateType(uniqueSignatureFromMethodGroup.RefKind, uniqueSignatureFromMethodGroup.ReturnsVoid ? default(TypeWithAnnotations) : uniqueSignatureFromMethodGroup.ReturnTypeWithAnnotations, uniqueSignatureFromMethodGroup.ParameterRefKinds, uniqueSignatureFromMethodGroup.ParameterTypesWithAnnotations, ref useSiteInfo);
                if ((object)methodGroupOrLambdaDelegateType != null)
                {
                    return methodGroupOrLambdaDelegateType;
                }
            }
            return null;
        }

        private MethodSymbol? GetUniqueSignatureFromMethodGroup(BoundMethodGroup node)
        {
            MethodSymbol method2 = null;
            ImmutableArray<MethodSymbol>.Enumerator enumerator = node.Methods.GetEnumerator();
            while (enumerator.MoveNext())
            {
                MethodSymbol current = enumerator.Current;
                BoundExpression receiverOpt = node.ReceiverOpt;
                if (!(receiverOpt is BoundTypeExpression))
                {
                    if ((!(receiverOpt is BoundThisReference) || !receiverOpt.WasCompilerGenerated) && current.IsStatic)
                    {
                        continue;
                    }
                }
                else if (!current.IsStatic)
                {
                    continue;
                }
                if (!isCandidateUnique(ref method2, current))
                {
                    return null;
                }
            }
            if (node.SearchExtensionMethods)
            {
                BoundExpression receiverOpt2 = node.ReceiverOpt;
                ExtensionMethodScopeEnumerator enumerator2 = new ExtensionMethodScopes(this).GetEnumerator();
                while (enumerator2.MoveNext())
                {
                    ExtensionMethodScope current2 = enumerator2.Current;
                    MethodGroup instance = MethodGroup.GetInstance();
                    PopulateExtensionMethodsFromSingleBinder(current2, instance, node.Syntax, receiverOpt2, node.Name, node.TypeArgumentsOpt, BindingDiagnosticBag.Discarded);
                    ArrayBuilder<MethodSymbol>.Enumerator enumerator3 = instance.Methods.GetEnumerator();
                    while (enumerator3.MoveNext())
                    {
                        MethodSymbol methodSymbol = enumerator3.Current.ReduceExtensionMethod(receiverOpt2.Type, Compilation);
                        if ((object)methodSymbol != null && !isCandidateUnique(ref method2, methodSymbol))
                        {
                            instance.Free();
                            return null;
                        }
                    }
                    instance.Free();
                }
            }
            if ((object)method2 == null)
            {
                return null;
            }
            int num = ((!node.TypeArgumentsOpt.IsDefaultOrEmpty) ? node.TypeArgumentsOpt.Length : 0);
            if (method2.Arity != num)
            {
                return null;
            }
            if (num > 0)
            {
                method2 = method2.ConstructedFrom.Construct(node.TypeArgumentsOpt);
            }
            return method2;
            static bool isCandidateUnique(ref MethodSymbol? method, MethodSymbol candidate)
            {
                if ((object)method == null)
                {
                    method = candidate;
                    return true;
                }
                if (MemberSignatureComparer.MethodGroupSignatureComparer.Equals(method, candidate))
                {
                    return true;
                }
                method = null;
                return false;
            }
        }

        internal NamedTypeSymbol? GetMethodGroupOrLambdaDelegateType(RefKind returnRefKind, TypeWithAnnotations returnTypeOpt, ImmutableArray<RefKind> parameterRefKinds, ImmutableArray<TypeWithAnnotations> parameterTypes, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            if (returnRefKind == RefKind.None && (parameterRefKinds.IsDefault || parameterRefKinds.All((RefKind refKind) => refKind == RefKind.None)))
            {
                WellKnownType wellKnownType = (returnTypeOpt.HasType ? WellKnownTypes.GetWellKnownFunctionDelegate(parameterTypes.Length) : WellKnownTypes.GetWellKnownActionDelegate(parameterTypes.Length));
                if (wellKnownType != 0)
                {
                    NamedTypeSymbol wellKnownType2 = Compilation.GetWellKnownType(wellKnownType);
                    wellKnownType2.AddUseSiteInfo(ref useSiteInfo);
                    if (returnTypeOpt.HasType)
                    {
                        parameterTypes = parameterTypes.Add(returnTypeOpt);
                    }
                    if (parameterTypes.Length == 0)
                    {
                        return wellKnownType2;
                    }
                    if (checkConstraints(Compilation, Conversions, wellKnownType2, parameterTypes))
                    {
                        return wellKnownType2.Construct(parameterTypes);
                    }
                }
            }
            return null;
            static bool checkConstraints(CSharpCompilation compilation, ConversionsBase conversions, NamedTypeSymbol delegateType, ImmutableArray<TypeWithAnnotations> typeArguments)
            {
                ArrayBuilder<TypeParameterDiagnosticInfo> instance = ArrayBuilder<TypeParameterDiagnosticInfo>.GetInstance();
                ImmutableArray<TypeParameterSymbol> typeParameters = delegateType.TypeParameters;
                TypeMap substitution = new TypeMap(typeParameters, typeArguments);
                ArrayBuilder<TypeParameterDiagnosticInfo> useSiteDiagnosticsBuilder = null;
                ConstraintsHelper.CheckConstraintsArgs args = new ConstraintsHelper.CheckConstraintsArgs(compilation, conversions, includeNullability: false, NoLocation.Singleton, null, CompoundUseSiteInfo<AssemblySymbol>.Discarded);
                bool result = delegateType.CheckConstraints(in args, substitution, typeParameters, typeArguments, instance, null, ref useSiteDiagnosticsBuilder);
                instance.Free();
                return result;
            }
        }

        internal static bool ReportDelegateInvokeUseSiteDiagnostic(BindingDiagnosticBag diagnostics, TypeSymbol possibleDelegateType, Location location = null, SyntaxNode node = null)
        {
            if (!possibleDelegateType.IsDelegateType())
            {
                return false;
            }
            MethodSymbol methodSymbol = possibleDelegateType.DelegateInvokeMethod();
            if ((object)methodSymbol == null)
            {
                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_InvalidDelegateType, possibleDelegateType), location ?? node.Location);
                return true;
            }
            UseSiteInfo<AssemblySymbol> useSiteInfo = methodSymbol.GetUseSiteInfo();
            diagnostics.AddDependencies(useSiteInfo);
            DiagnosticInfo diagnosticInfo = useSiteInfo.DiagnosticInfo;
            if (diagnosticInfo == null)
            {
                return false;
            }
            if (location == null)
            {
                location = node.Location;
            }
            if (diagnosticInfo.Code == 7024)
            {
                diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_InvalidDelegateType, possibleDelegateType), location));
                return true;
            }
            return Symbol.ReportUseSiteDiagnostic(diagnosticInfo, diagnostics, location);
        }

        private BoundConditionalAccess BindConditionalAccessExpression(ConditionalAccessExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            BoundExpression boundExpression = BindConditionalAccessReceiver(node, diagnostics);
            BoundExpression boundExpression2 = new BinderWithConditionalReceiver(this, boundExpression).BindValue(node.WhenNotNull, diagnostics, BindValueKind.RValue);
            if (boundExpression.HasAnyErrors || boundExpression2.HasAnyErrors)
            {
                return new BoundConditionalAccess(node, boundExpression, boundExpression2, CreateErrorType(), hasErrors: true);
            }
            _ = boundExpression.Type;
            if (boundExpression2.Kind == BoundKind.MethodGroup)
            {
                return GenerateBadConditionalAccessNodeError(node, boundExpression, boundExpression2, diagnostics);
            }
            TypeSymbol typeSymbol = boundExpression2.Type;
            if ((object)typeSymbol == null)
            {
                return GenerateBadConditionalAccessNodeError(node, boundExpression, boundExpression2, diagnostics);
            }
            if ((!typeSymbol.IsReferenceType && !typeSymbol.IsValueType) || typeSymbol.IsPointerOrFunctionPointer() || typeSymbol.IsRestrictedType())
            {
                bool flag = true;
                CSharpSyntaxNode parent = node.Parent;
                if (parent != null)
                {
                    switch (parent.Kind())
                    {
                        case SyntaxKind.ExpressionStatement:
                            flag = ((ExpressionStatementSyntax)parent).Expression != node;
                            break;
                        case SyntaxKind.SimpleLambdaExpression:
                            flag = ((SimpleLambdaExpressionSyntax)parent).Body != node || ContainingMethodOrLambdaRequiresValue();
                            break;
                        case SyntaxKind.ParenthesizedLambdaExpression:
                            flag = ((ParenthesizedLambdaExpressionSyntax)parent).Body != node || ContainingMethodOrLambdaRequiresValue();
                            break;
                        case SyntaxKind.ArrowExpressionClause:
                            flag = ((ArrowExpressionClauseSyntax)parent).Expression != node || ContainingMethodOrLambdaRequiresValue();
                            break;
                        case SyntaxKind.ForStatement:
                            {
                                ForStatementSyntax forStatementSyntax = (ForStatementSyntax)parent;
                                flag = !forStatementSyntax.Incrementors.Contains(node) && !forStatementSyntax.Initializers.Contains(node);
                                break;
                            }
                    }
                }
                if (flag)
                {
                    return GenerateBadConditionalAccessNodeError(node, boundExpression, boundExpression2, diagnostics);
                }
                typeSymbol = GetSpecialType(SpecialType.System_Void, diagnostics, node);
            }
            if (typeSymbol.IsValueType && !typeSymbol.IsNullableType() && !typeSymbol.IsVoidType())
            {
                typeSymbol = GetSpecialType(SpecialType.System_Nullable_T, diagnostics, node).Construct(typeSymbol);
            }
            return new BoundConditionalAccess(node, boundExpression, boundExpression2, typeSymbol);
        }

        private bool ContainingMethodOrLambdaRequiresValue()
        {
            if (ContainingMemberOrLambda is MethodSymbol methodSymbol)
            {
                if (!methodSymbol.ReturnsVoid)
                {
                    return !methodSymbol.IsAsyncReturningTask(Compilation);
                }
                return false;
            }
            return true;
        }

        private BoundConditionalAccess GenerateBadConditionalAccessNodeError(ConditionalAccessExpressionSyntax node, BoundExpression receiver, BoundExpression access, BindingDiagnosticBag diagnostics)
        {
            SyntaxToken operatorToken = node.OperatorToken;
            DiagnosticInfo info = new CSDiagnosticInfo(ErrorCode.ERR_BadUnaryOp, SyntaxFacts.GetText(operatorToken.Kind()), access.Display);
            diagnostics.Add(new CSDiagnostic(info, operatorToken.GetLocation()));
            receiver = BadExpression(receiver.Syntax, receiver);
            return new BoundConditionalAccess(node, receiver, access, CreateErrorType(), hasErrors: true);
        }

        private BoundExpression BindMemberBindingExpression(MemberBindingExpressionSyntax node, bool invoked, bool indexed, BindingDiagnosticBag diagnostics)
        {
            BoundExpression receiverForConditionalBinding = GetReceiverForConditionalBinding(node, diagnostics);
            return BindMemberAccessWithBoundLeft(node, receiverForConditionalBinding, node.Name, node.OperatorToken, invoked, indexed, diagnostics);
        }

        private BoundExpression BindElementBindingExpression(ElementBindingExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            BoundExpression receiverForConditionalBinding = GetReceiverForConditionalBinding(node, diagnostics);
            return BindElementAccess(node, receiverForConditionalBinding, node.ArgumentList, diagnostics);
        }

        private static CSharpSyntaxNode GetConditionalReceiverSyntax(ConditionalAccessExpressionSyntax node)
        {
            ExpressionSyntax expression = node.Expression;
            while (expression.IsKind(SyntaxKind.ParenthesizedExpression))
            {
                expression = ((ParenthesizedExpressionSyntax)expression).Expression;
            }
            return expression;
        }

        private BoundExpression GetReceiverForConditionalBinding(ExpressionSyntax binding, BindingDiagnosticBag diagnostics)
        {
            ConditionalAccessExpressionSyntax node = SyntaxFactory.FindConditionalAccessNodeForBinding(binding);
            BoundExpression boundExpression = ConditionalReceiverExpression;
            if (boundExpression?.Syntax != GetConditionalReceiverSyntax(node))
            {
                boundExpression = BindConditionalAccessReceiver(node, diagnostics);
            }
            TypeSymbol typeSymbol = boundExpression.Type;
            if ((object)typeSymbol != null && typeSymbol.IsNullableType())
            {
                typeSymbol = typeSymbol.GetNullableUnderlyingType();
            }
            return new BoundConditionalReceiver(boundExpression.Syntax, 0, typeSymbol ?? CreateErrorType(), boundExpression.HasErrors)
            {
                WasCompilerGenerated = true
            };
        }

        private BoundExpression BindConditionalAccessReceiver(ConditionalAccessExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            ExpressionSyntax expression = node.Expression;
            BoundExpression expr = BindRValueWithoutTargetType(expression, diagnostics);
            expr = MakeMemberAccessValue(expr, diagnostics);
            if (expr.HasAnyErrors)
            {
                return expr;
            }
            SyntaxToken operatorToken = node.OperatorToken;
            if (expr.Kind == BoundKind.UnboundLambda)
            {
                MessageID messageID = ((UnboundLambda)expr).MessageID;
                DiagnosticInfo info = new CSDiagnosticInfo(ErrorCode.ERR_BadUnaryOp, SyntaxFacts.GetText(operatorToken.Kind()), messageID.Localize());
                diagnostics.Add(new CSDiagnostic(info, node.Location));
                return BadExpression(expression, expr);
            }
            TypeSymbol type = expr.Type;
            if ((object)type == null)
            {
                Error(diagnostics, ErrorCode.ERR_BadUnaryOp, operatorToken.GetLocation(), operatorToken.Text, expr.Display);
                return BadExpression(expression, expr);
            }
            if (type.IsVoidType())
            {
                Error(diagnostics, ErrorCode.ERR_BadUnaryOp, operatorToken.GetLocation(), operatorToken.Text, type);
                return BadExpression(expression, expr);
            }
            if (type.IsValueType && !type.IsNullableType())
            {
                Error(diagnostics, ErrorCode.ERR_BadUnaryOp, operatorToken.GetLocation(), operatorToken.Text, type);
                return BadExpression(expression, expr);
            }
            return expr;
        }

        internal Binder WithFlags(BinderFlags flags)
        {
            if (Flags != flags)
            {
                return new Binder(this, flags);
            }
            return this;
        }

        internal Binder WithAdditionalFlags(BinderFlags flags)
        {
            if (!Flags.Includes(flags))
            {
                return new Binder(this, Flags | flags);
            }
            return this;
        }

        internal Binder WithContainingMemberOrLambda(Symbol containing)
        {
            return new BinderWithContainingMemberOrLambda(this, containing);
        }

        internal Binder WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags flags, Symbol containing)
        {
            return new BinderWithContainingMemberOrLambda(this, Flags | flags, containing);
        }

        internal Binder WithUnsafeRegionIfNecessary(SyntaxTokenList modifiers)
        {
            if (!Flags.Includes(BinderFlags.UnsafeRegion) && modifiers.Any(SyntaxKind.UnsafeKeyword))
            {
                return new Binder(this, Flags | BinderFlags.UnsafeRegion);
            }
            return this;
        }

        internal Binder WithCheckedOrUncheckedRegion(bool @checked)
        {
            BinderFlags binderFlags = (@checked ? BinderFlags.CheckedRegion : BinderFlags.UncheckedRegion);
            BinderFlags binderFlags2 = (@checked ? BinderFlags.UncheckedRegion : BinderFlags.CheckedRegion);
            if (!Flags.Includes(binderFlags))
            {
                return new Binder(this, (Flags & ~binderFlags2) | binderFlags);
            }
            return this;
        }

        internal static void BindFieldInitializers(CSharpCompilation compilation, SynthesizedInteractiveInitializerMethod? scriptInitializerOpt, ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> fieldInitializers, BindingDiagnosticBag diagnostics, ref ProcessedFieldInitializers processedInitializers)
        {
            BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(withDiagnostics: true, diagnostics.AccumulatesDependencies);
            processedInitializers.BoundInitializers = BindFieldInitializers(compilation, scriptInitializerOpt, fieldInitializers, instance, out var firstImportChain);
            processedInitializers.HasErrors = instance.HasAnyErrors();
            processedInitializers.FirstImportChain = firstImportChain;
            diagnostics.AddRange(instance);
            instance.Free();
        }

        internal static ImmutableArray<BoundInitializer> BindFieldInitializers(CSharpCompilation compilation, SynthesizedInteractiveInitializerMethod? scriptInitializerOpt, ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> initializers, BindingDiagnosticBag diagnostics, out ImportChain? firstImportChain)
        {
            if (initializers.IsEmpty)
            {
                firstImportChain = null;
                return ImmutableArray<BoundInitializer>.Empty;
            }
            ArrayBuilder<BoundInitializer> instance = ArrayBuilder<BoundInitializer>.GetInstance();
            if ((object)scriptInitializerOpt == null)
            {
                BindRegularCSharpFieldInitializers(compilation, initializers, instance, diagnostics, out firstImportChain);
            }
            else
            {
                BindScriptFieldInitializers(compilation, scriptInitializerOpt, initializers, instance, diagnostics, out firstImportChain);
            }
            return instance.ToImmutableAndFree();
        }

        internal static void BindRegularCSharpFieldInitializers(CSharpCompilation compilation, ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> initializers, ArrayBuilder<BoundInitializer> boundInitializers, BindingDiagnosticBag diagnostics, out ImportChain? firstDebugImports)
        {
            firstDebugImports = null;
            ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Enumerator enumerator = initializers.GetEnumerator();
            while (enumerator.MoveNext())
            {
                ImmutableArray<FieldOrPropertyInitializer> current = enumerator.Current;
                BinderFactory binderFactory = null;
                ImmutableArray<FieldOrPropertyInitializer>.Enumerator enumerator2 = current.GetEnumerator();
                while (enumerator2.MoveNext())
                {
                    FieldOrPropertyInitializer current2 = enumerator2.Current;
                    FieldSymbol fieldOpt = current2.FieldOpt;
                    if (fieldOpt.IsMetadataConstant)
                    {
                        continue;
                    }
                    SyntaxReference syntax = current2.Syntax;
                    SyntaxNode syntax2 = syntax.GetSyntax();
                    if (!(syntax2 is EqualsValueClauseSyntax equalsValueClauseSyntax))
                    {
                        if (!(syntax2 is ParameterSyntax parameterSyntax))
                        {
                            throw ExceptionUtilities.Unreachable;
                        }
                        if (firstDebugImports == null)
                        {
                            if (binderFactory == null)
                            {
                                binderFactory = compilation.GetBinderFactory(syntax.SyntaxTree);
                            }
                            firstDebugImports = binderFactory.GetBinder(parameterSyntax).ImportChain;
                        }
                        boundInitializers.Add(new BoundFieldEqualsValue(parameterSyntax, fieldOpt, ImmutableArray<LocalSymbol>.Empty, new BoundParameter(parameterSyntax, ((SynthesizedRecordPropertySymbol)fieldOpt.AssociatedSymbol).BackingParameter).MakeCompilerGenerated()));
                    }
                    else
                    {
                        if (binderFactory == null)
                        {
                            binderFactory = compilation.GetBinderFactory(syntax.SyntaxTree);
                        }
                        Binder binder = binderFactory.GetBinder(equalsValueClauseSyntax);
                        if (firstDebugImports == null)
                        {
                            firstDebugImports = binder.ImportChain;
                        }
                        binder = binder.GetFieldInitializerBinder(fieldOpt);
                        BoundFieldEqualsValue item = BindFieldInitializer(binder, fieldOpt, equalsValueClauseSyntax, diagnostics);
                        boundInitializers.Add(item);
                    }
                }
            }
        }

        internal Binder GetFieldInitializerBinder(FieldSymbol fieldSymbol, bool suppressBinderFlagsFieldInitializer = false)
        {
            Binder binder = this;
            if (!fieldSymbol.IsStatic)
            {
                SynthesizedRecordConstructor synthesizedRecordConstructor = fieldSymbol.ContainingType.GetMembersUnordered().OfType<SynthesizedRecordConstructor>().SingleOrDefault();
                if ((object)synthesizedRecordConstructor != null)
                {
                    binder = new InMethodBinder(synthesizedRecordConstructor, binder);
                }
            }
            return new LocalScopeBinder(binder).WithAdditionalFlagsAndContainingMemberOrLambda((!suppressBinderFlagsFieldInitializer) ? BinderFlags.FieldInitializer : BinderFlags.None, fieldSymbol);
        }

        private static void BindScriptFieldInitializers(CSharpCompilation compilation, SynthesizedInteractiveInitializerMethod scriptInitializer, ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> initializers, ArrayBuilder<BoundInitializer> boundInitializers, BindingDiagnosticBag diagnostics, out ImportChain? firstDebugImports)
        {
            firstDebugImports = null;
            for (int i = 0; i < initializers.Length; i++)
            {
                ImmutableArray<FieldOrPropertyInitializer> immutableArray = initializers[i];
                BinderFactory binderFactory = null;
                ScriptLocalScopeBinder.Labels labels = null;
                for (int j = 0; j < immutableArray.Length; j++)
                {
                    FieldOrPropertyInitializer fieldOrPropertyInitializer = immutableArray[j];
                    FieldSymbol fieldOpt = fieldOrPropertyInitializer.FieldOpt;
                    if ((object)fieldOpt == null || !fieldOpt.IsConst)
                    {
                        SyntaxReference syntax = fieldOrPropertyInitializer.Syntax;
                        SyntaxTree syntaxTree = syntax.SyntaxTree;
                        CSharpSyntaxNode cSharpSyntaxNode = (CSharpSyntaxNode)syntax.GetSyntax();
                        CompilationUnitSyntax compilationUnitRoot = syntaxTree.GetCompilationUnitRoot();
                        if (binderFactory == null)
                        {
                            binderFactory = compilation.GetBinderFactory(syntaxTree);
                            labels = new ScriptLocalScopeBinder.Labels(scriptInitializer, compilationUnitRoot);
                        }
                        Binder binder = binderFactory.GetBinder(cSharpSyntaxNode);
                        if (firstDebugImports == null)
                        {
                            firstDebugImports = binder.ImportChain;
                        }
                        Binder binder2 = new ExecutableCodeBinder(compilationUnitRoot, scriptInitializer, new ScriptLocalScopeBinder(labels, binder));
                        BoundInitializer item = (((object)fieldOpt == null) ? BindGlobalStatement(binder2, scriptInitializer, (StatementSyntax)cSharpSyntaxNode, diagnostics, i == initializers.Length - 1 && j == immutableArray.Length - 1) : BindFieldInitializer(binder2.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.FieldInitializer, fieldOpt), fieldOpt, (EqualsValueClauseSyntax)cSharpSyntaxNode, diagnostics));
                        boundInitializers.Add(item);
                    }
                }
            }
        }

        private static BoundInitializer BindGlobalStatement(Binder binder, SynthesizedInteractiveInitializerMethod scriptInitializer, StatementSyntax statementNode, BindingDiagnosticBag diagnostics, bool isLast)
        {
            BoundStatement boundStatement = binder.BindStatement(statementNode, diagnostics);
            if (isLast && !boundStatement.HasAnyErrors)
            {
                if (binder.Compilation.IsSubmission)
                {
                    BoundExpression trailingScriptExpression = InitializerRewriter.GetTrailingScriptExpression(boundStatement);
                    if (trailingScriptExpression != null && ((object)trailingScriptExpression.Type == null || !trailingScriptExpression.Type.IsVoidType()))
                    {
                        TypeSymbol resultType = scriptInitializer.ResultType;
                        trailingScriptExpression = binder.GenerateConversionForAssignment(resultType, trailingScriptExpression, diagnostics);
                        boundStatement = new BoundExpressionStatement(boundStatement.Syntax, trailingScriptExpression, trailingScriptExpression.HasErrors);
                    }
                }
                if (boundStatement.Kind == BoundKind.LabeledStatement)
                {
                    BoundStatement body = ((BoundLabeledStatement)boundStatement).Body;
                    while (body.Kind == BoundKind.LabeledStatement)
                    {
                        body = ((BoundLabeledStatement)body).Body;
                    }
                    if (InitializerRewriter.GetTrailingScriptExpression(body) != null)
                    {
                        Error(diagnostics, ErrorCode.ERR_SemicolonExpected, ((ExpressionStatementSyntax)body.Syntax).SemicolonToken);
                    }
                }
            }
            return new BoundGlobalStatementInitializer(statementNode, boundStatement);
        }

        private static BoundFieldEqualsValue BindFieldInitializer(Binder binder, FieldSymbol fieldSymbol, EqualsValueClauseSyntax equalsValueClauseNode, BindingDiagnosticBag diagnostics)
        {
            ConsList<FieldSymbol> fieldsBeingBound = binder.FieldsBeingBound;
            BindingDiagnosticBag diagnostics2 = ((!(fieldSymbol is SourceMemberFieldSymbolFromDeclarator sourceMemberFieldSymbolFromDeclarator) || !sourceMemberFieldSymbolFromDeclarator.FieldTypeInferred(fieldsBeingBound)) ? diagnostics : BindingDiagnosticBag.Discarded);
            binder = new ExecutableCodeBinder(equalsValueClauseNode, fieldSymbol, new LocalScopeBinder(binder));
            return binder.BindFieldInitializer(fieldSymbol, equalsValueClauseNode, diagnostics2);
        }

        private BoundExpression BindInterpolatedString(InterpolatedStringExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
            NamedTypeSymbol specialType = GetSpecialType(SpecialType.System_String, diagnostics, node);
            ConstantValue constantValue = null;
            bool flag = true;
            if (node.Contents.Count == 0)
            {
                constantValue = ConstantValue.Create(string.Empty);
            }
            else
            {
                NamedTypeSymbol specialType2 = GetSpecialType(SpecialType.System_Object, diagnostics, node);
                NamedTypeSymbol specialType3 = GetSpecialType(SpecialType.System_Int32, diagnostics, node);
                SyntaxList<InterpolatedStringContentSyntax>.Enumerator enumerator = node.Contents.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    InterpolatedStringContentSyntax current = enumerator.Current;
                    switch (current.Kind())
                    {
                        case SyntaxKind.Interpolation:
                            {
                                InterpolationSyntax interpolationSyntax = (InterpolationSyntax)current;
                                BoundExpression boundExpression = BindValue(interpolationSyntax.Expression, diagnostics, BindValueKind.RValue);
                                if ((object)boundExpression.Type == null)
                                {
                                    boundExpression = GenerateConversionForAssignment(specialType2, boundExpression, diagnostics);
                                }
                                else
                                {
                                    boundExpression = BindToNaturalType(boundExpression, diagnostics);
                                    GenerateConversionForAssignment(specialType2, boundExpression, diagnostics);
                                }
                                BoundExpression boundExpression2 = null;
                                BoundLiteral format = null;
                                if (interpolationSyntax.AlignmentClause != null)
                                {
                                    boundExpression2 = GenerateConversionForAssignment(specialType3, BindValue(interpolationSyntax.AlignmentClause!.Value, diagnostics, BindValueKind.RValue), diagnostics);
                                    ConstantValue constantValue3 = boundExpression2.ConstantValue;
                                    if (constantValue3 != null && !constantValue3.IsBad)
                                    {
                                        int int32Value = constantValue3.Int32Value;
                                        int32Value = ((int32Value > 0) ? (-int32Value) : int32Value);
                                        if (int32Value < -32767)
                                        {
                                            diagnostics.Add(ErrorCode.WRN_AlignmentMagnitude, boundExpression2.Syntax.Location, constantValue3.Int32Value, 32767);
                                        }
                                    }
                                    else if (!boundExpression2.HasErrors)
                                    {
                                        diagnostics.Add(ErrorCode.ERR_ConstantExpected, interpolationSyntax.AlignmentClause!.Value.Location);
                                    }
                                }
                                if (interpolationSyntax.FormatClause != null)
                                {
                                    string valueText2 = interpolationSyntax.FormatClause!.FormatStringToken.ValueText;
                                    bool hasErrors = false;
                                    char ch;
                                    if (valueText2.Length == 0)
                                    {
                                        diagnostics.Add(ErrorCode.ERR_EmptyFormatSpecifier, interpolationSyntax.FormatClause!.Location);
                                        hasErrors = true;
                                    }
                                    else if (SyntaxFacts.IsWhitespace(ch = valueText2[valueText2.Length - 1]) || SyntaxFacts.IsNewLine(ch))
                                    {
                                        diagnostics.Add(ErrorCode.ERR_TrailingWhitespaceInFormatSpecifier, interpolationSyntax.FormatClause!.Location);
                                        hasErrors = true;
                                    }
                                    format = new BoundLiteral(interpolationSyntax.FormatClause, ConstantValue.Create(valueText2), specialType, hasErrors);
                                }
                                instance.Add(new BoundStringInsert(interpolationSyntax, boundExpression, boundExpression2, format, null));
                                if (flag && !(boundExpression.ConstantValue == null) && interpolationSyntax != null && interpolationSyntax.FormatClause == null && interpolationSyntax.AlignmentClause == null)
                                {
                                    ConstantValue constantValue4 = boundExpression.ConstantValue;
                                    if ((object)constantValue4 != null && constantValue4.IsString && !constantValue4.IsBad)
                                    {
                                        constantValue = (((object)constantValue == null) ? boundExpression.ConstantValue : FoldStringConcatenation(BinaryOperatorKind.StringConcatenation, constantValue, boundExpression.ConstantValue));
                                        break;
                                    }
                                }
                                flag = false;
                                break;
                            }
                        case SyntaxKind.InterpolatedStringText:
                            {
                                string valueText = ((InterpolatedStringTextSyntax)current).TextToken.ValueText;
                                instance.Add(new BoundLiteral(current, ConstantValue.Create(valueText, SpecialType.System_String), specialType));
                                if (flag)
                                {
                                    ConstantValue constantValue2 = ConstantValue.Create(ConstantValueUtils.UnescapeInterpolatedStringLiteral(valueText), SpecialType.System_String);
                                    constantValue = (((object)constantValue == null) ? constantValue2 : FoldStringConcatenation(BinaryOperatorKind.StringConcatenation, constantValue, constantValue2));
                                }
                                break;
                            }
                        default:
                            throw ExceptionUtilities.UnexpectedValue(current.Kind());
                    }
                }
                if (!flag)
                {
                    constantValue = null;
                }
            }
            return new BoundUnconvertedInterpolatedString(node, instance.ToImmutableAndFree(), constantValue, specialType);
        }

        private BoundExpression BindMethodGroup(ExpressionSyntax node, bool invoked, bool indexed, BindingDiagnosticBag diagnostics)
        {
            switch (node.Kind())
            {
                case SyntaxKind.IdentifierName:
                case SyntaxKind.GenericName:
                    return BindIdentifier((SimpleNameSyntax)node, invoked, indexed, diagnostics);
                case SyntaxKind.SimpleMemberAccessExpression:
                case SyntaxKind.PointerMemberAccessExpression:
                    return BindMemberAccess((MemberAccessExpressionSyntax)node, invoked, indexed, diagnostics);
                case SyntaxKind.ParenthesizedExpression:
                    return BindMethodGroup(((ParenthesizedExpressionSyntax)node).Expression, invoked: false, indexed: false, diagnostics);
                default:
                    return BindExpression(node, diagnostics, invoked, indexed);
            }
        }

        private static ImmutableArray<MethodSymbol> GetOriginalMethods(OverloadResolutionResult<MethodSymbol> overloadResolutionResult)
        {
            if (overloadResolutionResult == null)
            {
                return ImmutableArray<MethodSymbol>.Empty;
            }
            ArrayBuilder<MethodSymbol> instance = ArrayBuilder<MethodSymbol>.GetInstance();
            ImmutableArray<MemberResolutionResult<MethodSymbol>>.Enumerator enumerator = overloadResolutionResult.Results.GetEnumerator();
            while (enumerator.MoveNext())
            {
                instance.Add(enumerator.Current.Member);
            }
            return instance.ToImmutableAndFree();
        }

        internal BoundExpression MakeInvocationExpression(SyntaxNode node, BoundExpression receiver, string methodName, ImmutableArray<BoundExpression> args, BindingDiagnosticBag diagnostics, SeparatedSyntaxList<TypeSyntax> typeArgsSyntax = default(SeparatedSyntaxList<TypeSyntax>), ImmutableArray<TypeWithAnnotations> typeArgs = default(ImmutableArray<TypeWithAnnotations>), CSharpSyntaxNode? queryClause = null, bool allowFieldsAndProperties = false, bool allowUnexpandedForm = true)
        {
            receiver = BindToNaturalType(receiver, diagnostics);
            BoundExpression boundExpression = BindInstanceMemberAccess(node, node, receiver, methodName, typeArgs.NullToEmpty().Length, typeArgsSyntax, typeArgs, invoked: true, indexed: false, diagnostics);
            if (!allowFieldsAndProperties && (boundExpression.Kind == BoundKind.FieldAccess || boundExpression.Kind == BoundKind.PropertyAccess))
            {
                MessageID id;
                Symbol item;
                if (boundExpression.Kind == BoundKind.FieldAccess)
                {
                    id = MessageID.IDS_SK_FIELD;
                    item = ((BoundFieldAccess)boundExpression).FieldSymbol;
                }
                else
                {
                    id = MessageID.IDS_SK_PROPERTY;
                    item = ((BoundPropertyAccess)boundExpression).PropertySymbol;
                }
                diagnostics.Add(ErrorCode.ERR_BadSKknown, node.Location, methodName, id.Localize(), MessageID.IDS_SK_METHOD.Localize());
                return BadExpression(node, LookupResultKind.Empty, ImmutableArray.Create(item), args.Add(receiver));
            }
            boundExpression = CheckValue(boundExpression, BindValueKind.RValueOrMethodGroup, diagnostics);
            boundExpression.WasCompilerGenerated = true;
            AnalyzedArguments instance = AnalyzedArguments.GetInstance();
            instance.Arguments.AddRange(args);
            BoundExpression boundExpression2 = BindInvocationExpression(node, node, methodName, boundExpression, instance, diagnostics, queryClause, allowUnexpandedForm);
            if (queryClause != null && boundExpression2.Kind == BoundKind.DynamicInvocation)
            {
                boundExpression2 = CreateBadCall(node, boundExpression, LookupResultKind.Viable, instance);
            }
            boundExpression2.WasCompilerGenerated = true;
            instance.Free();
            return boundExpression2;
        }

        private BoundExpression BindInvocationExpression(InvocationExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            if (TryBindNameofOperator(node, diagnostics, out var result))
            {
                return result;
            }
            bool num = node.Expression.Kind() == SyntaxKind.ArgListExpression;
            AnalyzedArguments instance = AnalyzedArguments.GetInstance();
            if (num)
            {
                BindArgumentsAndNames(node.ArgumentList, diagnostics, instance);
                result = BindArgListOperator(node, diagnostics, instance);
            }
            else
            {
                BoundExpression expr = BindMethodGroup(node.Expression, invoked: true, indexed: false, diagnostics);
                expr = CheckValue(expr, BindValueKind.RValueOrMethodGroup, diagnostics);
                string methodName = ((expr.Kind == BoundKind.MethodGroup) ? GetName(node.Expression) : null);
                BindArgumentsAndNames(node.ArgumentList, diagnostics, instance, allowArglist: true);
                result = BindInvocationExpression(node, node.Expression, methodName, expr, instance, diagnostics);
            }
            instance.Free();
            return result;
        }

        private BoundExpression BindArgListOperator(InvocationExpressionSyntax node, BindingDiagnosticBag diagnostics, AnalyzedArguments analyzedArguments)
        {
            bool hasErrors = analyzedArguments.HasErrors;
            TypeSymbol specialType = GetSpecialType(SpecialType.System_Object, diagnostics, node);
            for (int i = 0; i < analyzedArguments.Arguments.Count; i++)
            {
                BoundExpression boundExpression = analyzedArguments.Arguments[i];
                if (boundExpression.Kind == BoundKind.OutVariablePendingInference)
                {
                    analyzedArguments.Arguments[i] = ((OutVariablePendingInference)boundExpression).FailInference(this, diagnostics);
                }
                else if ((object)boundExpression.Type == null && !boundExpression.HasAnyErrors)
                {
                    analyzedArguments.Arguments[i] = GenerateConversionForAssignment(specialType, boundExpression, diagnostics);
                }
                else if (boundExpression.Type.IsVoidType())
                {
                    Error(diagnostics, ErrorCode.ERR_CantUseVoidInArglist, boundExpression.Syntax);
                    hasErrors = true;
                }
                else if (analyzedArguments.RefKind(i) == RefKind.None)
                {
                    analyzedArguments.Arguments[i] = BindToNaturalType(analyzedArguments.Arguments[i], diagnostics);
                }
                RefKind refKind = analyzedArguments.RefKind(i);
                if (refKind > RefKind.Ref)
                {
                    Error(diagnostics, ErrorCode.ERR_CantUseInOrOutInArglist, boundExpression.Syntax);
                    hasErrors = true;
                }
            }
            ImmutableArray<BoundExpression> arguments = analyzedArguments.Arguments.ToImmutable();
            ImmutableArray<RefKind> argumentRefKindsOpt = analyzedArguments.RefKinds.ToImmutableOrNull();
            return new BoundArgListOperator(node, arguments, argumentRefKindsOpt, null, hasErrors);
        }

        private BoundExpression BindInvocationExpression(SyntaxNode node, SyntaxNode expression, string methodName, BoundExpression boundExpression, AnalyzedArguments analyzedArguments, BindingDiagnosticBag diagnostics, CSharpSyntaxNode queryClause = null, bool allowUnexpandedForm = true)
        {
            BoundExpression boundExpression2;
            NamedTypeSymbol delegateType;
            if ((object)boundExpression.Type != null && boundExpression.Type.IsDynamic())
            {
                ReportSuppressionIfNeeded(boundExpression, diagnostics);
                boundExpression2 = BindDynamicInvocation(node, boundExpression, analyzedArguments, ImmutableArray<MethodSymbol>.Empty, diagnostics, queryClause);
            }
            else if (boundExpression.Kind == BoundKind.MethodGroup)
            {
                ReportSuppressionIfNeeded(boundExpression, diagnostics);
                boundExpression2 = BindMethodGroupInvocation(node, expression, methodName, (BoundMethodGroup)boundExpression, analyzedArguments, diagnostics, queryClause, allowUnexpandedForm, out var _);
            }
            else if ((object)(delegateType = GetDelegateType(boundExpression)) != null)
            {
                if (ReportDelegateInvokeUseSiteDiagnostic(diagnostics, delegateType, null, node))
                {
                    return CreateBadCall(node, boundExpression, LookupResultKind.Viable, analyzedArguments);
                }
                boundExpression2 = BindDelegateInvocation(node, expression, methodName, boundExpression, analyzedArguments, diagnostics, queryClause, delegateType);
            }
            else
            {
                TypeSymbol? type = boundExpression.Type;
                if ((object)type != null && type!.Kind == SymbolKind.FunctionPointerType)
                {
                    ReportSuppressionIfNeeded(boundExpression, diagnostics);
                    boundExpression2 = BindFunctionPointerInvocation(node, boundExpression, analyzedArguments, diagnostics);
                }
                else
                {
                    if (!boundExpression.HasAnyErrors)
                    {
                        diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_MethodNameExpected), expression.Location);
                    }
                    boundExpression2 = CreateBadCall(node, boundExpression, LookupResultKind.NotInvocable, analyzedArguments);
                }
            }
            CheckRestrictedTypeReceiver(boundExpression2, Compilation, diagnostics);
            return boundExpression2;
        }

        private BoundExpression BindDynamicInvocation(SyntaxNode node, BoundExpression expression, AnalyzedArguments arguments, ImmutableArray<MethodSymbol> applicableMethods, BindingDiagnosticBag diagnostics, CSharpSyntaxNode queryClause)
        {
            CheckNamedArgumentsForDynamicInvocation(arguments, diagnostics);
            bool flag = false;
            if (expression.Kind == BoundKind.MethodGroup)
            {
                BoundMethodGroup boundMethodGroup = (BoundMethodGroup)expression;
                BoundExpression receiverOpt = boundMethodGroup.ReceiverOpt;
                if (receiverOpt != null)
                {
                    switch (receiverOpt.Kind)
                    {
                        case BoundKind.BaseReference:
                            Error(diagnostics, ErrorCode.ERR_NoDynamicPhantomOnBase, node, boundMethodGroup.Name);
                            flag = true;
                            break;
                        case BoundKind.ThisReference:
                            if ((InConstructorInitializer || InFieldInitializer) && receiverOpt.WasCompilerGenerated)
                            {
                                expression = boundMethodGroup.Update(boundMethodGroup.TypeArgumentsOpt, boundMethodGroup.Name, boundMethodGroup.Methods, boundMethodGroup.LookupSymbolOpt, boundMethodGroup.LookupError, boundMethodGroup.Flags & ~BoundMethodGroupFlags.HasImplicitReceiver, new BoundTypeExpression(node, null, ContainingType).MakeCompilerGenerated(), boundMethodGroup.ResultKind);
                            }
                            break;
                        case BoundKind.TypeOrValueExpression:
                            {
                                BoundTypeOrValueExpression boundTypeOrValueExpression = (BoundTypeOrValueExpression)receiverOpt;
                                bool useType = IsInstance(boundTypeOrValueExpression.Data.ValueSymbol) && !HasThis(isExplicit: false, out bool inStaticContext);
                                BoundExpression receiverOpt2 = ReplaceTypeOrValueReceiver(boundTypeOrValueExpression, useType, diagnostics);
                                expression = boundMethodGroup.Update(boundMethodGroup.TypeArgumentsOpt, boundMethodGroup.Name, boundMethodGroup.Methods, boundMethodGroup.LookupSymbolOpt, boundMethodGroup.LookupError, boundMethodGroup.Flags, receiverOpt2, boundMethodGroup.ResultKind);
                                break;
                            }
                    }
                }
            }
            else
            {
                expression = BindToNaturalType(expression, diagnostics);
            }
            ImmutableArray<BoundExpression> arguments2 = BuildArgumentsForDynamicInvocation(arguments, diagnostics);
            ImmutableArray<RefKind> immutableArray = arguments.RefKinds.ToImmutableOrNull();
            flag &= ReportBadDynamicArguments(node, arguments2, immutableArray, diagnostics, queryClause);
            return new BoundDynamicInvocation(node, arguments.GetNames(), immutableArray, applicableMethods, expression, arguments2, Compilation.DynamicType, flag);
        }

        private void CheckNamedArgumentsForDynamicInvocation(AnalyzedArguments arguments, BindingDiagnosticBag diagnostics)
        {
            if (arguments.Names.Count == 0 || !Compilation.LanguageVersion.AllowNonTrailingNamedArguments())
            {
                return;
            }
            bool flag = false;
            for (int i = 0; i < arguments.Names.Count; i++)
            {
                if (arguments.Names[i] != null)
                {
                    flag = true;
                }
                else if (flag)
                {
                    Error(diagnostics, ErrorCode.ERR_NamedArgumentSpecificationBeforeFixedArgumentInDynamicInvocation, arguments.Arguments[i].Syntax);
                    break;
                }
            }
        }

        private ImmutableArray<BoundExpression> BuildArgumentsForDynamicInvocation(AnalyzedArguments arguments, BindingDiagnosticBag diagnostics)
        {
            ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance(arguments.Arguments.Count);
            instance.AddRange(arguments.Arguments);
            int i = 0;
            for (int count = instance.Count; i < count; i++)
            {
                ArrayBuilder<BoundExpression> arrayBuilder = instance;
                int index = i;
                BoundExpression boundExpression = instance[i];
                BoundExpression boundExpression3 = (arrayBuilder[index] = ((boundExpression is OutVariablePendingInference outVariablePendingInference) ? outVariablePendingInference.FailInference(this, diagnostics) : ((!(boundExpression is BoundDiscardExpression boundDiscardExpression) || boundDiscardExpression.HasExpressionType()) ? BindToNaturalType(boundExpression, diagnostics) : boundDiscardExpression.FailInference(this, diagnostics))));
            }
            return instance.ToImmutableAndFree();
        }

        private static bool ReportBadDynamicArguments(SyntaxNode node, ImmutableArray<BoundExpression> arguments, ImmutableArray<RefKind> refKinds, BindingDiagnosticBag diagnostics, CSharpSyntaxNode queryClause)
        {
            bool result = false;
            bool flag = false;
            if (!refKinds.IsDefault)
            {
                for (int i = 0; i < refKinds.Length; i++)
                {
                    if (refKinds[i] == RefKind.In)
                    {
                        Error(diagnostics, ErrorCode.ERR_InDynamicMethodArg, arguments[i].Syntax);
                        result = true;
                    }
                }
            }
            ImmutableArray<BoundExpression>.Enumerator enumerator = arguments.GetEnumerator();
            while (enumerator.MoveNext())
            {
                BoundExpression current = enumerator.Current;
                if (!IsLegalDynamicOperand(current))
                {
                    if (queryClause != null && !flag)
                    {
                        flag = true;
                        Error(diagnostics, ErrorCode.ERR_BadDynamicQuery, node);
                        result = true;
                    }
                    else if (current.Kind == BoundKind.Lambda || current.Kind == BoundKind.UnboundLambda)
                    {
                        Error(diagnostics, ErrorCode.ERR_BadDynamicMethodArgLambda, current.Syntax);
                        result = true;
                    }
                    else if (current.Kind == BoundKind.MethodGroup)
                    {
                        Error(diagnostics, ErrorCode.ERR_BadDynamicMethodArgMemgrp, current.Syntax);
                        result = true;
                    }
                    else if (current.Kind == BoundKind.ArgListOperator)
                    {
                        Error(diagnostics, ErrorCode.ERR_BadDynamicMethodArg, current.Syntax, "__arglist");
                    }
                    else
                    {
                        Error(diagnostics, ErrorCode.ERR_BadDynamicMethodArg, current.Syntax, current.Type);
                        result = true;
                    }
                }
            }
            return result;
        }

        private BoundExpression BindDelegateInvocation(SyntaxNode node, SyntaxNode expression, string methodName, BoundExpression boundExpression, AnalyzedArguments analyzedArguments, BindingDiagnosticBag diagnostics, CSharpSyntaxNode queryClause, NamedTypeSymbol delegateType)
        {
            MethodGroup instance = MethodGroup.GetInstance();
            instance.PopulateWithSingleMethod(boundExpression, delegateType.DelegateInvokeMethod);
            OverloadResolutionResult<MethodSymbol> instance2 = OverloadResolutionResult<MethodSymbol>.GetInstance();
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            OverloadResolution overloadResolution = OverloadResolution;
            ArrayBuilder<MethodSymbol> methods = instance.Methods;
            ArrayBuilder<TypeWithAnnotations> typeArguments = instance.TypeArguments;
            BoundExpression receiver = instance.Receiver;
            CallingConventionInfo callingConventionInfo = default(CallingConventionInfo);
            overloadResolution.MethodInvocationOverloadResolution(methods, typeArguments, receiver, analyzedArguments, instance2, ref useSiteInfo, isMethodGroupConversion: false, allowRefOmittedArguments: false, inferWithDynamic: false, allowUnexpandedForm: true, RefKind.None, null, isFunctionPointerResolution: false, in callingConventionInfo);
            diagnostics.Add(node, useSiteInfo);
            BoundExpression result = ((!analyzedArguments.HasDynamicArgument || !instance2.HasAnyApplicableMember) ? BindInvocationExpressionContinued(node, expression, methodName, instance2, analyzedArguments, instance, delegateType, diagnostics, queryClause) : BindDynamicInvocation(node, boundExpression, analyzedArguments, instance2.GetAllApplicableMembers(), diagnostics, queryClause));
            instance2.Free();
            instance.Free();
            return result;
        }

        private static bool HasApplicableConditionalMethod(OverloadResolutionResult<MethodSymbol> results)
        {
            ImmutableArray<MemberResolutionResult<MethodSymbol>> results2 = results.Results;
            for (int i = 0; i < results2.Length; i++)
            {
                if (results2[i].IsApplicable && results2[i].Member.IsConditional)
                {
                    return true;
                }
            }
            return false;
        }

        private BoundExpression BindMethodGroupInvocation(SyntaxNode syntax, SyntaxNode expression, string methodName, BoundMethodGroup methodGroup, AnalyzedArguments analyzedArguments, BindingDiagnosticBag diagnostics, CSharpSyntaxNode queryClause, bool allowUnexpandedForm, out bool anyApplicableCandidates)
        {
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            CallingConventionInfo callingConventionInfo = default(CallingConventionInfo);
            MethodGroupResolution resolution = ResolveMethodGroup(methodGroup, expression, methodName, analyzedArguments, isMethodGroupConversion: false, ref useSiteInfo, inferWithDynamic: false, allowUnexpandedForm, RefKind.None, null, isFunctionPointerResolution: false, in callingConventionInfo);
            diagnostics.Add(expression, useSiteInfo);
            anyApplicableCandidates = resolution.ResultKind == LookupResultKind.Viable && resolution.OverloadResolutionResult.HasAnyApplicableMember;
            if (!methodGroup.HasAnyErrors)
            {
                diagnostics.AddRange(resolution.Diagnostics);
            }
            BoundExpression result;
            if (resolution.HasAnyErrors)
            {
                ImmutableArray<MethodSymbol> methods;
                LookupResultKind resultKind;
                ImmutableArray<TypeWithAnnotations> typeArgumentsWithAnnotations;
                if (resolution.OverloadResolutionResult != null)
                {
                    methods = GetOriginalMethods(resolution.OverloadResolutionResult);
                    resultKind = resolution.MethodGroup.ResultKind;
                    typeArgumentsWithAnnotations = resolution.MethodGroup.TypeArguments.ToImmutable();
                }
                else
                {
                    methods = methodGroup.Methods;
                    resultKind = methodGroup.ResultKind;
                    typeArgumentsWithAnnotations = methodGroup.TypeArgumentsOpt;
                }
                result = CreateBadCall(syntax, methodName, methodGroup.ReceiverOpt, methods, resultKind, typeArgumentsWithAnnotations, analyzedArguments, resolution.IsExtensionMethodGroup, isDelegate: false);
            }
            else if (!resolution.IsEmpty)
            {
                if (resolution.ResultKind != LookupResultKind.Viable)
                {
                    if (resolution.MethodGroup != null)
                    {
                        result = BindInvocationExpressionContinued(syntax, expression, methodName, resolution.OverloadResolutionResult, resolution.AnalyzedArguments, resolution.MethodGroup, null, BindingDiagnosticBag.Discarded, queryClause);
                    }
                    result = CreateBadCall(syntax, methodGroup, methodGroup.ResultKind, analyzedArguments);
                }
                else if (resolution.AnalyzedArguments.HasDynamicArgument && resolution.OverloadResolutionResult.HasAnyApplicableMember)
                {
                    if (resolution.IsLocalFunctionInvocation)
                    {
                        result = BindLocalFunctionInvocationWithDynamicArgument(syntax, expression, methodName, methodGroup, diagnostics, queryClause, resolution);
                    }
                    else if (resolution.IsExtensionMethodGroup)
                    {
                        Error(diagnostics, ErrorCode.ERR_BadArgTypeDynamicExtension, syntax, methodGroup.InstanceOpt!.Type, methodGroup.Name);
                        result = CreateBadCall(syntax, methodGroup, methodGroup.ResultKind, analyzedArguments);
                    }
                    else
                    {
                        if (HasApplicableConditionalMethod(resolution.OverloadResolutionResult))
                        {
                            Error(diagnostics, ErrorCode.WRN_DynamicDispatchToConditionalMethod, syntax, methodGroup.Name);
                        }
                        ImmutableArray<MethodSymbol> candidatesPassingFinalValidation = GetCandidatesPassingFinalValidation(syntax, resolution.OverloadResolutionResult, methodGroup.ReceiverOpt, methodGroup.TypeArgumentsOpt, diagnostics);
                        result = ((candidatesPassingFinalValidation.Length <= 0) ? CreateBadCall(syntax, methodGroup, methodGroup.ResultKind, analyzedArguments) : BindDynamicInvocation(syntax, methodGroup, resolution.AnalyzedArguments, candidatesPassingFinalValidation, diagnostics, queryClause));
                    }
                }
                else
                {
                    result = BindInvocationExpressionContinued(syntax, expression, methodName, resolution.OverloadResolutionResult, resolution.AnalyzedArguments, resolution.MethodGroup, null, diagnostics, queryClause);
                }
            }
            else
            {
                result = CreateBadCall(syntax, methodGroup, methodGroup.ResultKind, analyzedArguments);
            }
            resolution.Free();
            return result;
        }

        private BoundExpression BindLocalFunctionInvocationWithDynamicArgument(SyntaxNode syntax, SyntaxNode expression, string methodName, BoundMethodGroup boundMethodGroup, BindingDiagnosticBag diagnostics, CSharpSyntaxNode queryClause, MethodGroupResolution resolution)
        {
            MemberResolutionResult<MethodSymbol> validResult = resolution.OverloadResolutionResult.ValidResult;
            ImmutableArray<BoundExpression> arguments = resolution.AnalyzedArguments.Arguments.ToImmutable();
            ImmutableArray<RefKind> refKinds = resolution.AnalyzedArguments.RefKinds.ToImmutableOrNull();
            ReportBadDynamicArguments(syntax, arguments, refKinds, diagnostics, queryClause);
            MethodSymbol member = validResult.Member;
            MemberAnalysisResult result = validResult.Result;
            if (Microsoft.CodeAnalysis.CSharp.OverloadResolution.IsValidParams(member) && result.Kind == MemberResolutionKind.ApplicableInNormalForm)
            {
                ImmutableArray<ParameterSymbol> parameters = member.Parameters;
                int num = parameters.Length - 1;
                for (int i = 0; i < arguments.Length; i++)
                {
                    if (arguments[i].HasDynamicType() && result.ParameterFromArgument(i) == num)
                    {
                        Error(diagnostics, ErrorCode.ERR_DynamicLocalFunctionParamsParameter, syntax, parameters.Last().Name, member.Name);
                        return BindDynamicInvocation(syntax, boundMethodGroup, resolution.AnalyzedArguments, resolution.OverloadResolutionResult.GetAllApplicableMembers(), diagnostics, queryClause);
                    }
                }
            }
            if (boundMethodGroup.TypeArgumentsOpt.IsDefaultOrEmpty && member.IsGenericMethod)
            {
                Error(diagnostics, ErrorCode.ERR_DynamicLocalFunctionTypeParameter, syntax, member.Name);
                return BindDynamicInvocation(syntax, boundMethodGroup, resolution.AnalyzedArguments, resolution.OverloadResolutionResult.GetAllApplicableMembers(), diagnostics, queryClause);
            }
            return BindInvocationExpressionContinued(syntax, expression, methodName, resolution.OverloadResolutionResult, resolution.AnalyzedArguments, resolution.MethodGroup, null, diagnostics, queryClause);
        }

        private ImmutableArray<TMethodOrPropertySymbol> GetCandidatesPassingFinalValidation<TMethodOrPropertySymbol>(
            SyntaxNode syntax,
            OverloadResolutionResult<TMethodOrPropertySymbol> overloadResolutionResult,
            BoundExpression receiverOpt,
            ImmutableArray<TypeWithAnnotations> typeArgumentsOpt,
            BindingDiagnosticBag diagnostics) where TMethodOrPropertySymbol : Symbol
        {
            Debug.Assert(overloadResolutionResult.HasAnyApplicableMember);

            var finalCandidates = ArrayBuilder<TMethodOrPropertySymbol>.GetInstance();
            BindingDiagnosticBag firstFailed = null;
            var candidateDiagnostics = BindingDiagnosticBag.GetInstance(diagnostics);

            for (int i = 0, n = overloadResolutionResult.ResultsBuilder.Count; i < n; i++)
            {
                var result = overloadResolutionResult.ResultsBuilder[i];
                if (result.Result.IsApplicable)
                {
                    // For F to pass the check, all of the following must hold:
                    //      ...
                    // * If the type parameters of F were substituted in the step above, their constraints are satisfied.
                    // * If F is a static method, the method group must have resulted from a simple-name, a member-access through a type, 
                    //   or a member-access whose receiver can't be classified as a type or value until after overload resolution (see 7.6.4.1). 
                    // * If F is an instance method, the method group must have resulted from a simple-name, a member-access through a variable or value, 
                    //   or a member-access whose receiver can't be classified as a type or value until after overload resolution (see 7.6.4.1).

                    if (!MemberGroupFinalValidationAccessibilityChecks(receiverOpt, result.Member, syntax, candidateDiagnostics, invokedAsExtensionMethod: false) &&
                        (typeArgumentsOpt.IsDefault || ((MethodSymbol)(object)result.Member).CheckConstraints(new ConstraintsHelper.CheckConstraintsArgs(this.Compilation, this.Conversions, includeNullability: false, syntax.Location, candidateDiagnostics))))
                    {
                        finalCandidates.Add(result.Member);
                        continue;
                    }

                    if (firstFailed == null)
                    {
                        firstFailed = candidateDiagnostics;
                        candidateDiagnostics = BindingDiagnosticBag.GetInstance(diagnostics);
                    }
                    else
                    {
                        candidateDiagnostics.Clear();
                    }
                }
            }

            if (firstFailed != null)
            {
                // Report diagnostics of the first candidate that failed the validation
                // unless we have at least one candidate that passes.
                if (finalCandidates.Count == 0)
                {
                    diagnostics.AddRange(firstFailed);
                }

                firstFailed.Free();
            }

            candidateDiagnostics.Free();

            return finalCandidates.ToImmutableAndFree();
        }

        private void CheckRestrictedTypeReceiver(BoundExpression expression, CSharpCompilation compilation, BindingDiagnosticBag diagnostics)
        {
            switch (expression.Kind)
            {
                case BoundKind.Call:
                    {
                        BoundCall boundCall = (BoundCall)expression;
                        if (!boundCall.HasAnyErrors && boundCall.ReceiverOpt != null && (object)boundCall.ReceiverOpt!.Type != null)
                        {
                            if (boundCall.ReceiverOpt!.Type.IsRestrictedType() && !TypeSymbol.Equals(boundCall.Method.ContainingType, boundCall.ReceiverOpt!.Type, TypeCompareKind.ConsiderEverything))
                            {
                                SymbolDistinguisher symbolDistinguisher = new SymbolDistinguisher(compilation, boundCall.ReceiverOpt!.Type, boundCall.Method.ContainingType);
                                Error(diagnostics, ErrorCode.ERR_NoImplicitConv, boundCall.ReceiverOpt!.Syntax, symbolDistinguisher.First, symbolDistinguisher.Second);
                            }
                            else if (boundCall.ReceiverOpt!.Kind == BoundKind.BaseReference && ContainingType.IsRestrictedType())
                            {
                                SymbolDistinguisher symbolDistinguisher2 = new SymbolDistinguisher(compilation, ContainingType, boundCall.Method.ContainingType);
                                Error(diagnostics, ErrorCode.ERR_NoImplicitConv, boundCall.ReceiverOpt!.Syntax, symbolDistinguisher2.First, symbolDistinguisher2.Second);
                            }
                        }
                        break;
                    }
                case BoundKind.DynamicInvocation:
                    {
                        BoundDynamicInvocation boundDynamicInvocation = (BoundDynamicInvocation)expression;
                        if (!boundDynamicInvocation.HasAnyErrors && (object)boundDynamicInvocation.Expression.Type != null && boundDynamicInvocation.Expression.Type.IsRestrictedType())
                        {
                            Error(diagnostics, ErrorCode.ERR_BadDynamicMethodArg, boundDynamicInvocation.Expression.Syntax, boundDynamicInvocation.Expression.Type);
                        }
                        break;
                    }
                default:
                    throw ExceptionUtilities.UnexpectedValue(expression.Kind);
                case BoundKind.FunctionPointerInvocation:
                    break;
            }
        }

        private BoundCall BindInvocationExpressionContinued(SyntaxNode node, SyntaxNode expression, string methodName, OverloadResolutionResult<MethodSymbol> result, AnalyzedArguments analyzedArguments, MethodGroup methodGroup, NamedTypeSymbol delegateTypeOpt, BindingDiagnosticBag diagnostics, CSharpSyntaxNode queryClause = null)
        {
            bool isExtensionMethodGroup = methodGroup.IsExtensionMethodGroup;
            if (!result.Succeeded)
            {
                if (analyzedArguments.HasErrors)
                {
                    ArrayBuilder<BoundExpression>.Enumerator enumerator = analyzedArguments.Arguments.GetEnumerator();
                    while (enumerator.MoveNext())
                    {
                        BoundExpression current = enumerator.Current;
                        if (!(current is UnboundLambda unboundLambda))
                        {
                            if (!(current is BoundUnconvertedObjectCreationExpression) && !(current is BoundTupleLiteral))
                            {
                                if (current is BoundUnconvertedSwitchExpression source)
                                {
                                    TypeSymbol type = current.Type;
                                    if ((object)type != null)
                                    {
                                        ConvertSwitchExpression(source, type, null, diagnostics);
                                    }
                                }
                                else if (current is BoundUnconvertedConditionalOperator source2)
                                {
                                    TypeSymbol type = current.Type;
                                    if ((object)type != null)
                                    {
                                        TypeSymbol destination = type;
                                        ConvertConditionalExpression(source2, destination, null, diagnostics);
                                    }
                                }
                            }
                            else
                            {
                                BindToNaturalType(current, diagnostics);
                            }
                        }
                        else
                        {
                            BoundLambda boundLambda = unboundLambda.BindForErrorRecovery();
                            diagnostics.AddRange(boundLambda.Diagnostics);
                        }
                    }
                }
                else
                {
                    string name = (((object)delegateTypeOpt == null) ? methodName : null);
                    result.ReportDiagnostics(this, GetLocationForOverloadResolutionDiagnostic(node, expression), node, diagnostics, name, methodGroup.Receiver, expression, analyzedArguments, methodGroup.Methods.ToImmutable(), null, delegateTypeOpt, queryClause);
                }
                return CreateBadCall(node, methodGroup.Name, (isExtensionMethodGroup && analyzedArguments.Arguments.Count > 0 && methodGroup.Receiver == analyzedArguments.Arguments[0]) ? null : methodGroup.Receiver, GetOriginalMethods(result), methodGroup.ResultKind, methodGroup.TypeArguments.ToImmutable(), analyzedArguments, isExtensionMethodGroup, (object)delegateTypeOpt != null);
            }
            MemberResolutionResult<MethodSymbol> validResult = result.ValidResult;
            TypeSymbol returnType = validResult.Member.ReturnType;
            CoerceArguments(validResult, analyzedArguments.Arguments, diagnostics);
            MethodSymbol member = validResult.Member;
            bool expanded = validResult.Result.Kind == MemberResolutionKind.ApplicableInExpandedForm;
            ImmutableArray<int> argsToParamsOpt = validResult.Result.ArgsToParamsOpt;
            BindDefaultArguments(node, member.Parameters, analyzedArguments.Arguments, analyzedArguments.RefKinds, ref argsToParamsOpt, out var defaultArguments, expanded, enableCallerInfo: true, diagnostics);
            BoundExpression boundExpression = ReplaceTypeOrValueReceiver(methodGroup.Receiver, !member.RequiresInstanceReceiver && !isExtensionMethodGroup, diagnostics);
            bool flag = MemberGroupFinalValidation(boundExpression, member, expression, diagnostics, isExtensionMethodGroup);
            CheckImplicitThisCopyInReadOnlyMember(boundExpression, member, diagnostics);
            if (isExtensionMethodGroup)
            {
                BoundExpression boundExpression2 = analyzedArguments.Argument(0);
                ParameterSymbol parameterSymbol = member.Parameters.First();
                if (boundExpression != boundExpression2)
                {
                    boundExpression2 = CreateConversion(boundExpression, validResult.Result.ConversionForArg(0), parameterSymbol.Type, diagnostics);
                }
                if (parameterSymbol.RefKind == RefKind.Ref)
                {
                    boundExpression2 = CheckValue(boundExpression2, BindValueKind.RefOrOut, diagnostics);
                    if (analyzedArguments.RefKinds.Count == 0)
                    {
                        analyzedArguments.RefKinds.Count = analyzedArguments.Arguments.Count;
                    }
                    analyzedArguments.RefKinds[0] = RefKind.Ref;
                    CheckFeatureAvailability(boundExpression2.Syntax, MessageID.IDS_FeatureRefExtensionMethods, diagnostics);
                }
                else if (parameterSymbol.RefKind == RefKind.In)
                {
                    CheckFeatureAvailability(boundExpression2.Syntax, MessageID.IDS_FeatureRefExtensionMethods, diagnostics);
                }
                analyzedArguments.Arguments[0] = boundExpression2;
            }
            if (isExtensionMethodGroup || (!member.RequiresInstanceReceiver && boundExpression != null && boundExpression.WasCompilerGenerated))
            {
                boundExpression = null;
            }
            ImmutableArray<string> names = analyzedArguments.GetNames();
            ImmutableArray<RefKind> argumentRefKindsOpt = analyzedArguments.RefKinds.ToImmutableOrNull();
            ImmutableArray<BoundExpression> immutableArray = analyzedArguments.Arguments.ToImmutable();
            if (!flag && member.RequiresInstanceReceiver && boundExpression != null && boundExpression.Kind == BoundKind.ThisReference && boundExpression.WasCompilerGenerated)
            {
                flag = IsRefOrOutThisParameterCaptured(node, diagnostics);
            }
            if (member.HasUnsafeParameter())
            {
                flag = ReportUnsafeIfNotAllowed(node, diagnostics) || flag;
            }
            bool flag2 = boundExpression != null && boundExpression.Kind == BoundKind.BaseReference;
            ReportDiagnosticsIfObsolete(diagnostics, member, node, flag2);
            ReportDiagnosticsIfUnmanagedCallersOnly(diagnostics, member, node.Location, isDelegateConversion: false);
            if (member.IsRuntimeFinalizer())
            {
                ErrorCode code = (flag2 ? ErrorCode.ERR_CallingBaseFinalizeDeprecated : ErrorCode.ERR_CallingFinalizeDeprecated);
                Error(diagnostics, code, node);
                flag = true;
            }
            if (!flag)
            {
                flag = !CheckInvocationArgMixing(node, member, boundExpression, member.Parameters, immutableArray, argsToParamsOpt, LocalScopeDepth, diagnostics);
            }
            bool flag3 = (object)delegateTypeOpt != null;
            if (!flag3 && member.RequiresInstanceReceiver)
            {
                WarnOnAccessOfOffDefault((node.Kind() == SyntaxKind.InvocationExpression) ? ((InvocationExpressionSyntax)node).Expression : node, boundExpression, diagnostics);
            }
            return new BoundCall(node, boundExpression, member, immutableArray, names, argumentRefKindsOpt, flag3, expanded, isExtensionMethodGroup, argsToParamsOpt, defaultArguments, LookupResultKind.Viable, returnType, flag);
        }

        private static SourceLocation GetCallerLocation(SyntaxNode syntax)
        {
            SyntaxToken syntaxToken = ((syntax is InvocationExpressionSyntax invocationExpressionSyntax) ? invocationExpressionSyntax.ArgumentList.OpenParenToken : ((syntax is BaseObjectCreationExpressionSyntax baseObjectCreationExpressionSyntax) ? baseObjectCreationExpressionSyntax.NewKeyword : ((syntax is ConstructorInitializerSyntax constructorInitializerSyntax) ? constructorInitializerSyntax.ArgumentList.OpenParenToken : ((syntax is PrimaryConstructorBaseTypeSyntax primaryConstructorBaseTypeSyntax) ? primaryConstructorBaseTypeSyntax.ArgumentList.OpenParenToken : ((!(syntax is ElementAccessExpressionSyntax elementAccessExpressionSyntax)) ? syntax.GetFirstToken() : elementAccessExpressionSyntax.ArgumentList.OpenBracketToken)))));
            SyntaxToken token = syntaxToken;
            return new SourceLocation(in token);
        }

        private BoundExpression GetDefaultParameterSpecialNoConversion(SyntaxNode syntax, ParameterSymbol parameter, BindingDiagnosticBag diagnostics)
        {
            TypeSymbol type = parameter.Type;
            BoundExpression boundExpression = null;
            if (parameter.IsMarshalAsObject)
            {
                boundExpression = new BoundDefaultExpression(syntax, type)
                {
                    WasCompilerGenerated = true
                };
            }
            else if (parameter.IsIUnknownConstant)
            {
                if (GetWellKnownTypeMember(Compilation, WellKnownMember.System_Runtime_InteropServices_UnknownWrapper__ctor, diagnostics, null, syntax) is MethodSymbol constructor)
                {
                    BoundDefaultExpression boundDefaultExpression = new BoundDefaultExpression(syntax, type)
                    {
                        WasCompilerGenerated = true
                    };
                    boundExpression = new BoundObjectCreationExpression(syntax, constructor, boundDefaultExpression)
                    {
                        WasCompilerGenerated = true
                    };
                }
            }
            else if (parameter.IsIDispatchConstant)
            {
                if (GetWellKnownTypeMember(Compilation, WellKnownMember.System_Runtime_InteropServices_DispatchWrapper__ctor, diagnostics, null, syntax) is MethodSymbol constructor2)
                {
                    BoundDefaultExpression boundDefaultExpression2 = new BoundDefaultExpression(syntax, type)
                    {
                        WasCompilerGenerated = true
                    };
                    boundExpression = new BoundObjectCreationExpression(syntax, constructor2, boundDefaultExpression2)
                    {
                        WasCompilerGenerated = true
                    };
                }
            }
            else if (GetWellKnownTypeMember(Compilation, WellKnownMember.System_Type__Missing, diagnostics, null, syntax) is FieldSymbol fieldSymbol)
            {
                boundExpression = new BoundFieldAccess(syntax, null, fieldSymbol, null)
                {
                    WasCompilerGenerated = true
                };
            }
            return boundExpression ?? BadExpression(syntax).MakeCompilerGenerated();
        }

        internal static ParameterSymbol? GetCorrespondingParameter(int argumentOrdinal, ImmutableArray<ParameterSymbol> parameters, ImmutableArray<int> argsToParamsOpt, bool expanded)
        {
            int length = parameters.Length;
            if (argsToParamsOpt.IsDefault)
            {
                if (argumentOrdinal < length)
                {
                    return parameters[argumentOrdinal];
                }
                if (expanded)
                {
                    return parameters[length - 1];
                }
                return null;
            }
            int num = argsToParamsOpt[argumentOrdinal];
            if (num < length)
            {
                return parameters[num];
            }
            return null;
        }

        internal void BindDefaultArguments(
            SyntaxNode node,
            ImmutableArray<ParameterSymbol> parameters,
            ArrayBuilder<BoundExpression> argumentsBuilder,
            ArrayBuilder<RefKind>? argumentRefKindsBuilder,
            ref ImmutableArray<int> argsToParamsOpt,
            out BitVector defaultArguments,
            bool expanded,
            bool enableCallerInfo,
            BindingDiagnosticBag diagnostics,
            bool assertMissingParametersAreOptional = true)
        {

            var visitedParameters = BitVector.Create(parameters.Length);
            for (var i = 0; i < argumentsBuilder.Count; i++)
            {
                var parameter = GetCorrespondingParameter(i, parameters, argsToParamsOpt, expanded);
                if (parameter is not null)
                {
                    visitedParameters[parameter.Ordinal] = true;
                }
            }

            // only proceed with binding default arguments if we know there is some parameter that has not been matched by an explicit argument
            if (parameters.All(static (param, visitedParameters) => visitedParameters[param.Ordinal], visitedParameters))
            {
                defaultArguments = default;
                return;
            }

            // In a scenario like `string Prop { get; } = M();`, the containing symbol could be the synthesized field.
            // We want to use the associated user-declared symbol instead where possible.
            var containingMember = ContainingMember() switch
            {
                FieldSymbol { AssociatedSymbol: { } symbol } => symbol,
                var c => c
            };

            defaultArguments = BitVector.Create(parameters.Length);
            ArrayBuilder<int>? argsToParamsBuilder = null;
            if (!argsToParamsOpt.IsDefault)
            {
                argsToParamsBuilder = ArrayBuilder<int>.GetInstance(argsToParamsOpt.Length);
                argsToParamsBuilder.AddRange(argsToParamsOpt);
            }

            // Params methods can be invoked in normal form, so the strongest assertion we can make is that, if
            // we're in an expanded context, the last param must be params. The inverse is not necessarily true.

            // Params array is filled in the local rewriter
            var lastIndex = expanded ? ^1 : ^0;

            // FilRip : Replace the range of index to something compatible 4.5.2
            ReadOnlySpan<ParameterSymbol> readOnlySpan2 = parameters.AsSpan();
            ParameterSymbol[] redim = readOnlySpan2.ToArray();
            Array.Resize(ref redim, lastIndex.GetOffset(parameters.Length));
            readOnlySpan2 = redim.AsSpan();
            // FilRip : End replace

            // Go over missing parameters, inserting default values for optional parameters
            foreach (var parameter in readOnlySpan2)
            {
                if (!visitedParameters[parameter.Ordinal])
                {
                    Debug.Assert(parameter.IsOptional || !assertMissingParametersAreOptional);

                    defaultArguments[argumentsBuilder.Count] = true;
                    argumentsBuilder.Add(bindDefaultArgument(node, parameter, containingMember, enableCallerInfo, diagnostics));

                    if (argumentRefKindsBuilder is { Count: > 0 })
                    {
                        argumentRefKindsBuilder.Add(RefKind.None);
                    }

                    argsToParamsBuilder?.Add(parameter.Ordinal);
                }
            }
            Debug.Assert(argumentRefKindsBuilder is null || argumentRefKindsBuilder.Count == 0 || argumentRefKindsBuilder.Count == argumentsBuilder.Count);
            Debug.Assert(argsToParamsBuilder is null || argsToParamsBuilder.Count == argumentsBuilder.Count);

            if (argsToParamsBuilder is object)
            {
                argsToParamsOpt = argsToParamsBuilder.ToImmutableOrNull();
                argsToParamsBuilder.Free();
            }

            BoundExpression bindDefaultArgument(SyntaxNode syntax, ParameterSymbol parameter, Symbol containingMember, bool enableCallerInfo, BindingDiagnosticBag diagnostics)
            {
                TypeSymbol parameterType = parameter.Type;
                if (Flags.Includes(BinderFlags.ParameterDefaultValue))
                {
                    // This is only expected to occur in recursive error scenarios, for example: `object F(object param = F()) { }`
                    // We return a non-error expression here to ensure ERR_DefaultValueMustBeConstant (or another appropriate diagnostics) is produced by the caller.
                    return new BoundDefaultExpression(syntax, parameterType) { WasCompilerGenerated = true };
                }

                var defaultConstantValue = parameter.ExplicitDefaultConstantValue switch
                {
                    // Bad default values are implicitly replaced with default(T) at call sites.
                    { IsBad: true } => ConstantValue.Null,
                    var constantValue => constantValue
                };
                Debug.Assert((object?)defaultConstantValue != ConstantValue.Unset);

                var callerSourceLocation = enableCallerInfo ? GetCallerLocation(syntax) : null;
                BoundExpression defaultValue;
                if (callerSourceLocation is object && parameter.IsCallerLineNumber)
                {
                    int line = callerSourceLocation.SourceTree.GetDisplayLineNumber(callerSourceLocation.SourceSpan);
                    defaultValue = new BoundLiteral(syntax, ConstantValue.Create(line), Compilation.GetSpecialType(SpecialType.System_Int32)) { WasCompilerGenerated = true };
                }
                else if (callerSourceLocation is object && parameter.IsCallerFilePath)
                {
                    string path = callerSourceLocation.SourceTree.GetDisplayPath(callerSourceLocation.SourceSpan, Compilation.Options.SourceReferenceResolver);
                    defaultValue = new BoundLiteral(syntax, ConstantValue.Create(path), Compilation.GetSpecialType(SpecialType.System_String)) { WasCompilerGenerated = true };
                }
                else if (callerSourceLocation is object && parameter.IsCallerMemberName)
                {
                    var memberName = containingMember.GetMemberCallerName();
                    defaultValue = new BoundLiteral(syntax, ConstantValue.Create(memberName), Compilation.GetSpecialType(SpecialType.System_String)) { WasCompilerGenerated = true };
                }
                else if (defaultConstantValue == ConstantValue.NotAvailable)
                {
                    // There is no constant value given for the parameter in source/metadata.
                    if (parameterType.IsDynamic() || parameterType.SpecialType == SpecialType.System_Object)
                    {
                        // We have something like M([Optional] object x). We have special handling for such situations.
                        defaultValue = GetDefaultParameterSpecialNoConversion(syntax, parameter, diagnostics);
                    }
                    else
                    {
                        // The argument to M([Optional] int x) becomes default(int)
                        defaultValue = new BoundDefaultExpression(syntax, parameterType) { WasCompilerGenerated = true };
                    }
                }
                else if (defaultConstantValue.IsNull)
                {
                    defaultValue = new BoundDefaultExpression(syntax, parameterType) { WasCompilerGenerated = true };
                }
                else
                {
                    TypeSymbol constantType = Compilation.GetSpecialType(defaultConstantValue.SpecialType);
                    defaultValue = new BoundLiteral(syntax, defaultConstantValue, constantType) { WasCompilerGenerated = true };
                }

                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                Conversion conversion = Conversions.ClassifyConversionFromExpression(defaultValue, parameterType, ref useSiteInfo);
                diagnostics.Add(syntax, useSiteInfo);

                if (!conversion.IsValid && defaultConstantValue is { SpecialType: SpecialType.System_Decimal or SpecialType.System_DateTime })
                {
                    // Usually, if a default constant value fails to convert to the parameter type, we want an error at the call site.
                    // For legacy reasons, decimal and DateTime constants are special. If such a constant fails to convert to the parameter type
                    // then we want to silently replace it with default(ParameterType).
                    defaultValue = new BoundDefaultExpression(syntax, parameterType) { WasCompilerGenerated = true };
                }
                else
                {
                    if (!conversion.IsValid)
                    {
                        GenerateImplicitConversionError(diagnostics, syntax, conversion, defaultValue, parameterType);
                    }
                    var isCast = conversion.IsExplicit;
                    defaultValue = CreateConversion(
                        defaultValue.Syntax,
                        defaultValue,
                        conversion,
                        isCast,
                        isCast ? new ConversionGroup(conversion, parameter.TypeWithAnnotations) : null,
                        parameterType,
                        diagnostics);
                }

                return defaultValue;
            }

        }

        internal bool CheckImplicitThisCopyInReadOnlyMember(BoundExpression receiver, MethodSymbol method, BindingDiagnosticBag diagnostics)
        {
            if (receiver is BoundThisReference && receiver.Type!.IsValueType && ContainingMemberOrLambda is MethodSymbol methodSymbol && methodSymbol.IsEffectivelyReadOnly && TypeSymbol.Equals(methodSymbol.ContainingType, method.ContainingType, TypeCompareKind.ConsiderEverything) && !method.IsEffectivelyReadOnly && method.RequiresInstanceReceiver)
            {
                Error(diagnostics, ErrorCode.WRN_ImplicitCopyInReadOnlyMember, receiver.Syntax, method, "this");
                return false;
            }
            return true;
        }

        private static Location GetLocationForOverloadResolutionDiagnostic(SyntaxNode node, SyntaxNode expression)
        {
            if (node != expression)
            {
                switch (expression.Kind())
                {
                    case SyntaxKind.QualifiedName:
                        return ((QualifiedNameSyntax)expression).Right.GetLocation();
                    case SyntaxKind.SimpleMemberAccessExpression:
                    case SyntaxKind.PointerMemberAccessExpression:
                        return ((MemberAccessExpressionSyntax)expression).Name.GetLocation();
                }
            }
            return expression.GetLocation();
        }

        private BoundExpression ReplaceTypeOrValueReceiver(BoundExpression receiver, bool useType, BindingDiagnosticBag diagnostics)
        {
            if (receiver == null)
            {
                return null;
            }
            switch (receiver.Kind)
            {
                case BoundKind.TypeOrValueExpression:
                    {
                        BoundTypeOrValueExpression boundTypeOrValueExpression = (BoundTypeOrValueExpression)receiver;
                        if (useType)
                        {
                            diagnostics.AddRange(boundTypeOrValueExpression.Data.TypeDiagnostics);
                            return boundTypeOrValueExpression.Data.TypeExpression;
                        }
                        diagnostics.AddRange(boundTypeOrValueExpression.Data.ValueDiagnostics);
                        return CheckValue(boundTypeOrValueExpression.Data.ValueExpression, BindValueKind.RValue, diagnostics);
                    }
                case BoundKind.QueryClause:
                    {
                        BoundQueryClause boundQueryClause = (BoundQueryClause)receiver;
                        BoundExpression value = boundQueryClause.Value;
                        BoundExpression boundExpression = ReplaceTypeOrValueReceiver(value, useType, diagnostics);
                        if (value != boundExpression)
                        {
                            return boundQueryClause.Update(boundExpression, boundQueryClause.DefinedSymbol, boundQueryClause.Operation, boundQueryClause.Cast, boundQueryClause.Binder, boundQueryClause.UnoptimizedForm, boundQueryClause.Type);
                        }
                        return boundQueryClause;
                    }
                default:
                    return BindToNaturalType(receiver, diagnostics);
            }
        }

        private static NamedTypeSymbol GetDelegateType(BoundExpression expr)
        {
            if (expr != null && expr.Kind != BoundKind.TypeExpression && expr.Type is NamedTypeSymbol namedTypeSymbol && namedTypeSymbol.IsDelegateType())
            {
                return namedTypeSymbol;
            }
            return null;
        }

        private BoundCall CreateBadCall(SyntaxNode node, string name, BoundExpression receiver, ImmutableArray<MethodSymbol> methods, LookupResultKind resultKind, ImmutableArray<TypeWithAnnotations> typeArgumentsWithAnnotations, AnalyzedArguments analyzedArguments, bool invokedAsExtensionMethod, bool isDelegate)
        {
            if (!typeArgumentsWithAnnotations.IsDefaultOrEmpty)
            {
                ArrayBuilder<MethodSymbol> instance = ArrayBuilder<MethodSymbol>.GetInstance();
                ImmutableArray<MethodSymbol>.Enumerator enumerator = methods.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    MethodSymbol current = enumerator.Current;
                    instance.Add((current.ConstructedFrom == current && current.Arity == typeArgumentsWithAnnotations.Length) ? current.Construct(typeArgumentsWithAnnotations) : current);
                }
                methods = instance.ToImmutableAndFree();
            }
            MethodSymbol method;
            if (methods.Length == 1 && !IsUnboundGeneric(methods[0]))
            {
                method = methods[0];
            }
            else
            {
                TypeSymbol returnType = GetCommonTypeOrReturnType(methods) ?? new ExtendedErrorTypeSymbol(Compilation, string.Empty, 0, null);
                method = new ErrorMethodSymbol((receiver != null && (object)receiver.Type != null) ? receiver.Type : ContainingType, returnType, name);
            }
            ImmutableArray<BoundExpression> arguments = BuildArgumentsForErrorRecovery(analyzedArguments, methods);
            ImmutableArray<string> names = analyzedArguments.GetNames();
            ImmutableArray<RefKind> refKinds = analyzedArguments.RefKinds.ToImmutableOrNull();
            receiver = BindToTypeForErrorRecovery(receiver);
            return BoundCall.ErrorCall(node, receiver, method, arguments, names, refKinds, isDelegate, invokedAsExtensionMethod, methods, resultKind, this);
        }

        private static bool IsUnboundGeneric(MethodSymbol method)
        {
            if (method.IsGenericMethod)
            {
                return method.ConstructedFrom() == method;
            }
            return false;
        }

        private ImmutableArray<BoundExpression> BuildArgumentsForErrorRecovery(AnalyzedArguments analyzedArguments, ImmutableArray<MethodSymbol> methods)
        {
            ArrayBuilder<ImmutableArray<ParameterSymbol>> instance = ArrayBuilder<ImmutableArray<ParameterSymbol>>.GetInstance();
            ImmutableArray<MethodSymbol>.Enumerator enumerator = methods.GetEnumerator();
            while (enumerator.MoveNext())
            {
                MethodSymbol current = enumerator.Current;
                if (!IsUnboundGeneric(current) && current.ParameterCount > 0)
                {
                    instance.Add(current.Parameters);
                    if (instance.Count == 10)
                    {
                        break;
                    }
                }
            }
            ImmutableArray<BoundExpression> result = BuildArgumentsForErrorRecovery(analyzedArguments, instance);
            instance.Free();
            return result;
        }

        private ImmutableArray<BoundExpression> BuildArgumentsForErrorRecovery(AnalyzedArguments analyzedArguments, ImmutableArray<PropertySymbol> properties)
        {
            ArrayBuilder<ImmutableArray<ParameterSymbol>> instance = ArrayBuilder<ImmutableArray<ParameterSymbol>>.GetInstance();
            ImmutableArray<PropertySymbol>.Enumerator enumerator = properties.GetEnumerator();
            while (enumerator.MoveNext())
            {
                PropertySymbol current = enumerator.Current;
                if (current.ParameterCount > 0)
                {
                    instance.Add(current.Parameters);
                    if (instance.Count == 10)
                    {
                        break;
                    }
                }
            }
            ImmutableArray<BoundExpression> result = BuildArgumentsForErrorRecovery(analyzedArguments, instance);
            instance.Free();
            return result;
        }

        private ImmutableArray<BoundExpression> BuildArgumentsForErrorRecovery(AnalyzedArguments analyzedArguments, IEnumerable<ImmutableArray<ParameterSymbol>> parameterListList)
        {
            DiagnosticBag instance = DiagnosticBag.GetInstance();
            int count = analyzedArguments.Arguments.Count;
            ArrayBuilder<BoundExpression> instance2 = ArrayBuilder<BoundExpression>.GetInstance(count);
            instance2.AddRange(analyzedArguments.Arguments);
            for (int j = 0; j < count; j++)
            {
                BoundExpression boundExpression = instance2[j];
                switch (boundExpression.Kind)
                {
                    case BoundKind.UnboundLambda:
                        {
                            UnboundLambda unboundLambda = (UnboundLambda)boundExpression;
                            foreach (ImmutableArray<ParameterSymbol> parameterList in parameterListList)
                            {
                                TypeSymbol correspondingParameterType = GetCorrespondingParameterType(analyzedArguments, j, parameterList);
                                if ((object)correspondingParameterType != null && correspondingParameterType.Kind == SymbolKind.NamedType && (object)correspondingParameterType.GetDelegateType() != null)
                                {
                                    unboundLambda.Bind((NamedTypeSymbol)correspondingParameterType);
                                }
                            }
                            instance2[j] = unboundLambda.BindForErrorRecovery();
                            break;
                        }
                    case BoundKind.DiscardExpression:
                    case BoundKind.OutVariablePendingInference:
                        {
                            if (boundExpression.HasExpressionType())
                            {
                                break;
                            }
                            TypeSymbol typeSymbol = getCorrespondingParameterType(j);
                            if (boundExpression.Kind == BoundKind.OutVariablePendingInference)
                            {
                                if ((object)typeSymbol == null)
                                {
                                    instance2[j] = ((OutVariablePendingInference)boundExpression).FailInference(this, null);
                                }
                                else
                                {
                                    instance2[j] = ((OutVariablePendingInference)boundExpression).SetInferredTypeWithAnnotations(TypeWithAnnotations.Create(typeSymbol), null);
                                }
                            }
                            else if (boundExpression.Kind == BoundKind.DiscardExpression)
                            {
                                if ((object)typeSymbol == null)
                                {
                                    instance2[j] = ((BoundDiscardExpression)boundExpression).FailInference(this, null);
                                }
                                else
                                {
                                    instance2[j] = ((BoundDiscardExpression)boundExpression).SetInferredTypeWithAnnotations(TypeWithAnnotations.Create(typeSymbol));
                                }
                            }
                            break;
                        }
                    case BoundKind.OutDeconstructVarPendingInference:
                        instance2[j] = ((OutDeconstructVarPendingInference)boundExpression).FailInference(this);
                        break;
                    case BoundKind.Local:
                    case BoundKind.Parameter:
                        instance2[j] = BindToTypeForErrorRecovery(boundExpression);
                        break;
                    default:
                        instance2[j] = BindToTypeForErrorRecovery(boundExpression, getCorrespondingParameterType(j));
                        break;
                }
            }
            instance.Free();
            return instance2.ToImmutableAndFree();
            TypeSymbol getCorrespondingParameterType(int i)
            {
                TypeSymbol typeSymbol2 = null;
                foreach (ImmutableArray<ParameterSymbol> parameterList2 in parameterListList)
                {
                    TypeSymbol correspondingParameterType2 = GetCorrespondingParameterType(analyzedArguments, i, parameterList2);
                    if ((object)correspondingParameterType2 != null)
                    {
                        if ((object)typeSymbol2 == null)
                        {
                            typeSymbol2 = correspondingParameterType2;
                        }
                        else if (!typeSymbol2.Equals(correspondingParameterType2, TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes))
                        {
                            return null;
                        }
                    }
                }
                return typeSymbol2;
            }
        }

        private static TypeSymbol GetCorrespondingParameterType(AnalyzedArguments analyzedArguments, int i, ImmutableArray<ParameterSymbol> parameterList)
        {
            string text = analyzedArguments.Name(i);
            if (text != null)
            {
                ImmutableArray<ParameterSymbol>.Enumerator enumerator = parameterList.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    ParameterSymbol current = enumerator.Current;
                    if (current.Name == text)
                    {
                        return current.Type;
                    }
                }
                return null;
            }
            if (i >= parameterList.Length)
            {
                return null;
            }
            return parameterList[i].Type;
        }

        private ImmutableArray<BoundExpression> BuildArgumentsForErrorRecovery(AnalyzedArguments analyzedArguments)
        {
            return BuildArgumentsForErrorRecovery(analyzedArguments, Enumerable.Empty<ImmutableArray<ParameterSymbol>>());
        }

        private BoundCall CreateBadCall(SyntaxNode node, BoundExpression expr, LookupResultKind resultKind, AnalyzedArguments analyzedArguments)
        {
            TypeSymbol returnType = new ExtendedErrorTypeSymbol(Compilation, string.Empty, 0, null);
            MethodSymbol method = new ErrorMethodSymbol(expr.Type ?? ContainingType, returnType, string.Empty);
            ImmutableArray<BoundExpression> arguments = BuildArgumentsForErrorRecovery(analyzedArguments);
            ImmutableArray<string> names = analyzedArguments.GetNames();
            ImmutableArray<RefKind> refKinds = analyzedArguments.RefKinds.ToImmutableOrNull();
            ImmutableArray<MethodSymbol> originalMethods = ((expr.Kind == BoundKind.MethodGroup) ? ((BoundMethodGroup)expr).Methods : ImmutableArray<MethodSymbol>.Empty);
            return BoundCall.ErrorCall(node, expr, method, arguments, names, refKinds, isDelegateCall: false, invokedAsExtensionMethod: false, originalMethods, resultKind, this);
        }

        private static TypeSymbol GetCommonTypeOrReturnType<TMember>(ImmutableArray<TMember> members) where TMember : Symbol
        {
            TypeSymbol typeSymbol = null;
            int i = 0;
            for (int length = members.Length; i < length; i++)
            {
                TypeSymbol type = members[i].GetTypeOrReturnType().Type;
                if ((object)typeSymbol == null)
                {
                    typeSymbol = type;
                }
                else if (!TypeSymbol.Equals(typeSymbol, type, TypeCompareKind.ConsiderEverything))
                {
                    return null;
                }
            }
            return typeSymbol;
        }

        private bool TryBindNameofOperator(InvocationExpressionSyntax node, BindingDiagnosticBag diagnostics, out BoundExpression result)
        {
            result = null;
            if (node.Expression.Kind() != SyntaxKind.IdentifierName || ((IdentifierNameSyntax)node.Expression).Identifier.ContextualKind() != SyntaxKind.NameOfKeyword || node.ArgumentList.Arguments.Count != 1)
            {
                return false;
            }
            ArgumentSyntax argumentSyntax = node.ArgumentList.Arguments[0];
            if (argumentSyntax.NameColon != null || argumentSyntax.RefOrOutKeyword != default(SyntaxToken) || InvocableNameofInScope())
            {
                return false;
            }
            result = BindNameofOperatorInternal(node, diagnostics);
            return true;
        }

        private BoundExpression BindNameofOperatorInternal(InvocationExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            CheckFeatureAvailability(node, MessageID.IDS_FeatureNameof, diagnostics);
            ExpressionSyntax expression = node.ArgumentList.Arguments[0].Expression;
            NameofBinder nameofBinder = new NameofBinder(expression, this);
            BoundExpression boundExpression = nameofBinder.BindExpression(expression, diagnostics);
            bool flag = CheckSyntaxForNameofArgument(expression, out string name, boundExpression.HasAnyErrors ? BindingDiagnosticBag.Discarded : diagnostics);
            if (!boundExpression.HasAnyErrors && flag && boundExpression.Kind == BoundKind.MethodGroup)
            {
                BoundMethodGroup boundMethodGroup = (BoundMethodGroup)boundExpression;
                if (!boundMethodGroup.TypeArgumentsOpt.IsDefaultOrEmpty)
                {
                    diagnostics.Add(ErrorCode.ERR_NameofMethodGroupWithTypeParameters, expression.Location);
                }
                else
                {
                    nameofBinder.EnsureNameofExpressionSymbols(boundMethodGroup, diagnostics);
                }
            }
            if (boundExpression is BoundNamespaceExpression boundNamespaceExpression)
            {
                diagnostics.AddAssembliesUsedByNamespaceReference(boundNamespaceExpression.NamespaceSymbol);
            }
            boundExpression = BindToNaturalType(boundExpression, diagnostics, reportNoTargetType: false);
            return new BoundNameOfOperator(node, boundExpression, ConstantValue.Create(name), Compilation.GetSpecialType(SpecialType.System_String));
        }

        private void EnsureNameofExpressionSymbols(BoundMethodGroup methodGroup, BindingDiagnosticBag diagnostics)
        {
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            CallingConventionInfo callingConventionInfo = default(CallingConventionInfo);
            MethodGroupResolution methodGroupResolution = ResolveMethodGroup(methodGroup, null, isMethodGroupConversion: false, ref useSiteInfo, inferWithDynamic: false, RefKind.None, null, isFunctionPointerResolution: false, in callingConventionInfo);
            diagnostics.Add(methodGroup.Syntax, useSiteInfo);
            diagnostics.AddRange(methodGroupResolution.Diagnostics);
            if (methodGroupResolution.IsExtensionMethodGroup)
            {
                diagnostics.Add(ErrorCode.ERR_NameofExtensionMethod, methodGroup.Syntax.Location);
            }
        }

        private bool CheckSyntaxForNameofArgument(ExpressionSyntax argument, out string name, BindingDiagnosticBag diagnostics, bool top = true)
        {
            switch (argument.Kind())
            {
                case SyntaxKind.IdentifierName:
                    {
                        IdentifierNameSyntax identifierNameSyntax = (IdentifierNameSyntax)argument;
                        name = identifierNameSyntax.Identifier.ValueText;
                        return true;
                    }
                case SyntaxKind.GenericName:
                    {
                        GenericNameSyntax genericNameSyntax = (GenericNameSyntax)argument;
                        name = genericNameSyntax.Identifier.ValueText;
                        return true;
                    }
                case SyntaxKind.SimpleMemberAccessExpression:
                    {
                        MemberAccessExpressionSyntax memberAccessExpressionSyntax = (MemberAccessExpressionSyntax)argument;
                        bool result = true;
                        SyntaxKind syntaxKind = memberAccessExpressionSyntax.Expression.Kind();
                        if (syntaxKind - 8746 > SyntaxKind.List)
                        {
                            result = CheckSyntaxForNameofArgument(memberAccessExpressionSyntax.Expression, out name, diagnostics, top: false);
                        }
                        name = memberAccessExpressionSyntax.Name.Identifier.ValueText;
                        return result;
                    }
                case SyntaxKind.AliasQualifiedName:
                    {
                        AliasQualifiedNameSyntax aliasQualifiedNameSyntax = (AliasQualifiedNameSyntax)argument;
                        bool result2 = true;
                        if (top)
                        {
                            diagnostics.Add(ErrorCode.ERR_AliasQualifiedNameNotAnExpression, argument.Location);
                            result2 = false;
                        }
                        name = aliasQualifiedNameSyntax.Name.Identifier.ValueText;
                        return result2;
                    }
                case SyntaxKind.PredefinedType:
                case SyntaxKind.ThisExpression:
                case SyntaxKind.BaseExpression:
                    name = "";
                    if (!top)
                    {
                        return true;
                    }
                    break;
            }
            ErrorCode code = (top ? ErrorCode.ERR_ExpressionHasNoName : ErrorCode.ERR_SubexpressionNotInNameof);
            diagnostics.Add(code, argument.Location);
            name = "";
            return false;
        }

        private bool InvocableNameofInScope()
        {
            LookupResult instance = LookupResult.GetInstance();
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
            LookupSymbolsWithFallback(instance, SyntaxFacts.GetText(SyntaxKind.NameOfKeyword), 0, ref useSiteInfo, null, LookupOptions.MustBeInvocableIfMember | LookupOptions.AllMethodsOnArityZero);
            bool isMultiViable = instance.IsMultiViable;
            instance.Free();
            return isMultiViable;
        }

        private BoundFunctionPointerInvocation BindFunctionPointerInvocation(SyntaxNode node, BoundExpression boundExpression, AnalyzedArguments analyzedArguments, BindingDiagnosticBag diagnostics)
        {
            FunctionPointerTypeSymbol functionPointerTypeSymbol = (FunctionPointerTypeSymbol)boundExpression.Type;
            OverloadResolutionResult<FunctionPointerMethodSymbol> instance = OverloadResolutionResult<FunctionPointerMethodSymbol>.GetInstance();
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            ArrayBuilder<FunctionPointerMethodSymbol> instance2 = ArrayBuilder<FunctionPointerMethodSymbol>.GetInstance(1);
            instance2.Add(functionPointerTypeSymbol.Signature);
            OverloadResolution.FunctionPointerOverloadResolution(instance2, analyzedArguments, instance, ref useSiteInfo);
            diagnostics.Add(node, useSiteInfo);
            if (!instance.Succeeded)
            {
                ImmutableArray<FunctionPointerMethodSymbol> immutableArray = instance2.ToImmutableAndFree();
                instance.ReportDiagnostics(this, node.Location, null, diagnostics, null, boundExpression, boundExpression.Syntax, analyzedArguments, immutableArray, null, null, null, isMethodGroupConversion: false, functionPointerTypeSymbol.Signature.RefKind);
                return new BoundFunctionPointerInvocation(node, boundExpression, BuildArgumentsForErrorRecovery(analyzedArguments, StaticCast<MethodSymbol>.From(immutableArray)), analyzedArguments.RefKinds.ToImmutableOrNull(), LookupResultKind.OverloadResolutionFailure, functionPointerTypeSymbol.Signature.ReturnType, hasErrors: true);
            }
            instance2.Free();
            MemberResolutionResult<FunctionPointerMethodSymbol> validResult = instance.ValidResult;
            CoerceArguments(validResult, analyzedArguments.Arguments, diagnostics);
            ImmutableArray<BoundExpression> immutableArray2 = analyzedArguments.Arguments.ToImmutable();
            ImmutableArray<RefKind> argumentRefKindsOpt = analyzedArguments.RefKinds.ToImmutableOrNull();
            bool flag = ReportUnsafeIfNotAllowed(node, diagnostics);
            if (!flag)
            {
                flag = !CheckInvocationArgMixing(node, functionPointerTypeSymbol.Signature, null, functionPointerTypeSymbol.Signature.Parameters, immutableArray2, validResult.Result.ArgsToParamsOpt, LocalScopeDepth, diagnostics);
            }
            return new BoundFunctionPointerInvocation(node, boundExpression, immutableArray2, argumentRefKindsOpt, LookupResultKind.Viable, functionPointerTypeSymbol.Signature.ReturnType, flag);
        }

        private UnboundLambda AnalyzeAnonymousFunction(AnonymousFunctionExpressionSyntax syntax, BindingDiagnosticBag diagnostics)
        {
            ImmutableArray<string> names = default(ImmutableArray<string>);
            ImmutableArray<RefKind> refKinds = default(ImmutableArray<RefKind>);
            ImmutableArray<TypeWithAnnotations> types = default(ImmutableArray<TypeWithAnnotations>);
            ImmutableArray<SyntaxList<AttributeListSyntax>> attributes = default(ImmutableArray<SyntaxList<AttributeListSyntax>>);
            ArrayBuilder<string> instance = ArrayBuilder<string>.GetInstance();
            ImmutableArray<bool> discardsOpt = default(ImmutableArray<bool>);
            SeparatedSyntaxList<ParameterSyntax>? separatedSyntaxList = null;
            if (syntax is LambdaExpressionSyntax lambdaExpressionSyntax)
            {
                checkAttributes(syntax, lambdaExpressionSyntax.AttributeLists, diagnostics);
            }
            bool flag;
            switch (syntax.Kind())
            {
                default:
                    {
                        flag = true;
                        SimpleLambdaExpressionSyntax simpleLambdaExpressionSyntax = (SimpleLambdaExpressionSyntax)syntax;
                        instance.Add(simpleLambdaExpressionSyntax.Parameter.Identifier.ValueText);
                        break;
                    }
                case SyntaxKind.ParenthesizedLambdaExpression:
                    {
                        flag = true;
                        ParenthesizedLambdaExpressionSyntax parenthesizedLambdaExpressionSyntax = (ParenthesizedLambdaExpressionSyntax)syntax;
                        separatedSyntaxList = parenthesizedLambdaExpressionSyntax.ParameterList.Parameters;
                        CheckParenthesizedLambdaParameters(separatedSyntaxList.Value, diagnostics);
                        break;
                    }
                case SyntaxKind.AnonymousMethodExpression:
                    {
                        AnonymousMethodExpressionSyntax anonymousMethodExpressionSyntax = (AnonymousMethodExpressionSyntax)syntax;
                        flag = anonymousMethodExpressionSyntax.ParameterList != null;
                        if (flag)
                        {
                            separatedSyntaxList = anonymousMethodExpressionSyntax.ParameterList!.Parameters;
                        }
                        break;
                    }
            }
            bool isAsync = syntax.Modifiers.Any(SyntaxKind.AsyncKeyword);
            bool isStatic = syntax.Modifiers.Any(SyntaxKind.StaticKeyword);
            if (separatedSyntaxList.HasValue)
            {
                bool flag2 = true;
                bool flag3 = true;
                ArrayBuilder<TypeWithAnnotations> instance2 = ArrayBuilder<TypeWithAnnotations>.GetInstance();
                ArrayBuilder<RefKind> instance3 = ArrayBuilder<RefKind>.GetInstance();
                ArrayBuilder<SyntaxList<AttributeListSyntax>> instance4 = ArrayBuilder<SyntaxList<AttributeListSyntax>>.GetInstance();
                int num = 0;
                SeparatedSyntaxList<ParameterSyntax>.Enumerator enumerator = separatedSyntaxList.Value.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    ParameterSyntax current = enumerator.Current;
                    if (current.Identifier.IsUnderscoreToken())
                    {
                        num++;
                    }
                    checkAttributes(syntax, current.AttributeLists, diagnostics);
                    if (current.Default != null)
                    {
                        Error(diagnostics, ErrorCode.ERR_DefaultValueNotAllowed, current.Default!.EqualsToken);
                    }
                    if (current.IsArgList)
                    {
                        Error(diagnostics, ErrorCode.ERR_IllegalVarArgs, current);
                        continue;
                    }
                    TypeSyntax type = current.Type;
                    TypeWithAnnotations item = default(TypeWithAnnotations);
                    RefKind item2 = RefKind.None;
                    if (type == null)
                    {
                        flag2 = false;
                    }
                    else
                    {
                        item = BindType(type, diagnostics);
                        SyntaxTokenList.Enumerator enumerator2 = current.Modifiers.GetEnumerator();
                        while (enumerator2.MoveNext())
                        {
                            SyntaxToken current2 = enumerator2.Current;
                            switch (current2.Kind())
                            {
                                case SyntaxKind.RefKeyword:
                                    item2 = RefKind.Ref;
                                    flag3 = false;
                                    break;
                                case SyntaxKind.OutKeyword:
                                    item2 = RefKind.Out;
                                    flag3 = false;
                                    break;
                                case SyntaxKind.InKeyword:
                                    item2 = RefKind.In;
                                    flag3 = false;
                                    break;
                                case SyntaxKind.ParamsKeyword:
                                    Error(diagnostics, ErrorCode.ERR_IllegalParams, current);
                                    break;
                                case SyntaxKind.ThisKeyword:
                                    Error(diagnostics, ErrorCode.ERR_ThisInBadContext, current2);
                                    break;
                            }
                        }
                    }
                    instance.Add(current.Identifier.ValueText);
                    instance2.Add(item);
                    instance3.Add(item2);
                    instance4.Add((syntax.Kind() == SyntaxKind.ParenthesizedLambdaExpression) ? current.AttributeLists : default(SyntaxList<AttributeListSyntax>));
                }
                discardsOpt = computeDiscards(separatedSyntaxList.Value, num);
                if (flag2)
                {
                    types = instance2.ToImmutable();
                }
                if (!flag3)
                {
                    refKinds = instance3.ToImmutable();
                }
                if (instance4.Any((SyntaxList<AttributeListSyntax> a) => a.Count > 0))
                {
                    attributes = instance4.ToImmutable();
                }
                instance2.Free();
                instance3.Free();
                instance4.Free();
            }
            if (flag)
            {
                names = instance.ToImmutable();
            }
            instance.Free();
            return new UnboundLambda(syntax, this, diagnostics.AccumulatesDependencies, attributes, refKinds, types, names, discardsOpt, isAsync, isStatic);
            static void checkAttributes(AnonymousFunctionExpressionSyntax syntax, SyntaxList<AttributeListSyntax> attributeLists, BindingDiagnosticBag diagnostics)
            {
                SyntaxList<AttributeListSyntax>.Enumerator enumerator4 = attributeLists.GetEnumerator();
                while (enumerator4.MoveNext())
                {
                    AttributeListSyntax current4 = enumerator4.Current;
                    if (syntax.Kind() == SyntaxKind.ParenthesizedLambdaExpression)
                    {
                        MessageID.IDS_FeatureLambdaAttributes.CheckFeatureAvailability(diagnostics, current4);
                    }
                    else
                    {
                        Error(diagnostics, (syntax.Kind() == SyntaxKind.SimpleLambdaExpression) ? ErrorCode.ERR_AttributesRequireParenthesizedLambdaExpression : ErrorCode.ERR_AttributesNotAllowed, current4);
                    }
                }
            }
            static ImmutableArray<bool> computeDiscards(SeparatedSyntaxList<ParameterSyntax> parameters, int underscoresCount)
            {
                if (underscoresCount <= 1)
                {
                    return default(ImmutableArray<bool>);
                }
                ArrayBuilder<bool> instance5 = ArrayBuilder<bool>.GetInstance(parameters.Count);
                SeparatedSyntaxList<ParameterSyntax>.Enumerator enumerator3 = parameters.GetEnumerator();
                while (enumerator3.MoveNext())
                {
                    ParameterSyntax current3 = enumerator3.Current;
                    instance5.Add(current3.Identifier.IsUnderscoreToken());
                }
                return instance5.ToImmutableAndFree();
            }
        }

        private static void CheckParenthesizedLambdaParameters(SeparatedSyntaxList<ParameterSyntax> parameterSyntaxList, BindingDiagnosticBag diagnostics)
        {
            if (parameterSyntaxList.Count <= 0)
            {
                return;
            }
            bool flag = parameterSyntaxList[0].Type != null;
            int i = 1;
            for (int count = parameterSyntaxList.Count; i < count; i++)
            {
                ParameterSyntax parameterSyntax = parameterSyntaxList[i];
                if (!parameterSyntax.Identifier.IsMissing)
                {
                    bool flag2 = parameterSyntax.Type != null;
                    if (flag != flag2)
                    {
                        diagnostics.Add(ErrorCode.ERR_InconsistentLambdaParameterUsage, parameterSyntax.Type?.GetLocation() ?? parameterSyntax.Identifier.GetLocation());
                    }
                }
            }
        }

        private UnboundLambda BindAnonymousFunction(AnonymousFunctionExpressionSyntax syntax, BindingDiagnosticBag diagnostics)
        {
            UnboundLambda unboundLambda = AnalyzeAnonymousFunction(syntax, diagnostics);
            UnboundLambdaState data = unboundLambda.Data;
            if (data.HasExplicitlyTypedParameterList)
            {
                for (int i = 0; i < unboundLambda.ParameterCount; i++)
                {
                    TypeWithAnnotations typeWithAnnotations = unboundLambda.Data.ParameterTypeWithAnnotations(i);
                    if (typeWithAnnotations.HasType && typeWithAnnotations.IsStatic)
                    {
                        Error(diagnostics, ErrorFacts.GetStaticClassParameterCode(useWarning: false), syntax, typeWithAnnotations.Type);
                    }
                }
            }
            syntax.Modifiers.ToDeclarationModifiers(diagnostics.DiagnosticBag ?? new DiagnosticBag());
            if (data.HasNames)
            {
                LocalScopeBinder localScopeBinder = new LocalScopeBinder(this);
                bool flag = localScopeBinder.Compilation.IsFeatureEnabled(MessageID.IDS_FeatureNameShadowingInNestedFunctions);
                PooledHashSet<string> instance = PooledHashSet<string>.GetInstance();
                bool flag2 = false;
                for (int j = 0; j < unboundLambda.ParameterCount; j++)
                {
                    string text = unboundLambda.ParameterName(j);
                    if (string.IsNullOrEmpty(text))
                    {
                        continue;
                    }
                    if (unboundLambda.ParameterIsDiscard(j))
                    {
                        if (flag2)
                        {
                            MessageID.IDS_FeatureLambdaDiscardParameters.CheckFeatureAvailability(diagnostics, localScopeBinder.Compilation, unboundLambda.ParameterLocation(j));
                        }
                        flag2 = true;
                    }
                    else if (!instance.Add(text))
                    {
                        diagnostics.Add(ErrorCode.ERR_DuplicateParamName, unboundLambda.ParameterLocation(j), text);
                    }
                    else if (!flag)
                    {
                        localScopeBinder.ValidateLambdaParameterNameConflictsInScope(unboundLambda.ParameterLocation(j), text, diagnostics);
                    }
                }
                instance.Free();
            }
            return unboundLambda;
        }

        internal void LookupSymbolsSimpleName(LookupResult result, NamespaceOrTypeSymbol qualifierOpt, string plainName, int arity, ConsList<TypeSymbol> basesBeingResolved, LookupOptions options, bool diagnose, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            if (options.IsAttributeTypeLookup())
            {
                LookupAttributeType(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteInfo);
            }
            else
            {
                LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteInfo);
            }
        }

        internal void LookupExtensionMethods(LookupResult result, string name, int arity, LookupOptions options, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            ExtensionMethodScopeEnumerator enumerator = new ExtensionMethodScopes(this).GetEnumerator();
            while (enumerator.MoveNext())
            {
                ExtensionMethodScope current = enumerator.Current;
                LookupExtensionMethodsInSingleBinder(current, result, name, arity, options, ref useSiteInfo);
            }
        }

        private Binder LookupSymbolsWithFallback(LookupResult result, string name, int arity, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, ConsList<TypeSymbol> basesBeingResolved = null, LookupOptions options = LookupOptions.Default)
        {
            Binder result2 = LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose: false, ref useSiteInfo);
            if (result.Kind != LookupResultKind.Viable && result.Kind != 0)
            {
                result.Clear();
                LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose: true, ref useSiteInfo);
            }
            return result2;
        }

        private Binder LookupSymbolsInternal(LookupResult result, string name, int arity, ConsList<TypeSymbol> basesBeingResolved, LookupOptions options, bool diagnose, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            Binder binder = null;
            Binder binder2 = this;
            while (binder2 != null && !result.IsMultiViable)
            {
                if (binder != null)
                {
                    LookupResult instance = LookupResult.GetInstance();
                    binder2.LookupSymbolsInSingleBinder(instance, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteInfo);
                    result.MergeEqual(instance);
                    instance.Free();
                }
                else
                {
                    binder2.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteInfo);
                    if (!result.IsClear)
                    {
                        binder = binder2;
                    }
                }
                if ((options & LookupOptions.LabelsOnly) != 0 && binder2.IsLastBinderWithinMember())
                {
                    break;
                }
                binder2 = binder2.Next;
            }
            return binder;
        }

        internal virtual void LookupSymbolsInSingleBinder(LookupResult result, string name, int arity, ConsList<TypeSymbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
        }

        private void LookupSymbolsOrMembersInternal(LookupResult result, NamespaceOrTypeSymbol qualifierOpt, string name, int arity, ConsList<TypeSymbol> basesBeingResolved, LookupOptions options, bool diagnose, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            if ((object)qualifierOpt == null)
            {
                LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose, ref useSiteInfo);
            }
            else
            {
                LookupMembersInternal(result, qualifierOpt, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteInfo);
            }
        }

        private void LookupMembersWithFallback(LookupResult result, NamespaceOrTypeSymbol nsOrType, string name, int arity, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, ConsList<TypeSymbol> basesBeingResolved = null, LookupOptions options = LookupOptions.Default)
        {
            LookupMembersInternal(result, nsOrType, name, arity, basesBeingResolved, options, this, diagnose: false, ref useSiteInfo);
            if (!result.IsMultiViable && !result.IsClear)
            {
                result.Clear();
                LookupMembersInternal(result, nsOrType, name, arity, basesBeingResolved, options, this, diagnose: true, ref useSiteInfo);
            }
        }

        protected void LookupMembersInternal(LookupResult result, NamespaceOrTypeSymbol nsOrType, string name, int arity, ConsList<TypeSymbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            if (nsOrType.IsNamespace)
            {
                LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteInfo);
            }
            else
            {
                LookupMembersInType(result, (TypeSymbol)nsOrType, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteInfo);
            }
        }

        protected void LookupMembersInType(LookupResult result, TypeSymbol type, string name, int arity, ConsList<TypeSymbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            switch (type.TypeKind)
            {
                case TypeKind.TypeParameter:
                    LookupMembersInTypeParameter(result, (TypeParameterSymbol)type, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteInfo);
                    break;
                case TypeKind.Interface:
                    LookupMembersInInterface(result, (NamedTypeSymbol)type, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteInfo);
                    break;
                case TypeKind.Array:
                case TypeKind.Class:
                case TypeKind.Delegate:
                case TypeKind.Dynamic:
                case TypeKind.Enum:
                case TypeKind.Struct:
                case TypeKind.Submission:
                    LookupMembersInClass(result, type, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteInfo);
                    break;
                case TypeKind.Error:
                    LookupMembersInErrorType(result, (ErrorTypeSymbol)type, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteInfo);
                    break;
                case TypeKind.Pointer:
                case TypeKind.FunctionPointer:
                    result.Clear();
                    break;
                default:
                    throw ExceptionUtilities.UnexpectedValue(type.TypeKind);
            }
        }

        private void LookupMembersInErrorType(LookupResult result, ErrorTypeSymbol errorType, string name, int arity, ConsList<TypeSymbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            if (!errorType.CandidateSymbols.IsDefault && errorType.CandidateSymbols.Length == 1 && errorType.ResultKind == LookupResultKind.Inaccessible && errorType.CandidateSymbols.First() is TypeSymbol type)
            {
                LookupMembersInType(result, type, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteInfo);
            }
            else
            {
                result.Clear();
            }
        }

        protected void LookupMembersInSubmissions(LookupResult result, TypeSymbol submissionClass, CompilationUnitSyntax declarationSyntax, bool inUsings, string name, int arity, ConsList<TypeSymbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            LookupResult instance = LookupResult.GetInstance();
            LookupResult instance2 = LookupResult.GetInstance();
            SymbolKind? symbolKind = null;
            bool flag = Compilation.IsSubmissionSyntaxTree(declarationSyntax.SyntaxTree);
            for (CSharpCompilation cSharpCompilation = Compilation; cSharpCompilation != null; cSharpCompilation = cSharpCompilation.PreviousSubmission)
            {
                instance.Clear();
                bool flag2 = cSharpCompilation == Compilation;
                bool flag3 = !(flag2 && inUsings);
                Imports imports = ((!flag3) ? Imports.Empty : (flag ? cSharpCompilation.GetSubmissionImports() : ((!flag2) ? Imports.Empty : ((SourceNamespaceSymbol)Compilation.SourceModule.GlobalNamespace).GetImports(declarationSyntax, basesBeingResolved))));
                if ((options & LookupOptions.NamespaceAliasesOnly) == 0 && (object)cSharpCompilation.ScriptClass != null)
                {
                    LookupMembersWithoutInheritance(instance, cSharpCompilation.ScriptClass, name, arity, options, originalBinder, submissionClass, diagnose, ref useSiteInfo, basesBeingResolved);
                    if (instance.IsMultiViable && flag3 && IsUsingAlias(imports.UsingAliases, name, originalBinder.IsSemanticModelBinder))
                    {
                        Symbol symbol = instance.Symbols.First();
                        if (symbol.Kind != SymbolKind.NamedType || arity == 0)
                        {
                            CSDiagnosticInfo errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_ConflictingAliasAndDefinition, name, symbol.GetKindText());
                            ExtendedErrorTypeSymbol symbol2 = new ExtendedErrorTypeSymbol((NamespaceOrTypeSymbol?)null, name, arity, errorInfo, unreported: true, variableUsedBeforeDeclaration: false);
                            result.SetFrom(LookupResult.Good(symbol2));
                            break;
                        }
                    }
                }
                if (!instance.IsMultiViable && flag3)
                {
                    if (!flag2)
                    {
                        imports = Imports.ExpandPreviousSubmissionImports(imports, Compilation);
                    }
                    LookupSymbolInAliases(imports.UsingAliases, imports.ExternAliases, originalBinder, instance, name, arity, basesBeingResolved, options, diagnose, ref useSiteInfo);
                }
                if (!symbolKind.HasValue)
                {
                    if (!instance.IsMultiViable)
                    {
                        instance2.MergePrioritized(instance);
                    }
                    else
                    {
                        result.MergeEqual(instance);
                        Symbol symbol3 = instance.Symbols.First();
                        if (!IsMethodOrIndexer(symbol3))
                        {
                            break;
                        }
                        options &= ~(LookupOptions.NamespacesOrTypesOnly | LookupOptions.MustBeInvocableIfMember);
                        symbolKind = symbol3.Kind;
                    }
                }
                else
                {
                    if (instance.Symbols.Count > 0 && instance.Symbols.First().Kind != symbolKind.Value)
                    {
                        break;
                    }
                    if (instance.IsMultiViable)
                    {
                        result.MergeEqual(instance);
                    }
                }
            }
            if (result.Symbols.Count == 0)
            {
                result.SetFrom(instance2);
            }
            instance.Free();
            instance2.Free();
        }

        protected bool IsUsingAlias(ImmutableDictionary<string, AliasAndUsingDirective> usingAliases, string name, bool callerIsSemanticModel)
        {
            if (usingAliases.TryGetValue(name, out var value))
            {
                MarkImportDirective(value.UsingDirectiveReference, callerIsSemanticModel);
                return true;
            }
            return false;
        }

        protected void MarkImportDirective(SyntaxReference directive, bool callerIsSemanticModel)
        {
            if (directive != null && !callerIsSemanticModel)
            {
                Compilation.MarkImportDirectiveAsUsed(directive);
            }
        }

        protected void LookupSymbolInAliases(ImmutableDictionary<string, AliasAndUsingDirective> usingAliases, ImmutableArray<AliasAndExternAliasDirective> externAliases, Binder originalBinder, LookupResult result, string name, int arity, ConsList<TypeSymbol> basesBeingResolved, LookupOptions options, bool diagnose, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            bool isSemanticModelBinder = originalBinder.IsSemanticModelBinder;
            if (usingAliases.TryGetValue(name, out var value))
            {
                SingleLookupResult result2 = originalBinder.CheckViability(value.Alias, arity, options, null, diagnose, ref useSiteInfo, basesBeingResolved);
                if (result2.Kind == LookupResultKind.Viable)
                {
                    MarkImportDirective(value.UsingDirectiveReference, isSemanticModelBinder);
                }
                result.MergeEqual(result2);
            }
            ImmutableArray<AliasAndExternAliasDirective>.Enumerator enumerator = externAliases.GetEnumerator();
            while (enumerator.MoveNext())
            {
                AliasAndExternAliasDirective current = enumerator.Current;
                if (!current.SkipInLookup && current.Alias.Name == name)
                {
                    SingleLookupResult result3 = originalBinder.CheckViability(current.Alias, arity, options, null, diagnose, ref useSiteInfo, basesBeingResolved);
                    if (result3.Kind == LookupResultKind.Viable)
                    {
                        MarkImportDirective(current.ExternAliasDirectiveReference, isSemanticModelBinder);
                    }
                    result.MergeEqual(result3);
                }
            }
        }

        private static void LookupMembersInNamespace(LookupResult result, NamespaceSymbol ns, string name, int arity, LookupOptions options, Binder originalBinder, bool diagnose, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            ImmutableArray<Symbol>.Enumerator enumerator = GetCandidateMembers(ns, name, options, originalBinder).GetEnumerator();
            while (enumerator.MoveNext())
            {
                Symbol current = enumerator.Current;
                SingleLookupResult result2 = originalBinder.CheckViability(current, arity, options, null, diagnose, ref useSiteInfo);
                result.MergeEqual(result2);
            }
        }

        private void LookupExtensionMethodsInSingleBinder(ExtensionMethodScope scope, LookupResult result, string name, int arity, LookupOptions options, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            ArrayBuilder<MethodSymbol> instance = ArrayBuilder<MethodSymbol>.GetInstance();
            scope.Binder.GetCandidateExtensionMethods(instance, name, arity, options, this);
            ArrayBuilder<MethodSymbol>.Enumerator enumerator = instance.GetEnumerator();
            while (enumerator.MoveNext())
            {
                MethodSymbol current = enumerator.Current;
                SingleLookupResult result2 = CheckViability(current, arity, options, null, diagnose: true, ref useSiteInfo);
                result.MergeEqual(result2);
            }
            instance.Free();
        }

        private void LookupAttributeType(LookupResult result, NamespaceOrTypeSymbol qualifierOpt, string name, int arity, ConsList<TypeSymbol> basesBeingResolved, LookupOptions options, bool diagnose, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            LookupSymbolsOrMembersInternal(result, qualifierOpt, name, arity, basesBeingResolved, options, diagnose, ref useSiteInfo);
            CompoundUseSiteInfo<AssemblySymbol> attributeTypeViabilityUseSiteInfo = new CompoundUseSiteInfo<AssemblySymbol>(useSiteInfo);
            bool flag = IsSingleViableAttributeType(result, out Symbol symbol, ref attributeTypeViabilityUseSiteInfo);
            LookupResult lookupResult = null;
            Symbol symbol2 = null;
            CompoundUseSiteInfo<AssemblySymbol> other = new CompoundUseSiteInfo<AssemblySymbol>(useSiteInfo);
            bool flag2 = false;
            if (!options.IsVerbatimNameAttributeTypeLookup())
            {
                lookupResult = LookupResult.GetInstance();
                LookupSymbolsOrMembersInternal(lookupResult, qualifierOpt, name + "Attribute", arity, basesBeingResolved, options, diagnose, ref useSiteInfo);
                flag2 = IsSingleViableAttributeType(lookupResult, out symbol2, ref other);
            }
            if (flag && flag2)
            {
                result.MergeEqual(lookupResult);
            }
            else if (flag)
            {
                useSiteInfo.MergeAndClear(ref attributeTypeViabilityUseSiteInfo);
            }
            else if (flag2)
            {
                result.SetFrom(lookupResult);
                useSiteInfo.MergeAndClear(ref other);
            }
            else
            {
                if (!result.IsClear && (object)symbol != null)
                {
                    result.SetFrom(GenerateNonViableAttributeTypeResult(symbol, result.Error, diagnose));
                }
                if (lookupResult != null)
                {
                    if (!lookupResult.IsClear && (object)symbol2 != null)
                    {
                        lookupResult.SetFrom(GenerateNonViableAttributeTypeResult(symbol2, lookupResult.Error, diagnose));
                    }
                    result.MergePrioritized(lookupResult);
                }
            }
            lookupResult?.Free();
        }

        private bool IsAmbiguousResult(LookupResult result, out Symbol resultSymbol)
        {
            resultSymbol = null;
            ArrayBuilder<Symbol> symbols = result.Symbols;
            switch (symbols.Count)
            {
                case 0:
                    return false;
                case 1:
                    resultSymbol = symbols[0];
                    return false;
                default:
                    resultSymbol = ResolveMultipleSymbolsInAttributeTypeLookup(symbols);
                    return (object)resultSymbol == null;
            }
        }

        private Symbol ResolveMultipleSymbolsInAttributeTypeLookup(ArrayBuilder<Symbol> symbols)
        {
            ImmutableArray<Symbol> immutableArray = symbols.ToImmutable();
            for (int i = 0; i < symbols.Count; i++)
            {
                symbols[i] = UnwrapAliasNoDiagnostics(symbols[i]);
            }
            BestSymbolInfo bestSymbolInfo = GetBestSymbolInfo(symbols, out BestSymbolInfo secondBest);
            if (bestSymbolInfo.IsFromCompilation && !secondBest.IsFromCompilation)
            {
                Symbol x = symbols[bestSymbolInfo.Index];
                Symbol y = symbols[secondBest.Index];
                if (NameAndArityMatchRecursively(x, y))
                {
                    return immutableArray[bestSymbolInfo.Index];
                }
            }
            return null;
        }

        private static bool NameAndArityMatchRecursively(Symbol x, Symbol y)
        {
            while (true)
            {
                if (isRoot(x))
                {
                    return isRoot(y);
                }
                if (isRoot(y))
                {
                    return false;
                }
                if (x.Name != y.Name || x.GetArity() != y.GetArity())
                {
                    break;
                }
                x = x.ContainingSymbol;
                y = y.ContainingSymbol;
            }
            return false;
            static bool isRoot(Symbol symbol)
            {
                if ((object)symbol != null)
                {
                    if (symbol is NamespaceSymbol namespaceSymbol)
                    {
                        return namespaceSymbol.IsGlobalNamespace;
                    }
                    return false;
                }
                return true;
            }
        }

        private bool IsSingleViableAttributeType(LookupResult result, out Symbol symbol, ref CompoundUseSiteInfo<AssemblySymbol> attributeTypeViabilityUseSiteInfo)
        {
            if (IsAmbiguousResult(result, out symbol))
            {
                return false;
            }
            if (result == null || result.Kind != LookupResultKind.Viable || (object)symbol == null)
            {
                return false;
            }
            DiagnosticInfo diagInfo = null;
            return CheckAttributeTypeViability(UnwrapAliasNoDiagnostics(symbol), diagnose: false, ref diagInfo, ref attributeTypeViabilityUseSiteInfo);
        }

        private SingleLookupResult GenerateNonViableAttributeTypeResult(Symbol symbol, DiagnosticInfo diagInfo, bool diagnose)
        {
            symbol = UnwrapAliasNoDiagnostics(symbol);
            CompoundUseSiteInfo<AssemblySymbol> attributeTypeViabilityUseSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
            CheckAttributeTypeViability(symbol, diagnose, ref diagInfo, ref attributeTypeViabilityUseSiteInfo);
            return LookupResult.NotAnAttributeType(symbol, diagInfo);
        }

        private bool CheckAttributeTypeViability(Symbol symbol, bool diagnose, ref DiagnosticInfo diagInfo, ref CompoundUseSiteInfo<AssemblySymbol> attributeTypeViabilityUseSiteInfo)
        {
            if (symbol.Kind == SymbolKind.NamedType)
            {
                NamedTypeSymbol namedTypeSymbol = (NamedTypeSymbol)symbol;
                if (namedTypeSymbol.IsGenericType)
                {
                    diagInfo = (diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_AttributeCantBeGeneric, symbol) : null);
                    return false;
                }
                if (namedTypeSymbol.IsAbstract)
                {
                    diagInfo = (diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_AbstractAttributeClass, symbol) : null);
                    return false;
                }
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = ((attributeTypeViabilityUseSiteInfo.AccumulatesDependencies || !diagnose) ? new CompoundUseSiteInfo<AssemblySymbol>(attributeTypeViabilityUseSiteInfo) : CompoundUseSiteInfo<AssemblySymbol>.DiscardedDependencies);
                if (Compilation.IsEqualOrDerivedFromWellKnownClass(namedTypeSymbol, WellKnownType.System_Attribute, ref useSiteInfo))
                {
                    attributeTypeViabilityUseSiteInfo.MergeAndClear(ref useSiteInfo);
                    return true;
                }
                if (diagnose && useSiteInfo.HasErrors)
                {
                    foreach (DiagnosticInfo item in useSiteInfo.Diagnostics!)
                    {
                        if (item.Severity == DiagnosticSeverity.Error)
                        {
                            diagInfo = item;
                            return false;
                        }
                    }
                }
            }
            diagInfo = (diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_NotAnAttributeClass, symbol) : null);
            return false;
        }

        internal virtual void GetCandidateExtensionMethods(ArrayBuilder<MethodSymbol> methods, string name, int arity, LookupOptions options, Binder originalBinder)
        {
        }

        protected static void LookupMembersWithoutInheritance(LookupResult result, TypeSymbol type, string name, int arity, LookupOptions options, Binder originalBinder, TypeSymbol accessThroughType, bool diagnose, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, ConsList<TypeSymbol> basesBeingResolved)
        {
            ImmutableArray<Symbol>.Enumerator enumerator = GetCandidateMembers(type, name, options, originalBinder).GetEnumerator();
            while (enumerator.MoveNext())
            {
                Symbol current = enumerator.Current;
                SingleLookupResult result2 = originalBinder.CheckViability(current, arity, options, accessThroughType, diagnose, ref useSiteInfo, basesBeingResolved);
                result.MergeEqual(result2);
            }
        }

        private void LookupMembersInClass(LookupResult result, TypeSymbol type, string name, int arity, ConsList<TypeSymbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            LookupMembersInClass(result, type, name, arity, basesBeingResolved, options, originalBinder, type, diagnose, ref useSiteInfo);
        }

        private void LookupMembersInClass(LookupResult result, TypeSymbol type, string name, int arity, ConsList<TypeSymbol> basesBeingResolved, LookupOptions options, Binder originalBinder, TypeSymbol accessThroughType, bool diagnose, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            TypeSymbol typeSymbol = type;
            LookupResult instance = LookupResult.GetInstance();
            PooledHashSet<NamedTypeSymbol> visited = null;
            while ((object)typeSymbol != null)
            {
                instance.Clear();
                LookupMembersWithoutInheritance(instance, typeSymbol, name, arity, options, originalBinder, accessThroughType, diagnose, ref useSiteInfo, basesBeingResolved);
                MergeHidingLookupResults(result, instance, basesBeingResolved, ref useSiteInfo);
                if (typeSymbol is NamedTypeSymbol namedTypeSymbol && namedTypeSymbol.ShouldAddWinRTMembers)
                {
                    AddWinRTMembers(result, namedTypeSymbol, name, arity, options, originalBinder, diagnose, ref useSiteInfo);
                }
                bool flag = instance.IsMultiViable && !IsMethodOrIndexer(instance.Symbols[0]);
                if (result.IsMultiViable && (flag || !IsMethodOrIndexer(result.Symbols[0])))
                {
                    break;
                }
                if (basesBeingResolved != null && basesBeingResolved.ContainsReference(type.OriginalDefinition))
                {
                    Symbol nearestOtherSymbol = GetNearestOtherSymbol(basesBeingResolved, type);
                    CSDiagnosticInfo errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_CircularBase, type, nearestOtherSymbol);
                    ExtendedErrorTypeSymbol symbol = new ExtendedErrorTypeSymbol(Compilation, name, arity, errorInfo, unreported: true);
                    result.SetFrom(LookupResult.Good(symbol));
                }
                if (originalBinder.InCrefButNotParameterOrReturnType)
                {
                    break;
                }
                typeSymbol = typeSymbol.GetNextBaseTypeNoUseSiteDiagnostics(basesBeingResolved, Compilation, ref visited);
                typeSymbol?.OriginalDefinition.AddUseSiteInfo(ref useSiteInfo);
            }
            visited?.Free();
            instance.Free();
        }

        private void AddWinRTMembers(LookupResult result, NamedTypeSymbol type, string name, int arity, LookupOptions options, Binder originalBinder, bool diagnose, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            MemberSignatureComparer cSharpOverrideComparer = MemberSignatureComparer.CSharpOverrideComparer;
            HashSet<Symbol> hashSet = new HashSet<Symbol>(cSharpOverrideComparer);
            HashSet<Symbol> hashSet2 = new HashSet<Symbol>(cSharpOverrideComparer);
            if (result.IsMultiViable)
            {
                ArrayBuilder<Symbol>.Enumerator enumerator = result.Symbols.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    Symbol current = enumerator.Current;
                    if (current.Kind == SymbolKind.Method || current.Kind == SymbolKind.Property)
                    {
                        hashSet.Add(current);
                    }
                }
            }
            LookupResult instance = LookupResult.GetInstance();
            GetWellKnownWinRTMemberInterfaces(out var idictSymbol, out var iroDictSymbol, out var iListSymbol, out var iCollectionSymbol, out var inccSymbol, out var inpcSymbol);
            ImmutableArray<NamedTypeSymbol>.Enumerator enumerator2 = type.AllInterfacesWithDefinitionUseSiteDiagnostics(ref useSiteInfo).GetEnumerator();
            while (enumerator2.MoveNext())
            {
                NamedTypeSymbol current2 = enumerator2.Current;
                if (!ShouldAddWinRTMembersForInterface(current2, idictSymbol, iroDictSymbol, iListSymbol, iCollectionSymbol, inccSymbol, inpcSymbol))
                {
                    continue;
                }
                LookupMembersWithoutInheritance(instance, current2, name, arity, options, originalBinder, current2, diagnose, ref useSiteInfo, null);
                if (instance.IsMultiViable)
                {
                    ArrayBuilder<Symbol>.Enumerator enumerator = instance.Symbols.GetEnumerator();
                    while (enumerator.MoveNext())
                    {
                        Symbol current3 = enumerator.Current;
                        if (!hashSet.Add(current3))
                        {
                            hashSet2.Add(current3);
                        }
                    }
                }
                instance.Clear();
            }
            instance.Free();
            if (result.IsMultiViable)
            {
                ArrayBuilder<Symbol>.Enumerator enumerator = result.Symbols.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    Symbol current4 = enumerator.Current;
                    if (current4.Kind == SymbolKind.Method || current4.Kind == SymbolKind.Property)
                    {
                        hashSet.Remove(current4);
                        hashSet2.Remove(current4);
                    }
                }
            }
            foreach (Symbol item in hashSet)
            {
                if (!hashSet2.Contains(item))
                {
                    result.MergeEqual(new SingleLookupResult(LookupResultKind.Viable, item, null));
                }
            }
        }

        private void GetWellKnownWinRTMemberInterfaces(out NamedTypeSymbol idictSymbol, out NamedTypeSymbol iroDictSymbol, out NamedTypeSymbol iListSymbol, out NamedTypeSymbol iCollectionSymbol, out NamedTypeSymbol inccSymbol, out NamedTypeSymbol inpcSymbol)
        {
            idictSymbol = Compilation.GetWellKnownType(WellKnownType.System_Collections_Generic_IDictionary_KV);
            iroDictSymbol = Compilation.GetWellKnownType(WellKnownType.System_Collections_Generic_IReadOnlyDictionary_KV);
            iListSymbol = Compilation.GetWellKnownType(WellKnownType.System_Collections_IList);
            iCollectionSymbol = Compilation.GetWellKnownType(WellKnownType.System_Collections_ICollection);
            inccSymbol = Compilation.GetWellKnownType(WellKnownType.System_Collections_Specialized_INotifyCollectionChanged);
            inpcSymbol = Compilation.GetWellKnownType(WellKnownType.System_ComponentModel_INotifyPropertyChanged);
        }

        private static bool ShouldAddWinRTMembersForInterface(NamedTypeSymbol iface, NamedTypeSymbol idictSymbol, NamedTypeSymbol iroDictSymbol, NamedTypeSymbol iListSymbol, NamedTypeSymbol iCollectionSymbol, NamedTypeSymbol inccSymbol, NamedTypeSymbol inpcSymbol)
        {
            NamedTypeSymbol originalDefinition = iface.OriginalDefinition;
            SpecialType specialType = originalDefinition.SpecialType;
            if (specialType != SpecialType.System_Collections_Generic_IEnumerable_T && specialType != SpecialType.System_Collections_Generic_IList_T && specialType != SpecialType.System_Collections_Generic_ICollection_T && !TypeSymbol.Equals(originalDefinition, idictSymbol, TypeCompareKind.ConsiderEverything) && specialType != SpecialType.System_Collections_Generic_IReadOnlyList_T && specialType != SpecialType.System_Collections_Generic_IReadOnlyCollection_T && !TypeSymbol.Equals(originalDefinition, iroDictSymbol, TypeCompareKind.ConsiderEverything) && specialType != SpecialType.System_Collections_IEnumerable && !TypeSymbol.Equals(originalDefinition, iListSymbol, TypeCompareKind.ConsiderEverything) && !TypeSymbol.Equals(originalDefinition, iCollectionSymbol, TypeCompareKind.ConsiderEverything) && !TypeSymbol.Equals(originalDefinition, inccSymbol, TypeCompareKind.ConsiderEverything))
            {
                return TypeSymbol.Equals(originalDefinition, inpcSymbol, TypeCompareKind.ConsiderEverything);
            }
            return true;
        }

        private static Symbol GetNearestOtherSymbol(ConsList<TypeSymbol> list, TypeSymbol type)
        {
            TypeSymbol typeSymbol = type;
            while (list != null && list != ConsList<TypeSymbol>.Empty)
            {
                if (TypeSymbol.Equals(list.Head, type.OriginalDefinition, TypeCompareKind.ConsiderEverything))
                {
                    if (TypeSymbol.Equals(typeSymbol, type, TypeCompareKind.ConsiderEverything) && list.Tail != null && list.Tail != ConsList<TypeSymbol>.Empty)
                    {
                        typeSymbol = list.Tail.Head;
                    }
                    break;
                }
                typeSymbol = list.Head;
                list = list.Tail;
            }
            return typeSymbol;
        }

        private static void LookupMembersInInterfaceOnly(LookupResult current, NamedTypeSymbol type, string name, int arity, ConsList<TypeSymbol> basesBeingResolved, LookupOptions options, Binder originalBinder, TypeSymbol accessThroughType, bool diagnose, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            LookupMembersWithoutInheritance(current, type, name, arity, options, originalBinder, accessThroughType, diagnose, ref useSiteInfo, basesBeingResolved);
            if ((options & LookupOptions.NamespaceAliasesOnly) == 0 && !originalBinder.InCrefButNotParameterOrReturnType)
            {
                LookupMembersInInterfacesWithoutInheritance(current, GetBaseInterfaces(type, basesBeingResolved, ref useSiteInfo), name, arity, basesBeingResolved, options, originalBinder, accessThroughType, diagnose, ref useSiteInfo);
            }
        }

        private static ImmutableArray<NamedTypeSymbol> GetBaseInterfaces(NamedTypeSymbol type, ConsList<TypeSymbol> basesBeingResolved, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            if (basesBeingResolved == null || !basesBeingResolved.Any())
            {
                return type.AllInterfacesWithDefinitionUseSiteDiagnostics(ref useSiteInfo);
            }
            if (basesBeingResolved.ContainsReference(type.OriginalDefinition))
            {
                return ImmutableArray<NamedTypeSymbol>.Empty;
            }
            ImmutableArray<NamedTypeSymbol> declaredInterfaces = type.GetDeclaredInterfaces(basesBeingResolved);
            if (declaredInterfaces.IsEmpty)
            {
                return ImmutableArray<NamedTypeSymbol>.Empty;
            }
            ConsList<NamedTypeSymbol> cycleGuard2 = ConsList<NamedTypeSymbol>.Empty.Prepend(type.OriginalDefinition);
            ArrayBuilder<NamedTypeSymbol> instance = ArrayBuilder<NamedTypeSymbol>.GetInstance();
            HashSet<NamedTypeSymbol> visited2 = new HashSet<NamedTypeSymbol>(Microsoft.CodeAnalysis.CSharp.Symbols.SymbolEqualityComparer.ConsiderEverything);
            for (int num = declaredInterfaces.Length - 1; num >= 0; num--)
            {
                addAllInterfaces(declaredInterfaces[num], visited2, instance, basesBeingResolved, cycleGuard2);
            }
            instance.ReverseContents();
            ArrayBuilder<NamedTypeSymbol>.Enumerator enumerator = instance.GetEnumerator();
            while (enumerator.MoveNext())
            {
                enumerator.Current.OriginalDefinition.AddUseSiteInfo(ref useSiteInfo);
            }
            return instance.ToImmutableAndFree();
            static void addAllInterfaces(NamedTypeSymbol @interface, HashSet<NamedTypeSymbol> visited, ArrayBuilder<NamedTypeSymbol> result, ConsList<TypeSymbol> basesBeingResolved, ConsList<NamedTypeSymbol> cycleGuard)
            {
                NamedTypeSymbol originalDefinition;
                if (@interface.IsInterface && !cycleGuard.ContainsReference(originalDefinition = @interface.OriginalDefinition) && visited.Add(@interface))
                {
                    if (!basesBeingResolved.ContainsReference(originalDefinition))
                    {
                        ImmutableArray<NamedTypeSymbol> declaredInterfaces2 = @interface.GetDeclaredInterfaces(basesBeingResolved);
                        if (!declaredInterfaces2.IsEmpty)
                        {
                            cycleGuard = cycleGuard.Prepend(originalDefinition);
                            for (int num2 = declaredInterfaces2.Length - 1; num2 >= 0; num2--)
                            {
                                addAllInterfaces(declaredInterfaces2[num2], visited, result, basesBeingResolved, cycleGuard);
                            }
                        }
                    }
                    result.Add(@interface);
                }
            }
        }

        private static void LookupMembersInInterfacesWithoutInheritance(LookupResult current, ImmutableArray<NamedTypeSymbol> interfaces, string name, int arity, ConsList<TypeSymbol> basesBeingResolved, LookupOptions options, Binder originalBinder, TypeSymbol accessThroughType, bool diagnose, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            if (interfaces.Length <= 0)
            {
                return;
            }
            LookupResult instance = LookupResult.GetInstance();
            HashSet<NamedTypeSymbol> hashSet = null;
            if (interfaces.Length > 1)
            {
                hashSet = new HashSet<NamedTypeSymbol>(Microsoft.CodeAnalysis.CSharp.Symbols.SymbolEqualityComparer.IgnoringNullable);
            }
            ImmutableArray<NamedTypeSymbol>.Enumerator enumerator = interfaces.GetEnumerator();
            while (enumerator.MoveNext())
            {
                NamedTypeSymbol current2 = enumerator.Current;
                if (hashSet == null || hashSet.Add(current2))
                {
                    LookupMembersWithoutInheritance(instance, current2, name, arity, options, originalBinder, accessThroughType, diagnose, ref useSiteInfo, basesBeingResolved);
                    MergeHidingLookupResults(current, instance, basesBeingResolved, ref useSiteInfo);
                    instance.Clear();
                }
            }
            instance.Free();
        }

        private void LookupMembersInInterface(LookupResult current, NamedTypeSymbol type, string name, int arity, ConsList<TypeSymbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            LookupMembersInInterfaceOnly(current, type, name, arity, basesBeingResolved, options, originalBinder, type, diagnose, ref useSiteInfo);
            if (!originalBinder.InCrefButNotParameterOrReturnType)
            {
                LookupResult instance = LookupResult.GetInstance();
                LookupMembersInClass(instance, Compilation.GetSpecialType(SpecialType.System_Object), name, arity, basesBeingResolved, options, originalBinder, type, diagnose, ref useSiteInfo);
                MergeHidingLookupResults(current, instance, basesBeingResolved, ref useSiteInfo);
                instance.Free();
            }
        }

        private void LookupMembersInTypeParameter(LookupResult current, TypeParameterSymbol typeParameter, string name, int arity, ConsList<TypeSymbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            if ((options & (LookupOptions.NamespaceAliasesOnly | LookupOptions.NamespacesOrTypesOnly)) == 0)
            {
                LookupMembersInClass(current, typeParameter.EffectiveBaseClass(ref useSiteInfo), name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteInfo);
                LookupMembersInInterfacesWithoutInheritance(current, typeParameter.AllEffectiveInterfacesWithDefinitionUseSiteDiagnostics(ref useSiteInfo), name, arity, null, options, originalBinder, typeParameter, diagnose, ref useSiteInfo);
            }
        }

        private static bool IsDerivedType(NamedTypeSymbol baseType, NamedTypeSymbol derivedType, ConsList<TypeSymbol> basesBeingResolved, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            NamedTypeSymbol namedTypeSymbol = derivedType.BaseTypeWithDefinitionUseSiteDiagnostics(ref useSiteInfo);
            while ((object)namedTypeSymbol != null)
            {
                if (TypeSymbol.Equals(namedTypeSymbol, baseType, TypeCompareKind.ConsiderEverything))
                {
                    return true;
                }
                namedTypeSymbol = namedTypeSymbol.BaseTypeWithDefinitionUseSiteDiagnostics(ref useSiteInfo);
            }
            if (baseType.IsInterface)
            {
                return GetBaseInterfaces(derivedType, basesBeingResolved, ref useSiteInfo).Contains(baseType);
            }
            return false;
        }

        private static void MergeHidingLookupResults(LookupResult resultHiding, LookupResult resultHidden, ConsList<TypeSymbol> basesBeingResolved, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            if (resultHiding.IsMultiViable && resultHidden.IsMultiViable)
            {
                ArrayBuilder<Symbol> symbols = resultHiding.Symbols;
                int count = symbols.Count;
                ArrayBuilder<Symbol> symbols2 = resultHidden.Symbols;
                int count2 = symbols2.Count;
                for (int i = 0; i < count2; i++)
                {
                    Symbol symbol = symbols2[i];
                    NamedTypeSymbol containingType = symbol.ContainingType;
                    int num = 0;
                    while (true)
                    {
                        if (num < count)
                        {
                            Symbol symbol2 = symbols[num];
                            if ((!symbol2.ContainingType.IsInterface || IsDerivedType(containingType, symbol2.ContainingType, basesBeingResolved, ref useSiteInfo) || containingType.SpecialType == SpecialType.System_Object) && (!IsMethodOrIndexer(symbol2) || !IsMethodOrIndexer(symbol)))
                            {
                                break;
                            }
                            num++;
                            continue;
                        }
                        symbols.Add(symbol);
                        break;
                    }
                }
            }
            else
            {
                resultHiding.MergePrioritized(resultHidden);
            }
        }

        private static bool IsMethodOrIndexer(Symbol symbol)
        {
            if (symbol.Kind != SymbolKind.Method)
            {
                return symbol.IsIndexer();
            }
            return true;
        }

        internal static ImmutableArray<Symbol> GetCandidateMembers(NamespaceOrTypeSymbol nsOrType, string name, LookupOptions options, Binder originalBinder)
        {
            if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && nsOrType is TypeSymbol)
            {
                return nsOrType.GetTypeMembers(name).Cast<NamedTypeSymbol, Symbol>();
            }
            if (nsOrType.Kind == SymbolKind.NamedType && originalBinder.IsEarlyAttributeBinder)
            {
                return ((NamedTypeSymbol)nsOrType).GetEarlyAttributeDecodingMembers(name);
            }
            if ((options & LookupOptions.LabelsOnly) != 0)
            {
                return ImmutableArray<Symbol>.Empty;
            }
            return nsOrType.GetMembers(name);
        }

        internal static ImmutableArray<Symbol> GetCandidateMembers(NamespaceOrTypeSymbol nsOrType, LookupOptions options, Binder originalBinder)
        {
            if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && nsOrType is TypeSymbol)
            {
                return StaticCast<Symbol>.From(nsOrType.GetTypeMembersUnordered());
            }
            if (nsOrType.Kind == SymbolKind.NamedType && originalBinder.IsEarlyAttributeBinder)
            {
                return ((NamedTypeSymbol)nsOrType).GetEarlyAttributeDecodingMembers();
            }
            if ((options & LookupOptions.LabelsOnly) != 0)
            {
                return ImmutableArray<Symbol>.Empty;
            }
            return nsOrType.GetMembersUnordered();
        }

        internal SingleLookupResult CheckViability(Symbol symbol, int arity, LookupOptions options, TypeSymbol accessThroughType, bool diagnose, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, ConsList<TypeSymbol> basesBeingResolved = null)
        {
            Symbol unwrappedSymbol = ((symbol.Kind == SymbolKind.Alias) ? ((AliasSymbol)symbol).GetAliasTarget(basesBeingResolved) : symbol);
            if (!Compilation.SourceModule.Equals(unwrappedSymbol.ContainingModule) && unwrappedSymbol.IsHiddenByCodeAnalysisEmbeddedAttribute())
            {
                return LookupResult.Empty();
            }
            if (WrongArity(symbol, arity, diagnose, options, out var diagInfo))
            {
                return LookupResult.WrongArity(symbol, diagInfo);
            }
            if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)
            {
                diagInfo = (diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null);
                return LookupResult.NotReferencable(symbol, diagInfo);
            }
            if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))
            {
                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);
            }
            if ((options & LookupOptions.MustBeInvocableIfMember) != 0 && IsNonInvocableMember(unwrappedSymbol))
            {
                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);
            }
            if (InCref && !IsCrefAccessible(unwrappedSymbol))
            {
                ImmutableArray<Symbol> symbols = ImmutableArray.Create(unwrappedSymbol);
                object obj;
                if (!diagnose)
                {
                    obj = null;
                }
                else
                {
                    object[] args = new Symbol[1] { unwrappedSymbol };
                    obj = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, args, symbols, ImmutableArray<Location>.Empty);
                }
                diagInfo = (DiagnosticInfo)obj;
                return LookupResult.Inaccessible(symbol, diagInfo);
            }
            if (!InCref && !IsAccessible(unwrappedSymbol, RefineAccessThroughType(options, accessThroughType), out var failedThroughTypeCheck, ref useSiteInfo, basesBeingResolved))
            {
                if (!diagnose)
                {
                    diagInfo = null;
                }
                else if (failedThroughTypeCheck)
                {
                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, ContainingType);
                }
                else if (IsBadIvtSpecification())
                {
                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(Compilation.Assembly.PublicKey));
                }
                else
                {
                    object[] args = new Symbol[1] { unwrappedSymbol };
                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, args, ImmutableArray.Create(unwrappedSymbol), ImmutableArray<Location>.Empty);
                }
                return LookupResult.Inaccessible(symbol, diagInfo);
            }
            if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())
            {
                diagInfo = (diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null);
                return LookupResult.NotReferencable(symbol, diagInfo);
            }
            if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))
            {
                diagInfo = (diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null);
                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);
            }
            if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))
            {
                diagInfo = (diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null);
                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);
            }
            if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)
            {
                diagInfo = (diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null);
                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);
            }
            if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)
            {
                diagInfo = (diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null);
                return LookupResult.NotLabel(symbol, diagInfo);
            }
            return LookupResult.Good(symbol);
            bool IsBadIvtSpecification()
            {
                if ((unwrappedSymbol.DeclaredAccessibility == Accessibility.Internal || unwrappedSymbol.DeclaredAccessibility == Accessibility.ProtectedAndInternal || unwrappedSymbol.DeclaredAccessibility == Accessibility.ProtectedOrInternal) && !options.IsAttributeTypeLookup())
                {
                    string assemblyName = Compilation.AssemblyName;
                    if (assemblyName == null)
                    {
                        return false;
                    }
                    IEnumerable<ImmutableArray<byte>> internalsVisibleToPublicKeys = unwrappedSymbol.ContainingAssembly.GetInternalsVisibleToPublicKeys(assemblyName);
                    if (!internalsVisibleToPublicKeys.Any())
                    {
                        return false;
                    }
                    foreach (ImmutableArray<byte> item in internalsVisibleToPublicKeys)
                    {
                        if (item.SequenceEqual(Compilation.Assembly.Identity.PublicKey))
                        {
                            return false;
                        }
                    }
                    return true;
                }
                return false;
            }
        }

        private CSDiagnosticInfo MakeCallMethodsDirectlyDiagnostic(Symbol symbol)
        {
            MethodSymbol methodSymbol;
            MethodSymbol methodSymbol2;
            switch (symbol.Kind)
            {
                case SymbolKind.Property:
                    {
                        PropertySymbol leastOverriddenProperty = ((PropertySymbol)symbol).GetLeastOverriddenProperty(ContainingType);
                        methodSymbol = leastOverriddenProperty.GetMethod;
                        methodSymbol2 = leastOverriddenProperty.SetMethod;
                        break;
                    }
                case SymbolKind.Event:
                    {
                        EventSymbol leastOverriddenEvent = ((EventSymbol)symbol).GetLeastOverriddenEvent(ContainingType);
                        methodSymbol = leastOverriddenEvent.AddMethod;
                        methodSymbol2 = leastOverriddenEvent.RemoveMethod;
                        break;
                    }
                default:
                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);
            }
            if ((object)methodSymbol == null || (object)methodSymbol2 == null)
            {
                return new CSDiagnosticInfo(ErrorCode.ERR_BindToBogusProp1, symbol, methodSymbol ?? methodSymbol2);
            }
            return new CSDiagnosticInfo(ErrorCode.ERR_BindToBogusProp2, symbol, methodSymbol, methodSymbol2);
        }

        internal void CheckViability<TSymbol>(LookupResult result, ImmutableArray<TSymbol> symbols, int arity, LookupOptions options, TypeSymbol accessThroughType, bool diagnose, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, ConsList<TypeSymbol> basesBeingResolved) where TSymbol : Symbol
        {
            ImmutableArray<TSymbol>.Enumerator enumerator = symbols.GetEnumerator();
            while (enumerator.MoveNext())
            {
                TSymbol current = enumerator.Current;
                SingleLookupResult result2 = CheckViability(current, arity, options, accessThroughType, diagnose, ref useSiteInfo, basesBeingResolved);
                result.MergeEqual(result2);
            }
        }

        internal bool CanAddLookupSymbolInfo(Symbol symbol, LookupOptions options, LookupSymbolsInfo info, TypeSymbol accessThroughType, AliasSymbol aliasSymbol = null)
        {
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
            string name = ((aliasSymbol != null) ? aliasSymbol.Name : symbol.Name);
            if (!info.CanBeAdded(name))
            {
                return false;
            }
            if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(symbol is NamespaceOrTypeSymbol))
            {
                return false;
            }
            if ((options & LookupOptions.MustBeInvocableIfMember) != 0 && IsNonInvocableMember(symbol))
            {
                return false;
            }
            if (InCref ? (!IsCrefAccessible(symbol)) : (!IsAccessible(symbol, ref useSiteInfo, RefineAccessThroughType(options, accessThroughType))))
            {
                return false;
            }
            if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(symbol))
            {
                return false;
            }
            if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(symbol))
            {
                return false;
            }
            if ((options & LookupOptions.MustNotBeNamespace) != 0 && symbol.Kind == SymbolKind.Namespace)
            {
                return false;
            }
            return true;
        }

        private static TypeSymbol RefineAccessThroughType(LookupOptions options, TypeSymbol accessThroughType)
        {
            if ((options & LookupOptions.UseBaseReferenceAccessibility) == 0)
            {
                return accessThroughType;
            }
            return null;
        }

        private bool IsCrefAccessible(Symbol symbol)
        {
            if (IsEffectivelyPrivate(symbol))
            {
                return symbol.ContainingAssembly == Compilation.Assembly;
            }
            return true;
        }

        private static bool IsEffectivelyPrivate(Symbol symbol)
        {
            Symbol symbol2 = symbol;
            while ((object)symbol2 != null)
            {
                if (symbol2.DeclaredAccessibility == Accessibility.Private)
                {
                    return true;
                }
                symbol2 = symbol2.ContainingSymbol;
            }
            return false;
        }

        internal bool IsAccessible(Symbol symbol, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, TypeSymbol accessThroughType = null, ConsList<TypeSymbol> basesBeingResolved = null)
        {
            return IsAccessible(symbol, accessThroughType, out bool failedThroughTypeCheck, ref useSiteInfo, basesBeingResolved);
        }

        internal bool IsAccessible(Symbol symbol, TypeSymbol accessThroughType, out bool failedThroughTypeCheck, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, ConsList<TypeSymbol> basesBeingResolved = null)
        {
            if (Flags.Includes(BinderFlags.IgnoreAccessibility))
            {
                failedThroughTypeCheck = false;
                return true;
            }
            return IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteInfo, basesBeingResolved);
        }

        internal virtual bool IsAccessibleHelper(Symbol symbol, TypeSymbol accessThroughType, out bool failedThroughTypeCheck, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, ConsList<TypeSymbol> basesBeingResolved)
        {
            return Next!.IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteInfo, basesBeingResolved);
        }

        internal bool IsNonInvocableMember(Symbol symbol)
        {
            switch (symbol.Kind)
            {
                case SymbolKind.Event:
                case SymbolKind.Field:
                case SymbolKind.Method:
                case SymbolKind.NamedType:
                case SymbolKind.Property:
                    return !IsInvocableMember(symbol);
                default:
                    return false;
            }
        }

        private bool IsInvocableMember(Symbol symbol)
        {
            TypeSymbol typeSymbol = null;
            switch (symbol.Kind)
            {
                case SymbolKind.Event:
                case SymbolKind.Method:
                    return true;
                case SymbolKind.Field:
                    typeSymbol = ((FieldSymbol)symbol).GetFieldType(FieldsBeingBound).Type;
                    break;
                case SymbolKind.Property:
                    typeSymbol = ((PropertySymbol)symbol).Type;
                    break;
            }
            if ((object)typeSymbol != null)
            {
                if (!typeSymbol.IsDelegateType() && !typeSymbol.IsDynamic())
                {
                    return typeSymbol.IsFunctionPointer();
                }
                return true;
            }
            return false;
        }

        private static bool IsInstance(Symbol symbol)
        {
            SymbolKind kind = symbol.Kind;
            if ((uint)(kind - 5) <= 1u || kind == SymbolKind.Method || kind == SymbolKind.Property)
            {
                return symbol.RequiresInstanceReceiver();
            }
            return false;
        }

        private static bool WrongArity(Symbol symbol, int arity, bool diagnose, LookupOptions options, out DiagnosticInfo diagInfo)
        {
            switch (symbol.Kind)
            {
                case SymbolKind.NamedType:
                    {
                        if (arity == 0 && (options & LookupOptions.AllNamedTypesOnArityZero) != 0)
                        {
                            break;
                        }
                        NamedTypeSymbol namedTypeSymbol = (NamedTypeSymbol)symbol;
                        if (namedTypeSymbol.Arity != arity || (options.IsAttributeTypeLookup() && arity != 0))
                        {
                            if (namedTypeSymbol.Arity == 0)
                            {
                                diagInfo = (diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_HasNoTypeVars, namedTypeSymbol, MessageID.IDS_SK_TYPE.Localize()) : null);
                            }
                            else
                            {
                                diagInfo = (diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadArity, namedTypeSymbol, MessageID.IDS_SK_TYPE.Localize(), namedTypeSymbol.Arity) : null);
                            }
                            return true;
                        }
                        break;
                    }
                case SymbolKind.Method:
                    {
                        if (arity == 0 && (options & LookupOptions.AllMethodsOnArityZero) != 0)
                        {
                            break;
                        }
                        MethodSymbol methodSymbol = (MethodSymbol)symbol;
                        if (methodSymbol.Arity != arity)
                        {
                            if (methodSymbol.Arity == 0)
                            {
                                diagInfo = (diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_HasNoTypeVars, methodSymbol, MessageID.IDS_SK_METHOD.Localize()) : null);
                            }
                            else
                            {
                                diagInfo = (diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadArity, methodSymbol, MessageID.IDS_SK_METHOD.Localize(), methodSymbol.Arity) : null);
                            }
                            return true;
                        }
                        break;
                    }
                default:
                    if (arity != 0)
                    {
                        diagInfo = (diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_TypeArgsNotAllowed, symbol, symbol.Kind.Localize()) : null);
                        return true;
                    }
                    break;
            }
            diagInfo = null;
            return false;
        }

        internal void AddLookupSymbolsInfo(LookupSymbolsInfo result, LookupOptions options = LookupOptions.Default)
        {
            Binder binder = this;
            while (binder != null)
            {
                binder.AddLookupSymbolsInfoInSingleBinder(result, options, this);
                if ((options & LookupOptions.LabelsOnly) == 0 || !binder.IsLastBinderWithinMember())
                {
                    binder = binder.Next;
                    continue;
                }
                break;
            }
        }

        protected virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo info, LookupOptions options, Binder originalBinder)
        {
        }

        internal void AddMemberLookupSymbolsInfo(LookupSymbolsInfo result, NamespaceOrTypeSymbol nsOrType, LookupOptions options, Binder originalBinder)
        {
            if (nsOrType.IsNamespace)
            {
                AddMemberLookupSymbolsInfoInNamespace(result, (NamespaceSymbol)nsOrType, options, originalBinder);
            }
            else
            {
                AddMemberLookupSymbolsInfoInType(result, (TypeSymbol)nsOrType, options, originalBinder);
            }
        }

        private void AddMemberLookupSymbolsInfoInType(LookupSymbolsInfo result, TypeSymbol type, LookupOptions options, Binder originalBinder)
        {
            switch (type.TypeKind)
            {
                case TypeKind.TypeParameter:
                    AddMemberLookupSymbolsInfoInTypeParameter(result, (TypeParameterSymbol)type, options, originalBinder);
                    break;
                case TypeKind.Interface:
                    AddMemberLookupSymbolsInfoInInterface(result, type, options, originalBinder, type);
                    break;
                case TypeKind.Array:
                case TypeKind.Class:
                case TypeKind.Delegate:
                case TypeKind.Dynamic:
                case TypeKind.Enum:
                case TypeKind.Struct:
                case TypeKind.Submission:
                    AddMemberLookupSymbolsInfoInClass(result, type, options, originalBinder, type);
                    break;
                case TypeKind.Error:
                case TypeKind.Module:
                case TypeKind.Pointer:
                    break;
            }
        }

        protected void AddMemberLookupSymbolsInfoInSubmissions(LookupSymbolsInfo result, TypeSymbol scriptClass, bool inUsings, LookupOptions options, Binder originalBinder)
        {
            for (CSharpCompilation cSharpCompilation = Compilation; cSharpCompilation != null; cSharpCompilation = cSharpCompilation.PreviousSubmission)
            {
                if ((object)cSharpCompilation.ScriptClass != null)
                {
                    AddMemberLookupSymbolsInfoWithoutInheritance(result, cSharpCompilation.ScriptClass, options, originalBinder, scriptClass);
                }
                bool flag = cSharpCompilation == Compilation;
                if ((options & LookupOptions.LabelsOnly) == 0 && !(flag && inUsings))
                {
                    Imports imports = cSharpCompilation.GetSubmissionImports();
                    if (!flag)
                    {
                        imports = Imports.ExpandPreviousSubmissionImports(imports, Compilation);
                    }
                    AddLookupSymbolsInfoInAliases(imports.UsingAliases, imports.ExternAliases, result, options, originalBinder);
                }
            }
        }

        protected void AddLookupSymbolsInfoInAliases(ImmutableDictionary<string, AliasAndUsingDirective> usingAliases, ImmutableArray<AliasAndExternAliasDirective> externAliases, LookupSymbolsInfo result, LookupOptions options, Binder originalBinder)
        {
            if ((options & LookupOptions.LabelsOnly) != 0)
            {
                return;
            }
            foreach (KeyValuePair<string, AliasAndUsingDirective> usingAlias in usingAliases)
            {
                addAliasSymbolToResult(result, usingAlias.Value.Alias, options, originalBinder);
            }
            ImmutableArray<AliasAndExternAliasDirective>.Enumerator enumerator2 = externAliases.GetEnumerator();
            while (enumerator2.MoveNext())
            {
                AliasAndExternAliasDirective current = enumerator2.Current;
                if (!current.SkipInLookup)
                {
                    addAliasSymbolToResult(result, current.Alias, options, originalBinder);
                }
            }
            static void addAliasSymbolToResult(LookupSymbolsInfo result, AliasSymbol aliasSymbol, LookupOptions options, Binder originalBinder)
            {
                NamespaceOrTypeSymbol aliasTarget = aliasSymbol.GetAliasTarget(null);
                if (originalBinder.CanAddLookupSymbolInfo(aliasTarget, options, result, null, aliasSymbol))
                {
                    result.AddSymbol(aliasSymbol, aliasSymbol.Name, 0);
                }
            }
        }

        private static void AddMemberLookupSymbolsInfoInNamespace(LookupSymbolsInfo result, NamespaceSymbol ns, LookupOptions options, Binder originalBinder)
        {
            ImmutableArray<Symbol>.Enumerator enumerator = ((result.FilterName != null) ? GetCandidateMembers(ns, result.FilterName, options, originalBinder) : GetCandidateMembers(ns, options, originalBinder)).GetEnumerator();
            while (enumerator.MoveNext())
            {
                Symbol current = enumerator.Current;
                if (originalBinder.CanAddLookupSymbolInfo(current, options, result, null))
                {
                    result.AddSymbol(current, current.Name, current.GetArity());
                }
            }
        }

        private static void AddMemberLookupSymbolsInfoWithoutInheritance(LookupSymbolsInfo result, TypeSymbol type, LookupOptions options, Binder originalBinder, TypeSymbol accessThroughType)
        {
            ImmutableArray<Symbol>.Enumerator enumerator = ((result.FilterName != null) ? GetCandidateMembers(type, result.FilterName, options, originalBinder) : GetCandidateMembers(type, options, originalBinder)).GetEnumerator();
            while (enumerator.MoveNext())
            {
                Symbol current = enumerator.Current;
                if (originalBinder.CanAddLookupSymbolInfo(current, options, result, accessThroughType))
                {
                    result.AddSymbol(current, current.Name, current.GetArity());
                }
            }
        }

        private void AddWinRTMembersLookupSymbolsInfo(LookupSymbolsInfo result, NamedTypeSymbol type, LookupOptions options, Binder originalBinder, TypeSymbol accessThroughType)
        {
            GetWellKnownWinRTMemberInterfaces(out var idictSymbol, out var iroDictSymbol, out var iListSymbol, out var iCollectionSymbol, out var inccSymbol, out var inpcSymbol);
            ImmutableArray<NamedTypeSymbol>.Enumerator enumerator = type.AllInterfacesNoUseSiteDiagnostics.GetEnumerator();
            while (enumerator.MoveNext())
            {
                NamedTypeSymbol current = enumerator.Current;
                if (ShouldAddWinRTMembersForInterface(current, idictSymbol, iroDictSymbol, iListSymbol, iCollectionSymbol, inccSymbol, inpcSymbol))
                {
                    AddMemberLookupSymbolsInfoWithoutInheritance(result, current, options, originalBinder, accessThroughType);
                }
            }
        }

        private void AddMemberLookupSymbolsInfoInClass(LookupSymbolsInfo result, TypeSymbol type, LookupOptions options, Binder originalBinder, TypeSymbol accessThroughType)
        {
            PooledHashSet<NamedTypeSymbol> visited = null;
            while ((object)type != null && !type.IsVoidType())
            {
                AddMemberLookupSymbolsInfoWithoutInheritance(result, type, options, originalBinder, accessThroughType);
                if (type is NamedTypeSymbol namedTypeSymbol && namedTypeSymbol.ShouldAddWinRTMembers)
                {
                    AddWinRTMembersLookupSymbolsInfo(result, namedTypeSymbol, options, originalBinder, accessThroughType);
                }
                if (originalBinder.InCrefButNotParameterOrReturnType)
                {
                    break;
                }
                type = type.GetNextBaseTypeNoUseSiteDiagnostics(null, Compilation, ref visited);
            }
            visited?.Free();
        }

        private void AddMemberLookupSymbolsInfoInInterface(LookupSymbolsInfo result, TypeSymbol type, LookupOptions options, Binder originalBinder, TypeSymbol accessThroughType)
        {
            AddMemberLookupSymbolsInfoWithoutInheritance(result, type, options, originalBinder, accessThroughType);
            if (!originalBinder.InCrefButNotParameterOrReturnType)
            {
                ImmutableArray<NamedTypeSymbol>.Enumerator enumerator = type.AllInterfacesNoUseSiteDiagnostics.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    NamedTypeSymbol current = enumerator.Current;
                    AddMemberLookupSymbolsInfoWithoutInheritance(result, current, options, originalBinder, accessThroughType);
                }
                AddMemberLookupSymbolsInfoInClass(result, Compilation.GetSpecialType(SpecialType.System_Object), options, originalBinder, accessThroughType);
            }
        }

        private void AddMemberLookupSymbolsInfoInTypeParameter(LookupSymbolsInfo result, TypeParameterSymbol type, LookupOptions options, Binder originalBinder)
        {
            if (type.TypeParameterKind != TypeParameterKind.Cref)
            {
                NamedTypeSymbol effectiveBaseClassNoUseSiteDiagnostics = type.EffectiveBaseClassNoUseSiteDiagnostics;
                AddMemberLookupSymbolsInfoInClass(result, effectiveBaseClassNoUseSiteDiagnostics, options, originalBinder, effectiveBaseClassNoUseSiteDiagnostics);
                ImmutableArray<NamedTypeSymbol>.Enumerator enumerator = type.AllEffectiveInterfacesNoUseSiteDiagnostics.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    NamedTypeSymbol current = enumerator.Current;
                    AddMemberLookupSymbolsInfoWithoutInheritance(result, current, options, originalBinder, type);
                }
            }
        }

        private bool ValidateLambdaParameterNameConflictsInScope(Location location, string name, BindingDiagnosticBag diagnostics)
        {
            return ValidateNameConflictsInScope(null, location, name, diagnostics);
        }

        internal bool ValidateDeclarationNameConflictsInScope(Symbol symbol, BindingDiagnosticBag diagnostics)
        {
            Location location = GetLocation(symbol);
            return ValidateNameConflictsInScope(symbol, location, symbol.Name, diagnostics);
        }

        private static Location GetLocation(Symbol symbol)
        {
            ImmutableArray<Location> locations = symbol.Locations;
            if (locations.Length == 0)
            {
                return symbol.ContainingSymbol.Locations[0];
            }
            return locations[0];
        }

        internal void ValidateParameterNameConflicts(ImmutableArray<TypeParameterSymbol> typeParameters, ImmutableArray<ParameterSymbol> parameters, bool allowShadowingNames, BindingDiagnosticBag diagnostics)
        {
            PooledHashSet<string> pooledHashSet = null;
            if (!typeParameters.IsDefaultOrEmpty)
            {
                pooledHashSet = PooledHashSet<string>.GetInstance();
                ImmutableArray<TypeParameterSymbol>.Enumerator enumerator = typeParameters.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    TypeParameterSymbol current = enumerator.Current;
                    string name = current.Name;
                    if (!string.IsNullOrEmpty(name) && pooledHashSet.Add(name) && !allowShadowingNames)
                    {
                        ValidateDeclarationNameConflictsInScope(current, diagnostics);
                    }
                }
            }
            PooledHashSet<string> pooledHashSet2 = null;
            if (!parameters.IsDefaultOrEmpty)
            {
                pooledHashSet2 = PooledHashSet<string>.GetInstance();
                ImmutableArray<ParameterSymbol>.Enumerator enumerator2 = parameters.GetEnumerator();
                while (enumerator2.MoveNext())
                {
                    ParameterSymbol current2 = enumerator2.Current;
                    string name2 = current2.Name;
                    if (!string.IsNullOrEmpty(name2))
                    {
                        if (pooledHashSet != null && pooledHashSet.Contains(name2))
                        {
                            diagnostics.Add(ErrorCode.ERR_LocalSameNameAsTypeParam, GetLocation(current2), name2);
                        }
                        if (!pooledHashSet2.Add(name2))
                        {
                            diagnostics.Add(ErrorCode.ERR_DuplicateParamName, GetLocation(current2), name2);
                        }
                        else if (!allowShadowingNames)
                        {
                            ValidateDeclarationNameConflictsInScope(current2, diagnostics);
                        }
                    }
                }
            }
            pooledHashSet?.Free();
            pooledHashSet2?.Free();
        }

        private bool ValidateNameConflictsInScope(Symbol? symbol, Location location, string name, BindingDiagnosticBag diagnostics)
        {
            if (string.IsNullOrEmpty(name))
            {
                return false;
            }
            bool flag = Compilation.IsFeatureEnabled(MessageID.IDS_FeatureNameShadowingInNestedFunctions);
            for (Binder binder = this; binder != null; binder = binder.Next)
            {
                if (binder is InContainerBinder)
                {
                    return false;
                }
                LocalScopeBinder obj = binder as LocalScopeBinder;
                if (obj != null && obj.EnsureSingleDefinition(symbol, name, location, diagnostics))
                {
                    return true;
                }
                if (flag && binder.IsNestedFunctionBinder)
                {
                    return false;
                }
                if (binder.IsLastBinderWithinMember())
                {
                    return false;
                }
            }
            return false;
        }

        private bool IsLastBinderWithinMember()
        {
            Symbol containingMemberOrLambda = ContainingMemberOrLambda;
            SymbolKind? symbolKind = containingMemberOrLambda?.Kind;
            if (symbolKind.HasValue)
            {
                SymbolKind valueOrDefault = symbolKind.GetValueOrDefault();
                if ((uint)(valueOrDefault - 11) > 1u)
                {
                    Symbol containingSymbol = containingMemberOrLambda.ContainingSymbol;
                    if ((object)containingSymbol != null && containingSymbol.Kind == SymbolKind.NamedType)
                    {
                        return Next?.ContainingMemberOrLambda != containingMemberOrLambda;
                    }
                    return false;
                }
            }
            return true;
        }

        private BoundExpression BindCompoundAssignment(AssignmentExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            node.Left.CheckDeconstructionCompatibleArgument(diagnostics);
            BoundExpression boundExpression = BindValue(node.Left, diagnostics, GetBinaryAssignmentKind(node.Kind()));
            ReportSuppressionIfNeeded(boundExpression, diagnostics);
            BoundExpression boundExpression2 = BindValue(node.Right, diagnostics, BindValueKind.RValue);
            BinaryOperatorKind kind = SyntaxKindToBinaryOperatorKind(node.Kind());
            if (boundExpression.Kind == BoundKind.EventAccess)
            {
                BinaryOperatorKind binaryOperatorKind = kind.Operator();
                if (binaryOperatorKind == BinaryOperatorKind.Addition || binaryOperatorKind == BinaryOperatorKind.Subtraction)
                {
                    return BindEventAssignment(node, (BoundEventAccess)boundExpression, boundExpression2, binaryOperatorKind, diagnostics);
                }
            }
            if (boundExpression.HasAnyErrors || boundExpression2.HasAnyErrors)
            {
                boundExpression = BindToTypeForErrorRecovery(boundExpression);
                boundExpression2 = BindToTypeForErrorRecovery(boundExpression2);
                return new BoundCompoundAssignmentOperator(node, BinaryOperatorSignature.Error, boundExpression, boundExpression2, Conversion.NoConversion, Conversion.NoConversion, LookupResultKind.Empty, CreateErrorType(), hasErrors: true);
            }
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            if (boundExpression.HasDynamicType() || boundExpression2.HasDynamicType())
            {
                if (IsLegalDynamicOperand(boundExpression2) && IsLegalDynamicOperand(boundExpression))
                {
                    boundExpression = BindToNaturalType(boundExpression, diagnostics);
                    boundExpression2 = BindToNaturalType(boundExpression2, diagnostics);
                    Conversion finalConversion = Compilation.Conversions.ClassifyConversionFromExpression(boundExpression2, boundExpression.Type, ref useSiteInfo);
                    diagnostics.Add(node, useSiteInfo);
                    return new BoundCompoundAssignmentOperator(node, new BinaryOperatorSignature(kind.WithType(BinaryOperatorKind.Dynamic).WithOverflowChecksIfApplicable(CheckOverflowAtRuntime), boundExpression.Type, boundExpression2.Type, Compilation.DynamicType), boundExpression, boundExpression2, Conversion.NoConversion, finalConversion, LookupResultKind.Viable, boundExpression.Type);
                }
                Error(diagnostics, ErrorCode.ERR_BadBinaryOps, node, node.OperatorToken.Text, boundExpression.Display, boundExpression2.Display);
                boundExpression = BindToTypeForErrorRecovery(boundExpression);
                boundExpression2 = BindToTypeForErrorRecovery(boundExpression2);
                return new BoundCompoundAssignmentOperator(node, BinaryOperatorSignature.Error, boundExpression, boundExpression2, Conversion.NoConversion, Conversion.NoConversion, LookupResultKind.Empty, CreateErrorType(), hasErrors: true);
            }
            if (boundExpression.Kind == BoundKind.EventAccess && !CheckEventValueKind((BoundEventAccess)boundExpression, BindValueKind.Assignable, diagnostics))
            {
                boundExpression = BindToTypeForErrorRecovery(boundExpression);
                boundExpression2 = BindToTypeForErrorRecovery(boundExpression2);
                return new BoundCompoundAssignmentOperator(node, BinaryOperatorSignature.Error, boundExpression, boundExpression2, Conversion.NoConversion, Conversion.NoConversion, LookupResultKind.NotAVariable, CreateErrorType(), hasErrors: true);
            }
            BinaryOperatorAnalysisResult binaryOperatorAnalysisResult = BinaryOperatorOverloadResolution(kind, boundExpression, boundExpression2, node, diagnostics, out LookupResultKind resultKind, out ImmutableArray<MethodSymbol> originalUserDefinedOperators);
            if (!binaryOperatorAnalysisResult.HasValue)
            {
                ReportAssignmentOperatorError(node, diagnostics, boundExpression, boundExpression2, resultKind);
                boundExpression = BindToTypeForErrorRecovery(boundExpression);
                boundExpression2 = BindToTypeForErrorRecovery(boundExpression2);
                return new BoundCompoundAssignmentOperator(node, BinaryOperatorSignature.Error, boundExpression, boundExpression2, Conversion.NoConversion, Conversion.NoConversion, resultKind, originalUserDefinedOperators, CreateErrorType(), hasErrors: true);
            }
            bool flag = false;
            BinaryOperatorSignature @operator = binaryOperatorAnalysisResult.Signature;
            CheckNativeIntegerFeatureAvailability(@operator.Kind, node, diagnostics);
            if (CheckOverflowAtRuntime)
            {
                @operator = new BinaryOperatorSignature(@operator.Kind.WithOverflowChecksIfApplicable(CheckOverflowAtRuntime), @operator.LeftType, @operator.RightType, @operator.ReturnType, @operator.Method);
            }
            BoundExpression right = CreateConversion(boundExpression2, binaryOperatorAnalysisResult.RightConversion, @operator.RightType, diagnostics);
            TypeSymbol type = boundExpression.Type;
            Conversion conversion = Conversions.ClassifyConversionFromExpressionType(@operator.ReturnType, type, ref useSiteInfo);
            bool flag2 = !@operator.Kind.IsUserDefined();
            if (!conversion.IsValid || (conversion.IsExplicit && !flag2))
            {
                flag = true;
                GenerateImplicitConversionError(diagnostics, Compilation, node, conversion, @operator.ReturnType, type);
            }
            else
            {
                ReportDiagnosticsIfObsolete(diagnostics, conversion, node, hasBaseReceiver: false);
            }
            if (conversion.IsExplicit && flag2 && !kind.IsShift())
            {
                Conversion conversion2 = Conversions.ClassifyConversionFromExpression(boundExpression2, type, ref useSiteInfo);
                if (!conversion2.IsImplicit || !conversion2.IsValid)
                {
                    flag = true;
                    GenerateImplicitConversionError(diagnostics, node, conversion2, boundExpression2, type);
                }
            }
            diagnostics.Add(node, useSiteInfo);
            if (!flag && type.IsVoidPointer())
            {
                Error(diagnostics, ErrorCode.ERR_VoidError, node);
                flag = true;
            }
            Conversion leftConversion = binaryOperatorAnalysisResult.LeftConversion;
            ReportDiagnosticsIfObsolete(diagnostics, leftConversion, node, hasBaseReceiver: false);
            return new BoundCompoundAssignmentOperator(node, @operator, boundExpression, right, leftConversion, conversion, resultKind, originalUserDefinedOperators, type, flag);
        }

        private BoundExpression BindEventAssignment(AssignmentExpressionSyntax node, BoundEventAccess left, BoundExpression right, BinaryOperatorKind opKind, BindingDiagnosticBag diagnostics)
        {
            bool hasErrors = false;
            EventSymbol eventSymbol = left.EventSymbol;
            BoundExpression receiverOpt = left.ReceiverOpt;
            TypeSymbol type = left.Type;
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            Conversion conversion = Conversions.ClassifyConversionFromExpression(right, type, ref useSiteInfo);
            if (!conversion.IsImplicit || !conversion.IsValid)
            {
                hasErrors = true;
                if (type.IsDelegateType())
                {
                    GenerateImplicitConversionError(diagnostics, node, conversion, right, type);
                }
            }
            BoundExpression argument = CreateConversion(right, conversion, type, diagnostics);
            bool flag = opKind == BinaryOperatorKind.Addition;
            MethodSymbol methodSymbol = (flag ? eventSymbol.AddMethod : eventSymbol.RemoveMethod);
            TypeSymbol type2;
            if ((object)methodSymbol == null)
            {
                type2 = GetSpecialType(SpecialType.System_Void, diagnostics, node);
                if (!eventSymbol.OriginalDefinition.IsFromCompilation(Compilation))
                {
                    Error(diagnostics, ErrorCode.ERR_MissingPredefinedMember, node, type, SourceEventSymbol.GetAccessorName(eventSymbol.Name, flag));
                }
            }
            else
            {
                CheckImplicitThisCopyInReadOnlyMember(receiverOpt, methodSymbol, diagnostics);
                if (!IsAccessible(methodSymbol, ref useSiteInfo, GetAccessThroughType(receiverOpt)))
                {
                    Error(diagnostics, ErrorCode.ERR_BadAccess, node, methodSymbol);
                    hasErrors = true;
                }
                else if (IsBadBaseAccess(node, receiverOpt, methodSymbol, diagnostics, eventSymbol))
                {
                    hasErrors = true;
                }
                else
                {
                    CheckRuntimeSupportForSymbolAccess(node, receiverOpt, methodSymbol, diagnostics);
                }
                type2 = ((!eventSymbol.IsWindowsRuntimeEvent) ? methodSymbol.ReturnType : GetSpecialType(SpecialType.System_Void, diagnostics, node));
            }
            diagnostics.Add(node, useSiteInfo);
            return new BoundEventAssignmentOperator(node, eventSymbol, flag, right.HasDynamicType(), receiverOpt, argument, type2, hasErrors);
        }

        private static bool IsLegalDynamicOperand(BoundExpression operand)
        {
            TypeSymbol type = operand.Type;
            if ((object)type == null)
            {
                return operand.IsLiteralNull();
            }
            if (!type.IsPointerOrFunctionPointer() && !type.IsRestrictedType())
            {
                return !type.IsVoidType();
            }
            return false;
        }

        private BoundExpression BindDynamicBinaryOperator(BinaryExpressionSyntax node, BinaryOperatorKind kind, BoundExpression left, BoundExpression right, BindingDiagnosticBag diagnostics)
        {
            bool flag = false;
            bool flag2 = IsLegalDynamicOperand(left);
            bool flag3 = IsLegalDynamicOperand(right);
            if (!flag2 || !flag3)
            {
                Error(diagnostics, ErrorCode.ERR_BadBinaryOps, node, node.OperatorToken.Text, left.Display, right.Display);
                flag = true;
            }
            MethodSymbol userDefinedOperator = null;
            if (kind.IsLogical() && flag2)
            {
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                if (!IsValidDynamicCondition(left, kind == BinaryOperatorKind.LogicalAnd, ref useSiteInfo, out userDefinedOperator))
                {
                    Error(diagnostics, ErrorCode.ERR_InvalidDynamicCondition, node.Left, left.Type, (kind == BinaryOperatorKind.LogicalAnd) ? "false" : "true");
                    flag = true;
                }
                diagnostics.Add(node, useSiteInfo);
            }
            return new BoundBinaryOperator(node, (flag ? kind : kind.WithType(BinaryOperatorKind.Dynamic)).WithOverflowChecksIfApplicable(CheckOverflowAtRuntime), null, left: BindToNaturalType(left, diagnostics), right: BindToNaturalType(right, diagnostics), methodOpt: userDefinedOperator, resultKind: LookupResultKind.Viable, type: Compilation.DynamicType, hasErrors: flag);
        }

        protected static bool IsSimpleBinaryOperator(SyntaxKind kind)
        {
            if (kind - 8668 <= (SyntaxKind)6 || kind - 8677 <= (SyntaxKind)8)
            {
                return true;
            }
            return false;
        }

        private BoundExpression BindSimpleBinaryOperator(BinaryExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            ArrayBuilder<BinaryExpressionSyntax> instance = ArrayBuilder<BinaryExpressionSyntax>.GetInstance();
            ExpressionSyntax expressionSyntax = node;
            while (IsSimpleBinaryOperator(expressionSyntax.Kind()))
            {
                BinaryExpressionSyntax binaryExpressionSyntax = (BinaryExpressionSyntax)expressionSyntax;
                instance.Push(binaryExpressionSyntax);
                expressionSyntax = binaryExpressionSyntax.Left;
            }
            BoundExpression boundExpression = BindExpression(expressionSyntax, diagnostics);
            if (node.IsKind(SyntaxKind.SubtractExpression) && expressionSyntax.IsKind(SyntaxKind.ParenthesizedExpression))
            {
                if (boundExpression.Kind == BoundKind.TypeExpression && !((ParenthesizedExpressionSyntax)expressionSyntax).Expression.IsKind(SyntaxKind.ParenthesizedExpression))
                {
                    Error(diagnostics, ErrorCode.ERR_PossibleBadNegCast, node);
                }
                else if (boundExpression.Kind == BoundKind.BadExpression)
                {
                    ParenthesizedExpressionSyntax parenthesizedExpressionSyntax = (ParenthesizedExpressionSyntax)expressionSyntax;
                    if (parenthesizedExpressionSyntax.Expression.IsKind(SyntaxKind.IdentifierName) && ((IdentifierNameSyntax)parenthesizedExpressionSyntax.Expression).Identifier.ValueText == "dynamic")
                    {
                        Error(diagnostics, ErrorCode.ERR_PossibleBadNegCast, node);
                    }
                }
            }
            while (instance.Count > 0)
            {
                BinaryExpressionSyntax binaryExpressionSyntax2 = instance.Pop();
                BindValueKind binaryAssignmentKind = GetBinaryAssignmentKind(binaryExpressionSyntax2.Kind());
                BoundExpression left = CheckValue(boundExpression, binaryAssignmentKind, diagnostics);
                BoundExpression right = BindValue(binaryExpressionSyntax2.Right, diagnostics, BindValueKind.RValue);
                boundExpression = BindSimpleBinaryOperator(binaryExpressionSyntax2, diagnostics, left, right);
            }
            instance.Free();
            return boundExpression;
        }

        private BoundExpression BindSimpleBinaryOperator(BinaryExpressionSyntax node, BindingDiagnosticBag diagnostics, BoundExpression left, BoundExpression right)
        {
            BinaryOperatorKind binaryOperatorKind = SyntaxKindToBinaryOperatorKind(node.Kind());
            if (left.HasAnyErrors || right.HasAnyErrors)
            {
                left = BindToTypeForErrorRecovery(left);
                right = BindToTypeForErrorRecovery(right);
                return new BoundBinaryOperator(node, binaryOperatorKind, null, null, LookupResultKind.Empty, left, right, GetBinaryOperatorErrorType(binaryOperatorKind, diagnostics, node), hasErrors: true);
            }
            TypeSymbol type = left.Type;
            TypeSymbol type2 = right.Type;
            if (((object)type != null && type.IsDynamic()) || ((object)type2 != null && type2.IsDynamic()))
            {
                return BindDynamicBinaryOperator(node, binaryOperatorKind, left, right, diagnostics);
            }
            bool flag = left.IsLiteralNull();
            bool flag2 = right.IsLiteralNull();
            if ((binaryOperatorKind == BinaryOperatorKind.Equal || binaryOperatorKind == BinaryOperatorKind.NotEqual) && flag && flag2)
            {
                return new BoundLiteral(node, ConstantValue.Create(binaryOperatorKind == BinaryOperatorKind.Equal), GetSpecialType(SpecialType.System_Boolean, diagnostics, node));
            }
            if (IsTupleBinaryOperation(left, right) && (binaryOperatorKind == BinaryOperatorKind.Equal || binaryOperatorKind == BinaryOperatorKind.NotEqual))
            {
                CheckFeatureAvailability(node, MessageID.IDS_FeatureTupleEquality, diagnostics);
                return BindTupleBinaryOperator(node, binaryOperatorKind, left, right, diagnostics);
            }
            bool flag3 = BindSimpleBinaryOperatorParts(node, diagnostics, left, right, binaryOperatorKind, out LookupResultKind resultKind, out ImmutableArray<MethodSymbol> originalUserDefinedOperators, out BinaryOperatorSignature resultSignature, out BinaryOperatorAnalysisResult best);
            BinaryOperatorKind binaryOperatorKind2 = resultSignature.Kind;
            bool flag4 = false;
            if (!flag3)
            {
                ReportBinaryOperatorError(node, diagnostics, node.OperatorToken, left, right, resultKind);
                binaryOperatorKind2 &= ~BinaryOperatorKind.TypeMask;
                flag4 = true;
            }
            SyntaxKind syntaxKind = node.Kind();
            if (syntaxKind - 8680 <= (SyntaxKind)5)
            {
                if ((binaryOperatorKind2 & BinaryOperatorKind.Pointer) == BinaryOperatorKind.Pointer && (object)type != null && type.TypeKind == TypeKind.FunctionPointer && (object)type2 != null && type2.TypeKind == TypeKind.FunctionPointer)
                {
                    Error(diagnostics, ErrorCode.WRN_DoNotCompareFunctionPointers, node.OperatorToken);
                }
            }
            else if (type.IsVoidPointer() || type2.IsVoidPointer())
            {
                Error(diagnostics, ErrorCode.ERR_VoidError, node);
                flag4 = true;
            }
            CheckNativeIntegerFeatureAvailability(binaryOperatorKind2, node, diagnostics);
            TypeSymbol returnType = resultSignature.ReturnType;
            BoundExpression expression = left;
            BoundExpression expression2 = right;
            ConstantValue constantValue = null;
            if (flag3 && binaryOperatorKind2.OperandTypes() != BinaryOperatorKind.NullableNull)
            {
                expression = CreateConversion(left, best.LeftConversion, resultSignature.LeftType, diagnostics);
                expression2 = CreateConversion(right, best.RightConversion, resultSignature.RightType, diagnostics);
                constantValue = FoldBinaryOperator(node, binaryOperatorKind2, expression, expression2, returnType.SpecialType, diagnostics);
            }
            else
            {
                expression = BindToNaturalType(expression, diagnostics, reportNoTargetType: false);
                expression2 = BindToNaturalType(expression2, diagnostics, reportNoTargetType: false);
            }
            flag4 = flag4 || (constantValue != null && constantValue.IsBad);
            return new BoundBinaryOperator(node, binaryOperatorKind2.WithOverflowChecksIfApplicable(CheckOverflowAtRuntime), expression, expression2, constantValue, resultSignature.Method, resultKind, originalUserDefinedOperators, returnType, flag4);
        }

        private bool BindSimpleBinaryOperatorParts(BinaryExpressionSyntax node, BindingDiagnosticBag diagnostics, BoundExpression left, BoundExpression right, BinaryOperatorKind kind, out LookupResultKind resultKind, out ImmutableArray<MethodSymbol> originalUserDefinedOperators, out BinaryOperatorSignature resultSignature, out BinaryOperatorAnalysisResult best)
        {
            best = BinaryOperatorOverloadResolution(kind, left, right, node, diagnostics, out resultKind, out originalUserDefinedOperators);
            bool result;
            if (!best.HasValue)
            {
                resultSignature = new BinaryOperatorSignature(kind, null, null, CreateErrorType());
                result = false;
            }
            else
            {
                BinaryOperatorSignature signature = best.Signature;
                bool flag = signature.Kind == BinaryOperatorKind.ObjectEqual || signature.Kind == BinaryOperatorKind.ObjectNotEqual;
                bool flag2 = left.IsLiteralNull();
                bool flag3 = right.IsLiteralNull();
                TypeSymbol type = left.Type;
                TypeSymbol type2 = right.Type;
                if ((object)signature.Method == null && (signature.Kind.Operator() == BinaryOperatorKind.Equal || signature.Kind.Operator() == BinaryOperatorKind.NotEqual) && ((flag2 && (object)type2 != null && type2.IsNullableType()) || (flag3 && (object)type != null && type.IsNullableType())))
                {
                    resultSignature = new BinaryOperatorSignature(kind | BinaryOperatorKind.NullableNull, null, null, GetSpecialType(SpecialType.System_Boolean, diagnostics, node));
                    result = true;
                }
                else
                {
                    resultSignature = signature;
                    CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                    bool leftIsDefault = left.IsLiteralDefault();
                    bool rightIsDefault = right.IsLiteralDefault();
                    result = !flag || BuiltInOperators.IsValidObjectEquality(Conversions, type, flag2, leftIsDefault, type2, flag3, rightIsDefault, ref useSiteInfo);
                    diagnostics.Add(node, useSiteInfo);
                }
            }
            return result;
        }

        private static void ReportUnaryOperatorError(CSharpSyntaxNode node, BindingDiagnosticBag diagnostics, string operatorName, BoundExpression operand, LookupResultKind resultKind)
        {
            if (!operand.IsLiteralDefault())
            {
                ErrorCode code = ((resultKind == LookupResultKind.Ambiguous) ? ErrorCode.ERR_AmbigUnaryOp : ErrorCode.ERR_BadUnaryOp);
                Error(diagnostics, code, node, operatorName, operand.Display);
            }
        }

        private void ReportAssignmentOperatorError(AssignmentExpressionSyntax node, BindingDiagnosticBag diagnostics, BoundExpression left, BoundExpression right, LookupResultKind resultKind)
        {
            if (((ushort)node.OperatorToken.RawKind == 8280 || (ushort)node.OperatorToken.RawKind == 8281) && (object)left.Type != null && left.Type!.TypeKind == TypeKind.Delegate)
            {
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
                Conversion conversion = Conversions.ClassifyConversionFromExpression(right, left.Type, ref useSiteInfo);
                GenerateImplicitConversionError(diagnostics, right.Syntax, conversion, right, left.Type);
            }
            else
            {
                ReportBinaryOperatorError(node, diagnostics, node.OperatorToken, left, right, resultKind);
            }
        }

        private static void ReportBinaryOperatorError(ExpressionSyntax node, BindingDiagnosticBag diagnostics, SyntaxToken operatorToken, BoundExpression left, BoundExpression right, LookupResultKind resultKind)
        {
            bool isEquality = operatorToken.Kind() == SyntaxKind.EqualsEqualsToken || operatorToken.Kind() == SyntaxKind.ExclamationEqualsToken;
            switch (left.Kind, right.Kind)
            {
                case (BoundKind.DefaultLiteral, _) when !isEquality:
                case (_, BoundKind.DefaultLiteral) when !isEquality:
                    // other than == and !=, binary operators are disallowed on `default` literal
                    Error(diagnostics, ErrorCode.ERR_BadOpOnNullOrDefaultOrNew, node, operatorToken.Text, "default");
                    return;
                case (BoundKind.DefaultLiteral, BoundKind.DefaultLiteral):
                    Error(diagnostics, ErrorCode.ERR_AmbigBinaryOpsOnDefault, node, operatorToken.Text, left.Display, right.Display);
                    return;
                case (BoundKind.DefaultLiteral, _) when right.Type is TypeParameterSymbol:
                    Debug.Assert(!right.Type.IsReferenceType);
                    Error(diagnostics, ErrorCode.ERR_AmbigBinaryOpsOnUnconstrainedDefault, node, operatorToken.Text, right.Type);
                    return;
                case (_, BoundKind.DefaultLiteral) when left.Type is TypeParameterSymbol:
                    Debug.Assert(!left.Type.IsReferenceType);
                    Error(diagnostics, ErrorCode.ERR_AmbigBinaryOpsOnUnconstrainedDefault, node, operatorToken.Text, left.Type);
                    return;
                case (BoundKind.UnconvertedObjectCreationExpression, _):
                    Error(diagnostics, ErrorCode.ERR_BadOpOnNullOrDefaultOrNew, node, operatorToken.Text, left.Display);
                    return;
                case (_, BoundKind.UnconvertedObjectCreationExpression):
                    Error(diagnostics, ErrorCode.ERR_BadOpOnNullOrDefaultOrNew, node, operatorToken.Text, right.Display);
                    return;
            }

            ErrorCode errorCode = resultKind == LookupResultKind.Ambiguous ?
                ErrorCode.ERR_AmbigBinaryOps : // Operator '{0}' is ambiguous on operands of type '{1}' and '{2}'
                ErrorCode.ERR_BadBinaryOps;    // Operator '{0}' cannot be applied to operands of type '{1}' and '{2}'

            Error(diagnostics, errorCode, node, operatorToken.Text, left.Display, right.Display);
        }

        private BoundExpression BindConditionalLogicalOperator(BinaryExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            BinaryExpressionSyntax binaryExpressionSyntax = node;
            ExpressionSyntax expressionSyntax;
            while (true)
            {
                expressionSyntax = binaryExpressionSyntax.Left;
                if (!(expressionSyntax is BinaryExpressionSyntax binaryExpressionSyntax2) || (binaryExpressionSyntax2.Kind() != SyntaxKind.LogicalOrExpression && binaryExpressionSyntax2.Kind() != SyntaxKind.LogicalAndExpression))
                {
                    break;
                }
                binaryExpressionSyntax = binaryExpressionSyntax2;
            }
            BoundExpression boundExpression = BindRValueWithoutTargetType(expressionSyntax, diagnostics);
            do
            {
                binaryExpressionSyntax = (BinaryExpressionSyntax)expressionSyntax.Parent;
                BoundExpression right = BindRValueWithoutTargetType(binaryExpressionSyntax.Right, diagnostics);
                boundExpression = BindConditionalLogicalOperator(binaryExpressionSyntax, boundExpression, right, diagnostics);
                expressionSyntax = binaryExpressionSyntax;
            }
            while (expressionSyntax != node);
            return boundExpression;
        }

        private BoundExpression BindConditionalLogicalOperator(BinaryExpressionSyntax node, BoundExpression left, BoundExpression right, BindingDiagnosticBag diagnostics)
        {
            BinaryOperatorKind binaryOperatorKind = SyntaxKindToBinaryOperatorKind(node.Kind());
            if ((object)left.Type != null && left.Type!.SpecialType == SpecialType.System_Boolean && (object)right.Type != null && right.Type!.SpecialType == SpecialType.System_Boolean)
            {
                ConstantValue constantValue = FoldBinaryOperator(node, binaryOperatorKind | BinaryOperatorKind.Bool, left, right, SpecialType.System_Boolean, diagnostics);
                return new BoundBinaryOperator(node, binaryOperatorKind | BinaryOperatorKind.Bool, constantValue, null, LookupResultKind.Viable, left, right, left.Type, constantValue != null && constantValue.IsBad);
            }
            if (left.HasAnyErrors || right.HasAnyErrors)
            {
                return new BoundBinaryOperator(node, binaryOperatorKind, null, null, LookupResultKind.Empty, left, right, GetBinaryOperatorErrorType(binaryOperatorKind, diagnostics, node), hasErrors: true);
            }
            if (left.HasDynamicType() || right.HasDynamicType())
            {
                left = BindToNaturalType(left, diagnostics);
                right = BindToNaturalType(right, diagnostics);
                return BindDynamicBinaryOperator(node, binaryOperatorKind, left, right, diagnostics);
            }
            BinaryOperatorAnalysisResult binaryOperatorAnalysisResult = BinaryOperatorOverloadResolution(binaryOperatorKind, left, right, node, diagnostics, out LookupResultKind resultKind, out ImmutableArray<MethodSymbol> originalUserDefinedOperators);
            if (!binaryOperatorAnalysisResult.HasValue)
            {
                ReportBinaryOperatorError(node, diagnostics, node.OperatorToken, left, right, resultKind);
            }
            else
            {
                BinaryOperatorSignature signature = binaryOperatorAnalysisResult.Signature;
                bool flag = signature.LeftType.SpecialType == SpecialType.System_Boolean && signature.RightType.SpecialType == SpecialType.System_Boolean;
                MethodSymbol trueOperator = null;
                MethodSymbol falseOperator = null;
                if (!flag && !signature.Kind.IsUserDefined())
                {
                    ReportBinaryOperatorError(node, diagnostics, node.OperatorToken, left, right, resultKind);
                }
                else if (flag || IsValidUserDefinedConditionalLogicalOperator(node, signature, diagnostics, out trueOperator, out falseOperator))
                {
                    BoundExpression left2 = CreateConversion(left, binaryOperatorAnalysisResult.LeftConversion, signature.LeftType, diagnostics);
                    BoundExpression right2 = CreateConversion(right, binaryOperatorAnalysisResult.RightConversion, signature.RightType, diagnostics);
                    BinaryOperatorKind binaryOperatorKind2 = binaryOperatorKind | signature.Kind.OperandTypes();
                    if (signature.Kind.IsLifted())
                    {
                        binaryOperatorKind2 |= BinaryOperatorKind.Lifted;
                    }
                    if (binaryOperatorKind2.IsUserDefined())
                    {
                        return new BoundUserDefinedConditionalLogicalOperator(node, binaryOperatorKind2, left2, right2, signature.Method, trueOperator, falseOperator, resultKind, originalUserDefinedOperators, signature.ReturnType);
                    }
                    return new BoundBinaryOperator(node, binaryOperatorKind2, left2, right2, null, signature.Method, resultKind, originalUserDefinedOperators, signature.ReturnType);
                }
            }
            return new BoundBinaryOperator(node, binaryOperatorKind, left, right, null, null, resultKind, originalUserDefinedOperators, CreateErrorType(), hasErrors: true);
        }

        private bool IsValidDynamicCondition(BoundExpression left, bool isNegative, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, out MethodSymbol userDefinedOperator)
        {
            userDefinedOperator = null;
            TypeSymbol type = left.Type;
            if ((object)type == null)
            {
                return false;
            }
            if (type.IsDynamic())
            {
                return true;
            }
            if (Conversions.ClassifyImplicitConversionFromExpression(left, Compilation.GetSpecialType(SpecialType.System_Boolean), ref useSiteInfo).Exists)
            {
                return true;
            }
            if (type.Kind != SymbolKind.NamedType)
            {
                return false;
            }
            NamedTypeSymbol containingType = type as NamedTypeSymbol;
            return HasApplicableBooleanOperator(containingType, isNegative ? "op_False" : "op_True", type, ref useSiteInfo, out userDefinedOperator);
        }

        private bool IsValidUserDefinedConditionalLogicalOperator(CSharpSyntaxNode syntax, BinaryOperatorSignature signature, BindingDiagnosticBag diagnostics, out MethodSymbol trueOperator, out MethodSymbol falseOperator)
        {
            NamedTypeSymbol containingType = signature.Method.ContainingType;
            bool num = TypeSymbol.Equals(signature.LeftType, signature.RightType, TypeCompareKind.ConsiderEverything) && TypeSymbol.Equals(signature.LeftType, signature.ReturnType, TypeCompareKind.ConsiderEverything);
            bool flag = TypeSymbol.Equals(signature.ReturnType, containingType, TypeCompareKind.ConsiderEverything) || (signature.ReturnType.IsNullableType() && TypeSymbol.Equals(signature.ReturnType.GetNullableUnderlyingType(), containingType, TypeCompareKind.ConsiderEverything));
            if (!num || !flag)
            {
                Error(diagnostics, ErrorCode.ERR_BadBoolOp, syntax, signature.Method);
                trueOperator = null;
                falseOperator = null;
                return false;
            }
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            if (!HasApplicableBooleanOperator(containingType, "op_True", signature.LeftType, ref useSiteInfo, out trueOperator) || !HasApplicableBooleanOperator(containingType, "op_False", signature.LeftType, ref useSiteInfo, out falseOperator))
            {
                Error(diagnostics, ErrorCode.ERR_MustHaveOpTF, syntax, signature.Method, containingType);
                diagnostics.Add(syntax, useSiteInfo);
                trueOperator = null;
                falseOperator = null;
                return false;
            }
            diagnostics.Add(syntax, useSiteInfo);
            return true;
        }

        private bool HasApplicableBooleanOperator(NamedTypeSymbol containingType, string name, TypeSymbol argumentType, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, out MethodSymbol @operator)
        {
            NamedTypeSymbol namedTypeSymbol = containingType;
            while ((object)namedTypeSymbol != null)
            {
                ImmutableArray<MethodSymbol> operators = namedTypeSymbol.GetOperators(name);
                for (int i = 0; i < operators.Length; i++)
                {
                    MethodSymbol methodSymbol = operators[i];
                    if (methodSymbol.ParameterCount == 1 && methodSymbol.DeclaredAccessibility == Accessibility.Public && Conversions.ClassifyConversionFromType(argumentType, methodSymbol.GetParameterType(0), ref useSiteInfo).IsImplicit)
                    {
                        @operator = methodSymbol;
                        return true;
                    }
                }
                namedTypeSymbol = namedTypeSymbol.BaseTypeWithDefinitionUseSiteDiagnostics(ref useSiteInfo);
            }
            @operator = null;
            return false;
        }

        private TypeSymbol GetBinaryOperatorErrorType(BinaryOperatorKind kind, BindingDiagnosticBag diagnostics, CSharpSyntaxNode node)
        {
            switch (kind)
            {
                case BinaryOperatorKind.Equal:
                case BinaryOperatorKind.NotEqual:
                case BinaryOperatorKind.GreaterThan:
                case BinaryOperatorKind.LessThan:
                case BinaryOperatorKind.GreaterThanOrEqual:
                case BinaryOperatorKind.LessThanOrEqual:
                    return GetSpecialType(SpecialType.System_Boolean, diagnostics, node);
                default:
                    return CreateErrorType();
            }
        }

        private BinaryOperatorAnalysisResult BinaryOperatorOverloadResolution(BinaryOperatorKind kind, BoundExpression left, BoundExpression right, CSharpSyntaxNode node, BindingDiagnosticBag diagnostics, out LookupResultKind resultKind, out ImmutableArray<MethodSymbol> originalUserDefinedOperators)
        {
            if (!IsTypelessExpressionAllowedInBinaryOperator(kind, left, right))
            {
                resultKind = LookupResultKind.OverloadResolutionFailure;
                originalUserDefinedOperators = default(ImmutableArray<MethodSymbol>);
                return default(BinaryOperatorAnalysisResult);
            }
            BinaryOperatorOverloadResolutionResult instance = BinaryOperatorOverloadResolutionResult.GetInstance();
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            OverloadResolution.BinaryOperatorOverloadResolution(kind, left, right, instance, ref useSiteInfo);
            diagnostics.Add(node, useSiteInfo);
            BinaryOperatorAnalysisResult best = instance.Best;
            if (instance.Results.Any())
            {
                ArrayBuilder<MethodSymbol> instance2 = ArrayBuilder<MethodSymbol>.GetInstance();
                ArrayBuilder<BinaryOperatorAnalysisResult>.Enumerator enumerator = instance.Results.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    MethodSymbol method = enumerator.Current.Signature.Method;
                    if ((object)method != null)
                    {
                        instance2.Add(method);
                    }
                }
                originalUserDefinedOperators = instance2.ToImmutableAndFree();
                if (best.HasValue)
                {
                    resultKind = LookupResultKind.Viable;
                }
                else if (instance.AnyValid())
                {
                    resultKind = LookupResultKind.Ambiguous;
                }
                else
                {
                    resultKind = LookupResultKind.OverloadResolutionFailure;
                }
            }
            else
            {
                originalUserDefinedOperators = ImmutableArray<MethodSymbol>.Empty;
                resultKind = (best.HasValue ? LookupResultKind.Viable : LookupResultKind.Empty);
            }
            if (best.HasValue)
            {
                MethodSymbol method2 = best.Signature.Method;
                if ((object)method2 != null)
                {
                    ReportObsoleteAndFeatureAvailabilityDiagnostics(method2, node, diagnostics);
                    ReportUseSite(method2, diagnostics, node);
                }
            }
            instance.Free();
            return best;
        }

        private void ReportObsoleteAndFeatureAvailabilityDiagnostics(MethodSymbol operatorMethod, CSharpSyntaxNode node, BindingDiagnosticBag diagnostics)
        {
            if ((object)operatorMethod != null)
            {
                ReportDiagnosticsIfObsolete(diagnostics, operatorMethod, node, hasBaseReceiver: false);
                if (operatorMethod.ContainingType.IsInterface && operatorMethod.ContainingModule != Compilation.SourceModule)
                {
                    CheckFeatureAvailability(node, MessageID.IDS_DefaultInterfaceImplementation, diagnostics);
                }
            }
        }

        private bool IsTypelessExpressionAllowedInBinaryOperator(BinaryOperatorKind kind, BoundExpression left, BoundExpression right)
        {
            if (left.IsImplicitObjectCreation() || right.IsImplicitObjectCreation())
            {
                return false;
            }
            if (kind == BinaryOperatorKind.Equal || kind == BinaryOperatorKind.NotEqual)
            {
                if (left.IsLiteralDefault())
                {
                    return !right.IsLiteralDefault();
                }
                return true;
            }
            if (!left.IsLiteralDefault())
            {
                return !right.IsLiteralDefault();
            }
            return false;
        }

        private UnaryOperatorAnalysisResult UnaryOperatorOverloadResolution(UnaryOperatorKind kind, BoundExpression operand, CSharpSyntaxNode node, BindingDiagnosticBag diagnostics, out LookupResultKind resultKind, out ImmutableArray<MethodSymbol> originalUserDefinedOperators)
        {
            UnaryOperatorOverloadResolutionResult instance = UnaryOperatorOverloadResolutionResult.GetInstance();
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            OverloadResolution.UnaryOperatorOverloadResolution(kind, operand, instance, ref useSiteInfo);
            diagnostics.Add(node, useSiteInfo);
            UnaryOperatorAnalysisResult best = instance.Best;
            if (instance.Results.Any())
            {
                ArrayBuilder<MethodSymbol> instance2 = ArrayBuilder<MethodSymbol>.GetInstance();
                ArrayBuilder<UnaryOperatorAnalysisResult>.Enumerator enumerator = instance.Results.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    MethodSymbol method = enumerator.Current.Signature.Method;
                    if ((object)method != null)
                    {
                        instance2.Add(method);
                    }
                }
                originalUserDefinedOperators = instance2.ToImmutableAndFree();
                if (best.HasValue)
                {
                    resultKind = LookupResultKind.Viable;
                }
                else if (instance.AnyValid())
                {
                    if (kind == UnaryOperatorKind.UnaryMinus && (object)operand.Type != null && (operand.Type!.SpecialType == SpecialType.System_UInt64 || (operand.Type!.SpecialType == SpecialType.System_UIntPtr && operand.Type!.IsNativeIntegerType)))
                    {
                        resultKind = LookupResultKind.OverloadResolutionFailure;
                    }
                    else
                    {
                        resultKind = LookupResultKind.Ambiguous;
                    }
                }
                else
                {
                    resultKind = LookupResultKind.OverloadResolutionFailure;
                }
            }
            else
            {
                originalUserDefinedOperators = ImmutableArray<MethodSymbol>.Empty;
                resultKind = (best.HasValue ? LookupResultKind.Viable : LookupResultKind.Empty);
            }
            if (best.HasValue)
            {
                MethodSymbol method2 = best.Signature.Method;
                if ((object)method2 != null)
                {
                    ReportObsoleteAndFeatureAvailabilityDiagnostics(method2, node, diagnostics);
                    ReportUseSite(method2, diagnostics, node);
                }
            }
            instance.Free();
            return best;
        }

        private static object FoldDecimalBinaryOperators(BinaryOperatorKind kind, ConstantValue valueLeft, ConstantValue valueRight)
        {
            return kind switch
            {
                BinaryOperatorKind.DecimalAddition => valueLeft.DecimalValue + valueRight.DecimalValue,
                BinaryOperatorKind.DecimalSubtraction => valueLeft.DecimalValue - valueRight.DecimalValue,
                BinaryOperatorKind.DecimalMultiplication => valueLeft.DecimalValue * valueRight.DecimalValue,
                BinaryOperatorKind.DecimalDivision => valueLeft.DecimalValue / valueRight.DecimalValue,
                BinaryOperatorKind.DecimalRemainder => valueLeft.DecimalValue % valueRight.DecimalValue,
                _ => null,
            };
        }

        private static object FoldNativeIntegerOverflowingBinaryOperator(BinaryOperatorKind kind, ConstantValue valueLeft, ConstantValue valueRight)
        {
            checked
            {
                switch (kind)
                {
                    case BinaryOperatorKind.NIntAddition:
                        return valueLeft.Int32Value + valueRight.Int32Value;
                    case BinaryOperatorKind.NUIntAddition:
                        return valueLeft.UInt32Value + valueRight.UInt32Value;
                    case BinaryOperatorKind.NIntSubtraction:
                        return valueLeft.Int32Value - valueRight.Int32Value;
                    case BinaryOperatorKind.NUIntSubtraction:
                        return valueLeft.UInt32Value - valueRight.UInt32Value;
                    case BinaryOperatorKind.NIntMultiplication:
                        return valueLeft.Int32Value * valueRight.Int32Value;
                    case BinaryOperatorKind.NUIntMultiplication:
                        return valueLeft.UInt32Value * valueRight.UInt32Value;
                    case BinaryOperatorKind.NIntDivision:
                        return unchecked(valueLeft.Int32Value / valueRight.Int32Value);
                    case BinaryOperatorKind.NIntRemainder:
                        return unchecked(valueLeft.Int32Value % valueRight.Int32Value);
                    case BinaryOperatorKind.NIntLeftShift:
                        {
                            int num3 = valueLeft.Int32Value << valueRight.Int32Value;
                            long num4 = valueLeft.Int64Value << valueRight.Int32Value;
                            if (num3 != num4)
                            {
                                return null;
                            }
                            return num3;
                        }
                    case BinaryOperatorKind.NUIntLeftShift:
                        {
                            uint num = valueLeft.UInt32Value << valueRight.Int32Value;
                            ulong num2 = valueLeft.UInt64Value << valueRight.Int32Value;
                            if (num != num2)
                            {
                                return null;
                            }
                            return num;
                        }
                    default:
                        return null;
                }
            }
        }

        private static object FoldUncheckedIntegralBinaryOperator(BinaryOperatorKind kind, ConstantValue valueLeft, ConstantValue valueRight)
        {
            switch (kind)
            {
                case BinaryOperatorKind.IntAddition:
                    return valueLeft.Int32Value + valueRight.Int32Value;
                case BinaryOperatorKind.LongAddition:
                    return valueLeft.Int64Value + valueRight.Int64Value;
                case BinaryOperatorKind.UIntAddition:
                    return valueLeft.UInt32Value + valueRight.UInt32Value;
                case BinaryOperatorKind.ULongAddition:
                    return valueLeft.UInt64Value + valueRight.UInt64Value;
                case BinaryOperatorKind.IntSubtraction:
                    return valueLeft.Int32Value - valueRight.Int32Value;
                case BinaryOperatorKind.LongSubtraction:
                    return valueLeft.Int64Value - valueRight.Int64Value;
                case BinaryOperatorKind.UIntSubtraction:
                    return valueLeft.UInt32Value - valueRight.UInt32Value;
                case BinaryOperatorKind.ULongSubtraction:
                    return valueLeft.UInt64Value - valueRight.UInt64Value;
                case BinaryOperatorKind.IntMultiplication:
                    return valueLeft.Int32Value * valueRight.Int32Value;
                case BinaryOperatorKind.LongMultiplication:
                    return valueLeft.Int64Value * valueRight.Int64Value;
                case BinaryOperatorKind.UIntMultiplication:
                    return valueLeft.UInt32Value * valueRight.UInt32Value;
                case BinaryOperatorKind.ULongMultiplication:
                    return valueLeft.UInt64Value * valueRight.UInt64Value;
                case BinaryOperatorKind.IntDivision:
                    if (valueLeft.Int32Value == int.MinValue && valueRight.Int32Value == -1)
                    {
                        return int.MinValue;
                    }
                    return valueLeft.Int32Value / valueRight.Int32Value;
                case BinaryOperatorKind.LongDivision:
                    if (valueLeft.Int64Value == long.MinValue && valueRight.Int64Value == -1)
                    {
                        return long.MinValue;
                    }
                    return valueLeft.Int64Value / valueRight.Int64Value;
                default:
                    return null;
            }
        }

        private static object FoldCheckedIntegralBinaryOperator(BinaryOperatorKind kind, ConstantValue valueLeft, ConstantValue valueRight)
        {
            checked
            {
                return kind switch
                {
                    BinaryOperatorKind.IntAddition => valueLeft.Int32Value + valueRight.Int32Value,
                    BinaryOperatorKind.LongAddition => valueLeft.Int64Value + valueRight.Int64Value,
                    BinaryOperatorKind.UIntAddition => valueLeft.UInt32Value + valueRight.UInt32Value,
                    BinaryOperatorKind.ULongAddition => valueLeft.UInt64Value + valueRight.UInt64Value,
                    BinaryOperatorKind.IntSubtraction => valueLeft.Int32Value - valueRight.Int32Value,
                    BinaryOperatorKind.LongSubtraction => valueLeft.Int64Value - valueRight.Int64Value,
                    BinaryOperatorKind.UIntSubtraction => valueLeft.UInt32Value - valueRight.UInt32Value,
                    BinaryOperatorKind.ULongSubtraction => valueLeft.UInt64Value - valueRight.UInt64Value,
                    BinaryOperatorKind.IntMultiplication => valueLeft.Int32Value * valueRight.Int32Value,
                    BinaryOperatorKind.LongMultiplication => valueLeft.Int64Value * valueRight.Int64Value,
                    BinaryOperatorKind.UIntMultiplication => valueLeft.UInt32Value * valueRight.UInt32Value,
                    BinaryOperatorKind.ULongMultiplication => valueLeft.UInt64Value * valueRight.UInt64Value,
                    BinaryOperatorKind.IntDivision => unchecked(valueLeft.Int32Value / valueRight.Int32Value),
                    BinaryOperatorKind.LongDivision => unchecked(valueLeft.Int64Value / valueRight.Int64Value),
                    _ => null,
                };
            }
        }

        internal static TypeSymbol GetEnumType(BinaryOperatorKind kind, BoundExpression left, BoundExpression right)
        {
            switch (kind)
            {
                case BinaryOperatorKind.EnumAndUnderlyingAddition:
                case BinaryOperatorKind.EnumSubtraction:
                case BinaryOperatorKind.EnumAndUnderlyingSubtraction:
                case BinaryOperatorKind.EnumEqual:
                case BinaryOperatorKind.EnumNotEqual:
                case BinaryOperatorKind.EnumGreaterThan:
                case BinaryOperatorKind.EnumLessThan:
                case BinaryOperatorKind.EnumGreaterThanOrEqual:
                case BinaryOperatorKind.EnumLessThanOrEqual:
                case BinaryOperatorKind.EnumAnd:
                case BinaryOperatorKind.EnumXor:
                case BinaryOperatorKind.EnumOr:
                    return left.Type;
                case BinaryOperatorKind.UnderlyingAndEnumAddition:
                case BinaryOperatorKind.UnderlyingAndEnumSubtraction:
                    return right.Type;
                default:
                    throw ExceptionUtilities.UnexpectedValue(kind);
            }
        }

        internal static SpecialType GetEnumPromotedType(SpecialType underlyingType)
        {
            switch (underlyingType)
            {
                case SpecialType.System_SByte:
                case SpecialType.System_Byte:
                case SpecialType.System_Int16:
                case SpecialType.System_UInt16:
                    return SpecialType.System_Int32;
                case SpecialType.System_Int32:
                case SpecialType.System_UInt32:
                case SpecialType.System_Int64:
                case SpecialType.System_UInt64:
                    return underlyingType;
                default:
                    throw ExceptionUtilities.UnexpectedValue(underlyingType);
            }
        }

        private ConstantValue? FoldEnumBinaryOperator(CSharpSyntaxNode syntax, BinaryOperatorKind kind, BoundExpression left, BoundExpression right, BindingDiagnosticBag diagnostics)
        {
            TypeSymbol enumType = GetEnumType(kind, left, right);
            TypeSymbol enumUnderlyingType = enumType.GetEnumUnderlyingType();
            BoundExpression source = CreateConversion(left, enumUnderlyingType, diagnostics);
            BoundExpression source2 = CreateConversion(right, enumUnderlyingType, diagnostics);
            SpecialType enumPromotedType = GetEnumPromotedType(enumUnderlyingType.SpecialType);
            TypeSymbol typeSymbol = ((enumPromotedType == enumUnderlyingType.SpecialType) ? enumUnderlyingType : GetSpecialType(enumPromotedType, diagnostics, syntax));
            source = CreateConversion(source, typeSymbol, diagnostics);
            source2 = CreateConversion(source2, typeSymbol, diagnostics);
            BinaryOperatorKind kind2 = kind.Operator().WithType(source.Type!.SpecialType);
            SpecialType specialType = SpecialType.None;
            switch (kind2.Operator())
            {
                case BinaryOperatorKind.Addition:
                case BinaryOperatorKind.Subtraction:
                case BinaryOperatorKind.And:
                case BinaryOperatorKind.Xor:
                case BinaryOperatorKind.Or:
                    specialType = typeSymbol.SpecialType;
                    break;
                case BinaryOperatorKind.Equal:
                case BinaryOperatorKind.NotEqual:
                case BinaryOperatorKind.GreaterThan:
                case BinaryOperatorKind.LessThan:
                case BinaryOperatorKind.GreaterThanOrEqual:
                case BinaryOperatorKind.LessThanOrEqual:
                    specialType = SpecialType.System_Boolean;
                    break;
                default:
                    throw ExceptionUtilities.UnexpectedValue(kind2.Operator());
            }
            ConstantValue constantValue = FoldBinaryOperator(syntax, kind2, source, source2, specialType, diagnostics);
            if (specialType != SpecialType.System_Boolean && constantValue != null && !constantValue.IsBad)
            {
                TypeSymbol destination = ((kind == BinaryOperatorKind.EnumSubtraction) ? enumUnderlyingType : enumType);
                return FoldConstantNumericConversion(syntax, constantValue, destination, diagnostics);
            }
            return constantValue;
        }

        private ConstantValue? FoldBinaryOperator(CSharpSyntaxNode syntax, BinaryOperatorKind kind, BoundExpression left, BoundExpression right, SpecialType resultType, BindingDiagnosticBag diagnostics)
        {
            if (left.HasAnyErrors || right.HasAnyErrors)
            {
                return null;
            }
            ConstantValue constantValue = TryFoldingNullableEquality(kind, left, right);
            if (constantValue != null)
            {
                return constantValue;
            }
            ConstantValue constantValue2 = left.ConstantValue;
            ConstantValue constantValue3 = right.ConstantValue;
            if (constantValue2 == null || constantValue3 == null)
            {
                return null;
            }
            if (constantValue2.IsBad || constantValue3.IsBad)
            {
                return ConstantValue.Bad;
            }
            if (kind.IsEnum() && !kind.IsLifted())
            {
                return FoldEnumBinaryOperator(syntax, kind, left, right, diagnostics);
            }
            if (IsDivisionByZero(kind, constantValue3))
            {
                Error(diagnostics, ErrorCode.ERR_IntDivByZero, syntax);
                return ConstantValue.Bad;
            }
            object obj = null;
            obj = FoldNeverOverflowBinaryOperators(kind, constantValue2, constantValue3);
            if (obj != null)
            {
                return ConstantValue.Create(obj, resultType);
            }
            ConstantValue constantValue4 = FoldStringConcatenation(kind, constantValue2, constantValue3);
            if (constantValue4 != null)
            {
                if (constantValue4.IsBad)
                {
                    Error(diagnostics, ErrorCode.ERR_ConstantStringTooLong, right.Syntax);
                }
                return constantValue4;
            }
            try
            {
                obj = FoldDecimalBinaryOperators(kind, constantValue2, constantValue3);
            }
            catch (OverflowException)
            {
                Error(diagnostics, ErrorCode.ERR_DecConstError, syntax);
                return ConstantValue.Bad;
            }
            if (obj != null)
            {
                return ConstantValue.Create(obj, resultType);
            }
            try
            {
                obj = FoldNativeIntegerOverflowingBinaryOperator(kind, constantValue2, constantValue3);
            }
            catch (OverflowException)
            {
                if (CheckOverflowAtCompileTime)
                {
                    Error(diagnostics, ErrorCode.ERR_CheckedOverflow, syntax);
                    return ConstantValue.Bad;
                }
                return null;
            }
            if (obj != null)
            {
                return ConstantValue.Create(obj, resultType);
            }
            if (CheckOverflowAtCompileTime)
            {
                try
                {
                    obj = FoldCheckedIntegralBinaryOperator(kind, constantValue2, constantValue3);
                }
                catch (OverflowException)
                {
                    Error(diagnostics, ErrorCode.ERR_CheckedOverflow, syntax);
                    return ConstantValue.Bad;
                }
            }
            else
            {
                obj = FoldUncheckedIntegralBinaryOperator(kind, constantValue2, constantValue3);
            }
            if (obj != null)
            {
                return ConstantValue.Create(obj, resultType);
            }
            return null;
        }

        private static ConstantValue? TryFoldingNullableEquality(BinaryOperatorKind kind, BoundExpression left, BoundExpression right)
        {
            if (kind.IsLifted())
            {
                BinaryOperatorKind binaryOperatorKind = kind.Operator();
                if ((binaryOperatorKind == BinaryOperatorKind.Equal || binaryOperatorKind == BinaryOperatorKind.NotEqual) && left.Kind == BoundKind.Conversion && right.Kind == BoundKind.Conversion)
                {
                    BoundConversion obj = (BoundConversion)left;
                    BoundConversion boundConversion = (BoundConversion)right;
                    ConstantValue constantValue = obj.Operand.ConstantValue;
                    ConstantValue constantValue2 = boundConversion.Operand.ConstantValue;
                    if (constantValue != null && constantValue2 != null)
                    {
                        bool isNull = constantValue.IsNull;
                        bool isNull2 = constantValue2.IsNull;
                        if (isNull || isNull2)
                        {
                            if (isNull == isNull2 != (binaryOperatorKind == BinaryOperatorKind.Equal))
                            {
                                return ConstantValue.False;
                            }
                            return ConstantValue.True;
                        }
                    }
                }
            }
            return null;
        }

        private static object? FoldNeverOverflowBinaryOperators(BinaryOperatorKind kind, ConstantValue valueLeft, ConstantValue valueRight)
        {
            switch (kind)
            {
                case BinaryOperatorKind.ObjectEqual:
                    if (valueLeft.IsNull)
                    {
                        return valueRight.IsNull;
                    }
                    if (valueRight.IsNull)
                    {
                        return false;
                    }
                    break;
                case BinaryOperatorKind.ObjectNotEqual:
                    if (valueLeft.IsNull)
                    {
                        return !valueRight.IsNull;
                    }
                    if (valueRight.IsNull)
                    {
                        return true;
                    }
                    break;
                case BinaryOperatorKind.DoubleAddition:
                    return valueLeft.DoubleValue + valueRight.DoubleValue;
                case BinaryOperatorKind.FloatAddition:
                    return valueLeft.SingleValue + valueRight.SingleValue;
                case BinaryOperatorKind.DoubleSubtraction:
                    return valueLeft.DoubleValue - valueRight.DoubleValue;
                case BinaryOperatorKind.FloatSubtraction:
                    return valueLeft.SingleValue - valueRight.SingleValue;
                case BinaryOperatorKind.DoubleMultiplication:
                    return valueLeft.DoubleValue * valueRight.DoubleValue;
                case BinaryOperatorKind.FloatMultiplication:
                    return valueLeft.SingleValue * valueRight.SingleValue;
                case BinaryOperatorKind.DoubleDivision:
                    return valueLeft.DoubleValue / valueRight.DoubleValue;
                case BinaryOperatorKind.FloatDivision:
                    return valueLeft.SingleValue / valueRight.SingleValue;
                case BinaryOperatorKind.DoubleRemainder:
                    return valueLeft.DoubleValue % valueRight.DoubleValue;
                case BinaryOperatorKind.FloatRemainder:
                    return valueLeft.SingleValue % valueRight.SingleValue;
                case BinaryOperatorKind.IntLeftShift:
                    return valueLeft.Int32Value << valueRight.Int32Value;
                case BinaryOperatorKind.LongLeftShift:
                    return valueLeft.Int64Value << valueRight.Int32Value;
                case BinaryOperatorKind.UIntLeftShift:
                    return valueLeft.UInt32Value << valueRight.Int32Value;
                case BinaryOperatorKind.ULongLeftShift:
                    return valueLeft.UInt64Value << valueRight.Int32Value;
                case BinaryOperatorKind.IntRightShift:
                case BinaryOperatorKind.NIntRightShift:
                    return valueLeft.Int32Value >> valueRight.Int32Value;
                case BinaryOperatorKind.LongRightShift:
                    return valueLeft.Int64Value >> valueRight.Int32Value;
                case BinaryOperatorKind.UIntRightShift:
                case BinaryOperatorKind.NUIntRightShift:
                    return valueLeft.UInt32Value >> valueRight.Int32Value;
                case BinaryOperatorKind.ULongRightShift:
                    return valueLeft.UInt64Value >> valueRight.Int32Value;
                case BinaryOperatorKind.BoolAnd:
                    return valueLeft.BooleanValue & valueRight.BooleanValue;
                case BinaryOperatorKind.IntAnd:
                case BinaryOperatorKind.NIntAnd:
                    return valueLeft.Int32Value & valueRight.Int32Value;
                case BinaryOperatorKind.LongAnd:
                    return valueLeft.Int64Value & valueRight.Int64Value;
                case BinaryOperatorKind.UIntAnd:
                case BinaryOperatorKind.NUIntAnd:
                    return valueLeft.UInt32Value & valueRight.UInt32Value;
                case BinaryOperatorKind.ULongAnd:
                    return valueLeft.UInt64Value & valueRight.UInt64Value;
                case BinaryOperatorKind.BoolOr:
                    return valueLeft.BooleanValue | valueRight.BooleanValue;
                case BinaryOperatorKind.IntOr:
                case BinaryOperatorKind.NIntOr:
                    return valueLeft.Int32Value | valueRight.Int32Value;
                case BinaryOperatorKind.LongOr:
                    return valueLeft.Int64Value | valueRight.Int64Value;
                case BinaryOperatorKind.UIntOr:
                case BinaryOperatorKind.NUIntOr:
                    return valueLeft.UInt32Value | valueRight.UInt32Value;
                case BinaryOperatorKind.ULongOr:
                    return valueLeft.UInt64Value | valueRight.UInt64Value;
                case BinaryOperatorKind.BoolXor:
                    return valueLeft.BooleanValue ^ valueRight.BooleanValue;
                case BinaryOperatorKind.IntXor:
                case BinaryOperatorKind.NIntXor:
                    return valueLeft.Int32Value ^ valueRight.Int32Value;
                case BinaryOperatorKind.LongXor:
                    return valueLeft.Int64Value ^ valueRight.Int64Value;
                case BinaryOperatorKind.UIntXor:
                case BinaryOperatorKind.NUIntXor:
                    return valueLeft.UInt32Value ^ valueRight.UInt32Value;
                case BinaryOperatorKind.ULongXor:
                    return valueLeft.UInt64Value ^ valueRight.UInt64Value;
                case BinaryOperatorKind.LogicalBoolAnd:
                    return valueLeft.BooleanValue && valueRight.BooleanValue;
                case BinaryOperatorKind.LogicalBoolOr:
                    return valueLeft.BooleanValue || valueRight.BooleanValue;
                case BinaryOperatorKind.BoolEqual:
                    return valueLeft.BooleanValue == valueRight.BooleanValue;
                case BinaryOperatorKind.StringEqual:
                    return valueLeft.StringValue == valueRight.StringValue;
                case BinaryOperatorKind.DecimalEqual:
                    return valueLeft.DecimalValue == valueRight.DecimalValue;
                case BinaryOperatorKind.FloatEqual:
                    return valueLeft.SingleValue == valueRight.SingleValue;
                case BinaryOperatorKind.DoubleEqual:
                    return valueLeft.DoubleValue == valueRight.DoubleValue;
                case BinaryOperatorKind.IntEqual:
                case BinaryOperatorKind.NIntEqual:
                    return valueLeft.Int32Value == valueRight.Int32Value;
                case BinaryOperatorKind.LongEqual:
                    return valueLeft.Int64Value == valueRight.Int64Value;
                case BinaryOperatorKind.UIntEqual:
                case BinaryOperatorKind.NUIntEqual:
                    return valueLeft.UInt32Value == valueRight.UInt32Value;
                case BinaryOperatorKind.ULongEqual:
                    return valueLeft.UInt64Value == valueRight.UInt64Value;
                case BinaryOperatorKind.BoolNotEqual:
                    return valueLeft.BooleanValue != valueRight.BooleanValue;
                case BinaryOperatorKind.StringNotEqual:
                    return valueLeft.StringValue != valueRight.StringValue;
                case BinaryOperatorKind.DecimalNotEqual:
                    return valueLeft.DecimalValue != valueRight.DecimalValue;
                case BinaryOperatorKind.FloatNotEqual:
                    return valueLeft.SingleValue != valueRight.SingleValue;
                case BinaryOperatorKind.DoubleNotEqual:
                    return valueLeft.DoubleValue != valueRight.DoubleValue;
                case BinaryOperatorKind.IntNotEqual:
                case BinaryOperatorKind.NIntNotEqual:
                    return valueLeft.Int32Value != valueRight.Int32Value;
                case BinaryOperatorKind.LongNotEqual:
                    return valueLeft.Int64Value != valueRight.Int64Value;
                case BinaryOperatorKind.UIntNotEqual:
                case BinaryOperatorKind.NUIntNotEqual:
                    return valueLeft.UInt32Value != valueRight.UInt32Value;
                case BinaryOperatorKind.ULongNotEqual:
                    return valueLeft.UInt64Value != valueRight.UInt64Value;
                case BinaryOperatorKind.DecimalLessThan:
                    return valueLeft.DecimalValue < valueRight.DecimalValue;
                case BinaryOperatorKind.FloatLessThan:
                    return valueLeft.SingleValue < valueRight.SingleValue;
                case BinaryOperatorKind.DoubleLessThan:
                    return valueLeft.DoubleValue < valueRight.DoubleValue;
                case BinaryOperatorKind.IntLessThan:
                case BinaryOperatorKind.NIntLessThan:
                    return valueLeft.Int32Value < valueRight.Int32Value;
                case BinaryOperatorKind.LongLessThan:
                    return valueLeft.Int64Value < valueRight.Int64Value;
                case BinaryOperatorKind.UIntLessThan:
                case BinaryOperatorKind.NUIntLessThan:
                    return valueLeft.UInt32Value < valueRight.UInt32Value;
                case BinaryOperatorKind.ULongLessThan:
                    return valueLeft.UInt64Value < valueRight.UInt64Value;
                case BinaryOperatorKind.DecimalGreaterThan:
                    return valueLeft.DecimalValue > valueRight.DecimalValue;
                case BinaryOperatorKind.FloatGreaterThan:
                    return valueLeft.SingleValue > valueRight.SingleValue;
                case BinaryOperatorKind.DoubleGreaterThan:
                    return valueLeft.DoubleValue > valueRight.DoubleValue;
                case BinaryOperatorKind.IntGreaterThan:
                case BinaryOperatorKind.NIntGreaterThan:
                    return valueLeft.Int32Value > valueRight.Int32Value;
                case BinaryOperatorKind.LongGreaterThan:
                    return valueLeft.Int64Value > valueRight.Int64Value;
                case BinaryOperatorKind.UIntGreaterThan:
                case BinaryOperatorKind.NUIntGreaterThan:
                    return valueLeft.UInt32Value > valueRight.UInt32Value;
                case BinaryOperatorKind.ULongGreaterThan:
                    return valueLeft.UInt64Value > valueRight.UInt64Value;
                case BinaryOperatorKind.DecimalLessThanOrEqual:
                    return valueLeft.DecimalValue <= valueRight.DecimalValue;
                case BinaryOperatorKind.FloatLessThanOrEqual:
                    return valueLeft.SingleValue <= valueRight.SingleValue;
                case BinaryOperatorKind.DoubleLessThanOrEqual:
                    return valueLeft.DoubleValue <= valueRight.DoubleValue;
                case BinaryOperatorKind.IntLessThanOrEqual:
                case BinaryOperatorKind.NIntLessThanOrEqual:
                    return valueLeft.Int32Value <= valueRight.Int32Value;
                case BinaryOperatorKind.LongLessThanOrEqual:
                    return valueLeft.Int64Value <= valueRight.Int64Value;
                case BinaryOperatorKind.UIntLessThanOrEqual:
                case BinaryOperatorKind.NUIntLessThanOrEqual:
                    return valueLeft.UInt32Value <= valueRight.UInt32Value;
                case BinaryOperatorKind.ULongLessThanOrEqual:
                    return valueLeft.UInt64Value <= valueRight.UInt64Value;
                case BinaryOperatorKind.DecimalGreaterThanOrEqual:
                    return valueLeft.DecimalValue >= valueRight.DecimalValue;
                case BinaryOperatorKind.FloatGreaterThanOrEqual:
                    return valueLeft.SingleValue >= valueRight.SingleValue;
                case BinaryOperatorKind.DoubleGreaterThanOrEqual:
                    return valueLeft.DoubleValue >= valueRight.DoubleValue;
                case BinaryOperatorKind.IntGreaterThanOrEqual:
                case BinaryOperatorKind.NIntGreaterThanOrEqual:
                    return valueLeft.Int32Value >= valueRight.Int32Value;
                case BinaryOperatorKind.LongGreaterThanOrEqual:
                    return valueLeft.Int64Value >= valueRight.Int64Value;
                case BinaryOperatorKind.UIntGreaterThanOrEqual:
                case BinaryOperatorKind.NUIntGreaterThanOrEqual:
                    return valueLeft.UInt32Value >= valueRight.UInt32Value;
                case BinaryOperatorKind.ULongGreaterThanOrEqual:
                    return valueLeft.UInt64Value >= valueRight.UInt64Value;
                case BinaryOperatorKind.UIntDivision:
                case BinaryOperatorKind.NUIntDivision:
                    return valueLeft.UInt32Value / valueRight.UInt32Value;
                case BinaryOperatorKind.ULongDivision:
                    return valueLeft.UInt64Value / valueRight.UInt64Value;
                case BinaryOperatorKind.IntRemainder:
                    return (valueRight.Int32Value != -1) ? (valueLeft.Int32Value % valueRight.Int32Value) : 0;
                case BinaryOperatorKind.LongRemainder:
                    return (valueRight.Int64Value != -1) ? (valueLeft.Int64Value % valueRight.Int64Value) : 0;
                case BinaryOperatorKind.UIntRemainder:
                case BinaryOperatorKind.NUIntRemainder:
                    return valueLeft.UInt32Value % valueRight.UInt32Value;
                case BinaryOperatorKind.ULongRemainder:
                    return valueLeft.UInt64Value % valueRight.UInt64Value;
            }
            return null;
        }

        private static ConstantValue? FoldStringConcatenation(BinaryOperatorKind kind, ConstantValue valueLeft, ConstantValue valueRight)
        {
            if (kind == BinaryOperatorKind.StringConcatenation)
            {
                Rope rope = valueLeft.RopeValue ?? Rope.Empty;
                Rope rope2 = valueRight.RopeValue ?? Rope.Empty;
                if (rope.Length + (long)rope2.Length <= int.MaxValue)
                {
                    return ConstantValue.CreateFromRope(Rope.Concat(rope, rope2));
                }
                return ConstantValue.Bad;
            }
            return null;
        }

        private static BinaryOperatorKind SyntaxKindToBinaryOperatorKind(SyntaxKind kind)
        {
            switch (kind)
            {
                case SyntaxKind.MultiplyExpression:
                case SyntaxKind.MultiplyAssignmentExpression:
                    return BinaryOperatorKind.Multiplication;
                case SyntaxKind.DivideExpression:
                case SyntaxKind.DivideAssignmentExpression:
                    return BinaryOperatorKind.Division;
                case SyntaxKind.ModuloExpression:
                case SyntaxKind.ModuloAssignmentExpression:
                    return BinaryOperatorKind.Remainder;
                case SyntaxKind.AddExpression:
                case SyntaxKind.AddAssignmentExpression:
                    return BinaryOperatorKind.Addition;
                case SyntaxKind.SubtractExpression:
                case SyntaxKind.SubtractAssignmentExpression:
                    return BinaryOperatorKind.Subtraction;
                case SyntaxKind.RightShiftExpression:
                case SyntaxKind.RightShiftAssignmentExpression:
                    return BinaryOperatorKind.RightShift;
                case SyntaxKind.LeftShiftExpression:
                case SyntaxKind.LeftShiftAssignmentExpression:
                    return BinaryOperatorKind.LeftShift;
                case SyntaxKind.EqualsExpression:
                    return BinaryOperatorKind.Equal;
                case SyntaxKind.NotEqualsExpression:
                    return BinaryOperatorKind.NotEqual;
                case SyntaxKind.GreaterThanExpression:
                    return BinaryOperatorKind.GreaterThan;
                case SyntaxKind.LessThanExpression:
                    return BinaryOperatorKind.LessThan;
                case SyntaxKind.GreaterThanOrEqualExpression:
                    return BinaryOperatorKind.GreaterThanOrEqual;
                case SyntaxKind.LessThanOrEqualExpression:
                    return BinaryOperatorKind.LessThanOrEqual;
                case SyntaxKind.BitwiseAndExpression:
                case SyntaxKind.AndAssignmentExpression:
                    return BinaryOperatorKind.And;
                case SyntaxKind.BitwiseOrExpression:
                case SyntaxKind.OrAssignmentExpression:
                    return BinaryOperatorKind.Or;
                case SyntaxKind.ExclusiveOrExpression:
                case SyntaxKind.ExclusiveOrAssignmentExpression:
                    return BinaryOperatorKind.Xor;
                case SyntaxKind.LogicalAndExpression:
                    return BinaryOperatorKind.LogicalAnd;
                case SyntaxKind.LogicalOrExpression:
                    return BinaryOperatorKind.LogicalOr;
                default:
                    throw ExceptionUtilities.UnexpectedValue(kind);
            }
        }

        private BoundExpression BindIncrementOperator(CSharpSyntaxNode node, ExpressionSyntax operandSyntax, SyntaxToken operatorToken, BindingDiagnosticBag diagnostics)
        {
            operandSyntax.CheckDeconstructionCompatibleArgument(diagnostics);
            BoundExpression boundExpression = BindToNaturalType(BindValue(operandSyntax, diagnostics, BindValueKind.IncrementDecrement), diagnostics);
            UnaryOperatorKind unaryOperatorKind = SyntaxKindToUnaryOperatorKind(node.Kind());
            if (boundExpression.HasAnyErrors)
            {
                return new BoundIncrementOperator(node, unaryOperatorKind, boundExpression, null, Conversion.NoConversion, Conversion.NoConversion, LookupResultKind.Empty, CreateErrorType(), hasErrors: true);
            }
            TypeSymbol type = boundExpression.Type;
            if (type.IsDynamic())
            {
                return new BoundIncrementOperator(node, unaryOperatorKind.WithType(UnaryOperatorKind.Dynamic).WithOverflowChecksIfApplicable(CheckOverflowAtRuntime), boundExpression, null, Conversion.NoConversion, Conversion.NoConversion, LookupResultKind.Viable, default(ImmutableArray<MethodSymbol>), type);
            }
            UnaryOperatorAnalysisResult unaryOperatorAnalysisResult = UnaryOperatorOverloadResolution(unaryOperatorKind, boundExpression, node, diagnostics, out LookupResultKind resultKind, out ImmutableArray<MethodSymbol> originalUserDefinedOperators);
            if (!unaryOperatorAnalysisResult.HasValue)
            {
                ReportUnaryOperatorError(node, diagnostics, operatorToken.Text, boundExpression, resultKind);
                return new BoundIncrementOperator(node, unaryOperatorKind, boundExpression, null, Conversion.NoConversion, Conversion.NoConversion, resultKind, originalUserDefinedOperators, CreateErrorType(), hasErrors: true);
            }
            UnaryOperatorSignature signature = unaryOperatorAnalysisResult.Signature;
            CheckNativeIntegerFeatureAvailability(signature.Kind, node, diagnostics);
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            Conversion conversion = Conversions.ClassifyConversionFromType(signature.ReturnType, type, ref useSiteInfo);
            diagnostics.Add(node, useSiteInfo);
            bool flag = false;
            if (!conversion.IsImplicit || !conversion.IsValid)
            {
                GenerateImplicitConversionError(diagnostics, Compilation, node, conversion, signature.ReturnType, type);
                flag = true;
            }
            else
            {
                ReportDiagnosticsIfObsolete(diagnostics, conversion, node, hasBaseReceiver: false);
            }
            if (!flag && type.IsVoidPointer())
            {
                Error(diagnostics, ErrorCode.ERR_VoidError, node);
                flag = true;
            }
            Conversion conversion2 = unaryOperatorAnalysisResult.Conversion;
            ReportDiagnosticsIfObsolete(diagnostics, conversion2, node, hasBaseReceiver: false);
            return new BoundIncrementOperator(node, signature.Kind.WithOverflowChecksIfApplicable(CheckOverflowAtRuntime), boundExpression, signature.Method, conversion2, conversion, resultKind, originalUserDefinedOperators, type, flag);
        }

        private BoundExpression BindSuppressNullableWarningExpression(PostfixUnaryExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            BoundExpression boundExpression = BindExpression(node.Operand, diagnostics);
            BoundKind kind = boundExpression.Kind;
            if (kind == BoundKind.TypeExpression || kind == BoundKind.NamespaceExpression)
            {
                Error(diagnostics, ErrorCode.ERR_IllegalSuppression, boundExpression.Syntax);
            }
            else if (boundExpression.IsSuppressed)
            {
                Error(diagnostics, ErrorCode.ERR_DuplicateNullSuppression, boundExpression.Syntax);
            }
            return boundExpression.WithSuppression();
        }

        private BoundExpression BindPointerIndirectionExpression(PrefixUnaryExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            BoundExpression operand = BindToNaturalType(BindValue(node.Operand, diagnostics, GetUnaryAssignmentKind(node.Kind())), diagnostics);
            BindPointerIndirectionExpressionInternal(node, operand, diagnostics, out var pointedAtType, out var hasErrors);
            return new BoundPointerIndirectionOperator(node, operand, pointedAtType ?? CreateErrorType(), hasErrors);
        }

        private static void BindPointerIndirectionExpressionInternal(CSharpSyntaxNode node, BoundExpression operand, BindingDiagnosticBag diagnostics, out TypeSymbol pointedAtType, out bool hasErrors)
        {
            PointerTypeSymbol pointerTypeSymbol = operand.Type as PointerTypeSymbol;
            hasErrors = operand.HasAnyErrors;
            if ((object)pointerTypeSymbol == null)
            {
                pointedAtType = null;
                if (!hasErrors)
                {
                    Error(diagnostics, ErrorCode.ERR_PtrExpected, node);
                    hasErrors = true;
                }
                return;
            }
            pointedAtType = pointerTypeSymbol.PointedAtType;
            if (pointedAtType.IsVoidType())
            {
                pointedAtType = null;
                if (!hasErrors)
                {
                    Error(diagnostics, ErrorCode.ERR_VoidError, node);
                    hasErrors = true;
                }
            }
        }

        private BoundExpression BindAddressOfExpression(PrefixUnaryExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            BoundExpression boundExpression = BindToNaturalType(BindValue(node.Operand, diagnostics, BindValueKind.AddressOf), diagnostics);
            ReportSuppressionIfNeeded(boundExpression, diagnostics);
            bool flag = boundExpression.HasAnyErrors;
            bool flag2 = SyntaxFacts.IsFixedStatementExpression(node);
            if (!(boundExpression is BoundLambda) && !(boundExpression is UnboundLambda))
            {
                if (boundExpression is BoundMethodGroup operand)
                {
                    return new BoundUnconvertedAddressOfOperator(node, operand, flag);
                }
                TypeSymbol type = boundExpression.Type;
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                ManagedKind managedKind = type.GetManagedKind(ref useSiteInfo);
                diagnostics.Add(node.Location, useSiteInfo);
                bool flag3 = Flags.Includes(BinderFlags.AllowManagedAddressOf);
                if (!flag3)
                {
                    if (!flag)
                    {
                        flag = CheckManagedAddr(Compilation, type, managedKind, node.Location, diagnostics);
                    }
                    if (!flag && IsMoveableVariable(boundExpression, out var _) != flag2)
                    {
                        Error(diagnostics, flag2 ? ErrorCode.ERR_FixedNotNeeded : ErrorCode.ERR_FixedNeeded, node);
                        flag = true;
                    }
                }
                TypeSymbol type2 = new PointerTypeSymbol(TypeWithAnnotations.Create((managedKind == ManagedKind.Managed && flag3) ? GetSpecialType(SpecialType.System_IntPtr, diagnostics, node) : (type ?? CreateErrorType())));
                return new BoundAddressOfOperator(node, boundExpression, type2, flag);
            }
            return new BoundAddressOfOperator(node, boundExpression, CreateErrorType(), hasErrors: true);
        }

        /// <summary>
        /// Checks to see whether an expression is a "moveable" variable according to the spec. Moveable
        /// variables have underlying memory which may be moved by the runtime. The spec defines anything
        /// not fixed as moveable and specifies the expressions which are fixed.
        /// </summary>
        internal bool IsMoveableVariable(BoundExpression expr, out Symbol accessedLocalOrParameterOpt)
        {
            accessedLocalOrParameterOpt = null;

            while (true)
            {
                BoundKind exprKind = expr.Kind;
                switch (exprKind)
                {
                    case BoundKind.FieldAccess:
                    case BoundKind.EventAccess:
                        {
                            FieldSymbol fieldSymbol;
                            BoundExpression receiver;
                            if (exprKind == BoundKind.FieldAccess)
                            {
                                BoundFieldAccess fieldAccess = (BoundFieldAccess)expr;
                                fieldSymbol = fieldAccess.FieldSymbol;
                                receiver = fieldAccess.ReceiverOpt;
                            }
                            else
                            {
                                BoundEventAccess eventAccess = (BoundEventAccess)expr;
                                if (!eventAccess.IsUsableAsField || eventAccess.EventSymbol.IsWindowsRuntimeEvent)
                                {
                                    return true;
                                }
                                EventSymbol eventSymbol = eventAccess.EventSymbol;
                                fieldSymbol = eventSymbol.AssociatedField;
                                receiver = eventAccess.ReceiverOpt;
                            }

                            if ((object)fieldSymbol == null || fieldSymbol.IsStatic || (object)receiver == null)
                            {
                                return true;
                            }

                            bool receiverIsLValue = CheckValueKind(receiver.Syntax, receiver, BindValueKind.AddressOf, checkingReceiver: false, diagnostics: BindingDiagnosticBag.Discarded);

                            if (!receiverIsLValue)
                            {
                                return true;
                            }

                            // NOTE: type parameters will already have been weeded out, since a
                            // variable of type parameter type has to be cast to an effective
                            // base or interface type before its fields can be accessed and a
                            // conversion isn't an lvalue.
                            if (receiver.Type.IsReferenceType)
                            {
                                return true;
                            }

                            expr = receiver;
                            continue;
                        }
                    case BoundKind.RangeVariable:
                        {
                            // NOTE: there are cases where you can take the address of a range variable.
                            // e.g. from x in new int[3] select *(&x)
                            BoundRangeVariable variableAccess = (BoundRangeVariable)expr;
                            expr = variableAccess.Value; //Check the underlying expression.
                            continue;
                        }
                    case BoundKind.Parameter:
                        {
                            BoundParameter parameterAccess = (BoundParameter)expr;
                            ParameterSymbol parameterSymbol = parameterAccess.ParameterSymbol;
                            accessedLocalOrParameterOpt = parameterSymbol;
                            return parameterSymbol.RefKind != RefKind.None;
                        }
                    case BoundKind.ThisReference:
                    case BoundKind.BaseReference:
                        {
                            accessedLocalOrParameterOpt = this.ContainingMemberOrLambda.EnclosingThisSymbol();
                            return true;
                        }
                    case BoundKind.Local:
                        {
                            BoundLocal localAccess = (BoundLocal)expr;
                            LocalSymbol localSymbol = localAccess.LocalSymbol;
                            accessedLocalOrParameterOpt = localSymbol;
                            // NOTE: The spec says that this is moveable if it is captured by an anonymous function,
                            // but that will be reported separately and error-recovery is better if we say that
                            // such locals are not moveable.
                            return localSymbol.RefKind != RefKind.None;
                        }
                    case BoundKind.PointerIndirectionOperator: //Covers ->, since the receiver will be one of these.
                    case BoundKind.ConvertedStackAllocExpression:
                        {
                            return false;
                        }
                    case BoundKind.PointerElementAccess:
                        {
                            // C# 7.3:
                            // a variable resulting from a... pointer_element_access of the form P[E] [is fixed] if P
                            // is not a fixed size buffer expression, or if the expression is a fixed size buffer
                            // member_access of the form E.I and E is a fixed variable
                            BoundExpression underlyingExpr = ((BoundPointerElementAccess)expr).Expression;
                            if (underlyingExpr is BoundFieldAccess fieldAccess && fieldAccess.FieldSymbol.IsFixedSizeBuffer)
                            {
                                expr = fieldAccess.ReceiverOpt;
                                continue;
                            }

                            return false;
                        }
                    case BoundKind.PropertyAccess: // Never fixed
                    case BoundKind.IndexerAccess: // Never fixed
                    default:
                        {
                            return true;
                        }
                }
            }
        }

        private BoundExpression BindUnaryOperator(PrefixUnaryExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            BoundExpression operand = BindToNaturalType(BindValue(node.Operand, diagnostics, GetUnaryAssignmentKind(node.Kind())), diagnostics);
            return BindIntegralMinValConstants(node, operand, diagnostics) ?? BindUnaryOperatorCore(node, node.OperatorToken.Text, operand, diagnostics);
        }

        private void ReportSuppressionIfNeeded(BoundExpression expr, BindingDiagnosticBag diagnostics)
        {
            if (expr.IsSuppressed)
            {
                Error(diagnostics, ErrorCode.ERR_IllegalSuppression, expr.Syntax);
            }
        }

        private BoundExpression BindUnaryOperatorCore(CSharpSyntaxNode node, string operatorText, BoundExpression operand, BindingDiagnosticBag diagnostics)
        {
            UnaryOperatorKind unaryOperatorKind = SyntaxKindToUnaryOperatorKind(node.Kind());
            bool flag = operand.IsLiteralNull() || operand.IsImplicitObjectCreation();
            if (flag)
            {
                Error(diagnostics, ErrorCode.ERR_BadOpOnNullOrDefaultOrNew, node, operatorText, operand.Display);
            }
            if (!flag)
            {
                TypeSymbol? type = operand.Type;
                if ((object)type == null || !type.IsErrorType())
                {
                    if (operand.HasDynamicType())
                    {
                        return new BoundUnaryOperator(node, unaryOperatorKind.WithType(UnaryOperatorKind.Dynamic).WithOverflowChecksIfApplicable(CheckOverflowAtRuntime), operand, null, null, LookupResultKind.Viable, operand.Type);
                    }
                    UnaryOperatorAnalysisResult unaryOperatorAnalysisResult = UnaryOperatorOverloadResolution(unaryOperatorKind, operand, node, diagnostics, out LookupResultKind resultKind, out ImmutableArray<MethodSymbol> originalUserDefinedOperators);
                    if (!unaryOperatorAnalysisResult.HasValue)
                    {
                        ReportUnaryOperatorError(node, diagnostics, operatorText, operand, resultKind);
                        return new BoundUnaryOperator(node, unaryOperatorKind, operand, null, null, resultKind, originalUserDefinedOperators, CreateErrorType(), hasErrors: true);
                    }
                    UnaryOperatorSignature signature = unaryOperatorAnalysisResult.Signature;
                    BoundExpression operand2 = CreateConversion(operand.Syntax, operand, unaryOperatorAnalysisResult.Conversion, isCast: false, null, signature.OperandType, diagnostics);
                    TypeSymbol returnType = signature.ReturnType;
                    UnaryOperatorKind kind = signature.Kind;
                    MethodSymbol method = signature.Method;
                    ConstantValue constantValueOpt = FoldUnaryOperator(node, kind, operand2, returnType.SpecialType, diagnostics);
                    CheckNativeIntegerFeatureAvailability(kind, node, diagnostics);
                    return new BoundUnaryOperator(node, kind.WithOverflowChecksIfApplicable(CheckOverflowAtRuntime), operand2, constantValueOpt, method, resultKind, returnType);
                }
            }
            return new BoundUnaryOperator(node, unaryOperatorKind, operand, null, null, LookupResultKind.Empty, CreateErrorType(), hasErrors: true);
        }

        private ConstantValue? FoldEnumUnaryOperator(CSharpSyntaxNode syntax, UnaryOperatorKind kind, BoundExpression operand, BindingDiagnosticBag diagnostics)
        {
            NamedTypeSymbol enumUnderlyingType = operand.Type.GetEnumUnderlyingType();
            BoundExpression source = CreateConversion(operand, enumUnderlyingType, diagnostics);
            SpecialType enumPromotedType = GetEnumPromotedType(enumUnderlyingType.SpecialType);
            NamedTypeSymbol namedTypeSymbol = ((enumPromotedType == enumUnderlyingType.SpecialType) ? enumUnderlyingType : GetSpecialType(enumPromotedType, diagnostics, syntax));
            source = CreateConversion(source, namedTypeSymbol, diagnostics);
            UnaryOperatorKind kind2 = kind.Operator().WithType(enumPromotedType);
            ConstantValue constantValue = FoldUnaryOperator(syntax, kind2, operand, namedTypeSymbol.SpecialType, diagnostics);
            if (constantValue != null && !constantValue.IsBad)
            {
                return ((kind.Operator() == UnaryOperatorKind.BitwiseComplement) ? WithCheckedOrUncheckedRegion(@checked: false) : this).FoldConstantNumericConversion(syntax, constantValue, enumUnderlyingType, diagnostics);
            }
            return constantValue;
        }

        private ConstantValue? FoldUnaryOperator(CSharpSyntaxNode syntax, UnaryOperatorKind kind, BoundExpression operand, SpecialType resultType, BindingDiagnosticBag diagnostics)
        {
            if (operand.HasAnyErrors)
            {
                return null;
            }
            ConstantValue constantValue = operand.ConstantValue;
            if (constantValue == null || constantValue.IsBad)
            {
                return constantValue;
            }
            if (kind.IsEnum() && !kind.IsLifted())
            {
                return FoldEnumUnaryOperator(syntax, kind, operand, diagnostics);
            }
            object obj = FoldNeverOverflowUnaryOperator(kind, constantValue);
            if (obj != null)
            {
                return ConstantValue.Create(obj, resultType);
            }
            try
            {
                obj = FoldNativeIntegerOverflowingUnaryOperator(kind, constantValue);
            }
            catch (OverflowException)
            {
                if (CheckOverflowAtCompileTime)
                {
                    Error(diagnostics, ErrorCode.ERR_CheckedOverflow, syntax);
                    return ConstantValue.Bad;
                }
                return null;
            }
            if (obj != null)
            {
                return ConstantValue.Create(obj, resultType);
            }
            if (CheckOverflowAtCompileTime)
            {
                try
                {
                    obj = FoldCheckedIntegralUnaryOperator(kind, constantValue);
                }
                catch (OverflowException)
                {
                    Error(diagnostics, ErrorCode.ERR_CheckedOverflow, syntax);
                    return ConstantValue.Bad;
                }
            }
            else
            {
                obj = FoldUncheckedIntegralUnaryOperator(kind, constantValue);
            }
            if (obj != null)
            {
                return ConstantValue.Create(obj, resultType);
            }
            return null;
        }

        private static object? FoldNeverOverflowUnaryOperator(UnaryOperatorKind kind, ConstantValue value)
        {
            switch (kind)
            {
                case UnaryOperatorKind.DecimalUnaryMinus:
                    return -value.DecimalValue;
                case UnaryOperatorKind.FloatUnaryMinus:
                case UnaryOperatorKind.DoubleUnaryMinus:
                    return 0.0 - value.DoubleValue;
                case UnaryOperatorKind.DecimalUnaryPlus:
                    return value.DecimalValue;
                case UnaryOperatorKind.FloatUnaryPlus:
                case UnaryOperatorKind.DoubleUnaryPlus:
                    return value.DoubleValue;
                case UnaryOperatorKind.LongUnaryPlus:
                    return value.Int64Value;
                case UnaryOperatorKind.ULongUnaryPlus:
                    return value.UInt64Value;
                case UnaryOperatorKind.IntUnaryPlus:
                case UnaryOperatorKind.NIntUnaryPlus:
                    return value.Int32Value;
                case UnaryOperatorKind.UIntUnaryPlus:
                case UnaryOperatorKind.NUIntUnaryPlus:
                    return value.UInt32Value;
                case UnaryOperatorKind.BoolLogicalNegation:
                    return !value.BooleanValue;
                case UnaryOperatorKind.IntBitwiseComplement:
                    return ~value.Int32Value;
                case UnaryOperatorKind.LongBitwiseComplement:
                    return ~value.Int64Value;
                case UnaryOperatorKind.UIntBitwiseComplement:
                    return ~value.UInt32Value;
                case UnaryOperatorKind.ULongBitwiseComplement:
                    return ~value.UInt64Value;
                default:
                    return null;
            }
        }

        private static object? FoldUncheckedIntegralUnaryOperator(UnaryOperatorKind kind, ConstantValue value)
        {
            return kind switch
            {
                UnaryOperatorKind.LongUnaryMinus => -value.Int64Value,
                UnaryOperatorKind.IntUnaryMinus => -value.Int32Value,
                _ => null,
            };
        }

        private static object? FoldCheckedIntegralUnaryOperator(UnaryOperatorKind kind, ConstantValue value)
        {
            return checked(kind switch
            {
                UnaryOperatorKind.LongUnaryMinus => -value.Int64Value,
                UnaryOperatorKind.IntUnaryMinus => -value.Int32Value,
                _ => null,
            });
        }

        private static object? FoldNativeIntegerOverflowingUnaryOperator(UnaryOperatorKind kind, ConstantValue value)
        {
            switch (kind)
            {
                case UnaryOperatorKind.NIntUnaryMinus:
                    return checked(-value.Int32Value);
                case UnaryOperatorKind.NIntBitwiseComplement:
                case UnaryOperatorKind.NUIntBitwiseComplement:
                    return null;
                default:
                    return null;
            }
        }

        private static UnaryOperatorKind SyntaxKindToUnaryOperatorKind(SyntaxKind kind)
        {
            return kind switch
            {
                SyntaxKind.PreIncrementExpression => UnaryOperatorKind.PrefixIncrement,
                SyntaxKind.PostIncrementExpression => UnaryOperatorKind.PostfixIncrement,
                SyntaxKind.PreDecrementExpression => UnaryOperatorKind.PrefixDecrement,
                SyntaxKind.PostDecrementExpression => UnaryOperatorKind.PostfixDecrement,
                SyntaxKind.UnaryPlusExpression => UnaryOperatorKind.UnaryPlus,
                SyntaxKind.UnaryMinusExpression => UnaryOperatorKind.UnaryMinus,
                SyntaxKind.LogicalNotExpression => UnaryOperatorKind.LogicalNegation,
                SyntaxKind.BitwiseNotExpression => UnaryOperatorKind.BitwiseComplement,
                _ => throw ExceptionUtilities.UnexpectedValue(kind),
            };
        }

        private static BindValueKind GetBinaryAssignmentKind(SyntaxKind kind)
        {
            switch (kind)
            {
                case SyntaxKind.SimpleAssignmentExpression:
                    return BindValueKind.Assignable;
                case SyntaxKind.AddAssignmentExpression:
                case SyntaxKind.SubtractAssignmentExpression:
                case SyntaxKind.MultiplyAssignmentExpression:
                case SyntaxKind.DivideAssignmentExpression:
                case SyntaxKind.ModuloAssignmentExpression:
                case SyntaxKind.AndAssignmentExpression:
                case SyntaxKind.ExclusiveOrAssignmentExpression:
                case SyntaxKind.OrAssignmentExpression:
                case SyntaxKind.LeftShiftAssignmentExpression:
                case SyntaxKind.RightShiftAssignmentExpression:
                case SyntaxKind.CoalesceAssignmentExpression:
                    return BindValueKind.CompoundAssignment;
                default:
                    return BindValueKind.RValue;
            }
        }

        private static BindValueKind GetUnaryAssignmentKind(SyntaxKind kind)
        {
            switch (kind)
            {
                case SyntaxKind.PreIncrementExpression:
                case SyntaxKind.PreDecrementExpression:
                case SyntaxKind.PostIncrementExpression:
                case SyntaxKind.PostDecrementExpression:
                    return BindValueKind.IncrementDecrement;
                default:
                    return BindValueKind.RValue;
            }
        }

        private BoundLiteral BindIntegralMinValConstants(PrefixUnaryExpressionSyntax node, BoundExpression operand, BindingDiagnosticBag diagnostics)
        {
            if (node.Kind() != SyntaxKind.UnaryMinusExpression)
            {
                return null;
            }
            if (node.Operand != operand.Syntax || operand.Syntax.Kind() != SyntaxKind.NumericLiteralExpression)
            {
                return null;
            }
            SyntaxToken token = ((LiteralExpressionSyntax)operand.Syntax).Token;
            if (token.Value is uint)
            {
                if ((uint)token.Value != 2147483648u)
                {
                    return null;
                }
                if (token.Text.Contains("u") || token.Text.Contains("U") || token.Text.Contains("l") || token.Text.Contains("L"))
                {
                    return null;
                }
                return new BoundLiteral(node, ConstantValue.Create(int.MinValue), GetSpecialType(SpecialType.System_Int32, diagnostics, node));
            }
            if (token.Value is ulong)
            {
                if ((ulong)token.Value != 9223372036854775808uL)
                {
                    return null;
                }
                if (token.Text.Contains("u") || token.Text.Contains("U"))
                {
                    return null;
                }
                return new BoundLiteral(node, ConstantValue.Create(long.MinValue), GetSpecialType(SpecialType.System_Int64, diagnostics, node));
            }
            return null;
        }

        private static bool IsDivisionByZero(BinaryOperatorKind kind, ConstantValue valueRight)
        {
            switch (kind)
            {
                case BinaryOperatorKind.DecimalDivision:
                case BinaryOperatorKind.DecimalRemainder:
                    return valueRight.DecimalValue == 0.0m;
                case BinaryOperatorKind.IntDivision:
                case BinaryOperatorKind.NIntDivision:
                case BinaryOperatorKind.IntRemainder:
                case BinaryOperatorKind.NIntRemainder:
                    return valueRight.Int32Value == 0;
                case BinaryOperatorKind.LongDivision:
                case BinaryOperatorKind.LongRemainder:
                    return valueRight.Int64Value == 0;
                case BinaryOperatorKind.UIntDivision:
                case BinaryOperatorKind.NUIntDivision:
                case BinaryOperatorKind.UIntRemainder:
                case BinaryOperatorKind.NUIntRemainder:
                    return valueRight.UInt32Value == 0;
                case BinaryOperatorKind.ULongDivision:
                case BinaryOperatorKind.ULongRemainder:
                    return valueRight.UInt64Value == 0;
                default:
                    return false;
            }
        }

        private bool IsOperandErrors(CSharpSyntaxNode node, ref BoundExpression operand, BindingDiagnosticBag diagnostics)
        {
            BoundKind kind = operand.Kind;
            if (kind == BoundKind.MethodGroup || kind - 174 <= BoundKind.PropertyEqualsValue)
            {
                if (!operand.HasAnyErrors)
                {
                    Error(diagnostics, ErrorCode.ERR_LambdaInIsAs, node);
                }
                operand = BadExpression(node, operand).MakeCompilerGenerated();
                return true;
            }
            if ((object)operand.Type == null && !operand.IsLiteralNull())
            {
                if (!operand.HasAnyErrors)
                {
                    Error(diagnostics, ErrorCode.ERR_BadUnaryOp, node, SyntaxFacts.GetText(SyntaxKind.IsKeyword), operand.Display);
                }
                operand = BadExpression(node, operand).MakeCompilerGenerated();
                return true;
            }
            return operand.HasAnyErrors;
        }

        private bool IsOperatorErrors(CSharpSyntaxNode node, TypeSymbol operandType, BoundTypeExpression typeExpression, BindingDiagnosticBag diagnostics)
        {
            TypeSymbol type = typeExpression.Type;
            if (type.IsStatic)
            {
                Error(diagnostics, ErrorCode.WRN_StaticInAsOrIs, node, type);
            }
            if (((object)operandType != null && operandType.IsPointerOrFunctionPointer()) || type.IsPointerOrFunctionPointer())
            {
                Error(diagnostics, ErrorCode.ERR_PointerInAsOrIs, node);
                return true;
            }
            return type.TypeKind == TypeKind.Error;
        }

        protected static bool IsUnderscore(ExpressionSyntax node)
        {
            if (node is IdentifierNameSyntax identifierNameSyntax)
            {
                return identifierNameSyntax.Identifier.IsUnderscoreToken();
            }
            return false;
        }

        private BoundExpression BindIsOperator(BinaryExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            TypeSymbol specialType = GetSpecialType(SpecialType.System_Boolean, diagnostics, node);
            BoundExpression operand = BindRValueWithoutTargetType(node.Left, diagnostics);
            bool flag = IsOperandErrors(node, ref operand, diagnostics);
            bool flag2 = IsUnderscore(node.Right);
            if (!tryBindAsType(node.Right, diagnostics, out var bindAsTypeDiagnostics2, out var boundType2) && !flag2 && ((CSharpParseOptions)node.SyntaxTree.Options).IsFeatureEnabled(MessageID.IDS_FeaturePatternMatching))
            {
                BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(diagnostics);
                if ((object)operand.Type == null)
                {
                    if (!flag)
                    {
                        instance.Add(ErrorCode.ERR_BadPatternExpression, node.Left.Location, operand.Display);
                    }
                    operand = ToBadExpression(operand);
                }
                bool hasErrors = node.Right.HasErrors;
                BoundExpression boundExpression = BindExpressionForPattern(operand.Type, node.Right, ref hasErrors, instance, out ConstantValue constantValueOpt, out bool wasExpression);
                if (wasExpression)
                {
                    hasErrors = hasErrors || (object)constantValueOpt == null;
                    bindAsTypeDiagnostics2.Free();
                    diagnostics.AddRangeAndFree(instance);
                    BoundConstantPattern pattern = new BoundConstantPattern(node.Right, boundExpression, constantValueOpt ?? ConstantValue.Bad, operand.Type, boundExpression.Type ?? operand.Type, hasErrors)
                    {
                        WasCompilerGenerated = true
                    };
                    return MakeIsPatternExpression(node, operand, pattern, specialType, flag, diagnostics);
                }
                instance.Free();
            }
            diagnostics.AddRangeAndFree(bindAsTypeDiagnostics2);
            TypeWithAnnotations typeWithAnnotations = boundType2.TypeWithAnnotations;
            TypeSymbol type = boundType2.Type;
            if (type.IsReferenceType && typeWithAnnotations.NullableAnnotation.IsAnnotated())
            {
                Error(diagnostics, ErrorCode.ERR_IsNullableType, node.Right, type);
                flag = true;
            }
            TypeKind typeKind = type.TypeKind;
            if (flag || IsOperatorErrors(node, operand.Type, boundType2, diagnostics))
            {
                return new BoundIsOperator(node, operand, boundType2, Conversion.NoConversion, specialType, hasErrors: true);
            }
            if (flag2 && ((CSharpParseOptions)node.SyntaxTree.Options).IsFeatureEnabled(MessageID.IDS_FeatureRecursivePatterns))
            {
                diagnostics.Add(ErrorCode.WRN_IsTypeNamedUnderscore, node.Right.Location, boundType2.AliasOpt ?? ((object)type));
            }
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            if (operand.ConstantValue == ConstantValue.Null || operand.Kind == BoundKind.MethodGroup || operand.Type.IsVoidType())
            {
                Error(diagnostics, ErrorCode.WRN_IsAlwaysFalse, node, type);
                Conversion conversion = Conversions.ClassifyConversionFromExpression(operand, type, ref useSiteInfo);
                diagnostics.Add(node, useSiteInfo);
                return new BoundIsOperator(node, operand, boundType2, conversion, specialType);
            }
            if (typeKind == TypeKind.Dynamic)
            {
                Error(diagnostics, ErrorCode.WRN_IsDynamicIsConfusing, node, node.OperatorToken.Text, type.Name, GetSpecialType(SpecialType.System_Object, diagnostics, node).Name);
            }
            TypeSymbol typeSymbol = operand.Type;
            if (typeSymbol.TypeKind == TypeKind.Dynamic)
            {
                typeSymbol = GetSpecialType(SpecialType.System_Object, diagnostics, node);
            }
            Conversion conversion2 = Conversions.ClassifyBuiltInConversion(typeSymbol, type, ref useSiteInfo);
            diagnostics.Add(node, useSiteInfo);
            ReportIsOperatorConstantWarnings(node, diagnostics, typeSymbol, type, conversion2.Kind, operand.ConstantValue);
            return new BoundIsOperator(node, operand, boundType2, conversion2, specialType);
            bool tryBindAsType(ExpressionSyntax possibleType, BindingDiagnosticBag diagnostics, out BindingDiagnosticBag bindAsTypeDiagnostics, out BoundTypeExpression boundType)
            {
                bindAsTypeDiagnostics = BindingDiagnosticBag.GetInstance(withDiagnostics: true, diagnostics.AccumulatesDependencies);
                TypeWithAnnotations typeWithAnnotations2 = BindType(possibleType, bindAsTypeDiagnostics, out AliasSymbol alias);
                TypeSymbol type2 = typeWithAnnotations2.Type;
                boundType = new BoundTypeExpression(possibleType, alias, typeWithAnnotations2);
                if ((object)type2 != null && type2.IsErrorType())
                {
                    return !bindAsTypeDiagnostics.HasAnyResolvedErrors();
                }
                return true;
            }
        }

        private static void ReportIsOperatorConstantWarnings(CSharpSyntaxNode syntax, BindingDiagnosticBag diagnostics, TypeSymbol operandType, TypeSymbol targetType, ConversionKind conversionKind, ConstantValue operandConstantValue)
        {
            ConstantValue isOperatorConstantResult = GetIsOperatorConstantResult(operandType, targetType, conversionKind, operandConstantValue);
            if (isOperatorConstantResult != null)
            {
                ErrorCode code = ((isOperatorConstantResult == ConstantValue.True) ? ErrorCode.WRN_IsAlwaysTrue : ErrorCode.WRN_IsAlwaysFalse);
                Error(diagnostics, code, syntax, targetType);
            }
        }

        internal static ConstantValue GetIsOperatorConstantResult(TypeSymbol operandType, TypeSymbol targetType, ConversionKind conversionKind, ConstantValue operandConstantValue, bool operandCouldBeNull = true)
        {
            if (operandConstantValue == ConstantValue.Null)
            {
                return ConstantValue.False;
            }
            operandCouldBeNull = operandCouldBeNull && operandType.CanContainNull() && (operandConstantValue == null || operandConstantValue == ConstantValue.Null);
            switch (conversionKind)
            {
                case ConversionKind.NoConversion:
                    if (!operandType.ContainsTypeParameter() && !targetType.ContainsTypeParameter())
                    {
                        return ConstantValue.False;
                    }
                    if ((operandType.IsValueType && targetType.IsClassType() && targetType.SpecialType != SpecialType.System_Enum) || (targetType.IsValueType && operandType.IsClassType() && operandType.SpecialType != SpecialType.System_Enum))
                    {
                        return ConstantValue.False;
                    }
                    if (targetType.IsRestrictedType() || operandType.IsRestrictedType())
                    {
                        return ConstantValue.False;
                    }
                    return null;
                case ConversionKind.ImplicitNumeric:
                case ConversionKind.ImplicitEnumeration:
                case ConversionKind.ImplicitTuple:
                case ConversionKind.ExplicitTuple:
                case ConversionKind.ImplicitConstant:
                case ConversionKind.ImplicitUserDefined:
                case ConversionKind.ExplicitNumeric:
                case ConversionKind.ExplicitUserDefined:
                case ConversionKind.IntPtr:
                    return ConstantValue.False;
                case ConversionKind.ExplicitEnumeration:
                    if (!operandType.IsEnumType() || !targetType.IsEnumType())
                    {
                        return ConstantValue.False;
                    }
                    goto case ConversionKind.NoConversion;
                case ConversionKind.ExplicitNullable:
                    if (targetType.IsNullableType())
                    {
                        return ConstantValue.False;
                    }
                    if (ConversionsBase.HasIdentityConversion(operandType.GetNullableUnderlyingType(), targetType))
                    {
                        if (!operandCouldBeNull)
                        {
                            return ConstantValue.True;
                        }
                        return null;
                    }
                    return ConstantValue.False;
                case ConversionKind.ImplicitReference:
                    if (!operandCouldBeNull)
                    {
                        return ConstantValue.True;
                    }
                    return null;
                case ConversionKind.ExplicitReference:
                case ConversionKind.Unboxing:
                    return null;
                case ConversionKind.Identity:
                    if (!operandCouldBeNull)
                    {
                        return ConstantValue.True;
                    }
                    return null;
                case ConversionKind.Boxing:
                    if (!operandCouldBeNull)
                    {
                        return ConstantValue.True;
                    }
                    return null;
                case ConversionKind.ImplicitNullable:
                    if (!operandType.Equals(targetType.GetNullableUnderlyingType(), TypeCompareKind.AllIgnoreOptions))
                    {
                        return ConstantValue.False;
                    }
                    return ConstantValue.True;
                default:
                    throw ExceptionUtilities.UnexpectedValue(conversionKind);
            }
        }

        private BoundExpression BindAsOperator(BinaryExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            BoundExpression boundExpression = BindRValueWithoutTargetType(node.Left, diagnostics);
            TypeWithAnnotations typeWithAnnotations = BindType(node.Right, diagnostics, out AliasSymbol alias);
            TypeSymbol typeSymbol = typeWithAnnotations.Type;
            BoundTypeExpression targetType = new BoundTypeExpression(node.Right, alias, typeWithAnnotations);
            TypeKind typeKind = typeSymbol.TypeKind;
            TypeSymbol type = typeSymbol;
            switch (boundExpression.Kind)
            {
                case BoundKind.MethodGroup:
                case BoundKind.Lambda:
                case BoundKind.UnboundLambda:
                    if (!boundExpression.HasAnyErrors)
                    {
                        Error(diagnostics, ErrorCode.ERR_LambdaInIsAs, node);
                    }
                    return new BoundAsOperator(node, boundExpression, targetType, Conversion.NoConversion, type, hasErrors: true);
                case BoundKind.TupleLiteral:
                case BoundKind.ConvertedTupleLiteral:
                    if ((object)boundExpression.Type == null)
                    {
                        Error(diagnostics, ErrorCode.ERR_TypelessTupleInAs, node);
                        return new BoundAsOperator(node, boundExpression, targetType, Conversion.NoConversion, type, hasErrors: true);
                    }
                    break;
            }
            if (boundExpression.HasAnyErrors || typeKind == TypeKind.Error)
            {
                return new BoundAsOperator(node, boundExpression, targetType, Conversion.NoConversion, type, hasErrors: true);
            }
            if (typeSymbol.IsReferenceType && typeWithAnnotations.NullableAnnotation.IsAnnotated())
            {
                Error(diagnostics, ErrorCode.ERR_AsNullableType, node.Right, typeSymbol);
                return new BoundAsOperator(node, boundExpression, targetType, Conversion.NoConversion, type, hasErrors: true);
            }
            if (!typeSymbol.IsReferenceType && !typeSymbol.IsNullableType())
            {
                switch (typeKind)
                {
                    case TypeKind.TypeParameter:
                        Error(diagnostics, ErrorCode.ERR_AsWithTypeVar, node, typeSymbol);
                        break;
                    case TypeKind.Pointer:
                    case TypeKind.FunctionPointer:
                        Error(diagnostics, ErrorCode.ERR_PointerInAsOrIs, node);
                        break;
                    default:
                        Error(diagnostics, ErrorCode.ERR_AsMustHaveReferenceType, node, typeSymbol);
                        break;
                }
                return new BoundAsOperator(node, boundExpression, targetType, Conversion.NoConversion, type, hasErrors: true);
            }
            if (typeSymbol.IsStatic)
            {
                Error(diagnostics, ErrorCode.WRN_StaticInAsOrIs, node, typeSymbol);
            }
            if (boundExpression.IsLiteralNull())
            {
                return new BoundAsOperator(node, boundExpression, targetType, Conversion.NullLiteral, type);
            }
            if (boundExpression.IsLiteralDefault())
            {
                boundExpression = new BoundDefaultExpression(boundExpression.Syntax, null, ConstantValue.Null, GetSpecialType(SpecialType.System_Object, diagnostics, node));
            }
            TypeSymbol typeSymbol2 = boundExpression.Type;
            TypeKind typeKind2 = typeSymbol2.TypeKind;
            if (typeSymbol2.IsPointerOrFunctionPointer())
            {
                Error(diagnostics, ErrorCode.ERR_PointerInAsOrIs, node);
                return new BoundAsOperator(node, boundExpression, targetType, Conversion.NoConversion, type, hasErrors: true);
            }
            if (typeKind2 == TypeKind.Dynamic)
            {
                typeSymbol2 = GetSpecialType(SpecialType.System_Object, diagnostics, node);
                typeKind2 = typeSymbol2.TypeKind;
            }
            if (typeKind == TypeKind.Dynamic)
            {
                typeSymbol = GetSpecialType(SpecialType.System_Object, diagnostics, node);
                typeKind = typeSymbol.TypeKind;
            }
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            Conversion conversion = Conversions.ClassifyBuiltInConversion(typeSymbol2, typeSymbol, ref useSiteInfo);
            diagnostics.Add(node, useSiteInfo);
            bool hasErrors = ReportAsOperatorConversionDiagnostics(node, diagnostics, Compilation, typeSymbol2, typeSymbol, conversion.Kind, boundExpression.ConstantValue);
            return new BoundAsOperator(node, boundExpression, targetType, conversion, type, hasErrors);
        }

        private static bool ReportAsOperatorConversionDiagnostics(CSharpSyntaxNode node, BindingDiagnosticBag diagnostics, CSharpCompilation compilation, TypeSymbol operandType, TypeSymbol targetType, ConversionKind conversionKind, ConstantValue operandConstantValue)
        {
            bool flag = false;
            switch (conversionKind)
            {
                default:
                    if ((!operandType.ContainsTypeParameter() && !targetType.ContainsTypeParameter()) || operandType.IsVoidType())
                    {
                        SymbolDistinguisher symbolDistinguisher = new SymbolDistinguisher(compilation, operandType, targetType);
                        Error(diagnostics, ErrorCode.ERR_NoExplicitBuiltinConv, node, symbolDistinguisher.First, symbolDistinguisher.Second);
                        flag = true;
                    }
                    break;
                case ConversionKind.Identity:
                case ConversionKind.ImplicitNullable:
                case ConversionKind.ImplicitReference:
                case ConversionKind.Boxing:
                case ConversionKind.ExplicitNullable:
                case ConversionKind.ExplicitReference:
                case ConversionKind.Unboxing:
                    break;
            }
            if (!flag)
            {
                ReportAsOperatorConstantWarnings(node, diagnostics, operandType, targetType, conversionKind, operandConstantValue);
            }
            return flag;
        }

        private static void ReportAsOperatorConstantWarnings(CSharpSyntaxNode node, BindingDiagnosticBag diagnostics, TypeSymbol operandType, TypeSymbol targetType, ConversionKind conversionKind, ConstantValue operandConstantValue)
        {
            if (GetAsOperatorConstantResult(operandType, targetType, conversionKind, operandConstantValue) != null)
            {
                Error(diagnostics, ErrorCode.WRN_AlwaysNull, node, targetType);
            }
        }

        internal static ConstantValue GetAsOperatorConstantResult(TypeSymbol operandType, TypeSymbol targetType, ConversionKind conversionKind, ConstantValue operandConstantValue)
        {
            ConstantValue isOperatorConstantResult = GetIsOperatorConstantResult(operandType, targetType, conversionKind, operandConstantValue);
            if (isOperatorConstantResult != null && !isOperatorConstantResult.BooleanValue)
            {
                return ConstantValue.Null;
            }
            return null;
        }

        private BoundExpression GenerateNullCoalescingBadBinaryOpsError(BinaryExpressionSyntax node, BoundExpression leftOperand, BoundExpression rightOperand, Conversion leftConversion, BindingDiagnosticBag diagnostics)
        {
            Error(diagnostics, ErrorCode.ERR_BadBinaryOps, node, SyntaxFacts.GetText(node.OperatorToken.Kind()), leftOperand.Display, rightOperand.Display);
            leftOperand = BindToTypeForErrorRecovery(leftOperand);
            rightOperand = BindToTypeForErrorRecovery(rightOperand);
            return new BoundNullCoalescingOperator(node, leftOperand, rightOperand, leftConversion, BoundNullCoalescingOperatorResultKind.NoCommonType, CreateErrorType(), hasErrors: true);
        }

        private BoundExpression BindNullCoalescingOperator(BinaryExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            BoundExpression expression = BindValue(node.Left, diagnostics, BindValueKind.RValue);
            expression = BindToNaturalType(expression, diagnostics);
            BoundExpression boundExpression = BindValue(node.Right, diagnostics, BindValueKind.RValue);
            if (expression.HasAnyErrors || boundExpression.HasAnyErrors)
            {
                expression = BindToTypeForErrorRecovery(expression);
                boundExpression = BindToTypeForErrorRecovery(boundExpression);
                return new BoundNullCoalescingOperator(node, expression, boundExpression, Conversion.NoConversion, BoundNullCoalescingOperatorResultKind.NoCommonType, CreateErrorType(), hasErrors: true);
            }
            if (expression.IsLiteralDefault())
            {
                Error(diagnostics, ErrorCode.ERR_BadOpOnNullOrDefaultOrNew, node, node.OperatorToken.Text, "default");
                return new BoundNullCoalescingOperator(node, expression, boundExpression, Conversion.NoConversion, BoundNullCoalescingOperatorResultKind.NoCommonType, CreateErrorType(), hasErrors: true);
            }
            TypeSymbol type = expression.Type;
            TypeSymbol type2 = boundExpression.Type;
            bool flag = type?.IsNullableType() ?? false;
            TypeSymbol typeSymbol = (flag ? type.GetNullableUnderlyingType() : type);
            if (expression.Kind == BoundKind.UnboundLambda || expression.Kind == BoundKind.MethodGroup)
            {
                return GenerateNullCoalescingBadBinaryOpsError(node, expression, boundExpression, Conversion.NoConversion, diagnostics);
            }
            if ((object)type != null && !type.IsReferenceType && !flag)
            {
                if (type.IsValueType)
                {
                    return GenerateNullCoalescingBadBinaryOpsError(node, expression, boundExpression, Conversion.NoConversion, diagnostics);
                }
                CheckFeatureAvailability(node, MessageID.IDS_FeatureUnconstrainedTypeParameterInNullCoalescingOperator, diagnostics);
            }
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            if ((object)type2 != null && type2.IsDynamic())
            {
                Conversion leftConversion = Conversions.ClassifyConversionFromExpression(expression, GetSpecialType(SpecialType.System_Object, diagnostics, node), ref useSiteInfo);
                boundExpression = BindToNaturalType(boundExpression, diagnostics);
                diagnostics.Add(node, useSiteInfo);
                return new BoundNullCoalescingOperator(node, expression, boundExpression, leftConversion, BoundNullCoalescingOperatorResultKind.RightDynamicType, type2);
            }
            if (flag)
            {
                Conversion conversion = Conversions.ClassifyImplicitConversionFromExpression(boundExpression, typeSymbol, ref useSiteInfo);
                if (conversion.Exists)
                {
                    Conversion leftConversion2 = Conversions.ClassifyConversionFromExpression(expression, typeSymbol, ref useSiteInfo);
                    diagnostics.Add(node, useSiteInfo);
                    BoundExpression rightOperand = CreateConversion(boundExpression, conversion, typeSymbol, diagnostics);
                    return new BoundNullCoalescingOperator(node, expression, rightOperand, leftConversion2, BoundNullCoalescingOperatorResultKind.LeftUnwrappedType, typeSymbol);
                }
            }
            if ((object)type != null)
            {
                Conversion conversion2 = Conversions.ClassifyImplicitConversionFromExpression(boundExpression, type, ref useSiteInfo);
                if (conversion2.Exists)
                {
                    BoundExpression rightOperand2 = CreateConversion(boundExpression, conversion2, type, diagnostics);
                    Conversion identity = Conversion.Identity;
                    diagnostics.Add(node, useSiteInfo);
                    return new BoundNullCoalescingOperator(node, expression, rightOperand2, identity, BoundNullCoalescingOperatorResultKind.LeftType, type);
                }
            }
            if ((object)type2 != null)
            {
                boundExpression = BindToNaturalType(boundExpression, diagnostics);
                Conversion conversion3;
                BoundNullCoalescingOperatorResultKind operatorResultKind;
                if (flag)
                {
                    conversion3 = Conversions.ClassifyImplicitConversionFromType(typeSymbol, type2, ref useSiteInfo);
                    operatorResultKind = BoundNullCoalescingOperatorResultKind.LeftUnwrappedRightType;
                }
                else
                {
                    conversion3 = Conversions.ClassifyImplicitConversionFromExpression(expression, type2, ref useSiteInfo);
                    operatorResultKind = BoundNullCoalescingOperatorResultKind.RightType;
                }
                if (conversion3.Exists)
                {
                    if (!conversion3.IsValid)
                    {
                        if (flag)
                        {
                            Conversion conversion4 = Conversion.MakeNullableConversion(ConversionKind.ExplicitNullable, conversion3);
                            BoundExpression source = CreateConversion(expression, conversion4, typeSymbol, diagnostics);
                            expression = CreateConversion(source, conversion3, type2, diagnostics);
                        }
                        else
                        {
                            expression = CreateConversion(expression, conversion3, type2, diagnostics);
                        }
                    }
                    else
                    {
                        ReportDiagnosticsIfObsolete(diagnostics, conversion3, node, hasBaseReceiver: false);
                    }
                    diagnostics.Add(node, useSiteInfo);
                    return new BoundNullCoalescingOperator(node, expression, boundExpression, conversion3, operatorResultKind, type2);
                }
            }
            diagnostics.Add(node, useSiteInfo);
            return GenerateNullCoalescingBadBinaryOpsError(node, expression, boundExpression, Conversion.NoConversion, diagnostics);
        }

        private BoundExpression BindNullCoalescingAssignmentOperator(AssignmentExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            BoundExpression boundExpression = BindValue(node.Left, diagnostics, BindValueKind.CompoundAssignment);
            ReportSuppressionIfNeeded(boundExpression, diagnostics);
            BoundExpression boundExpression2 = BindValue(node.Right, diagnostics, BindValueKind.RValue);
            if (boundExpression.HasAnyErrors || boundExpression2.HasAnyErrors)
            {
                boundExpression = BindToTypeForErrorRecovery(boundExpression);
                boundExpression2 = BindToTypeForErrorRecovery(boundExpression2);
                return new BoundNullCoalescingAssignmentOperator(node, boundExpression, boundExpression2, CreateErrorType(), hasErrors: true);
            }
            TypeSymbol type = boundExpression.Type;
            if (type.IsValueType && !type.IsNullableType())
            {
                return GenerateNullCoalescingAssignmentBadBinaryOpsError(node, boundExpression, boundExpression2, diagnostics);
            }
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            if (type.IsNullableType())
            {
                TypeSymbol nullableUnderlyingType = type.GetNullableUnderlyingType();
                Conversion conversion = Conversions.ClassifyImplicitConversionFromExpression(boundExpression2, nullableUnderlyingType, ref useSiteInfo);
                if (conversion.Exists)
                {
                    TypeSymbol? type2 = boundExpression2.Type;
                    if ((object)type2 == null || !type2.IsDynamic())
                    {
                        diagnostics.Add(node, useSiteInfo);
                        BoundExpression rightOperand = CreateConversion(boundExpression2, conversion, nullableUnderlyingType, diagnostics);
                        return new BoundNullCoalescingAssignmentOperator(node, boundExpression, rightOperand, nullableUnderlyingType);
                    }
                }
            }
            useSiteInfo = new CompoundUseSiteInfo<AssemblySymbol>(useSiteInfo);
            Conversion conversion2 = Conversions.ClassifyImplicitConversionFromExpression(boundExpression2, type, ref useSiteInfo);
            diagnostics.Add(node, useSiteInfo);
            if (conversion2.Exists)
            {
                BoundExpression rightOperand2 = CreateConversion(boundExpression2, conversion2, type, diagnostics);
                return new BoundNullCoalescingAssignmentOperator(node, boundExpression, rightOperand2, type);
            }
            return GenerateNullCoalescingAssignmentBadBinaryOpsError(node, boundExpression, boundExpression2, diagnostics);
        }

        private BoundExpression GenerateNullCoalescingAssignmentBadBinaryOpsError(AssignmentExpressionSyntax node, BoundExpression leftOperand, BoundExpression rightOperand, BindingDiagnosticBag diagnostics)
        {
            Error(diagnostics, ErrorCode.ERR_BadBinaryOps, node, SyntaxFacts.GetText(node.OperatorToken.Kind()), leftOperand.Display, rightOperand.Display);
            leftOperand = BindToTypeForErrorRecovery(leftOperand);
            rightOperand = BindToTypeForErrorRecovery(rightOperand);
            return new BoundNullCoalescingAssignmentOperator(node, leftOperand, rightOperand, CreateErrorType(), hasErrors: true);
        }

        /// <remarks>
        /// From ExpressionBinder::EnsureQMarkTypesCompatible:
        ///
        /// The v2.0 specification states that the types of the second and third operands T and S of a conditional operator
        /// must be TT and TS such that either (a) TT==TS, or (b), TT->TS or TS->TT but not both.
        ///
        /// Unfortunately that is not what we implemented in v2.0.  Instead, we implemented
        /// that either (a) TT=TS or (b) T->TS or S->TT but not both.  That is, we looked at the
        /// convertibility of the expressions, not the types.
        ///
        ///
        /// Changing that to the algorithm in the standard would be a breaking change.
        ///
        /// b ? (Func&lt;int&gt;)(delegate(){return 1;}) : (delegate(){return 2;})
        ///
        /// and
        ///
        /// b ? 0 : myenum
        ///
        /// would suddenly stop working.  (The first because o2 has no type, the second because 0 goes to
        /// any enum but enum doesn't go to int.)
        ///
        /// It gets worse.  We would like the 3.0 language features which require type inference to use
        /// a consistent algorithm, and that furthermore, the algorithm be smart about choosing the best
        /// of a set of types.  However, the language committee has decided that this algorithm will NOT
        /// consume information about the convertibility of expressions. Rather, it will gather up all
        /// the possible types and then pick the "largest" of them.
        ///
        /// To maintain backwards compatibility while still participating in the spirit of consistency,
        /// we implement an algorithm here which picks the type based on expression convertibility, but
        /// if there is a conflict, then it chooses the larger type rather than producing a type error.
        /// This means that b?0:myshort will have type int rather than producing an error (because 0->short,
        /// myshort->int).
        /// </remarks>
        private BoundExpression BindConditionalOperator(ConditionalExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            var whenTrue = node.WhenTrue.CheckAndUnwrapRefExpression(diagnostics, out var whenTrueRefKind);
            var whenFalse = node.WhenFalse.CheckAndUnwrapRefExpression(diagnostics, out var whenFalseRefKind);

            var isRef = whenTrueRefKind == RefKind.Ref && whenFalseRefKind == RefKind.Ref;
            if (!isRef)
            {
                if (whenFalseRefKind == RefKind.Ref)
                {
                    diagnostics.Add(ErrorCode.ERR_RefConditionalNeedsTwoRefs, whenFalse.GetFirstToken().GetLocation());
                }

                if (whenTrueRefKind == RefKind.Ref)
                {
                    diagnostics.Add(ErrorCode.ERR_RefConditionalNeedsTwoRefs, whenTrue.GetFirstToken().GetLocation());
                }
            }
            else
            {
                CheckFeatureAvailability(node, MessageID.IDS_FeatureRefConditional, diagnostics);
            }

            return isRef ? BindRefConditionalOperator(node, whenTrue, whenFalse, diagnostics) : BindValueConditionalOperator(node, whenTrue, whenFalse, diagnostics);
        }

        private BoundExpression BindValueConditionalOperator(ConditionalExpressionSyntax node, ExpressionSyntax whenTrue, ExpressionSyntax whenFalse, BindingDiagnosticBag diagnostics)
        {
            BoundExpression condition = BindBooleanExpression(node.Condition, diagnostics);
            BoundExpression boundExpression = BindValue(whenTrue, diagnostics, BindValueKind.RValue);
            BoundExpression boundExpression2 = BindValue(whenFalse, diagnostics, BindValueKind.RValue);
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            ConstantValue constantValue = null;
            TypeSymbol typeSymbol = BestTypeInferrer.InferBestTypeForConditionalOperator(boundExpression, boundExpression2, Conversions, out bool hadMultipleCandidates, ref useSiteInfo);
            diagnostics.Add(node, useSiteInfo);
            if ((object)typeSymbol == null)
            {
                ErrorCode noCommonTypeError = (hadMultipleCandidates ? ErrorCode.ERR_AmbigQM : ErrorCode.ERR_InvalidQM);
                constantValue = FoldConditionalOperator(condition, boundExpression, boundExpression2);
                return new BoundUnconvertedConditionalOperator(node, condition, boundExpression, boundExpression2, constantValue, noCommonTypeError, null, constantValue?.IsBad ?? false);
            }
            TypeSymbol typeSymbol2;
            bool flag;
            if (typeSymbol.IsErrorType())
            {
                boundExpression = BindToNaturalType(boundExpression, diagnostics, reportNoTargetType: false);
                boundExpression2 = BindToNaturalType(boundExpression2, diagnostics, reportNoTargetType: false);
                typeSymbol2 = typeSymbol;
                flag = true;
            }
            else
            {
                boundExpression = GenerateConversionForAssignment(typeSymbol, boundExpression, diagnostics);
                boundExpression2 = GenerateConversionForAssignment(typeSymbol, boundExpression2, diagnostics);
                flag = boundExpression.HasAnyErrors || boundExpression2.HasAnyErrors;
                typeSymbol2 = (flag ? CreateErrorType() : typeSymbol);
            }
            if (!flag)
            {
                constantValue = FoldConditionalOperator(condition, boundExpression, boundExpression2);
                flag = constantValue != null && constantValue.IsBad;
            }
            return new BoundConditionalOperator(node, isRef: false, condition, boundExpression, boundExpression2, constantValue, typeSymbol2, wasTargetTyped: false, typeSymbol2, flag);
        }

        private BoundExpression BindRefConditionalOperator(ConditionalExpressionSyntax node, ExpressionSyntax whenTrue, ExpressionSyntax whenFalse, BindingDiagnosticBag diagnostics)
        {
            BoundExpression condition = BindBooleanExpression(node.Condition, diagnostics);
            BoundExpression boundExpression = BindValue(whenTrue, diagnostics, BindValueKind.ReadonlyRef);
            BoundExpression boundExpression2 = BindValue(whenFalse, diagnostics, BindValueKind.ReadonlyRef);
            bool flag = boundExpression.HasErrors | boundExpression2.HasErrors;
            TypeSymbol type = boundExpression.Type;
            TypeSymbol type2 = boundExpression2.Type;
            TypeSymbol typeSymbol;
            if (!ConversionsBase.HasIdentityConversion(type, type2))
            {
                if (!flag)
                {
                    diagnostics.Add(ErrorCode.ERR_RefConditionalDifferentTypes, boundExpression2.Syntax.Location, type);
                }
                typeSymbol = CreateErrorType();
                flag = true;
            }
            else
            {
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                typeSymbol = BestTypeInferrer.InferBestTypeForConditionalOperator(boundExpression, boundExpression2, Conversions, out var _, ref useSiteInfo);
                diagnostics.Add(node, useSiteInfo);
            }
            if (!flag)
            {
                uint localScopeDepth = LocalScopeDepth;
                uint valEscape = GetValEscape(boundExpression, localScopeDepth);
                uint valEscape2 = GetValEscape(boundExpression2, localScopeDepth);
                if (valEscape != valEscape2)
                {
                    if (valEscape < valEscape2)
                    {
                        CheckValEscape(boundExpression2.Syntax, boundExpression2, localScopeDepth, valEscape, checkingReceiver: false, diagnostics);
                    }
                    else
                    {
                        CheckValEscape(boundExpression.Syntax, boundExpression, localScopeDepth, valEscape2, checkingReceiver: false, diagnostics);
                    }
                    diagnostics.Add(ErrorCode.ERR_MismatchedRefEscapeInTernary, node.Location);
                    flag = true;
                }
            }
            boundExpression = BindToNaturalType(boundExpression, diagnostics, reportNoTargetType: false);
            boundExpression2 = BindToNaturalType(boundExpression2, diagnostics, reportNoTargetType: false);
            return new BoundConditionalOperator(node, isRef: true, condition, boundExpression, boundExpression2, null, typeSymbol, wasTargetTyped: false, typeSymbol, flag);
        }

        private static ConstantValue FoldConditionalOperator(BoundExpression condition, BoundExpression trueExpr, BoundExpression falseExpr)
        {
            ConstantValue constantValue = trueExpr.ConstantValue;
            if (constantValue == null || constantValue.IsBad)
            {
                return constantValue;
            }
            ConstantValue constantValue2 = falseExpr.ConstantValue;
            if (constantValue2 == null || constantValue2.IsBad)
            {
                return constantValue2;
            }
            ConstantValue constantValue3 = condition.ConstantValue;
            if (constantValue3 == null || constantValue3.IsBad)
            {
                return constantValue3;
            }
            if (constantValue3 == ConstantValue.True)
            {
                return constantValue;
            }
            if (constantValue3 == ConstantValue.False)
            {
                return constantValue2;
            }
            return ConstantValue.Bad;
        }

        private static void CheckNativeIntegerFeatureAvailability(BinaryOperatorKind operatorKind, SyntaxNode syntax, BindingDiagnosticBag diagnostics)
        {
            BinaryOperatorKind binaryOperatorKind = operatorKind & BinaryOperatorKind.TypeMask;
            if ((uint)(binaryOperatorKind - 9) <= 1u)
            {
                CheckFeatureAvailability(syntax, MessageID.IDS_FeatureNativeInt, diagnostics);
            }
        }

        private static void CheckNativeIntegerFeatureAvailability(UnaryOperatorKind operatorKind, SyntaxNode syntax, BindingDiagnosticBag diagnostics)
        {
            UnaryOperatorKind unaryOperatorKind = operatorKind & UnaryOperatorKind.TypeMask;
            if ((uint)(unaryOperatorKind - 9) <= 1u)
            {
                CheckFeatureAvailability(syntax, MessageID.IDS_FeatureNativeInt, diagnostics);
            }
        }

        private BoundExpression BindIsPatternExpression(IsPatternExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            BoundExpression operand = BindRValueWithoutTargetType(node.Expression, diagnostics);
            bool flag = IsOperandErrors(node, ref operand, diagnostics);
            TypeSymbol type = operand.Type;
            if ((object)type == null || type.IsVoidType())
            {
                if (!flag)
                {
                    diagnostics.Add(ErrorCode.ERR_BadPatternExpression, node.Expression.Location, operand.Display);
                    flag = true;
                }
                operand = BadExpression(operand.Syntax, operand);
            }
            uint valEscape = GetValEscape(operand, LocalScopeDepth);
            BoundPattern boundPattern = BindPattern(node.Pattern, operand.Type, valEscape, permitDesignations: true, flag, diagnostics, underIsPattern: true);
            flag |= boundPattern.HasErrors;
            return MakeIsPatternExpression(node, operand, boundPattern, GetSpecialType(SpecialType.System_Boolean, diagnostics, node), flag, diagnostics);
        }

        private BoundExpression MakeIsPatternExpression(
            SyntaxNode node,
            BoundExpression expression,
            BoundPattern pattern,
            TypeSymbol boolType,
            bool hasErrors,
            BindingDiagnosticBag diagnostics)
        {
            // Note that these labels are for the convenience of the compilation of patterns, and are not necessarily emitted into the lowered code.
            LabelSymbol whenTrueLabel = new GeneratedLabelSymbol("isPatternSuccess");
            LabelSymbol whenFalseLabel = new GeneratedLabelSymbol("isPatternFailure");

            bool negated = pattern.IsNegated(out var innerPattern);
            BoundDecisionDag decisionDag = DecisionDagBuilder.CreateDecisionDagForIsPattern(
                this.Compilation, pattern.Syntax, expression, innerPattern, whenTrueLabel: whenTrueLabel, whenFalseLabel: whenFalseLabel, diagnostics);

            if (!hasErrors && getConstantResult(decisionDag, negated, whenTrueLabel, whenFalseLabel) is { } constantResult)
            {
                if (!constantResult)
                {
                    Debug.Assert(expression.Type is object);
                    diagnostics.Add(ErrorCode.ERR_IsPatternImpossible, node.Location, expression.Type);
                    hasErrors = true;
                }
                else
                {
                    switch (pattern)
                    {
                        case BoundConstantPattern _:
                        case BoundITuplePattern _:
                            // these patterns can fail in practice
                            throw ExceptionUtilities.Unreachable;
                        case BoundRelationalPattern _:
                        case BoundTypePattern _:
                        case BoundNegatedPattern _:
                        case BoundBinaryPattern _:
                            Debug.Assert(expression.Type is object);
                            diagnostics.Add(ErrorCode.WRN_IsPatternAlways, node.Location, expression.Type);
                            break;
                        case BoundDiscardPattern _:
                            // we do not give a warning on this because it is an existing scenario, and it should
                            // have been obvious in source that it would always match.
                            break;
                        case BoundDeclarationPattern _:
                        case BoundRecursivePattern _:
                            // We do not give a warning on these because people do this to give a name to a value
                            break;
                    }
                }
            }
            else if (expression.ConstantValue != null)
            {
                decisionDag = decisionDag.SimplifyDecisionDagIfConstantInput(expression);
                if (!hasErrors && getConstantResult(decisionDag, negated, whenTrueLabel, whenFalseLabel) is { } simplifiedResult)
                {
                    if (!simplifiedResult)
                    {
                        diagnostics.Add(ErrorCode.WRN_GivenExpressionNeverMatchesPattern, node.Location);
                    }
                    else
                    {
                        switch (pattern)
                        {
                            case BoundConstantPattern _:
                                diagnostics.Add(ErrorCode.WRN_GivenExpressionAlwaysMatchesConstant, node.Location);
                                break;
                            case BoundRelationalPattern _:
                            case BoundTypePattern _:
                            case BoundNegatedPattern _:
                            case BoundBinaryPattern _:
                            case BoundDiscardPattern _:
                                diagnostics.Add(ErrorCode.WRN_GivenExpressionAlwaysMatchesPattern, node.Location);
                                break;
                        }
                    }
                }
            }

            // decisionDag, whenTrueLabel, and whenFalseLabel represent the decision DAG for the inner pattern,
            // after removing any outer 'not's, so consumers will need to compensate for negated patterns.
            return new BoundIsPatternExpression(
                node, expression, pattern, negated, decisionDag, whenTrueLabel: whenTrueLabel, whenFalseLabel: whenFalseLabel, boolType, hasErrors);

            static bool? getConstantResult(BoundDecisionDag decisionDag, bool negated, LabelSymbol whenTrueLabel, LabelSymbol whenFalseLabel)
            {
                if (!decisionDag.ReachableLabels.Contains(whenTrueLabel))
                {
                    return negated;
                }
                else if (!decisionDag.ReachableLabels.Contains(whenFalseLabel))
                {
                    return !negated;
                }
                return null;
            }
        }

        private BoundExpression BindSwitchExpression(SwitchExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            Binder binder = GetBinder(node);
            return binder.BindSwitchExpressionCore(node, binder, diagnostics);
        }

        internal virtual BoundExpression BindSwitchExpressionCore(SwitchExpressionSyntax node, Binder originalBinder, BindingDiagnosticBag diagnostics)
        {
            return Next!.BindSwitchExpressionCore(node, originalBinder, diagnostics);
        }

        internal BoundPattern BindPattern(PatternSyntax node, TypeSymbol inputType, uint inputValEscape, bool permitDesignations, bool hasErrors, BindingDiagnosticBag diagnostics, bool underIsPattern = false)
        {
            if (!(node is DiscardPatternSyntax node2))
            {
                if (!(node is DeclarationPatternSyntax node3))
                {
                    if (!(node is ConstantPatternSyntax node4))
                    {
                        if (!(node is RecursivePatternSyntax node5))
                        {
                            if (!(node is VarPatternSyntax node6))
                            {
                                if (!(node is ParenthesizedPatternSyntax parenthesizedPatternSyntax))
                                {
                                    if (!(node is BinaryPatternSyntax node7))
                                    {
                                        if (!(node is UnaryPatternSyntax node8))
                                        {
                                            if (!(node is RelationalPatternSyntax node9))
                                            {
                                                if (node is TypePatternSyntax node10)
                                                {
                                                    return BindTypePattern(node10, inputType, hasErrors, diagnostics);
                                                }
                                                throw ExceptionUtilities.UnexpectedValue(node.Kind());
                                            }
                                            return BindRelationalPattern(node9, inputType, hasErrors, diagnostics);
                                        }
                                        return BindUnaryPattern(node8, inputType, inputValEscape, hasErrors, diagnostics, underIsPattern);
                                    }
                                    return BindBinaryPattern(node7, inputType, inputValEscape, permitDesignations, hasErrors, diagnostics);
                                }
                                return BindPattern(parenthesizedPatternSyntax.Pattern, inputType, inputValEscape, permitDesignations, hasErrors, diagnostics, underIsPattern);
                            }
                            return BindVarPattern(node6, inputType, inputValEscape, permitDesignations, hasErrors, diagnostics);
                        }
                        return BindRecursivePattern(node5, inputType, inputValEscape, permitDesignations, hasErrors, diagnostics);
                    }
                    return BindConstantPatternWithFallbackToTypePattern(node4, inputType, hasErrors, diagnostics);
                }
                return BindDeclarationPattern(node3, inputType, inputValEscape, permitDesignations, hasErrors, diagnostics);
            }
            return BindDiscardPattern(node2, inputType);
        }

        private BoundPattern BindDiscardPattern(DiscardPatternSyntax node, TypeSymbol inputType)
        {
            return new BoundDiscardPattern(node, inputType, inputType);
        }

        private BoundPattern BindConstantPatternWithFallbackToTypePattern(ConstantPatternSyntax node, TypeSymbol inputType, bool hasErrors, BindingDiagnosticBag diagnostics)
        {
            return BindConstantPatternWithFallbackToTypePattern(node, node.Expression, inputType, hasErrors, diagnostics);
        }

        internal BoundPattern BindConstantPatternWithFallbackToTypePattern(SyntaxNode node, ExpressionSyntax expression, TypeSymbol inputType, bool hasErrors, BindingDiagnosticBag diagnostics)
        {
            ExpressionSyntax expressionSyntax = SkipParensAndNullSuppressions(expression);
            if (expressionSyntax.Kind() == SyntaxKind.DefaultLiteralExpression)
            {
                diagnostics.Add(ErrorCode.ERR_DefaultPattern, expressionSyntax.Location);
                hasErrors = true;
            }
            BoundExpression boundExpression = BindExpressionOrTypeForPattern(inputType, expressionSyntax, ref hasErrors, diagnostics, out ConstantValue constantValueOpt, out bool wasExpression);
            if (wasExpression)
            {
                return new BoundConstantPattern(node, boundExpression, constantValueOpt ?? ConstantValue.Bad, inputType, boundExpression.Type ?? inputType, hasErrors || (object)constantValueOpt == null);
            }
            if (!hasErrors)
            {
                CheckFeatureAvailability(expressionSyntax, MessageID.IDS_FeatureTypePattern, diagnostics);
            }
            BoundTypeExpression boundTypeExpression = (BoundTypeExpression)boundExpression;
            bool isExplicitNotNullTest = boundTypeExpression.Type.SpecialType == SpecialType.System_Object;
            return new BoundTypePattern(node, boundTypeExpression, isExplicitNotNullTest, inputType, boundTypeExpression.Type, hasErrors);
        }

        private ExpressionSyntax SkipParensAndNullSuppressions(ExpressionSyntax e)
        {
            while (true)
            {
                if (!(e is ParenthesizedExpressionSyntax parenthesizedExpressionSyntax))
                {
                    if (!(e is PostfixUnaryExpressionSyntax postfixUnaryExpressionSyntax) || e.RawKind != 9054)
                    {
                        break;
                    }
                    e = postfixUnaryExpressionSyntax.Operand;
                }
                else
                {
                    e = parenthesizedExpressionSyntax.Expression;
                }
            }
            return e;
        }

        private BoundExpression BindExpressionOrTypeForPattern(TypeSymbol inputType, ExpressionSyntax patternExpression, ref bool hasErrors, BindingDiagnosticBag diagnostics, out ConstantValue? constantValueOpt, out bool wasExpression)
        {
            constantValueOpt = null;
            BoundExpression boundExpression = BindTypeOrRValue(patternExpression, diagnostics);
            wasExpression = boundExpression.Kind != BoundKind.TypeExpression;
            if (wasExpression)
            {
                return BindExpressionForPatternContinued(boundExpression, inputType, patternExpression, ref hasErrors, diagnostics, out constantValueOpt);
            }
            hasErrors |= CheckValidPatternType(patternExpression, inputType, boundExpression.Type, diagnostics);
            return boundExpression;
        }

        private BoundExpression BindExpressionForPattern(TypeSymbol inputType, ExpressionSyntax patternExpression, ref bool hasErrors, BindingDiagnosticBag diagnostics, out ConstantValue? constantValueOpt, out bool wasExpression)
        {
            constantValueOpt = null;
            BoundExpression expr = BindExpression(patternExpression, diagnostics, invoked: false, indexed: false);
            expr = CheckValue(expr, BindValueKind.RValue, diagnostics);
            wasExpression = expr.Kind switch
            {
                BoundKind.BadExpression => false,
                BoundKind.TypeExpression => false,
                _ => true,
            };
            if (!wasExpression)
            {
                return expr;
            }
            return BindExpressionForPatternContinued(expr, inputType, patternExpression, ref hasErrors, diagnostics, out constantValueOpt);
        }

        private BoundExpression BindExpressionForPatternContinued(BoundExpression expression, TypeSymbol inputType, ExpressionSyntax patternExpression, ref bool hasErrors, BindingDiagnosticBag diagnostics, out ConstantValue? constantValueOpt)
        {
            BoundExpression boundExpression = ConvertPatternExpression(inputType, patternExpression, expression, out constantValueOpt, hasErrors, diagnostics);
            ConstantValueUtils.CheckLangVersionForConstantValue(boundExpression, diagnostics);
            if (!boundExpression.HasErrors && !hasErrors)
            {
                if (constantValueOpt == null)
                {
                    diagnostics.Add(ErrorCode.ERR_ConstantExpected, patternExpression.Location);
                    hasErrors = true;
                }
                else if (inputType.IsPointerType())
                {
                    CheckFeatureAvailability(patternExpression, MessageID.IDS_FeatureNullPointerConstantPattern, diagnostics, patternExpression.Location);
                }
            }
            if ((object)boundExpression.Type == null && constantValueOpt != ConstantValue.Null)
            {
                boundExpression = new BoundConversion(boundExpression.Syntax, boundExpression, Conversion.NoConversion, isBaseConversion: false, @checked: false, explicitCastInCode: false, constantValueOpt, null, CreateErrorType(), hasErrors: true)
                {
                    WasCompilerGenerated = true
                };
            }
            return boundExpression;
        }

        internal BoundExpression ConvertPatternExpression(
            TypeSymbol inputType,
            CSharpSyntaxNode node,
            BoundExpression expression,
            out ConstantValue? constantValue,
            bool hasErrors,
            BindingDiagnosticBag diagnostics)
        {
            BoundExpression convertedExpression;

            // If we are pattern-matching against an open type, we do not convert the constant to the type of the input.
            // This permits us to match a value of type `IComparable<T>` with a pattern of type `int`.
            if (inputType.ContainsTypeParameter())
            {
                convertedExpression = expression;
                // If the expression does not have a constant value, an error will be reported in the caller
                if (!hasErrors && expression.ConstantValue is object)
                {
                    CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                    if (expression.ConstantValue == ConstantValue.Null)
                    {
                        // Pointers are value types, but they can be assigned null, so they can be matched against null.
                        if (inputType.IsNonNullableValueType() && !inputType.IsPointerOrFunctionPointer())
                        {
                            // We do not permit matching null against a struct type.
                            diagnostics.Add(ErrorCode.ERR_ValueCantBeNull, expression.Syntax.Location, inputType);
                            hasErrors = true;
                        }
                    }
                    else
                    {
                        if (ExpressionOfTypeMatchesPatternType(Conversions, inputType, expression.Type, ref useSiteInfo, out _, operandConstantValue: null) == false)
                        {
                            diagnostics.Add(ErrorCode.ERR_PatternWrongType, expression.Syntax.Location, inputType, expression.Display);
                            hasErrors = true;
                        }
                    }

                    if (!hasErrors)
                    {
                        var requiredVersion = MessageID.IDS_FeatureRecursivePatterns.RequiredVersion();
                        if (Compilation.LanguageVersion < requiredVersion &&
                            !this.Conversions.ClassifyConversionFromExpression(expression, inputType, ref useSiteInfo).IsImplicit)
                        {
                            diagnostics.Add(ErrorCode.ERR_ConstantPatternVsOpenType,
                                expression.Syntax.Location, inputType, expression.Display, new CSharpRequiredLanguageVersion(requiredVersion));
                        }
                    }

                    diagnostics.Add(node, useSiteInfo);
                }
            }
            else
            {
                // This will allow user-defined conversions, even though they're not permitted here.  This is acceptable
                // because the result of a user-defined conversion does not have a ConstantValue. A constant pattern
                // requires a constant value so we'll report a diagnostic to that effect later.
                convertedExpression = GenerateConversionForAssignment(inputType, expression, diagnostics);

                if (convertedExpression.Kind == BoundKind.Conversion)
                {
                    var conversion = (BoundConversion)convertedExpression;
                    BoundExpression operand = conversion.Operand;
                    if (inputType.IsNullableType() && (convertedExpression.ConstantValue == null || !convertedExpression.ConstantValue.IsNull))
                    {
                        // Null is a special case here because we want to compare null to the Nullable<T> itself, not to the underlying type.
                        // We are not interested in the diagnostic that get created here
                        convertedExpression = CreateConversion(operand, inputType.GetNullableUnderlyingType(), BindingDiagnosticBag.Discarded);
                    }
                    else if ((conversion.ConversionKind == ConversionKind.Boxing || conversion.ConversionKind == ConversionKind.ImplicitReference)
                        && operand.ConstantValue != null && convertedExpression.ConstantValue == null)
                    {
                        // A boxed constant (or string converted to object) is a special case because we prefer
                        // to compare to the pre-converted value by casting the input value to the type of the constant
                        // (that is, unboxing or downcasting it) and then testing the resulting value using primitives.
                        // That is much more efficient than calling object.Equals(x, y), and we can share the downcasted
                        // input value among many constant tests.
                        convertedExpression = operand;
                    }
                    else if (conversion.ConversionKind == ConversionKind.ImplicitNullToPointer ||
                        (conversion.ConversionKind == ConversionKind.NoConversion && convertedExpression.Type?.IsErrorType() == true))
                    {
                        convertedExpression = operand;
                    }
                }
            }

            constantValue = convertedExpression.ConstantValue;
            return convertedExpression;
        }

        private bool CheckValidPatternType(SyntaxNode typeSyntax, TypeSymbol inputType, TypeSymbol patternType, BindingDiagnosticBag diagnostics)
        {
            if (inputType.IsErrorType() || patternType.IsErrorType())
            {
                return false;
            }
            if (inputType.IsPointerOrFunctionPointer() || patternType.IsPointerOrFunctionPointer())
            {
                diagnostics.Add(ErrorCode.ERR_PointerTypeInPatternMatching, typeSyntax.Location);
                return true;
            }
            if (patternType.IsNullableType())
            {
                Error(diagnostics, ErrorCode.ERR_PatternNullableType, typeSyntax, patternType.GetNullableUnderlyingType());
                return true;
            }
            if (typeSyntax is NullableTypeSyntax)
            {
                Error(diagnostics, ErrorCode.ERR_PatternNullableType, typeSyntax, patternType);
                return true;
            }
            if (patternType.IsStatic)
            {
                Error(diagnostics, ErrorCode.ERR_VarDeclIsStaticClass, typeSyntax, patternType);
                return true;
            }
            if (patternType.IsDynamic())
            {
                Error(diagnostics, ErrorCode.ERR_PatternDynamicType, typeSyntax);
                return true;
            }
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            bool? flag = ExpressionOfTypeMatchesPatternType(Conversions, inputType, patternType, ref useSiteInfo, out Conversion conversion, null, operandCouldBeNull: true);
            diagnostics.Add(typeSyntax, useSiteInfo);
            if (flag != false)
            {
                if (!conversion.Exists && (inputType.ContainsTypeParameter() || patternType.ContainsTypeParameter()))
                {
                    LanguageVersion languageVersion = MessageID.IDS_FeatureGenericPatternMatching.RequiredVersion();
                    if (languageVersion > Compilation.LanguageVersion)
                    {
                        Error(diagnostics, ErrorCode.ERR_PatternWrongGenericTypeInVersion, typeSyntax, inputType, patternType, Compilation.LanguageVersion.ToDisplayString(), new CSharpRequiredLanguageVersion(languageVersion));
                        return true;
                    }
                }
                return false;
            }
            Error(diagnostics, ErrorCode.ERR_PatternWrongType, typeSyntax, inputType, patternType);
            return true;
        }

        internal static bool? ExpressionOfTypeMatchesPatternType(Conversions conversions, TypeSymbol expressionType, TypeSymbol patternType, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo, out Conversion conversion, ConstantValue? operandConstantValue = null, bool operandCouldBeNull = false)
        {
            if (expressionType.Equals(patternType, TypeCompareKind.AllIgnoreOptions))
            {
                conversion = Conversion.Identity;
                return true;
            }
            if (expressionType.IsDynamic())
            {
                expressionType = conversions.CorLibrary.GetSpecialType(SpecialType.System_Object);
            }
            conversion = conversions.ClassifyBuiltInConversion(expressionType, patternType, ref useSiteInfo);
            ConstantValue isOperatorConstantResult = GetIsOperatorConstantResult(expressionType, patternType, conversion.Kind, operandConstantValue, operandCouldBeNull);
            if (!(isOperatorConstantResult == null))
            {
                int value;
                if (!(isOperatorConstantResult == ConstantValue.True))
                {
                    if (!(isOperatorConstantResult == ConstantValue.False))
                    {
                        throw ExceptionUtilities.UnexpectedValue(isOperatorConstantResult);
                    }
                    value = 0;
                }
                else
                {
                    value = 1;
                }
                return (byte)value != 0;
            }
            return null;
        }

        private BoundPattern BindDeclarationPattern(DeclarationPatternSyntax node, TypeSymbol inputType, uint inputValEscape, bool permitDesignations, bool hasErrors, BindingDiagnosticBag diagnostics)
        {
            TypeSyntax type = node.Type;
            BoundTypeExpression boundTypeExpression = BindTypeForPattern(type, inputType, diagnostics, ref hasErrors);
            uint valEscape = GetValEscape(boundTypeExpression.Type, inputValEscape);
            BindPatternDesignation(node.Designation, boundTypeExpression.TypeWithAnnotations, valEscape, permitDesignations, type, diagnostics, ref hasErrors, out var variableSymbol, out var variableAccess);
            return new BoundDeclarationPattern(node, variableSymbol, variableAccess, boundTypeExpression, isVar: false, inputType, boundTypeExpression.Type, hasErrors);
        }

        private BoundTypeExpression BindTypeForPattern(TypeSyntax typeSyntax, TypeSymbol inputType, BindingDiagnosticBag diagnostics, ref bool hasErrors)
        {
            TypeWithAnnotations typeWithAnnotations = BindType(typeSyntax, diagnostics, out AliasSymbol alias);
            BoundTypeExpression result = new BoundTypeExpression(typeSyntax, alias, typeWithAnnotations);
            hasErrors |= CheckValidPatternType(typeSyntax, inputType, typeWithAnnotations.Type, diagnostics);
            return result;
        }

        private void BindPatternDesignation(VariableDesignationSyntax? designation, TypeWithAnnotations declType, uint inputValEscape, bool permitDesignations, TypeSyntax? typeSyntax, BindingDiagnosticBag diagnostics, ref bool hasErrors, out Symbol? variableSymbol, out BoundExpression? variableAccess)
        {
            if (!(designation is SingleVariableDesignationSyntax singleVariableDesignationSyntax))
            {
                if (designation is DiscardDesignationSyntax || designation == null)
                {
                    variableSymbol = null;
                    variableAccess = null;
                    return;
                }
                throw ExceptionUtilities.UnexpectedValue(designation!.Kind());
            }
            SyntaxToken identifier = singleVariableDesignationSyntax.Identifier;
            SourceLocalSymbol sourceLocalSymbol = LookupLocal(identifier);
            if (!permitDesignations && !identifier.IsMissing)
            {
                diagnostics.Add(ErrorCode.ERR_DesignatorBeneathPatternCombinator, identifier.GetLocation());
            }
            if ((object)sourceLocalSymbol != null)
            {
                if ((InConstructorInitializer || InFieldInitializer) && ContainingMemberOrLambda!.ContainingSymbol.Kind == SymbolKind.NamedType)
                {
                    CheckFeatureAvailability(designation, MessageID.IDS_FeatureExpressionVariablesInQueriesAndInitializers, diagnostics);
                }
                sourceLocalSymbol.SetTypeWithAnnotations(declType);
                sourceLocalSymbol.SetValEscape(GetValEscape(declType.Type, inputValEscape));
                hasErrors |= sourceLocalSymbol.ScopeBinder.ValidateDeclarationNameConflictsInScope(sourceLocalSymbol, diagnostics);
                if (!hasErrors)
                {
                    hasErrors = CheckRestrictedTypeInAsyncMethod(ContainingMemberOrLambda, declType.Type, diagnostics, (SyntaxNode)(typeSyntax ?? ((object)designation)));
                }
                variableSymbol = sourceLocalSymbol;
                variableAccess = new BoundLocal(designation, sourceLocalSymbol, (!sourceLocalSymbol.IsVar) ? BoundLocalDeclarationKind.WithExplicitType : BoundLocalDeclarationKind.WithInferredType, null, isNullableUnknown: false, declType.Type);
            }
            else
            {
                GlobalExpressionVariable globalExpressionVariable = LookupDeclaredField(singleVariableDesignationSyntax);
                globalExpressionVariable.SetTypeWithAnnotations(declType, BindingDiagnosticBag.Discarded);
                BoundExpression receiver = SynthesizeReceiver(designation, globalExpressionVariable, diagnostics);
                variableSymbol = globalExpressionVariable;
                variableAccess = new BoundFieldAccess(designation, receiver, globalExpressionVariable, null, hasErrors);
            }
        }

        private static uint GetValEscape(TypeSymbol type, uint possibleValEscape)
        {
            if (!type.IsRefLikeType)
            {
                return 0u;
            }
            return possibleValEscape;
        }

        private TypeWithAnnotations BindRecursivePatternType(TypeSyntax? typeSyntax, TypeSymbol inputType, BindingDiagnosticBag diagnostics, ref bool hasErrors, out BoundTypeExpression? boundDeclType)
        {
            if (typeSyntax != null)
            {
                boundDeclType = BindTypeForPattern(typeSyntax, inputType, diagnostics, ref hasErrors);
                return boundDeclType!.TypeWithAnnotations;
            }
            boundDeclType = null;
            return TypeWithAnnotations.Create(inputType.StrippedType(), NullableAnnotation.NotAnnotated);
        }

        internal static bool IsZeroElementTupleType(TypeSymbol type)
        {
            if (type.IsStructType() && type.Name == "ValueTuple" && type.GetArity() == 0)
            {
                Symbol containingSymbol = type.ContainingSymbol;
                if (containingSymbol.Kind == SymbolKind.Namespace && containingSymbol.Name == "System")
                {
                    return (containingSymbol.ContainingSymbol as NamespaceSymbol)?.IsGlobalNamespace ?? false;
                }
            }
            return false;
        }

        private BoundPattern BindRecursivePattern(RecursivePatternSyntax node, TypeSymbol inputType, uint inputValEscape, bool permitDesignations, bool hasErrors, BindingDiagnosticBag diagnostics)
        {
            if (inputType.IsPointerOrFunctionPointer())
            {
                diagnostics.Add(ErrorCode.ERR_PointerTypeInPatternMatching, node.Location);
                hasErrors = true;
                inputType = CreateErrorType();
            }
            TypeSyntax type = node.Type;
            TypeWithAnnotations declType = BindRecursivePatternType(type, inputType, diagnostics, ref hasErrors, out BoundTypeExpression boundDeclType);
            TypeSymbol type2 = declType.Type;
            inputValEscape = GetValEscape(type2, inputValEscape);
            MethodSymbol methodSymbol = null;
            ImmutableArray<BoundSubpattern> deconstruction = default(ImmutableArray<BoundSubpattern>);
            if (node.PositionalPatternClause != null)
            {
                PositionalPatternClauseSyntax positionalPatternClause = node.PositionalPatternClause;
                ArrayBuilder<BoundSubpattern> instance = ArrayBuilder<BoundSubpattern>.GetInstance(positionalPatternClause.Subpatterns.Count);
                if (IsZeroElementTupleType(type2))
                {
                    BindValueTupleSubpatterns(positionalPatternClause, type2, ImmutableArray<TypeWithAnnotations>.Empty, inputValEscape, permitDesignations, ref hasErrors, instance, diagnostics);
                }
                else if (type2.IsTupleType)
                {
                    BindValueTupleSubpatterns(positionalPatternClause, type2, type2.TupleElementTypesWithAnnotations, inputValEscape, permitDesignations, ref hasErrors, instance, diagnostics);
                }
                else
                {
                    BoundImplicitReceiver receiver = new BoundImplicitReceiver(positionalPatternClause, type2);
                    BindingDiagnosticBag instance2 = BindingDiagnosticBag.GetInstance(diagnostics);
                    BoundExpression deconstruct = MakeDeconstructInvocationExpression(positionalPatternClause.Subpatterns.Count, receiver, positionalPatternClause, instance2, out ImmutableArray<BoundDeconstructValuePlaceholder> outPlaceholders, out bool anyApplicableCandidates);
                    if (!anyApplicableCandidates && ShouldUseITupleForRecursivePattern(node, type2, diagnostics, out var iTupleType, out var iTupleGetLength, out var iTupleGetItem))
                    {
                        instance2.Free();
                        BindITupleSubpatterns(positionalPatternClause, instance, permitDesignations, diagnostics);
                        deconstruction = instance.ToImmutableAndFree();
                        return new BoundITuplePattern(node, iTupleGetLength, iTupleGetItem, deconstruction, inputType, iTupleType, hasErrors);
                    }
                    diagnostics.AddRangeAndFree(instance2);
                    methodSymbol = BindDeconstructSubpatterns(positionalPatternClause, inputValEscape, permitDesignations, deconstruct, outPlaceholders, instance, ref hasErrors, diagnostics);
                }
                deconstruction = instance.ToImmutableAndFree();
            }
            ImmutableArray<BoundSubpattern> properties = default(ImmutableArray<BoundSubpattern>);
            if (node.PropertyPatternClause != null)
            {
                properties = BindPropertyPatternClause(node.PropertyPatternClause, type2, inputValEscape, permitDesignations, diagnostics, ref hasErrors);
            }
            BindPatternDesignation(node.Designation, declType, inputValEscape, permitDesignations, type, diagnostics, ref hasErrors, out var variableSymbol, out var variableAccess);
            bool isExplicitNotNullTest = node.Designation == null && boundDeclType == null && properties.IsDefaultOrEmpty && (object)methodSymbol == null && deconstruction.IsDefault;
            return new BoundRecursivePattern(node, boundDeclType, methodSymbol, deconstruction, properties, variableSymbol, variableAccess, isExplicitNotNullTest, inputType, boundDeclType?.Type ?? inputType.StrippedType(), hasErrors);
        }

        private MethodSymbol? BindDeconstructSubpatterns(PositionalPatternClauseSyntax node, uint inputValEscape, bool permitDesignations, BoundExpression deconstruct, ImmutableArray<BoundDeconstructValuePlaceholder> outPlaceholders, ArrayBuilder<BoundSubpattern> patterns, ref bool hasErrors, BindingDiagnosticBag diagnostics)
        {
            MethodSymbol methodSymbol = deconstruct.ExpressionSymbol as MethodSymbol;
            if ((object)methodSymbol == null)
            {
                hasErrors = true;
            }
            int num = (((object)methodSymbol != null && methodSymbol.IsExtensionMethod) ? 1 : 0);
            for (int i = 0; i < node.Subpatterns.Count; i++)
            {
                SubpatternSyntax subpatternSyntax = node.Subpatterns[i];
                bool flag = hasErrors || outPlaceholders.IsDefaultOrEmpty || i >= outPlaceholders.Length;
                TypeSymbol typeSymbol = (flag ? CreateErrorType() : outPlaceholders[i].Type);
                ParameterSymbol parameterSymbol = null;
                if (subpatternSyntax.NameColon != null && !flag)
                {
                    int num2 = i + num;
                    if (num2 < methodSymbol.ParameterCount)
                    {
                        parameterSymbol = methodSymbol.Parameters[num2];
                        string valueText = subpatternSyntax.NameColon!.Name.Identifier.ValueText;
                        string name = parameterSymbol.Name;
                        if (valueText != name)
                        {
                            diagnostics.Add(ErrorCode.ERR_DeconstructParameterNameMismatch, subpatternSyntax.NameColon!.Name.Location, valueText, name);
                        }
                    }
                }
                BoundSubpattern item = new BoundSubpattern(subpatternSyntax, parameterSymbol, BindPattern(subpatternSyntax.Pattern, typeSymbol, GetValEscape(typeSymbol, inputValEscape), permitDesignations, flag, diagnostics));
                patterns.Add(item);
            }
            return methodSymbol;
        }

        private void BindITupleSubpatterns(PositionalPatternClauseSyntax node, ArrayBuilder<BoundSubpattern> patterns, bool permitDesignations, BindingDiagnosticBag diagnostics)
        {
            NamedTypeSymbol specialType = Compilation.GetSpecialType(SpecialType.System_Object);
            SeparatedSyntaxList<SubpatternSyntax>.Enumerator enumerator = node.Subpatterns.GetEnumerator();
            while (enumerator.MoveNext())
            {
                SubpatternSyntax current = enumerator.Current;
                if (current.NameColon != null)
                {
                    diagnostics.Add(ErrorCode.ERR_ArgumentNameInITuplePattern, current.NameColon!.Location);
                }
                BoundSubpattern item = new BoundSubpattern(current, null, BindPattern(current.Pattern, specialType, 0u, permitDesignations, hasErrors: false, diagnostics));
                patterns.Add(item);
            }
        }

        private void BindITupleSubpatterns(ParenthesizedVariableDesignationSyntax node, ArrayBuilder<BoundSubpattern> patterns, bool permitDesignations, BindingDiagnosticBag diagnostics)
        {
            NamedTypeSymbol specialType = Compilation.GetSpecialType(SpecialType.System_Object);
            SeparatedSyntaxList<VariableDesignationSyntax>.Enumerator enumerator = node.Variables.GetEnumerator();
            while (enumerator.MoveNext())
            {
                VariableDesignationSyntax current = enumerator.Current;
                BoundPattern pattern = BindVarDesignation(current, specialType, 0u, permitDesignations, hasErrors: false, diagnostics);
                BoundSubpattern item = new BoundSubpattern(current, null, pattern);
                patterns.Add(item);
            }
        }

        private void BindValueTupleSubpatterns(PositionalPatternClauseSyntax node, TypeSymbol declType, ImmutableArray<TypeWithAnnotations> elementTypesWithAnnotations, uint inputValEscape, bool permitDesignations, ref bool hasErrors, ArrayBuilder<BoundSubpattern> patterns, BindingDiagnosticBag diagnostics)
        {
            if (elementTypesWithAnnotations.Length != node.Subpatterns.Count && !hasErrors)
            {
                diagnostics.Add(ErrorCode.ERR_WrongNumberOfSubpatterns, node.Location, declType, elementTypesWithAnnotations.Length, node.Subpatterns.Count);
                hasErrors = true;
            }
            for (int i = 0; i < node.Subpatterns.Count; i++)
            {
                SubpatternSyntax subpatternSyntax = node.Subpatterns[i];
                bool flag = i >= elementTypesWithAnnotations.Length;
                TypeSymbol typeSymbol = (flag ? CreateErrorType() : elementTypesWithAnnotations[i].Type);
                FieldSymbol symbol = null;
                if (subpatternSyntax.NameColon != null && !flag)
                {
                    string valueText = subpatternSyntax.NameColon!.Name.Identifier.ValueText;
                    symbol = CheckIsTupleElement(subpatternSyntax.NameColon!.Name, (NamedTypeSymbol)declType, valueText, i, diagnostics);
                }
                BoundSubpattern item = new BoundSubpattern(subpatternSyntax, symbol, BindPattern(subpatternSyntax.Pattern, typeSymbol, GetValEscape(typeSymbol, inputValEscape), permitDesignations, flag, diagnostics));
                patterns.Add(item);
            }
        }

        private bool ShouldUseITupleForRecursivePattern(RecursivePatternSyntax node, TypeSymbol declType, BindingDiagnosticBag diagnostics, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out NamedTypeSymbol? iTupleType, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out MethodSymbol? iTupleGetLength, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out MethodSymbol? iTupleGetItem)
        {
            iTupleType = null;
            iTupleGetLength = (iTupleGetItem = null);
            if (node.Type != null)
            {
                return false;
            }
            if (node.PropertyPatternClause != null)
            {
                return false;
            }
            if (node.PositionalPatternClause == null)
            {
                return false;
            }
            VariableDesignationSyntax? designation = node.Designation;
            if (designation != null && designation!.Kind() == SyntaxKind.SingleVariableDesignation)
            {
                return false;
            }
            return ShouldUseITuple(node, declType, diagnostics, out iTupleType, out iTupleGetLength, out iTupleGetItem);
        }

        private bool ShouldUseITuple(SyntaxNode node, TypeSymbol declType, BindingDiagnosticBag diagnostics, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out NamedTypeSymbol? iTupleType, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out MethodSymbol? iTupleGetLength, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out MethodSymbol? iTupleGetItem)
        {
            BindingDiagnosticBag diagnostics2 = diagnostics;
            SyntaxNode node2 = node;
            iTupleType = null;
            iTupleGetLength = (iTupleGetItem = null);
            if (Compilation.LanguageVersion < MessageID.IDS_FeatureRecursivePatterns.RequiredVersion())
            {
                return false;
            }
            iTupleType = Compilation.GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_ITuple);
            if (iTupleType!.TypeKind != TypeKind.Interface)
            {
                return false;
            }
            if ((object)declType != Compilation.GetSpecialType(SpecialType.System_Object) && (object)declType != Compilation.DynamicType && (object)declType != iTupleType && !hasBaseInterface(declType, iTupleType))
            {
                return false;
            }
            iTupleGetLength = (MethodSymbol)Compilation.GetWellKnownTypeMember(WellKnownMember.System_Runtime_CompilerServices_ITuple__get_Length);
            iTupleGetItem = (MethodSymbol)Compilation.GetWellKnownTypeMember(WellKnownMember.System_Runtime_CompilerServices_ITuple__get_Item);
            if ((object)iTupleGetLength == null || (object)iTupleGetItem == null)
            {
                return false;
            }
            if (diagnostics2.ReportUseSite(iTupleType, node2) || diagnostics2.ReportUseSite(iTupleGetLength, node2))
            {
                _ = 1;
            }
            else
                diagnostics2.ReportUseSite(iTupleGetItem, node2);
            return true;
            bool hasBaseInterface(TypeSymbol type, NamedTypeSymbol possibleBaseInterface)
            {
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics2);
                bool isImplicit = Compilation.Conversions.ClassifyBuiltInConversion(type, possibleBaseInterface, ref useSiteInfo).IsImplicit;
                diagnostics2.Add(node2, useSiteInfo);
                return isImplicit;
            }
        }

        private static FieldSymbol? CheckIsTupleElement(SyntaxNode node, NamedTypeSymbol tupleType, string name, int tupleIndex, BindingDiagnosticBag diagnostics)
        {
            FieldSymbol fieldSymbol = null;
            ImmutableArray<Symbol>.Enumerator enumerator = tupleType.GetMembers(name).GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (enumerator.Current is FieldSymbol fieldSymbol2 && fieldSymbol2.IsTupleElement())
                {
                    fieldSymbol = fieldSymbol2;
                    break;
                }
            }
            if ((object)fieldSymbol == null || fieldSymbol.TupleElementIndex != tupleIndex)
            {
                diagnostics.Add(ErrorCode.ERR_TupleElementNameMismatch, node.Location, name, $"Item{tupleIndex + 1}");
            }
            return fieldSymbol;
        }

        private BoundPattern BindVarPattern(VarPatternSyntax node, TypeSymbol inputType, uint inputValEscape, bool permitDesignations, bool hasErrors, BindingDiagnosticBag diagnostics)
        {
            if ((inputType.IsPointerOrFunctionPointer() && node.Designation.Kind() == SyntaxKind.ParenthesizedVariableDesignation) || (inputType.IsPointerType() && Compilation.LanguageVersion < MessageID.IDS_FeatureRecursivePatterns.RequiredVersion()))
            {
                diagnostics.Add(ErrorCode.ERR_PointerTypeInPatternMatching, node.Location);
                hasErrors = true;
                inputType = CreateErrorType();
            }
            Symbol symbol = BindTypeOrAliasOrKeyword(node.VarKeyword, node, diagnostics, out bool isKeyword).Symbol;
            if (!isKeyword)
            {
                diagnostics.Add(ErrorCode.ERR_VarMayNotBindToType, node.VarKeyword.GetLocation(), symbol.ToDisplayString());
                hasErrors = true;
            }
            return BindVarDesignation(node.Designation, inputType, inputValEscape, permitDesignations, hasErrors, diagnostics);
        }

        private BoundPattern BindVarDesignation(
            VariableDesignationSyntax node,
            TypeSymbol inputType,
            uint inputValEscape,
            bool permitDesignations,
            bool hasErrors,
            BindingDiagnosticBag diagnostics)
        {
            switch (node.Kind())
            {
                case SyntaxKind.DiscardDesignation:
                    {
                        return new BoundDiscardPattern(node, inputType: inputType, narrowedType: inputType);
                    }
                case SyntaxKind.SingleVariableDesignation:
                    {
                        var declType = TypeWithState.ForType(inputType).ToTypeWithAnnotations(Compilation);
                        BindPatternDesignation(
                            designation: node, declType: declType, inputValEscape: inputValEscape, permitDesignations: permitDesignations,
                            typeSyntax: null, diagnostics: diagnostics, hasErrors: ref hasErrors,
                            variableSymbol: out Symbol? variableSymbol, variableAccess: out BoundExpression? variableAccess);
                        var boundOperandType = new BoundTypeExpression(syntax: node, aliasOpt: null, typeWithAnnotations: declType); // fake a type expression for the variable's type
                                                                                                                                     // We continue to use a BoundDeclarationPattern for the var pattern, as they have more in common.
                        return new BoundDeclarationPattern(
                            node.Parent.Kind() == SyntaxKind.VarPattern ? node.Parent : node, // for `var x` use whole pattern, otherwise use designation for the syntax
                            variableSymbol, variableAccess, boundOperandType, isVar: true,
                            inputType: inputType, narrowedType: inputType, hasErrors: hasErrors);
                    }
                case SyntaxKind.ParenthesizedVariableDesignation:
                    {
                        var tupleDesignation = (ParenthesizedVariableDesignationSyntax)node;
                        var subPatterns = ArrayBuilder<BoundSubpattern>.GetInstance(tupleDesignation.Variables.Count);
                        MethodSymbol? deconstructMethod = null;
                        var strippedInputType = inputType.StrippedType();

                        if (IsZeroElementTupleType(strippedInputType))
                        {
                            // Work around https://github.com/dotnet/roslyn/issues/20648: The compiler's internal APIs such as `declType.IsTupleType`
                            // do not correctly treat the non-generic struct `System.ValueTuple` as a tuple type.  We explicitly perform the tests
                            // required to identify it.  When that bug is fixed we should be able to remove this if statement.
                            addSubpatternsForTuple(ImmutableArray<TypeWithAnnotations>.Empty);
                        }
                        else if (strippedInputType.IsTupleType)
                        {
                            // It is a tuple type. Work according to its elements
                            addSubpatternsForTuple(strippedInputType.TupleElementTypesWithAnnotations);
                        }
                        else
                        {
                            // It is not a tuple type. Seek an appropriate Deconstruct method.
                            var inputPlaceholder = new BoundImplicitReceiver(node, strippedInputType); // A fake receiver expression to permit us to reuse binding logic
                            var deconstructDiagnostics = BindingDiagnosticBag.GetInstance(diagnostics);
                            BoundExpression deconstruct = MakeDeconstructInvocationExpression(
                                tupleDesignation.Variables.Count, inputPlaceholder, node, deconstructDiagnostics,
                                outPlaceholders: out ImmutableArray<BoundDeconstructValuePlaceholder> outPlaceholders,
                                out bool anyDeconstructCandidates);
                            if (!anyDeconstructCandidates &&
                                ShouldUseITuple(node, strippedInputType, diagnostics, out var iTupleType, out var iTupleGetLength, out var iTupleGetItem))
                            {
                                // There was no applicable candidate Deconstruct, and the constraints for the use of ITuple are satisfied.
                                // Use that and forget any errors from trying to bind Deconstruct.
                                deconstructDiagnostics.Free();
                                BindITupleSubpatterns(tupleDesignation, subPatterns, permitDesignations, diagnostics);
                                return new BoundITuplePattern(node, iTupleGetLength, iTupleGetItem, subPatterns.ToImmutableAndFree(), strippedInputType, iTupleType, hasErrors);
                            }
                            else
                            {
                                diagnostics.AddRangeAndFree(deconstructDiagnostics);
                            }

                            deconstructMethod = deconstruct.ExpressionSymbol as MethodSymbol;
                            if (!hasErrors)
                                hasErrors = outPlaceholders.IsDefault || tupleDesignation.Variables.Count != outPlaceholders.Length;

                            for (int i = 0; i < tupleDesignation.Variables.Count; i++)
                            {
                                var variable = tupleDesignation.Variables[i];
                                bool isError = outPlaceholders.IsDefaultOrEmpty || i >= outPlaceholders.Length;
                                TypeSymbol elementType = isError ? CreateErrorType() : outPlaceholders[i].Type;
                                BoundPattern pattern = BindVarDesignation(variable, elementType, GetValEscape(elementType, inputValEscape), permitDesignations, isError, diagnostics);
                                subPatterns.Add(new BoundSubpattern(variable, symbol: null, pattern));
                            }
                        }

                        return new BoundRecursivePattern(
                            syntax: node, declaredType: null, deconstructMethod: deconstructMethod,
                            deconstruction: subPatterns.ToImmutableAndFree(), properties: default, variable: null, variableAccess: null,
                            isExplicitNotNullTest: false, inputType: inputType, narrowedType: inputType.StrippedType(), hasErrors: hasErrors);

                        void addSubpatternsForTuple(ImmutableArray<TypeWithAnnotations> elementTypes)
                        {
                            if (elementTypes.Length != tupleDesignation.Variables.Count && !hasErrors)
                            {
                                diagnostics.Add(ErrorCode.ERR_WrongNumberOfSubpatterns, tupleDesignation.Location,
                                    strippedInputType, elementTypes.Length, tupleDesignation.Variables.Count);
                                hasErrors = true;
                            }
                            for (int i = 0; i < tupleDesignation.Variables.Count; i++)
                            {
                                var variable = tupleDesignation.Variables[i];
                                bool isError = i >= elementTypes.Length;
                                TypeSymbol elementType = isError ? CreateErrorType() : elementTypes[i].Type;
                                BoundPattern pattern = BindVarDesignation(variable, elementType, GetValEscape(elementType, inputValEscape), permitDesignations, isError, diagnostics);
                                subPatterns.Add(new BoundSubpattern(variable, symbol: null, pattern));
                            }
                        }
                    }
                default:
                    {
                        throw ExceptionUtilities.UnexpectedValue(node.Kind());
                    }
            }
        }

        private ImmutableArray<BoundSubpattern> BindPropertyPatternClause(PropertyPatternClauseSyntax node, TypeSymbol inputType, uint inputValEscape, bool permitDesignations, BindingDiagnosticBag diagnostics, ref bool hasErrors)
        {
            ArrayBuilder<BoundSubpattern> instance = ArrayBuilder<BoundSubpattern>.GetInstance(node.Subpatterns.Count);
            SeparatedSyntaxList<SubpatternSyntax>.Enumerator enumerator = node.Subpatterns.GetEnumerator();
            while (enumerator.MoveNext())
            {
                SubpatternSyntax current = enumerator.Current;
                IdentifierNameSyntax identifierNameSyntax = current.NameColon?.Name;
                PatternSyntax pattern = current.Pattern;
                Symbol symbol = null;
                TypeSymbol memberType;
                if (identifierNameSyntax == null)
                {
                    if (!hasErrors)
                    {
                        diagnostics.Add(ErrorCode.ERR_PropertyPatternNameMissing, pattern.Location, pattern);
                    }
                    memberType = CreateErrorType();
                    hasErrors = true;
                }
                else
                {
                    symbol = LookupMemberForPropertyPattern(inputType, identifierNameSyntax, diagnostics, ref hasErrors, out memberType);
                }
                BoundPattern pattern2 = BindPattern(pattern, memberType, GetValEscape(memberType, inputValEscape), permitDesignations, hasErrors, diagnostics);
                instance.Add(new BoundSubpattern(current, symbol, pattern2));
            }
            return instance.ToImmutableAndFree();
        }

        private Symbol? LookupMemberForPropertyPattern(TypeSymbol inputType, IdentifierNameSyntax name, BindingDiagnosticBag diagnostics, ref bool hasErrors, out TypeSymbol memberType)
        {
            Symbol symbol = BindPropertyPatternMember(inputType, name, ref hasErrors, diagnostics);
            TypeSymbol typeSymbol = (memberType = ((symbol is FieldSymbol fieldSymbol) ? fieldSymbol.Type : ((!(symbol is PropertySymbol propertySymbol)) ? CreateErrorType() : propertySymbol.Type)));
            return symbol;
        }

        private Symbol? BindPropertyPatternMember(TypeSymbol inputType, IdentifierNameSyntax memberName, ref bool hasErrors, BindingDiagnosticBag diagnostics)
        {
            BoundImplicitReceiver boundImplicitReceiver = new BoundImplicitReceiver(memberName, inputType);
            string valueText = memberName.Identifier.ValueText;
            BoundExpression boundExpression = BindInstanceMemberAccess(memberName, memberName, boundImplicitReceiver, valueText, 0, default(SeparatedSyntaxList<TypeSyntax>), default(ImmutableArray<TypeWithAnnotations>), invoked: false, indexed: false, diagnostics);
            if (boundExpression.Kind == BoundKind.PropertyGroup)
            {
                boundExpression = BindIndexedPropertyAccess((BoundPropertyGroup)boundExpression, mustHaveAllOptionalParameters: true, diagnostics);
            }
            hasErrors |= boundExpression.HasAnyErrors || boundImplicitReceiver.HasAnyErrors;
            switch (boundExpression.Kind)
            {
                default:
                    if (!hasErrors)
                    {
                        switch (boundExpression.ResultKind)
                        {
                            case LookupResultKind.Empty:
                                Error(diagnostics, ErrorCode.ERR_NoSuchMember, memberName, boundImplicitReceiver.Type, valueText);
                                break;
                            case LookupResultKind.Inaccessible:
                                boundExpression = CheckValue(boundExpression, BindValueKind.RValue, diagnostics);
                                break;
                            default:
                                Error(diagnostics, ErrorCode.ERR_PropertyLacksGet, memberName, valueText);
                                break;
                        }
                    }
                    hasErrors = true;
                    return boundExpression.ExpressionSymbol;
                case BoundKind.FieldAccess:
                case BoundKind.PropertyAccess:
                    if (hasErrors || !CheckValueKind(memberName.Parent, boundExpression, BindValueKind.RValue, checkingReceiver: false, diagnostics))
                    {
                        hasErrors = true;
                    }
                    return boundExpression.ExpressionSymbol;
            }
        }

        private BoundPattern BindTypePattern(TypePatternSyntax node, TypeSymbol inputType, bool hasErrors, BindingDiagnosticBag diagnostics)
        {
            BoundTypeExpression boundTypeExpression = BindTypeForPattern(node.Type, inputType, diagnostics, ref hasErrors);
            bool isExplicitNotNullTest = boundTypeExpression.Type.SpecialType == SpecialType.System_Object;
            return new BoundTypePattern(node, boundTypeExpression, isExplicitNotNullTest, inputType, boundTypeExpression.Type, hasErrors);
        }

        private BoundPattern BindRelationalPattern(RelationalPatternSyntax node, TypeSymbol inputType, bool hasErrors, BindingDiagnosticBag diagnostics)
        {
            BoundExpression boundExpression = BindExpressionForPattern(inputType, node.Expression, ref hasErrors, diagnostics, out ConstantValue constantValueOpt, out bool wasExpression);
            ExpressionSyntax expressionSyntax = SkipParensAndNullSuppressions(node.Expression);
            if (expressionSyntax.Kind() == SyntaxKind.DefaultLiteralExpression)
            {
                diagnostics.Add(ErrorCode.ERR_DefaultPattern, expressionSyntax.Location);
                hasErrors = true;
            }
            BinaryOperatorKind binaryOperatorKind = tokenKindToBinaryOperatorKind(node.OperatorToken.Kind());
            if (binaryOperatorKind == BinaryOperatorKind.Equal)
            {
                diagnostics.Add(ErrorCode.ERR_InvalidExprTerm, node.OperatorToken.GetLocation(), node.OperatorToken.Text);
                hasErrors = true;
            }
            BinaryOperatorKind binaryOperatorKind2 = RelationalOperatorType(boundExpression.Type.EnumUnderlyingTypeOrSelf());
            switch (binaryOperatorKind2)
            {
                case BinaryOperatorKind.Float:
                case BinaryOperatorKind.Double:
                    if (!hasErrors && constantValueOpt != null && !constantValueOpt.IsBad && double.IsNaN(constantValueOpt.DoubleValue))
                    {
                        diagnostics.Add(ErrorCode.ERR_RelationalPatternWithNaN, node.Expression.Location);
                        hasErrors = true;
                    }
                    break;
                case BinaryOperatorKind.Error:
                case BinaryOperatorKind.Bool:
                case BinaryOperatorKind.String:
                    if (!hasErrors)
                    {
                        diagnostics.Add(ErrorCode.ERR_UnsupportedTypeForRelationalPattern, node.Location, boundExpression.Type!.ToDisplayString());
                        hasErrors = true;
                    }
                    break;
            }
            if ((object)constantValueOpt == null)
            {
                hasErrors = true;
                constantValueOpt = ConstantValue.Bad;
            }
            return new BoundRelationalPattern(node, binaryOperatorKind | binaryOperatorKind2, boundExpression, constantValueOpt, inputType, boundExpression.Type, hasErrors);
            static BinaryOperatorKind tokenKindToBinaryOperatorKind(SyntaxKind kind)
            {
                return kind switch
                {
                    SyntaxKind.LessThanEqualsToken => BinaryOperatorKind.LessThanOrEqual,
                    SyntaxKind.LessThanToken => BinaryOperatorKind.LessThan,
                    SyntaxKind.GreaterThanToken => BinaryOperatorKind.GreaterThan,
                    SyntaxKind.GreaterThanEqualsToken => BinaryOperatorKind.GreaterThanOrEqual,
                    _ => BinaryOperatorKind.Equal,
                };
            }
        }

        internal static BinaryOperatorKind RelationalOperatorType(TypeSymbol type)
        {
            switch (type.SpecialType)
            {
                case SpecialType.System_Single:
                    return BinaryOperatorKind.Float;
                case SpecialType.System_Double:
                    return BinaryOperatorKind.Double;
                case SpecialType.System_Char:
                    return BinaryOperatorKind.Char;
                case SpecialType.System_SByte:
                    return BinaryOperatorKind.Int;
                case SpecialType.System_Byte:
                    return BinaryOperatorKind.Int;
                case SpecialType.System_UInt16:
                    return BinaryOperatorKind.Int;
                case SpecialType.System_Int16:
                    return BinaryOperatorKind.Int;
                case SpecialType.System_Int32:
                    return BinaryOperatorKind.Int;
                case SpecialType.System_UInt32:
                    return BinaryOperatorKind.UInt;
                case SpecialType.System_Int64:
                    return BinaryOperatorKind.Long;
                case SpecialType.System_UInt64:
                    return BinaryOperatorKind.ULong;
                case SpecialType.System_Decimal:
                    return BinaryOperatorKind.Decimal;
                case SpecialType.System_String:
                    return BinaryOperatorKind.String;
                case SpecialType.System_Boolean:
                    return BinaryOperatorKind.Bool;
                case SpecialType.System_IntPtr:
                    if (type.IsNativeIntegerType)
                    {
                        return BinaryOperatorKind.NInt;
                    }
                    break;
                case SpecialType.System_UIntPtr:
                    if (type.IsNativeIntegerType)
                    {
                        return BinaryOperatorKind.NUInt;
                    }
                    break;
            }
            return BinaryOperatorKind.Error;
        }

        private BoundPattern BindUnaryPattern(UnaryPatternSyntax node, TypeSymbol inputType, uint inputValEscape, bool hasErrors, BindingDiagnosticBag diagnostics, bool underIsPattern)
        {
            bool permitDesignations = underIsPattern;
            BoundPattern negated = BindPattern(node.Pattern, inputType, inputValEscape, permitDesignations, hasErrors, diagnostics, underIsPattern);
            return new BoundNegatedPattern(node, negated, inputType, inputType, hasErrors);
        }

        private BoundPattern BindBinaryPattern(BinaryPatternSyntax node, TypeSymbol inputType, uint inputValEscape, bool permitDesignations, bool hasErrors, BindingDiagnosticBag diagnostics)
        {
            bool flag = node.Kind() == SyntaxKind.OrPattern;
            if (flag)
            {
                permitDesignations = false;
                BoundPattern boundPattern = BindPattern(node.Left, inputType, inputValEscape, permitDesignations, hasErrors, diagnostics);
                BoundPattern boundPattern2 = BindPattern(node.Right, inputType, inputValEscape, permitDesignations, hasErrors, diagnostics);
                ArrayBuilder<TypeSymbol> instance = ArrayBuilder<TypeSymbol>.GetInstance(2);
                collectCandidates(boundPattern, instance);
                collectCandidates(boundPattern2, instance);
                TypeSymbol narrowedType = leastSpecificType(node, instance, diagnostics) ?? inputType;
                instance.Free();
                return new BoundBinaryPattern(node, flag, boundPattern, boundPattern2, inputType, narrowedType, hasErrors);
            }
            BoundPattern boundPattern3 = BindPattern(node.Left, inputType, inputValEscape, permitDesignations, hasErrors, diagnostics);
            uint valEscape = GetValEscape(boundPattern3.NarrowedType, inputValEscape);
            BoundPattern boundPattern4 = BindPattern(node.Right, boundPattern3.NarrowedType, valEscape, permitDesignations, hasErrors, diagnostics);
            return new BoundBinaryPattern(node, flag, boundPattern3, boundPattern4, inputType, boundPattern4.NarrowedType, hasErrors);
            static void collectCandidates(BoundPattern pat, ArrayBuilder<TypeSymbol> candidates)
            {
                if (pat is BoundBinaryPattern boundBinaryPattern && boundBinaryPattern.Disjunction)
                {
                    collectCandidates(boundBinaryPattern.Left, candidates);
                    collectCandidates(boundBinaryPattern.Right, candidates);
                }
                else
                {
                    candidates.Add(pat.NarrowedType);
                }
            }
            TypeSymbol? leastSpecificType(SyntaxNode node, ArrayBuilder<TypeSymbol> candidates, BindingDiagnosticBag diagnostics)
            {
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo2 = GetNewCompoundUseSiteInfo(diagnostics);
                TypeSymbol typeSymbol = candidates[0];
                int i = 1;
                for (int count = candidates.Count; i < count; i++)
                {
                    TypeSymbol possiblyLessSpecificCandidate2 = candidates[i];
                    typeSymbol = lessSpecificCandidate(typeSymbol, possiblyLessSpecificCandidate2, ref useSiteInfo2) ?? typeSymbol;
                }
                int j = 0;
                for (int count2 = candidates.Count; j < count2; j++)
                {
                    TypeSymbol bestSoFar2 = candidates[j];
                    if ((object)lessSpecificCandidate(bestSoFar2, typeSymbol, ref useSiteInfo2) == null)
                    {
                        typeSymbol = null;
                        break;
                    }
                }
                diagnostics.Add(node.Location, useSiteInfo2);
                return typeSymbol;
            }
            TypeSymbol? lessSpecificCandidate(TypeSymbol bestSoFar, TypeSymbol possiblyLessSpecificCandidate, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
            {
                if (bestSoFar.Equals(possiblyLessSpecificCandidate, TypeCompareKind.AllIgnoreOptions))
                {
                    return bestSoFar.MergeEquivalentTypes(possiblyLessSpecificCandidate, VarianceKind.Out);
                }
                if (Conversions.HasImplicitReferenceConversion(bestSoFar, possiblyLessSpecificCandidate, ref useSiteInfo))
                {
                    return possiblyLessSpecificCandidate;
                }
                if (Conversions.HasBoxingConversion(bestSoFar, possiblyLessSpecificCandidate, ref useSiteInfo))
                {
                    return possiblyLessSpecificCandidate;
                }
                return null;
            }
        }

        internal BoundExpression BindQuery(QueryExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            FromClauseSyntax fromClause = node.FromClause;
            BoundExpression boundExpression = BindLeftOfPotentialColorColorMemberAccess(fromClause.Expression, diagnostics);
            if (boundExpression.HasDynamicType())
            {
                diagnostics.Add(ErrorCode.ERR_BadDynamicQuery, fromClause.Expression.Location);
                boundExpression = BadExpression(fromClause.Expression, boundExpression);
            }
            else
            {
                boundExpression = BindToNaturalType(boundExpression, diagnostics);
            }
            QueryTranslationState queryTranslationState = new QueryTranslationState();
            queryTranslationState.fromExpression = MakeMemberAccessValue(boundExpression, diagnostics);
            RangeVariableSymbol definedSymbol = (queryTranslationState.rangeVariable = queryTranslationState.AddRangeVariable(this, fromClause.Identifier, diagnostics));
            for (int num = node.Body.Clauses.Count - 1; num >= 0; num--)
            {
                queryTranslationState.clauses.Push(node.Body.Clauses[num]);
            }
            queryTranslationState.selectOrGroup = node.Body.SelectOrGroup;
            BoundExpression castInvocation = null;
            if (fromClause.Type != null)
            {
                TypeWithAnnotations typeArg = BindTypeArgument(fromClause.Type, diagnostics);
                castInvocation = (queryTranslationState.fromExpression = MakeQueryInvocation(fromClause, queryTranslationState.fromExpression, "Cast", fromClause.Type, typeArg, diagnostics));
            }
            queryTranslationState.fromExpression = MakeQueryClause(fromClause, queryTranslationState.fromExpression, definedSymbol, null, castInvocation);
            BoundExpression boundExpression2 = BindQueryInternal1(queryTranslationState, diagnostics);
            for (QueryContinuationSyntax continuation = node.Body.Continuation; continuation != null; continuation = continuation.Body.Continuation)
            {
                queryTranslationState.Clear();
                queryTranslationState.fromExpression = boundExpression2;
                definedSymbol = (queryTranslationState.rangeVariable = queryTranslationState.AddRangeVariable(this, continuation.Identifier, diagnostics));
                SyntaxList<QueryClauseSyntax> clauses = continuation.Body.Clauses;
                for (int num2 = clauses.Count - 1; num2 >= 0; num2--)
                {
                    queryTranslationState.clauses.Push(clauses[num2]);
                }
                queryTranslationState.selectOrGroup = continuation.Body.SelectOrGroup;
                boundExpression2 = BindQueryInternal1(queryTranslationState, diagnostics);
                boundExpression2 = MakeQueryClause(continuation.Body, boundExpression2, definedSymbol);
                boundExpression2 = MakeQueryClause(continuation, boundExpression2, definedSymbol);
            }
            queryTranslationState.Free();
            return MakeQueryClause(node, boundExpression2);
        }

        private BoundExpression BindQueryInternal1(QueryTranslationState state, BindingDiagnosticBag diagnostics)
        {
            if (!IsDegenerateQuery(state))
            {
                return BindQueryInternal2(state, diagnostics);
            }
            return FinalTranslation(state, diagnostics);
        }

        private static bool IsDegenerateQuery(QueryTranslationState state)
        {
            if (!state.clauses.IsEmpty())
            {
                return false;
            }
            if (!(state.selectOrGroup is SelectClauseSyntax selectClauseSyntax))
            {
                return false;
            }
            if (selectClauseSyntax.Expression is IdentifierNameSyntax identifierNameSyntax)
            {
                return state.rangeVariable.Name == identifierNameSyntax.Identifier.ValueText;
            }
            return false;
        }

        private BoundExpression BindQueryInternal2(QueryTranslationState state, BindingDiagnosticBag diagnostics)
        {
            while (!state.clauses.IsEmpty())
            {
                ReduceQuery(state, diagnostics);
            }
            if (state.selectOrGroup == null)
            {
                return state.fromExpression;
            }
            if (IsDegenerateQuery(state))
            {
                BoundExpression fromExpression = state.fromExpression;
                BoundExpression boundExpression = FinalTranslation(state, BindingDiagnosticBag.Discarded);
                if (boundExpression.HasAnyErrors && !fromExpression.HasAnyErrors)
                {
                    boundExpression = null;
                }
                return MakeQueryClause(state.selectOrGroup, fromExpression, null, null, null, boundExpression);
            }
            return FinalTranslation(state, diagnostics);
        }

        private BoundExpression FinalTranslation(QueryTranslationState state, BindingDiagnosticBag diagnostics)
        {
            switch (state.selectOrGroup.Kind())
            {
                case SyntaxKind.SelectClause:
                    {
                        SelectClauseSyntax selectClauseSyntax = (SelectClauseSyntax)state.selectOrGroup;
                        RangeVariableSymbol rangeVariable2 = state.rangeVariable;
                        BoundExpression fromExpression2 = state.fromExpression;
                        ExpressionSyntax expression = selectClauseSyntax.Expression;
                        UnboundLambda arg = MakeQueryUnboundLambda(state.RangeVariableMap(), rangeVariable2, expression, diagnostics.AccumulatesDependencies);
                        BoundCall boundCall = MakeQueryInvocation(state.selectOrGroup, fromExpression2, "Select", arg, diagnostics);
                        return MakeQueryClause(selectClauseSyntax, boundCall, null, boundCall);
                    }
                case SyntaxKind.GroupClause:
                    {
                        GroupClauseSyntax groupClauseSyntax = (GroupClauseSyntax)state.selectOrGroup;
                        RangeVariableSymbol rangeVariable = state.rangeVariable;
                        BoundExpression fromExpression = state.fromExpression;
                        ExpressionSyntax groupExpression = groupClauseSyntax.GroupExpression;
                        ExpressionSyntax byExpression = groupClauseSyntax.ByExpression;
                        IdentifierNameSyntax identifierNameSyntax = groupExpression as IdentifierNameSyntax;
                        UnboundLambda unboundLambda = MakeQueryUnboundLambda(state.RangeVariableMap(), rangeVariable, byExpression, diagnostics.AccumulatesDependencies);
                        BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(diagnostics);
                        BoundExpression item = MakeQueryUnboundLambda(state.RangeVariableMap(), rangeVariable, groupExpression, diagnostics.AccumulatesDependencies);
                        BoundCall result = MakeQueryInvocation(state.selectOrGroup, fromExpression, "GroupBy", ImmutableArray.Create(unboundLambda, item), instance);
                        result = ReverseLastTwoParameterOrder(result);
                        BoundExpression boundExpression = null;
                        if (identifierNameSyntax != null && identifierNameSyntax.Identifier.ValueText == rangeVariable.Name)
                        {
                            boundExpression = result;
                            result = MakeQueryInvocation(state.selectOrGroup, fromExpression, "GroupBy", unboundLambda, diagnostics);
                            if (boundExpression.HasAnyErrors && !result.HasAnyErrors)
                            {
                                boundExpression = null;
                            }
                        }
                        else
                        {
                            diagnostics.AddRange(instance);
                        }
                        instance.Free();
                        return MakeQueryClause(groupClauseSyntax, result, null, result, null, boundExpression);
                    }
                default:
                    return new BoundBadExpression(state.selectOrGroup, LookupResultKind.OverloadResolutionFailure, ImmutableArray<Symbol>.Empty, ImmutableArray.Create(state.fromExpression), state.fromExpression.Type);
            }
        }

        private static BoundCall ReverseLastTwoParameterOrder(BoundCall result)
        {
            int length = result.Arguments.Length;
            ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance();
            instance.AddRange(result.Arguments);
            BoundExpression value = instance[length - 1];
            instance[length - 1] = instance[length - 2];
            instance[length - 2] = value;
            ArrayBuilder<int> instance2 = ArrayBuilder<int>.GetInstance();
            instance2.AddRange(Enumerable.Range(0, length));
            instance2[length - 1] = length - 2;
            instance2[length - 2] = length - 1;
            BitVector defaultArguments = result.DefaultArguments.Clone();
            int index = length - 1;
            int index2 = length - 2;
            bool flag = defaultArguments[length - 2];
            bool flag2 = defaultArguments[length - 1];
            bool flag4 = (defaultArguments[index] = flag);
            flag4 = (defaultArguments[index2] = flag2);
            return result.Update(result.ReceiverOpt, result.Method, instance.ToImmutableAndFree(), default(ImmutableArray<string>), default(ImmutableArray<RefKind>), result.IsDelegateCall, result.Expanded, result.InvokedAsExtensionMethod, instance2.ToImmutableAndFree(), defaultArguments, result.ResultKind, result.OriginalMethodsOpt, result.Type);
        }

        private void ReduceQuery(QueryTranslationState state, BindingDiagnosticBag diagnostics)
        {
            QueryClauseSyntax queryClauseSyntax = state.clauses.Pop();
            switch (queryClauseSyntax.Kind())
            {
                case SyntaxKind.WhereClause:
                    ReduceWhere((WhereClauseSyntax)queryClauseSyntax, state, diagnostics);
                    break;
                case SyntaxKind.JoinClause:
                    ReduceJoin((JoinClauseSyntax)queryClauseSyntax, state, diagnostics);
                    break;
                case SyntaxKind.OrderByClause:
                    ReduceOrderBy((OrderByClauseSyntax)queryClauseSyntax, state, diagnostics);
                    break;
                case SyntaxKind.FromClause:
                    ReduceFrom((FromClauseSyntax)queryClauseSyntax, state, diagnostics);
                    break;
                case SyntaxKind.LetClause:
                    ReduceLet((LetClauseSyntax)queryClauseSyntax, state, diagnostics);
                    break;
                default:
                    throw ExceptionUtilities.UnexpectedValue(queryClauseSyntax.Kind());
            }
        }

        private void ReduceWhere(WhereClauseSyntax where, QueryTranslationState state, BindingDiagnosticBag diagnostics)
        {
            UnboundLambda arg = MakeQueryUnboundLambda(state.RangeVariableMap(), state.rangeVariable, where.Condition, diagnostics.AccumulatesDependencies);
            BoundCall boundCall = MakeQueryInvocation(where, state.fromExpression, "Where", arg, diagnostics);
            state.fromExpression = MakeQueryClause(where, boundCall, null, boundCall);
        }

        private void ReduceJoin(JoinClauseSyntax join, QueryTranslationState state, BindingDiagnosticBag diagnostics)
        {
            BoundExpression boundExpression = BindRValueWithoutTargetType(join.InExpression, diagnostics);
            if (boundExpression.HasDynamicType())
            {
                diagnostics.Add(ErrorCode.ERR_BadDynamicQuery, join.InExpression.Location);
                boundExpression = BadExpression(join.InExpression, boundExpression);
            }
            BoundExpression boundExpression2 = null;
            if (join.Type != null)
            {
                TypeWithAnnotations typeArg = BindTypeArgument(join.Type, diagnostics);
                boundExpression2 = MakeQueryInvocation(join, boundExpression, "Cast", join.Type, typeArg, diagnostics);
                boundExpression = boundExpression2;
            }
            UnboundLambda item = MakeQueryUnboundLambda(state.RangeVariableMap(), state.rangeVariable, join.LeftExpression, diagnostics.AccumulatesDependencies);
            RangeVariableSymbol rangeVariable = state.rangeVariable;
            RangeVariableSymbol rangeVariableSymbol = state.AddRangeVariable(this, join.Identifier, diagnostics);
            UnboundLambda item2 = MakeQueryUnboundLambda(QueryTranslationState.RangeVariableMap(rangeVariableSymbol), rangeVariableSymbol, join.RightExpression, diagnostics.AccumulatesDependencies);
            if (state.clauses.IsEmpty() && state.selectOrGroup.Kind() == SyntaxKind.SelectClause)
            {
                SelectClauseSyntax selectClauseSyntax = (SelectClauseSyntax)state.selectOrGroup;
                BoundCall boundCall;
                if (join.Into == null)
                {
                    UnboundLambda item3 = MakeQueryUnboundLambda(state.RangeVariableMap(), ImmutableArray.Create(rangeVariable, rangeVariableSymbol), selectClauseSyntax.Expression, diagnostics.AccumulatesDependencies);
                    boundCall = MakeQueryInvocation(join, state.fromExpression, "Join", ImmutableArray.Create(boundExpression, item, item2, item3), diagnostics);
                }
                else
                {
                    state.allRangeVariables[rangeVariableSymbol].Free();
                    state.allRangeVariables.Remove(rangeVariableSymbol);
                    RangeVariableSymbol rangeVariableSymbol2 = state.AddRangeVariable(this, join.Into!.Identifier, diagnostics);
                    UnboundLambda item4 = MakeQueryUnboundLambda(state.RangeVariableMap(), ImmutableArray.Create(rangeVariable, rangeVariableSymbol2), selectClauseSyntax.Expression, diagnostics.AccumulatesDependencies);
                    boundCall = MakeQueryInvocation(join, state.fromExpression, "GroupJoin", ImmutableArray.Create(boundExpression, item, item2, item4), diagnostics);
                    ImmutableArray<BoundExpression> arguments = boundCall.Arguments;
                    arguments = arguments.SetItem(arguments.Length - 1, MakeQueryClause(join.Into, arguments[arguments.Length - 1], rangeVariableSymbol2));
                    boundCall = boundCall.Update(boundCall.ReceiverOpt, boundCall.Method, arguments);
                }
                state.Clear();
                state.fromExpression = MakeQueryClause(join, boundCall, rangeVariableSymbol, boundCall, boundExpression2);
                state.fromExpression = MakeQueryClause(selectClauseSyntax, state.fromExpression);
            }
            else
            {
                BoundCall boundCall2;
                if (join.Into == null)
                {
                    UnboundLambda item5 = MakePairLambda(join, state, rangeVariable, rangeVariableSymbol, diagnostics.AccumulatesDependencies);
                    boundCall2 = MakeQueryInvocation(join, state.fromExpression, "Join", ImmutableArray.Create(boundExpression, item, item2, item5), diagnostics);
                }
                else
                {
                    state.allRangeVariables[rangeVariableSymbol].Free();
                    state.allRangeVariables.Remove(rangeVariableSymbol);
                    RangeVariableSymbol rangeVariableSymbol3 = state.AddRangeVariable(this, join.Into!.Identifier, diagnostics);
                    UnboundLambda item6 = MakePairLambda(join, state, rangeVariable, rangeVariableSymbol3, diagnostics.AccumulatesDependencies);
                    boundCall2 = MakeQueryInvocation(join, state.fromExpression, "GroupJoin", ImmutableArray.Create(boundExpression, item, item2, item6), diagnostics);
                    ImmutableArray<BoundExpression> arguments2 = boundCall2.Arguments;
                    arguments2 = arguments2.SetItem(arguments2.Length - 1, MakeQueryClause(join.Into, arguments2[arguments2.Length - 1], rangeVariableSymbol3));
                    boundCall2 = boundCall2.Update(boundCall2.ReceiverOpt, boundCall2.Method, arguments2);
                }
                state.fromExpression = MakeQueryClause(join, boundCall2, rangeVariableSymbol, boundCall2, boundExpression2);
            }
        }

        private void ReduceOrderBy(OrderByClauseSyntax orderby, QueryTranslationState state, BindingDiagnosticBag diagnostics)
        {
            bool flag = true;
            SeparatedSyntaxList<OrderingSyntax>.Enumerator enumerator = orderby.Orderings.GetEnumerator();
            while (enumerator.MoveNext())
            {
                OrderingSyntax current = enumerator.Current;
                string methodName = (flag ? "OrderBy" : "ThenBy") + (current.IsKind(SyntaxKind.DescendingOrdering) ? "Descending" : "");
                UnboundLambda arg = MakeQueryUnboundLambda(state.RangeVariableMap(), state.rangeVariable, current.Expression, diagnostics.AccumulatesDependencies);
                BoundCall boundCall = MakeQueryInvocation(current, state.fromExpression, methodName, arg, diagnostics);
                state.fromExpression = MakeQueryClause(current, boundCall, null, boundCall);
                flag = false;
            }
            state.fromExpression = MakeQueryClause(orderby, state.fromExpression);
        }

        private void ReduceFrom(FromClauseSyntax from, QueryTranslationState state, BindingDiagnosticBag diagnostics)
        {
            RangeVariableSymbol rangeVariable = state.rangeVariable;
            BoundExpression item = ((from.Type != null) ? MakeQueryUnboundLambdaWithCast(state.RangeVariableMap(), rangeVariable, from.Expression, from.Type, BindTypeArgument(from.Type, diagnostics), diagnostics.AccumulatesDependencies) : MakeQueryUnboundLambda(state.RangeVariableMap(), rangeVariable, from.Expression, diagnostics.AccumulatesDependencies));
            RangeVariableSymbol rangeVariableSymbol = state.AddRangeVariable(this, from.Identifier, diagnostics);
            if (state.clauses.IsEmpty() && state.selectOrGroup.IsKind(SyntaxKind.SelectClause))
            {
                SelectClauseSyntax selectClauseSyntax = (SelectClauseSyntax)state.selectOrGroup;
                UnboundLambda item2 = MakeQueryUnboundLambda(state.RangeVariableMap(), ImmutableArray.Create(rangeVariable, rangeVariableSymbol), selectClauseSyntax.Expression, diagnostics.AccumulatesDependencies);
                BoundCall boundCall = MakeQueryInvocation(from, state.fromExpression, "SelectMany", ImmutableArray.Create(item, item2), diagnostics);
                BoundExpression castInvocation = ((from.Type != null) ? ExtractCastInvocation(boundCall) : null);
                ImmutableArray<BoundExpression> arguments = boundCall.Arguments;
                boundCall = boundCall.Update(boundCall.ReceiverOpt, boundCall.Method, arguments.SetItem(arguments.Length - 2, MakeQueryClause(from, arguments[arguments.Length - 2], rangeVariableSymbol, boundCall, castInvocation)));
                state.Clear();
                state.fromExpression = MakeQueryClause(from, boundCall, rangeVariableSymbol, boundCall);
                state.fromExpression = MakeQueryClause(selectClauseSyntax, state.fromExpression);
            }
            else
            {
                UnboundLambda item3 = MakePairLambda(from, state, rangeVariable, rangeVariableSymbol, diagnostics.AccumulatesDependencies);
                BoundCall boundCall2 = MakeQueryInvocation(from, state.fromExpression, "SelectMany", ImmutableArray.Create(item, item3), diagnostics);
                BoundExpression castInvocation2 = ((from.Type != null) ? ExtractCastInvocation(boundCall2) : null);
                state.fromExpression = MakeQueryClause(from, boundCall2, rangeVariableSymbol, boundCall2, castInvocation2);
            }
        }

        private static BoundExpression? ExtractCastInvocation(BoundCall invocation)
        {
            int index = (invocation.InvokedAsExtensionMethod ? 1 : 0);
            BoundLambda boundLambda = ((invocation.Arguments[index] is BoundConversion boundConversion) ? (boundConversion.Operand as BoundLambda) : null);
            BoundReturnStatement boundReturnStatement = ((boundLambda != null) ? (boundLambda.Body.Statements[0] as BoundReturnStatement) : null);
            if (boundReturnStatement == null)
            {
                return null;
            }
            return boundReturnStatement.ExpressionOpt as BoundCall;
        }

        private UnboundLambda MakePairLambda(CSharpSyntaxNode node, QueryTranslationState state, RangeVariableSymbol x1, RangeVariableSymbol x2, bool withDependencies)
        {
            CSharpSyntaxNode node2 = node;
            RangeVariableSymbol x3 = x1;
            RangeVariableSymbol x4 = x2;
            QueryTranslationState state2 = state;
            BoundBlock bodyFactory(LambdaSymbol lambdaSymbol, Binder lambdaBodyBinder, BindingDiagnosticBag d)
            {
                BoundParameter field1Value = new BoundParameter(node2, lambdaSymbol.Parameters[0])
                {
                    WasCompilerGenerated = true
                };
                BoundParameter field2Value = new BoundParameter(node2, lambdaSymbol.Parameters[1])
                {
                    WasCompilerGenerated = true
                };
                BoundExpression expression = MakePair(node2, x3.Name, field1Value, x4.Name, field2Value, state2, d);
                return lambdaBodyBinder.CreateBlockFromExpression(node2, ImmutableArray<LocalSymbol>.Empty, RefKind.None, expression, null, d);
            }
            UnboundLambda result = MakeQueryUnboundLambda(state2.RangeVariableMap(), ImmutableArray.Create(x3, x4), node2, bodyFactory, withDependencies);
            state2.rangeVariable = state2.TransparentRangeVariable(this);
            state2.AddTransparentIdentifier(x3.Name);
            ArrayBuilder<string> arrayBuilder = state2.allRangeVariables[x4];
            arrayBuilder[arrayBuilder.Count - 1] = x4.Name;
            return result;
        }

        private void ReduceLet(LetClauseSyntax let, QueryTranslationState state, BindingDiagnosticBag diagnostics)
        {
            LetClauseSyntax let2 = let;
            QueryTranslationState state2 = state;
            RangeVariableSymbol x = state2.rangeVariable;
            BoundBlock bodyFactory(LambdaSymbol lambdaSymbol, Binder lambdaBodyBinder, BindingDiagnosticBag d)
            {
                BoundParameter field1Value = new(let2, lambdaSymbol.Parameters[0])
                {
                    WasCompilerGenerated = true
                };
                lambdaBodyBinder = lambdaBodyBinder.GetRequiredBinder(let2.Expression);
                BoundExpression boundExpression = lambdaBodyBinder.BindRValueWithoutTargetType(let2.Expression, d);
                SourceLocation location = new SourceLocation(let2.SyntaxTree, new TextSpan(let2.Identifier.SpanStart, let2.Expression.Span.End - let2.Identifier.SpanStart));
                if (!boundExpression.HasAnyErrors && !boundExpression.HasExpressionType())
                {
                    Error(d, ErrorCode.ERR_QueryRangeVariableAssignedBadValue, location, boundExpression.Display);
                    boundExpression = new BoundBadExpression(boundExpression.Syntax, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, ImmutableArray.Create(boundExpression), CreateErrorType());
                }
                else if (!boundExpression.HasAnyErrors && boundExpression.Type.IsVoidType())
                {
                    Error(d, ErrorCode.ERR_QueryRangeVariableAssignedBadValue, location, boundExpression.Type);
                    boundExpression = new BoundBadExpression(boundExpression.Syntax, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, ImmutableArray.Create(boundExpression), boundExpression.Type);
                }
                BoundExpression result = MakePair(let2, x.Name, field1Value, let2.Identifier.ValueText, boundExpression, state2, d);
                return lambdaBodyBinder.CreateLambdaBlockForQueryClause(let2.Expression, result, d);
            }
            UnboundLambda arg = MakeQueryUnboundLambda(state2.RangeVariableMap(), ImmutableArray.Create(x), let2.Expression, bodyFactory, diagnostics.AccumulatesDependencies);
            state2.rangeVariable = state2.TransparentRangeVariable(this);
            state2.AddTransparentIdentifier(x.Name);
            RangeVariableSymbol rangeVariableSymbol = state2.AddRangeVariable(this, let2.Identifier, diagnostics);
            state2.allRangeVariables[rangeVariableSymbol].Add(let2.Identifier.ValueText);
            BoundCall boundCall = MakeQueryInvocation(let2, state2.fromExpression, "Select", arg, diagnostics);
            state2.fromExpression = MakeQueryClause(let2, boundCall, rangeVariableSymbol, boundCall);
        }

        private BoundBlock CreateLambdaBlockForQueryClause(ExpressionSyntax expression, BoundExpression result, BindingDiagnosticBag diagnostics)
        {
            ImmutableArray<LocalSymbol> declaredLocalsForScope = GetDeclaredLocalsForScope(expression);
            if (declaredLocalsForScope.Any())
            {
                CheckFeatureAvailability(expression, MessageID.IDS_FeatureExpressionVariablesInQueriesAndInitializers, diagnostics, declaredLocalsForScope[0].Locations[0]);
            }
            return CreateBlockFromExpression(expression, declaredLocalsForScope, RefKind.None, result, expression, diagnostics);
        }

        private BoundQueryClause MakeQueryClause(CSharpSyntaxNode syntax, BoundExpression expression, RangeVariableSymbol? definedSymbol = null, BoundExpression? queryInvocation = null, BoundExpression? castInvocation = null, BoundExpression? unoptimizedForm = null)
        {
            if (unoptimizedForm != null && unoptimizedForm!.HasAnyErrors && !expression.HasAnyErrors)
            {
                unoptimizedForm = null;
            }
            return new BoundQueryClause(syntax, expression, definedSymbol, queryInvocation, castInvocation, this, unoptimizedForm, TypeOrError(expression));
        }

        private BoundExpression MakePair(CSharpSyntaxNode node, string field1Name, BoundExpression field1Value, string field2Name, BoundExpression field2Value, QueryTranslationState state, BindingDiagnosticBag diagnostics)
        {
            if (field1Name == field2Name)
            {
                field2Name = state.TransparentRangeVariableName();
                field2Value = new BoundBadExpression(field2Value.Syntax, LookupResultKind.Empty, ImmutableArray<Symbol>.Empty, ImmutableArray.Create(field2Value), field2Value.Type, hasErrors: true);
            }
            AnonymousTypeDescriptor typeDescr = new AnonymousTypeDescriptor(ImmutableArray.Create(new AnonymousTypeField(field1Name, field1Value.Syntax.Location, TypeWithAnnotations.Create(TypeOrError(field1Value))), new AnonymousTypeField(field2Name, field2Value.Syntax.Location, TypeWithAnnotations.Create(TypeOrError(field2Value)))), node.Location);
            NamedTypeSymbol toCreate = Compilation.AnonymousTypeManager.ConstructAnonymousTypeSymbol(typeDescr);
            return MakeConstruction(node, toCreate, ImmutableArray.Create(field1Value, field2Value), diagnostics);
        }

        private TypeSymbol TypeOrError(BoundExpression e)
        {
            return e.Type ?? CreateErrorType();
        }

        private UnboundLambda MakeQueryUnboundLambda(RangeVariableMap qvm, RangeVariableSymbol parameter, ExpressionSyntax expression, bool withDependencies)
        {
            return MakeQueryUnboundLambda(qvm, ImmutableArray.Create(parameter), expression, withDependencies);
        }

        private UnboundLambda MakeQueryUnboundLambda(RangeVariableMap qvm, ImmutableArray<RangeVariableSymbol> parameters, ExpressionSyntax expression, bool withDependencies)
        {
            ExpressionSyntax expression2 = expression;
            return MakeQueryUnboundLambda(expression2, new QueryUnboundLambdaState(this, qvm, parameters, delegate (LambdaSymbol lambdaSymbol, Binder lambdaBodyBinder, BindingDiagnosticBag diagnostics)
            {
                lambdaBodyBinder = lambdaBodyBinder.GetRequiredBinder(expression2);
                BoundExpression result = lambdaBodyBinder.BindValue(expression2, diagnostics, BindValueKind.RValue);
                return lambdaBodyBinder.CreateLambdaBlockForQueryClause(expression2, result, diagnostics);
            }), withDependencies);
        }

        private UnboundLambda MakeQueryUnboundLambdaWithCast(RangeVariableMap qvm, RangeVariableSymbol parameter, ExpressionSyntax expression, TypeSyntax castTypeSyntax, TypeWithAnnotations castType, bool withDependencies)
        {
            ExpressionSyntax expression2 = expression;
            TypeSyntax castTypeSyntax2 = castTypeSyntax;
            return MakeQueryUnboundLambda(expression2, new QueryUnboundLambdaState(this, qvm, ImmutableArray.Create(parameter), delegate (LambdaSymbol lambdaSymbol, Binder lambdaBodyBinder, BindingDiagnosticBag diagnostics)
            {
                lambdaBodyBinder = lambdaBodyBinder.GetRequiredBinder(expression2);
                BoundExpression receiver = lambdaBodyBinder.BindValue(expression2, diagnostics, BindValueKind.RValue);
                receiver = lambdaBodyBinder.MakeQueryInvocation(expression2, receiver, "Cast", castTypeSyntax2, castType, diagnostics);
                return lambdaBodyBinder.CreateLambdaBlockForQueryClause(expression2, receiver, diagnostics);
            }), withDependencies);
        }

        private UnboundLambda MakeQueryUnboundLambda(RangeVariableMap qvm, ImmutableArray<RangeVariableSymbol> parameters, CSharpSyntaxNode node, LambdaBodyFactory bodyFactory, bool withDependencies)
        {
            return MakeQueryUnboundLambda(node, new QueryUnboundLambdaState(this, qvm, parameters, bodyFactory), withDependencies);
        }

        private static UnboundLambda MakeQueryUnboundLambda(CSharpSyntaxNode node, QueryUnboundLambdaState state, bool withDependencies)
        {
            UnboundLambda unboundLambda = new UnboundLambda(node, state, withDependencies, hasErrors: false)
            {
                WasCompilerGenerated = true
            };
            state.SetUnboundLambda(unboundLambda);
            return unboundLambda;
        }

        protected BoundCall MakeQueryInvocation(CSharpSyntaxNode node, BoundExpression receiver, string methodName, BoundExpression arg, BindingDiagnosticBag diagnostics)
        {
            return MakeQueryInvocation(node, receiver, methodName, default(SeparatedSyntaxList<TypeSyntax>), default(ImmutableArray<TypeWithAnnotations>), ImmutableArray.Create(arg), diagnostics);
        }

        protected BoundCall MakeQueryInvocation(CSharpSyntaxNode node, BoundExpression receiver, string methodName, ImmutableArray<BoundExpression> args, BindingDiagnosticBag diagnostics)
        {
            return MakeQueryInvocation(node, receiver, methodName, default(SeparatedSyntaxList<TypeSyntax>), default(ImmutableArray<TypeWithAnnotations>), args, diagnostics);
        }

        protected BoundCall MakeQueryInvocation(CSharpSyntaxNode node, BoundExpression receiver, string methodName, TypeSyntax typeArgSyntax, TypeWithAnnotations typeArg, BindingDiagnosticBag diagnostics)
        {
            return MakeQueryInvocation(node, receiver, methodName, new SeparatedSyntaxList<TypeSyntax>(new SyntaxNodeOrTokenList(typeArgSyntax, 0)), ImmutableArray.Create(typeArg), ImmutableArray<BoundExpression>.Empty, diagnostics);
        }

        protected BoundCall MakeQueryInvocation(CSharpSyntaxNode node, BoundExpression receiver, string methodName, SeparatedSyntaxList<TypeSyntax> typeArgsSyntax, ImmutableArray<TypeWithAnnotations> typeArgs, ImmutableArray<BoundExpression> args, BindingDiagnosticBag diagnostics)
        {
            BoundExpression boundExpression = receiver;
            while (boundExpression.Kind == BoundKind.QueryClause)
            {
                boundExpression = ((BoundQueryClause)boundExpression).Value;
            }
            if ((object)boundExpression.Type == null)
            {
                if (!boundExpression.HasAnyErrors && !node.HasErrors)
                {
                    if (boundExpression.IsLiteralNull())
                    {
                        diagnostics.Add(ErrorCode.ERR_NullNotValid, node.Location);
                    }
                    else if (boundExpression.IsLiteralDefault())
                    {
                        diagnostics.Add(ErrorCode.ERR_DefaultLiteralNotValid, node.Location);
                    }
                    else if (boundExpression.IsImplicitObjectCreation())
                    {
                        diagnostics.Add(ErrorCode.ERR_ImplicitObjectCreationNotValid, node.Location);
                    }
                    else if (boundExpression.Kind == BoundKind.NamespaceExpression)
                    {
                        diagnostics.Add(ErrorCode.ERR_BadSKunknown, boundExpression.Syntax.Location, ((BoundNamespaceExpression)boundExpression).NamespaceSymbol, MessageID.IDS_SK_NAMESPACE.Localize());
                    }
                    else if (boundExpression.Kind == BoundKind.Lambda || boundExpression.Kind == BoundKind.UnboundLambda)
                    {
                        diagnostics.Add(ErrorCode.ERR_QueryNoProvider, node.Location, MessageID.IDS_AnonMethod.Localize(), methodName);
                    }
                    else if (boundExpression.Kind == BoundKind.MethodGroup)
                    {
                        BoundMethodGroup node2 = (BoundMethodGroup)boundExpression;
                        CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                        CallingConventionInfo callingConventionInfo = default(CallingConventionInfo);
                        MethodGroupResolution methodGroupResolution = ResolveMethodGroup(node2, null, isMethodGroupConversion: false, ref useSiteInfo, inferWithDynamic: false, RefKind.None, null, isFunctionPointerResolution: false, in callingConventionInfo);
                        diagnostics.Add(node, useSiteInfo);
                        diagnostics.AddRange(methodGroupResolution.Diagnostics);
                        if (methodGroupResolution.HasAnyErrors)
                        {
                            receiver = BindMemberAccessBadResult(node2);
                        }
                        else
                        {
                            diagnostics.Add(ErrorCode.ERR_QueryNoProvider, node.Location, MessageID.IDS_SK_METHOD.Localize(), methodName);
                        }
                        methodGroupResolution.Free();
                    }
                }
                receiver = new BoundBadExpression(receiver.Syntax, LookupResultKind.NotAValue, ImmutableArray<Symbol>.Empty, ImmutableArray.Create(receiver), CreateErrorType());
            }
            else if (boundExpression.Kind == BoundKind.TypeExpression)
            {
                if (boundExpression.Type!.TypeKind == TypeKind.TypeParameter)
                {
                    Error(diagnostics, ErrorCode.ERR_BadSKunknown, boundExpression.Syntax, boundExpression.Type, MessageID.IDS_SK_TYVAR.Localize());
                }
            }
            else if (boundExpression.Kind != BoundKind.TypeOrValueExpression)
            {
                if (receiver.Type.IsVoidType())
                {
                    if (!receiver.HasAnyErrors && !node.HasErrors)
                    {
                        diagnostics.Add(ErrorCode.ERR_QueryNoProvider, node.Location, "void", methodName);
                    }
                    receiver = new BoundBadExpression(receiver.Syntax, LookupResultKind.NotAValue, ImmutableArray<Symbol>.Empty, ImmutableArray.Create(receiver), CreateErrorType());
                }
                else
                {
                    BoundExpression boundExpression2 = CheckValue(boundExpression, BindValueKind.RValue, diagnostics);
                    if (boundExpression2 != boundExpression)
                    {
                        receiver = updateUltimateReceiver(receiver, boundExpression, boundExpression2);
                    }
                }
            }
            return (BoundCall)MakeInvocationExpression(node, receiver, methodName, args, diagnostics, typeArgsSyntax, typeArgs, node, allowFieldsAndProperties: true);
            static BoundExpression updateUltimateReceiver(BoundExpression receiver, BoundExpression originalUltimateReceiver, BoundExpression replacementUltimateReceiver)
            {
                if (receiver is BoundQueryClause boundQueryClause)
                {
                    return boundQueryClause.Update(updateUltimateReceiver(boundQueryClause.Value, originalUltimateReceiver, replacementUltimateReceiver), boundQueryClause.DefinedSymbol, boundQueryClause.Operation, boundQueryClause.Cast, boundQueryClause.Binder, boundQueryClause.UnoptimizedForm, boundQueryClause.Type);
                }
                return replacementUltimateReceiver;
            }
        }

        protected BoundExpression MakeConstruction(CSharpSyntaxNode node, NamedTypeSymbol toCreate, ImmutableArray<BoundExpression> args, BindingDiagnosticBag diagnostics)
        {
            AnalyzedArguments instance = AnalyzedArguments.GetInstance();
            instance.Arguments.AddRange(args);
            BoundExpression boundExpression = BindClassCreationExpression(node, toCreate.Name, node, toCreate, instance, diagnostics);
            boundExpression.WasCompilerGenerated = true;
            instance.Free();
            return boundExpression;
        }

        internal void ReportQueryLookupFailed(SyntaxNode queryClause, BoundExpression instanceArgument, string name, ImmutableArray<Symbol> symbols, BindingDiagnosticBag diagnostics)
        {
            FromClauseSyntax fromClauseSyntax = null;
            SyntaxNode syntaxNode = queryClause;
            QueryExpressionSyntax queryExpressionSyntax;
            while (true)
            {
                queryExpressionSyntax = syntaxNode as QueryExpressionSyntax;
                if (queryExpressionSyntax != null)
                {
                    break;
                }
                syntaxNode = syntaxNode.Parent;
            }
            fromClauseSyntax = queryExpressionSyntax.FromClause;
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            if (instanceArgument.Type.IsDynamic())
            {
                diagnostics.Add(new DiagnosticInfoWithSymbols(ErrorCode.ERR_BadDynamicQuery, new object[0], symbols), new SourceLocation(queryClause));
            }
            else if (ImplementsStandardQueryInterface(instanceArgument.Type, name, ref useSiteInfo))
            {
                diagnostics.Add(new DiagnosticInfoWithSymbols(ErrorCode.ERR_QueryNoProviderStandard, new object[2] { instanceArgument.Type, name }, symbols), new SourceLocation((fromClauseSyntax != null) ? fromClauseSyntax.Expression : queryClause));
            }
            else if (fromClauseSyntax != null && fromClauseSyntax.Type == null && HasCastToQueryProvider(instanceArgument.Type, ref useSiteInfo))
            {
                diagnostics.Add(new DiagnosticInfoWithSymbols(ErrorCode.ERR_QueryNoProviderCastable, new object[3]
                {
                    instanceArgument.Type,
                    name,
                    fromClauseSyntax.Identifier.ValueText
                }, symbols), new SourceLocation(fromClauseSyntax.Expression));
            }
            else
            {
                diagnostics.Add(new DiagnosticInfoWithSymbols(ErrorCode.ERR_QueryNoProvider, new object[2] { instanceArgument.Type, name }, symbols), new SourceLocation((fromClauseSyntax != null) ? fromClauseSyntax.Expression : queryClause));
            }
            diagnostics.Add(queryClause, useSiteInfo);
        }

        private bool ImplementsStandardQueryInterface(TypeSymbol instanceType, string name, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            if (instanceType.TypeKind == TypeKind.Array || (name == "Cast" && HasCastToQueryProvider(instanceType, ref useSiteInfo)))
            {
                return true;
            }
            bool nonUnique = false;
            TypeSymbol originalDefinition = instanceType.OriginalDefinition;
            NamedTypeSymbol specialType = Compilation.GetSpecialType(SpecialType.System_Collections_Generic_IEnumerable_T);
            NamedTypeSymbol wellKnownType = Compilation.GetWellKnownType(WellKnownType.System_Linq_IQueryable_T);
            bool flag = TypeSymbol.Equals(originalDefinition, specialType, TypeCompareKind.ConsiderEverything) || HasUniqueInterface(instanceType, specialType, ref nonUnique, ref useSiteInfo);
            bool flag2 = TypeSymbol.Equals(originalDefinition, wellKnownType, TypeCompareKind.ConsiderEverything) || HasUniqueInterface(instanceType, wellKnownType, ref nonUnique, ref useSiteInfo);
            if (flag != flag2)
            {
                return !nonUnique;
            }
            return false;
        }

        private static bool HasUniqueInterface(TypeSymbol instanceType, NamedTypeSymbol interfaceType, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            bool nonUnique = false;
            return HasUniqueInterface(instanceType, interfaceType, ref nonUnique, ref useSiteInfo);
        }

        private static bool HasUniqueInterface(TypeSymbol instanceType, NamedTypeSymbol interfaceType, ref bool nonUnique, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            TypeSymbol typeSymbol = null;
            ImmutableArray<NamedTypeSymbol>.Enumerator enumerator = instanceType.AllInterfacesWithDefinitionUseSiteDiagnostics(ref useSiteInfo).GetEnumerator();
            while (enumerator.MoveNext())
            {
                NamedTypeSymbol current = enumerator.Current;
                if (TypeSymbol.Equals(current.OriginalDefinition, interfaceType, TypeCompareKind.ConsiderEverything))
                {
                    if ((object)typeSymbol == null)
                    {
                        typeSymbol = current;
                    }
                    else if (!TypeSymbol.Equals(typeSymbol, current, TypeCompareKind.ConsiderEverything))
                    {
                        nonUnique = true;
                        return false;
                    }
                }
            }
            return (object)typeSymbol != null;
        }

        private bool HasCastToQueryProvider(TypeSymbol instanceType, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            TypeSymbol originalDefinition = instanceType.OriginalDefinition;
            NamedTypeSymbol specialType = Compilation.GetSpecialType(SpecialType.System_Collections_IEnumerable);
            NamedTypeSymbol wellKnownType = Compilation.GetWellKnownType(WellKnownType.System_Linq_IQueryable);
            bool flag = TypeSymbol.Equals(originalDefinition, specialType, TypeCompareKind.ConsiderEverything) || HasUniqueInterface(instanceType, specialType, ref useSiteInfo);
            bool flag2 = TypeSymbol.Equals(originalDefinition, wellKnownType, TypeCompareKind.ConsiderEverything) || HasUniqueInterface(instanceType, wellKnownType, ref useSiteInfo);
            return flag != flag2;
        }

        private static bool IsJoinRangeVariableInLeftKey(SimpleNameSyntax node)
        {
            for (CSharpSyntaxNode parent = node.Parent; parent != null; parent = parent.Parent)
            {
                if (parent.Kind() == SyntaxKind.JoinClause)
                {
                    JoinClauseSyntax joinClauseSyntax = (JoinClauseSyntax)parent;
                    if (joinClauseSyntax.LeftExpression.Span.Contains(node.Span) && joinClauseSyntax.Identifier.ValueText == node.Identifier.ValueText)
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        private static bool IsInJoinRightKey(SimpleNameSyntax node)
        {
            for (CSharpSyntaxNode parent = node.Parent; parent != null; parent = parent.Parent)
            {
                if (parent.Kind() == SyntaxKind.JoinClause && ((JoinClauseSyntax)parent).RightExpression.Span.Contains(node.Span))
                {
                    return true;
                }
            }
            return false;
        }

        internal static void ReportQueryInferenceFailed(CSharpSyntaxNode queryClause, string methodName, BoundExpression receiver, AnalyzedArguments arguments, ImmutableArray<Symbol> symbols, BindingDiagnosticBag diagnostics)
        {
            string text = null;
            bool flag = false;
            switch (queryClause.Kind())
            {
                case SyntaxKind.JoinClause:
                    text = SyntaxFacts.GetText(SyntaxKind.JoinKeyword);
                    flag = true;
                    break;
                case SyntaxKind.LetClause:
                    text = SyntaxFacts.GetText(SyntaxKind.LetKeyword);
                    break;
                case SyntaxKind.SelectClause:
                    text = SyntaxFacts.GetText(SyntaxKind.SelectKeyword);
                    break;
                case SyntaxKind.WhereClause:
                    text = SyntaxFacts.GetText(SyntaxKind.WhereKeyword);
                    break;
                case SyntaxKind.OrderByClause:
                case SyntaxKind.AscendingOrdering:
                case SyntaxKind.DescendingOrdering:
                    text = SyntaxFacts.GetText(SyntaxKind.OrderByKeyword);
                    flag = true;
                    break;
                case SyntaxKind.QueryContinuation:
                    text = SyntaxFacts.GetText(SyntaxKind.IntoKeyword);
                    break;
                case SyntaxKind.GroupClause:
                    text = SyntaxFacts.GetText(SyntaxKind.GroupKeyword) + " " + SyntaxFacts.GetText(SyntaxKind.ByKeyword);
                    flag = true;
                    break;
                case SyntaxKind.FromClause:
                    if (ReportQueryInferenceFailedSelectMany((FromClauseSyntax)queryClause, methodName, receiver, arguments, symbols, diagnostics))
                    {
                        return;
                    }
                    text = SyntaxFacts.GetText(SyntaxKind.FromKeyword);
                    break;
                default:
                    throw ExceptionUtilities.UnexpectedValue(queryClause.Kind());
            }
            diagnostics.Add(new DiagnosticInfoWithSymbols(flag ? ErrorCode.ERR_QueryTypeInferenceFailedMulti : ErrorCode.ERR_QueryTypeInferenceFailed, new object[2] { text, methodName }, symbols), queryClause.GetFirstToken().GetLocation());
        }

        private static bool ReportQueryInferenceFailedSelectMany(FromClauseSyntax fromClause, string methodName, BoundExpression receiver, AnalyzedArguments arguments, ImmutableArray<Symbol> symbols, BindingDiagnosticBag diagnostics)
        {
            BoundExpression boundExpression = arguments.Argument(arguments.IsExtensionMethodInvocation ? 1 : 0);
            TypeSymbol typeSymbol = null;
            if (boundExpression.Kind == BoundKind.UnboundLambda)
            {
                foreach (TypeSymbol item in ((UnboundLambda)boundExpression).Data.InferredReturnTypes())
                {
                    if (!item.IsErrorType())
                    {
                        typeSymbol = item;
                        break;
                    }
                }
            }
            if ((object)typeSymbol == null || typeSymbol.IsErrorType())
            {
                return false;
            }
            TypeSymbol typeSymbol2 = receiver?.Type;
            diagnostics.Add(new DiagnosticInfoWithSymbols(ErrorCode.ERR_QueryTypeInferenceFailedSelectMany, new object[3] { typeSymbol, typeSymbol2, methodName }, symbols), fromClause.Expression.Location);
            return true;
        }

        public virtual BoundStatement BindStatement(StatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            if (node.AttributeLists.Count > 0)
            {
                AttributeListSyntax syntax = node.AttributeLists[0];
                if (node.Kind() == SyntaxKind.LocalFunctionStatement)
                {
                    CheckFeatureAvailability(syntax, MessageID.IDS_FeatureLocalFunctionAttributes, diagnostics);
                }
                else if (node.Kind() != SyntaxKind.Block)
                {
                    Error(diagnostics, ErrorCode.ERR_AttributesNotAllowed, syntax);
                }
            }
            switch (node.Kind())
            {
                case SyntaxKind.Block:
                    return BindBlock((BlockSyntax)node, diagnostics);
                case SyntaxKind.LocalDeclarationStatement:
                    return BindLocalDeclarationStatement((LocalDeclarationStatementSyntax)node, diagnostics);
                case SyntaxKind.LocalFunctionStatement:
                    return BindLocalFunctionStatement((LocalFunctionStatementSyntax)node, diagnostics);
                case SyntaxKind.ExpressionStatement:
                    return BindExpressionStatement((ExpressionStatementSyntax)node, diagnostics);
                case SyntaxKind.IfStatement:
                    return BindIfStatement((IfStatementSyntax)node, diagnostics);
                case SyntaxKind.SwitchStatement:
                    return BindSwitchStatement((SwitchStatementSyntax)node, diagnostics);
                case SyntaxKind.DoStatement:
                    return BindDo((DoStatementSyntax)node, diagnostics);
                case SyntaxKind.WhileStatement:
                    return BindWhile((WhileStatementSyntax)node, diagnostics);
                case SyntaxKind.ForStatement:
                    return BindFor((ForStatementSyntax)node, diagnostics);
                case SyntaxKind.ForEachStatement:
                case SyntaxKind.ForEachVariableStatement:
                    return BindForEach((CommonForEachStatementSyntax)node, diagnostics);
                case SyntaxKind.BreakStatement:
                    return BindBreak((BreakStatementSyntax)node, diagnostics);
                case SyntaxKind.ContinueStatement:
                    return BindContinue((ContinueStatementSyntax)node, diagnostics);
                case SyntaxKind.ReturnStatement:
                    return BindReturn((ReturnStatementSyntax)node, diagnostics);
                case SyntaxKind.FixedStatement:
                    return BindFixedStatement((FixedStatementSyntax)node, diagnostics);
                case SyntaxKind.LabeledStatement:
                    return BindLabeled((LabeledStatementSyntax)node, diagnostics);
                case SyntaxKind.GotoStatement:
                case SyntaxKind.GotoCaseStatement:
                case SyntaxKind.GotoDefaultStatement:
                    return BindGoto((GotoStatementSyntax)node, diagnostics);
                case SyntaxKind.TryStatement:
                    return BindTryStatement((TryStatementSyntax)node, diagnostics);
                case SyntaxKind.EmptyStatement:
                    return BindEmpty((EmptyStatementSyntax)node);
                case SyntaxKind.ThrowStatement:
                    return BindThrow((ThrowStatementSyntax)node, diagnostics);
                case SyntaxKind.UnsafeStatement:
                    return BindUnsafeStatement((UnsafeStatementSyntax)node, diagnostics);
                case SyntaxKind.CheckedStatement:
                case SyntaxKind.UncheckedStatement:
                    return BindCheckedStatement((CheckedStatementSyntax)node, diagnostics);
                case SyntaxKind.UsingStatement:
                    return BindUsingStatement((UsingStatementSyntax)node, diagnostics);
                case SyntaxKind.YieldBreakStatement:
                    return BindYieldBreakStatement((YieldStatementSyntax)node, diagnostics);
                case SyntaxKind.YieldReturnStatement:
                    return BindYieldReturnStatement((YieldStatementSyntax)node, diagnostics);
                case SyntaxKind.LockStatement:
                    return BindLockStatement((LockStatementSyntax)node, diagnostics);
                default:
                    return new BoundBadStatement(node, ImmutableArray<BoundNode>.Empty, hasErrors: true);
            }
        }

        private BoundStatement BindCheckedStatement(CheckedStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            return BindEmbeddedBlock(node.Block, diagnostics);
        }

        private BoundStatement BindUnsafeStatement(UnsafeStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            GetBinder(node);
            if (!Compilation.Options.AllowUnsafe)
            {
                Error(diagnostics, ErrorCode.ERR_IllegalUnsafe, node.UnsafeKeyword);
            }
            else if (IsIndirectlyInIterator)
            {
                Error(diagnostics, ErrorCode.ERR_IllegalInnerUnsafe, node.UnsafeKeyword);
            }
            return BindEmbeddedBlock(node.Block, diagnostics);
        }

        private BoundStatement BindFixedStatement(FixedStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            Binder? binder = GetBinder(node);
            binder!.ReportUnsafeIfNotAllowed(node, diagnostics);
            return binder!.BindFixedStatementParts(node, diagnostics);
        }

        private BoundStatement BindFixedStatementParts(FixedStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            VariableDeclarationSyntax declaration = node.Declaration;
            BindForOrUsingOrFixedDeclarations(declaration, LocalDeclarationKind.FixedVariable, diagnostics, out var declarations);
            BoundMultipleLocalDeclarations declarations2 = new BoundMultipleLocalDeclarations(declaration, declarations);
            BoundStatement body = BindPossibleEmbeddedStatement(node.Statement, diagnostics);
            return new BoundFixedStatement(node, GetDeclaredLocalsForScope(node), declarations2, body);
        }

        private void CheckRequiredLangVersionForAsyncIteratorMethods(BindingDiagnosticBag diagnostics)
        {
            MethodSymbol methodSymbol = (MethodSymbol)ContainingMemberOrLambda;
            if (methodSymbol.IsAsync)
            {
                MessageID.IDS_FeatureAsyncStreams.CheckFeatureAvailability(diagnostics, methodSymbol.DeclaringCompilation, methodSymbol.Locations[0]);
            }
        }

        protected virtual void ValidateYield(YieldStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            Next?.ValidateYield(node, diagnostics);
        }

        private BoundStatement BindYieldReturnStatement(YieldStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            ValidateYield(node, diagnostics);
            TypeSymbol type = GetIteratorElementType().Type;
            BoundExpression expr = ((node.Expression == null) ? BadExpression(node).MakeCompilerGenerated() : BindValue(node.Expression, diagnostics, BindValueKind.RValue));
            expr = ValidateEscape(expr, 0u, isByRef: false, diagnostics);
            expr = (expr.HasAnyErrors ? BindToTypeForErrorRecovery(expr) : GenerateConversionForAssignment(type, expr, diagnostics));
            if (Flags.Includes(BinderFlags.InFinallyBlock))
            {
                Error(diagnostics, ErrorCode.ERR_BadYieldInFinally, node.YieldKeyword);
            }
            else if (Flags.Includes(BinderFlags.InTryBlockOfTryCatch))
            {
                Error(diagnostics, ErrorCode.ERR_BadYieldInTryOfCatch, node.YieldKeyword);
            }
            else if (Flags.Includes(BinderFlags.InCatchBlock))
            {
                Error(diagnostics, ErrorCode.ERR_BadYieldInCatch, node.YieldKeyword);
            }
            else if (BindingTopLevelScriptCode)
            {
                Error(diagnostics, ErrorCode.ERR_YieldNotAllowedInScript, node.YieldKeyword);
            }
            CheckRequiredLangVersionForAsyncIteratorMethods(diagnostics);
            return new BoundYieldReturnStatement(node, expr);
        }

        private BoundStatement BindYieldBreakStatement(YieldStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            if (Flags.Includes(BinderFlags.InFinallyBlock))
            {
                Error(diagnostics, ErrorCode.ERR_BadYieldInFinally, node.YieldKeyword);
            }
            else if (BindingTopLevelScriptCode)
            {
                Error(diagnostics, ErrorCode.ERR_YieldNotAllowedInScript, node.YieldKeyword);
            }
            ValidateYield(node, diagnostics);
            CheckRequiredLangVersionForAsyncIteratorMethods(diagnostics);
            return new BoundYieldBreakStatement(node);
        }

        private BoundStatement BindLockStatement(LockStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            Binder binder = GetBinder(node);
            return binder.BindLockStatementParts(diagnostics, binder);
        }

        internal virtual BoundStatement BindLockStatementParts(BindingDiagnosticBag diagnostics, Binder originalBinder)
        {
            return Next!.BindLockStatementParts(diagnostics, originalBinder);
        }

        private BoundStatement BindUsingStatement(UsingStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            Binder binder = GetBinder(node);
            return binder.BindUsingStatementParts(diagnostics, binder);
        }

        internal virtual BoundStatement BindUsingStatementParts(BindingDiagnosticBag diagnostics, Binder originalBinder)
        {
            return Next!.BindUsingStatementParts(diagnostics, originalBinder);
        }

        internal BoundStatement BindPossibleEmbeddedStatement(StatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            switch (node.Kind())
            {
                case SyntaxKind.LocalDeclarationStatement:
                    diagnostics.Add(ErrorCode.ERR_BadEmbeddedStmt, node.GetLocation());
                    goto case SyntaxKind.ExpressionStatement;
                case SyntaxKind.ExpressionStatement:
                case SyntaxKind.ReturnStatement:
                case SyntaxKind.YieldReturnStatement:
                case SyntaxKind.ThrowStatement:
                case SyntaxKind.LockStatement:
                case SyntaxKind.IfStatement:
                    {
                        Binder binder = GetBinder(node);
                        return binder.WrapWithVariablesIfAny(node, binder.BindStatement(node, diagnostics));
                    }
                case SyntaxKind.LabeledStatement:
                case SyntaxKind.LocalFunctionStatement:
                    {
                        diagnostics.Add(ErrorCode.ERR_BadEmbeddedStmt, node.GetLocation());
                        Binder binder = GetBinder(node);
                        return binder.WrapWithVariablesAndLocalFunctionsIfAny(node, binder.BindStatement(node, diagnostics));
                    }
                case SyntaxKind.SwitchStatement:
                    {
                        SwitchStatementSyntax switchStatementSyntax = (SwitchStatementSyntax)node;
                        Binder binder = GetBinder(switchStatementSyntax.Expression);
                        return binder.WrapWithVariablesIfAny(switchStatementSyntax.Expression, binder.BindStatement(node, diagnostics));
                    }
                case SyntaxKind.EmptyStatement:
                    {
                        EmptyStatementSyntax emptyStatementSyntax = (EmptyStatementSyntax)node;
                        if (!emptyStatementSyntax.SemicolonToken.IsMissing)
                        {
                            SyntaxKind syntaxKind = node.Parent!.Kind();
                            if ((syntaxKind != SyntaxKind.WhileStatement && syntaxKind - 8811 > SyntaxKind.List && syntaxKind != SyntaxKind.ForEachVariableStatement) || emptyStatementSyntax.SemicolonToken.GetNextToken().Kind() == SyntaxKind.OpenBraceToken)
                            {
                                diagnostics.Add(ErrorCode.WRN_PossibleMistakenNullStatement, node.GetLocation());
                            }
                        }
                        break;
                    }
            }
            return BindStatement(node, diagnostics);
        }

        private BoundExpression BindThrownExpression(ExpressionSyntax exprSyntax, BindingDiagnosticBag diagnostics, ref bool hasErrors)
        {
            BoundExpression boundExpression = BindValue(exprSyntax, diagnostics, BindValueKind.RValue);
            if (Compilation.LanguageVersion < MessageID.IDS_FeatureSwitchExpression.RequiredVersion())
            {
                if (!boundExpression.IsLiteralNull())
                {
                    boundExpression = BindToNaturalType(boundExpression, diagnostics);
                    TypeSymbol type = boundExpression.Type;
                    CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                    if ((object)type == null || (!type.IsErrorType() && !Compilation.IsExceptionType(type.EffectiveType(ref useSiteInfo), ref useSiteInfo)))
                    {
                        diagnostics.Add(ErrorCode.ERR_BadExceptionType, exprSyntax.Location);
                        hasErrors = true;
                        diagnostics.Add(exprSyntax, useSiteInfo);
                    }
                    else
                    {
                        diagnostics.AddDependencies(useSiteInfo);
                    }
                }
            }
            else
            {
                boundExpression = GenerateConversionForAssignment(GetWellKnownType(WellKnownType.System_Exception, diagnostics, exprSyntax), boundExpression, diagnostics);
            }
            return boundExpression;
        }

        private BoundStatement BindThrow(ThrowStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            BoundExpression expressionOpt = null;
            bool hasErrors = false;
            ExpressionSyntax expression = node.Expression;
            if (expression != null)
            {
                expressionOpt = BindThrownExpression(expression, diagnostics, ref hasErrors);
            }
            else if (!Flags.Includes(BinderFlags.InCatchBlock))
            {
                diagnostics.Add(ErrorCode.ERR_BadEmptyThrow, node.ThrowKeyword.GetLocation());
                hasErrors = true;
            }
            else if (Flags.Includes(BinderFlags.InNestedFinallyBlock))
            {
                diagnostics.Add(ErrorCode.ERR_BadEmptyThrowInFinally, node.ThrowKeyword.GetLocation());
                hasErrors = true;
            }
            return new BoundThrowStatement(node, expressionOpt, hasErrors);
        }

        private static BoundStatement BindEmpty(EmptyStatementSyntax node)
        {
            return new BoundNoOpStatement(node, NoOpStatementFlavor.Default);
        }

        private BoundLabeledStatement BindLabeled(LabeledStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            bool hasErrors = false;
            LookupResult instance = LookupResult.GetInstance();
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            Binder binder = LookupSymbolsWithFallback(instance, node.Identifier.ValueText, 0, ref useSiteInfo, null, LookupOptions.LabelsOnly);
            LabelSymbol labelSymbol = ((instance.Symbols.Count > 0 && instance.IsMultiViable) ? ((LabelSymbol)instance.Symbols.First()) : new SourceLabelSymbol((MethodSymbol)ContainingMemberOrLambda, node.Identifier));
            if (!labelSymbol.IdentifierNodeOrToken.IsToken || labelSymbol.IdentifierNodeOrToken.AsToken() != node.Identifier)
            {
                Error(diagnostics, ErrorCode.ERR_DuplicateLabel, node.Identifier, node.Identifier.ValueText);
                hasErrors = true;
            }
            if (binder != null)
            {
                instance.Clear();
                binder.Next!.LookupSymbolsWithFallback(instance, node.Identifier.ValueText, 0, ref useSiteInfo, null, LookupOptions.LabelsOnly);
                if (instance.IsMultiViable)
                {
                    Error(diagnostics, ErrorCode.ERR_LabelShadow, node.Identifier, node.Identifier.ValueText);
                    hasErrors = true;
                }
            }
            diagnostics.Add(node, useSiteInfo);
            instance.Free();
            BoundStatement body = BindStatement(node.Statement, diagnostics);
            return new BoundLabeledStatement(node, labelSymbol, body, hasErrors);
        }

        private BoundStatement BindGoto(GotoStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            switch (node.Kind())
            {
                case SyntaxKind.GotoStatement:
                    {
                        BoundExpression boundExpression = BindLabel(node.Expression, diagnostics);
                        if (!(boundExpression is BoundLabel boundLabel))
                        {
                            return new BoundBadStatement(node, ImmutableArray.Create((BoundNode)boundExpression), hasErrors: true);
                        }
                        LabelSymbol label = boundLabel.Label;
                        return new BoundGotoStatement(node, label, null, boundLabel);
                    }
                case SyntaxKind.GotoCaseStatement:
                case SyntaxKind.GotoDefaultStatement:
                    {
                        SwitchBinder switchBinder = GetSwitchBinder(this);
                        if (switchBinder == null)
                        {
                            Error(diagnostics, ErrorCode.ERR_InvalidGotoCase, node);
                            ImmutableArray<BoundNode> childBoundNodes = ((node.Expression == null) ? ImmutableArray<BoundNode>.Empty : ImmutableArray.Create((BoundNode)BindRValueWithoutTargetType(node.Expression, BindingDiagnosticBag.Discarded)));
                            return new BoundBadStatement(node, childBoundNodes, hasErrors: true);
                        }
                        return switchBinder.BindGotoCaseOrDefault(node, this, diagnostics);
                    }
                default:
                    throw ExceptionUtilities.UnexpectedValue(node.Kind());
            }
        }

        private BoundStatement BindLocalFunctionStatement(LocalFunctionStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            LocalFunctionSymbol localSymbol = LookupLocalFunction(node.Identifier);
            bool flag = localSymbol.ScopeBinder.ValidateDeclarationNameConflictsInScope(localSymbol, diagnostics);
            BoundBlock boundBlock = null;
            BoundBlock boundBlock2 = null;
            if (node.Body != null)
            {
                boundBlock = runAnalysis(BindEmbeddedBlock(node.Body, diagnostics), diagnostics);
                if (node.ExpressionBody != null)
                {
                    boundBlock2 = runAnalysis(BindExpressionBodyAsBlock(node.ExpressionBody, BindingDiagnosticBag.Discarded), BindingDiagnosticBag.Discarded);
                }
            }
            else if (node.ExpressionBody != null)
            {
                boundBlock2 = runAnalysis(BindExpressionBodyAsBlock(node.ExpressionBody, diagnostics), diagnostics);
            }
            else if (!flag && (!localSymbol.IsExtern || !localSymbol.IsStatic))
            {
                flag = true;
                diagnostics.Add(ErrorCode.ERR_LocalFunctionMissingBody, localSymbol.Locations[0], localSymbol);
            }
            if (!flag && (boundBlock != null || boundBlock2 != null) && localSymbol.IsExtern)
            {
                flag = true;
                diagnostics.Add(ErrorCode.ERR_ExternHasBody, localSymbol.Locations[0], localSymbol);
            }
            localSymbol.GetDeclarationDiagnostics(diagnostics);
            Symbol.CheckForBlockAndExpressionBody(node.Body, node.ExpressionBody, node, diagnostics);
            return new BoundLocalFunctionStatement(node, localSymbol, boundBlock, boundBlock2, flag);
            BoundBlock runAnalysis(BoundBlock block, BindingDiagnosticBag blockDiagnostics)
            {
                if (block != null)
                {
                    DiagnosticBag instance = DiagnosticBag.GetInstance();
                    bool num = ControlFlowPass.Analyze(localSymbol.DeclaringCompilation, localSymbol, block, instance);
                    instance.Free();
                    if (num)
                    {
                        if (ImplicitReturnIsOkay(localSymbol))
                        {
                            block = FlowAnalysisPass.AppendImplicitReturn(block, localSymbol);
                        }
                        else
                        {
                            blockDiagnostics.Add(ErrorCode.ERR_ReturnExpected, localSymbol.Locations[0], localSymbol);
                        }
                    }
                }
                return block;
            }
        }

        private bool ImplicitReturnIsOkay(MethodSymbol method)
        {
            if (!method.ReturnsVoid && !method.IsIterator)
            {
                return method.IsAsyncReturningTask(Compilation);
            }
            return true;
        }

        public BoundStatement BindExpressionStatement(ExpressionStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            return BindExpressionStatement(node, node.Expression, node.AllowsAnyExpression, diagnostics);
        }

        private BoundExpressionStatement BindExpressionStatement(CSharpSyntaxNode node, ExpressionSyntax syntax, bool allowsAnyExpression, BindingDiagnosticBag diagnostics)
        {
            BoundExpression boundExpression = BindRValueWithoutTargetType(syntax, diagnostics);
            ReportSuppressionIfNeeded(boundExpression, diagnostics);
            BoundExpressionStatement result;
            if (!allowsAnyExpression && !IsValidStatementExpression(syntax, boundExpression))
            {
                if (!node.HasErrors)
                {
                    Error(diagnostics, ErrorCode.ERR_IllegalStatement, syntax);
                }
                result = new BoundExpressionStatement(node, boundExpression, hasErrors: true);
            }
            else
            {
                result = new BoundExpressionStatement(node, boundExpression);
            }
            CheckForUnobservedAwaitable(boundExpression, diagnostics);
            return result;
        }

        private void CheckForUnobservedAwaitable(BoundExpression expression, BindingDiagnosticBag diagnostics)
        {
            if (CouldBeAwaited(expression))
            {
                Error(diagnostics, ErrorCode.WRN_UnobservedAwaitableExpression, expression.Syntax);
            }
        }

        internal BoundStatement BindLocalDeclarationStatement(LocalDeclarationStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            if (node.UsingKeyword != default(SyntaxToken))
            {
                return BindUsingDeclarationStatementParts(node, diagnostics);
            }
            return BindDeclarationStatementParts(node, diagnostics);
        }

        private BoundStatement BindUsingDeclarationStatementParts(LocalDeclarationStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            return UsingStatementBinder.BindUsingStatementOrDeclarationFromParts(node, node.UsingKeyword, node.AwaitKeyword, this, null, diagnostics);
        }

        private BoundStatement BindDeclarationStatementParts(LocalDeclarationStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            TypeSyntax typeSyntax = node.Declaration.Type.SkipRef(out RefKind refKind);
            bool isConst = node.IsConst;
            TypeWithAnnotations declTypeOpt = BindVariableTypeWithAnnotations(node.Declaration, diagnostics, typeSyntax, ref isConst, out bool isVar, out AliasSymbol alias);
            LocalDeclarationKind kind = ((!isConst) ? LocalDeclarationKind.RegularVariable : LocalDeclarationKind.Constant);
            SeparatedSyntaxList<VariableDeclaratorSyntax> variables = node.Declaration.Variables;
            int count = variables.Count;
            if (count == 1)
            {
                return BindVariableDeclaration(kind, isVar, variables[0], typeSyntax, declTypeOpt, alias, diagnostics, includeBoundType: true, node);
            }
            BoundLocalDeclaration[] array = new BoundLocalDeclaration[count];
            int num = 0;
            SeparatedSyntaxList<VariableDeclaratorSyntax>.Enumerator enumerator = variables.GetEnumerator();
            while (enumerator.MoveNext())
            {
                VariableDeclaratorSyntax current = enumerator.Current;
                bool includeBoundType = num == 0;
                array[num++] = BindVariableDeclaration(kind, isVar, current, typeSyntax, declTypeOpt, alias, diagnostics, includeBoundType);
            }
            return new BoundMultipleLocalDeclarations(node, array.AsImmutableOrNull());
        }

        internal MethodSymbol TryFindDisposePatternMethod(BoundExpression expr, SyntaxNode syntaxNode, bool hasAwait, BindingDiagnosticBag diagnostics)
        {
            PatternLookupResult patternLookupResult = PerformPatternMethodLookup(expr, hasAwait ? "DisposeAsync" : "Dispose", syntaxNode, diagnostics, out MethodSymbol result);
            if ((object)result != null && result.IsExtensionMethod)
            {
                return null;
            }
            if ((!hasAwait && (object)result != null && !result.ReturnsVoid) || patternLookupResult == PatternLookupResult.NotAMethod)
            {
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                if (IsAccessible(result, ref useSiteInfo))
                {
                    diagnostics.Add(ErrorCode.WRN_PatternBadSignature, syntaxNode.Location, expr.Type, MessageID.IDS_Disposable.Localize(), result);
                }
                diagnostics.Add(syntaxNode, useSiteInfo);
                return null;
            }
            return result;
        }

        private TypeWithAnnotations BindVariableTypeWithAnnotations(CSharpSyntaxNode declarationNode, BindingDiagnosticBag diagnostics, TypeSyntax typeSyntax, ref bool isConst, out bool isVar, out AliasSymbol alias)
        {
            TypeWithAnnotations result = BindTypeOrVarKeyword(typeSyntax.SkipRef(out RefKind refKind), diagnostics, out isVar, out alias);
            if (isVar)
            {
                if (isConst)
                {
                    Error(diagnostics, ErrorCode.ERR_ImplicitlyTypedVariableCannotBeConst, declarationNode);
                    isConst = false;
                }
                if (declarationNode.Parent!.Kind() == SyntaxKind.LocalDeclarationStatement && ((VariableDeclarationSyntax)declarationNode).Variables.Count > 1 && !declarationNode.HasErrors)
                {
                    Error(diagnostics, ErrorCode.ERR_ImplicitlyTypedVariableMultipleDeclarator, declarationNode);
                }
            }
            else
            {
                if (result.IsStatic)
                {
                    Error(diagnostics, ErrorCode.ERR_VarDeclIsStaticClass, typeSyntax, result.Type);
                }
                if (isConst && !result.Type.CanBeConst())
                {
                    Error(diagnostics, ErrorCode.ERR_BadConstType, typeSyntax, result.Type);
                    isConst = false;
                }
            }
            return result;
        }

        internal BoundExpression BindInferredVariableInitializer(BindingDiagnosticBag diagnostics, RefKind refKind, EqualsValueClauseSyntax initializer, CSharpSyntaxNode errorSyntax)
        {
            IsInitializerRefKindValid(initializer, initializer, refKind, diagnostics, out var valueKind, out var value);
            return BindInferredVariableInitializer(diagnostics, value, valueKind, refKind, errorSyntax);
        }

        protected BoundExpression BindInferredVariableInitializer(BindingDiagnosticBag diagnostics, ExpressionSyntax initializer, BindValueKind valueKind, RefKind refKind, CSharpSyntaxNode errorSyntax)
        {
            if (initializer == null)
            {
                if (!errorSyntax.HasErrors)
                {
                    Error(diagnostics, ErrorCode.ERR_ImplicitlyTypedVariableWithNoInitializer, errorSyntax);
                }
                return null;
            }
            if (initializer.Kind() == SyntaxKind.ArrayInitializerExpression)
            {
                BoundArrayInitialization expr = BindUnexpectedArrayInitializer((InitializerExpressionSyntax)initializer, diagnostics, ErrorCode.ERR_ImplicitlyTypedVariableAssignedArrayInitializer, errorSyntax);
                return CheckValue(expr, valueKind, diagnostics);
            }
            BoundExpression boundExpression = BindToNaturalType(BindValue(initializer, diagnostics, valueKind), diagnostics);
            if (!boundExpression.HasAnyErrors && !boundExpression.HasExpressionType())
            {
                Error(diagnostics, ErrorCode.ERR_ImplicitlyTypedVariableAssignedBadValue, errorSyntax, boundExpression.Display);
            }
            return boundExpression;
        }

        private static bool IsInitializerRefKindValid(EqualsValueClauseSyntax initializer, CSharpSyntaxNode node, RefKind variableRefKind, BindingDiagnosticBag diagnostics, out BindValueKind valueKind, out ExpressionSyntax value)
        {
            RefKind refKind = RefKind.None;
            value = initializer?.Value.CheckAndUnwrapRefExpression(diagnostics, out refKind);
            if (variableRefKind == RefKind.None)
            {
                valueKind = BindValueKind.RValue;
                if (refKind == RefKind.Ref)
                {
                    Error(diagnostics, ErrorCode.ERR_InitializeByValueVariableWithReference, node);
                    return false;
                }
            }
            else
            {
                valueKind = ((variableRefKind == RefKind.In) ? BindValueKind.ReadonlyRef : BindValueKind.RefOrOut);
                if (initializer == null)
                {
                    Error(diagnostics, ErrorCode.ERR_ByReferenceVariableMustBeInitialized, node);
                    return false;
                }
                if (refKind != RefKind.Ref)
                {
                    Error(diagnostics, ErrorCode.ERR_InitializeByReferenceVariableWithValue, node);
                    return false;
                }
            }
            return true;
        }

        protected BoundLocalDeclaration BindVariableDeclaration(LocalDeclarationKind kind, bool isVar, VariableDeclaratorSyntax declarator, TypeSyntax typeSyntax, TypeWithAnnotations declTypeOpt, AliasSymbol aliasOpt, BindingDiagnosticBag diagnostics, bool includeBoundType, CSharpSyntaxNode associatedSyntaxNode = null)
        {
            return BindVariableDeclaration(LocateDeclaredVariableSymbol(declarator, typeSyntax, kind), kind, isVar, declarator, typeSyntax, declTypeOpt, aliasOpt, diagnostics, includeBoundType, associatedSyntaxNode);
        }

        protected BoundLocalDeclaration BindVariableDeclaration(SourceLocalSymbol localSymbol, LocalDeclarationKind kind, bool isVar, VariableDeclaratorSyntax declarator, TypeSyntax typeSyntax, TypeWithAnnotations declTypeOpt, AliasSymbol aliasOpt, BindingDiagnosticBag diagnostics, bool includeBoundType, CSharpSyntaxNode associatedSyntaxNode = null)
        {
            BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(withDiagnostics: true, diagnostics.AccumulatesDependencies);
            associatedSyntaxNode ??= declarator;
            bool flag = localSymbol.ScopeBinder.ValidateDeclarationNameConflictsInScope(localSymbol, diagnostics);
            bool flag2 = false;
            if (localSymbol.RefKind != 0)
            {
                CheckRefLocalInAsyncOrIteratorMethod(localSymbol.IdentifierToken, diagnostics);
            }
            EqualsValueClauseSyntax initializer = declarator.Initializer;
            if (!IsInitializerRefKindValid(initializer, declarator, localSymbol.RefKind, diagnostics, out var valueKind, out var value))
            {
                flag2 = true;
            }
            BoundExpression initializerOpt;
            if (isVar)
            {
                aliasOpt = null;
                initializerOpt = BindInferredVariableInitializer(diagnostics, value, valueKind, localSymbol.RefKind, declarator);
                TypeSymbol typeSymbol = initializerOpt?.Type;
                if ((object)typeSymbol != null)
                {
                    declTypeOpt = TypeWithAnnotations.Create(typeSymbol);
                    if (declTypeOpt.IsVoidType())
                    {
                        Error(instance, ErrorCode.ERR_ImplicitlyTypedVariableAssignedBadValue, declarator, declTypeOpt.Type);
                        declTypeOpt = TypeWithAnnotations.Create(CreateErrorType("var"));
                        flag2 = true;
                    }
                    if (!declTypeOpt.Type.IsErrorType() && declTypeOpt.IsStatic)
                    {
                        Error(instance, ErrorCode.ERR_VarDeclIsStaticClass, typeSyntax, typeSymbol);
                        flag2 = true;
                    }
                }
                else
                {
                    declTypeOpt = TypeWithAnnotations.Create(CreateErrorType("var"));
                    flag2 = true;
                }
            }
            else if (initializer == null)
            {
                initializerOpt = null;
            }
            else
            {
                initializerOpt = BindPossibleArrayInitializer(value, declTypeOpt.Type, valueKind, diagnostics);
                if (kind != LocalDeclarationKind.FixedVariable)
                {
                    initializerOpt = GenerateConversionForAssignment(declTypeOpt.Type, initializerOpt, instance, isDefaultParameter: false, localSymbol.RefKind != RefKind.None);
                }
            }
            if (kind == LocalDeclarationKind.FixedVariable)
            {
                if (isVar && !flag2)
                {
                    Error(instance, ErrorCode.ERR_ImplicitlyTypedLocalCannotBeFixed, declarator);
                    flag2 = true;
                }
                if (!declTypeOpt.Type.IsPointerType())
                {
                    if (!flag2)
                    {
                        Error(instance, declTypeOpt.Type.IsFunctionPointer() ? ErrorCode.ERR_CannotUseFunctionPointerAsFixedLocal : ErrorCode.ERR_BadFixedInitType, declarator);
                        flag2 = true;
                    }
                }
                else if (!IsValidFixedVariableInitializer(declTypeOpt.Type, localSymbol, ref initializerOpt, instance))
                {
                    flag2 = true;
                }
            }
            if (CheckRestrictedTypeInAsyncMethod(ContainingMemberOrLambda, declTypeOpt.Type, instance, typeSyntax))
            {
                flag2 = true;
            }
            localSymbol.SetTypeWithAnnotations(declTypeOpt);
            if (initializerOpt != null)
            {
                uint localScopeDepth = LocalScopeDepth;
                localSymbol.SetValEscape(GetValEscape(initializerOpt, localScopeDepth));
                if (localSymbol.RefKind != 0)
                {
                    localSymbol.SetRefEscape(GetRefEscape(initializerOpt, localScopeDepth));
                }
            }
            ImmutableArray<BoundExpression> argumentsOpt = BindDeclaratorArguments(declarator, instance);
            switch (kind)
            {
                case LocalDeclarationKind.FixedVariable:
                case LocalDeclarationKind.UsingVariable:
                    if (initializerOpt == null)
                    {
                        Error(instance, ErrorCode.ERR_FixedMustInit, declarator);
                        flag2 = true;
                    }
                    break;
                case LocalDeclarationKind.Constant:
                    if (initializerOpt != null && !instance.HasAnyResolvedErrors())
                    {
                        ImmutableBindingDiagnostic<AssemblySymbol> constantValueDiagnostics = localSymbol.GetConstantValueDiagnostics(initializerOpt);
                        diagnostics.AddRange(constantValueDiagnostics, allowMismatchInDependencyAccumulation: true);
                        flag2 = constantValueDiagnostics.Diagnostics.HasAnyErrors();
                    }
                    break;
            }
            diagnostics.AddRangeAndFree(instance);
            BoundTypeExpression declaredTypeOpt = null;
            if (includeBoundType)
            {
                ArrayBuilder<BoundExpression> instance2 = ArrayBuilder<BoundExpression>.GetInstance();
                static void action(ArrayRankSpecifierSyntax rankSpecifier, (Binder binder, ArrayBuilder<BoundExpression> invalidDimensions, BindingDiagnosticBag diagnostics) args)
                {
                    bool hasErrors = false;
                    SeparatedSyntaxList<ExpressionSyntax>.Enumerator enumerator = rankSpecifier.Sizes.GetEnumerator();
                    while (enumerator.MoveNext())
                    {
                        ExpressionSyntax current = enumerator.Current;
                        BoundExpression boundExpression = args.binder.BindArrayDimension(current, args.diagnostics, ref hasErrors);
                        if (boundExpression != null)
                        {
                            args.invalidDimensions.Add(boundExpression);
                        }
                    }
                }
                (Binder, ArrayBuilder<BoundExpression>, BindingDiagnosticBag) argument = (this, instance2, diagnostics);
                typeSyntax.VisitRankSpecifiers(action, in argument);
                declaredTypeOpt = new BoundTypeExpression(typeSyntax, aliasOpt, instance2.ToImmutableAndFree(), declTypeOpt);
            }
            return new BoundLocalDeclaration(associatedSyntaxNode, localSymbol, declaredTypeOpt, (!flag2) ? initializerOpt : BindToTypeForErrorRecovery(initializerOpt)?.WithHasErrors(), argumentsOpt, isVar, flag2 || flag);
        }

        protected bool CheckRefLocalInAsyncOrIteratorMethod(SyntaxToken identifierToken, BindingDiagnosticBag diagnostics)
        {
            if (IsInAsyncMethod())
            {
                Error(diagnostics, ErrorCode.ERR_BadAsyncLocalType, identifierToken);
                return true;
            }
            if (IsDirectlyInIterator)
            {
                Error(diagnostics, ErrorCode.ERR_BadIteratorLocalType, identifierToken);
                return true;
            }
            return false;
        }

        internal ImmutableArray<BoundExpression> BindDeclaratorArguments(VariableDeclaratorSyntax declarator, BindingDiagnosticBag diagnostics)
        {
            ImmutableArray<BoundExpression> result = default(ImmutableArray<BoundExpression>);
            if (declarator.ArgumentList != null)
            {
                AnalyzedArguments instance = AnalyzedArguments.GetInstance();
                BindArgumentsAndNames(declarator.ArgumentList, diagnostics, instance);
                result = BuildArgumentsForErrorRecovery(instance);
                instance.Free();
            }
            return result;
        }

        private SourceLocalSymbol LocateDeclaredVariableSymbol(VariableDeclaratorSyntax declarator, TypeSyntax typeSyntax, LocalDeclarationKind outerKind)
        {
            LocalDeclarationKind kind = ((outerKind != LocalDeclarationKind.UsingVariable) ? LocalDeclarationKind.RegularVariable : LocalDeclarationKind.UsingVariable);
            return LocateDeclaredVariableSymbol(declarator.Identifier, typeSyntax, declarator.Initializer, kind);
        }

        private SourceLocalSymbol LocateDeclaredVariableSymbol(SyntaxToken identifier, TypeSyntax typeSyntax, EqualsValueClauseSyntax equalsValue, LocalDeclarationKind kind)
        {
            SourceLocalSymbol sourceLocalSymbol = LookupLocal(identifier);
            if ((object)sourceLocalSymbol == null)
            {
                sourceLocalSymbol = SourceLocalSymbol.MakeLocal(ContainingMemberOrLambda, this, allowRefKind: false, typeSyntax, identifier, kind, equalsValue);
            }
            return sourceLocalSymbol;
        }

        private bool IsValidFixedVariableInitializer(TypeSymbol declType, SourceLocalSymbol localSymbol, ref BoundExpression initializerOpt, BindingDiagnosticBag diagnostics)
        {
            Debug.Assert(!ReferenceEquals(declType, null));
            Debug.Assert(declType.IsPointerType());

            if (initializerOpt?.HasAnyErrors != false)
            {
                return false;
            }

            TypeSymbol initializerType = initializerOpt.Type;
            SyntaxNode initializerSyntax = initializerOpt.Syntax;

            if ((object)initializerType == null)
            {
                Error(diagnostics, ErrorCode.ERR_ExprCannotBeFixed, initializerSyntax);
                return false;
            }

            TypeSymbol elementType;
            bool hasErrors = false;
            MethodSymbol fixedPatternMethod = null;

            switch (initializerOpt.Kind)
            {
                case BoundKind.AddressOfOperator:
                    elementType = ((BoundAddressOfOperator)initializerOpt).Operand.Type;
                    break;

                case BoundKind.FieldAccess:
                    var fa = (BoundFieldAccess)initializerOpt;
                    if (fa.FieldSymbol.IsFixedSizeBuffer)
                    {
                        elementType = ((PointerTypeSymbol)fa.Type).PointedAtType;
                        break;
                    }

                    goto default;

                default:
                    //  fixed (T* variable = <expr>) ...

                    // check for arrays
                    if (initializerType.IsArray())
                    {
                        // See ExpressionBinder::BindPtrToArray (though most of that functionality is now in LocalRewriter).
                        elementType = ((ArrayTypeSymbol)initializerType).ElementType;
                        break;
                    }

                    // check for a special ref-returning method
                    var additionalDiagnostics = BindingDiagnosticBag.GetInstance(diagnostics);
                    fixedPatternMethod = GetFixedPatternMethodOpt(initializerOpt, additionalDiagnostics);

                    // check for String
                    // NOTE: We will allow the pattern method to take precedence, but only if it is an instance member of System.String
                    if (initializerType.SpecialType == SpecialType.System_String &&
                        ((object)fixedPatternMethod == null || fixedPatternMethod.ContainingType.SpecialType != SpecialType.System_String))
                    {
                        fixedPatternMethod = null;
                        elementType = this.GetSpecialType(SpecialType.System_Char, diagnostics, initializerSyntax);
                        additionalDiagnostics.Free();
                        break;
                    }

                    // if the feature was enabled, but something went wrong with the method, report that, otherwise don't.
                    // If feature is not enabled, additional errors would be just noise.
                    bool extensibleFixedEnabled = ((CSharpParseOptions)initializerOpt.SyntaxTree.Options)?.IsFeatureEnabled(MessageID.IDS_FeatureExtensibleFixedStatement) != false;
                    if (extensibleFixedEnabled)
                    {
                        diagnostics.AddRange(additionalDiagnostics);
                    }

                    additionalDiagnostics.Free();

                    if ((object)fixedPatternMethod != null)
                    {
                        elementType = fixedPatternMethod.ReturnType;
                        CheckFeatureAvailability(initializerOpt.Syntax, MessageID.IDS_FeatureExtensibleFixedStatement, diagnostics);
                        break;
                    }
                    else
                    {
                        Error(diagnostics, ErrorCode.ERR_ExprCannotBeFixed, initializerSyntax);
                        return false;
                    }
            }

            if (CheckManagedAddr(Compilation, elementType, initializerSyntax.Location, diagnostics))
            {
                hasErrors = true;
            }

            initializerOpt = BindToNaturalType(initializerOpt, diagnostics, reportNoTargetType: false);
            initializerOpt = GetFixedLocalCollectionInitializer(initializerOpt, elementType, declType, fixedPatternMethod, hasErrors, diagnostics);
            return true;
        }

        private MethodSymbol GetFixedPatternMethodOpt(BoundExpression initializer, BindingDiagnosticBag additionalDiagnostics)
        {
            if (initializer.Type.IsVoidType())
            {
                return null;
            }
            PerformPatternMethodLookup(initializer, "GetPinnableReference", initializer.Syntax, additionalDiagnostics, out var result);
            if ((object)result == null)
            {
                return null;
            }
            if (HasOptionalOrVariableParameters(result) || result.ReturnsVoid || !result.RefKind.IsManagedReference() || (result.ParameterCount != 0 && (!result.IsStatic || result.ParameterCount != 1)))
            {
                additionalDiagnostics.Add(ErrorCode.WRN_PatternBadSignature, initializer.Syntax.Location, initializer.Type, "fixed", result);
                return null;
            }
            return result;
        }

        private BoundExpression GetFixedLocalCollectionInitializer(BoundExpression initializer, TypeSymbol elementType, TypeSymbol declType, MethodSymbol patternMethodOpt, bool hasErrors, BindingDiagnosticBag diagnostics)
        {
            SyntaxNode syntax = initializer.Syntax;
            TypeSymbol typeSymbol = new PointerTypeSymbol(TypeWithAnnotations.Create(elementType));
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            Conversion conversion = Conversions.ClassifyConversionFromType(typeSymbol, declType, ref useSiteInfo);
            diagnostics.Add(syntax, useSiteInfo);
            if (!conversion.IsValid || !conversion.IsImplicit)
            {
                GenerateImplicitConversionError(diagnostics, Compilation, syntax, conversion, typeSymbol, declType);
                hasErrors = true;
            }
            return new BoundFixedLocalCollectionInitializer(syntax, typeSymbol, conversion, initializer, patternMethodOpt, declType, hasErrors);
        }

        private BoundExpression BindAssignment(AssignmentExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            node.Left.CheckDeconstructionCompatibleArgument(diagnostics);
            if (node.Left.Kind() == SyntaxKind.TupleExpression || node.Left.Kind() == SyntaxKind.DeclarationExpression)
            {
                return BindDeconstruction(node, diagnostics);
            }
            bool isRef = false;
            BindValueKind bindValueKind;
            BindValueKind bindValueKind2;
            ExpressionSyntax node2;
            if (node.Right.Kind() == SyntaxKind.RefExpression)
            {
                isRef = true;
                bindValueKind = BindValueKind.RefAssignable;
                bindValueKind2 = BindValueKind.RefersToLocation;
                node2 = ((RefExpressionSyntax)node.Right).Expression;
            }
            else
            {
                bindValueKind = BindValueKind.Assignable;
                bindValueKind2 = BindValueKind.RValue;
                node2 = node.Right;
            }
            BoundExpression boundExpression = BindValue(node.Left, diagnostics, bindValueKind);
            ReportSuppressionIfNeeded(boundExpression, diagnostics);
            RefKind refKind = RefKind.None;
            if (bindValueKind == BindValueKind.RefAssignable && !boundExpression.HasErrors)
            {
                refKind = boundExpression.GetRefKind();
                if (refKind == RefKind.Ref || refKind == RefKind.Out)
                {
                    bindValueKind2 |= BindValueKind.Assignable;
                }
            }
            BoundExpression boundExpression2 = BindValue(node2, diagnostics, bindValueKind2);
            if (boundExpression.Kind == BoundKind.DiscardExpression)
            {
                boundExpression2 = BindToNaturalType(boundExpression2, diagnostics);
                boundExpression = InferTypeForDiscardAssignment((BoundDiscardExpression)boundExpression, boundExpression2, diagnostics);
            }
            return BindAssignment(node, boundExpression, boundExpression2, isRef, diagnostics);
        }

        private BoundExpression InferTypeForDiscardAssignment(BoundDiscardExpression op1, BoundExpression op2, BindingDiagnosticBag diagnostics)
        {
            TypeSymbol type = op2.Type;
            if ((object)type == null)
            {
                return op1.FailInference(this, diagnostics);
            }
            if (type.IsVoidType())
            {
                diagnostics.Add(ErrorCode.ERR_VoidAssignment, op1.Syntax.Location);
            }
            return op1.SetInferredTypeWithAnnotations(TypeWithAnnotations.Create(type));
        }

        private BoundAssignmentOperator BindAssignment(SyntaxNode node, BoundExpression op1, BoundExpression op2, bool isRef, BindingDiagnosticBag diagnostics)
        {
            bool hasErrors = op1.HasAnyErrors || op2.HasAnyErrors;
            if (!op1.HasAnyErrors)
            {
                BoundExpression boundExpression = GenerateConversionForAssignment(op1.Type, op2, diagnostics, isDefaultParameter: false, isRef);
                op2 = ((op1.Kind == BoundKind.DynamicIndexerAccess || op1.Kind == BoundKind.DynamicMemberAccess || op1.Kind == BoundKind.DynamicObjectInitializerMember) ? BindToNaturalType(op2, diagnostics) : boundExpression);
                if (isRef)
                {
                    uint refEscape = GetRefEscape(op1, LocalScopeDepth);
                    uint refEscape2 = GetRefEscape(op2, LocalScopeDepth);
                    if (refEscape < refEscape2)
                    {
                        Error(diagnostics, ErrorCode.ERR_RefAssignNarrower, node, op1.ExpressionSymbol!.Name, op2.Syntax);
                        op2 = ToBadExpression(op2);
                    }
                }
                if (op1.Type!.IsRefLikeType)
                {
                    uint valEscape = GetValEscape(op1, LocalScopeDepth);
                    op2 = ValidateEscape(op2, valEscape, isByRef: false, diagnostics);
                }
            }
            else
            {
                op2 = BindToTypeForErrorRecovery(op2);
            }
            TypeSymbol type = ((op1.Kind != BoundKind.EventAccess || !((BoundEventAccess)op1).EventSymbol.IsWindowsRuntimeEvent) ? op1.Type : GetSpecialType(SpecialType.System_Void, diagnostics, node));
            return new BoundAssignmentOperator(node, op1, op2, isRef, type, hasErrors);
        }

        private static PropertySymbol GetPropertySymbol(BoundExpression expr, out BoundExpression receiver, out SyntaxNode propertySyntax)
        {
            PropertySymbol propertySymbol;
            switch (expr.Kind)
            {
                case BoundKind.PropertyAccess:
                    {
                        BoundPropertyAccess boundPropertyAccess = (BoundPropertyAccess)expr;
                        receiver = boundPropertyAccess.ReceiverOpt;
                        propertySymbol = boundPropertyAccess.PropertySymbol;
                        break;
                    }
                case BoundKind.IndexerAccess:
                    {
                        BoundIndexerAccess boundIndexerAccess = (BoundIndexerAccess)expr;
                        receiver = boundIndexerAccess.ReceiverOpt;
                        propertySymbol = boundIndexerAccess.Indexer;
                        break;
                    }
                case BoundKind.IndexOrRangePatternIndexerAccess:
                    {
                        BoundIndexOrRangePatternIndexerAccess boundIndexOrRangePatternIndexerAccess = (BoundIndexOrRangePatternIndexerAccess)expr;
                        receiver = boundIndexOrRangePatternIndexerAccess.Receiver;
                        propertySymbol = (PropertySymbol)boundIndexOrRangePatternIndexerAccess.PatternSymbol;
                        break;
                    }
                default:
                    receiver = null;
                    propertySymbol = null;
                    propertySyntax = null;
                    return null;
            }
            SyntaxNode syntax = expr.Syntax;
            switch (syntax.Kind())
            {
                case SyntaxKind.SimpleMemberAccessExpression:
                case SyntaxKind.PointerMemberAccessExpression:
                    propertySyntax = ((MemberAccessExpressionSyntax)syntax).Name;
                    break;
                case SyntaxKind.IdentifierName:
                    propertySyntax = syntax;
                    break;
                case SyntaxKind.ElementAccessExpression:
                    propertySyntax = ((ElementAccessExpressionSyntax)syntax).ArgumentList;
                    break;
                default:
                    propertySyntax = syntax;
                    break;
            }
            return propertySymbol;
        }

        private static SyntaxNode GetEventName(BoundEventAccess expr)
        {
            SyntaxNode syntax = expr.Syntax;
            switch (syntax.Kind())
            {
                case SyntaxKind.SimpleMemberAccessExpression:
                case SyntaxKind.PointerMemberAccessExpression:
                    return ((MemberAccessExpressionSyntax)syntax).Name;
                case SyntaxKind.QualifiedName:
                    return ((QualifiedNameSyntax)syntax).Right;
                case SyntaxKind.IdentifierName:
                    return syntax;
                case SyntaxKind.MemberBindingExpression:
                    return ((MemberBindingExpressionSyntax)syntax).Name;
                default:
                    throw ExceptionUtilities.UnexpectedValue(syntax.Kind());
            }
        }

        private DiagnosticInfo GetBadEventUsageDiagnosticInfo(EventSymbol eventSymbol)
        {
            EventSymbol eventSymbol2 = (EventSymbol)eventSymbol.GetLeastOverriddenMember(ContainingType);
            if (!eventSymbol2.HasAssociatedField)
            {
                return new CSDiagnosticInfo(ErrorCode.ERR_BadEventUsageNoField, eventSymbol2);
            }
            return new CSDiagnosticInfo(ErrorCode.ERR_BadEventUsage, eventSymbol2, eventSymbol2.ContainingType);
        }

        internal static bool AccessingAutoPropertyFromConstructor(BoundPropertyAccess propertyAccess, Symbol fromMember)
        {
            return AccessingAutoPropertyFromConstructor(propertyAccess.ReceiverOpt, propertyAccess.PropertySymbol, fromMember);
        }

        private static bool AccessingAutoPropertyFromConstructor(BoundExpression receiver, PropertySymbol propertySymbol, Symbol fromMember)
        {
            if (!propertySymbol.IsDefinition && propertySymbol.ContainingType.Equals(propertySymbol.ContainingType.OriginalDefinition, TypeCompareKind.IgnoreNullableModifiersForReferenceTypes))
            {
                propertySymbol = propertySymbol.OriginalDefinition;
            }
            SourcePropertySymbolBase sourcePropertySymbolBase = propertySymbol as SourcePropertySymbolBase;
            bool isStatic = propertySymbol.IsStatic;
            if ((object)sourcePropertySymbolBase != null && sourcePropertySymbolBase.IsAutoPropertyWithGetAccessor && TypeSymbol.Equals(sourcePropertySymbolBase.ContainingType, fromMember.ContainingType, TypeCompareKind.ConsiderEverything) && IsConstructorOrField(fromMember, isStatic))
            {
                if (!isStatic)
                {
                    return receiver.Kind == BoundKind.ThisReference;
                }
                return true;
            }
            return false;
        }

        private static bool IsConstructorOrField(Symbol member, bool isStatic)
        {
            if ((member as MethodSymbol)?.MethodKind != (MethodKind?)((!isStatic) ? 1 : 14))
            {
                FieldSymbol obj = member as FieldSymbol;
                if ((object)obj == null)
                {
                    return false;
                }
                return obj.IsStatic == isStatic;
            }
            return true;
        }

        private TypeSymbol GetAccessThroughType(BoundExpression receiver)
        {
            if (receiver == null)
            {
                return ContainingType;
            }
            if (receiver.Kind == BoundKind.BaseReference)
            {
                return null;
            }
            return receiver.Type;
        }

        private BoundExpression BindPossibleArrayInitializer(ExpressionSyntax node, TypeSymbol destinationType, BindValueKind valueKind, BindingDiagnosticBag diagnostics)
        {
            if (node.Kind() != SyntaxKind.ArrayInitializerExpression)
            {
                return BindValue(node, diagnostics, valueKind);
            }
            BoundExpression expr = ((destinationType.Kind != SymbolKind.ArrayType) ? BindUnexpectedArrayInitializer((InitializerExpressionSyntax)node, diagnostics, ErrorCode.ERR_ArrayInitToNonArrayType) : ((BoundExpression)BindArrayCreationWithInitializer(diagnostics, null, (InitializerExpressionSyntax)node, (ArrayTypeSymbol)destinationType, ImmutableArray<BoundExpression>.Empty)));
            return CheckValue(expr, valueKind, diagnostics);
        }

        protected virtual SourceLocalSymbol LookupLocal(SyntaxToken nameToken)
        {
            return Next!.LookupLocal(nameToken);
        }

        protected virtual LocalFunctionSymbol LookupLocalFunction(SyntaxToken nameToken)
        {
            return Next!.LookupLocalFunction(nameToken);
        }

        internal virtual BoundBlock BindEmbeddedBlock(BlockSyntax node, BindingDiagnosticBag diagnostics)
        {
            return BindBlock(node, diagnostics);
        }

        private BoundBlock BindBlock(BlockSyntax node, BindingDiagnosticBag diagnostics)
        {
            if (node.AttributeLists.Count > 0)
            {
                Error(diagnostics, ErrorCode.ERR_AttributesNotAllowed, node.AttributeLists[0]);
            }
            return GetBinder(node)!.BindBlockParts(node, diagnostics);
        }

        private BoundBlock BindBlockParts(BlockSyntax node, BindingDiagnosticBag diagnostics)
        {
            SyntaxList<StatementSyntax> statements = node.Statements;
            int count = statements.Count;
            ArrayBuilder<BoundStatement> instance = ArrayBuilder<BoundStatement>.GetInstance(count);
            for (int i = 0; i < count; i++)
            {
                BoundStatement item = BindStatement(statements[i], diagnostics);
                instance.Add(item);
            }
            return FinishBindBlockParts(node, instance.ToImmutableAndFree(), diagnostics);
        }

        private BoundBlock FinishBindBlockParts(CSharpSyntaxNode node, ImmutableArray<BoundStatement> boundStatements, BindingDiagnosticBag diagnostics)
        {
            ImmutableArray<LocalSymbol> declaredLocalsForScope = GetDeclaredLocalsForScope(node);
            if (IsDirectlyInIterator && ContainingMemberOrLambda is MethodSymbol methodSymbol)
            {
                methodSymbol.IteratorElementTypeWithAnnotations = GetIteratorElementType();
            }
            return new BoundBlock(node, declaredLocalsForScope, GetDeclaredLocalFunctionsForScope(node), boundStatements);
        }

        internal BoundExpression GenerateConversionForAssignment(TypeSymbol targetType, BoundExpression expression, BindingDiagnosticBag diagnostics, bool isDefaultParameter = false, bool isRefAssignment = false)
        {
            if (expression.HasAnyErrors && expression.Kind != BoundKind.UnboundLambda)
            {
                diagnostics = BindingDiagnosticBag.Discarded;
            }
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            Conversion conversion = Conversions.ClassifyConversionFromExpression(expression, targetType, ref useSiteInfo);
            diagnostics.Add(expression.Syntax, useSiteInfo);
            if (isRefAssignment)
            {
                if (conversion.Kind == ConversionKind.Identity)
                {
                    return expression;
                }
                Error(diagnostics, ErrorCode.ERR_RefAssignmentMustHaveIdentityConversion, expression.Syntax, targetType);
            }
            else if (!conversion.IsImplicit || !conversion.IsValid)
            {
                if (!isDefaultParameter)
                {
                    GenerateImplicitConversionError(diagnostics, expression.Syntax, conversion, expression, targetType);
                }
                diagnostics = BindingDiagnosticBag.Discarded;
            }
            return CreateConversion(expression.Syntax, expression, conversion, isCast: false, null, targetType, diagnostics);
        }

        internal void GenerateAnonymousFunctionConversionError(BindingDiagnosticBag diagnostics, SyntaxNode syntax, UnboundLambda anonymousFunction, TypeSymbol targetType)
        {
            if (targetType.IsErrorType())
            {
                return;
            }
            LambdaConversionResult lambdaConversionResult = ConversionsBase.IsAnonymousFunctionCompatibleWithType(anonymousFunction, targetType);
            if (lambdaConversionResult == LambdaConversionResult.Success)
            {
                return;
            }
            LocalizableErrorArgument localizableErrorArgument = anonymousFunction.MessageID.Localize();
            switch (lambdaConversionResult)
            {
                case LambdaConversionResult.BadTargetType:
                    if (!ReportDelegateInvokeUseSiteDiagnostic(diagnostics, targetType, null, syntax))
                    {
                        Error(diagnostics, ErrorCode.ERR_AnonMethToNonDel, syntax, localizableErrorArgument, targetType);
                    }
                    return;
                case LambdaConversionResult.ExpressionTreeMustHaveDelegateTypeArgument:
                    Error(diagnostics, ErrorCode.ERR_ExpressionTreeMustHaveDelegate, syntax, ((NamedTypeSymbol)targetType).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[0].Type);
                    return;
                case LambdaConversionResult.ExpressionTreeFromAnonymousMethod:
                    Error(diagnostics, ErrorCode.ERR_AnonymousMethodToExpressionTree, syntax);
                    return;
            }
            NamedTypeSymbol delegateType = targetType.GetDelegateType();
            switch (lambdaConversionResult)
            {
                case LambdaConversionResult.MissingSignatureWithOutParameter:
                    Error(diagnostics, ErrorCode.ERR_CantConvAnonMethNoParams, syntax, targetType);
                    return;
                case LambdaConversionResult.BadParameterCount:
                    Error(diagnostics, ErrorCode.ERR_BadDelArgCount, syntax, delegateType, anonymousFunction.ParameterCount);
                    return;
            }
            if (anonymousFunction.HasExplicitlyTypedParameterList)
            {
                for (int i = 0; i < anonymousFunction.ParameterCount; i++)
                {
                    if (anonymousFunction.ParameterType(i).IsErrorType())
                    {
                        return;
                    }
                }
            }
            ImmutableArray<ParameterSymbol> immutableArray = delegateType.DelegateParameters();
            switch (lambdaConversionResult)
            {
                case LambdaConversionResult.RefInImplicitlyTypedLambda:
                    {
                        for (int k = 0; k < anonymousFunction.ParameterCount; k++)
                        {
                            RefKind refKind3 = immutableArray[k].RefKind;
                            if (refKind3 != 0)
                            {
                                Error(diagnostics, ErrorCode.ERR_BadParamRef, anonymousFunction.ParameterLocation(k), k + 1, refKind3.ToParameterDisplayString());
                            }
                        }
                        break;
                    }
                case LambdaConversionResult.StaticTypeInImplicitlyTypedLambda:
                    {
                        for (int l = 0; l < anonymousFunction.ParameterCount; l++)
                        {
                            if (immutableArray[l].TypeWithAnnotations.IsStatic)
                            {
                                Error(diagnostics, ErrorFacts.GetStaticClassParameterCode(useWarning: false), anonymousFunction.ParameterLocation(l), immutableArray[l].Type);
                            }
                        }
                        break;
                    }
                case LambdaConversionResult.MismatchedParameterType:
                    {
                        Error(diagnostics, ErrorCode.ERR_CantConvAnonMethParams, syntax, localizableErrorArgument, targetType);
                        for (int j = 0; j < anonymousFunction.ParameterCount; j++)
                        {
                            TypeSymbol typeSymbol = anonymousFunction.ParameterType(j);
                            if (typeSymbol.IsErrorType())
                            {
                                continue;
                            }
                            Location location = anonymousFunction.ParameterLocation(j);
                            RefKind refKind = anonymousFunction.RefKind(j);
                            TypeSymbol type = immutableArray[j].Type;
                            RefKind refKind2 = immutableArray[j].RefKind;
                            if (!typeSymbol.Equals(type, TypeCompareKind.AllIgnoreOptions))
                            {
                                SymbolDistinguisher symbolDistinguisher = new SymbolDistinguisher(Compilation, typeSymbol, type);
                                Error(diagnostics, ErrorCode.ERR_BadParamType, location, j + 1, refKind.ToParameterPrefix(), symbolDistinguisher.First, refKind2.ToParameterPrefix(), symbolDistinguisher.Second);
                            }
                            else if (refKind != refKind2)
                            {
                                if (refKind2 == RefKind.None)
                                {
                                    Error(diagnostics, ErrorCode.ERR_BadParamExtraRef, location, j + 1, refKind.ToParameterDisplayString());
                                }
                                else
                                {
                                    Error(diagnostics, ErrorCode.ERR_BadParamRef, location, j + 1, refKind2.ToParameterDisplayString());
                                }
                            }
                        }
                        break;
                    }
                case LambdaConversionResult.BindingFailed:
                    {
                        BoundLambda boundLambda = anonymousFunction.Bind(delegateType);
                        diagnostics.AddRange(boundLambda.Diagnostics);
                        break;
                    }
                default:
                    diagnostics.Add(ErrorCode.ERR_InternalError, syntax.Location);
                    break;
            }
        }

        protected static void GenerateImplicitConversionError(BindingDiagnosticBag diagnostics, CSharpCompilation compilation, SyntaxNode syntax, Conversion conversion, TypeSymbol sourceType, TypeSymbol targetType, ConstantValue sourceConstantValueOpt = null)
        {
            if (sourceType.IsErrorType() || targetType.IsErrorType())
            {
                return;
            }
            if (conversion.IsExplicit)
            {
                if (sourceType.SpecialType == SpecialType.System_Double && syntax.Kind() == SyntaxKind.NumericLiteralExpression && (targetType.SpecialType == SpecialType.System_Single || targetType.SpecialType == SpecialType.System_Decimal))
                {
                    Error(diagnostics, ErrorCode.ERR_LiteralDoubleCast, syntax, (targetType.SpecialType == SpecialType.System_Single) ? "F" : "M", targetType);
                }
                else if (conversion.Kind == ConversionKind.ExplicitNumeric && sourceConstantValueOpt != null && sourceConstantValueOpt != ConstantValue.Bad && ConversionsBase.HasImplicitConstantExpressionConversion(new BoundLiteral(syntax, ConstantValue.Bad, sourceType), targetType))
                {
                    Error(diagnostics, ErrorCode.ERR_ConstOutOfRange, syntax, sourceConstantValueOpt.Value, targetType);
                }
                else
                {
                    SymbolDistinguisher symbolDistinguisher = new SymbolDistinguisher(compilation, sourceType, targetType);
                    Error(diagnostics, ErrorCode.ERR_NoImplicitConvCast, syntax, symbolDistinguisher.First, symbolDistinguisher.Second);
                }
            }
            else if (conversion.ResultKind == LookupResultKind.OverloadResolutionFailure)
            {
                ImmutableArray<MethodSymbol> originalUserDefinedConversions = conversion.OriginalUserDefinedConversions;
                if (originalUserDefinedConversions.Length > 1)
                {
                    Error(diagnostics, ErrorCode.ERR_AmbigUDConv, syntax, originalUserDefinedConversions[0], originalUserDefinedConversions[1], sourceType, targetType);
                }
                else
                {
                    SymbolDistinguisher symbolDistinguisher2 = new SymbolDistinguisher(compilation, sourceType, targetType);
                    Error(diagnostics, ErrorCode.ERR_NoImplicitConv, syntax, symbolDistinguisher2.First, symbolDistinguisher2.Second);
                }
            }
            else if (TypeSymbol.Equals(sourceType, targetType, TypeCompareKind.ConsiderEverything))
            {
                Error(diagnostics, ErrorCode.ERR_NoImplicitConv, syntax, sourceType, targetType);
            }
            else
            {
                SymbolDistinguisher symbolDistinguisher3 = new SymbolDistinguisher(compilation, sourceType, targetType);
                Error(diagnostics, ErrorCode.ERR_NoImplicitConv, syntax, symbolDistinguisher3.First, symbolDistinguisher3.Second);
            }
        }

        protected void GenerateImplicitConversionError(BindingDiagnosticBag diagnostics, SyntaxNode syntax, Conversion conversion, BoundExpression operand, TypeSymbol targetType)
        {
            if (targetType.TypeKind == TypeKind.Error)
            {
                return;
            }
            if (targetType.IsVoidType())
            {
                Error(diagnostics, ErrorCode.ERR_NoImplicitConv, syntax, operand.Display, targetType);
                return;
            }
            switch (operand.Kind)
            {
                case BoundKind.BadExpression:
                    return;
                case BoundKind.UnboundLambda:
                    GenerateAnonymousFunctionConversionError(diagnostics, syntax, (UnboundLambda)operand, targetType);
                    return;
                case BoundKind.TupleLiteral:
                    {
                        BoundTupleLiteral boundTupleLiteral = (BoundTupleLiteral)operand;
                        if (targetType.TryGetElementTypesWithAnnotationsIfTupleType(out ImmutableArray<TypeWithAnnotations> elementTypes) && elementTypes.Length == boundTupleLiteral.Arguments.Length)
                        {
                            GenerateImplicitConversionErrorsForTupleLiteralArguments(diagnostics, boundTupleLiteral.Arguments, elementTypes);
                            return;
                        }
                        if ((object)boundTupleLiteral.Type == null)
                        {
                            Error(diagnostics, ErrorCode.ERR_ConversionNotTupleCompatible, syntax, boundTupleLiteral.Arguments.Length, targetType);
                            return;
                        }
                        break;
                    }
                case BoundKind.MethodGroup:
                    reportMethodGroupErrors((BoundMethodGroup)operand, fromAddressOf: false);
                    return;
                case BoundKind.UnconvertedAddressOfOperator:
                    reportMethodGroupErrors(((BoundUnconvertedAddressOfOperator)operand).Operand, fromAddressOf: true);
                    return;
                case BoundKind.Literal:
                    if (operand.IsLiteralNull())
                    {
                        if (targetType.TypeKind == TypeKind.TypeParameter)
                        {
                            Error(diagnostics, ErrorCode.ERR_TypeVarCantBeNull, syntax, targetType);
                            return;
                        }
                        if (targetType.IsValueType)
                        {
                            Error(diagnostics, ErrorCode.ERR_ValueCantBeNull, syntax, targetType);
                            return;
                        }
                    }
                    break;
                case BoundKind.StackAllocArrayCreation:
                    {
                        BoundStackAllocArrayCreation boundStackAllocArrayCreation = (BoundStackAllocArrayCreation)operand;
                        Error(diagnostics, ErrorCode.ERR_StackAllocConversionNotPossible, syntax, boundStackAllocArrayCreation.ElementType, targetType);
                        return;
                    }
                case BoundKind.UnconvertedSwitchExpression:
                    {
                        BoundUnconvertedSwitchExpression obj = (BoundUnconvertedSwitchExpression)operand;
                        CompoundUseSiteInfo<AssemblySymbol> useSiteInfo3 = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
                        bool reportedError3 = false;
                        ImmutableArray<BoundSwitchExpressionArm>.Enumerator enumerator = obj.SwitchArms.GetEnumerator();
                        while (enumerator.MoveNext())
                        {
                            BoundSwitchExpressionArm current = enumerator.Current;
                            tryConversion(current.Value, ref reportedError3, ref useSiteInfo3);
                        }
                        return;
                    }
                case BoundKind.AddressOfOperator:
                    if (targetType.IsFunctionPointer())
                    {
                        Error(diagnostics, ErrorCode.ERR_InvalidAddrOp, ((BoundAddressOfOperator)operand).Operand.Syntax);
                        return;
                    }
                    break;
                case BoundKind.UnconvertedConditionalOperator:
                    {
                        BoundUnconvertedConditionalOperator boundUnconvertedConditionalOperator = (BoundUnconvertedConditionalOperator)operand;
                        CompoundUseSiteInfo<AssemblySymbol> useSiteInfo2 = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
                        bool reportedError2 = false;
                        tryConversion(boundUnconvertedConditionalOperator.Consequence, ref reportedError2, ref useSiteInfo2);
                        tryConversion(boundUnconvertedConditionalOperator.Alternative, ref reportedError2, ref useSiteInfo2);
                        return;
                    }
            }
            TypeSymbol type = operand.Type;
            if ((object)type != null)
            {
                GenerateImplicitConversionError(diagnostics, Compilation, syntax, conversion, type, targetType, operand.ConstantValue);
            }
            void reportMethodGroupErrors(BoundMethodGroup methodGroup, bool fromAddressOf)
            {
                if (!Conversions.ReportDelegateOrFunctionPointerMethodGroupDiagnostics(this, methodGroup, targetType, diagnostics))
                {
                    SyntaxNode syntaxNode = syntax;
                    while (syntaxNode.Kind() == SyntaxKind.ParenthesizedExpression)
                    {
                        syntaxNode = ((ParenthesizedExpressionSyntax)syntaxNode).Expression;
                    }
                    if (syntaxNode.Kind() == SyntaxKind.SimpleMemberAccessExpression || syntaxNode.Kind() == SyntaxKind.PointerMemberAccessExpression)
                    {
                        syntaxNode = ((MemberAccessExpressionSyntax)syntaxNode).Name;
                    }
                    Location location = syntaxNode.Location;
                    if (!ReportDelegateInvokeUseSiteDiagnostic(diagnostics, targetType, location))
                    {
                        ErrorCode code;
                        switch (targetType.TypeKind)
                        {
                            case TypeKind.FunctionPointer:
                                if (!fromAddressOf)
                                {
                                    Error(diagnostics, ErrorCode.ERR_MissingAddressOf, location);
                                    return;
                                }
                                code = ErrorCode.ERR_MethFuncPtrMismatch;
                                break;
                            case TypeKind.Delegate:
                                code = ((!fromAddressOf) ? ErrorCode.ERR_MethDelegateMismatch : ErrorCode.ERR_CannotConvertAddressOfToDelegate);
                                break;
                            default:
                                if (fromAddressOf)
                                {
                                    code = ErrorCode.ERR_AddressOfToNonFunctionPointer;
                                }
                                else
                                {
                                    if (targetType.SpecialType == SpecialType.System_Delegate && syntax.IsFeatureEnabled(MessageID.IDS_FeatureInferredDelegateType))
                                    {
                                        Error(diagnostics, ErrorCode.ERR_CannotInferDelegateType, location);
                                        return;
                                    }
                                    code = ErrorCode.ERR_MethGrpToNonDel;
                                }
                                break;
                        }
                        Error(diagnostics, code, location, methodGroup.Name, targetType);
                    }
                }
            }
            void tryConversion(BoundExpression expr, ref bool reportedError, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
            {
                Conversion conversion2 = Conversions.ClassifyImplicitConversionFromExpression(expr, targetType, ref useSiteInfo);
                if (!conversion2.IsImplicit || !conversion2.IsValid)
                {
                    GenerateImplicitConversionError(diagnostics, expr.Syntax, conversion2, expr, targetType);
                    reportedError = true;
                }
            }
        }

        private void GenerateImplicitConversionErrorsForTupleLiteralArguments(BindingDiagnosticBag diagnostics, ImmutableArray<BoundExpression> tupleArguments, ImmutableArray<TypeWithAnnotations> targetElementTypes)
        {
            _ = tupleArguments.Length;
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
            for (int i = 0; i < targetElementTypes.Length; i++)
            {
                BoundExpression boundExpression = tupleArguments[i];
                TypeSymbol type = targetElementTypes[i].Type;
                Conversion conversion = Conversions.ClassifyImplicitConversionFromExpression(boundExpression, type, ref useSiteInfo);
                if (!conversion.IsValid)
                {
                    GenerateImplicitConversionError(diagnostics, boundExpression.Syntax, conversion, boundExpression, type);
                }
            }
        }

        private BoundStatement BindIfStatement(IfStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            BoundExpression condition = BindBooleanExpression(node.Condition, diagnostics);
            BoundStatement consequence = BindPossibleEmbeddedStatement(node.Statement, diagnostics);
            BoundStatement alternativeOpt = ((node.Else == null) ? null : BindPossibleEmbeddedStatement(node.Else!.Statement, diagnostics));
            return new BoundIfStatement(node, condition, consequence, alternativeOpt);
        }

        internal BoundExpression BindBooleanExpression(ExpressionSyntax node, BindingDiagnosticBag diagnostics)
        {
            BoundExpression boundExpression = BindValue(node, diagnostics, BindValueKind.RValue);
            NamedTypeSymbol specialType = GetSpecialType(SpecialType.System_Boolean, diagnostics, node);
            if (boundExpression.HasAnyErrors)
            {
                return BoundConversion.Synthesized(node, BindToTypeForErrorRecovery(boundExpression), Conversion.NoConversion, @checked: false, explicitCastInCode: false, null, null, specialType, hasErrors: true);
            }
            if (boundExpression.HasDynamicType())
            {
                return new BoundUnaryOperator(node, UnaryOperatorKind.DynamicTrue, BindToNaturalType(boundExpression, diagnostics), null, null, LookupResultKind.Viable, specialType)
                {
                    WasCompilerGenerated = true
                };
            }
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            Conversion conversion = Conversions.ClassifyConversionFromExpression(boundExpression, specialType, ref useSiteInfo);
            diagnostics.Add(boundExpression.Syntax, useSiteInfo);
            if (conversion.IsImplicit)
            {
                if (conversion.Kind == ConversionKind.Identity && boundExpression.Kind == BoundKind.AssignmentOperator)
                {
                    BoundAssignmentOperator boundAssignmentOperator = (BoundAssignmentOperator)boundExpression;
                    if (boundAssignmentOperator.Right.Kind == BoundKind.Literal && boundAssignmentOperator.Right.ConstantValue!.Discriminator == ConstantValueTypeDiscriminator.Boolean)
                    {
                        Error(diagnostics, ErrorCode.WRN_IncorrectBooleanAssg, boundAssignmentOperator.Syntax);
                    }
                }
                return CreateConversion(boundExpression.Syntax, boundExpression, conversion, isCast: false, null, wasCompilerGenerated: true, specialType, diagnostics);
            }
            boundExpression = BindToNaturalType(boundExpression, diagnostics);
            UnaryOperatorAnalysisResult unaryOperatorAnalysisResult = UnaryOperatorOverloadResolution(UnaryOperatorKind.True, boundExpression, node, diagnostics, out LookupResultKind resultKind, out ImmutableArray<MethodSymbol> originalUserDefinedOperators);
            if (!unaryOperatorAnalysisResult.HasValue)
            {
                GenerateImplicitConversionError(diagnostics, node, conversion, boundExpression, specialType);
                return BoundConversion.Synthesized(node, boundExpression, Conversion.NoConversion, @checked: false, explicitCastInCode: false, null, null, specialType, hasErrors: true);
            }
            UnaryOperatorSignature signature = unaryOperatorAnalysisResult.Signature;
            BoundExpression operand = CreateConversion(node, boundExpression, unaryOperatorAnalysisResult.Conversion, isCast: false, null, unaryOperatorAnalysisResult.Signature.OperandType, diagnostics);
            return new BoundUnaryOperator(node, signature.Kind, operand, null, signature.Method, resultKind, originalUserDefinedOperators, signature.ReturnType)
            {
                WasCompilerGenerated = true
            };
        }

        private BoundStatement BindSwitchStatement(SwitchStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            Binder binder = GetBinder(node);
            return binder.BindSwitchStatementCore(node, binder, diagnostics);
        }

        internal virtual BoundStatement BindSwitchStatementCore(SwitchStatementSyntax node, Binder originalBinder, BindingDiagnosticBag diagnostics)
        {
            return Next!.BindSwitchStatementCore(node, originalBinder, diagnostics);
        }

        internal virtual void BindPatternSwitchLabelForInference(CasePatternSwitchLabelSyntax node, BindingDiagnosticBag diagnostics)
        {
            Next!.BindPatternSwitchLabelForInference(node, diagnostics);
        }

        private BoundStatement BindWhile(WhileStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            Binder binder = GetBinder(node);
            return binder.BindWhileParts(diagnostics, binder);
        }

        internal virtual BoundWhileStatement BindWhileParts(BindingDiagnosticBag diagnostics, Binder originalBinder)
        {
            return Next!.BindWhileParts(diagnostics, originalBinder);
        }

        private BoundStatement BindDo(DoStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            Binder binder = GetBinder(node);
            return binder.BindDoParts(diagnostics, binder);
        }

        internal virtual BoundDoStatement BindDoParts(BindingDiagnosticBag diagnostics, Binder originalBinder)
        {
            return Next!.BindDoParts(diagnostics, originalBinder);
        }

        internal BoundForStatement BindFor(ForStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            Binder binder = GetBinder(node);
            return binder.BindForParts(diagnostics, binder);
        }

        internal virtual BoundForStatement BindForParts(BindingDiagnosticBag diagnostics, Binder originalBinder)
        {
            return Next!.BindForParts(diagnostics, originalBinder);
        }

        internal BoundStatement BindForOrUsingOrFixedDeclarations(VariableDeclarationSyntax nodeOpt, LocalDeclarationKind localKind, BindingDiagnosticBag diagnostics, out ImmutableArray<BoundLocalDeclaration> declarations)
        {
            if (nodeOpt == null)
            {
                declarations = ImmutableArray<BoundLocalDeclaration>.Empty;
                return null;
            }
            TypeSyntax typeSyntax = nodeOpt.Type;
            if (localKind == LocalDeclarationKind.RegularVariable)
            {
                typeSyntax = typeSyntax.SkipRef(out var _);
            }
            TypeWithAnnotations declTypeOpt = BindTypeOrVarKeyword(typeSyntax, diagnostics, out bool isVar, out AliasSymbol alias);
            SeparatedSyntaxList<VariableDeclaratorSyntax> variables = nodeOpt.Variables;
            int count = variables.Count;
            if (isVar && count > 1)
            {
                Error(diagnostics, ErrorCode.ERR_ImplicitlyTypedVariableMultipleDeclarator, nodeOpt);
            }
            BoundLocalDeclaration[] array = new BoundLocalDeclaration[count];
            for (int i = 0; i < count; i++)
            {
                VariableDeclaratorSyntax declarator = variables[i];
                bool includeBoundType = i == 0;
                BoundLocalDeclaration boundLocalDeclaration = (array[i] = BindVariableDeclaration(localKind, isVar, declarator, typeSyntax, declTypeOpt, alias, diagnostics, includeBoundType));
            }
            declarations = array.AsImmutableOrNull();
            if (count != 1)
            {
                return new BoundMultipleLocalDeclarations(nodeOpt, declarations);
            }
            return declarations[0];
        }

        internal BoundStatement BindStatementExpressionList(SeparatedSyntaxList<ExpressionSyntax> statements, BindingDiagnosticBag diagnostics)
        {
            int count = statements.Count;
            switch (count)
            {
                case 0:
                    return null;
                case 1:
                    {
                        ExpressionSyntax expressionSyntax2 = statements[0];
                        return BindExpressionStatement(expressionSyntax2, expressionSyntax2, allowsAnyExpression: false, diagnostics);
                    }
                default:
                    {
                        ArrayBuilder<BoundStatement> instance = ArrayBuilder<BoundStatement>.GetInstance();
                        for (int i = 0; i < count; i++)
                        {
                            ExpressionSyntax expressionSyntax = statements[i];
                            BoundExpressionStatement item = BindExpressionStatement(expressionSyntax, expressionSyntax, allowsAnyExpression: false, diagnostics);
                            instance.Add(item);
                        }
                        return BoundStatementList.Synthesized(statements.Node, instance.ToImmutableAndFree());
                    }
            }
        }

        private BoundStatement BindForEach(CommonForEachStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            Binder binder = GetBinder(node);
            return GetBinder(node.Expression)!.WrapWithVariablesIfAny(node.Expression, binder.BindForEachParts(diagnostics, binder));
        }

        internal virtual BoundStatement BindForEachParts(BindingDiagnosticBag diagnostics, Binder originalBinder)
        {
            return Next!.BindForEachParts(diagnostics, originalBinder);
        }

        internal virtual BoundStatement BindForEachDeconstruction(BindingDiagnosticBag diagnostics, Binder originalBinder)
        {
            return Next!.BindForEachDeconstruction(diagnostics, originalBinder);
        }

        private BoundStatement BindBreak(BreakStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            GeneratedLabelSymbol breakLabel = BreakLabel;
            if ((object)breakLabel == null)
            {
                Error(diagnostics, ErrorCode.ERR_NoBreakOrCont, node);
                return new BoundBadStatement(node, ImmutableArray<BoundNode>.Empty, hasErrors: true);
            }
            return new BoundBreakStatement(node, breakLabel);
        }

        private BoundStatement BindContinue(ContinueStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            GeneratedLabelSymbol continueLabel = ContinueLabel;
            if ((object)continueLabel == null)
            {
                Error(diagnostics, ErrorCode.ERR_NoBreakOrCont, node);
                return new BoundBadStatement(node, ImmutableArray<BoundNode>.Empty, hasErrors: true);
            }
            return new BoundContinueStatement(node, continueLabel);
        }

        private static SwitchBinder GetSwitchBinder(Binder binder)
        {
            SwitchBinder switchBinder = binder as SwitchBinder;
            while (binder != null && switchBinder == null)
            {
                binder = binder.Next;
                switchBinder = binder as SwitchBinder;
            }
            return switchBinder;
        }

        protected static bool IsInAsyncMethod(MethodSymbol method)
        {
            return method?.IsAsync ?? false;
        }

        protected bool IsInAsyncMethod()
        {
            return IsInAsyncMethod(ContainingMemberOrLambda as MethodSymbol);
        }

        protected bool IsTaskReturningAsyncMethod()
        {
            Symbol containingMemberOrLambda = ContainingMemberOrLambda;
            if ((object)containingMemberOrLambda != null && containingMemberOrLambda.Kind == SymbolKind.Method)
            {
                return ((MethodSymbol)containingMemberOrLambda).IsAsyncReturningTask(Compilation);
            }
            return false;
        }

        protected bool IsGenericTaskReturningAsyncMethod()
        {
            Symbol containingMemberOrLambda = ContainingMemberOrLambda;
            if ((object)containingMemberOrLambda != null && containingMemberOrLambda.Kind == SymbolKind.Method)
            {
                return ((MethodSymbol)containingMemberOrLambda).IsAsyncReturningGenericTask(Compilation);
            }
            return false;
        }

        protected bool IsIAsyncEnumerableOrIAsyncEnumeratorReturningAsyncMethod()
        {
            Symbol containingMemberOrLambda = ContainingMemberOrLambda;
            if ((object)containingMemberOrLambda != null && containingMemberOrLambda.Kind == SymbolKind.Method)
            {
                MethodSymbol method = (MethodSymbol)containingMemberOrLambda;
                if (!method.IsAsyncReturningIAsyncEnumerable(Compilation))
                {
                    return method.IsAsyncReturningIAsyncEnumerator(Compilation);
                }
                return true;
            }
            return false;
        }

        protected virtual TypeSymbol GetCurrentReturnType(out RefKind refKind)
        {
            if (ContainingMemberOrLambda is MethodSymbol methodSymbol)
            {
                refKind = methodSymbol.RefKind;
                TypeSymbol returnType = methodSymbol.ReturnType;
                if ((object)returnType == LambdaSymbol.ReturnTypeIsBeingInferred)
                {
                    return null;
                }
                return returnType;
            }
            refKind = RefKind.None;
            return null;
        }

        private BoundStatement BindReturn(ReturnStatementSyntax syntax, BindingDiagnosticBag diagnostics)
        {
            RefKind refKind = RefKind.None;
            ExpressionSyntax expressionSyntax = syntax.Expression?.CheckAndUnwrapRefExpression(diagnostics, out refKind);
            BoundExpression boundExpression = null;
            if (expressionSyntax != null)
            {
                BindValueKind requiredReturnValueKind = GetRequiredReturnValueKind(refKind);
                boundExpression = BindValue(expressionSyntax, diagnostics, requiredReturnValueKind);
            }
            else
            {
                SynthesizedInteractiveInitializerMethod synthesizedInteractiveInitializerMethod = ContainingMemberOrLambda as SynthesizedInteractiveInitializerMethod;
                if (synthesizedInteractiveInitializerMethod != null)
                {
                    boundExpression = new BoundDefaultExpression(synthesizedInteractiveInitializerMethod.GetNonNullSyntaxNode(), synthesizedInteractiveInitializerMethod.ResultType);
                }
            }
            TypeSymbol currentReturnType = GetCurrentReturnType(out RefKind refKind2);
            bool flag = false;
            if (IsDirectlyInIterator)
            {
                diagnostics.Add(ErrorCode.ERR_ReturnInIterator, syntax.ReturnKeyword.GetLocation());
                flag = true;
            }
            else if (IsInAsyncMethod())
            {
                if (refKind != 0)
                {
                    diagnostics.Add(ErrorCode.ERR_MustNotHaveRefReturn, syntax.ReturnKeyword.GetLocation());
                    flag = true;
                }
                else if (IsIAsyncEnumerableOrIAsyncEnumeratorReturningAsyncMethod())
                {
                    diagnostics.Add(ErrorCode.ERR_ReturnInIterator, syntax.ReturnKeyword.GetLocation());
                    flag = true;
                }
            }
            else if ((object)currentReturnType != null && refKind != RefKind.None != (refKind2 != RefKind.None))
            {
                ErrorCode code = ((refKind != 0) ? ErrorCode.ERR_MustNotHaveRefReturn : ErrorCode.ERR_MustHaveRefReturn);
                diagnostics.Add(code, syntax.ReturnKeyword.GetLocation());
                flag = true;
            }
            if (boundExpression != null)
            {
                flag |= boundExpression.HasErrors || ((object)boundExpression.Type != null && boundExpression.Type.IsErrorType());
            }
            if (flag)
            {
                return new BoundReturnStatement(syntax, refKind, BindToTypeForErrorRecovery(boundExpression), hasErrors: true);
            }
            if ((object)currentReturnType != null)
            {
                if (currentReturnType.IsVoidType() || IsTaskReturningAsyncMethod())
                {
                    if (boundExpression != null)
                    {
                        Symbol containingMemberOrLambda = ContainingMemberOrLambda;
                        if (containingMemberOrLambda is LambdaSymbol)
                        {
                            ErrorCode code2 = (currentReturnType.IsVoidType() ? ErrorCode.ERR_RetNoObjectRequiredLambda : ErrorCode.ERR_TaskRetNoObjectRequiredLambda);
                            Error(diagnostics, code2, syntax.ReturnKeyword);
                            flag = true;
                        }
                        else
                        {
                            ErrorCode code3 = (currentReturnType.IsVoidType() ? ErrorCode.ERR_RetNoObjectRequired : ErrorCode.ERR_TaskRetNoObjectRequired);
                            Error(diagnostics, code3, syntax.ReturnKeyword, containingMemberOrLambda);
                            flag = true;
                        }
                    }
                }
                else if (boundExpression == null)
                {
                    TypeSymbol typeSymbol = (IsGenericTaskReturningAsyncMethod() ? currentReturnType.GetMemberTypeArgumentsNoUseSiteDiagnostics().Single() : currentReturnType);
                    Error(diagnostics, ErrorCode.ERR_RetObjectRequired, syntax.ReturnKeyword, typeSymbol);
                    flag = true;
                }
                else
                {
                    boundExpression = CreateReturnConversion(syntax, diagnostics, boundExpression, refKind2, currentReturnType);
                    boundExpression = ValidateEscape(boundExpression, 0u, refKind != RefKind.None, diagnostics);
                }
            }
            else if ((object)boundExpression?.Type != null && boundExpression.Type.IsVoidType())
            {
                Error(diagnostics, ErrorCode.ERR_CantReturnVoid, expressionSyntax);
                flag = true;
            }
            return new BoundReturnStatement(syntax, refKind, flag ? BindToTypeForErrorRecovery(boundExpression) : boundExpression, flag);
        }

        internal BoundExpression CreateReturnConversion(SyntaxNode syntax, BindingDiagnosticBag diagnostics, BoundExpression argument, RefKind returnRefKind, TypeSymbol returnType)
        {
            bool flag = false;
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            Conversion conversion;
            if (IsInAsyncMethod())
            {
                if (!IsGenericTaskReturningAsyncMethod())
                {
                    conversion = Conversion.NoConversion;
                    flag = true;
                }
                else
                {
                    returnType = returnType.GetMemberTypeArgumentsNoUseSiteDiagnostics().Single();
                    conversion = Conversions.ClassifyConversionFromExpression(argument, returnType, ref useSiteInfo);
                }
            }
            else
            {
                conversion = Conversions.ClassifyConversionFromExpression(argument, returnType, ref useSiteInfo);
            }
            diagnostics.Add(syntax, useSiteInfo);
            if (!argument.HasAnyErrors)
            {
                if (returnRefKind != 0)
                {
                    if (conversion.Kind == ConversionKind.Identity)
                    {
                        return BindToNaturalType(argument, diagnostics);
                    }
                    Error(diagnostics, ErrorCode.ERR_RefReturnMustHaveIdentityConversion, argument.Syntax, returnType);
                    argument = argument.WithHasErrors();
                }
                else if ((!conversion.IsImplicit || !conversion.IsValid) && !flag)
                {
                    if (IsGenericTaskReturningAsyncMethod() && TypeSymbol.Equals(argument.Type, GetCurrentReturnType(out var _), TypeCompareKind.ConsiderEverything))
                    {
                        Error(diagnostics, ErrorCode.ERR_BadAsyncReturnExpression, argument.Syntax, returnType);
                    }
                    else
                    {
                        GenerateImplicitConversionError(diagnostics, argument.Syntax, conversion, argument, returnType);
                        if (ContainingMemberOrLambda is LambdaSymbol)
                        {
                            ReportCantConvertLambdaReturn(argument.Syntax, diagnostics);
                        }
                    }
                }
            }
            return CreateConversion(argument.Syntax, argument, conversion, isCast: false, null, returnType, diagnostics);
        }

        private BoundTryStatement BindTryStatement(TryStatementSyntax node, BindingDiagnosticBag diagnostics)
        {
            BoundBlock tryBlock = BindEmbeddedBlock(node.Block, diagnostics);
            ImmutableArray<BoundCatchBlock> catchBlocks = BindCatchBlocks(node.Catches, diagnostics);
            BoundBlock finallyBlockOpt = ((node.Finally != null) ? BindEmbeddedBlock(node.Finally!.Block, diagnostics) : null);
            return new BoundTryStatement(node, tryBlock, catchBlocks, finallyBlockOpt);
        }

        private ImmutableArray<BoundCatchBlock> BindCatchBlocks(SyntaxList<CatchClauseSyntax> catchClauses, BindingDiagnosticBag diagnostics)
        {
            int count = catchClauses.Count;
            if (count == 0)
            {
                return ImmutableArray<BoundCatchBlock>.Empty;
            }
            ArrayBuilder<BoundCatchBlock> instance = ArrayBuilder<BoundCatchBlock>.GetInstance(count);
            bool flag = false;
            SyntaxList<CatchClauseSyntax>.Enumerator enumerator = catchClauses.GetEnumerator();
            while (enumerator.MoveNext())
            {
                CatchClauseSyntax current = enumerator.Current;
                if (flag)
                {
                    diagnostics.Add(ErrorCode.ERR_TooManyCatches, current.CatchKeyword.GetLocation());
                }
                BoundCatchBlock item = GetBinder(current)!.BindCatchBlock(current, instance, diagnostics);
                instance.Add(item);
                flag |= current.Declaration == null && current.Filter == null;
            }
            return instance.ToImmutableAndFree();
        }

        private BoundCatchBlock BindCatchBlock(CatchClauseSyntax node, ArrayBuilder<BoundCatchBlock> previousBlocks, BindingDiagnosticBag diagnostics)
        {
            bool flag = false;
            TypeSymbol typeSymbol = null;
            BoundExpression boundExpression = null;
            CatchDeclarationSyntax declaration = node.Declaration;
            if (declaration != null)
            {
                typeSymbol = BindType(declaration.Type, diagnostics).Type;
                if (typeSymbol.IsErrorType())
                {
                    flag = true;
                }
                else
                {
                    CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                    TypeSymbol type = typeSymbol.EffectiveType(ref useSiteInfo);
                    if (!Compilation.IsExceptionType(type, ref useSiteInfo))
                    {
                        Error(diagnostics, ErrorCode.ERR_BadExceptionType, declaration.Type);
                        flag = true;
                        diagnostics.Add(declaration.Type, useSiteInfo);
                    }
                    else
                    {
                        diagnostics.AddDependencies(useSiteInfo);
                    }
                }
            }
            CatchFilterClauseSyntax filter = node.Filter;
            if (filter != null)
            {
                boundExpression = GetBinder(filter)!.BindCatchFilter(filter, diagnostics);
                flag |= boundExpression.HasAnyErrors;
            }
            if (!flag)
            {
                ArrayBuilder<BoundCatchBlock>.Enumerator enumerator = previousBlocks.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    BoundCatchBlock current = enumerator.Current;
                    TypeSymbol exceptionTypeOpt = current.ExceptionTypeOpt;
                    if (current.ExceptionFilterOpt != null || (object)exceptionTypeOpt == null || exceptionTypeOpt.IsErrorType())
                    {
                        continue;
                    }
                    if ((object)typeSymbol != null)
                    {
                        CompoundUseSiteInfo<AssemblySymbol> useSiteInfo2 = GetNewCompoundUseSiteInfo(diagnostics);
                        if (Conversions.HasIdentityOrImplicitReferenceConversion(typeSymbol, exceptionTypeOpt, ref useSiteInfo2))
                        {
                            Error(diagnostics, ErrorCode.ERR_UnreachableCatch, declaration.Type, exceptionTypeOpt);
                            diagnostics.Add(declaration.Type, useSiteInfo2);
                            flag = true;
                            break;
                        }
                        diagnostics.Add(declaration.Type, useSiteInfo2);
                    }
                    else if (TypeSymbol.Equals(exceptionTypeOpt, Compilation.GetWellKnownType(WellKnownType.System_Exception), TypeCompareKind.ConsiderEverything) && Compilation.SourceAssembly.RuntimeCompatibilityWrapNonExceptionThrows)
                    {
                        Error(diagnostics, ErrorCode.WRN_UnreachableGeneralCatch, node.CatchKeyword);
                        break;
                    }
                }
            }
            ImmutableArray<LocalSymbol> declaredLocalsForScope = GetBinder(node)!.GetDeclaredLocalsForScope(node);
            BoundExpression exceptionSourceOpt = null;
            LocalSymbol localSymbol = declaredLocalsForScope.FirstOrDefault();
            if ((object)localSymbol != null && localSymbol.DeclarationKind == LocalDeclarationKind.CatchVariable)
            {
                flag |= ValidateDeclarationNameConflictsInScope(localSymbol, diagnostics);
                exceptionSourceOpt = new BoundLocal(declaration, localSymbol, null, localSymbol.Type);
            }
            BoundBlock body = BindEmbeddedBlock(node.Block, diagnostics);
            return new BoundCatchBlock(node, declaredLocalsForScope, exceptionSourceOpt, typeSymbol, null, boundExpression, body, flag);
        }

        private BoundExpression BindCatchFilter(CatchFilterClauseSyntax filter, BindingDiagnosticBag diagnostics)
        {
            BoundExpression boundExpression = BindBooleanExpression(filter.FilterExpression, diagnostics);
            if (boundExpression.ConstantValue != null)
            {
                ErrorCode code = (boundExpression.ConstantValue!.BooleanValue ? ErrorCode.WRN_FilterIsConstantTrue : ((filter.Parent!.Parent is TryStatementSyntax tryStatementSyntax && tryStatementSyntax.Catches.Count == 1 && tryStatementSyntax.Finally == null) ? ErrorCode.WRN_FilterIsConstantFalseRedundantTryCatch : ErrorCode.WRN_FilterIsConstantFalse));
                Error(diagnostics, code, filter.FilterExpression);
            }
            return boundExpression;
        }

        private void ReportCantConvertLambdaReturn(SyntaxNode syntax, BindingDiagnosticBag diagnostics)
        {
            if (!(syntax.Parent is QueryClauseSyntax) && !(syntax.Parent is SelectOrGroupClauseSyntax) && ContainingMemberOrLambda is LambdaSymbol lambdaSymbol)
            {
                Location locationForDiagnostics = GetLocationForDiagnostics(syntax);
                if (IsInAsyncMethod())
                {
                    Error(diagnostics, ErrorCode.ERR_CantConvAsyncAnonFuncReturns, locationForDiagnostics, lambdaSymbol.MessageID.Localize(), lambdaSymbol.ReturnType);
                }
                else
                {
                    Error(diagnostics, ErrorCode.ERR_CantConvAnonMethReturns, locationForDiagnostics, lambdaSymbol.MessageID.Localize());
                }
            }
        }

        private static Location GetLocationForDiagnostics(SyntaxNode node)
        {
            if (!(node is LambdaExpressionSyntax lambdaExpressionSyntax))
            {
                if (node is AnonymousMethodExpressionSyntax anonymousMethodExpressionSyntax)
                {
                    return Location.Create(anonymousMethodExpressionSyntax.SyntaxTree, TextSpan.FromBounds(anonymousMethodExpressionSyntax.SpanStart, anonymousMethodExpressionSyntax.ParameterList?.Span.End ?? anonymousMethodExpressionSyntax.DelegateKeyword.Span.End));
                }
                return node.Location;
            }
            return Location.Create(lambdaExpressionSyntax.SyntaxTree, TextSpan.FromBounds(lambdaExpressionSyntax.SpanStart, lambdaExpressionSyntax.ArrowToken.Span.End));
        }

        private static bool IsValidStatementExpression(SyntaxNode syntax, BoundExpression expression)
        {
            if (!SyntaxFacts.IsStatementExpression(syntax))
            {
                return false;
            }
            if (expression.IsSuppressed)
            {
                return false;
            }
            if (expression.Kind == BoundKind.DelegateCreationExpression || expression.Kind == BoundKind.NameOfOperator)
            {
                return false;
            }
            return true;
        }

        internal BoundBlock CreateBlockFromExpression(CSharpSyntaxNode node, ImmutableArray<LocalSymbol> locals, RefKind refKind, BoundExpression expression, ExpressionSyntax expressionSyntax, BindingDiagnosticBag diagnostics)
        {
            TypeSymbol currentReturnType = GetCurrentReturnType(out RefKind refKind2);
            SyntaxNode syntaxNode = expressionSyntax ?? expression.Syntax;
            BoundStatement item;
            if (IsInAsyncMethod() && refKind != 0)
            {
                Error(diagnostics, ErrorCode.ERR_MustNotHaveRefReturn, syntaxNode);
                expression = BindToTypeForErrorRecovery(expression);
                item = new BoundReturnStatement(syntaxNode, refKind, expression)
                {
                    WasCompilerGenerated = true
                };
            }
            else if ((object)currentReturnType != null)
            {
                if (refKind != RefKind.None != (refKind2 != RefKind.None) && expression.Kind != BoundKind.ThrowExpression)
                {
                    ErrorCode code = ((refKind != 0) ? ErrorCode.ERR_MustNotHaveRefReturn : ErrorCode.ERR_MustHaveRefReturn);
                    Error(diagnostics, code, syntaxNode);
                    expression = BindToTypeForErrorRecovery(expression);
                    item = new BoundReturnStatement(syntaxNode, RefKind.None, expression)
                    {
                        WasCompilerGenerated = true
                    };
                }
                else if (currentReturnType.IsVoidType() || IsTaskReturningAsyncMethod())
                {
                    bool hasErrors = false;
                    if (expressionSyntax == null || !IsValidExpressionBody(expressionSyntax, expression))
                    {
                        expression = BindToTypeForErrorRecovery(expression);
                        Error(diagnostics, ErrorCode.ERR_IllegalStatement, syntaxNode);
                        hasErrors = true;
                    }
                    else
                    {
                        expression = BindToNaturalType(expression, diagnostics);
                    }
                    BoundExpressionStatement boundExpressionStatement = new BoundExpressionStatement(syntaxNode, expression, hasErrors);
                    CheckForUnobservedAwaitable(expression, diagnostics);
                    item = boundExpressionStatement;
                }
                else if (IsIAsyncEnumerableOrIAsyncEnumeratorReturningAsyncMethod())
                {
                    Error(diagnostics, ErrorCode.ERR_ReturnInIterator, syntaxNode);
                    expression = BindToTypeForErrorRecovery(expression);
                    item = new BoundReturnStatement(syntaxNode, refKind2, expression)
                    {
                        WasCompilerGenerated = true
                    };
                }
                else
                {
                    expression = (currentReturnType.IsErrorType() ? BindToTypeForErrorRecovery(expression) : CreateReturnConversion(syntaxNode, diagnostics, expression, refKind, currentReturnType));
                    item = new BoundReturnStatement(syntaxNode, refKind2, expression)
                    {
                        WasCompilerGenerated = true
                    };
                }
            }
            else
            {
                TypeSymbol? type = expression.Type;
                if ((object)type != null && type!.SpecialType == SpecialType.System_Void)
                {
                    expression = BindToNaturalType(expression, diagnostics);
                    item = new BoundExpressionStatement(syntaxNode, expression)
                    {
                        WasCompilerGenerated = true
                    };
                }
                else
                {
                    if (!(ContainingMemberOrLambda is MethodSymbol methodSymbol) || (object)methodSymbol.ReturnType != LambdaSymbol.ReturnTypeIsBeingInferred)
                    {
                        expression = BindToNaturalType(expression, diagnostics);
                    }
                    item = new BoundReturnStatement(syntaxNode, refKind, expression)
                    {
                        WasCompilerGenerated = true
                    };
                }
            }
            return new BoundBlock(node, locals, ImmutableArray.Create(item))
            {
                WasCompilerGenerated = (node.Kind() != SyntaxKind.ArrowExpressionClause)
            };
        }

        private static bool IsValidExpressionBody(SyntaxNode expressionSyntax, BoundExpression expression)
        {
            if (!IsValidStatementExpression(expressionSyntax, expression))
            {
                return expressionSyntax.Kind() == SyntaxKind.ThrowExpression;
            }
            return true;
        }

        internal virtual BoundBlock BindExpressionBodyAsBlock(ArrowExpressionClauseSyntax expressionBody, BindingDiagnosticBag diagnostics)
        {
            Binder binder = GetBinder(expressionBody);
            return bindExpressionBodyAsBlockInternal(expressionBody, binder, diagnostics);
            static BoundBlock bindExpressionBodyAsBlockInternal(ArrowExpressionClauseSyntax expressionBody, Binder bodyBinder, BindingDiagnosticBag diagnostics)
            {
                ExpressionSyntax expressionSyntax = expressionBody.Expression.CheckAndUnwrapRefExpression(diagnostics, out RefKind refKind);
                BindValueKind requiredReturnValueKind = bodyBinder.GetRequiredReturnValueKind(refKind);
                BoundExpression expr = bodyBinder.BindValue(expressionSyntax, diagnostics, requiredReturnValueKind);
                expr = bodyBinder.ValidateEscape(expr, 0u, refKind != RefKind.None, diagnostics);
                return bodyBinder.CreateBlockFromExpression(expressionBody, bodyBinder.GetDeclaredLocalsForScope(expressionBody), refKind, expr, expressionSyntax, diagnostics);
            }
        }

        public BoundBlock BindLambdaExpressionAsBlock(ExpressionSyntax body, BindingDiagnosticBag diagnostics)
        {
            Binder binder = GetBinder(body);
            ExpressionSyntax expressionSyntax = body.CheckAndUnwrapRefExpression(diagnostics, out RefKind refKind);
            BindValueKind requiredReturnValueKind = GetRequiredReturnValueKind(refKind);
            BoundExpression expr = binder.BindValue(expressionSyntax, diagnostics, requiredReturnValueKind);
            expr = ValidateEscape(expr, 0u, refKind != RefKind.None, diagnostics);
            return binder.CreateBlockFromExpression(body, binder.GetDeclaredLocalsForScope(body), refKind, expr, expressionSyntax, diagnostics);
        }

        public BoundBlock CreateBlockFromExpression(ExpressionSyntax body, BoundExpression expression, BindingDiagnosticBag diagnostics)
        {
            Binder binder = GetBinder(body);
            return binder.CreateBlockFromExpression(body, binder.GetDeclaredLocalsForScope(body), RefKind.None, expression, body, diagnostics);
        }

        private BindValueKind GetRequiredReturnValueKind(RefKind refKind)
        {
            BindValueKind result = BindValueKind.RValue;
            if (refKind != 0)
            {
                GetCurrentReturnType(out var refKind2);
                result = ((refKind2 == RefKind.Ref) ? BindValueKind.RefReturn : BindValueKind.ReadonlyRef);
            }
            return result;
        }

        public virtual BoundNode BindMethodBody(CSharpSyntaxNode syntax, BindingDiagnosticBag diagnostics)
        {
            if (!(syntax is RecordDeclarationSyntax recordDecl))
            {
                if (!(syntax is BaseMethodDeclarationSyntax baseMethodDeclarationSyntax))
                {
                    if (!(syntax is AccessorDeclarationSyntax accessorDeclarationSyntax))
                    {
                        if (!(syntax is ArrowExpressionClauseSyntax expressionBody))
                        {
                            if (syntax is CompilationUnitSyntax compilationUnit)
                            {
                                return BindSimpleProgram(compilationUnit, diagnostics);
                            }
                            throw ExceptionUtilities.UnexpectedValue(syntax.Kind());
                        }
                        return BindExpressionBodyAsBlock(expressionBody, diagnostics);
                    }
                    return BindMethodBody(accessorDeclarationSyntax, accessorDeclarationSyntax.Body, accessorDeclarationSyntax.ExpressionBody, diagnostics);
                }
                if (baseMethodDeclarationSyntax.Kind() == SyntaxKind.ConstructorDeclaration)
                {
                    return BindConstructorBody((ConstructorDeclarationSyntax)baseMethodDeclarationSyntax, diagnostics);
                }
                return BindMethodBody(baseMethodDeclarationSyntax, baseMethodDeclarationSyntax.Body, baseMethodDeclarationSyntax.ExpressionBody, diagnostics);
            }
            return BindRecordConstructorBody(recordDecl, diagnostics);
        }

        private BoundNode BindSimpleProgram(CompilationUnitSyntax compilationUnit, BindingDiagnosticBag diagnostics)
        {
            SynthesizedSimpleProgramEntryPointSymbol simpleProgram = (SynthesizedSimpleProgramEntryPointSymbol)ContainingMemberOrLambda;
            return GetBinder(compilationUnit)!.BindSimpleProgramCompilationUnit(compilationUnit, simpleProgram, diagnostics);
        }

        private BoundNode BindSimpleProgramCompilationUnit(CompilationUnitSyntax compilationUnit, SynthesizedSimpleProgramEntryPointSymbol simpleProgram, BindingDiagnosticBag diagnostics)
        {
            ArrayBuilder<BoundStatement> instance = ArrayBuilder<BoundStatement>.GetInstance();
            SyntaxList<MemberDeclarationSyntax>.Enumerator enumerator = compilationUnit.Members.GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (enumerator.Current is GlobalStatementSyntax globalStatementSyntax)
                {
                    BoundStatement item = BindStatement(globalStatementSyntax.Statement, diagnostics);
                    instance.Add(item);
                }
            }
            return new BoundNonConstructorMethodBody(compilationUnit, FinishBindBlockParts(compilationUnit, instance.ToImmutableAndFree(), diagnostics).MakeCompilerGenerated(), null);
        }

        private BoundNode BindRecordConstructorBody(RecordDeclarationSyntax recordDecl, BindingDiagnosticBag diagnostics)
        {
            Binder binder = GetBinder(recordDecl);
            BoundExpressionStatement initializer = null;
            PrimaryConstructorBaseTypeSyntax primaryConstructorBaseTypeIfClass = recordDecl.PrimaryConstructorBaseTypeIfClass;
            if (primaryConstructorBaseTypeIfClass != null)
            {
                initializer = binder.BindConstructorInitializer(primaryConstructorBaseTypeIfClass, diagnostics);
            }
            return new BoundConstructorMethodBody(recordDecl, binder.GetDeclaredLocalsForScope(recordDecl), initializer, new BoundBlock(recordDecl, ImmutableArray<LocalSymbol>.Empty, ImmutableArray<BoundStatement>.Empty).MakeCompilerGenerated(), null);
        }

        internal virtual BoundExpressionStatement BindConstructorInitializer(PrimaryConstructorBaseTypeSyntax initializer, BindingDiagnosticBag diagnostics)
        {
            BoundExpression expression = GetBinder(initializer)!.BindConstructorInitializer(initializer.ArgumentList, (MethodSymbol)ContainingMember(), diagnostics);
            return new BoundExpressionStatement(initializer, expression);
        }

        private BoundNode BindConstructorBody(ConstructorDeclarationSyntax constructor, BindingDiagnosticBag diagnostics)
        {
            if (constructor.Initializer == null && constructor.Body == null && constructor.ExpressionBody == null)
            {
                return null;
            }
            Binder binder = GetBinder(constructor);
            ConstructorInitializerSyntax? initializer = constructor.Initializer;
            if ((initializer == null || !initializer.IsKind(SyntaxKind.ThisConstructorInitializer)) && ContainingType!.GetMembersUnordered().OfType<SynthesizedRecordConstructor>().Any())
            {
                MethodSymbol methodSymbol = (MethodSymbol)ContainingMember();
                if (!methodSymbol.IsStatic && !SynthesizedRecordCopyCtor.IsCopyConstructor(methodSymbol))
                {
                    Error(diagnostics, ErrorCode.ERR_UnexpectedOrMissingConstructorInitializerInRecord, constructor.Initializer?.ThisOrBaseKeyword ?? constructor.Identifier);
                }
            }
            return new BoundConstructorMethodBody(constructor, binder.GetDeclaredLocalsForScope(constructor), (constructor.Initializer == null) ? null : binder.BindConstructorInitializer(constructor.Initializer, diagnostics), (constructor.Body == null) ? null : ((BoundBlock)binder.BindStatement(constructor.Body, diagnostics)), (constructor.ExpressionBody == null) ? null : binder.BindExpressionBodyAsBlock(constructor.ExpressionBody, (constructor.Body == null) ? diagnostics : BindingDiagnosticBag.Discarded));
        }

        internal virtual BoundExpressionStatement BindConstructorInitializer(ConstructorInitializerSyntax initializer, BindingDiagnosticBag diagnostics)
        {
            BoundExpression expression = GetBinder(initializer)!.BindConstructorInitializer(initializer.ArgumentList, (MethodSymbol)ContainingMember(), diagnostics);
            return new BoundExpressionStatement(initializer, expression);
        }

        private BoundNode BindMethodBody(CSharpSyntaxNode declaration, BlockSyntax blockBody, ArrowExpressionClauseSyntax expressionBody, BindingDiagnosticBag diagnostics)
        {
            if (blockBody == null && expressionBody == null)
            {
                return null;
            }
            return new BoundNonConstructorMethodBody(declaration, (blockBody == null) ? null : ((BoundBlock)BindStatement(blockBody, diagnostics)), (expressionBody == null) ? null : BindExpressionBodyAsBlock(expressionBody, (blockBody == null) ? diagnostics : BindingDiagnosticBag.Discarded));
        }

        internal PatternLookupResult PerformPatternMethodLookup(BoundExpression receiver, string methodName, SyntaxNode syntaxNode, BindingDiagnosticBag diagnostics, out MethodSymbol result)
        {
            BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(diagnostics);
            try
            {
                result = null;
                BoundExpression boundExpression = BindInstanceMemberAccess(syntaxNode, syntaxNode, receiver, methodName, 0, default(SeparatedSyntaxList<TypeSyntax>), default(ImmutableArray<TypeWithAnnotations>), invoked: true, indexed: false, instance);
                if (boundExpression.Kind != BoundKind.MethodGroup)
                {
                    return PatternLookupResult.NotAMethod;
                }
                AnalyzedArguments instance2 = AnalyzedArguments.GetInstance();
                BoundExpression boundExpression2 = BindMethodGroupInvocation(syntaxNode, syntaxNode, methodName, (BoundMethodGroup)boundExpression, instance2, instance, null, allowUnexpandedForm: false, out bool anyApplicableCandidates);
                instance2.Free();
                if (boundExpression2.Kind != BoundKind.Call)
                {
                    return PatternLookupResult.NotCallable;
                }
                BoundCall boundCall = (BoundCall)boundExpression2;
                if (boundCall.ResultKind == LookupResultKind.Empty)
                {
                    return PatternLookupResult.NoResults;
                }
                diagnostics.AddRange(instance);
                MethodSymbol method = boundCall.Method;
                if (method is ErrorMethodSymbol || boundExpression2.HasAnyErrors)
                {
                    return PatternLookupResult.ResultHasErrors;
                }
                result = method;
                return PatternLookupResult.Success;
            }
            finally
            {
                instance.Free();
            }
        }

        internal TypeWithAnnotations BindTypeOrVarKeyword(TypeSyntax syntax, BindingDiagnosticBag diagnostics, out bool isVar)
        {
            NamespaceOrTypeOrAliasSymbolWithAnnotations symbol = BindTypeOrAliasOrVarKeyword(syntax, diagnostics, out isVar);
            if (!isVar)
            {
                return UnwrapAlias(in symbol, diagnostics, syntax).TypeWithAnnotations;
            }
            return default(TypeWithAnnotations);
        }

        private TypeWithAnnotations BindTypeOrConstraintKeyword(TypeSyntax syntax, BindingDiagnosticBag diagnostics, out ConstraintContextualKeyword keyword)
        {
            NamespaceOrTypeOrAliasSymbolWithAnnotations symbol = BindTypeOrAliasOrConstraintKeyword(syntax, diagnostics, out keyword);
            if (keyword == ConstraintContextualKeyword.None)
            {
                return UnwrapAlias(in symbol, diagnostics, syntax).TypeWithAnnotations;
            }
            return default(TypeWithAnnotations);
        }

        internal TypeWithAnnotations BindTypeOrVarKeyword(TypeSyntax syntax, BindingDiagnosticBag diagnostics, out bool isVar, out AliasSymbol alias)
        {
            NamespaceOrTypeOrAliasSymbolWithAnnotations symbol = BindTypeOrAliasOrVarKeyword(syntax, diagnostics, out isVar);
            if (isVar)
            {
                alias = null;
                return default(TypeWithAnnotations);
            }
            return UnwrapAlias(in symbol, out alias, diagnostics, syntax).TypeWithAnnotations;
        }

        private NamespaceOrTypeOrAliasSymbolWithAnnotations BindTypeOrAliasOrVarKeyword(TypeSyntax syntax, BindingDiagnosticBag diagnostics, out bool isVar)
        {
            if (syntax.IsVar)
            {
                NamespaceOrTypeOrAliasSymbolWithAnnotations result = BindTypeOrAliasOrKeyword((IdentifierNameSyntax)syntax, diagnostics, out isVar);
                if (isVar)
                {
                    CheckFeatureAvailability(syntax, MessageID.IDS_FeatureImplicitLocal, diagnostics);
                }
                return result;
            }
            isVar = false;
            return BindTypeOrAlias(syntax, diagnostics);
        }

        private NamespaceOrTypeOrAliasSymbolWithAnnotations BindTypeOrAliasOrConstraintKeyword(TypeSyntax syntax, BindingDiagnosticBag diagnostics, out ConstraintContextualKeyword keyword)
        {
            if (syntax.IsUnmanaged)
            {
                keyword = ConstraintContextualKeyword.Unmanaged;
            }
            else if (syntax.IsNotNull)
            {
                keyword = ConstraintContextualKeyword.NotNull;
            }
            else
            {
                keyword = ConstraintContextualKeyword.None;
            }
            if (keyword != 0)
            {
                IdentifierNameSyntax syntax2 = (IdentifierNameSyntax)syntax;
                NamespaceOrTypeOrAliasSymbolWithAnnotations result = BindTypeOrAliasOrKeyword(syntax2, diagnostics, out bool isKeyword);
                if (isKeyword)
                {
                    switch (keyword)
                    {
                        case ConstraintContextualKeyword.Unmanaged:
                            CheckFeatureAvailability(syntax, MessageID.IDS_FeatureUnmanagedGenericTypeConstraint, diagnostics);
                            break;
                        case ConstraintContextualKeyword.NotNull:
                            CheckFeatureAvailability(syntax2, MessageID.IDS_FeatureNotNullGenericTypeConstraint, diagnostics);
                            break;
                        default:
                            throw ExceptionUtilities.UnexpectedValue(keyword);
                    }
                }
                else
                {
                    keyword = ConstraintContextualKeyword.None;
                }
                return result;
            }
            return BindTypeOrAlias(syntax, diagnostics);
        }

        private NamespaceOrTypeOrAliasSymbolWithAnnotations BindTypeOrAliasOrKeyword(IdentifierNameSyntax syntax, BindingDiagnosticBag diagnostics, out bool isKeyword)
        {
            return BindTypeOrAliasOrKeyword(syntax.Identifier, syntax, diagnostics, out isKeyword);
        }

        private NamespaceOrTypeOrAliasSymbolWithAnnotations BindTypeOrAliasOrKeyword(SyntaxToken identifier, SyntaxNode syntax, BindingDiagnosticBag diagnostics, out bool isKeyword)
        {
            // Keywords can only be IdentifierNameSyntax
            var identifierValueText = identifier.ValueText;
            Symbol symbol = null;

            // Perform name lookup without generating diagnostics as it could possibly be a keyword in the current context.
            var lookupResult = LookupResult.GetInstance();
            var discardedUseSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
            this.LookupSymbolsInternal(lookupResult, identifierValueText, arity: 0, useSiteInfo: ref discardedUseSiteInfo, basesBeingResolved: null, options: LookupOptions.NamespacesOrTypesOnly, diagnose: false);

            // We have following possible cases for lookup:

            //  1) LookupResultKind.Empty: must be a keyword

            //  2) LookupResultKind.Viable:
            //      a) Single viable result that corresponds to 1) a non-error type: cannot be a keyword
            //                                                  2) an error type: must be a keyword
            //      b) Single viable result that corresponds to namespace: must be a keyword
            //      c) Multi viable result (ambiguous result), we must return an error type: cannot be a keyword

            // 3) Non viable, non empty lookup result: must be a keyword

            // BREAKING CHANGE:     Case (2)(c) is a breaking change from the native compiler.
            // BREAKING CHANGE:     Native compiler interprets lookup with ambiguous result to correspond to bind
            // BREAKING CHANGE:     to "var" keyword (isVar = true), rather than reporting an error.
            // BREAKING CHANGE:     See test SemanticErrorTests.ErrorMeansSuccess_var() for an example.

            switch (lookupResult.Kind)
            {
                case LookupResultKind.Empty:
                    // Case (1)
                    isKeyword = true;
                    symbol = null;
                    break;

                case LookupResultKind.Viable:
                    // Case (2)
                    var resultDiagnostics = new BindingDiagnosticBag(DiagnosticBag.GetInstance(), diagnostics.DependenciesBag);
                    bool wasError;
                    symbol = ResultSymbol(
                        lookupResult,
                        identifierValueText,
                        arity: 0,
                        where: syntax,
                        diagnostics: resultDiagnostics,
                        suppressUseSiteDiagnostics: false,
                        wasError: out wasError,
                        qualifierOpt: null);

                    // Here, we're mimicking behavior of dev10.  If the identifier fails to bind
                    // as a type, even if the reason is (e.g.) a type/alias conflict, then treat
                    // it as the contextual keyword.
                    if (wasError && lookupResult.IsSingleViable)
                    {
                        // NOTE: don't report diagnostics - we're not going to use the lookup result.
                        resultDiagnostics.DiagnosticBag.Free();
                        // Case (2)(a)(2)
                        goto default;
                    }

                    diagnostics.AddRange(resultDiagnostics.DiagnosticBag);
                    resultDiagnostics.DiagnosticBag.Free();

                    if (lookupResult.IsSingleViable)
                    {
                        var type = UnwrapAlias(symbol, diagnostics, syntax) as TypeSymbol;

                        if ((object)type != null)
                        {
                            // Case (2)(a)(1)
                            isKeyword = false;
                        }
                        else
                        {
                            // Case (2)(b)
                            isKeyword = true;
                            symbol = null;
                        }
                    }
                    else
                    {
                        // Case (2)(c)
                        isKeyword = false;
                    }

                    break;

                default:
                    // Case (3)
                    isKeyword = true;
                    symbol = null;
                    break;
            }

            lookupResult.Free();

            return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(AreNullableAnnotationsEnabled(identifier), symbol);
        }

        internal TypeWithAnnotations BindType(ExpressionSyntax syntax, BindingDiagnosticBag diagnostics, ConsList<TypeSymbol> basesBeingResolved = null, bool suppressUseSiteDiagnostics = false)
        {
            NamespaceOrTypeOrAliasSymbolWithAnnotations symbol = BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);
            return UnwrapAlias(in symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations;
        }

        internal TypeWithAnnotations BindType(ExpressionSyntax syntax, BindingDiagnosticBag diagnostics, out AliasSymbol alias, ConsList<TypeSymbol> basesBeingResolved = null)
        {
            NamespaceOrTypeOrAliasSymbolWithAnnotations symbol = BindTypeOrAlias(syntax, diagnostics, basesBeingResolved);
            return UnwrapAlias(in symbol, out alias, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations;
        }

        internal NamespaceOrTypeOrAliasSymbolWithAnnotations BindTypeOrAlias(ExpressionSyntax syntax, BindingDiagnosticBag diagnostics, ConsList<TypeSymbol> basesBeingResolved = null, bool suppressUseSiteDiagnostics = false)
        {
            NamespaceOrTypeOrAliasSymbolWithAnnotations result = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics);
            if (result.IsType || (result.IsAlias && UnwrapAliasNoDiagnostics(result.Symbol, basesBeingResolved) is TypeSymbol))
            {
                if (result.IsType)
                {
                    result.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics);
                }
                return result;
            }
            CSDiagnosticInfo errorInfo = diagnostics.Add(ErrorCode.ERR_BadSKknown, syntax.Location, syntax, result.Symbol.GetKindText(), MessageID.IDS_SK_TYPE.Localize());
            return TypeWithAnnotations.Create(new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(result.Symbol), result.Symbol, LookupResultKind.NotATypeOrNamespace, errorInfo));
        }

        private NamespaceOrTypeSymbol GetContainingNamespaceOrType(Symbol symbol)
        {
            return symbol.ContainingNamespaceOrType() ?? Compilation.Assembly.GlobalNamespace;
        }

        internal Symbol BindNamespaceAliasSymbol(IdentifierNameSyntax node, BindingDiagnosticBag diagnostics)
        {
            if (node.Identifier.Kind() == SyntaxKind.GlobalKeyword)
            {
                return Compilation.GlobalNamespaceAlias;
            }
            string valueText = node.Identifier.ValueText;
            LookupResult instance = LookupResult.GetInstance();
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            LookupSymbolsWithFallback(instance, valueText, 0, ref useSiteInfo, null, LookupOptions.NamespaceAliasesOnly);
            diagnostics.Add(node, useSiteInfo);
            Symbol result = ResultSymbol(instance, valueText, 0, node, diagnostics, suppressUseSiteDiagnostics: false, out bool wasError, null, LookupOptions.NamespaceAliasesOnly);
            instance.Free();
            return result;
        }

        internal NamespaceOrTypeOrAliasSymbolWithAnnotations BindNamespaceOrTypeSymbol(ExpressionSyntax syntax, BindingDiagnosticBag diagnostics, ConsList<TypeSymbol> basesBeingResolved = null)
        {
            return BindNamespaceOrTypeSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null);
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        internal NamespaceOrTypeOrAliasSymbolWithAnnotations BindNamespaceOrTypeSymbol(ExpressionSyntax syntax, BindingDiagnosticBag diagnostics, ConsList<TypeSymbol> basesBeingResolved, bool suppressUseSiteDiagnostics)
        {
            NamespaceOrTypeOrAliasSymbolWithAnnotations symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);
            return UnwrapAlias(in symbol, diagnostics, syntax, basesBeingResolved);
        }

        internal NamespaceOrTypeOrAliasSymbolWithAnnotations BindNamespaceOrTypeOrAliasSymbol(ExpressionSyntax syntax, BindingDiagnosticBag diagnostics, ConsList<TypeSymbol> basesBeingResolved, bool suppressUseSiteDiagnostics)
        {
            BindingDiagnosticBag diagnostics2 = diagnostics;
            ExpressionSyntax syntax2 = syntax;
            ConsList<TypeSymbol> basesBeingResolved2 = basesBeingResolved;
            switch (syntax2.Kind())
            {
                case SyntaxKind.NullableType:
                    return bindNullable();
                case SyntaxKind.PredefinedType:
                    return bindPredefined();
                case SyntaxKind.IdentifierName:
                    return BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol((IdentifierNameSyntax)syntax2, diagnostics2, basesBeingResolved2, suppressUseSiteDiagnostics, null);
                case SyntaxKind.GenericName:
                    return BindGenericSimpleNamespaceOrTypeOrAliasSymbol((GenericNameSyntax)syntax2, diagnostics2, basesBeingResolved2, null);
                case SyntaxKind.AliasQualifiedName:
                    return bindAlias();
                case SyntaxKind.QualifiedName:
                    {
                        QualifiedNameSyntax qualifiedNameSyntax = (QualifiedNameSyntax)syntax2;
                        return BindQualifiedName(qualifiedNameSyntax.Left, qualifiedNameSyntax.Right, diagnostics2, basesBeingResolved2, suppressUseSiteDiagnostics);
                    }
                case SyntaxKind.SimpleMemberAccessExpression:
                    {
                        MemberAccessExpressionSyntax memberAccessExpressionSyntax = (MemberAccessExpressionSyntax)syntax2;
                        return BindQualifiedName(memberAccessExpressionSyntax.Expression, memberAccessExpressionSyntax.Name, diagnostics2, basesBeingResolved2, suppressUseSiteDiagnostics);
                    }
                case SyntaxKind.ArrayType:
                    return BindArrayType((ArrayTypeSyntax)syntax2, diagnostics2, permitDimensions: false, basesBeingResolved2, disallowRestrictedTypes: true);
                case SyntaxKind.PointerType:
                    return bindPointer();
                case SyntaxKind.FunctionPointerType:
                    {
                        FunctionPointerTypeSyntax functionPointerTypeSyntax = (FunctionPointerTypeSyntax)syntax2;
                        CSDiagnosticInfo unsafeDiagnosticInfo = GetUnsafeDiagnosticInfo(null);
                        if (unsafeDiagnosticInfo != null)
                        {
                            SyntaxToken delegateKeyword = functionPointerTypeSyntax.DelegateKeyword;
                            SyntaxToken asteriskToken = functionPointerTypeSyntax.AsteriskToken;
                            diagnostics2.Add(unsafeDiagnosticInfo, Location.Create(delegateKeyword.SyntaxTree, TextSpan.FromBounds(delegateKeyword.SpanStart, asteriskToken.Span.End)));
                        }
                        return TypeWithAnnotations.Create(FunctionPointerTypeSymbol.CreateFromSource(functionPointerTypeSyntax, this, diagnostics2, basesBeingResolved2, suppressUseSiteDiagnostics));
                    }
                case SyntaxKind.OmittedTypeArgument:
                    return BindTypeArgument((TypeSyntax)syntax2, diagnostics2, basesBeingResolved2);
                case SyntaxKind.TupleType:
                    {
                        TupleTypeSyntax tupleTypeSyntax = (TupleTypeSyntax)syntax2;
                        return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(tupleTypeSyntax.CloseParenToken), BindTupleType(tupleTypeSyntax, diagnostics2, basesBeingResolved2));
                    }
                case SyntaxKind.RefType:
                    {
                        RefTypeSyntax refTypeSyntax = (RefTypeSyntax)syntax2;
                        SyntaxToken refKeyword = refTypeSyntax.RefKeyword;
                        if (!syntax2.HasErrors)
                        {
                            diagnostics2.Add(ErrorCode.ERR_UnexpectedToken, refKeyword.GetLocation(), refKeyword.ToString());
                        }
                        return BindNamespaceOrTypeOrAliasSymbol(refTypeSyntax.Type, diagnostics2, basesBeingResolved2, suppressUseSiteDiagnostics);
                    }
                default:
                    return createErrorType();
            }
            NamespaceOrTypeOrAliasSymbolWithAnnotations bindAlias()
            {
                AliasQualifiedNameSyntax aliasQualifiedNameSyntax = (AliasQualifiedNameSyntax)syntax2;
                Symbol symbol = BindNamespaceAliasSymbol(aliasQualifiedNameSyntax.Alias, diagnostics2);
                NamespaceOrTypeSymbol namespaceOrTypeSymbol = ((symbol is AliasSymbol aliasSymbol) ? aliasSymbol.Target : ((NamespaceOrTypeSymbol)symbol));
                if (namespaceOrTypeSymbol.Kind == SymbolKind.NamedType)
                {
                    return TypeWithAnnotations.Create(new ExtendedErrorTypeSymbol(namespaceOrTypeSymbol, LookupResultKind.NotATypeOrNamespace, diagnostics2.Add(ErrorCode.ERR_ColColWithTypeAlias, aliasQualifiedNameSyntax.Alias.Location, aliasQualifiedNameSyntax.Alias.Identifier.Text)));
                }
                return BindSimpleNamespaceOrTypeOrAliasSymbol(aliasQualifiedNameSyntax.Name, diagnostics2, basesBeingResolved2, suppressUseSiteDiagnostics, namespaceOrTypeSymbol);
            }
            NamespaceOrTypeOrAliasSymbolWithAnnotations bindNullable()
            {
                NullableTypeSyntax nullableTypeSyntax = (NullableTypeSyntax)syntax2;
                TypeSyntax elementType = nullableTypeSyntax.ElementType;
                TypeWithAnnotations typeArgument2 = BindType(elementType, diagnostics2, basesBeingResolved2);
                TypeWithAnnotations type = typeArgument2.SetIsAnnotated(Compilation);
                reportNullableReferenceTypesIfNeeded(nullableTypeSyntax.QuestionToken, typeArgument2);
                if (!ShouldCheckConstraints)
                {
                    diagnostics2.Add(new LazyUseSiteDiagnosticsInfoForNullableType(Compilation.LanguageVersion, type), syntax2.GetLocation());
                }
                else if (type.IsNullableType())
                {
                    ReportUseSite(type.Type.OriginalDefinition, diagnostics2, syntax2);
                    NamedTypeSymbol type2 = (NamedTypeSymbol)type.Type;
                    ConstraintsHelper.CheckConstraintsArgs args = new ConstraintsHelper.CheckConstraintsArgs(location: syntax2.Location, currentCompilation: Compilation, conversions: Conversions, includeNullability: true, diagnostics: diagnostics2);
                    type2.CheckConstraints(in args);
                }
                else
                {
                    CSDiagnosticInfo nullableUnconstrainedTypeParameterDiagnosticIfNecessary = GetNullableUnconstrainedTypeParameterDiagnosticIfNecessary(Compilation.LanguageVersion, in type);
                    if (nullableUnconstrainedTypeParameterDiagnosticIfNecessary != null)
                    {
                        diagnostics2.Add(nullableUnconstrainedTypeParameterDiagnosticIfNecessary, syntax2.Location);
                    }
                }
                return type;
            }
            NamespaceOrTypeOrAliasSymbolWithAnnotations bindPointer()
            {
                PointerTypeSyntax pointerTypeSyntax = (PointerTypeSyntax)syntax2;
                TypeWithAnnotations pointedAtType = BindType(pointerTypeSyntax.ElementType, diagnostics2, basesBeingResolved2);
                ReportUnsafeIfNotAllowed(pointerTypeSyntax, diagnostics2);
                if (!Flags.HasFlag(BinderFlags.SuppressConstraintChecks))
                {
                    CheckManagedAddr(Compilation, pointedAtType.Type, pointerTypeSyntax.Location, diagnostics2);
                }
                return TypeWithAnnotations.Create(new PointerTypeSymbol(pointedAtType));
            }
            NamespaceOrTypeOrAliasSymbolWithAnnotations bindPredefined()
            {
                PredefinedTypeSyntax predefinedTypeSyntax = (PredefinedTypeSyntax)syntax2;
                NamedTypeSymbol typeSymbol = BindPredefinedTypeSymbol(predefinedTypeSyntax, diagnostics2);
                return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedTypeSyntax.Keyword), typeSymbol);
            }
            NamespaceOrTypeOrAliasSymbolWithAnnotations createErrorType()
            {
                diagnostics2.Add(ErrorCode.ERR_TypeExpected, syntax2.GetLocation());
                return TypeWithAnnotations.Create(CreateErrorType());
            }
            void reportNullableReferenceTypesIfNeeded(SyntaxToken questionToken, TypeWithAnnotations typeArgument)
            {
                bool isNullableEnabled = AreNullableAnnotationsEnabled(questionToken);
                bool isGeneratedCode = IsGeneratedCode(questionToken);
                Location location = questionToken.GetLocation();
                DiagnosticBag diagnosticBag = diagnostics2.DiagnosticBag;
                if (diagnosticBag != null)
                {
                    if (typeArgument.HasType && !ShouldCheckConstraints)
                    {
                        LazyMissingNonNullTypesContextDiagnosticInfo.AddAll(isNullableEnabled, isGeneratedCode, typeArgument, location, diagnosticBag);
                    }
                    else
                    {
                        LazyMissingNonNullTypesContextDiagnosticInfo.ReportNullableReferenceTypesIfNeeded(isNullableEnabled, isGeneratedCode, typeArgument, location, diagnosticBag);
                    }
                }
            }
        }

        internal static CSDiagnosticInfo? GetNullableUnconstrainedTypeParameterDiagnosticIfNecessary(LanguageVersion languageVersion, in TypeWithAnnotations type)
        {
            if (type.Type.IsTypeParameterDisallowingAnnotationInCSharp8())
            {
                LanguageVersion languageVersion2 = MessageID.IDS_FeatureDefaultTypeParameterConstraint.RequiredVersion();
                if (languageVersion2 > languageVersion)
                {
                    return new CSDiagnosticInfo(ErrorCode.ERR_NullableUnconstrainedTypeParameter, new CSharpRequiredLanguageVersion(languageVersion2));
                }
            }
            return null;
        }

        private TypeWithAnnotations BindArrayType(ArrayTypeSyntax node, BindingDiagnosticBag diagnostics, bool permitDimensions, ConsList<TypeSymbol> basesBeingResolved, bool disallowRestrictedTypes)
        {
            TypeWithAnnotations typeWithAnnotations = BindType(node.ElementType, diagnostics, basesBeingResolved);
            if (typeWithAnnotations.IsStatic)
            {
                Error(diagnostics, ErrorCode.ERR_ArrayOfStaticClass, node.ElementType, typeWithAnnotations.Type);
            }
            if (disallowRestrictedTypes)
            {
                if (ShouldCheckConstraints)
                {
                    if (typeWithAnnotations.IsRestrictedType())
                    {
                        Error(diagnostics, ErrorCode.ERR_ArrayElementCantBeRefAny, node.ElementType, typeWithAnnotations.Type);
                    }
                }
                else
                {
                    diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(typeWithAnnotations), node.ElementType.GetLocation());
                }
            }
            for (int num = node.RankSpecifiers.Count - 1; num >= 0; num--)
            {
                ArrayRankSpecifierSyntax arrayRankSpecifierSyntax = node.RankSpecifiers[num];
                SeparatedSyntaxList<ExpressionSyntax> sizes = arrayRankSpecifierSyntax.Sizes;
                if (!permitDimensions && sizes.Count != 0 && sizes[0].Kind() != SyntaxKind.OmittedArraySizeExpression)
                {
                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, arrayRankSpecifierSyntax);
                }
                ArrayTypeSymbol typeSymbol = ArrayTypeSymbol.CreateCSharpArray(Compilation.Assembly, typeWithAnnotations, arrayRankSpecifierSyntax.Rank);
                typeWithAnnotations = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(arrayRankSpecifierSyntax.CloseBracketToken), typeSymbol);
            }
            return typeWithAnnotations;
        }

        private TypeSymbol BindTupleType(TupleTypeSyntax syntax, BindingDiagnosticBag diagnostics, ConsList<TypeSymbol> basesBeingResolved)
        {
            int count = syntax.Elements.Count;
            ArrayBuilder<TypeWithAnnotations> instance = ArrayBuilder<TypeWithAnnotations>.GetInstance(count);
            ArrayBuilder<Location> instance2 = ArrayBuilder<Location>.GetInstance(count);
            ArrayBuilder<string> elementNames = null;
            PooledHashSet<string> instance3 = PooledHashSet<string>.GetInstance();
            bool flag = false;
            for (int i = 0; i < count; i++)
            {
                TupleElementSyntax tupleElementSyntax = syntax.Elements[i];
                TypeWithAnnotations item = BindType(tupleElementSyntax.Type, diagnostics, basesBeingResolved);
                instance.Add(item);
                string name = null;
                SyntaxToken identifier = tupleElementSyntax.Identifier;
                if (identifier.Kind() == SyntaxKind.IdentifierToken)
                {
                    name = identifier.ValueText;
                    flag = true;
                    CheckTupleMemberName(name, i, identifier, diagnostics, instance3);
                    instance2.Add(identifier.GetLocation());
                }
                else
                {
                    instance2.Add(tupleElementSyntax.Location);
                }
                CollectTupleFieldMemberName(name, i, count, ref elementNames);
            }
            instance3.Free();
            if (flag)
            {
                ReportMissingTupleElementNamesAttributesIfNeeded(Compilation, syntax.GetLocation(), diagnostics);
            }
            ImmutableArray<TypeWithAnnotations> elementTypesWithAnnotations = instance.ToImmutableAndFree();
            ImmutableArray<Location> elementLocations = instance2.ToImmutableAndFree();
            if (elementTypesWithAnnotations.Length < 2)
            {
                throw ExceptionUtilities.UnexpectedValue(elementTypesWithAnnotations.Length);
            }
            bool flag2 = Compilation.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes);
            return NamedTypeSymbol.CreateTuple(syntax.Location, elementTypesWithAnnotations, elementLocations, elementNames?.ToImmutableAndFree() ?? default(ImmutableArray<string>), Compilation, ShouldCheckConstraints, ShouldCheckConstraints && flag2, default(ImmutableArray<bool>), syntax, diagnostics);
        }

        internal static void ReportMissingTupleElementNamesAttributesIfNeeded(CSharpCompilation compilation, Location location, BindingDiagnosticBag diagnostics)
        {
            BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(diagnostics);
            if (!compilation.HasTupleNamesAttributes(instance, location))
            {
                CSDiagnosticInfo info = new CSDiagnosticInfo(ErrorCode.ERR_TupleElementNamesAttributeMissing, AttributeDescription.TupleElementNamesAttribute.FullName);
                Error(diagnostics, info, location);
            }
            else
            {
                diagnostics.AddRange(instance);
            }
            instance.Free();
        }

        private static void CollectTupleFieldMemberName(string name, int elementIndex, int tupleSize, ref ArrayBuilder<string> elementNames)
        {
            if (elementNames != null)
            {
                elementNames.Add(name);
            }
            else if (name != null)
            {
                elementNames = ArrayBuilder<string>.GetInstance(tupleSize);
                for (int i = 0; i < elementIndex; i++)
                {
                    elementNames.Add(null);
                }
                elementNames.Add(name);
            }
        }

        private static bool CheckTupleMemberName(string name, int index, SyntaxNodeOrToken syntax, BindingDiagnosticBag diagnostics, PooledHashSet<string> uniqueFieldNames)
        {
            int num = NamedTypeSymbol.IsTupleElementNameReserved(name);
            if (num == 0)
            {
                Error(diagnostics, ErrorCode.ERR_TupleReservedElementNameAnyPosition, syntax, name);
                return false;
            }
            if (num > 0 && num != index + 1)
            {
                Error(diagnostics, ErrorCode.ERR_TupleReservedElementName, syntax, name, num);
                return false;
            }
            if (!uniqueFieldNames.Add(name))
            {
                Error(diagnostics, ErrorCode.ERR_TupleDuplicateElementName, syntax);
                return false;
            }
            return true;
        }

        private NamedTypeSymbol BindPredefinedTypeSymbol(PredefinedTypeSyntax node, BindingDiagnosticBag diagnostics)
        {
            return GetSpecialType(node.Keyword.Kind().GetSpecialType(), diagnostics, node);
        }

        private NamespaceOrTypeOrAliasSymbolWithAnnotations BindSimpleNamespaceOrTypeOrAliasSymbol(SimpleNameSyntax syntax, BindingDiagnosticBag diagnostics, ConsList<TypeSymbol> basesBeingResolved, bool suppressUseSiteDiagnostics, NamespaceOrTypeSymbol qualifierOpt = null)
        {
            return syntax.Kind() switch
            {
                SyntaxKind.IdentifierName => BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol((IdentifierNameSyntax)syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics, qualifierOpt),
                SyntaxKind.GenericName => BindGenericSimpleNamespaceOrTypeOrAliasSymbol((GenericNameSyntax)syntax, diagnostics, basesBeingResolved, qualifierOpt),
                _ => TypeWithAnnotations.Create(new ExtendedErrorTypeSymbol(qualifierOpt ?? Compilation.Assembly.GlobalNamespace, string.Empty, 0, null)),
            };
        }

        private static bool IsViableType(LookupResult result)
        {
            if (!result.IsMultiViable)
            {
                return false;
            }
            ArrayBuilder<Symbol>.Enumerator enumerator = result.Symbols.GetEnumerator();
            while (enumerator.MoveNext())
            {
                Symbol current = enumerator.Current;
                switch (current.Kind)
                {
                    case SymbolKind.Alias:
                        if (((AliasSymbol)current).Target.Kind == SymbolKind.NamedType)
                        {
                            return true;
                        }
                        break;
                    case SymbolKind.NamedType:
                    case SymbolKind.TypeParameter:
                        return true;
                }
            }
            return false;
        }

        protected NamespaceOrTypeOrAliasSymbolWithAnnotations BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol(IdentifierNameSyntax node, BindingDiagnosticBag diagnostics, ConsList<TypeSymbol> basesBeingResolved, bool suppressUseSiteDiagnostics, NamespaceOrTypeSymbol qualifierOpt)
        {
            string valueText = node.Identifier.ValueText;
            if (string.IsNullOrWhiteSpace(valueText))
            {
                return TypeWithAnnotations.Create(new ExtendedErrorTypeSymbol(Compilation.Assembly.GlobalNamespace, valueText, 0, new CSDiagnosticInfo(ErrorCode.ERR_SingleTypeNameNotFound)));
            }
            ExtendedErrorTypeSymbol extendedErrorTypeSymbol = CreateErrorIfLookupOnTypeParameter(node.Parent, qualifierOpt, valueText, 0, diagnostics);
            if ((object)extendedErrorTypeSymbol != null)
            {
                return TypeWithAnnotations.Create(extendedErrorTypeSymbol);
            }
            LookupResult instance = LookupResult.GetInstance();
            LookupOptions simpleNameLookupOptions = GetSimpleNameLookupOptions(node, node.Identifier.IsVerbatimIdentifier());
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            LookupSymbolsSimpleName(instance, qualifierOpt, valueText, 0, basesBeingResolved, simpleNameLookupOptions, diagnose: true, ref useSiteInfo);
            diagnostics.Add(node, useSiteInfo);
            Symbol symbol = null;
            if ((object)qualifierOpt == null && !IsViableType(instance))
            {
                if (node.Identifier.ValueText == "dynamic")
                {
                    if ((node.Parent == null || (node.Parent!.Kind() != SyntaxKind.Attribute && SyntaxFacts.IsInTypeOnlyContext(node))) && Compilation.LanguageVersion >= MessageID.IDS_FeatureDynamic.RequiredVersion())
                    {
                        symbol = Compilation.DynamicType;
                        ReportUseSiteDiagnosticForDynamic(diagnostics, node);
                    }
                }
                else
                {
                    symbol = BindNativeIntegerSymbolIfAny(node, diagnostics);
                }
            }
            if ((object)symbol == null)
            {
                symbol = ResultSymbol(instance, valueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out var _, qualifierOpt, simpleNameLookupOptions);
                if (symbol.Kind == SymbolKind.Alias)
                {
                    NamespaceOrTypeSymbol aliasTarget = ((AliasSymbol)symbol).GetAliasTarget(basesBeingResolved);
                    if (aliasTarget.Kind == SymbolKind.NamedType && ((NamedTypeSymbol)aliasTarget).ContainsDynamic())
                    {
                        ReportUseSiteDiagnosticForDynamic(diagnostics, node);
                    }
                }
            }
            instance.Free();
            return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(AreNullableAnnotationsEnabled(node.Identifier), symbol);
        }

        private NamedTypeSymbol BindNativeIntegerSymbolIfAny(IdentifierNameSyntax node, BindingDiagnosticBag diagnostics)
        {
            string text = node.Identifier.Text;
            SpecialType typeId;
            if (!(text == "nint"))
            {
                if (!(text == "nuint"))
                {
                    return null;
                }
                typeId = SpecialType.System_UIntPtr;
            }
            else
            {
                typeId = SpecialType.System_IntPtr;
            }
            CSharpSyntaxNode parent = node.Parent;
            if (!(parent is AttributeSyntax attributeSyntax))
            {
                if (!(parent is UsingDirectiveSyntax usingDirectiveSyntax))
                {
                    if (parent is ArgumentSyntax argumentSyntax && IsInsideNameof && argumentSyntax.Parent?.Parent is InvocationExpressionSyntax invocationExpressionSyntax)
                    {
                        IdentifierNameSyntax obj = invocationExpressionSyntax.Expression as IdentifierNameSyntax;
                        if (obj != null && obj.Identifier.ContextualKind() == SyntaxKind.NameOfKeyword)
                        {
                            return null;
                        }
                    }
                }
                else if (usingDirectiveSyntax.Name == node)
                {
                    return null;
                }
            }
            else if (attributeSyntax.Name == node)
            {
                return null;
            }
            CheckFeatureAvailability(node, MessageID.IDS_FeatureNativeInt, diagnostics);
            return GetSpecialType(typeId, diagnostics, node).AsNativeInteger();
        }

        private void ReportUseSiteDiagnosticForDynamic(BindingDiagnosticBag diagnostics, IdentifierNameSyntax node)
        {
            if (node.IsTypeInContextWhichNeedsDynamicAttribute())
            {
                BindingDiagnosticBag instance = BindingDiagnosticBag.GetInstance(diagnostics);
                if (!Compilation.HasDynamicEmitAttributes(instance, node.Location))
                {
                    Symbol.ReportUseSiteDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_DynamicAttributeMissing, AttributeDescription.DynamicAttribute.FullName), diagnostics, node.Location);
                }
                else
                {
                    diagnostics.AddRange(instance);
                }
                instance.Free();
                GetSpecialType(SpecialType.System_Boolean, diagnostics, node);
            }
        }

        private static LookupOptions GetSimpleNameLookupOptions(NameSyntax node, bool isVerbatimIdentifier)
        {
            if (SyntaxFacts.IsAttributeName(node))
            {
                if (!isVerbatimIdentifier)
                {
                    return LookupOptions.AttributeTypeOnly;
                }
                return LookupOptions.VerbatimNameAttributeTypeOnly;
            }
            return LookupOptions.NamespacesOrTypesOnly;
        }

        private static Symbol UnwrapAliasNoDiagnostics(Symbol symbol, ConsList<TypeSymbol> basesBeingResolved = null)
        {
            if (symbol.Kind == SymbolKind.Alias)
            {
                return ((AliasSymbol)symbol).GetAliasTarget(basesBeingResolved);
            }
            return symbol;
        }

        private NamespaceOrTypeOrAliasSymbolWithAnnotations UnwrapAlias(in NamespaceOrTypeOrAliasSymbolWithAnnotations symbol, BindingDiagnosticBag diagnostics, SyntaxNode syntax, ConsList<TypeSymbol> basesBeingResolved = null)
        {
            if (symbol.IsAlias)
            {
                return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(symbol.IsNullableEnabled, (NamespaceOrTypeSymbol)UnwrapAlias(symbol.Symbol, out AliasSymbol alias, diagnostics, syntax, basesBeingResolved));
            }
            return symbol;
        }

        private NamespaceOrTypeOrAliasSymbolWithAnnotations UnwrapAlias(in NamespaceOrTypeOrAliasSymbolWithAnnotations symbol, out AliasSymbol alias, BindingDiagnosticBag diagnostics, SyntaxNode syntax, ConsList<TypeSymbol> basesBeingResolved = null)
        {
            if (symbol.IsAlias)
            {
                return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(symbol.IsNullableEnabled, (NamespaceOrTypeSymbol)UnwrapAlias(symbol.Symbol, out alias, diagnostics, syntax, basesBeingResolved));
            }
            alias = null;
            return symbol;
        }

        private Symbol UnwrapAlias(Symbol symbol, BindingDiagnosticBag diagnostics, SyntaxNode syntax, ConsList<TypeSymbol> basesBeingResolved = null)
        {
            return UnwrapAlias(symbol, out AliasSymbol alias, diagnostics, syntax, basesBeingResolved);
        }

        private Symbol UnwrapAlias(Symbol symbol, out AliasSymbol alias, BindingDiagnosticBag diagnostics, SyntaxNode syntax, ConsList<TypeSymbol> basesBeingResolved = null)
        {
            if (symbol.Kind == SymbolKind.Alias)
            {
                alias = (AliasSymbol)symbol;
                NamespaceOrTypeSymbol aliasTarget = alias.GetAliasTarget(basesBeingResolved);
                if (aliasTarget is TypeSymbol type)
                {
                    TypeSymbolExtensions.VisitType(arg: (this, diagnostics, syntax), type: type, predicate: delegate (TypeSymbol typePart, (Binder, BindingDiagnosticBag diagnostics, SyntaxNode syntax) argTuple, bool isNested)
                    {
                        argTuple.Item1.ReportDiagnosticsIfObsolete(argTuple.diagnostics, typePart, argTuple.syntax, hasBaseReceiver: false);
                        return false;
                    });
                }
                return aliasTarget;
            }
            alias = null;
            return symbol;
        }

        private TypeWithAnnotations BindGenericSimpleNamespaceOrTypeOrAliasSymbol(GenericNameSyntax node, BindingDiagnosticBag diagnostics, ConsList<TypeSymbol> basesBeingResolved, NamespaceOrTypeSymbol qualifierOpt)
        {
            string valueText = node.Identifier.ValueText;
            SeparatedSyntaxList<TypeSyntax> arguments = node.TypeArgumentList.Arguments;
            bool isUnboundGenericName = node.IsUnboundGenericName;
            LookupOptions simpleNameLookupOptions = GetSimpleNameLookupOptions(node, isVerbatimIdentifier: false);
            NamedTypeSymbol namedTypeSymbol = LookupGenericTypeName(diagnostics, basesBeingResolved, qualifierOpt, node, valueText, node.Arity, simpleNameLookupOptions);
            NamedTypeSymbol namedTypeSymbol2;
            if (!isUnboundGenericName)
            {
                namedTypeSymbol2 = (((Flags & BinderFlags.SuppressTypeArgumentBinding) == 0) ? ConstructNamedType(namedTypeSymbol, node, arguments, BindTypeArguments(arguments, diagnostics, basesBeingResolved), basesBeingResolved, diagnostics) : namedTypeSymbol.Construct(PlaceholderTypeArgumentSymbol.CreateTypeArguments(namedTypeSymbol.TypeParameters)));
            }
            else if (!IsUnboundTypeAllowed(node))
            {
                if (!namedTypeSymbol.IsErrorType())
                {
                    diagnostics.Add(ErrorCode.ERR_UnexpectedUnboundGenericName, node.Location);
                }
                namedTypeSymbol2 = namedTypeSymbol.Construct(UnboundArgumentErrorTypeSymbol.CreateTypeArguments(namedTypeSymbol.TypeParameters, node.Arity, null), unbound: false);
            }
            else
            {
                namedTypeSymbol2 = namedTypeSymbol.AsUnboundGenericType();
            }
            if (simpleNameLookupOptions.IsAttributeTypeLookup())
            {
                namedTypeSymbol2 = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(namedTypeSymbol2), namedTypeSymbol2, LookupResultKind.NotAnAttributeType, null);
            }
            return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(node.TypeArgumentList.GreaterThanToken), namedTypeSymbol2);
        }

        private NamedTypeSymbol LookupGenericTypeName(BindingDiagnosticBag diagnostics, ConsList<TypeSymbol> basesBeingResolved, NamespaceOrTypeSymbol qualifierOpt, GenericNameSyntax node, string plainName, int arity, LookupOptions options)
        {
            ExtendedErrorTypeSymbol extendedErrorTypeSymbol = CreateErrorIfLookupOnTypeParameter(node.Parent, qualifierOpt, plainName, arity, diagnostics);
            if ((object)extendedErrorTypeSymbol != null)
            {
                return extendedErrorTypeSymbol;
            }
            LookupResult instance = LookupResult.GetInstance();
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            LookupSymbolsSimpleName(instance, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose: true, ref useSiteInfo);
            diagnostics.Add(node, useSiteInfo);
            Symbol symbol = ResultSymbol(instance, plainName, arity, node, diagnostics, basesBeingResolved != null, out bool wasError, qualifierOpt, options);
            NamedTypeSymbol namedTypeSymbol = symbol as NamedTypeSymbol;
            if ((object)namedTypeSymbol == null)
            {
                namedTypeSymbol = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbol), ImmutableArray.Create(symbol), instance.Kind, instance.Error, arity);
            }
            instance.Free();
            return namedTypeSymbol;
        }

        private ExtendedErrorTypeSymbol CreateErrorIfLookupOnTypeParameter(CSharpSyntaxNode node, NamespaceOrTypeSymbol qualifierOpt, string name, int arity, BindingDiagnosticBag diagnostics)
        {
            if ((object)qualifierOpt != null && qualifierOpt.Kind == SymbolKind.TypeParameter)
            {
                CSDiagnosticInfo cSDiagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_LookupInTypeVariable, qualifierOpt);
                diagnostics.Add(cSDiagnosticInfo, node.Location);
                return new ExtendedErrorTypeSymbol(Compilation, name, arity, cSDiagnosticInfo);
            }
            return null;
        }

        private ImmutableArray<TypeWithAnnotations> BindTypeArguments(SeparatedSyntaxList<TypeSyntax> typeArguments, BindingDiagnosticBag diagnostics, ConsList<TypeSymbol> basesBeingResolved = null)
        {
            ArrayBuilder<TypeWithAnnotations> instance = ArrayBuilder<TypeWithAnnotations>.GetInstance();
            SeparatedSyntaxList<TypeSyntax>.Enumerator enumerator = typeArguments.GetEnumerator();
            while (enumerator.MoveNext())
            {
                TypeSyntax current = enumerator.Current;
                instance.Add(BindTypeArgument(current, diagnostics, basesBeingResolved));
            }
            return instance.ToImmutableAndFree();
        }

        private TypeWithAnnotations BindTypeArgument(TypeSyntax typeArgument, BindingDiagnosticBag diagnostics, ConsList<TypeSymbol> basesBeingResolved = null)
        {
            Binder binder = WithAdditionalFlags(BinderFlags.SuppressUnsafeDiagnostics);
            if (typeArgument.Kind() != SyntaxKind.OmittedTypeArgument)
            {
                return binder.BindType(typeArgument, diagnostics, basesBeingResolved);
            }
            return TypeWithAnnotations.Create(UnboundArgumentErrorTypeSymbol.Instance);
        }

        private NamedTypeSymbol ConstructNamedTypeUnlessTypeArgumentOmitted(SyntaxNode typeSyntax, NamedTypeSymbol type, SeparatedSyntaxList<TypeSyntax> typeArgumentsSyntax, ImmutableArray<TypeWithAnnotations> typeArguments, BindingDiagnosticBag diagnostics)
        {
            if (typeArgumentsSyntax.Any(SyntaxKind.OmittedTypeArgument))
            {
                Error(diagnostics, ErrorCode.ERR_BadArity, typeSyntax, type, MessageID.IDS_SK_TYPE.Localize(), typeArgumentsSyntax.Count);
                return type;
            }
            return ConstructNamedType(type, typeSyntax, typeArgumentsSyntax, typeArguments, null, diagnostics);
        }

        private static BoundMethodOrPropertyGroup ConstructBoundMemberGroupAndReportOmittedTypeArguments(SyntaxNode syntax, SeparatedSyntaxList<TypeSyntax> typeArgumentsSyntax, ImmutableArray<TypeWithAnnotations> typeArguments, BoundExpression receiver, string plainName, ArrayBuilder<Symbol> members, LookupResult lookupResult, BoundMethodGroupFlags methodGroupFlags, bool hasErrors, BindingDiagnosticBag diagnostics)
        {
            if (!hasErrors && lookupResult.IsMultiViable && typeArgumentsSyntax.Any(SyntaxKind.OmittedTypeArgument))
            {
                Error(diagnostics, ErrorCode.ERR_BadArity, syntax, plainName, MessageID.IDS_MethodGroup.Localize(), typeArgumentsSyntax.Count);
                hasErrors = true;
            }
            return members[0].Kind switch
            {
                SymbolKind.Method => new BoundMethodGroup(syntax, typeArguments, receiver, plainName, members.SelectAsArray(s_toMethodSymbolFunc), lookupResult, methodGroupFlags, hasErrors),
                SymbolKind.Property => new BoundPropertyGroup(syntax, members.SelectAsArray(s_toPropertySymbolFunc), receiver, lookupResult.Kind, hasErrors),
                _ => throw ExceptionUtilities.UnexpectedValue(members[0].Kind),
            };
        }

        private NamedTypeSymbol ConstructNamedType(NamedTypeSymbol type, SyntaxNode typeSyntax, SeparatedSyntaxList<TypeSyntax> typeArgumentsSyntax, ImmutableArray<TypeWithAnnotations> typeArguments, ConsList<TypeSymbol> basesBeingResolved, BindingDiagnosticBag diagnostics)
        {
            type = type.Construct(typeArguments);
            if (ShouldCheckConstraints && ConstraintsHelper.RequiresChecking(type))
            {
                bool includeNullability = Compilation.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes);
                NamedTypeSymbol type2 = type;
                ConstraintsHelper.CheckConstraintsArgs args = new ConstraintsHelper.CheckConstraintsArgs(Compilation, Conversions, includeNullability, typeSyntax.Location, diagnostics);
                type2.CheckConstraintsForNamedType(in args, typeSyntax, typeArgumentsSyntax, basesBeingResolved);
            }
            return type;
        }

        private NamespaceOrTypeOrAliasSymbolWithAnnotations BindQualifiedName(ExpressionSyntax leftName, SimpleNameSyntax rightName, BindingDiagnosticBag diagnostics, ConsList<TypeSymbol> basesBeingResolved, bool suppressUseSiteDiagnostics)
        {
            NamespaceOrTypeSymbol namespaceOrTypeSymbol = BindNamespaceOrTypeSymbol(leftName, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics: false).NamespaceOrTypeSymbol;
            ReportDiagnosticsIfObsolete(diagnostics, namespaceOrTypeSymbol, leftName, hasBaseReceiver: false);
            int num;
            if (namespaceOrTypeSymbol.Kind == SymbolKind.NamedType)
            {
                num = (((NamedTypeSymbol)namespaceOrTypeSymbol).IsUnboundGenericType ? 1 : 0);
                if (num != 0)
                {
                    namespaceOrTypeSymbol = ((NamedTypeSymbol)namespaceOrTypeSymbol).OriginalDefinition;
                }
            }
            else
            {
                num = 0;
            }
            NamespaceOrTypeOrAliasSymbolWithAnnotations right = BindSimpleNamespaceOrTypeOrAliasSymbol(rightName, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics, namespaceOrTypeSymbol);
            if (num != 0)
            {
                return convertToUnboundGenericType();
            }
            return right;
            NamespaceOrTypeOrAliasSymbolWithAnnotations convertToUnboundGenericType()
            {
                if (right.Symbol is NamedTypeSymbol namedTypeSymbol && namedTypeSymbol.IsGenericType)
                {
                    TypeWithAnnotations typeWithAnnotations = right.TypeWithAnnotations;
                    return typeWithAnnotations.WithTypeAndModifiers(namedTypeSymbol.AsUnboundGenericType(), typeWithAnnotations.CustomModifiers);
                }
                return right;
            }
        }

        internal NamedTypeSymbol GetSpecialType(SpecialType typeId, BindingDiagnosticBag diagnostics, SyntaxNode node)
        {
            return GetSpecialType(Compilation, typeId, node, diagnostics);
        }

        internal static NamedTypeSymbol GetSpecialType(CSharpCompilation compilation, SpecialType typeId, SyntaxNode node, BindingDiagnosticBag diagnostics)
        {
            NamedTypeSymbol specialType = compilation.GetSpecialType(typeId);
            ReportUseSite(specialType, diagnostics, node);
            return specialType;
        }

        internal static NamedTypeSymbol GetSpecialType(CSharpCompilation compilation, SpecialType typeId, Location location, BindingDiagnosticBag diagnostics)
        {
            NamedTypeSymbol specialType = compilation.GetSpecialType(typeId);
            ReportUseSite(specialType, diagnostics, location);
            return specialType;
        }

        internal Symbol GetSpecialTypeMember(SpecialMember member, BindingDiagnosticBag diagnostics, SyntaxNode syntax)
        {
            if (!TryGetSpecialTypeMember<Symbol>(Compilation, member, syntax, diagnostics, out var symbol))
            {
                return null;
            }
            return symbol;
        }

        internal static bool TryGetSpecialTypeMember<TSymbol>(CSharpCompilation compilation, SpecialMember specialMember, SyntaxNode syntax, BindingDiagnosticBag diagnostics, out TSymbol symbol) where TSymbol : Symbol
        {
            symbol = (TSymbol)compilation.GetSpecialTypeMember(specialMember);
            if (symbol == null)
            {
                MemberDescriptor descriptor = SpecialMembers.GetDescriptor(specialMember);
                diagnostics.Add(ErrorCode.ERR_MissingPredefinedMember, syntax.Location, descriptor.DeclaringTypeMetadataName, descriptor.Name);
                return false;
            }
            UseSiteInfo<AssemblySymbol> useSiteInfoForWellKnownMemberOrContainingType = GetUseSiteInfoForWellKnownMemberOrContainingType(symbol);
            if (useSiteInfoForWellKnownMemberOrContainingType.DiagnosticInfo != null)
            {
                diagnostics.ReportUseSiteDiagnostic(useSiteInfoForWellKnownMemberOrContainingType.DiagnosticInfo, new SourceLocation(syntax));
            }
            return true;
        }

        private static UseSiteInfo<AssemblySymbol> GetUseSiteInfoForWellKnownMemberOrContainingType(Symbol symbol)
        {
            UseSiteInfo<AssemblySymbol> result = symbol.GetUseSiteInfo();
            symbol.MergeUseSiteInfo(ref result, symbol.ContainingType.GetUseSiteInfo());
            return result;
        }

        internal static bool ReportUseSite(Symbol symbol, BindingDiagnosticBag diagnostics, SyntaxNode node)
        {
            return diagnostics.ReportUseSite(symbol, node);
        }

        internal static bool ReportUseSite(Symbol symbol, BindingDiagnosticBag diagnostics, SyntaxToken token)
        {
            return diagnostics.ReportUseSite(symbol, token);
        }

        internal static bool ReportUseSite(Symbol symbol, BindingDiagnosticBag diagnostics, Location location)
        {
            return diagnostics.ReportUseSite(symbol, location);
        }

        internal NamedTypeSymbol GetWellKnownType(WellKnownType type, BindingDiagnosticBag diagnostics, SyntaxNode node)
        {
            return GetWellKnownType(type, diagnostics, node.Location);
        }

        internal NamedTypeSymbol GetWellKnownType(WellKnownType type, BindingDiagnosticBag diagnostics, Location location)
        {
            return GetWellKnownType(Compilation, type, diagnostics, location);
        }

        internal static NamedTypeSymbol GetWellKnownType(CSharpCompilation compilation, WellKnownType type, BindingDiagnosticBag diagnostics, SyntaxNode node)
        {
            return GetWellKnownType(compilation, type, diagnostics, node.Location);
        }

        internal static NamedTypeSymbol GetWellKnownType(CSharpCompilation compilation, WellKnownType type, BindingDiagnosticBag diagnostics, Location location)
        {
            NamedTypeSymbol wellKnownType = compilation.GetWellKnownType(type);
            ReportUseSite(wellKnownType, diagnostics, location);
            return wellKnownType;
        }

        internal NamedTypeSymbol GetWellKnownType(WellKnownType type, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            NamedTypeSymbol wellKnownType = Compilation.GetWellKnownType(type);
            wellKnownType.AddUseSiteInfo(ref useSiteInfo);
            return wellKnownType;
        }

        internal Symbol GetWellKnownTypeMember(WellKnownMember member, BindingDiagnosticBag diagnostics, Location location = null, SyntaxNode syntax = null, bool isOptional = false)
        {
            return GetWellKnownTypeMember(Compilation, member, diagnostics, location, syntax, isOptional);
        }

        internal static Symbol GetWellKnownTypeMember(CSharpCompilation compilation, WellKnownMember member, BindingDiagnosticBag diagnostics, Location location = null, SyntaxNode syntax = null, bool isOptional = false)
        {
            Symbol wellKnownTypeMember = GetWellKnownTypeMember(compilation, member, out UseSiteInfo<AssemblySymbol> useSiteInfo, isOptional);
            diagnostics.Add(useSiteInfo, location ?? syntax.Location);
            return wellKnownTypeMember;
        }

        internal static Symbol GetWellKnownTypeMember(CSharpCompilation compilation, WellKnownMember member, out UseSiteInfo<AssemblySymbol> useSiteInfo, bool isOptional = false)
        {
            Symbol wellKnownTypeMember = compilation.GetWellKnownTypeMember(member);
            if ((object)wellKnownTypeMember != null)
            {
                useSiteInfo = GetUseSiteInfoForWellKnownMemberOrContainingType(wellKnownTypeMember);
                if (useSiteInfo.DiagnosticInfo != null && isOptional)
                {
                    if (useSiteInfo.DiagnosticInfo!.Severity == DiagnosticSeverity.Error)
                    {
                        useSiteInfo = default(UseSiteInfo<AssemblySymbol>);
                        return null;
                    }
                    useSiteInfo = new UseSiteInfo<AssemblySymbol>(null, useSiteInfo.PrimaryDependency, useSiteInfo.SecondaryDependencies);
                }
            }
            else if (!isOptional)
            {
                MemberDescriptor descriptor = WellKnownMembers.GetDescriptor(member);
                useSiteInfo = new UseSiteInfo<AssemblySymbol>(new CSDiagnosticInfo(ErrorCode.ERR_MissingPredefinedMember, descriptor.DeclaringTypeMetadataName, descriptor.Name));
            }
            else
            {
                useSiteInfo = default(UseSiteInfo<AssemblySymbol>);
            }
            return wellKnownTypeMember;
        }

        internal Symbol ResultSymbol(LookupResult result, string simpleName, int arity, SyntaxNode where, BindingDiagnosticBag diagnostics, bool suppressUseSiteDiagnostics, out bool wasError, NamespaceOrTypeSymbol qualifierOpt, LookupOptions options = LookupOptions.Default)
        {
            Symbol symbol = resultSymbol(result, simpleName, arity, where, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options);
            if (symbol.Kind == SymbolKind.NamedType)
            {
                CheckRuntimeSupportForSymbolAccess(where, null, symbol, diagnostics);
                if (suppressUseSiteDiagnostics && diagnostics.DependenciesBag != null)
                {
                    AssemblySymbol containingAssembly = symbol.ContainingAssembly;
                    if ((object)containingAssembly != null && containingAssembly != Compilation.Assembly && containingAssembly != Compilation.Assembly.CorLibrary)
                    {
                        diagnostics.AddDependency(containingAssembly);
                    }
                }
            }
            return symbol;
            Symbol resultSymbol(LookupResult result, string simpleName, int arity, SyntaxNode where, BindingDiagnosticBag diagnostics, bool suppressUseSiteDiagnostics, out bool wasError, NamespaceOrTypeSymbol qualifierOpt, LookupOptions options)
            {
                ArrayBuilder<Symbol> symbols = result.Symbols;
                wasError = false;
                if (result.IsMultiViable)
                {
                    if (symbols.Count > 1)
                    {
                        symbols.Sort(ConsistentSymbolOrder.Instance);
                        ImmutableArray<Symbol> immutableArray = symbols.ToImmutable();
                        for (int i = 0; i < symbols.Count; i++)
                        {
                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);
                        }
                        BestSymbolInfo bestSymbolInfo = GetBestSymbolInfo(symbols, out BestSymbolInfo secondBest);
                        if (bestSymbolInfo.IsFromCompilation && !secondBest.IsFromCompilation)
                        {
                            Symbol symbol2 = symbols[bestSymbolInfo.Index];
                            Symbol symbol3 = symbols[secondBest.Index];
                            object obj = ((!bestSymbolInfo.IsFromSourceModule) ? symbol2.ContainingModule : ((object)symbol2.Locations.First().SourceTree!.FilePath));
                            if (NameAndArityMatchRecursively(symbol2, symbol3))
                            {
                                if (symbol2.Kind == SymbolKind.Namespace && symbol3.Kind == SymbolKind.NamedType)
                                {
                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, immutableArray, obj, symbol2, symbol3.ContainingAssembly, symbol3);
                                    return immutableArray[bestSymbolInfo.Index];
                                }
                                if (symbol2.Kind == SymbolKind.NamedType && symbol3.Kind == SymbolKind.Namespace)
                                {
                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, immutableArray, obj, symbol2, GetContainingAssembly(symbol3), symbol3);
                                    return immutableArray[bestSymbolInfo.Index];
                                }
                                if (symbol2.Kind == SymbolKind.NamedType && symbol3.Kind == SymbolKind.NamedType)
                                {
                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, immutableArray, obj, symbol2, symbol3.ContainingAssembly, symbol3);
                                    return immutableArray[bestSymbolInfo.Index];
                                }
                            }
                        }
                        Symbol symbol4 = symbols[bestSymbolInfo.Index];
                        Symbol symbol5 = symbols[secondBest.Index];
                        bool flag;
                        CSDiagnosticInfo cSDiagnosticInfo;
                        if (symbol4 != symbol5 && NameAndArityMatchRecursively(symbol4, symbol5))
                        {
                            flag = !bestSymbolInfo.IsFromSourceModule || !secondBest.IsFromSourceModule;
                            if (symbol4.Kind == SymbolKind.NamedType && symbol5.Kind == SymbolKind.NamedType)
                            {
                                if (symbol4.OriginalDefinition == symbol5.OriginalDefinition)
                                {
                                    flag = true;
                                    cSDiagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, immutableArray, new object[3]
                                    {
                                        (where as NameSyntax)?.ErrorDisplayName() ?? simpleName,
                                        new FormattedSymbol(symbol4, SymbolDisplayFormat.CSharpErrorMessageFormat),
                                        new FormattedSymbol(symbol5, SymbolDisplayFormat.CSharpErrorMessageFormat)
                                    });
                                }
                                else
                                {
                                    cSDiagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, immutableArray, new object[3] { symbol4.ContainingAssembly, symbol4, symbol5.ContainingAssembly });
                                    if (secondBest.IsFromAddedModule)
                                    {
                                        flag = false;
                                    }
                                    else if (Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) && secondBest.IsFromCorLibrary)
                                    {
                                        return symbol4;
                                    }
                                }
                            }
                            else if (symbol4.Kind == SymbolKind.Namespace && symbol5.Kind == SymbolKind.NamedType)
                            {
                                cSDiagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, immutableArray, new object[4]
                                {
                                    GetContainingAssembly(symbol4),
                                    symbol4,
                                    symbol5.ContainingAssembly,
                                    symbol5
                                });
                                if (bestSymbolInfo.IsFromSourceModule && secondBest.IsFromAddedModule)
                                {
                                    flag = false;
                                }
                            }
                            else if (symbol4.Kind == SymbolKind.NamedType && symbol5.Kind == SymbolKind.Namespace)
                            {
                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)
                                {
                                    cSDiagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, immutableArray, new object[4]
                                    {
                                        GetContainingAssembly(symbol5),
                                        symbol5,
                                        symbol4.ContainingAssembly,
                                        symbol4
                                    });
                                }
                                else
                                {
                                    object obj2 = ((!bestSymbolInfo.IsFromSourceModule) ? symbol4.ContainingModule : ((object)symbol4.Locations.First().SourceTree!.FilePath));
                                    ModuleSymbol moduleSymbol = symbol5.ContainingModule;
                                    if ((object)moduleSymbol == null)
                                    {
                                        ImmutableArray<NamespaceSymbol>.Enumerator enumerator = ((NamespaceSymbol)symbol5).ConstituentNamespaces.GetEnumerator();
                                        while (enumerator.MoveNext())
                                        {
                                            NamespaceSymbol current = enumerator.Current;
                                            if (current.ContainingAssembly == Compilation.Assembly)
                                            {
                                                ModuleSymbol containingModule = current.ContainingModule;
                                                if ((object)moduleSymbol == null || moduleSymbol.Ordinal > containingModule.Ordinal)
                                                {
                                                    moduleSymbol = containingModule;
                                                }
                                            }
                                        }
                                    }
                                    cSDiagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, immutableArray, new object[4] { obj2, symbol4, moduleSymbol, symbol5 });
                                }
                            }
                            else if (symbol4.Kind == SymbolKind.RangeVariable && symbol5.Kind == SymbolKind.RangeVariable)
                            {
                                cSDiagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, immutableArray, new object[2] { symbol4, symbol5 });
                            }
                            else
                            {
                                cSDiagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, immutableArray, new object[2] { symbol4, symbol5 });
                                flag = true;
                            }
                        }
                        else
                        {
                            flag = true;
                            cSDiagnosticInfo = ((!(symbol4 is NamespaceOrTypeSymbol) || !(symbol5 is NamespaceOrTypeSymbol)) ? new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, immutableArray, new object[2] { symbol4, symbol5 }) : ((!options.IsAttributeTypeLookup() || symbol4.Kind != SymbolKind.NamedType || symbol5.Kind != SymbolKind.NamedType || !(immutableArray[bestSymbolInfo.Index].Name != immutableArray[secondBest.Index].Name) || !Compilation.IsAttributeType((NamedTypeSymbol)symbol4) || !Compilation.IsAttributeType((NamedTypeSymbol)symbol5)) ? new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, immutableArray, new object[3]
                            {
                                (where as NameSyntax)?.ErrorDisplayName() ?? simpleName,
                                new FormattedSymbol(symbol4, SymbolDisplayFormat.CSharpErrorMessageFormat),
                                new FormattedSymbol(symbol5, SymbolDisplayFormat.CSharpErrorMessageFormat)
                            }) : new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, immutableArray, new object[3]
                            {
                                (where as NameSyntax)?.ErrorDisplayName() ?? simpleName,
                                symbol4,
                                symbol5
                            })));
                        }
                        wasError = true;
                        if (flag)
                        {
                            diagnostics.Add(cSDiagnosticInfo, where.Location);
                        }
                        return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(immutableArray[0]), immutableArray, LookupResultKind.Ambiguous, cSDiagnosticInfo, arity);
                    }
                    Symbol symbol6 = symbols[0];
                    if (symbol6 is TypeSymbol typeSymbol && typeSymbol.PrimitiveTypeCode == PrimitiveTypeCode.Void && simpleName == "Void")
                    {
                        wasError = true;
                        CSDiagnosticInfo cSDiagnosticInfo2 = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);
                        diagnostics.Add(cSDiagnosticInfo2, where.Location);
                        symbol6 = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbol6), symbol6, LookupResultKind.NotReferencable, cSDiagnosticInfo2);
                    }
                    else
                    {
                        if (symbol6.Kind == SymbolKind.NamedType && ((SourceModuleSymbol)Compilation.SourceModule).AnyReferencedAssembliesAreLinked && diagnostics.DiagnosticBag != null)
                        {
                            EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)symbol6, where, diagnostics.DiagnosticBag);
                        }
                        if (!suppressUseSiteDiagnostics)
                        {
                            wasError = ReportUseSite(symbol6, diagnostics, where);
                        }
                        else if (symbol6.Kind == SymbolKind.ErrorType)
                        {
                            ErrorTypeSymbol errorTypeSymbol = (ErrorTypeSymbol)symbol6;
                            if (errorTypeSymbol.Unreported)
                            {
                                DiagnosticInfo errorInfo = errorTypeSymbol.ErrorInfo;
                                if (errorInfo != null && errorInfo.Code == 146)
                                {
                                    wasError = true;
                                    diagnostics.Add(errorInfo, where.Location);
                                    symbol6 = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorTypeSymbol), errorTypeSymbol.Name, errorTypeSymbol.Arity, errorInfo);
                                }
                            }
                        }
                    }
                    return symbol6;
                }
                wasError = true;
                if (result.Kind == LookupResultKind.Empty)
                {
                    string aliasOpt = null;
                    SyntaxNode syntaxNode = where;
                    while (syntaxNode is ExpressionSyntax)
                    {
                        if (syntaxNode.Kind() == SyntaxKind.AliasQualifiedName)
                        {
                            aliasOpt = ((AliasQualifiedNameSyntax)syntaxNode).Alias.Identifier.ValueText;
                            break;
                        }
                        syntaxNode = syntaxNode.Parent;
                    }
                    CSDiagnosticInfo errorInfo2 = NotFound(where, simpleName, arity, (where as NameSyntax)?.ErrorDisplayName() ?? simpleName, diagnostics, aliasOpt, qualifierOpt, options);
                    return new ExtendedErrorTypeSymbol(qualifierOpt ?? Compilation.Assembly.GlobalNamespace, simpleName, arity, errorInfo2);
                }
                if (!suppressUseSiteDiagnostics)
                {
                    for (int j = 0; j < symbols.Count; j++)
                    {
                        ReportUseSite(symbols[j], diagnostics, where);
                    }
                }
                if (result.Error != null && ((object)qualifierOpt == null || qualifierOpt.Kind != SymbolKind.ErrorType))
                {
                    diagnostics.Add(new CSDiagnostic(result.Error, where.Location));
                }
                if (symbols.Count > 1 || symbols[0] is NamespaceOrTypeSymbol || symbols[0] is AliasSymbol || result.Kind == LookupResultKind.NotATypeOrNamespace || result.Kind == LookupResultKind.NotAnAttributeType)
                {
                    return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0]), symbols.ToImmutable(), result.Kind, result.Error, arity);
                }
                return symbols[0];
            }
        }

        private static AssemblySymbol GetContainingAssembly(Symbol symbol)
        {
            return symbol.ContainingAssembly ?? ((NamespaceSymbol)symbol).ConstituentNamespaces.First().ContainingAssembly;
        }

        private BestSymbolInfo GetBestSymbolInfo(ArrayBuilder<Symbol> symbols, out BestSymbolInfo secondBest)
        {
            BestSymbolInfo first = default(BestSymbolInfo);
            BestSymbolInfo first2 = default(BestSymbolInfo);
            CSharpCompilation compilation = Compilation;
            for (int i = 0; i < symbols.Count; i++)
            {
                Symbol symbol = symbols[i];
                BestSymbolLocation bestSymbolLocation;
                if (symbol.Kind == SymbolKind.Namespace)
                {
                    bestSymbolLocation = BestSymbolLocation.None;
                    ImmutableArray<NamespaceSymbol>.Enumerator enumerator = ((NamespaceSymbol)symbol).ConstituentNamespaces.GetEnumerator();
                    while (enumerator.MoveNext())
                    {
                        NamespaceSymbol current = enumerator.Current;
                        BestSymbolLocation location = GetLocation(compilation, current);
                        if (BestSymbolInfo.IsSecondLocationBetter(bestSymbolLocation, location))
                        {
                            bestSymbolLocation = location;
                            if (bestSymbolLocation == BestSymbolLocation.FromSourceModule)
                            {
                                break;
                            }
                        }
                    }
                }
                else
                {
                    bestSymbolLocation = GetLocation(compilation, symbol);
                }
                BestSymbolInfo second = new BestSymbolInfo(bestSymbolLocation, i);
                if (BestSymbolInfo.Sort(ref first2, ref second))
                {
                    BestSymbolInfo.Sort(ref first, ref first2);
                }
            }
            secondBest = first2;
            return first;
        }

        private static BestSymbolLocation GetLocation(CSharpCompilation compilation, Symbol symbol)
        {
            AssemblySymbol containingAssembly = symbol.ContainingAssembly;
            if (containingAssembly == compilation.SourceAssembly)
            {
                if (!(symbol.ContainingModule == compilation.SourceModule))
                {
                    return BestSymbolLocation.FromAddedModule;
                }
                return BestSymbolLocation.FromSourceModule;
            }
            if (!(containingAssembly == containingAssembly.CorLibrary))
            {
                return BestSymbolLocation.FromReferencedAssembly;
            }
            return BestSymbolLocation.FromCorLibrary;
        }

        private CSDiagnosticInfo NotFound(SyntaxNode where, string simpleName, int arity, string whereText, BindingDiagnosticBag diagnostics, string aliasOpt, NamespaceOrTypeSymbol qualifierOpt, LookupOptions options)
        {
            Location location = where.Location;
            if (options.IsAttributeTypeLookup() && !options.IsVerbatimNameAttributeTypeLookup())
            {
                NotFound(where, simpleName, arity, whereText + "Attribute", diagnostics, aliasOpt, qualifierOpt, options | LookupOptions.VerbatimNameAttributeTypeOnly);
            }
            AssemblySymbol forwardedToAssembly;
            if ((object)qualifierOpt != null)
            {
                if (qualifierOpt.IsType)
                {
                    if (qualifierOpt is ErrorTypeSymbol errorTypeSymbol && errorTypeSymbol.ErrorInfo != null)
                    {
                        return (CSDiagnosticInfo)errorTypeSymbol.ErrorInfo;
                    }
                    return diagnostics.Add(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, location, whereText, qualifierOpt);
                }
                forwardedToAssembly = GetForwardedToAssembly(simpleName, arity, ref qualifierOpt, diagnostics, location);
                if ((object)qualifierOpt == Compilation.GlobalNamespace)
                {
                    if ((object)forwardedToAssembly != null)
                    {
                        return diagnostics.Add(ErrorCode.ERR_GlobalSingleTypeNameNotFoundFwd, location, whereText, forwardedToAssembly);
                    }
                    return diagnostics.Add(ErrorCode.ERR_GlobalSingleTypeNameNotFound, location, whereText, qualifierOpt);
                }
                object obj = qualifierOpt;
                if (aliasOpt != null && qualifierOpt.IsNamespace && ((NamespaceSymbol)qualifierOpt).IsGlobalNamespace)
                {
                    obj = aliasOpt;
                }
                if ((object)forwardedToAssembly != null)
                {
                    return diagnostics.Add(ErrorCode.ERR_DottedTypeNameNotFoundInNSFwd, location, whereText, obj, forwardedToAssembly);
                }
                return diagnostics.Add(ErrorCode.ERR_DottedTypeNameNotFoundInNS, location, whereText, obj);
            }
            if (options == LookupOptions.NamespaceAliasesOnly)
            {
                return diagnostics.Add(ErrorCode.ERR_AliasNotFound, location, whereText);
            }
            if ((where as IdentifierNameSyntax)?.Identifier.Text == "var" && !options.IsAttributeTypeLookup())
            {
                ErrorCode code = ((where.Parent is QueryClauseSyntax) ? ErrorCode.ERR_TypeVarNotFoundRangeVariable : ErrorCode.ERR_TypeVarNotFound);
                return diagnostics.Add(code, location);
            }
            forwardedToAssembly = GetForwardedToAssembly(simpleName, arity, ref qualifierOpt, diagnostics, location);
            if ((object)forwardedToAssembly != null)
            {
                if (!(qualifierOpt == null))
                {
                    return diagnostics.Add(ErrorCode.ERR_DottedTypeNameNotFoundInNSFwd, location, whereText, qualifierOpt, forwardedToAssembly);
                }
                return diagnostics.Add(ErrorCode.ERR_SingleTypeNameNotFoundFwd, location, whereText, forwardedToAssembly);
            }
            return diagnostics.Add(ErrorCode.ERR_SingleTypeNameNotFound, location, whereText);
        }

        protected virtual AssemblySymbol GetForwardedToAssemblyInUsingNamespaces(string metadataName, ref NamespaceOrTypeSymbol qualifierOpt, BindingDiagnosticBag diagnostics, Location location)
        {
            return Next?.GetForwardedToAssemblyInUsingNamespaces(metadataName, ref qualifierOpt, diagnostics, location);
        }

        protected AssemblySymbol GetForwardedToAssembly(string fullName, BindingDiagnosticBag diagnostics, Location location)
        {
            MetadataTypeName emittedName = MetadataTypeName.FromFullName(fullName);
            ImmutableArray<AssemblySymbol>.Enumerator enumerator = Compilation.Assembly.Modules[0].GetReferencedAssemblySymbols().GetEnumerator();
            while (enumerator.MoveNext())
            {
                NamedTypeSymbol namedTypeSymbol = enumerator.Current.TryLookupForwardedMetadataType(ref emittedName);
                if ((object)namedTypeSymbol == null)
                {
                    continue;
                }
                if (namedTypeSymbol.Kind == SymbolKind.ErrorType)
                {
                    DiagnosticInfo errorInfo = ((ErrorTypeSymbol)namedTypeSymbol).ErrorInfo;
                    if (errorInfo.Code == 731)
                    {
                        diagnostics.Add(ErrorCode.ERR_CycleInTypeForwarder, location, fullName, namedTypeSymbol.ContainingAssembly.Name);
                    }
                    else if (errorInfo.Code == 8206)
                    {
                        diagnostics.Add(errorInfo, location);
                        return null;
                    }
                }
                return namedTypeSymbol.ContainingAssembly;
            }
            return null;
        }

        protected AssemblySymbol GetForwardedToAssembly(string name, int arity, ref NamespaceOrTypeSymbol qualifierOpt, BindingDiagnosticBag diagnostics, Location location)
        {
            if ((Flags & BinderFlags.InContextualAttributeBinder) != 0)
            {
                Binder binder = this;
                do
                {
                    if (binder is ContextualAttributeBinder contextualAttributeBinder)
                    {
                        if ((object)contextualAttributeBinder.AttributeTarget == null || contextualAttributeBinder.AttributeTarget.Kind != SymbolKind.Assembly)
                        {
                            break;
                        }
                        return null;
                    }
                    binder = binder.Next;
                }
                while (binder != null);
            }
            string text = MetadataHelpers.ComposeAritySuffixedMetadataName(name, arity);
            string fullName = MetadataHelpers.BuildQualifiedName(qualifierOpt?.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat), text);
            AssemblySymbol forwardedToAssembly = GetForwardedToAssembly(fullName, diagnostics, location);
            if ((object)forwardedToAssembly != null)
            {
                return forwardedToAssembly;
            }
            if ((object)qualifierOpt == null)
            {
                return GetForwardedToAssemblyInUsingNamespaces(text, ref qualifierOpt, diagnostics, location);
            }
            return null;
        }

        internal static bool CheckFeatureAvailability(SyntaxNode syntax, MessageID feature, BindingDiagnosticBag diagnostics, Location? location = null)
        {
            return CheckFeatureAvailability(syntax, feature, diagnostics.DiagnosticBag, location);
        }

        internal static bool CheckFeatureAvailability(SyntaxNode syntax, MessageID feature, DiagnosticBag? diagnostics, Location? location = null)
        {
            return CheckFeatureAvailability(syntax.SyntaxTree, feature, diagnostics, location ?? syntax.GetLocation());
        }

        internal static bool CheckFeatureAvailability(SyntaxTree tree, MessageID feature, BindingDiagnosticBag diagnostics, Location location)
        {
            return CheckFeatureAvailability(tree, feature, diagnostics.DiagnosticBag, location);
        }

        internal static bool CheckFeatureAvailability(SyntaxTree tree, MessageID feature, DiagnosticBag? diagnostics, Location location)
        {
            CSDiagnosticInfo featureAvailabilityDiagnosticInfo = feature.GetFeatureAvailabilityDiagnosticInfo((CSharpParseOptions)tree.Options);
            if (featureAvailabilityDiagnosticInfo != null)
            {
                diagnostics?.Add(featureAvailabilityDiagnosticInfo, location);
                return false;
            }
            return true;
        }

        private BoundTupleBinaryOperator BindTupleBinaryOperator(BinaryExpressionSyntax node, BinaryOperatorKind kind, BoundExpression left, BoundExpression right, BindingDiagnosticBag diagnostics)
        {
            TupleBinaryOperatorInfo.Multiple multiple = BindTupleBinaryOperatorNestedInfo(node, kind, left, right, diagnostics);
            BoundExpression left2 = ApplyConvertedTypes(left, multiple, isRight: false, diagnostics);
            BoundExpression right2 = ApplyConvertedTypes(right, multiple, isRight: true, diagnostics);
            TypeSymbol specialType = GetSpecialType(SpecialType.System_Boolean, diagnostics, node);
            return new BoundTupleBinaryOperator(node, left2, right2, kind, multiple, specialType);
        }

        private BoundExpression ApplyConvertedTypes(BoundExpression expr, TupleBinaryOperatorInfo @operator, bool isRight, BindingDiagnosticBag diagnostics)
        {
            TypeSymbol typeSymbol = (isRight ? @operator.RightConvertedTypeOpt : @operator.LeftConvertedTypeOpt);
            if ((object)typeSymbol == null)
            {
                if (@operator.InfoKind == TupleBinaryOperatorInfoKind.Multiple && expr is BoundTupleLiteral boundTupleLiteral)
                {
                    TupleBinaryOperatorInfo.Multiple multiple = (TupleBinaryOperatorInfo.Multiple)@operator;
                    if (multiple.Operators.Length == 0)
                    {
                        return BindToNaturalType(expr, diagnostics, reportNoTargetType: false);
                    }
                    ImmutableArray<BoundExpression> arguments = boundTupleLiteral.Arguments;
                    int length = arguments.Length;
                    ArrayBuilder<BoundExpression> instance = ArrayBuilder<BoundExpression>.GetInstance(length);
                    for (int i = 0; i < length; i++)
                    {
                        instance.Add(ApplyConvertedTypes(arguments[i], multiple.Operators[i], isRight, diagnostics));
                    }
                    return new BoundConvertedTupleLiteral(boundTupleLiteral.Syntax, boundTupleLiteral, wasTargetTyped: false, instance.ToImmutableAndFree(), boundTupleLiteral.ArgumentNamesOpt, boundTupleLiteral.InferredNamesOpt, boundTupleLiteral.Type, boundTupleLiteral.HasErrors);
                }
                return BindToNaturalType(expr, diagnostics, reportNoTargetType: false);
            }
            return GenerateConversionForAssignment(typeSymbol, expr, diagnostics);
        }

        private TupleBinaryOperatorInfo BindTupleBinaryOperatorInfo(BinaryExpressionSyntax node, BinaryOperatorKind kind, BoundExpression left, BoundExpression right, BindingDiagnosticBag diagnostics)
        {
            TypeSymbol type = left.Type;
            TypeSymbol type2 = right.Type;
            if (((object)type != null && type.IsDynamic()) || ((object)type2 != null && type2.IsDynamic()))
            {
                return BindTupleDynamicBinaryOperatorSingleInfo(node, kind, left, right, diagnostics);
            }
            if (IsTupleBinaryOperation(left, right))
            {
                return BindTupleBinaryOperatorNestedInfo(node, kind, left, right, diagnostics);
            }
            BoundExpression boundExpression = BindSimpleBinaryOperator(node, diagnostics, left, right);
            if (!(boundExpression is BoundLiteral))
            {
                if (boundExpression is BoundBinaryOperator boundBinaryOperator)
                {
                    PrepareBoolConversionAndTruthOperator(boundBinaryOperator.Type, node, kind, diagnostics, out var conversionForBool, out var boolOperator);
                    return new TupleBinaryOperatorInfo.Single(boundBinaryOperator.Left.Type, boundBinaryOperator.Right.Type, boundBinaryOperator.OperatorKind, boundBinaryOperator.MethodOpt, conversionForBool, boolOperator);
                }
                throw ExceptionUtilities.UnexpectedValue(boundExpression);
            }
            return new TupleBinaryOperatorInfo.NullNull(kind);
        }

        private void PrepareBoolConversionAndTruthOperator(TypeSymbol type, BinaryExpressionSyntax node, BinaryOperatorKind binaryOperator, BindingDiagnosticBag diagnostics, out Conversion conversionForBool, out UnaryOperatorSignature boolOperator)
        {
            CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
            TypeSymbol specialType = GetSpecialType(SpecialType.System_Boolean, diagnostics, node);
            Conversion conversion = Conversions.ClassifyImplicitConversionFromType(type, specialType, ref useSiteInfo);
            diagnostics.Add(node, useSiteInfo);
            if (conversion.IsImplicit)
            {
                ReportDiagnosticsIfObsolete(diagnostics, conversion, node, hasBaseReceiver: false);
                conversionForBool = conversion;
                boolOperator = default(UnaryOperatorSignature);
                return;
            }
            UnaryOperatorKind kind = binaryOperator switch
            {
                BinaryOperatorKind.Equal => UnaryOperatorKind.False,
                BinaryOperatorKind.NotEqual => UnaryOperatorKind.True,
                _ => throw ExceptionUtilities.UnexpectedValue(binaryOperator),
            };
            BoundExpression operand = new BoundTupleOperandPlaceholder(node, type);
            UnaryOperatorAnalysisResult unaryOperatorAnalysisResult = UnaryOperatorOverloadResolution(kind, operand, node, diagnostics, out LookupResultKind resultKind, out ImmutableArray<MethodSymbol> originalUserDefinedOperators);
            if (unaryOperatorAnalysisResult.HasValue)
            {
                conversionForBool = unaryOperatorAnalysisResult.Conversion;
                boolOperator = unaryOperatorAnalysisResult.Signature;
            }
            else
            {
                GenerateImplicitConversionError(diagnostics, node, conversion, operand, specialType);
                conversionForBool = Conversion.NoConversion;
                boolOperator = default(UnaryOperatorSignature);
            }
        }

        private TupleBinaryOperatorInfo BindTupleDynamicBinaryOperatorSingleInfo(BinaryExpressionSyntax node, BinaryOperatorKind kind, BoundExpression left, BoundExpression right, BindingDiagnosticBag diagnostics)
        {
            bool flag = false;
            if (!IsLegalDynamicOperand(left) || !IsLegalDynamicOperand(right))
            {
                Error(diagnostics, ErrorCode.ERR_BadBinaryOps, node, node.OperatorToken.Text, left.Display, right.Display);
                flag = true;
            }
            BinaryOperatorKind kind2 = (flag ? kind : kind.WithType(BinaryOperatorKind.Dynamic));
            TypeSymbol obj = (flag ? CreateErrorType() : Compilation.DynamicType);
            return new TupleBinaryOperatorInfo.Single(obj, obj, kind2, null, Conversion.Identity, default(UnaryOperatorSignature));
        }

        private TupleBinaryOperatorInfo.Multiple BindTupleBinaryOperatorNestedInfo(BinaryExpressionSyntax node, BinaryOperatorKind kind, BoundExpression left, BoundExpression right, BindingDiagnosticBag diagnostics)
        {
            left = GiveTupleTypeToDefaultLiteralIfNeeded(left, right.Type);
            right = GiveTupleTypeToDefaultLiteralIfNeeded(right, left.Type);
            if (left.IsLiteralDefaultOrImplicitObjectCreation() || right.IsLiteralDefaultOrImplicitObjectCreation())
            {
                ReportBinaryOperatorError(node, diagnostics, node.OperatorToken, left, right, LookupResultKind.Ambiguous);
                return TupleBinaryOperatorInfo.Multiple.ErrorInstance;
            }
            int tupleCardinality = GetTupleCardinality(left);
            int tupleCardinality2 = GetTupleCardinality(right);
            if (tupleCardinality != tupleCardinality2)
            {
                Error(diagnostics, ErrorCode.ERR_TupleSizesMismatchForBinOps, node, tupleCardinality, tupleCardinality2);
                return TupleBinaryOperatorInfo.Multiple.ErrorInstance;
            }
            var (elements, immutableArray) = GetTupleArgumentsOrPlaceholders(left);
            var (elements2, immutableArray2) = GetTupleArgumentsOrPlaceholders(right);
            ReportNamesMismatchesIfAny(left, right, immutableArray, immutableArray2, diagnostics);
            int length = elements.Length;
            ArrayBuilder<TupleBinaryOperatorInfo> instance = ArrayBuilder<TupleBinaryOperatorInfo>.GetInstance(length);
            for (int i = 0; i < length; i++)
            {
                instance.Add(BindTupleBinaryOperatorInfo(node, kind, elements[i], elements2[i], diagnostics));
            }
            CSharpCompilation compilation = Compilation;
            ImmutableArray<TupleBinaryOperatorInfo> immutableArray3 = instance.ToImmutableAndFree();
            bool num = left.Type?.IsNullableType() ?? false;
            bool flag = right.Type?.IsNullableType() ?? false;
            bool isNullable = num || flag;
            TypeSymbol leftConvertedTypeOpt = MakeConvertedType(immutableArray3.SelectAsArray((TupleBinaryOperatorInfo o) => o.LeftConvertedTypeOpt), node.Left, elements, immutableArray, isNullable, compilation, diagnostics);
            TypeSymbol rightConvertedTypeOpt = MakeConvertedType(immutableArray3.SelectAsArray((TupleBinaryOperatorInfo o) => o.RightConvertedTypeOpt), node.Right, elements2, immutableArray2, isNullable, compilation, diagnostics);
            return new TupleBinaryOperatorInfo.Multiple(immutableArray3, leftConvertedTypeOpt, rightConvertedTypeOpt);
        }

        private static void ReportNamesMismatchesIfAny(BoundExpression left, BoundExpression right, ImmutableArray<string> leftNames, ImmutableArray<string> rightNames, BindingDiagnosticBag diagnostics)
        {
            bool flag = left is BoundTupleExpression;
            bool flag2 = right is BoundTupleExpression;
            if (!flag && !flag2)
            {
                return;
            }
            bool isDefault = leftNames.IsDefault;
            bool isDefault2 = rightNames.IsDefault;
            if (isDefault && isDefault2)
            {
                return;
            }
            ImmutableArray<bool> immutableArray = (flag ? ((BoundTupleExpression)left).InferredNamesOpt : default(ImmutableArray<bool>));
            bool isDefault3 = immutableArray.IsDefault;
            ImmutableArray<bool> immutableArray2 = (flag2 ? ((BoundTupleExpression)right).InferredNamesOpt : default(ImmutableArray<bool>));
            bool isDefault4 = immutableArray2.IsDefault;
            int num = (isDefault ? rightNames.Length : leftNames.Length);
            for (int i = 0; i < num; i++)
            {
                string text = (isDefault ? null : leftNames[i]);
                string text2 = (isDefault2 ? null : rightNames[i]);
                if (string.CompareOrdinal(text2, text) != 0)
                {
                    bool flag3 = !isDefault3 && immutableArray[i];
                    bool flag4 = !isDefault4 && immutableArray2[i];
                    bool flag5 = flag && text != null && !flag3;
                    bool flag6 = flag2 && text2 != null && !flag4;
                    if (flag5 || flag6)
                    {
                        bool num2 = ((flag5 && flag6) ? flag2 : flag6);
                        Location location = ((BoundTupleExpression)(num2 ? right : left)).Arguments[i].Syntax.Parent!.Location;
                        string text3 = (num2 ? text2 : text);
                        diagnostics.Add(ErrorCode.WRN_TupleBinopLiteralNameMismatch, location, text3);
                    }
                }
            }
        }

        internal static BoundExpression GiveTupleTypeToDefaultLiteralIfNeeded(BoundExpression expr, TypeSymbol targetType)
        {
            if (!expr.IsLiteralDefault() || (object)targetType == null)
            {
                return expr;
            }
            return new BoundDefaultExpression(expr.Syntax, targetType);
        }

        private static bool IsTupleBinaryOperation(BoundExpression left, BoundExpression right)
        {
            bool flag = left.IsLiteralDefaultOrImplicitObjectCreation();
            bool flag2 = right.IsLiteralDefaultOrImplicitObjectCreation();
            if (flag && flag2)
            {
                return false;
            }
            if (GetTupleCardinality(left) > 1 || flag)
            {
                return GetTupleCardinality(right) > 1 || flag2;
            }
            return false;
        }

        private static int GetTupleCardinality(BoundExpression expr)
        {
            if (expr is BoundTupleExpression boundTupleExpression)
            {
                return boundTupleExpression.Arguments.Length;
            }
            TypeSymbol type = expr.Type;
            if ((object)type == null)
            {
                return -1;
            }
            TypeSymbol typeSymbol = type.StrippedType();
            if ((object)typeSymbol != null && typeSymbol.IsTupleType)
            {
                return typeSymbol.TupleElementTypesWithAnnotations.Length;
            }
            return -1;
        }

        private static (ImmutableArray<BoundExpression> Elements, ImmutableArray<string> Names) GetTupleArgumentsOrPlaceholders(BoundExpression expr)
        {
            if (expr is BoundTupleExpression boundTupleExpression)
            {
                return (boundTupleExpression.Arguments, boundTupleExpression.ArgumentNamesOpt);
            }
            TypeSymbol typeSymbol = expr.Type.StrippedType();
            return (typeSymbol.TupleElementTypesWithAnnotations.SelectAsArray((Func<TypeWithAnnotations, SyntaxNode, BoundExpression>)((TypeWithAnnotations t, SyntaxNode s) => new BoundTupleOperandPlaceholder(s, t.Type)), expr.Syntax), typeSymbol.TupleElementNames);
        }

        private TypeSymbol MakeConvertedType(ImmutableArray<TypeSymbol> convertedTypes, CSharpSyntaxNode syntax, ImmutableArray<BoundExpression> elements, ImmutableArray<string> names, bool isNullable, CSharpCompilation compilation, BindingDiagnosticBag diagnostics)
        {
            ImmutableArray<TypeSymbol>.Enumerator enumerator = convertedTypes.GetEnumerator();
            while (enumerator.MoveNext())
            {
                if ((object)enumerator.Current == null)
                {
                    return null;
                }
            }
            ImmutableArray<Location> elementLocations = elements.SelectAsArray((BoundExpression e) => e.Syntax.Location);
            NamedTypeSymbol namedTypeSymbol = NamedTypeSymbol.CreateTuple(null, convertedTypes.SelectAsArray((TypeSymbol t) => TypeWithAnnotations.Create(t)), elementLocations, names, compilation, shouldCheckConstraints: true, includeNullability: false, default(ImmutableArray<bool>), syntax, diagnostics);
            if (!isNullable)
            {
                return namedTypeSymbol;
            }
            return GetSpecialType(SpecialType.System_Nullable_T, diagnostics, syntax).Construct(namedTypeSymbol);
        }

        internal bool ReportUnsafeIfNotAllowed(SyntaxNode node, BindingDiagnosticBag diagnostics, TypeSymbol sizeOfTypeOpt = null)
        {
            CSDiagnosticInfo unsafeDiagnosticInfo = GetUnsafeDiagnosticInfo(sizeOfTypeOpt);
            if (unsafeDiagnosticInfo == null)
            {
                return false;
            }
            diagnostics.Add(new CSDiagnostic(unsafeDiagnosticInfo, node.Location));
            return true;
        }

        internal bool ReportUnsafeIfNotAllowed(Location location, BindingDiagnosticBag diagnostics)
        {
            CSDiagnosticInfo unsafeDiagnosticInfo = GetUnsafeDiagnosticInfo(null);
            if (unsafeDiagnosticInfo == null)
            {
                return false;
            }
            diagnostics.Add(new CSDiagnostic(unsafeDiagnosticInfo, location));
            return true;
        }

        private CSDiagnosticInfo GetUnsafeDiagnosticInfo(TypeSymbol sizeOfTypeOpt)
        {
            if (Flags.Includes(BinderFlags.SuppressUnsafeDiagnostics))
            {
                return null;
            }
            if (IsIndirectlyInIterator)
            {
                return new CSDiagnosticInfo(ErrorCode.ERR_IllegalInnerUnsafe);
            }
            if (!InUnsafeRegion)
            {
                if ((object)sizeOfTypeOpt != null)
                {
                    return new CSDiagnosticInfo(ErrorCode.ERR_SizeofUnsafe, sizeOfTypeOpt);
                }
                return new CSDiagnosticInfo(ErrorCode.ERR_UnsafeNeeded);
            }
            return null;
        }

        private BoundExpression BindWithExpression(WithExpressionSyntax syntax, BindingDiagnosticBag diagnostics)
        {
            BoundExpression boundExpression = BindRValueWithoutTargetType(syntax.Expression, diagnostics);
            TypeSymbol typeSymbol = boundExpression.Type;
            LookupResult.GetInstance();
            bool hasErrors = false;
            if ((object)typeSymbol == null || typeSymbol.IsVoidType())
            {
                diagnostics.Add(ErrorCode.ERR_InvalidWithReceiverType, syntax.Expression.Location);
                typeSymbol = CreateErrorType();
            }
            MethodSymbol methodSymbol = null;
            if (typeSymbol.IsValueType)
            {
                CheckFeatureAvailability(syntax, MessageID.IDS_FeatureWithOnStructs, diagnostics);
            }
            else if (!typeSymbol.IsErrorType())
            {
                CompoundUseSiteInfo<AssemblySymbol> useSiteInfo = GetNewCompoundUseSiteInfo(diagnostics);
                methodSymbol = SynthesizedRecordClone.FindValidCloneMethod((typeSymbol is TypeParameterSymbol typeParameterSymbol) ? typeParameterSymbol.EffectiveBaseClass(ref useSiteInfo) : typeSymbol, ref useSiteInfo);
                if ((object)methodSymbol == null)
                {
                    hasErrors = true;
                    diagnostics.Add(ErrorCode.ERR_CannotClone, syntax.Expression.Location, typeSymbol);
                }
                else
                {
                    methodSymbol.AddUseSiteInfo(ref useSiteInfo);
                }
                diagnostics.Add(syntax.Expression, useSiteInfo);
            }
            BoundObjectInitializerExpressionBase initializerExpression = BindInitializerExpression(syntax.Initializer, typeSymbol, syntax.Expression, isForNewInstance: true, diagnostics);
            return new BoundWithExpression(syntax, boundExpression, methodSymbol, initializerExpression, typeSymbol, hasErrors);
        }

        internal ImmutableArray<Symbol> BindXmlNameAttribute(XmlNameAttributeSyntax syntax, ref CompoundUseSiteInfo<AssemblySymbol> useSiteInfo)
        {
            IdentifierNameSyntax identifier = syntax.Identifier;
            if (identifier.IsMissing)
            {
                return ImmutableArray<Symbol>.Empty;
            }
            string valueText = identifier.Identifier.ValueText;
            LookupResult instance = LookupResult.GetInstance();
            LookupSymbolsWithFallback(instance, valueText, 0, ref useSiteInfo);
            if (instance.Kind == LookupResultKind.Empty)
            {
                instance.Free();
                return ImmutableArray<Symbol>.Empty;
            }
            ImmutableArray<Symbol> result = instance.Symbols.ToImmutable();
            instance.Free();
            return result;
        }
    }
}
