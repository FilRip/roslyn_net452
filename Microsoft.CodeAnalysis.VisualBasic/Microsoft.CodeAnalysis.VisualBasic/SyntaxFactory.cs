using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.ComponentModel;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System.Xml.Linq;
using Microsoft.CodeAnalysis.Syntax;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis.VisualBasic.ObjectDisplay;
using Microsoft.CodeAnalysis.VisualBasic.Syntax;
using Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax;
using Microsoft.VisualBasic.CompilerServices;
using Roslyn.Utilities;

namespace Microsoft.CodeAnalysis.VisualBasic
{
	public class SyntaxFactory
	{
		private static readonly SyntaxTriviaList s_elasticMarkerList = TriviaList((SyntaxTrivia)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ElasticZeroSpace);

		public static SyntaxTrivia CarriageReturnLineFeed { get; } = (SyntaxTrivia)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CarriageReturnLineFeed;


		public static SyntaxTrivia LineFeed { get; } = (SyntaxTrivia)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.LineFeed;


		public static SyntaxTrivia CarriageReturn { get; } = (SyntaxTrivia)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CarriageReturn;


		public static SyntaxTrivia Space { get; } = (SyntaxTrivia)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.Space;


		public static SyntaxTrivia Tab { get; } = (SyntaxTrivia)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.Tab;


		public static SyntaxTrivia ElasticCarriageReturnLineFeed { get; } = (SyntaxTrivia)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturnLineFeed;


		public static SyntaxTrivia ElasticLineFeed { get; } = (SyntaxTrivia)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ElasticLineFeed;


		public static SyntaxTrivia ElasticCarriageReturn { get; } = (SyntaxTrivia)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturn;


		public static SyntaxTrivia ElasticSpace { get; } = (SyntaxTrivia)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ElasticSpace;


		public static SyntaxTrivia ElasticTab { get; } = (SyntaxTrivia)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ElasticTab;


		public static SyntaxTrivia ElasticMarker { get; } = (SyntaxTrivia)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.ElasticZeroSpace;


		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EmptyStatementSyntax EmptyStatement(SyntaxToken empty)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(empty);
			if (syntaxKind != SyntaxKind.EmptyToken)
			{
				throw new ArgumentException("empty");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EmptyStatementSyntax(SyntaxKind.EmptyStatement, null, null, (PunctuationSyntax)empty.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EmptyStatementSyntax EmptyStatement()
		{
			return EmptyStatement(Token(SyntaxKind.EmptyToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndIfStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			switch (VisualBasicExtensions.Kind(blockKeyword))
			{
			default:
				throw new ArgumentException("blockKeyword");
			case SyntaxKind.AddHandlerKeyword:
			case SyntaxKind.ClassKeyword:
			case SyntaxKind.EnumKeyword:
			case SyntaxKind.EventKeyword:
			case SyntaxKind.FunctionKeyword:
			case SyntaxKind.GetKeyword:
			case SyntaxKind.IfKeyword:
			case SyntaxKind.InterfaceKeyword:
			case SyntaxKind.ModuleKeyword:
			case SyntaxKind.NamespaceKeyword:
			case SyntaxKind.OperatorKeyword:
			case SyntaxKind.PropertyKeyword:
			case SyntaxKind.RaiseEventKeyword:
			case SyntaxKind.RemoveHandlerKeyword:
			case SyntaxKind.SelectKeyword:
			case SyntaxKind.SetKeyword:
			case SyntaxKind.StructureKeyword:
			case SyntaxKind.SubKeyword:
			case SyntaxKind.SyncLockKeyword:
			case SyntaxKind.TryKeyword:
			case SyntaxKind.UsingKeyword:
			case SyntaxKind.WhileKeyword:
			case SyntaxKind.WithKeyword:
				return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndIfStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
			}
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndIfStatement()
		{
			return EndIfStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.IfKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndUsingStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.UsingKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndUsingStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndUsingStatement()
		{
			return EndUsingStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.UsingKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndWithStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.WithKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndWithStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndWithStatement()
		{
			return EndWithStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.WithKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndSelectStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.SelectKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndSelectStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndSelectStatement()
		{
			return EndSelectStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.SelectKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndStructureStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.StructureKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndStructureStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndStructureStatement()
		{
			return EndStructureStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.StructureKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndEnumStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.EnumKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndEnumStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndEnumStatement()
		{
			return EndEnumStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.EnumKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndInterfaceStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.InterfaceKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndInterfaceStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndInterfaceStatement()
		{
			return EndInterfaceStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.InterfaceKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndClassStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.ClassKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndClassStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndClassStatement()
		{
			return EndClassStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.ClassKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndModuleStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.ModuleKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndModuleStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndModuleStatement()
		{
			return EndModuleStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.ModuleKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndNamespaceStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.NamespaceKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndNamespaceStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndNamespaceStatement()
		{
			return EndNamespaceStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.NamespaceKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndSubStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.SubKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndSubStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndSubStatement()
		{
			return EndSubStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.SubKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndFunctionStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.FunctionKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndFunctionStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndFunctionStatement()
		{
			return EndFunctionStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.FunctionKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndGetStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.GetKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndGetStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndGetStatement()
		{
			return EndGetStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.GetKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndSetStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.SetKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndSetStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndSetStatement()
		{
			return EndSetStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.SetKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndPropertyStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.PropertyKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndPropertyStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndPropertyStatement()
		{
			return EndPropertyStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.PropertyKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndOperatorStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.OperatorKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndOperatorStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndOperatorStatement()
		{
			return EndOperatorStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.OperatorKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndEventStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.EventKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndEventStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndEventStatement()
		{
			return EndEventStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.EventKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndAddHandlerStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.AddHandlerKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndAddHandlerStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndAddHandlerStatement()
		{
			return EndAddHandlerStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.AddHandlerKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndRemoveHandlerStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.RemoveHandlerKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndRemoveHandlerStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndRemoveHandlerStatement()
		{
			return EndRemoveHandlerStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.RemoveHandlerKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndRaiseEventStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.RaiseEventKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndRaiseEventStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndRaiseEventStatement()
		{
			return EndRaiseEventStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.RaiseEventKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndWhileStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.WhileKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndWhileStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndWhileStatement()
		{
			return EndWhileStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.WhileKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndTryStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.TryKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndTryStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndTryStatement()
		{
			return EndTryStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.TryKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndSyncLockStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.SyncLockKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(SyntaxKind.EndSyncLockStatement, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndSyncLockStatement()
		{
			return EndSyncLockStatement(Token(SyntaxKind.EndKeyword), Token(SyntaxKind.SyncLockKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndBlockStatement(SyntaxKind kind, SyntaxToken endKeyword, SyntaxToken blockKeyword)
		{
			if (!SyntaxFacts.IsEndBlockStatement(kind))
			{
				throw new ArgumentException("kind");
			}
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(blockKeyword, GetEndBlockStatementBlockKeywordKind(kind)))
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(kind, null, null, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		private static SyntaxKind GetEndBlockStatementBlockKeywordKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.EndIfStatement => SyntaxKind.IfKeyword, 
				SyntaxKind.EndUsingStatement => SyntaxKind.UsingKeyword, 
				SyntaxKind.EndWithStatement => SyntaxKind.WithKeyword, 
				SyntaxKind.EndSelectStatement => SyntaxKind.SelectKeyword, 
				SyntaxKind.EndStructureStatement => SyntaxKind.StructureKeyword, 
				SyntaxKind.EndEnumStatement => SyntaxKind.EnumKeyword, 
				SyntaxKind.EndInterfaceStatement => SyntaxKind.InterfaceKeyword, 
				SyntaxKind.EndClassStatement => SyntaxKind.ClassKeyword, 
				SyntaxKind.EndModuleStatement => SyntaxKind.ModuleKeyword, 
				SyntaxKind.EndNamespaceStatement => SyntaxKind.NamespaceKeyword, 
				SyntaxKind.EndSubStatement => SyntaxKind.SubKeyword, 
				SyntaxKind.EndFunctionStatement => SyntaxKind.FunctionKeyword, 
				SyntaxKind.EndGetStatement => SyntaxKind.GetKeyword, 
				SyntaxKind.EndSetStatement => SyntaxKind.SetKeyword, 
				SyntaxKind.EndPropertyStatement => SyntaxKind.PropertyKeyword, 
				SyntaxKind.EndOperatorStatement => SyntaxKind.OperatorKeyword, 
				SyntaxKind.EndEventStatement => SyntaxKind.EventKeyword, 
				SyntaxKind.EndAddHandlerStatement => SyntaxKind.AddHandlerKeyword, 
				SyntaxKind.EndRemoveHandlerStatement => SyntaxKind.RemoveHandlerKeyword, 
				SyntaxKind.EndRaiseEventStatement => SyntaxKind.RaiseEventKeyword, 
				SyntaxKind.EndWhileStatement => SyntaxKind.WhileKeyword, 
				SyntaxKind.EndTryStatement => SyntaxKind.TryKeyword, 
				SyntaxKind.EndSyncLockStatement => SyntaxKind.SyncLockKeyword, 
				_ => throw new ArgumentException("BlockKeyword"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax EndBlockStatement(SyntaxKind kind, SyntaxToken blockKeyword)
		{
			return EndBlockStatement(kind, Token(SyntaxKind.EndKeyword), blockKeyword);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax CompilationUnit(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.OptionStatementSyntax> options, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsStatementSyntax> imports, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributesStatementSyntax> attributes, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> members, SyntaxToken endOfFileToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(endOfFileToken);
			if (syntaxKind != SyntaxKind.EndOfFileToken)
			{
				throw new ArgumentException("endOfFileToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax(SyntaxKind.CompilationUnit, null, null, options.Node, imports.Node, attributes.Node, members.Node, (PunctuationSyntax)endOfFileToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax CompilationUnit(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.OptionStatementSyntax> options, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsStatementSyntax> imports, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributesStatementSyntax> attributes, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> members)
		{
			return CompilationUnit(options, imports, attributes, members, Token(SyntaxKind.EndOfFileToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax CompilationUnit()
		{
			return CompilationUnit(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.OptionStatementSyntax>), default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsStatementSyntax>), default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributesStatementSyntax>), default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), Token(SyntaxKind.EndOfFileToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OptionStatementSyntax OptionStatement(SyntaxToken optionKeyword, SyntaxToken nameKeyword, SyntaxToken valueKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(optionKeyword);
			if (syntaxKind != SyntaxKind.OptionKeyword)
			{
				throw new ArgumentException("optionKeyword");
			}
			switch (VisualBasicExtensions.Kind(nameKeyword))
			{
			default:
				throw new ArgumentException("nameKeyword");
			case SyntaxKind.CompareKeyword:
			case SyntaxKind.ExplicitKeyword:
			case SyntaxKind.InferKeyword:
			case SyntaxKind.StrictKeyword:
				return new Microsoft.CodeAnalysis.VisualBasic.Syntax.OptionStatementSyntax(SyntaxKind.OptionStatement, null, null, (KeywordSyntax)optionKeyword.Node, (KeywordSyntax)nameKeyword.Node, (KeywordSyntax)valueKeyword.Node);
			}
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OptionStatementSyntax OptionStatement(SyntaxToken nameKeyword, SyntaxToken valueKeyword)
		{
			return OptionStatement(Token(SyntaxKind.OptionKeyword), nameKeyword, valueKeyword);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OptionStatementSyntax OptionStatement(SyntaxToken nameKeyword)
		{
			return OptionStatement(Token(SyntaxKind.OptionKeyword), nameKeyword, default(SyntaxToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsStatementSyntax ImportsStatement(SyntaxToken importsKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsClauseSyntax> importsClauses)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(importsKeyword);
			if (syntaxKind != SyntaxKind.ImportsKeyword)
			{
				throw new ArgumentException("importsKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsStatementSyntax(SyntaxKind.ImportsStatement, null, null, (KeywordSyntax)importsKeyword.Node, importsClauses.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsStatementSyntax ImportsStatement(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsClauseSyntax> importsClauses)
		{
			return ImportsStatement(Token(SyntaxKind.ImportsKeyword), importsClauses);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsStatementSyntax ImportsStatement()
		{
			return ImportsStatement(Token(SyntaxKind.ImportsKeyword), default(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsClauseSyntax>));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax SimpleImportsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportAliasClauseSyntax alias, Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax name)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			SyntaxKind syntaxKind = name.Kind();
			if (syntaxKind - 399 > (SyntaxKind)3 && syntaxKind - 409 > SyntaxKind.List)
			{
				throw new ArgumentException("name");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax(SyntaxKind.SimpleImportsClause, null, null, alias, name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax SimpleImportsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax name)
		{
			return SimpleImportsClause(null, name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportAliasClauseSyntax ImportAliasClause(SyntaxToken identifier, SyntaxToken equalsToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(equalsToken);
			if (syntaxKind2 != SyntaxKind.EqualsToken)
			{
				throw new ArgumentException("equalsToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportAliasClauseSyntax(SyntaxKind.ImportAliasClause, null, null, (IdentifierTokenSyntax)identifier.Node, (PunctuationSyntax)equalsToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportAliasClauseSyntax ImportAliasClause(SyntaxToken identifier)
		{
			return ImportAliasClause(identifier, Token(SyntaxKind.EqualsToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportAliasClauseSyntax ImportAliasClause(string identifier)
		{
			return ImportAliasClause(Identifier(identifier), Token(SyntaxKind.EqualsToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNamespaceImportsClauseSyntax XmlNamespaceImportsClause(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax xmlNamespace, SyntaxToken greaterThanToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(lessThanToken);
			if (syntaxKind != SyntaxKind.LessThanToken)
			{
				throw new ArgumentException("lessThanToken");
			}
			if (xmlNamespace == null)
			{
				throw new ArgumentNullException("xmlNamespace");
			}
			SyntaxKind syntaxKind2 = xmlNamespace.Kind();
			if (syntaxKind2 != SyntaxKind.XmlAttribute)
			{
				throw new ArgumentException("xmlNamespace");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(greaterThanToken);
			if (syntaxKind3 != SyntaxKind.GreaterThanToken)
			{
				throw new ArgumentException("greaterThanToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNamespaceImportsClauseSyntax(SyntaxKind.XmlNamespaceImportsClause, null, null, (PunctuationSyntax)lessThanToken.Node, xmlNamespace, (PunctuationSyntax)greaterThanToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNamespaceImportsClauseSyntax XmlNamespaceImportsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax xmlNamespace)
		{
			return XmlNamespaceImportsClause(Token(SyntaxKind.LessThanToken), xmlNamespace, Token(SyntaxKind.GreaterThanToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax NamespaceBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax namespaceStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> members, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endNamespaceStatement)
		{
			if (namespaceStatement == null)
			{
				throw new ArgumentNullException("namespaceStatement");
			}
			SyntaxKind syntaxKind = namespaceStatement.Kind();
			if (syntaxKind != SyntaxKind.NamespaceStatement)
			{
				throw new ArgumentException("namespaceStatement");
			}
			if (endNamespaceStatement == null)
			{
				throw new ArgumentNullException("endNamespaceStatement");
			}
			SyntaxKind syntaxKind2 = endNamespaceStatement.Kind();
			if (syntaxKind2 != SyntaxKind.EndNamespaceStatement)
			{
				throw new ArgumentException("endNamespaceStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax(SyntaxKind.NamespaceBlock, null, null, namespaceStatement, members.Node, endNamespaceStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax NamespaceBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax namespaceStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> members)
		{
			return NamespaceBlock(namespaceStatement, members, EndNamespaceStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax NamespaceBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax namespaceStatement)
		{
			return NamespaceBlock(namespaceStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), EndNamespaceStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax NamespaceStatement(SyntaxToken namespaceKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax name)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(namespaceKeyword);
			if (syntaxKind != SyntaxKind.NamespaceKeyword)
			{
				throw new ArgumentException("namespaceKeyword");
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			SyntaxKind syntaxKind2 = name.Kind();
			if (syntaxKind2 - 399 > (SyntaxKind)3 && syntaxKind2 - 409 > SyntaxKind.List)
			{
				throw new ArgumentException("name");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax(SyntaxKind.NamespaceStatement, null, null, (KeywordSyntax)namespaceKeyword.Node, name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax NamespaceStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax name)
		{
			return NamespaceStatement(Token(SyntaxKind.NamespaceKeyword), name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleBlockSyntax ModuleBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax moduleStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax> inherits, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax> implements, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> members, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endModuleStatement)
		{
			if (moduleStatement == null)
			{
				throw new ArgumentNullException("moduleStatement");
			}
			SyntaxKind syntaxKind = moduleStatement.Kind();
			if (syntaxKind != SyntaxKind.ModuleStatement)
			{
				throw new ArgumentException("moduleStatement");
			}
			if (endModuleStatement == null)
			{
				throw new ArgumentNullException("endModuleStatement");
			}
			SyntaxKind syntaxKind2 = endModuleStatement.Kind();
			if (syntaxKind2 != SyntaxKind.EndModuleStatement)
			{
				throw new ArgumentException("endModuleStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleBlockSyntax(SyntaxKind.ModuleBlock, null, null, moduleStatement, inherits.Node, implements.Node, members.Node, endModuleStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleBlockSyntax ModuleBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax moduleStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax> inherits, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax> implements, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> members)
		{
			return ModuleBlock(moduleStatement, inherits, implements, members, EndModuleStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleBlockSyntax ModuleBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax moduleStatement)
		{
			return ModuleBlock(moduleStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax>), default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax>), default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), EndModuleStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureBlockSyntax StructureBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax structureStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax> inherits, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax> implements, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> members, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endStructureStatement)
		{
			if (structureStatement == null)
			{
				throw new ArgumentNullException("structureStatement");
			}
			SyntaxKind syntaxKind = structureStatement.Kind();
			if (syntaxKind != SyntaxKind.StructureStatement)
			{
				throw new ArgumentException("structureStatement");
			}
			if (endStructureStatement == null)
			{
				throw new ArgumentNullException("endStructureStatement");
			}
			SyntaxKind syntaxKind2 = endStructureStatement.Kind();
			if (syntaxKind2 != SyntaxKind.EndStructureStatement)
			{
				throw new ArgumentException("endStructureStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureBlockSyntax(SyntaxKind.StructureBlock, null, null, structureStatement, inherits.Node, implements.Node, members.Node, endStructureStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureBlockSyntax StructureBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax structureStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax> inherits, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax> implements, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> members)
		{
			return StructureBlock(structureStatement, inherits, implements, members, EndStructureStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureBlockSyntax StructureBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax structureStatement)
		{
			return StructureBlock(structureStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax>), default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax>), default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), EndStructureStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceBlockSyntax InterfaceBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax interfaceStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax> inherits, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax> implements, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> members, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endInterfaceStatement)
		{
			if (interfaceStatement == null)
			{
				throw new ArgumentNullException("interfaceStatement");
			}
			SyntaxKind syntaxKind = interfaceStatement.Kind();
			if (syntaxKind != SyntaxKind.InterfaceStatement)
			{
				throw new ArgumentException("interfaceStatement");
			}
			if (endInterfaceStatement == null)
			{
				throw new ArgumentNullException("endInterfaceStatement");
			}
			SyntaxKind syntaxKind2 = endInterfaceStatement.Kind();
			if (syntaxKind2 != SyntaxKind.EndInterfaceStatement)
			{
				throw new ArgumentException("endInterfaceStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceBlockSyntax(SyntaxKind.InterfaceBlock, null, null, interfaceStatement, inherits.Node, implements.Node, members.Node, endInterfaceStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceBlockSyntax InterfaceBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax interfaceStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax> inherits, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax> implements, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> members)
		{
			return InterfaceBlock(interfaceStatement, inherits, implements, members, EndInterfaceStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceBlockSyntax InterfaceBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax interfaceStatement)
		{
			return InterfaceBlock(interfaceStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax>), default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax>), default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), EndInterfaceStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassBlockSyntax ClassBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax classStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax> inherits, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax> implements, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> members, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endClassStatement)
		{
			if (classStatement == null)
			{
				throw new ArgumentNullException("classStatement");
			}
			SyntaxKind syntaxKind = classStatement.Kind();
			if (syntaxKind != SyntaxKind.ClassStatement)
			{
				throw new ArgumentException("classStatement");
			}
			if (endClassStatement == null)
			{
				throw new ArgumentNullException("endClassStatement");
			}
			SyntaxKind syntaxKind2 = endClassStatement.Kind();
			if (syntaxKind2 != SyntaxKind.EndClassStatement)
			{
				throw new ArgumentException("endClassStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassBlockSyntax(SyntaxKind.ClassBlock, null, null, classStatement, inherits.Node, implements.Node, members.Node, endClassStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassBlockSyntax ClassBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax classStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax> inherits, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax> implements, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> members)
		{
			return ClassBlock(classStatement, inherits, implements, members, EndClassStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassBlockSyntax ClassBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax classStatement)
		{
			return ClassBlock(classStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax>), default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax>), default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), EndClassStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax EnumBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax enumStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> members, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endEnumStatement)
		{
			if (enumStatement == null)
			{
				throw new ArgumentNullException("enumStatement");
			}
			SyntaxKind syntaxKind = enumStatement.Kind();
			if (syntaxKind != SyntaxKind.EnumStatement)
			{
				throw new ArgumentException("enumStatement");
			}
			if (endEnumStatement == null)
			{
				throw new ArgumentNullException("endEnumStatement");
			}
			SyntaxKind syntaxKind2 = endEnumStatement.Kind();
			if (syntaxKind2 != SyntaxKind.EndEnumStatement)
			{
				throw new ArgumentException("endEnumStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax(SyntaxKind.EnumBlock, null, null, enumStatement, members.Node, endEnumStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax EnumBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax enumStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> members)
		{
			return EnumBlock(enumStatement, members, EndEnumStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax EnumBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax enumStatement)
		{
			return EnumBlock(enumStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), EndEnumStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax InheritsStatement(SyntaxToken inheritsKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax> types)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(inheritsKeyword);
			if (syntaxKind != SyntaxKind.InheritsKeyword)
			{
				throw new ArgumentException("inheritsKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax(SyntaxKind.InheritsStatement, null, null, (KeywordSyntax)inheritsKeyword.Node, types.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax InheritsStatement(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax> types)
		{
			return InheritsStatement(Token(SyntaxKind.InheritsKeyword), types);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax InheritsStatement(params Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax[] types)
		{
			return InheritsStatement(Token(SyntaxKind.InheritsKeyword), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax>().AddRange(types));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax ImplementsStatement(SyntaxToken implementsKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax> types)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(implementsKeyword);
			if (syntaxKind != SyntaxKind.ImplementsKeyword)
			{
				throw new ArgumentException("implementsKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax(SyntaxKind.ImplementsStatement, null, null, (KeywordSyntax)implementsKeyword.Node, types.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax ImplementsStatement(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax> types)
		{
			return ImplementsStatement(Token(SyntaxKind.ImplementsKeyword), types);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax ImplementsStatement(params Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax[] types)
		{
			return ImplementsStatement(Token(SyntaxKind.ImplementsKeyword), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax>().AddRange(types));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax ModuleStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken moduleKeyword, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax typeParameterList)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(moduleKeyword);
			if (syntaxKind != SyntaxKind.ModuleKeyword)
			{
				throw new ArgumentException("moduleKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind2 != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax(SyntaxKind.ModuleStatement, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)moduleKeyword.Node, (IdentifierTokenSyntax)identifier.Node, typeParameterList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax ModuleStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax typeParameterList)
		{
			return ModuleStatement(attributeLists, modifiers, Token(SyntaxKind.ModuleKeyword), identifier, typeParameterList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax ModuleStatement(SyntaxToken identifier)
		{
			return ModuleStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.ModuleKeyword), identifier, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax ModuleStatement(string identifier)
		{
			return ModuleStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.ModuleKeyword), Identifier(identifier), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax StructureStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken structureKeyword, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax typeParameterList)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(structureKeyword);
			if (syntaxKind != SyntaxKind.StructureKeyword)
			{
				throw new ArgumentException("structureKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind2 != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax(SyntaxKind.StructureStatement, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)structureKeyword.Node, (IdentifierTokenSyntax)identifier.Node, typeParameterList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax StructureStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax typeParameterList)
		{
			return StructureStatement(attributeLists, modifiers, Token(SyntaxKind.StructureKeyword), identifier, typeParameterList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax StructureStatement(SyntaxToken identifier)
		{
			return StructureStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.StructureKeyword), identifier, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax StructureStatement(string identifier)
		{
			return StructureStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.StructureKeyword), Identifier(identifier), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax InterfaceStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken interfaceKeyword, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax typeParameterList)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(interfaceKeyword);
			if (syntaxKind != SyntaxKind.InterfaceKeyword)
			{
				throw new ArgumentException("interfaceKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind2 != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax(SyntaxKind.InterfaceStatement, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)interfaceKeyword.Node, (IdentifierTokenSyntax)identifier.Node, typeParameterList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax InterfaceStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax typeParameterList)
		{
			return InterfaceStatement(attributeLists, modifiers, Token(SyntaxKind.InterfaceKeyword), identifier, typeParameterList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax InterfaceStatement(SyntaxToken identifier)
		{
			return InterfaceStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.InterfaceKeyword), identifier, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax InterfaceStatement(string identifier)
		{
			return InterfaceStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.InterfaceKeyword), Identifier(identifier), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax ClassStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken classKeyword, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax typeParameterList)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(classKeyword);
			if (syntaxKind != SyntaxKind.ClassKeyword)
			{
				throw new ArgumentException("classKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind2 != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax(SyntaxKind.ClassStatement, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)classKeyword.Node, (IdentifierTokenSyntax)identifier.Node, typeParameterList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax ClassStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax typeParameterList)
		{
			return ClassStatement(attributeLists, modifiers, Token(SyntaxKind.ClassKeyword), identifier, typeParameterList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax ClassStatement(SyntaxToken identifier)
		{
			return ClassStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.ClassKeyword), identifier, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax ClassStatement(string identifier)
		{
			return ClassStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.ClassKeyword), Identifier(identifier), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax EnumStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax underlyingType)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(enumKeyword);
			if (syntaxKind != SyntaxKind.EnumKeyword)
			{
				throw new ArgumentException("enumKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind2 != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax(SyntaxKind.EnumStatement, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)enumKeyword.Node, (IdentifierTokenSyntax)identifier.Node, underlyingType);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax EnumStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax underlyingType)
		{
			return EnumStatement(attributeLists, modifiers, Token(SyntaxKind.EnumKeyword), identifier, underlyingType);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax EnumStatement(SyntaxToken identifier)
		{
			return EnumStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.EnumKeyword), identifier, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax EnumStatement(string identifier)
		{
			return EnumStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.EnumKeyword), Identifier(identifier), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax TypeParameterList(SyntaxToken openParenToken, SyntaxToken ofKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax> parameters, SyntaxToken closeParenToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(openParenToken);
			if (syntaxKind != SyntaxKind.OpenParenToken)
			{
				throw new ArgumentException("openParenToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(ofKeyword);
			if (syntaxKind2 != SyntaxKind.OfKeyword)
			{
				throw new ArgumentException("ofKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(closeParenToken);
			if (syntaxKind3 != SyntaxKind.CloseParenToken)
			{
				throw new ArgumentException("closeParenToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax(SyntaxKind.TypeParameterList, null, null, (PunctuationSyntax)openParenToken.Node, (KeywordSyntax)ofKeyword.Node, parameters.Node, (PunctuationSyntax)closeParenToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax TypeParameterList(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax> parameters)
		{
			return TypeParameterList(Token(SyntaxKind.OpenParenToken), Token(SyntaxKind.OfKeyword), parameters, Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax TypeParameterList(params Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax[] parameters)
		{
			return TypeParameterList(Token(SyntaxKind.OpenParenToken), Token(SyntaxKind.OfKeyword), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax>().AddRange(parameters), Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax TypeParameter(SyntaxToken varianceKeyword, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterConstraintClauseSyntax typeParameterConstraintClause)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax(SyntaxKind.TypeParameter, null, null, (KeywordSyntax)varianceKeyword.Node, (IdentifierTokenSyntax)identifier.Node, typeParameterConstraintClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax TypeParameter(SyntaxToken identifier)
		{
			return TypeParameter(default(SyntaxToken), identifier, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax TypeParameter(string identifier)
		{
			return TypeParameter(default(SyntaxToken), Identifier(identifier), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSingleConstraintClauseSyntax TypeParameterSingleConstraintClause(SyntaxToken asKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax constraint)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(asKeyword);
			if (syntaxKind != SyntaxKind.AsKeyword)
			{
				throw new ArgumentException("asKeyword");
			}
			if (constraint == null)
			{
				throw new ArgumentNullException("constraint");
			}
			SyntaxKind syntaxKind2 = constraint.Kind();
			if (syntaxKind2 - 72 > (SyntaxKind)3)
			{
				throw new ArgumentException("constraint");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSingleConstraintClauseSyntax(SyntaxKind.TypeParameterSingleConstraintClause, null, null, (KeywordSyntax)asKeyword.Node, constraint);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSingleConstraintClauseSyntax TypeParameterSingleConstraintClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax constraint)
		{
			return TypeParameterSingleConstraintClause(Token(SyntaxKind.AsKeyword), constraint);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterMultipleConstraintClauseSyntax TypeParameterMultipleConstraintClause(SyntaxToken asKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax> constraints, SyntaxToken closeBraceToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(asKeyword);
			if (syntaxKind != SyntaxKind.AsKeyword)
			{
				throw new ArgumentException("asKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(openBraceToken);
			if (syntaxKind2 != SyntaxKind.OpenBraceToken)
			{
				throw new ArgumentException("openBraceToken");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(closeBraceToken);
			if (syntaxKind3 != SyntaxKind.CloseBraceToken)
			{
				throw new ArgumentException("closeBraceToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterMultipleConstraintClauseSyntax(SyntaxKind.TypeParameterMultipleConstraintClause, null, null, (KeywordSyntax)asKeyword.Node, (PunctuationSyntax)openBraceToken.Node, constraints.Node, (PunctuationSyntax)closeBraceToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterMultipleConstraintClauseSyntax TypeParameterMultipleConstraintClause(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax> constraints)
		{
			return TypeParameterMultipleConstraintClause(Token(SyntaxKind.AsKeyword), Token(SyntaxKind.OpenBraceToken), constraints, Token(SyntaxKind.CloseBraceToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterMultipleConstraintClauseSyntax TypeParameterMultipleConstraintClause(params Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax[] constraints)
		{
			return TypeParameterMultipleConstraintClause(Token(SyntaxKind.AsKeyword), Token(SyntaxKind.OpenBraceToken), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax>().AddRange(constraints), Token(SyntaxKind.CloseBraceToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SpecialConstraintSyntax NewConstraint(SyntaxToken constraintKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(constraintKeyword);
			if (syntaxKind != SyntaxKind.ClassKeyword && syntaxKind != SyntaxKind.NewKeyword && syntaxKind != SyntaxKind.StructureKeyword)
			{
				throw new ArgumentException("constraintKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SpecialConstraintSyntax(SyntaxKind.NewConstraint, null, null, (KeywordSyntax)constraintKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SpecialConstraintSyntax ClassConstraint(SyntaxToken constraintKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(constraintKeyword);
			if (syntaxKind != SyntaxKind.ClassKeyword && syntaxKind != SyntaxKind.NewKeyword && syntaxKind != SyntaxKind.StructureKeyword)
			{
				throw new ArgumentException("constraintKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SpecialConstraintSyntax(SyntaxKind.ClassConstraint, null, null, (KeywordSyntax)constraintKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SpecialConstraintSyntax StructureConstraint(SyntaxToken constraintKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(constraintKeyword);
			if (syntaxKind != SyntaxKind.ClassKeyword && syntaxKind != SyntaxKind.NewKeyword && syntaxKind != SyntaxKind.StructureKeyword)
			{
				throw new ArgumentException("constraintKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SpecialConstraintSyntax(SyntaxKind.StructureConstraint, null, null, (KeywordSyntax)constraintKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SpecialConstraintSyntax SpecialConstraint(SyntaxKind kind, SyntaxToken constraintKeyword)
		{
			if (!SyntaxFacts.IsSpecialConstraint(kind))
			{
				throw new ArgumentException("kind");
			}
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(constraintKeyword);
			if (syntaxKind != SyntaxKind.ClassKeyword && syntaxKind != SyntaxKind.NewKeyword && syntaxKind != SyntaxKind.StructureKeyword)
			{
				throw new ArgumentException("constraintKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SpecialConstraintSyntax(kind, null, null, (KeywordSyntax)constraintKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeConstraintSyntax TypeConstraint(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			SyntaxKind syntaxKind = type.Kind();
			if (syntaxKind - 396 > SyntaxKind.EndUsingStatement && syntaxKind - 409 > SyntaxKind.List && syntaxKind != SyntaxKind.TupleType)
			{
				throw new ArgumentException("type");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeConstraintSyntax(SyntaxKind.TypeConstraint, null, null, type);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax initializer)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax(SyntaxKind.EnumMemberDeclaration, null, null, attributeLists.Node, (IdentifierTokenSyntax)identifier.Node, initializer);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxToken identifier)
		{
			return EnumMemberDeclaration(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), identifier, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax EnumMemberDeclaration(string identifier)
		{
			return EnumMemberDeclaration(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), Identifier(identifier), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax SubBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax subOrFunctionStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endSubOrFunctionStatement)
		{
			if (subOrFunctionStatement == null)
			{
				throw new ArgumentNullException("subOrFunctionStatement");
			}
			SyntaxKind syntaxKind = subOrFunctionStatement.Kind();
			if (syntaxKind - 93 > SyntaxKind.List)
			{
				throw new ArgumentException("subOrFunctionStatement");
			}
			if (endSubOrFunctionStatement == null)
			{
				throw new ArgumentNullException("endSubOrFunctionStatement");
			}
			SyntaxKind syntaxKind2 = endSubOrFunctionStatement.Kind();
			if (syntaxKind2 - 15 > SyntaxKind.List)
			{
				throw new ArgumentException("endSubOrFunctionStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax(SyntaxKind.SubBlock, null, null, subOrFunctionStatement, statements.Node, endSubOrFunctionStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax SubBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax subOrFunctionStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			return SubBlock(subOrFunctionStatement, statements, EndSubStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax SubBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax subOrFunctionStatement)
		{
			return SubBlock(subOrFunctionStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), EndSubStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax FunctionBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax subOrFunctionStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endSubOrFunctionStatement)
		{
			if (subOrFunctionStatement == null)
			{
				throw new ArgumentNullException("subOrFunctionStatement");
			}
			SyntaxKind syntaxKind = subOrFunctionStatement.Kind();
			if (syntaxKind != SyntaxKind.FunctionStatement)
			{
				throw new ArgumentException("subOrFunctionStatement");
			}
			if (endSubOrFunctionStatement == null)
			{
				throw new ArgumentNullException("endSubOrFunctionStatement");
			}
			SyntaxKind syntaxKind2 = endSubOrFunctionStatement.Kind();
			if (syntaxKind2 != SyntaxKind.EndFunctionStatement)
			{
				throw new ArgumentException("endSubOrFunctionStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax(SyntaxKind.FunctionBlock, null, null, subOrFunctionStatement, statements.Node, endSubOrFunctionStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax FunctionBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax subOrFunctionStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			return FunctionBlock(subOrFunctionStatement, statements, EndFunctionStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax FunctionBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax subOrFunctionStatement)
		{
			return FunctionBlock(subOrFunctionStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), EndFunctionStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax MethodBlock(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax subOrFunctionStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endSubOrFunctionStatement)
		{
			if (!SyntaxFacts.IsMethodBlock(kind))
			{
				throw new ArgumentException("kind");
			}
			if (subOrFunctionStatement == null)
			{
				throw new ArgumentNullException("subOrFunctionStatement");
			}
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(subOrFunctionStatement, GetMethodBlockSubOrFunctionStatementKind(kind)))
			{
				throw new ArgumentException("subOrFunctionStatement");
			}
			if (endSubOrFunctionStatement == null)
			{
				throw new ArgumentNullException("endSubOrFunctionStatement");
			}
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(endSubOrFunctionStatement, GetMethodBlockEndSubOrFunctionStatementKind(kind)))
			{
				throw new ArgumentException("endSubOrFunctionStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax(kind, null, null, subOrFunctionStatement, statements.Node, endSubOrFunctionStatement);
		}

		private static SyntaxKind GetMethodBlockSubOrFunctionStatementKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.SubBlock => SyntaxKind.SubStatement, 
				SyntaxKind.FunctionBlock => SyntaxKind.FunctionStatement, 
				_ => throw new ArgumentException("SubOrFunctionStatement"), 
			};
		}

		private static SyntaxKind GetMethodBlockEndSubOrFunctionStatementKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.SubBlock => SyntaxKind.EndSubStatement, 
				SyntaxKind.FunctionBlock => SyntaxKind.EndFunctionStatement, 
				_ => throw new ArgumentException("EndSubOrFunctionStatement"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax MethodBlock(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax subOrFunctionStatement, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endSubOrFunctionStatement)
		{
			return MethodBlock(kind, subOrFunctionStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), endSubOrFunctionStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstructorBlockSyntax ConstructorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax subNewStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endSubStatement)
		{
			if (subNewStatement == null)
			{
				throw new ArgumentNullException("subNewStatement");
			}
			SyntaxKind syntaxKind = subNewStatement.Kind();
			if (syntaxKind != SyntaxKind.SubNewStatement)
			{
				throw new ArgumentException("subNewStatement");
			}
			if (endSubStatement == null)
			{
				throw new ArgumentNullException("endSubStatement");
			}
			SyntaxKind syntaxKind2 = endSubStatement.Kind();
			if (syntaxKind2 != SyntaxKind.EndSubStatement)
			{
				throw new ArgumentException("endSubStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstructorBlockSyntax(SyntaxKind.ConstructorBlock, null, null, subNewStatement, statements.Node, endSubStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstructorBlockSyntax ConstructorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax subNewStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			return ConstructorBlock(subNewStatement, statements, EndSubStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstructorBlockSyntax ConstructorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax subNewStatement)
		{
			return ConstructorBlock(subNewStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), EndSubStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorBlockSyntax OperatorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax operatorStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endOperatorStatement)
		{
			if (operatorStatement == null)
			{
				throw new ArgumentNullException("operatorStatement");
			}
			SyntaxKind syntaxKind = operatorStatement.Kind();
			if (syntaxKind != SyntaxKind.OperatorStatement)
			{
				throw new ArgumentException("operatorStatement");
			}
			if (endOperatorStatement == null)
			{
				throw new ArgumentNullException("endOperatorStatement");
			}
			SyntaxKind syntaxKind2 = endOperatorStatement.Kind();
			if (syntaxKind2 != SyntaxKind.EndOperatorStatement)
			{
				throw new ArgumentException("endOperatorStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorBlockSyntax(SyntaxKind.OperatorBlock, null, null, operatorStatement, statements.Node, endOperatorStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorBlockSyntax OperatorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax operatorStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			return OperatorBlock(operatorStatement, statements, EndOperatorStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorBlockSyntax OperatorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax operatorStatement)
		{
			return OperatorBlock(operatorStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), EndOperatorStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax GetAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax accessorStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endAccessorStatement)
		{
			if (accessorStatement == null)
			{
				throw new ArgumentNullException("accessorStatement");
			}
			SyntaxKind syntaxKind = accessorStatement.Kind();
			if (syntaxKind - 105 > (SyntaxKind)3 && syntaxKind != SyntaxKind.RaiseEventAccessorStatement)
			{
				throw new ArgumentException("accessorStatement");
			}
			if (endAccessorStatement == null)
			{
				throw new ArgumentNullException("endAccessorStatement");
			}
			SyntaxKind syntaxKind2 = endAccessorStatement.Kind();
			if (syntaxKind2 - 17 > SyntaxKind.List && syntaxKind2 - 22 > SyntaxKind.EmptyStatement)
			{
				throw new ArgumentException("endAccessorStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax(SyntaxKind.GetAccessorBlock, null, null, accessorStatement, statements.Node, endAccessorStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax GetAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax accessorStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			return GetAccessorBlock(accessorStatement, statements, EndGetStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax GetAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax accessorStatement)
		{
			return GetAccessorBlock(accessorStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), EndGetStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax SetAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax accessorStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endAccessorStatement)
		{
			if (accessorStatement == null)
			{
				throw new ArgumentNullException("accessorStatement");
			}
			SyntaxKind syntaxKind = accessorStatement.Kind();
			if (syntaxKind != SyntaxKind.SetAccessorStatement)
			{
				throw new ArgumentException("accessorStatement");
			}
			if (endAccessorStatement == null)
			{
				throw new ArgumentNullException("endAccessorStatement");
			}
			SyntaxKind syntaxKind2 = endAccessorStatement.Kind();
			if (syntaxKind2 != SyntaxKind.EndSetStatement)
			{
				throw new ArgumentException("endAccessorStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax(SyntaxKind.SetAccessorBlock, null, null, accessorStatement, statements.Node, endAccessorStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax SetAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax accessorStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			return SetAccessorBlock(accessorStatement, statements, EndSetStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax SetAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax accessorStatement)
		{
			return SetAccessorBlock(accessorStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), EndSetStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax AddHandlerAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax accessorStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endAccessorStatement)
		{
			if (accessorStatement == null)
			{
				throw new ArgumentNullException("accessorStatement");
			}
			SyntaxKind syntaxKind = accessorStatement.Kind();
			if (syntaxKind != SyntaxKind.AddHandlerAccessorStatement)
			{
				throw new ArgumentException("accessorStatement");
			}
			if (endAccessorStatement == null)
			{
				throw new ArgumentNullException("endAccessorStatement");
			}
			SyntaxKind syntaxKind2 = endAccessorStatement.Kind();
			if (syntaxKind2 != SyntaxKind.EndAddHandlerStatement)
			{
				throw new ArgumentException("endAccessorStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax(SyntaxKind.AddHandlerAccessorBlock, null, null, accessorStatement, statements.Node, endAccessorStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax AddHandlerAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax accessorStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			return AddHandlerAccessorBlock(accessorStatement, statements, EndAddHandlerStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax AddHandlerAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax accessorStatement)
		{
			return AddHandlerAccessorBlock(accessorStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), EndAddHandlerStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax RemoveHandlerAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax accessorStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endAccessorStatement)
		{
			if (accessorStatement == null)
			{
				throw new ArgumentNullException("accessorStatement");
			}
			SyntaxKind syntaxKind = accessorStatement.Kind();
			if (syntaxKind != SyntaxKind.RemoveHandlerAccessorStatement)
			{
				throw new ArgumentException("accessorStatement");
			}
			if (endAccessorStatement == null)
			{
				throw new ArgumentNullException("endAccessorStatement");
			}
			SyntaxKind syntaxKind2 = endAccessorStatement.Kind();
			if (syntaxKind2 != SyntaxKind.EndRemoveHandlerStatement)
			{
				throw new ArgumentException("endAccessorStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax(SyntaxKind.RemoveHandlerAccessorBlock, null, null, accessorStatement, statements.Node, endAccessorStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax RemoveHandlerAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax accessorStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			return RemoveHandlerAccessorBlock(accessorStatement, statements, EndRemoveHandlerStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax RemoveHandlerAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax accessorStatement)
		{
			return RemoveHandlerAccessorBlock(accessorStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), EndRemoveHandlerStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax RaiseEventAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax accessorStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endAccessorStatement)
		{
			if (accessorStatement == null)
			{
				throw new ArgumentNullException("accessorStatement");
			}
			SyntaxKind syntaxKind = accessorStatement.Kind();
			if (syntaxKind != SyntaxKind.RaiseEventAccessorStatement)
			{
				throw new ArgumentException("accessorStatement");
			}
			if (endAccessorStatement == null)
			{
				throw new ArgumentNullException("endAccessorStatement");
			}
			SyntaxKind syntaxKind2 = endAccessorStatement.Kind();
			if (syntaxKind2 != SyntaxKind.EndRaiseEventStatement)
			{
				throw new ArgumentException("endAccessorStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax(SyntaxKind.RaiseEventAccessorBlock, null, null, accessorStatement, statements.Node, endAccessorStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax RaiseEventAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax accessorStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			return RaiseEventAccessorBlock(accessorStatement, statements, EndRaiseEventStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax RaiseEventAccessorBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax accessorStatement)
		{
			return RaiseEventAccessorBlock(accessorStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), EndRaiseEventStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax AccessorBlock(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax accessorStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endAccessorStatement)
		{
			if (!SyntaxFacts.IsAccessorBlock(kind))
			{
				throw new ArgumentException("kind");
			}
			if (accessorStatement == null)
			{
				throw new ArgumentNullException("accessorStatement");
			}
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(accessorStatement, GetAccessorBlockAccessorStatementKind(kind)))
			{
				throw new ArgumentException("accessorStatement");
			}
			if (endAccessorStatement == null)
			{
				throw new ArgumentNullException("endAccessorStatement");
			}
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(endAccessorStatement, GetAccessorBlockEndAccessorStatementKind(kind)))
			{
				throw new ArgumentException("endAccessorStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax(kind, null, null, accessorStatement, statements.Node, endAccessorStatement);
		}

		private static SyntaxKind GetAccessorBlockAccessorStatementKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.GetAccessorBlock => SyntaxKind.GetAccessorStatement, 
				SyntaxKind.SetAccessorBlock => SyntaxKind.SetAccessorStatement, 
				SyntaxKind.AddHandlerAccessorBlock => SyntaxKind.AddHandlerAccessorStatement, 
				SyntaxKind.RemoveHandlerAccessorBlock => SyntaxKind.RemoveHandlerAccessorStatement, 
				SyntaxKind.RaiseEventAccessorBlock => SyntaxKind.RaiseEventAccessorStatement, 
				_ => throw new ArgumentException("AccessorStatement"), 
			};
		}

		private static SyntaxKind GetAccessorBlockEndAccessorStatementKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.GetAccessorBlock => SyntaxKind.EndGetStatement, 
				SyntaxKind.SetAccessorBlock => SyntaxKind.EndSetStatement, 
				SyntaxKind.AddHandlerAccessorBlock => SyntaxKind.EndAddHandlerStatement, 
				SyntaxKind.RemoveHandlerAccessorBlock => SyntaxKind.EndRemoveHandlerStatement, 
				SyntaxKind.RaiseEventAccessorBlock => SyntaxKind.EndRaiseEventStatement, 
				_ => throw new ArgumentException("EndAccessorStatement"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax AccessorBlock(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax accessorStatement, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endAccessorStatement)
		{
			return AccessorBlock(kind, accessorStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), endAccessorStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax PropertyBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax propertyStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax> accessors, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endPropertyStatement)
		{
			if (propertyStatement == null)
			{
				throw new ArgumentNullException("propertyStatement");
			}
			SyntaxKind syntaxKind = propertyStatement.Kind();
			if (syntaxKind != SyntaxKind.PropertyStatement)
			{
				throw new ArgumentException("propertyStatement");
			}
			if (endPropertyStatement == null)
			{
				throw new ArgumentNullException("endPropertyStatement");
			}
			SyntaxKind syntaxKind2 = endPropertyStatement.Kind();
			if (syntaxKind2 != SyntaxKind.EndPropertyStatement)
			{
				throw new ArgumentException("endPropertyStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax(SyntaxKind.PropertyBlock, null, null, propertyStatement, accessors.Node, endPropertyStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax PropertyBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax propertyStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax> accessors)
		{
			return PropertyBlock(propertyStatement, accessors, EndPropertyStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax EventBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax eventStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax> accessors, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endEventStatement)
		{
			if (eventStatement == null)
			{
				throw new ArgumentNullException("eventStatement");
			}
			SyntaxKind syntaxKind = eventStatement.Kind();
			if (syntaxKind != SyntaxKind.EventStatement)
			{
				throw new ArgumentException("eventStatement");
			}
			if (endEventStatement == null)
			{
				throw new ArgumentNullException("endEventStatement");
			}
			SyntaxKind syntaxKind2 = endEventStatement.Kind();
			if (syntaxKind2 != SyntaxKind.EndEventStatement)
			{
				throw new ArgumentException("endEventStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax(SyntaxKind.EventBlock, null, null, eventStatement, accessors.Node, endEventStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax EventBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax eventStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax> accessors)
		{
			return EventBlock(eventStatement, accessors, EndEventStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax ParameterList(SyntaxToken openParenToken, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax> parameters, SyntaxToken closeParenToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(openParenToken);
			if (syntaxKind != SyntaxKind.OpenParenToken)
			{
				throw new ArgumentException("openParenToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(closeParenToken);
			if (syntaxKind2 != SyntaxKind.CloseParenToken)
			{
				throw new ArgumentException("closeParenToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax(SyntaxKind.ParameterList, null, null, (PunctuationSyntax)openParenToken.Node, parameters.Node, (PunctuationSyntax)closeParenToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax ParameterList(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax> parameters)
		{
			return ParameterList(Token(SyntaxKind.OpenParenToken), parameters, Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax ParameterList()
		{
			return ParameterList(Token(SyntaxKind.OpenParenToken), default(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax>), Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax SubStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause, Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax handlesClause, Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax implementsClause)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(subOrFunctionKeyword);
			if (syntaxKind != SyntaxKind.FunctionKeyword && syntaxKind != SyntaxKind.SubKeyword)
			{
				throw new ArgumentException("subOrFunctionKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind2 != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax(SyntaxKind.SubStatement, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)subOrFunctionKeyword.Node, (IdentifierTokenSyntax)identifier.Node, typeParameterList, parameterList, asClause, handlesClause, implementsClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax SubStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause, Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax handlesClause, Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax implementsClause)
		{
			return SubStatement(attributeLists, modifiers, Token(SyntaxKind.SubKeyword), identifier, typeParameterList, parameterList, asClause, handlesClause, implementsClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax SubStatement(SyntaxToken identifier)
		{
			return SubStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.SubKeyword), identifier, null, null, null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax SubStatement(string identifier)
		{
			return SubStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.SubKeyword), Identifier(identifier), null, null, null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax FunctionStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause, Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax handlesClause, Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax implementsClause)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(subOrFunctionKeyword);
			if (syntaxKind != SyntaxKind.FunctionKeyword)
			{
				throw new ArgumentException("subOrFunctionKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind2 != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax(SyntaxKind.FunctionStatement, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)subOrFunctionKeyword.Node, (IdentifierTokenSyntax)identifier.Node, typeParameterList, parameterList, asClause, handlesClause, implementsClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax FunctionStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause, Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax handlesClause, Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax implementsClause)
		{
			return FunctionStatement(attributeLists, modifiers, Token(SyntaxKind.FunctionKeyword), identifier, typeParameterList, parameterList, asClause, handlesClause, implementsClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax FunctionStatement(SyntaxToken identifier)
		{
			return FunctionStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.FunctionKeyword), identifier, null, null, null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax FunctionStatement(string identifier)
		{
			return FunctionStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.FunctionKeyword), Identifier(identifier), null, null, null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax MethodStatement(SyntaxKind kind, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause, Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax handlesClause, Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax implementsClause)
		{
			if (!SyntaxFacts.IsMethodStatement(kind))
			{
				throw new ArgumentException("kind");
			}
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(subOrFunctionKeyword, GetMethodStatementSubOrFunctionKeywordKind(kind)))
			{
				throw new ArgumentException("subOrFunctionKeyword");
			}
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax(kind, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)subOrFunctionKeyword.Node, (IdentifierTokenSyntax)identifier.Node, typeParameterList, parameterList, asClause, handlesClause, implementsClause);
		}

		private static SyntaxKind GetMethodStatementSubOrFunctionKeywordKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.SubStatement => SyntaxKind.SubKeyword, 
				SyntaxKind.FunctionStatement => SyntaxKind.FunctionKeyword, 
				_ => throw new ArgumentException("SubOrFunctionKeyword"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax MethodStatement(SyntaxKind kind, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier)
		{
			return MethodStatement(kind, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), subOrFunctionKeyword, identifier, null, null, null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax MethodStatement(SyntaxKind kind, SyntaxToken subOrFunctionKeyword, string identifier)
		{
			return MethodStatement(kind, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), subOrFunctionKeyword, Identifier(identifier), null, null, null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax SubNewStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken subKeyword, SyntaxToken newKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(subKeyword);
			if (syntaxKind != SyntaxKind.SubKeyword)
			{
				throw new ArgumentException("subKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(newKeyword);
			if (syntaxKind2 != SyntaxKind.NewKeyword)
			{
				throw new ArgumentException("newKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax(SyntaxKind.SubNewStatement, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)subKeyword.Node, (KeywordSyntax)newKeyword.Node, parameterList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax SubNewStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList)
		{
			return SubNewStatement(attributeLists, modifiers, Token(SyntaxKind.SubKeyword), Token(SyntaxKind.NewKeyword), parameterList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax SubNewStatement()
		{
			return SubNewStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.SubKeyword), Token(SyntaxKind.NewKeyword), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax DeclareSubStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken declareKeyword, SyntaxToken charsetKeyword, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, SyntaxToken libKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax libraryName, SyntaxToken aliasKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax aliasName, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(declareKeyword);
			if (syntaxKind != SyntaxKind.DeclareKeyword)
			{
				throw new ArgumentException("declareKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(subOrFunctionKeyword);
			if (syntaxKind2 != SyntaxKind.FunctionKeyword && syntaxKind2 != SyntaxKind.SubKeyword)
			{
				throw new ArgumentException("subOrFunctionKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind3 != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			SyntaxKind syntaxKind4 = VisualBasicExtensions.Kind(libKeyword);
			if (syntaxKind4 != SyntaxKind.LibKeyword)
			{
				throw new ArgumentException("libKeyword");
			}
			if (libraryName == null)
			{
				throw new ArgumentNullException("libraryName");
			}
			SyntaxKind syntaxKind5 = libraryName.Kind();
			if (syntaxKind5 - 272 > (SyntaxKind)4 && syntaxKind5 - 279 > SyntaxKind.List)
			{
				throw new ArgumentException("libraryName");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax(SyntaxKind.DeclareSubStatement, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)declareKeyword.Node, (KeywordSyntax)charsetKeyword.Node, (KeywordSyntax)subOrFunctionKeyword.Node, (IdentifierTokenSyntax)identifier.Node, (KeywordSyntax)libKeyword.Node, libraryName, (KeywordSyntax)aliasKeyword.Node, aliasName, parameterList, asClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax DeclareSubStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken charsetKeyword, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax libraryName, Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax aliasName, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause)
		{
			return DeclareSubStatement(attributeLists, modifiers, Token(SyntaxKind.DeclareKeyword), charsetKeyword, Token(SyntaxKind.SubKeyword), identifier, Token(SyntaxKind.LibKeyword), libraryName, default(SyntaxToken), aliasName, parameterList, asClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax DeclareSubStatement(SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax libraryName)
		{
			return DeclareSubStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.DeclareKeyword), default(SyntaxToken), Token(SyntaxKind.SubKeyword), identifier, Token(SyntaxKind.LibKeyword), libraryName, default(SyntaxToken), null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax DeclareSubStatement(string identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax libraryName)
		{
			return DeclareSubStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.DeclareKeyword), default(SyntaxToken), Token(SyntaxKind.SubKeyword), Identifier(identifier), Token(SyntaxKind.LibKeyword), libraryName, default(SyntaxToken), null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax DeclareFunctionStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken declareKeyword, SyntaxToken charsetKeyword, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, SyntaxToken libKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax libraryName, SyntaxToken aliasKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax aliasName, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(declareKeyword);
			if (syntaxKind != SyntaxKind.DeclareKeyword)
			{
				throw new ArgumentException("declareKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(subOrFunctionKeyword);
			if (syntaxKind2 != SyntaxKind.FunctionKeyword)
			{
				throw new ArgumentException("subOrFunctionKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind3 != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			SyntaxKind syntaxKind4 = VisualBasicExtensions.Kind(libKeyword);
			if (syntaxKind4 != SyntaxKind.LibKeyword)
			{
				throw new ArgumentException("libKeyword");
			}
			if (libraryName == null)
			{
				throw new ArgumentNullException("libraryName");
			}
			SyntaxKind syntaxKind5 = libraryName.Kind();
			if (syntaxKind5 - 272 > (SyntaxKind)4 && syntaxKind5 - 279 > SyntaxKind.List)
			{
				throw new ArgumentException("libraryName");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax(SyntaxKind.DeclareFunctionStatement, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)declareKeyword.Node, (KeywordSyntax)charsetKeyword.Node, (KeywordSyntax)subOrFunctionKeyword.Node, (IdentifierTokenSyntax)identifier.Node, (KeywordSyntax)libKeyword.Node, libraryName, (KeywordSyntax)aliasKeyword.Node, aliasName, parameterList, asClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax DeclareFunctionStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken charsetKeyword, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax libraryName, Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax aliasName, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause)
		{
			return DeclareFunctionStatement(attributeLists, modifiers, Token(SyntaxKind.DeclareKeyword), charsetKeyword, Token(SyntaxKind.FunctionKeyword), identifier, Token(SyntaxKind.LibKeyword), libraryName, default(SyntaxToken), aliasName, parameterList, asClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax DeclareFunctionStatement(SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax libraryName)
		{
			return DeclareFunctionStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.DeclareKeyword), default(SyntaxToken), Token(SyntaxKind.FunctionKeyword), identifier, Token(SyntaxKind.LibKeyword), libraryName, default(SyntaxToken), null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax DeclareFunctionStatement(string identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax libraryName)
		{
			return DeclareFunctionStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.DeclareKeyword), default(SyntaxToken), Token(SyntaxKind.FunctionKeyword), Identifier(identifier), Token(SyntaxKind.LibKeyword), libraryName, default(SyntaxToken), null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax DeclareStatement(SyntaxKind kind, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken declareKeyword, SyntaxToken charsetKeyword, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, SyntaxToken libKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax libraryName, SyntaxToken aliasKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax aliasName, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause)
		{
			if (!SyntaxFacts.IsDeclareStatement(kind))
			{
				throw new ArgumentException("kind");
			}
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(declareKeyword);
			if (syntaxKind != SyntaxKind.DeclareKeyword)
			{
				throw new ArgumentException("declareKeyword");
			}
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(subOrFunctionKeyword, GetDeclareStatementSubOrFunctionKeywordKind(kind)))
			{
				throw new ArgumentException("subOrFunctionKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind2 != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(libKeyword);
			if (syntaxKind3 != SyntaxKind.LibKeyword)
			{
				throw new ArgumentException("libKeyword");
			}
			if (libraryName == null)
			{
				throw new ArgumentNullException("libraryName");
			}
			SyntaxKind syntaxKind4 = libraryName.Kind();
			if (syntaxKind4 - 272 > (SyntaxKind)4 && syntaxKind4 - 279 > SyntaxKind.List)
			{
				throw new ArgumentException("libraryName");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax(kind, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)declareKeyword.Node, (KeywordSyntax)charsetKeyword.Node, (KeywordSyntax)subOrFunctionKeyword.Node, (IdentifierTokenSyntax)identifier.Node, (KeywordSyntax)libKeyword.Node, libraryName, (KeywordSyntax)aliasKeyword.Node, aliasName, parameterList, asClause);
		}

		private static SyntaxKind GetDeclareStatementSubOrFunctionKeywordKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.DeclareSubStatement => SyntaxKind.SubKeyword, 
				SyntaxKind.DeclareFunctionStatement => SyntaxKind.FunctionKeyword, 
				_ => throw new ArgumentException("SubOrFunctionKeyword"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax DeclareStatement(SyntaxKind kind, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken charsetKeyword, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax libraryName, Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax aliasName, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause)
		{
			return DeclareStatement(kind, attributeLists, modifiers, Token(SyntaxKind.DeclareKeyword), charsetKeyword, subOrFunctionKeyword, identifier, Token(SyntaxKind.LibKeyword), libraryName, default(SyntaxToken), aliasName, parameterList, asClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax DeclareStatement(SyntaxKind kind, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax libraryName)
		{
			return DeclareStatement(kind, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.DeclareKeyword), default(SyntaxToken), subOrFunctionKeyword, identifier, Token(SyntaxKind.LibKeyword), libraryName, default(SyntaxToken), null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax DeclareStatement(SyntaxKind kind, SyntaxToken subOrFunctionKeyword, string identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax libraryName)
		{
			return DeclareStatement(kind, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.DeclareKeyword), default(SyntaxToken), subOrFunctionKeyword, Identifier(identifier), Token(SyntaxKind.LibKeyword), libraryName, default(SyntaxToken), null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax DelegateSubStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(delegateKeyword);
			if (syntaxKind != SyntaxKind.DelegateKeyword)
			{
				throw new ArgumentException("delegateKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(subOrFunctionKeyword);
			if (syntaxKind2 != SyntaxKind.FunctionKeyword && syntaxKind2 != SyntaxKind.SubKeyword)
			{
				throw new ArgumentException("subOrFunctionKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind3 != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax(SyntaxKind.DelegateSubStatement, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)delegateKeyword.Node, (KeywordSyntax)subOrFunctionKeyword.Node, (IdentifierTokenSyntax)identifier.Node, typeParameterList, parameterList, asClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax DelegateSubStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause)
		{
			return DelegateSubStatement(attributeLists, modifiers, Token(SyntaxKind.DelegateKeyword), Token(SyntaxKind.SubKeyword), identifier, typeParameterList, parameterList, asClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax DelegateSubStatement(SyntaxToken identifier)
		{
			return DelegateSubStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.DelegateKeyword), Token(SyntaxKind.SubKeyword), identifier, null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax DelegateSubStatement(string identifier)
		{
			return DelegateSubStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.DelegateKeyword), Token(SyntaxKind.SubKeyword), Identifier(identifier), null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax DelegateFunctionStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(delegateKeyword);
			if (syntaxKind != SyntaxKind.DelegateKeyword)
			{
				throw new ArgumentException("delegateKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(subOrFunctionKeyword);
			if (syntaxKind2 != SyntaxKind.FunctionKeyword)
			{
				throw new ArgumentException("subOrFunctionKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind3 != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax(SyntaxKind.DelegateFunctionStatement, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)delegateKeyword.Node, (KeywordSyntax)subOrFunctionKeyword.Node, (IdentifierTokenSyntax)identifier.Node, typeParameterList, parameterList, asClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax DelegateFunctionStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause)
		{
			return DelegateFunctionStatement(attributeLists, modifiers, Token(SyntaxKind.DelegateKeyword), Token(SyntaxKind.FunctionKeyword), identifier, typeParameterList, parameterList, asClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax DelegateFunctionStatement(SyntaxToken identifier)
		{
			return DelegateFunctionStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.DelegateKeyword), Token(SyntaxKind.FunctionKeyword), identifier, null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax DelegateFunctionStatement(string identifier)
		{
			return DelegateFunctionStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.DelegateKeyword), Token(SyntaxKind.FunctionKeyword), Identifier(identifier), null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax DelegateStatement(SyntaxKind kind, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause)
		{
			if (!SyntaxFacts.IsDelegateStatement(kind))
			{
				throw new ArgumentException("kind");
			}
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(delegateKeyword);
			if (syntaxKind != SyntaxKind.DelegateKeyword)
			{
				throw new ArgumentException("delegateKeyword");
			}
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(subOrFunctionKeyword, GetDelegateStatementSubOrFunctionKeywordKind(kind)))
			{
				throw new ArgumentException("subOrFunctionKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind2 != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax(kind, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)delegateKeyword.Node, (KeywordSyntax)subOrFunctionKeyword.Node, (IdentifierTokenSyntax)identifier.Node, typeParameterList, parameterList, asClause);
		}

		private static SyntaxKind GetDelegateStatementSubOrFunctionKeywordKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.DelegateSubStatement => SyntaxKind.SubKeyword, 
				SyntaxKind.DelegateFunctionStatement => SyntaxKind.FunctionKeyword, 
				_ => throw new ArgumentException("SubOrFunctionKeyword"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax DelegateStatement(SyntaxKind kind, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause)
		{
			return DelegateStatement(kind, attributeLists, modifiers, Token(SyntaxKind.DelegateKeyword), subOrFunctionKeyword, identifier, typeParameterList, parameterList, asClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax DelegateStatement(SyntaxKind kind, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier)
		{
			return DelegateStatement(kind, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.DelegateKeyword), subOrFunctionKeyword, identifier, null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax DelegateStatement(SyntaxKind kind, SyntaxToken subOrFunctionKeyword, string identifier)
		{
			return DelegateStatement(kind, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.DelegateKeyword), subOrFunctionKeyword, Identifier(identifier), null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax EventStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken customKeyword, SyntaxToken eventKeyword, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause, Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax implementsClause)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(eventKeyword);
			if (syntaxKind != SyntaxKind.EventKeyword)
			{
				throw new ArgumentException("eventKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind2 != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax(SyntaxKind.EventStatement, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)customKeyword.Node, (KeywordSyntax)eventKeyword.Node, (IdentifierTokenSyntax)identifier.Node, parameterList, asClause, implementsClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax EventStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause, Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax implementsClause)
		{
			return EventStatement(attributeLists, modifiers, default(SyntaxToken), Token(SyntaxKind.EventKeyword), identifier, parameterList, asClause, implementsClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax EventStatement(SyntaxToken identifier)
		{
			return EventStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), default(SyntaxToken), Token(SyntaxKind.EventKeyword), identifier, null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax EventStatement(string identifier)
		{
			return EventStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), default(SyntaxToken), Token(SyntaxKind.EventKeyword), Identifier(identifier), null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax OperatorStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken operatorKeyword, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(operatorKeyword);
			if (syntaxKind != SyntaxKind.OperatorKeyword)
			{
				throw new ArgumentException("operatorKeyword");
			}
			switch (VisualBasicExtensions.Kind(operatorToken))
			{
			default:
				throw new ArgumentException("operatorToken");
			case SyntaxKind.AndKeyword:
			case SyntaxKind.CTypeKeyword:
			case SyntaxKind.LikeKeyword:
			case SyntaxKind.ModKeyword:
			case SyntaxKind.NotKeyword:
			case SyntaxKind.OrKeyword:
			case SyntaxKind.XorKeyword:
			case SyntaxKind.IsFalseKeyword:
			case SyntaxKind.IsTrueKeyword:
			case SyntaxKind.AmpersandToken:
			case SyntaxKind.AsteriskToken:
			case SyntaxKind.PlusToken:
			case SyntaxKind.MinusToken:
			case SyntaxKind.SlashToken:
			case SyntaxKind.LessThanToken:
			case SyntaxKind.LessThanEqualsToken:
			case SyntaxKind.LessThanGreaterThanToken:
			case SyntaxKind.EqualsToken:
			case SyntaxKind.GreaterThanToken:
			case SyntaxKind.GreaterThanEqualsToken:
			case SyntaxKind.BackslashToken:
			case SyntaxKind.CaretToken:
			case SyntaxKind.LessThanLessThanToken:
			case SyntaxKind.GreaterThanGreaterThanToken:
				return new Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax(SyntaxKind.OperatorStatement, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)operatorKeyword.Node, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, parameterList, asClause);
			}
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax OperatorStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause)
		{
			return OperatorStatement(attributeLists, modifiers, Token(SyntaxKind.OperatorKeyword), operatorToken, parameterList, asClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax OperatorStatement(SyntaxToken operatorToken)
		{
			return OperatorStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.OperatorKeyword), operatorToken, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax PropertyStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken propertyKeyword, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClause, Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax initializer, Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax implementsClause)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(propertyKeyword);
			if (syntaxKind != SyntaxKind.PropertyKeyword)
			{
				throw new ArgumentException("propertyKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind2 != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax(SyntaxKind.PropertyStatement, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)propertyKeyword.Node, (IdentifierTokenSyntax)identifier.Node, parameterList, asClause, initializer, implementsClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax PropertyStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClause, Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax initializer, Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax implementsClause)
		{
			return PropertyStatement(attributeLists, modifiers, Token(SyntaxKind.PropertyKeyword), identifier, parameterList, asClause, initializer, implementsClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax PropertyStatement(SyntaxToken identifier)
		{
			return PropertyStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.PropertyKeyword), identifier, null, null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax PropertyStatement(string identifier)
		{
			return PropertyStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.PropertyKeyword), Identifier(identifier), null, null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax GetAccessorStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken accessorKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList)
		{
			switch (VisualBasicExtensions.Kind(accessorKeyword))
			{
			default:
				throw new ArgumentException("accessorKeyword");
			case SyntaxKind.AddHandlerKeyword:
			case SyntaxKind.GetKeyword:
			case SyntaxKind.RaiseEventKeyword:
			case SyntaxKind.RemoveHandlerKeyword:
			case SyntaxKind.SetKeyword:
				return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax(SyntaxKind.GetAccessorStatement, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)accessorKeyword.Node, parameterList);
			}
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax GetAccessorStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList)
		{
			return GetAccessorStatement(attributeLists, modifiers, Token(SyntaxKind.GetKeyword), parameterList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax GetAccessorStatement()
		{
			return GetAccessorStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.GetKeyword), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax SetAccessorStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken accessorKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(accessorKeyword);
			if (syntaxKind != SyntaxKind.SetKeyword)
			{
				throw new ArgumentException("accessorKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax(SyntaxKind.SetAccessorStatement, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)accessorKeyword.Node, parameterList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax SetAccessorStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList)
		{
			return SetAccessorStatement(attributeLists, modifiers, Token(SyntaxKind.SetKeyword), parameterList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax SetAccessorStatement()
		{
			return SetAccessorStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.SetKeyword), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax AddHandlerAccessorStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken accessorKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(accessorKeyword);
			if (syntaxKind != SyntaxKind.AddHandlerKeyword)
			{
				throw new ArgumentException("accessorKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax(SyntaxKind.AddHandlerAccessorStatement, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)accessorKeyword.Node, parameterList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax AddHandlerAccessorStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList)
		{
			return AddHandlerAccessorStatement(attributeLists, modifiers, Token(SyntaxKind.AddHandlerKeyword), parameterList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax AddHandlerAccessorStatement()
		{
			return AddHandlerAccessorStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.AddHandlerKeyword), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax RemoveHandlerAccessorStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken accessorKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(accessorKeyword);
			if (syntaxKind != SyntaxKind.RemoveHandlerKeyword)
			{
				throw new ArgumentException("accessorKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax(SyntaxKind.RemoveHandlerAccessorStatement, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)accessorKeyword.Node, parameterList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax RemoveHandlerAccessorStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList)
		{
			return RemoveHandlerAccessorStatement(attributeLists, modifiers, Token(SyntaxKind.RemoveHandlerKeyword), parameterList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax RemoveHandlerAccessorStatement()
		{
			return RemoveHandlerAccessorStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.RemoveHandlerKeyword), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax RaiseEventAccessorStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken accessorKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(accessorKeyword);
			if (syntaxKind != SyntaxKind.RaiseEventKeyword)
			{
				throw new ArgumentException("accessorKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax(SyntaxKind.RaiseEventAccessorStatement, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)accessorKeyword.Node, parameterList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax RaiseEventAccessorStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList)
		{
			return RaiseEventAccessorStatement(attributeLists, modifiers, Token(SyntaxKind.RaiseEventKeyword), parameterList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax RaiseEventAccessorStatement()
		{
			return RaiseEventAccessorStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.RaiseEventKeyword), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax AccessorStatement(SyntaxKind kind, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken accessorKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList)
		{
			if (!SyntaxFacts.IsAccessorStatement(kind))
			{
				throw new ArgumentException("kind");
			}
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(accessorKeyword, GetAccessorStatementAccessorKeywordKind(kind)))
			{
				throw new ArgumentException("accessorKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax(kind, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)accessorKeyword.Node, parameterList);
		}

		private static SyntaxKind GetAccessorStatementAccessorKeywordKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.GetAccessorStatement => SyntaxKind.GetKeyword, 
				SyntaxKind.SetAccessorStatement => SyntaxKind.SetKeyword, 
				SyntaxKind.AddHandlerAccessorStatement => SyntaxKind.AddHandlerKeyword, 
				SyntaxKind.RemoveHandlerAccessorStatement => SyntaxKind.RemoveHandlerKeyword, 
				SyntaxKind.RaiseEventAccessorStatement => SyntaxKind.RaiseEventKeyword, 
				_ => throw new ArgumentException("AccessorKeyword"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax AccessorStatement(SyntaxKind kind, SyntaxToken accessorKeyword)
		{
			return AccessorStatement(kind, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), accessorKeyword, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax ImplementsClause(SyntaxToken implementsKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax> interfaceMembers)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(implementsKeyword);
			if (syntaxKind != SyntaxKind.ImplementsKeyword)
			{
				throw new ArgumentException("implementsKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax(SyntaxKind.ImplementsClause, null, null, (KeywordSyntax)implementsKeyword.Node, interfaceMembers.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax ImplementsClause(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax> interfaceMembers)
		{
			return ImplementsClause(Token(SyntaxKind.ImplementsKeyword), interfaceMembers);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax ImplementsClause(params Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax[] interfaceMembers)
		{
			return ImplementsClause(Token(SyntaxKind.ImplementsKeyword), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax>().AddRange(interfaceMembers));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax HandlesClause(SyntaxToken handlesKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax> events)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(handlesKeyword);
			if (syntaxKind != SyntaxKind.HandlesKeyword)
			{
				throw new ArgumentException("handlesKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax(SyntaxKind.HandlesClause, null, null, (KeywordSyntax)handlesKeyword.Node, events.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax HandlesClause(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax> events)
		{
			return HandlesClause(Token(SyntaxKind.HandlesKeyword), events);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax HandlesClause(params Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax[] events)
		{
			return HandlesClause(Token(SyntaxKind.HandlesKeyword), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax>().AddRange(events));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.KeywordEventContainerSyntax KeywordEventContainer(SyntaxToken keyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(keyword);
			if (syntaxKind != SyntaxKind.MeKeyword && syntaxKind != SyntaxKind.MyBaseKeyword && syntaxKind != SyntaxKind.MyClassKeyword)
			{
				throw new ArgumentException("keyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.KeywordEventContainerSyntax(SyntaxKind.KeywordEventContainer, null, null, (KeywordSyntax)keyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsEventContainerSyntax WithEventsEventContainer(SyntaxToken identifier)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsEventContainerSyntax(SyntaxKind.WithEventsEventContainer, null, null, (IdentifierTokenSyntax)identifier.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsEventContainerSyntax WithEventsEventContainer(string identifier)
		{
			return WithEventsEventContainer(Identifier(identifier));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsPropertyEventContainerSyntax WithEventsPropertyEventContainer(Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsEventContainerSyntax withEventsContainer, SyntaxToken dotToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax property)
		{
			if (withEventsContainer == null)
			{
				throw new ArgumentNullException("withEventsContainer");
			}
			SyntaxKind syntaxKind = withEventsContainer.Kind();
			if (syntaxKind != SyntaxKind.WithEventsEventContainer)
			{
				throw new ArgumentException("withEventsContainer");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(dotToken);
			if (syntaxKind2 != SyntaxKind.DotToken)
			{
				throw new ArgumentException("dotToken");
			}
			if (property == null)
			{
				throw new ArgumentNullException("property");
			}
			SyntaxKind syntaxKind3 = property.Kind();
			if (syntaxKind3 != SyntaxKind.IdentifierName)
			{
				throw new ArgumentException("[property]");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsPropertyEventContainerSyntax(SyntaxKind.WithEventsPropertyEventContainer, null, null, withEventsContainer, (PunctuationSyntax)dotToken.Node, property);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsPropertyEventContainerSyntax WithEventsPropertyEventContainer(Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsEventContainerSyntax withEventsContainer, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax property)
		{
			return WithEventsPropertyEventContainer(withEventsContainer, Token(SyntaxKind.DotToken), property);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax HandlesClauseItem(Microsoft.CodeAnalysis.VisualBasic.Syntax.EventContainerSyntax eventContainer, SyntaxToken dotToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax eventMember)
		{
			if (eventContainer == null)
			{
				throw new ArgumentNullException("eventContainer");
			}
			SyntaxKind syntaxKind = eventContainer.Kind();
			if (syntaxKind - 114 > SyntaxKind.List)
			{
				throw new ArgumentException("eventContainer");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(dotToken);
			if (syntaxKind2 != SyntaxKind.DotToken)
			{
				throw new ArgumentException("dotToken");
			}
			if (eventMember == null)
			{
				throw new ArgumentNullException("eventMember");
			}
			SyntaxKind syntaxKind3 = eventMember.Kind();
			if (syntaxKind3 != SyntaxKind.IdentifierName)
			{
				throw new ArgumentException("eventMember");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax(SyntaxKind.HandlesClauseItem, null, null, eventContainer, (PunctuationSyntax)dotToken.Node, eventMember);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax HandlesClauseItem(Microsoft.CodeAnalysis.VisualBasic.Syntax.EventContainerSyntax eventContainer, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax eventMember)
		{
			return HandlesClauseItem(eventContainer, Token(SyntaxKind.DotToken), eventMember);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.IncompleteMemberSyntax IncompleteMember(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken missingIdentifier)
		{
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.IncompleteMemberSyntax(SyntaxKind.IncompleteMember, null, null, attributeLists.Node, modifiers.Node, (IdentifierTokenSyntax)missingIdentifier.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.IncompleteMemberSyntax IncompleteMember()
		{
			return IncompleteMember(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), default(SyntaxToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldDeclarationSyntax FieldDeclaration(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax> declarators)
		{
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldDeclarationSyntax(SyntaxKind.FieldDeclaration, null, null, attributeLists.Node, modifiers.Node, declarators.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldDeclarationSyntax FieldDeclaration(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax> declarators)
		{
			return FieldDeclaration(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), declarators);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldDeclarationSyntax FieldDeclaration(params Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax[] declarators)
		{
			return FieldDeclaration(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax>().AddRange(declarators));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax VariableDeclarator(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax> names, Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClause, Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax initializer)
		{
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax(SyntaxKind.VariableDeclarator, null, null, names.Node, asClause, initializer);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax VariableDeclarator(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax> names)
		{
			return VariableDeclarator(names, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax VariableDeclarator(params Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax[] names)
		{
			return VariableDeclarator(SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax>().AddRange(names), null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax SimpleAsClause(SyntaxToken asKeyword, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(asKeyword);
			if (syntaxKind != SyntaxKind.AsKeyword)
			{
				throw new ArgumentException("asKeyword");
			}
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			SyntaxKind syntaxKind2 = type.Kind();
			if (syntaxKind2 - 396 > SyntaxKind.EndUsingStatement && syntaxKind2 - 409 > SyntaxKind.List && syntaxKind2 != SyntaxKind.TupleType)
			{
				throw new ArgumentException("type");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax(SyntaxKind.SimpleAsClause, null, null, (KeywordSyntax)asKeyword.Node, attributeLists.Node, type);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax SimpleAsClause(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type)
		{
			return SimpleAsClause(Token(SyntaxKind.AsKeyword), attributeLists, type);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax SimpleAsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type)
		{
			return SimpleAsClause(Token(SyntaxKind.AsKeyword), default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), type);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax AsNewClause(SyntaxToken asKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax newExpression)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(asKeyword);
			if (syntaxKind != SyntaxKind.AsKeyword)
			{
				throw new ArgumentException("asKeyword");
			}
			if (newExpression == null)
			{
				throw new ArgumentNullException("newExpression");
			}
			SyntaxKind syntaxKind2 = newExpression.Kind();
			if (syntaxKind2 - 297 > SyntaxKind.List && syntaxKind2 != SyntaxKind.ArrayCreationExpression)
			{
				throw new ArgumentException("newExpression");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax(SyntaxKind.AsNewClause, null, null, (KeywordSyntax)asKeyword.Node, newExpression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax AsNewClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax newExpression)
		{
			return AsNewClause(Token(SyntaxKind.AsKeyword), newExpression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax ObjectMemberInitializer(SyntaxToken withKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax> initializers, SyntaxToken closeBraceToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(withKeyword);
			if (syntaxKind != SyntaxKind.WithKeyword)
			{
				throw new ArgumentException("withKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(openBraceToken);
			if (syntaxKind2 != SyntaxKind.OpenBraceToken)
			{
				throw new ArgumentException("openBraceToken");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(closeBraceToken);
			if (syntaxKind3 != SyntaxKind.CloseBraceToken)
			{
				throw new ArgumentException("closeBraceToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax(SyntaxKind.ObjectMemberInitializer, null, null, (KeywordSyntax)withKeyword.Node, (PunctuationSyntax)openBraceToken.Node, initializers.Node, (PunctuationSyntax)closeBraceToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax ObjectMemberInitializer(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax> initializers)
		{
			return ObjectMemberInitializer(Token(SyntaxKind.WithKeyword), Token(SyntaxKind.OpenBraceToken), initializers, Token(SyntaxKind.CloseBraceToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax ObjectMemberInitializer(params Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax[] initializers)
		{
			return ObjectMemberInitializer(Token(SyntaxKind.WithKeyword), Token(SyntaxKind.OpenBraceToken), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax>().AddRange(initializers), Token(SyntaxKind.CloseBraceToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCollectionInitializerSyntax ObjectCollectionInitializer(SyntaxToken fromKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax initializer)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(fromKeyword);
			if (syntaxKind != SyntaxKind.FromKeyword)
			{
				throw new ArgumentException("fromKeyword");
			}
			if (initializer == null)
			{
				throw new ArgumentNullException("initializer");
			}
			SyntaxKind syntaxKind2 = initializer.Kind();
			if (syntaxKind2 != SyntaxKind.CollectionInitializer)
			{
				throw new ArgumentException("initializer");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCollectionInitializerSyntax(SyntaxKind.ObjectCollectionInitializer, null, null, (KeywordSyntax)fromKeyword.Node, initializer);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCollectionInitializerSyntax ObjectCollectionInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax initializer)
		{
			return ObjectCollectionInitializer(Token(SyntaxKind.FromKeyword), initializer);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InferredFieldInitializerSyntax InferredFieldInitializer(SyntaxToken keyKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind = expression.Kind();
			if (syntaxKind - 291 > SyntaxKind.List && syntaxKind != SyntaxKind.IdentifierName)
			{
				throw new ArgumentException("expression");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.InferredFieldInitializerSyntax(SyntaxKind.InferredFieldInitializer, null, null, (KeywordSyntax)keyKeyword.Node, expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InferredFieldInitializerSyntax InferredFieldInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return InferredFieldInitializer(default(SyntaxToken), expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax NamedFieldInitializer(SyntaxToken keyKeyword, SyntaxToken dotToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax name, SyntaxToken equalsToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(dotToken);
			if (syntaxKind != SyntaxKind.DotToken)
			{
				throw new ArgumentException("dotToken");
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			SyntaxKind syntaxKind2 = name.Kind();
			if (syntaxKind2 != SyntaxKind.IdentifierName)
			{
				throw new ArgumentException("name");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(equalsToken);
			if (syntaxKind3 != SyntaxKind.EqualsToken)
			{
				throw new ArgumentException("equalsToken");
			}
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind4 = expression.Kind();
			if (syntaxKind4 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind4)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_0330;
				}
			}
			else if (syntaxKind4 - 711 <= SyntaxKind.EmptyStatement || syntaxKind4 - 779 <= SyntaxKind.List || syntaxKind4 - 788 <= SyntaxKind.List)
			{
				goto IL_0330;
			}
			throw new ArgumentException("expression");
			IL_0330:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax(SyntaxKind.NamedFieldInitializer, null, null, (KeywordSyntax)keyKeyword.Node, (PunctuationSyntax)dotToken.Node, name, (PunctuationSyntax)equalsToken.Node, expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax NamedFieldInitializer(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax name, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return NamedFieldInitializer(default(SyntaxToken), Token(SyntaxKind.DotToken), name, Token(SyntaxKind.EqualsToken), expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax EqualsValue(SyntaxToken equalsToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(equalsToken);
			if (syntaxKind != SyntaxKind.EqualsToken)
			{
				throw new ArgumentException("equalsToken");
			}
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			SyntaxKind syntaxKind2 = value.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("value");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax(SyntaxKind.EqualsValue, null, null, (PunctuationSyntax)equalsToken.Node, value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax EqualsValue(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value)
		{
			return EqualsValue(Token(SyntaxKind.EqualsToken), value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax Parameter(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause, Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax @default)
		{
			if (identifier == null)
			{
				throw new ArgumentNullException("identifier");
			}
			SyntaxKind syntaxKind = identifier.Kind();
			if (syntaxKind != SyntaxKind.ModifiedIdentifier)
			{
				throw new ArgumentException("identifier");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax(SyntaxKind.Parameter, null, null, attributeLists.Node, modifiers.Node, identifier, asClause, @default);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax Parameter(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax identifier)
		{
			return Parameter(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), identifier, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax ModifiedIdentifier(SyntaxToken identifier, SyntaxToken nullable, Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax arrayBounds, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax> arrayRankSpecifiers)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax(SyntaxKind.ModifiedIdentifier, null, null, (IdentifierTokenSyntax)identifier.Node, (PunctuationSyntax)nullable.Node, arrayBounds, arrayRankSpecifiers.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax ModifiedIdentifier(SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax arrayBounds)
		{
			return ModifiedIdentifier(identifier, default(SyntaxToken), arrayBounds, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax>));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax ModifiedIdentifier(SyntaxToken identifier)
		{
			return ModifiedIdentifier(identifier, default(SyntaxToken), null, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax>));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax ModifiedIdentifier(string identifier)
		{
			return ModifiedIdentifier(Identifier(identifier), default(SyntaxToken), null, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax>));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openParenToken, SyntaxTokenList commaTokens, SyntaxToken closeParenToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(openParenToken);
			if (syntaxKind != SyntaxKind.OpenParenToken)
			{
				throw new ArgumentException("openParenToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(closeParenToken);
			if (syntaxKind2 != SyntaxKind.CloseParenToken)
			{
				throw new ArgumentException("closeParenToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax(SyntaxKind.ArrayRankSpecifier, null, null, (PunctuationSyntax)openParenToken.Node, commaTokens.Node, (PunctuationSyntax)closeParenToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax ArrayRankSpecifier()
		{
			return ArrayRankSpecifier(Token(SyntaxKind.OpenParenToken), default(SyntaxTokenList), Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax AttributeList(SyntaxToken lessThanToken, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax> attributes, SyntaxToken greaterThanToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(lessThanToken);
			if (syntaxKind != SyntaxKind.LessThanToken)
			{
				throw new ArgumentException("lessThanToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(greaterThanToken);
			if (syntaxKind2 != SyntaxKind.GreaterThanToken)
			{
				throw new ArgumentException("greaterThanToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax(SyntaxKind.AttributeList, null, null, (PunctuationSyntax)lessThanToken.Node, attributes.Node, (PunctuationSyntax)greaterThanToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax AttributeList(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax> attributes)
		{
			return AttributeList(Token(SyntaxKind.LessThanToken), attributes, Token(SyntaxKind.GreaterThanToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax AttributeList()
		{
			return AttributeList(Token(SyntaxKind.LessThanToken), default(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax>), Token(SyntaxKind.GreaterThanToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax Attribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeTargetSyntax target, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax name, Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax argumentList)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			SyntaxKind syntaxKind = name.Kind();
			if (syntaxKind - 397 > SyntaxKind.EndIfStatement && syntaxKind - 409 > SyntaxKind.List)
			{
				throw new ArgumentException("name");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax(SyntaxKind.Attribute, null, null, target, name, argumentList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax Attribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax name)
		{
			return Attribute(null, name, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeTargetSyntax AttributeTarget(SyntaxToken attributeModifier, SyntaxToken colonToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(attributeModifier);
			if (syntaxKind != SyntaxKind.ModuleKeyword && syntaxKind != SyntaxKind.AssemblyKeyword)
			{
				throw new ArgumentException("attributeModifier");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(colonToken);
			if (syntaxKind2 != SyntaxKind.ColonToken)
			{
				throw new ArgumentException("colonToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeTargetSyntax(SyntaxKind.AttributeTarget, null, null, (KeywordSyntax)attributeModifier.Node, (PunctuationSyntax)colonToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeTargetSyntax AttributeTarget(SyntaxToken attributeModifier)
		{
			return AttributeTarget(attributeModifier, Token(SyntaxKind.ColonToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributesStatementSyntax AttributesStatement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists)
		{
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributesStatementSyntax(SyntaxKind.AttributesStatement, null, null, attributeLists.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributesStatementSyntax AttributesStatement()
		{
			return AttributesStatement(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionStatementSyntax ExpressionStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind = expression.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("expression");
			IL_02d2:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionStatementSyntax(SyntaxKind.ExpressionStatement, null, null, expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.PrintStatementSyntax PrintStatement(SyntaxToken questionToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(questionToken);
			if (syntaxKind != SyntaxKind.QuestionToken)
			{
				throw new ArgumentException("questionToken");
			}
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind2 = expression.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("expression");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.PrintStatementSyntax(SyntaxKind.PrintStatement, null, null, (PunctuationSyntax)questionToken.Node, expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.PrintStatementSyntax PrintStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return PrintStatement(Token(SyntaxKind.QuestionToken), expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileBlockSyntax WhileBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileStatementSyntax whileStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endWhileStatement)
		{
			if (whileStatement == null)
			{
				throw new ArgumentNullException("whileStatement");
			}
			SyntaxKind syntaxKind = whileStatement.Kind();
			if (syntaxKind != SyntaxKind.WhileStatement)
			{
				throw new ArgumentException("whileStatement");
			}
			if (endWhileStatement == null)
			{
				throw new ArgumentNullException("endWhileStatement");
			}
			SyntaxKind syntaxKind2 = endWhileStatement.Kind();
			if (syntaxKind2 != SyntaxKind.EndWhileStatement)
			{
				throw new ArgumentException("endWhileStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileBlockSyntax(SyntaxKind.WhileBlock, null, null, whileStatement, statements.Node, endWhileStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileBlockSyntax WhileBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileStatementSyntax whileStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			return WhileBlock(whileStatement, statements, EndWhileStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileBlockSyntax WhileBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileStatementSyntax whileStatement)
		{
			return WhileBlock(whileStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), EndWhileStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingBlockSyntax UsingBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax usingStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endUsingStatement)
		{
			if (usingStatement == null)
			{
				throw new ArgumentNullException("usingStatement");
			}
			SyntaxKind syntaxKind = usingStatement.Kind();
			if (syntaxKind != SyntaxKind.UsingStatement)
			{
				throw new ArgumentException("usingStatement");
			}
			if (endUsingStatement == null)
			{
				throw new ArgumentNullException("endUsingStatement");
			}
			SyntaxKind syntaxKind2 = endUsingStatement.Kind();
			if (syntaxKind2 != SyntaxKind.EndUsingStatement)
			{
				throw new ArgumentException("endUsingStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingBlockSyntax(SyntaxKind.UsingBlock, null, null, usingStatement, statements.Node, endUsingStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingBlockSyntax UsingBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax usingStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			return UsingBlock(usingStatement, statements, EndUsingStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingBlockSyntax UsingBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax usingStatement)
		{
			return UsingBlock(usingStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), EndUsingStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockBlockSyntax SyncLockBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockStatementSyntax syncLockStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endSyncLockStatement)
		{
			if (syncLockStatement == null)
			{
				throw new ArgumentNullException("syncLockStatement");
			}
			SyntaxKind syntaxKind = syncLockStatement.Kind();
			if (syntaxKind != SyntaxKind.SyncLockStatement)
			{
				throw new ArgumentException("syncLockStatement");
			}
			if (endSyncLockStatement == null)
			{
				throw new ArgumentNullException("endSyncLockStatement");
			}
			SyntaxKind syntaxKind2 = endSyncLockStatement.Kind();
			if (syntaxKind2 != SyntaxKind.EndSyncLockStatement)
			{
				throw new ArgumentException("endSyncLockStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockBlockSyntax(SyntaxKind.SyncLockBlock, null, null, syncLockStatement, statements.Node, endSyncLockStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockBlockSyntax SyncLockBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockStatementSyntax syncLockStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			return SyncLockBlock(syncLockStatement, statements, EndSyncLockStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockBlockSyntax SyncLockBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockStatementSyntax syncLockStatement)
		{
			return SyncLockBlock(syncLockStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), EndSyncLockStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.WithBlockSyntax WithBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.WithStatementSyntax withStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endWithStatement)
		{
			if (withStatement == null)
			{
				throw new ArgumentNullException("withStatement");
			}
			SyntaxKind syntaxKind = withStatement.Kind();
			if (syntaxKind != SyntaxKind.WithStatement)
			{
				throw new ArgumentException("withStatement");
			}
			if (endWithStatement == null)
			{
				throw new ArgumentNullException("endWithStatement");
			}
			SyntaxKind syntaxKind2 = endWithStatement.Kind();
			if (syntaxKind2 != SyntaxKind.EndWithStatement)
			{
				throw new ArgumentException("endWithStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.WithBlockSyntax(SyntaxKind.WithBlock, null, null, withStatement, statements.Node, endWithStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.WithBlockSyntax WithBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.WithStatementSyntax withStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			return WithBlock(withStatement, statements, EndWithStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.WithBlockSyntax WithBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.WithStatementSyntax withStatement)
		{
			return WithBlock(withStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), EndWithStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxTokenList modifiers, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax> declarators)
		{
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LocalDeclarationStatementSyntax(SyntaxKind.LocalDeclarationStatement, null, null, modifiers.Node, declarators.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax LabelStatement(SyntaxToken labelToken, SyntaxToken colonToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(labelToken);
			if (syntaxKind != SyntaxKind.IdentifierToken && syntaxKind != SyntaxKind.IntegerLiteralToken)
			{
				throw new ArgumentException("labelToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(colonToken);
			if (syntaxKind2 != SyntaxKind.ColonToken)
			{
				throw new ArgumentException("colonToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax(SyntaxKind.LabelStatement, null, null, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)labelToken.Node, (PunctuationSyntax)colonToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax LabelStatement(SyntaxToken labelToken)
		{
			return LabelStatement(labelToken, Token(SyntaxKind.ColonToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax LabelStatement(string labelToken)
		{
			return LabelStatement(Identifier(labelToken), Token(SyntaxKind.ColonToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.GoToStatementSyntax GoToStatement(SyntaxToken goToKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax label)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(goToKeyword);
			if (syntaxKind != SyntaxKind.GoToKeyword)
			{
				throw new ArgumentException("goToKeyword");
			}
			if (label == null)
			{
				throw new ArgumentNullException("label");
			}
			SyntaxKind syntaxKind2 = label.Kind();
			if (syntaxKind2 - 150 > SyntaxKind.EmptyStatement)
			{
				throw new ArgumentException("label");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.GoToStatementSyntax(SyntaxKind.GoToStatement, null, null, (KeywordSyntax)goToKeyword.Node, label);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.GoToStatementSyntax GoToStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax label)
		{
			return GoToStatement(Token(SyntaxKind.GoToKeyword), label);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax IdentifierLabel(SyntaxToken labelToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(labelToken);
			if (syntaxKind != SyntaxKind.NextKeyword && syntaxKind != SyntaxKind.IdentifierToken && syntaxKind != SyntaxKind.IntegerLiteralToken)
			{
				throw new ArgumentException("labelToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax(SyntaxKind.IdentifierLabel, null, null, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)labelToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax IdentifierLabel(string labelToken)
		{
			return IdentifierLabel(Identifier(labelToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax NumericLabel(SyntaxToken labelToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(labelToken);
			if (syntaxKind != SyntaxKind.IntegerLiteralToken)
			{
				throw new ArgumentException("labelToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax(SyntaxKind.NumericLabel, null, null, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)labelToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax NumericLabel()
		{
			return NumericLabel(Token(SyntaxKind.IntegerLiteralToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax NextLabel(SyntaxToken labelToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(labelToken);
			if (syntaxKind != SyntaxKind.NextKeyword)
			{
				throw new ArgumentException("labelToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax(SyntaxKind.NextLabel, null, null, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)labelToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax NextLabel()
		{
			return NextLabel(Token(SyntaxKind.NextKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax Label(SyntaxKind kind, SyntaxToken labelToken)
		{
			if (!SyntaxFacts.IsLabel(kind))
			{
				throw new ArgumentException("kind");
			}
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(labelToken, GetLabelLabelTokenKind(kind)))
			{
				throw new ArgumentException("labelToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax(kind, null, null, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)labelToken.Node);
		}

		private static SyntaxKind GetLabelLabelTokenKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.IdentifierLabel => SyntaxKind.IdentifierToken, 
				SyntaxKind.NumericLabel => SyntaxKind.IntegerLiteralToken, 
				SyntaxKind.NextLabel => SyntaxKind.NextKeyword, 
				_ => throw new ArgumentException("LabelToken"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax Label(SyntaxKind kind, string labelToken)
		{
			return Label(kind, Identifier(labelToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.StopOrEndStatementSyntax StopStatement(SyntaxToken stopOrEndKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(stopOrEndKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword && syntaxKind != SyntaxKind.StopKeyword)
			{
				throw new ArgumentException("stopOrEndKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.StopOrEndStatementSyntax(SyntaxKind.StopStatement, null, null, (KeywordSyntax)stopOrEndKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.StopOrEndStatementSyntax EndStatement(SyntaxToken stopOrEndKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(stopOrEndKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword && syntaxKind != SyntaxKind.StopKeyword)
			{
				throw new ArgumentException("stopOrEndKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.StopOrEndStatementSyntax(SyntaxKind.EndStatement, null, null, (KeywordSyntax)stopOrEndKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.StopOrEndStatementSyntax StopOrEndStatement(SyntaxKind kind, SyntaxToken stopOrEndKeyword)
		{
			if (!SyntaxFacts.IsStopOrEndStatement(kind))
			{
				throw new ArgumentException("kind");
			}
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(stopOrEndKeyword);
			if (syntaxKind != SyntaxKind.EndKeyword && syntaxKind != SyntaxKind.StopKeyword)
			{
				throw new ArgumentException("stopOrEndKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.StopOrEndStatementSyntax(kind, null, null, (KeywordSyntax)stopOrEndKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax ExitDoStatement(SyntaxToken exitKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(exitKeyword);
			if (syntaxKind != SyntaxKind.ExitKeyword)
			{
				throw new ArgumentException("exitKeyword");
			}
			switch (VisualBasicExtensions.Kind(blockKeyword))
			{
			default:
				throw new ArgumentException("blockKeyword");
			case SyntaxKind.DoKeyword:
			case SyntaxKind.ForKeyword:
			case SyntaxKind.FunctionKeyword:
			case SyntaxKind.OperatorKeyword:
			case SyntaxKind.PropertyKeyword:
			case SyntaxKind.SelectKeyword:
			case SyntaxKind.SubKeyword:
			case SyntaxKind.TryKeyword:
			case SyntaxKind.WhileKeyword:
				return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax(SyntaxKind.ExitDoStatement, null, null, (KeywordSyntax)exitKeyword.Node, (KeywordSyntax)blockKeyword.Node);
			}
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax ExitDoStatement()
		{
			return ExitDoStatement(Token(SyntaxKind.ExitKeyword), Token(SyntaxKind.DoKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax ExitForStatement(SyntaxToken exitKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(exitKeyword);
			if (syntaxKind != SyntaxKind.ExitKeyword)
			{
				throw new ArgumentException("exitKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.ForKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax(SyntaxKind.ExitForStatement, null, null, (KeywordSyntax)exitKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax ExitForStatement()
		{
			return ExitForStatement(Token(SyntaxKind.ExitKeyword), Token(SyntaxKind.ForKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax ExitSubStatement(SyntaxToken exitKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(exitKeyword);
			if (syntaxKind != SyntaxKind.ExitKeyword)
			{
				throw new ArgumentException("exitKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.SubKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax(SyntaxKind.ExitSubStatement, null, null, (KeywordSyntax)exitKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax ExitSubStatement()
		{
			return ExitSubStatement(Token(SyntaxKind.ExitKeyword), Token(SyntaxKind.SubKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax ExitFunctionStatement(SyntaxToken exitKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(exitKeyword);
			if (syntaxKind != SyntaxKind.ExitKeyword)
			{
				throw new ArgumentException("exitKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.FunctionKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax(SyntaxKind.ExitFunctionStatement, null, null, (KeywordSyntax)exitKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax ExitFunctionStatement()
		{
			return ExitFunctionStatement(Token(SyntaxKind.ExitKeyword), Token(SyntaxKind.FunctionKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax ExitOperatorStatement(SyntaxToken exitKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(exitKeyword);
			if (syntaxKind != SyntaxKind.ExitKeyword)
			{
				throw new ArgumentException("exitKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.OperatorKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax(SyntaxKind.ExitOperatorStatement, null, null, (KeywordSyntax)exitKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax ExitOperatorStatement()
		{
			return ExitOperatorStatement(Token(SyntaxKind.ExitKeyword), Token(SyntaxKind.OperatorKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax ExitPropertyStatement(SyntaxToken exitKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(exitKeyword);
			if (syntaxKind != SyntaxKind.ExitKeyword)
			{
				throw new ArgumentException("exitKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.PropertyKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax(SyntaxKind.ExitPropertyStatement, null, null, (KeywordSyntax)exitKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax ExitPropertyStatement()
		{
			return ExitPropertyStatement(Token(SyntaxKind.ExitKeyword), Token(SyntaxKind.PropertyKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax ExitTryStatement(SyntaxToken exitKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(exitKeyword);
			if (syntaxKind != SyntaxKind.ExitKeyword)
			{
				throw new ArgumentException("exitKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.TryKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax(SyntaxKind.ExitTryStatement, null, null, (KeywordSyntax)exitKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax ExitTryStatement()
		{
			return ExitTryStatement(Token(SyntaxKind.ExitKeyword), Token(SyntaxKind.TryKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax ExitSelectStatement(SyntaxToken exitKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(exitKeyword);
			if (syntaxKind != SyntaxKind.ExitKeyword)
			{
				throw new ArgumentException("exitKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.SelectKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax(SyntaxKind.ExitSelectStatement, null, null, (KeywordSyntax)exitKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax ExitSelectStatement()
		{
			return ExitSelectStatement(Token(SyntaxKind.ExitKeyword), Token(SyntaxKind.SelectKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax ExitWhileStatement(SyntaxToken exitKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(exitKeyword);
			if (syntaxKind != SyntaxKind.ExitKeyword)
			{
				throw new ArgumentException("exitKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.WhileKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax(SyntaxKind.ExitWhileStatement, null, null, (KeywordSyntax)exitKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax ExitWhileStatement()
		{
			return ExitWhileStatement(Token(SyntaxKind.ExitKeyword), Token(SyntaxKind.WhileKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax ExitStatement(SyntaxKind kind, SyntaxToken exitKeyword, SyntaxToken blockKeyword)
		{
			if (!SyntaxFacts.IsExitStatement(kind))
			{
				throw new ArgumentException("kind");
			}
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(exitKeyword);
			if (syntaxKind != SyntaxKind.ExitKeyword)
			{
				throw new ArgumentException("exitKeyword");
			}
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(blockKeyword, GetExitStatementBlockKeywordKind(kind)))
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax(kind, null, null, (KeywordSyntax)exitKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		private static SyntaxKind GetExitStatementBlockKeywordKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.ExitDoStatement => SyntaxKind.DoKeyword, 
				SyntaxKind.ExitForStatement => SyntaxKind.ForKeyword, 
				SyntaxKind.ExitSubStatement => SyntaxKind.SubKeyword, 
				SyntaxKind.ExitFunctionStatement => SyntaxKind.FunctionKeyword, 
				SyntaxKind.ExitOperatorStatement => SyntaxKind.OperatorKeyword, 
				SyntaxKind.ExitPropertyStatement => SyntaxKind.PropertyKeyword, 
				SyntaxKind.ExitTryStatement => SyntaxKind.TryKeyword, 
				SyntaxKind.ExitSelectStatement => SyntaxKind.SelectKeyword, 
				SyntaxKind.ExitWhileStatement => SyntaxKind.WhileKeyword, 
				_ => throw new ArgumentException("BlockKeyword"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax ExitStatement(SyntaxKind kind, SyntaxToken blockKeyword)
		{
			return ExitStatement(kind, Token(SyntaxKind.ExitKeyword), blockKeyword);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax ContinueWhileStatement(SyntaxToken continueKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(continueKeyword);
			if (syntaxKind != SyntaxKind.ContinueKeyword)
			{
				throw new ArgumentException("continueKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.DoKeyword && syntaxKind2 != SyntaxKind.ForKeyword && syntaxKind2 != SyntaxKind.WhileKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax(SyntaxKind.ContinueWhileStatement, null, null, (KeywordSyntax)continueKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax ContinueWhileStatement()
		{
			return ContinueWhileStatement(Token(SyntaxKind.ContinueKeyword), Token(SyntaxKind.WhileKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax ContinueDoStatement(SyntaxToken continueKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(continueKeyword);
			if (syntaxKind != SyntaxKind.ContinueKeyword)
			{
				throw new ArgumentException("continueKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.DoKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax(SyntaxKind.ContinueDoStatement, null, null, (KeywordSyntax)continueKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax ContinueDoStatement()
		{
			return ContinueDoStatement(Token(SyntaxKind.ContinueKeyword), Token(SyntaxKind.DoKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax ContinueForStatement(SyntaxToken continueKeyword, SyntaxToken blockKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(continueKeyword);
			if (syntaxKind != SyntaxKind.ContinueKeyword)
			{
				throw new ArgumentException("continueKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(blockKeyword);
			if (syntaxKind2 != SyntaxKind.ForKeyword)
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax(SyntaxKind.ContinueForStatement, null, null, (KeywordSyntax)continueKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax ContinueForStatement()
		{
			return ContinueForStatement(Token(SyntaxKind.ContinueKeyword), Token(SyntaxKind.ForKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax ContinueStatement(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken blockKeyword)
		{
			if (!SyntaxFacts.IsContinueStatement(kind))
			{
				throw new ArgumentException("kind");
			}
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(continueKeyword);
			if (syntaxKind != SyntaxKind.ContinueKeyword)
			{
				throw new ArgumentException("continueKeyword");
			}
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(blockKeyword, GetContinueStatementBlockKeywordKind(kind)))
			{
				throw new ArgumentException("blockKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax(kind, null, null, (KeywordSyntax)continueKeyword.Node, (KeywordSyntax)blockKeyword.Node);
		}

		private static SyntaxKind GetContinueStatementBlockKeywordKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.ContinueWhileStatement => SyntaxKind.WhileKeyword, 
				SyntaxKind.ContinueDoStatement => SyntaxKind.DoKeyword, 
				SyntaxKind.ContinueForStatement => SyntaxKind.ForKeyword, 
				_ => throw new ArgumentException("BlockKeyword"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax ContinueStatement(SyntaxKind kind, SyntaxToken blockKeyword)
		{
			return ContinueStatement(kind, Token(SyntaxKind.ContinueKeyword), blockKeyword);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(returnKeyword);
			if (syntaxKind != SyntaxKind.ReturnKeyword)
			{
				throw new ArgumentException("returnKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ReturnStatementSyntax(SyntaxKind.ReturnStatement, null, null, (KeywordSyntax)returnKeyword.Node, expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ReturnStatementSyntax ReturnStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return ReturnStatement(Token(SyntaxKind.ReturnKeyword), expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ReturnStatementSyntax ReturnStatement()
		{
			return ReturnStatement(Token(SyntaxKind.ReturnKeyword), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineIfStatementSyntax SingleLineIfStatement(SyntaxToken ifKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition, SyntaxToken thenKeyword, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineElseClauseSyntax elseClause)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(ifKeyword);
			if (syntaxKind != SyntaxKind.IfKeyword)
			{
				throw new ArgumentException("ifKeyword");
			}
			if (condition == null)
			{
				throw new ArgumentNullException("condition");
			}
			SyntaxKind syntaxKind2 = condition.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("condition");
			IL_02ec:
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(thenKeyword);
			if (syntaxKind3 != SyntaxKind.ThenKeyword)
			{
				throw new ArgumentException("thenKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineIfStatementSyntax(SyntaxKind.SingleLineIfStatement, null, null, (KeywordSyntax)ifKeyword.Node, condition, (KeywordSyntax)thenKeyword.Node, statements.Node, elseClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineIfStatementSyntax SingleLineIfStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineElseClauseSyntax elseClause)
		{
			return SingleLineIfStatement(Token(SyntaxKind.IfKeyword), condition, Token(SyntaxKind.ThenKeyword), statements, elseClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineIfStatementSyntax SingleLineIfStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition)
		{
			return SingleLineIfStatement(Token(SyntaxKind.IfKeyword), condition, Token(SyntaxKind.ThenKeyword), default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineElseClauseSyntax SingleLineElseClause(SyntaxToken elseKeyword, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(elseKeyword);
			if (syntaxKind != SyntaxKind.ElseKeyword)
			{
				throw new ArgumentException("elseKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineElseClauseSyntax(SyntaxKind.SingleLineElseClause, null, null, (KeywordSyntax)elseKeyword.Node, statements.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineElseClauseSyntax SingleLineElseClause(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			return SingleLineElseClause(Token(SyntaxKind.ElseKeyword), statements);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineElseClauseSyntax SingleLineElseClause()
		{
			return SingleLineElseClause(Token(SyntaxKind.ElseKeyword), default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineIfBlockSyntax MultiLineIfBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.IfStatementSyntax ifStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfBlockSyntax> elseIfBlocks, Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseBlockSyntax elseBlock, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endIfStatement)
		{
			if (ifStatement == null)
			{
				throw new ArgumentNullException("ifStatement");
			}
			SyntaxKind syntaxKind = ifStatement.Kind();
			if (syntaxKind != SyntaxKind.IfStatement)
			{
				throw new ArgumentException("ifStatement");
			}
			if (endIfStatement == null)
			{
				throw new ArgumentNullException("endIfStatement");
			}
			SyntaxKind syntaxKind2 = endIfStatement.Kind();
			if (syntaxKind2 != SyntaxKind.EndIfStatement)
			{
				throw new ArgumentException("endIfStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineIfBlockSyntax(SyntaxKind.MultiLineIfBlock, null, null, ifStatement, statements.Node, elseIfBlocks.Node, elseBlock, endIfStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineIfBlockSyntax MultiLineIfBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.IfStatementSyntax ifStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfBlockSyntax> elseIfBlocks, Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseBlockSyntax elseBlock)
		{
			return MultiLineIfBlock(ifStatement, statements, elseIfBlocks, elseBlock, EndIfStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineIfBlockSyntax MultiLineIfBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.IfStatementSyntax ifStatement)
		{
			return MultiLineIfBlock(ifStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfBlockSyntax>), null, EndIfStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.IfStatementSyntax IfStatement(SyntaxToken ifKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition, SyntaxToken thenKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(ifKeyword);
			if (syntaxKind != SyntaxKind.IfKeyword)
			{
				throw new ArgumentException("ifKeyword");
			}
			if (condition == null)
			{
				throw new ArgumentNullException("condition");
			}
			SyntaxKind syntaxKind2 = condition.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("condition");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.IfStatementSyntax(SyntaxKind.IfStatement, null, null, (KeywordSyntax)ifKeyword.Node, condition, (KeywordSyntax)thenKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.IfStatementSyntax IfStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition)
		{
			return IfStatement(Token(SyntaxKind.IfKeyword), condition, default(SyntaxToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfBlockSyntax ElseIfBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfStatementSyntax elseIfStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			if (elseIfStatement == null)
			{
				throw new ArgumentNullException("elseIfStatement");
			}
			SyntaxKind syntaxKind = elseIfStatement.Kind();
			if (syntaxKind != SyntaxKind.ElseIfStatement)
			{
				throw new ArgumentException("elseIfStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfBlockSyntax(SyntaxKind.ElseIfBlock, null, null, elseIfStatement, statements.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfBlockSyntax ElseIfBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfStatementSyntax elseIfStatement)
		{
			return ElseIfBlock(elseIfStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfStatementSyntax ElseIfStatement(SyntaxToken elseIfKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition, SyntaxToken thenKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(elseIfKeyword);
			if (syntaxKind != SyntaxKind.ElseIfKeyword)
			{
				throw new ArgumentException("elseIfKeyword");
			}
			if (condition == null)
			{
				throw new ArgumentNullException("condition");
			}
			SyntaxKind syntaxKind2 = condition.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("condition");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfStatementSyntax(SyntaxKind.ElseIfStatement, null, null, (KeywordSyntax)elseIfKeyword.Node, condition, (KeywordSyntax)thenKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfStatementSyntax ElseIfStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition)
		{
			return ElseIfStatement(Token(SyntaxKind.ElseIfKeyword), condition, default(SyntaxToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseBlockSyntax ElseBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseStatementSyntax elseStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			if (elseStatement == null)
			{
				throw new ArgumentNullException("elseStatement");
			}
			SyntaxKind syntaxKind = elseStatement.Kind();
			if (syntaxKind != SyntaxKind.ElseStatement)
			{
				throw new ArgumentException("elseStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseBlockSyntax(SyntaxKind.ElseBlock, null, null, elseStatement, statements.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseBlockSyntax ElseBlock(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			return ElseBlock(ElseStatement(), statements);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseBlockSyntax ElseBlock()
		{
			return ElseBlock(ElseStatement(), default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseStatementSyntax ElseStatement(SyntaxToken elseKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(elseKeyword);
			if (syntaxKind != SyntaxKind.ElseKeyword)
			{
				throw new ArgumentException("elseKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseStatementSyntax(SyntaxKind.ElseStatement, null, null, (KeywordSyntax)elseKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseStatementSyntax ElseStatement()
		{
			return ElseStatement(Token(SyntaxKind.ElseKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TryBlockSyntax TryBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.TryStatementSyntax tryStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax> catchBlocks, Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyBlockSyntax finallyBlock, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endTryStatement)
		{
			if (tryStatement == null)
			{
				throw new ArgumentNullException("tryStatement");
			}
			SyntaxKind syntaxKind = tryStatement.Kind();
			if (syntaxKind != SyntaxKind.TryStatement)
			{
				throw new ArgumentException("tryStatement");
			}
			if (endTryStatement == null)
			{
				throw new ArgumentNullException("endTryStatement");
			}
			SyntaxKind syntaxKind2 = endTryStatement.Kind();
			if (syntaxKind2 != SyntaxKind.EndTryStatement)
			{
				throw new ArgumentException("endTryStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TryBlockSyntax(SyntaxKind.TryBlock, null, null, tryStatement, statements.Node, catchBlocks.Node, finallyBlock, endTryStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TryBlockSyntax TryBlock(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax> catchBlocks, Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyBlockSyntax finallyBlock)
		{
			return TryBlock(TryStatement(), statements, catchBlocks, finallyBlock, EndTryStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TryBlockSyntax TryBlock()
		{
			return TryBlock(TryStatement(), default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax>), null, EndTryStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TryStatementSyntax TryStatement(SyntaxToken tryKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(tryKeyword);
			if (syntaxKind != SyntaxKind.TryKeyword)
			{
				throw new ArgumentException("tryKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TryStatementSyntax(SyntaxKind.TryStatement, null, null, (KeywordSyntax)tryKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TryStatementSyntax TryStatement()
		{
			return TryStatement(Token(SyntaxKind.TryKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax CatchBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax catchStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			if (catchStatement == null)
			{
				throw new ArgumentNullException("catchStatement");
			}
			SyntaxKind syntaxKind = catchStatement.Kind();
			if (syntaxKind != SyntaxKind.CatchStatement)
			{
				throw new ArgumentException("catchStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax(SyntaxKind.CatchBlock, null, null, catchStatement, statements.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax CatchBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax catchStatement)
		{
			return CatchBlock(catchStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax CatchStatement(SyntaxToken catchKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax identifierName, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause, Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchFilterClauseSyntax whenClause)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(catchKeyword);
			if (syntaxKind != SyntaxKind.CatchKeyword)
			{
				throw new ArgumentException("catchKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax(SyntaxKind.CatchStatement, null, null, (KeywordSyntax)catchKeyword.Node, identifierName, asClause, whenClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax CatchStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax identifierName, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause, Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchFilterClauseSyntax whenClause)
		{
			return CatchStatement(Token(SyntaxKind.CatchKeyword), identifierName, asClause, whenClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax CatchStatement()
		{
			return CatchStatement(Token(SyntaxKind.CatchKeyword), null, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax filter)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(whenKeyword);
			if (syntaxKind != SyntaxKind.WhenKeyword)
			{
				throw new ArgumentException("whenKeyword");
			}
			if (filter == null)
			{
				throw new ArgumentNullException("filter");
			}
			SyntaxKind syntaxKind2 = filter.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("filter");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchFilterClauseSyntax(SyntaxKind.CatchFilterClause, null, null, (KeywordSyntax)whenKeyword.Node, filter);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchFilterClauseSyntax CatchFilterClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax filter)
		{
			return CatchFilterClause(Token(SyntaxKind.WhenKeyword), filter);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyBlockSyntax FinallyBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyStatementSyntax finallyStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			if (finallyStatement == null)
			{
				throw new ArgumentNullException("finallyStatement");
			}
			SyntaxKind syntaxKind = finallyStatement.Kind();
			if (syntaxKind != SyntaxKind.FinallyStatement)
			{
				throw new ArgumentException("finallyStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyBlockSyntax(SyntaxKind.FinallyBlock, null, null, finallyStatement, statements.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyBlockSyntax FinallyBlock(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			return FinallyBlock(FinallyStatement(), statements);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyBlockSyntax FinallyBlock()
		{
			return FinallyBlock(FinallyStatement(), default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyStatementSyntax FinallyStatement(SyntaxToken finallyKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(finallyKeyword);
			if (syntaxKind != SyntaxKind.FinallyKeyword)
			{
				throw new ArgumentException("finallyKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyStatementSyntax(SyntaxKind.FinallyStatement, null, null, (KeywordSyntax)finallyKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyStatementSyntax FinallyStatement()
		{
			return FinallyStatement(Token(SyntaxKind.FinallyKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ErrorStatementSyntax ErrorStatement(SyntaxToken errorKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax errorNumber)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(errorKeyword);
			if (syntaxKind != SyntaxKind.ErrorKeyword)
			{
				throw new ArgumentException("errorKeyword");
			}
			if (errorNumber == null)
			{
				throw new ArgumentNullException("errorNumber");
			}
			SyntaxKind syntaxKind2 = errorNumber.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("errorNumber");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ErrorStatementSyntax(SyntaxKind.ErrorStatement, null, null, (KeywordSyntax)errorKeyword.Node, errorNumber);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ErrorStatementSyntax ErrorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax errorNumber)
		{
			return ErrorStatement(Token(SyntaxKind.ErrorKeyword), errorNumber);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax OnErrorGoToZeroStatement(SyntaxToken onKeyword, SyntaxToken errorKeyword, SyntaxToken goToKeyword, SyntaxToken minus, Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax label)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(onKeyword);
			if (syntaxKind != SyntaxKind.OnKeyword)
			{
				throw new ArgumentException("onKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(errorKeyword);
			if (syntaxKind2 != SyntaxKind.ErrorKeyword)
			{
				throw new ArgumentException("errorKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(goToKeyword);
			if (syntaxKind3 != SyntaxKind.GoToKeyword)
			{
				throw new ArgumentException("goToKeyword");
			}
			if (label == null)
			{
				throw new ArgumentNullException("label");
			}
			SyntaxKind syntaxKind4 = label.Kind();
			if (syntaxKind4 - 150 > SyntaxKind.EmptyStatement)
			{
				throw new ArgumentException("label");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax(SyntaxKind.OnErrorGoToZeroStatement, null, null, (KeywordSyntax)onKeyword.Node, (KeywordSyntax)errorKeyword.Node, (KeywordSyntax)goToKeyword.Node, (PunctuationSyntax)minus.Node, label);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax OnErrorGoToZeroStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax label)
		{
			return OnErrorGoToZeroStatement(Token(SyntaxKind.OnKeyword), Token(SyntaxKind.ErrorKeyword), Token(SyntaxKind.GoToKeyword), default(SyntaxToken), label);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax OnErrorGoToMinusOneStatement(SyntaxToken onKeyword, SyntaxToken errorKeyword, SyntaxToken goToKeyword, SyntaxToken minus, Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax label)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(onKeyword);
			if (syntaxKind != SyntaxKind.OnKeyword)
			{
				throw new ArgumentException("onKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(errorKeyword);
			if (syntaxKind2 != SyntaxKind.ErrorKeyword)
			{
				throw new ArgumentException("errorKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(goToKeyword);
			if (syntaxKind3 != SyntaxKind.GoToKeyword)
			{
				throw new ArgumentException("goToKeyword");
			}
			if (label == null)
			{
				throw new ArgumentNullException("label");
			}
			SyntaxKind syntaxKind4 = label.Kind();
			if (syntaxKind4 - 150 > SyntaxKind.EmptyStatement)
			{
				throw new ArgumentException("label");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax(SyntaxKind.OnErrorGoToMinusOneStatement, null, null, (KeywordSyntax)onKeyword.Node, (KeywordSyntax)errorKeyword.Node, (KeywordSyntax)goToKeyword.Node, (PunctuationSyntax)minus.Node, label);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax OnErrorGoToMinusOneStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax label)
		{
			return OnErrorGoToMinusOneStatement(Token(SyntaxKind.OnKeyword), Token(SyntaxKind.ErrorKeyword), Token(SyntaxKind.GoToKeyword), default(SyntaxToken), label);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax OnErrorGoToLabelStatement(SyntaxToken onKeyword, SyntaxToken errorKeyword, SyntaxToken goToKeyword, SyntaxToken minus, Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax label)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(onKeyword);
			if (syntaxKind != SyntaxKind.OnKeyword)
			{
				throw new ArgumentException("onKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(errorKeyword);
			if (syntaxKind2 != SyntaxKind.ErrorKeyword)
			{
				throw new ArgumentException("errorKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(goToKeyword);
			if (syntaxKind3 != SyntaxKind.GoToKeyword)
			{
				throw new ArgumentException("goToKeyword");
			}
			if (label == null)
			{
				throw new ArgumentNullException("label");
			}
			SyntaxKind syntaxKind4 = label.Kind();
			if (syntaxKind4 - 150 > SyntaxKind.EmptyStatement)
			{
				throw new ArgumentException("label");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax(SyntaxKind.OnErrorGoToLabelStatement, null, null, (KeywordSyntax)onKeyword.Node, (KeywordSyntax)errorKeyword.Node, (KeywordSyntax)goToKeyword.Node, (PunctuationSyntax)minus.Node, label);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax OnErrorGoToLabelStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax label)
		{
			return OnErrorGoToLabelStatement(Token(SyntaxKind.OnKeyword), Token(SyntaxKind.ErrorKeyword), Token(SyntaxKind.GoToKeyword), default(SyntaxToken), label);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax OnErrorGoToStatement(SyntaxKind kind, SyntaxToken onKeyword, SyntaxToken errorKeyword, SyntaxToken goToKeyword, SyntaxToken minus, Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax label)
		{
			if (!SyntaxFacts.IsOnErrorGoToStatement(kind))
			{
				throw new ArgumentException("kind");
			}
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(onKeyword);
			if (syntaxKind != SyntaxKind.OnKeyword)
			{
				throw new ArgumentException("onKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(errorKeyword);
			if (syntaxKind2 != SyntaxKind.ErrorKeyword)
			{
				throw new ArgumentException("errorKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(goToKeyword);
			if (syntaxKind3 != SyntaxKind.GoToKeyword)
			{
				throw new ArgumentException("goToKeyword");
			}
			if (label == null)
			{
				throw new ArgumentNullException("label");
			}
			SyntaxKind syntaxKind4 = label.Kind();
			if (syntaxKind4 - 150 > SyntaxKind.EmptyStatement)
			{
				throw new ArgumentException("label");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax(kind, null, null, (KeywordSyntax)onKeyword.Node, (KeywordSyntax)errorKeyword.Node, (KeywordSyntax)goToKeyword.Node, (PunctuationSyntax)minus.Node, label);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax OnErrorGoToStatement(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax label)
		{
			return OnErrorGoToStatement(kind, Token(SyntaxKind.OnKeyword), Token(SyntaxKind.ErrorKeyword), Token(SyntaxKind.GoToKeyword), default(SyntaxToken), label);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorResumeNextStatementSyntax OnErrorResumeNextStatement(SyntaxToken onKeyword, SyntaxToken errorKeyword, SyntaxToken resumeKeyword, SyntaxToken nextKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(onKeyword);
			if (syntaxKind != SyntaxKind.OnKeyword)
			{
				throw new ArgumentException("onKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(errorKeyword);
			if (syntaxKind2 != SyntaxKind.ErrorKeyword)
			{
				throw new ArgumentException("errorKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(resumeKeyword);
			if (syntaxKind3 != SyntaxKind.ResumeKeyword)
			{
				throw new ArgumentException("resumeKeyword");
			}
			SyntaxKind syntaxKind4 = VisualBasicExtensions.Kind(nextKeyword);
			if (syntaxKind4 != SyntaxKind.NextKeyword)
			{
				throw new ArgumentException("nextKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorResumeNextStatementSyntax(SyntaxKind.OnErrorResumeNextStatement, null, null, (KeywordSyntax)onKeyword.Node, (KeywordSyntax)errorKeyword.Node, (KeywordSyntax)resumeKeyword.Node, (KeywordSyntax)nextKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorResumeNextStatementSyntax OnErrorResumeNextStatement()
		{
			return OnErrorResumeNextStatement(Token(SyntaxKind.OnKeyword), Token(SyntaxKind.ErrorKeyword), Token(SyntaxKind.ResumeKeyword), Token(SyntaxKind.NextKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax ResumeStatement(SyntaxToken resumeKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax label)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(resumeKeyword);
			if (syntaxKind != SyntaxKind.ResumeKeyword)
			{
				throw new ArgumentException("resumeKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax(SyntaxKind.ResumeStatement, null, null, (KeywordSyntax)resumeKeyword.Node, label);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax ResumeStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax label)
		{
			return ResumeStatement(SyntaxKind.ResumeStatement, Token(SyntaxKind.ResumeKeyword), label);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax ResumeStatement()
		{
			return ResumeStatement(SyntaxKind.ResumeStatement, Token(SyntaxKind.ResumeKeyword), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax ResumeLabelStatement(SyntaxToken resumeKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax label)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(resumeKeyword);
			if (syntaxKind != SyntaxKind.ResumeKeyword)
			{
				throw new ArgumentException("resumeKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax(SyntaxKind.ResumeLabelStatement, null, null, (KeywordSyntax)resumeKeyword.Node, label);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax ResumeLabelStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax label)
		{
			return ResumeLabelStatement(Token(SyntaxKind.ResumeKeyword), label);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax ResumeLabelStatement()
		{
			return ResumeLabelStatement(Token(SyntaxKind.ResumeKeyword), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax ResumeNextStatement(SyntaxToken resumeKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax label)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(resumeKeyword);
			if (syntaxKind != SyntaxKind.ResumeKeyword)
			{
				throw new ArgumentException("resumeKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax(SyntaxKind.ResumeNextStatement, null, null, (KeywordSyntax)resumeKeyword.Node, label);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax ResumeNextStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax label)
		{
			return ResumeNextStatement(Token(SyntaxKind.ResumeKeyword), label);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax ResumeNextStatement()
		{
			return ResumeNextStatement(Token(SyntaxKind.ResumeKeyword), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax ResumeStatement(SyntaxKind kind, SyntaxToken resumeKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax label)
		{
			if (!SyntaxFacts.IsResumeStatement(kind))
			{
				throw new ArgumentException("kind");
			}
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(resumeKeyword);
			if (syntaxKind != SyntaxKind.ResumeKeyword)
			{
				throw new ArgumentException("resumeKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax(kind, null, null, (KeywordSyntax)resumeKeyword.Node, label);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax ResumeStatement(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax label)
		{
			return ResumeStatement(kind, Token(SyntaxKind.ResumeKeyword), label);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax ResumeStatement(SyntaxKind kind)
		{
			return ResumeStatement(kind, Token(SyntaxKind.ResumeKeyword), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectBlockSyntax SelectBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax selectStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax> caseBlocks, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endSelectStatement)
		{
			if (selectStatement == null)
			{
				throw new ArgumentNullException("selectStatement");
			}
			SyntaxKind syntaxKind = selectStatement.Kind();
			if (syntaxKind != SyntaxKind.SelectStatement)
			{
				throw new ArgumentException("selectStatement");
			}
			if (endSelectStatement == null)
			{
				throw new ArgumentNullException("endSelectStatement");
			}
			SyntaxKind syntaxKind2 = endSelectStatement.Kind();
			if (syntaxKind2 != SyntaxKind.EndSelectStatement)
			{
				throw new ArgumentException("endSelectStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectBlockSyntax(SyntaxKind.SelectBlock, null, null, selectStatement, caseBlocks.Node, endSelectStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectBlockSyntax SelectBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax selectStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax> caseBlocks)
		{
			return SelectBlock(selectStatement, caseBlocks, EndSelectStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectBlockSyntax SelectBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax selectStatement)
		{
			return SelectBlock(selectStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax>), EndSelectStatement());
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax SelectStatement(SyntaxToken selectKeyword, SyntaxToken caseKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(selectKeyword);
			if (syntaxKind != SyntaxKind.SelectKeyword)
			{
				throw new ArgumentException("selectKeyword");
			}
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind2 = expression.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("expression");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax(SyntaxKind.SelectStatement, null, null, (KeywordSyntax)selectKeyword.Node, (KeywordSyntax)caseKeyword.Node, expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax SelectStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return SelectStatement(Token(SyntaxKind.SelectKeyword), default(SyntaxToken), expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax CaseBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax caseStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			if (caseStatement == null)
			{
				throw new ArgumentNullException("caseStatement");
			}
			SyntaxKind syntaxKind = caseStatement.Kind();
			if (syntaxKind - 211 > SyntaxKind.List)
			{
				throw new ArgumentException("caseStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax(SyntaxKind.CaseBlock, null, null, caseStatement, statements.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax CaseBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax caseStatement)
		{
			return CaseBlock(SyntaxKind.CaseBlock, caseStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax CaseElseBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax caseStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			if (caseStatement == null)
			{
				throw new ArgumentNullException("caseStatement");
			}
			SyntaxKind syntaxKind = caseStatement.Kind();
			if (syntaxKind - 211 > SyntaxKind.List)
			{
				throw new ArgumentException("caseStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax(SyntaxKind.CaseElseBlock, null, null, caseStatement, statements.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax CaseElseBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax caseStatement)
		{
			return CaseElseBlock(caseStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax CaseBlock(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax caseStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements)
		{
			if (!SyntaxFacts.IsCaseBlock(kind))
			{
				throw new ArgumentException("kind");
			}
			if (caseStatement == null)
			{
				throw new ArgumentNullException("caseStatement");
			}
			SyntaxKind syntaxKind = caseStatement.Kind();
			if (syntaxKind - 211 > SyntaxKind.List)
			{
				throw new ArgumentException("caseStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax(kind, null, null, caseStatement, statements.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax CaseBlock(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax caseStatement)
		{
			return CaseBlock(kind, caseStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax CaseStatement(SyntaxToken caseKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax> cases)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(caseKeyword);
			if (syntaxKind != SyntaxKind.CaseKeyword)
			{
				throw new ArgumentException("caseKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax(SyntaxKind.CaseStatement, null, null, (KeywordSyntax)caseKeyword.Node, cases.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax CaseStatement(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax> cases)
		{
			return CaseStatement(SyntaxKind.CaseStatement, Token(SyntaxKind.CaseKeyword), cases);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax CaseStatement(params Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax[] cases)
		{
			return CaseStatement(SyntaxKind.CaseStatement, Token(SyntaxKind.CaseKeyword), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax>().AddRange(cases));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax CaseElseStatement(SyntaxToken caseKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax> cases)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(caseKeyword);
			if (syntaxKind != SyntaxKind.CaseKeyword)
			{
				throw new ArgumentException("caseKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax(SyntaxKind.CaseElseStatement, null, null, (KeywordSyntax)caseKeyword.Node, cases.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax CaseElseStatement(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax> cases)
		{
			return CaseElseStatement(Token(SyntaxKind.CaseKeyword), cases);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax CaseElseStatement(params Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax[] cases)
		{
			return CaseElseStatement(Token(SyntaxKind.CaseKeyword), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax>().AddRange(cases));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax CaseStatement(SyntaxKind kind, SyntaxToken caseKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax> cases)
		{
			if (!SyntaxFacts.IsCaseStatement(kind))
			{
				throw new ArgumentException("kind");
			}
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(caseKeyword);
			if (syntaxKind != SyntaxKind.CaseKeyword)
			{
				throw new ArgumentException("caseKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax(kind, null, null, (KeywordSyntax)caseKeyword.Node, cases.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax CaseStatement(SyntaxKind kind, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax> cases)
		{
			return CaseStatement(kind, Token(SyntaxKind.CaseKeyword), cases);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax CaseStatement(SyntaxKind kind, params Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax[] cases)
		{
			return CaseStatement(kind, Token(SyntaxKind.CaseKeyword), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax>().AddRange(cases));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseCaseClauseSyntax ElseCaseClause(SyntaxToken elseKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(elseKeyword);
			if (syntaxKind != SyntaxKind.ElseKeyword)
			{
				throw new ArgumentException("elseKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseCaseClauseSyntax(SyntaxKind.ElseCaseClause, null, null, (KeywordSyntax)elseKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseCaseClauseSyntax ElseCaseClause()
		{
			return ElseCaseClause(Token(SyntaxKind.ElseKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleCaseClauseSyntax SimpleCaseClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			SyntaxKind syntaxKind = value.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("value");
			IL_02d2:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleCaseClauseSyntax(SyntaxKind.SimpleCaseClause, null, null, value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeCaseClauseSyntax RangeCaseClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax lowerBound, SyntaxToken toKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax upperBound)
		{
			if (lowerBound == null)
			{
				throw new ArgumentNullException("lowerBound");
			}
			SyntaxKind syntaxKind = lowerBound.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("lowerBound");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeCaseClauseSyntax(SyntaxKind.RangeCaseClause, null, null, lowerBound, (KeywordSyntax)toKeyword.Node, upperBound);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(toKeyword);
			if (syntaxKind2 != SyntaxKind.ToKeyword)
			{
				throw new ArgumentException("toKeyword");
			}
			if (upperBound == null)
			{
				throw new ArgumentNullException("upperBound");
			}
			SyntaxKind syntaxKind3 = upperBound.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("upperBound");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeCaseClauseSyntax RangeCaseClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax lowerBound, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax upperBound)
		{
			return RangeCaseClause(lowerBound, Token(SyntaxKind.ToKeyword), upperBound);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax CaseEqualsClause(SyntaxToken isKeyword, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value)
		{
			switch (VisualBasicExtensions.Kind(operatorToken))
			{
			default:
				throw new ArgumentException("operatorToken");
			case SyntaxKind.LessThanToken:
			case SyntaxKind.LessThanEqualsToken:
			case SyntaxKind.LessThanGreaterThanToken:
			case SyntaxKind.EqualsToken:
			case SyntaxKind.GreaterThanToken:
			case SyntaxKind.GreaterThanEqualsToken:
				{
					if (value == null)
					{
						throw new ArgumentNullException("value");
					}
					SyntaxKind syntaxKind = value.Kind();
					if (syntaxKind <= SyntaxKind.AwaitExpression)
					{
						switch (syntaxKind)
						{
						case SyntaxKind.KeywordEventContainer:
						case SyntaxKind.WithEventsEventContainer:
						case SyntaxKind.WithEventsPropertyEventContainer:
						case SyntaxKind.IdentifierLabel:
						case SyntaxKind.NumericLabel:
						case SyntaxKind.NextLabel:
						case SyntaxKind.MidExpression:
						case SyntaxKind.CharacterLiteralExpression:
						case SyntaxKind.TrueLiteralExpression:
						case SyntaxKind.FalseLiteralExpression:
						case SyntaxKind.NumericLiteralExpression:
						case SyntaxKind.DateLiteralExpression:
						case SyntaxKind.StringLiteralExpression:
						case SyntaxKind.NothingLiteralExpression:
						case SyntaxKind.ParenthesizedExpression:
						case SyntaxKind.MeExpression:
						case SyntaxKind.MyBaseExpression:
						case SyntaxKind.MyClassExpression:
						case SyntaxKind.GetTypeExpression:
						case SyntaxKind.TypeOfIsExpression:
						case SyntaxKind.TypeOfIsNotExpression:
						case SyntaxKind.GetXmlNamespaceExpression:
						case SyntaxKind.SimpleMemberAccessExpression:
						case SyntaxKind.DictionaryAccessExpression:
						case SyntaxKind.XmlElementAccessExpression:
						case SyntaxKind.XmlDescendantAccessExpression:
						case SyntaxKind.XmlAttributeAccessExpression:
						case SyntaxKind.InvocationExpression:
						case SyntaxKind.ObjectCreationExpression:
						case SyntaxKind.AnonymousObjectCreationExpression:
						case SyntaxKind.ArrayCreationExpression:
						case SyntaxKind.CollectionInitializer:
						case SyntaxKind.CTypeExpression:
						case SyntaxKind.DirectCastExpression:
						case SyntaxKind.TryCastExpression:
						case SyntaxKind.PredefinedCastExpression:
						case SyntaxKind.AddExpression:
						case SyntaxKind.SubtractExpression:
						case SyntaxKind.MultiplyExpression:
						case SyntaxKind.DivideExpression:
						case SyntaxKind.IntegerDivideExpression:
						case SyntaxKind.ExponentiateExpression:
						case SyntaxKind.LeftShiftExpression:
						case SyntaxKind.RightShiftExpression:
						case SyntaxKind.ConcatenateExpression:
						case SyntaxKind.ModuloExpression:
						case SyntaxKind.EqualsExpression:
						case SyntaxKind.NotEqualsExpression:
						case SyntaxKind.LessThanExpression:
						case SyntaxKind.LessThanOrEqualExpression:
						case SyntaxKind.GreaterThanOrEqualExpression:
						case SyntaxKind.GreaterThanExpression:
						case SyntaxKind.IsExpression:
						case SyntaxKind.IsNotExpression:
						case SyntaxKind.LikeExpression:
						case SyntaxKind.OrExpression:
						case SyntaxKind.ExclusiveOrExpression:
						case SyntaxKind.AndExpression:
						case SyntaxKind.OrElseExpression:
						case SyntaxKind.AndAlsoExpression:
						case SyntaxKind.UnaryPlusExpression:
						case SyntaxKind.UnaryMinusExpression:
						case SyntaxKind.NotExpression:
						case SyntaxKind.AddressOfExpression:
						case SyntaxKind.BinaryConditionalExpression:
						case SyntaxKind.TernaryConditionalExpression:
						case SyntaxKind.SingleLineFunctionLambdaExpression:
						case SyntaxKind.SingleLineSubLambdaExpression:
						case SyntaxKind.MultiLineFunctionLambdaExpression:
						case SyntaxKind.MultiLineSubLambdaExpression:
						case SyntaxKind.QueryExpression:
						case SyntaxKind.FunctionAggregation:
						case SyntaxKind.GroupAggregation:
						case SyntaxKind.XmlDocument:
						case SyntaxKind.XmlElement:
						case SyntaxKind.XmlText:
						case SyntaxKind.XmlElementStartTag:
						case SyntaxKind.XmlElementEndTag:
						case SyntaxKind.XmlEmptyElement:
						case SyntaxKind.XmlAttribute:
						case SyntaxKind.XmlString:
						case SyntaxKind.XmlPrefixName:
						case SyntaxKind.XmlName:
						case SyntaxKind.XmlBracketedName:
						case SyntaxKind.XmlComment:
						case SyntaxKind.XmlProcessingInstruction:
						case SyntaxKind.XmlCDataSection:
						case SyntaxKind.XmlEmbeddedExpression:
						case SyntaxKind.ArrayType:
						case SyntaxKind.NullableType:
						case SyntaxKind.PredefinedType:
						case SyntaxKind.IdentifierName:
						case SyntaxKind.GenericName:
						case SyntaxKind.QualifiedName:
						case SyntaxKind.GlobalName:
						case SyntaxKind.CrefOperatorReference:
						case SyntaxKind.QualifiedCrefOperatorReference:
						case SyntaxKind.AwaitExpression:
							goto IL_0308;
						}
					}
					else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
					{
						goto IL_0308;
					}
					throw new ArgumentException("value");
				}
				IL_0308:
				return new Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax(SyntaxKind.CaseEqualsClause, null, null, (KeywordSyntax)isKeyword.Node, (PunctuationSyntax)operatorToken.Node, value);
			}
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax CaseEqualsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value)
		{
			return CaseEqualsClause(default(SyntaxToken), Token(SyntaxKind.EqualsToken), value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax CaseNotEqualsClause(SyntaxToken isKeyword, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind != SyntaxKind.LessThanGreaterThanToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			SyntaxKind syntaxKind2 = value.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("value");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax(SyntaxKind.CaseNotEqualsClause, null, null, (KeywordSyntax)isKeyword.Node, (PunctuationSyntax)operatorToken.Node, value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax CaseNotEqualsClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value)
		{
			return CaseNotEqualsClause(default(SyntaxToken), Token(SyntaxKind.LessThanGreaterThanToken), value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax CaseLessThanClause(SyntaxToken isKeyword, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind != SyntaxKind.LessThanToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			SyntaxKind syntaxKind2 = value.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("value");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax(SyntaxKind.CaseLessThanClause, null, null, (KeywordSyntax)isKeyword.Node, (PunctuationSyntax)operatorToken.Node, value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax CaseLessThanClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value)
		{
			return CaseLessThanClause(default(SyntaxToken), Token(SyntaxKind.LessThanToken), value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax CaseLessThanOrEqualClause(SyntaxToken isKeyword, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind != SyntaxKind.LessThanEqualsToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			SyntaxKind syntaxKind2 = value.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("value");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax(SyntaxKind.CaseLessThanOrEqualClause, null, null, (KeywordSyntax)isKeyword.Node, (PunctuationSyntax)operatorToken.Node, value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax CaseLessThanOrEqualClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value)
		{
			return CaseLessThanOrEqualClause(default(SyntaxToken), Token(SyntaxKind.LessThanEqualsToken), value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax CaseGreaterThanOrEqualClause(SyntaxToken isKeyword, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind != SyntaxKind.GreaterThanEqualsToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			SyntaxKind syntaxKind2 = value.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("value");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax(SyntaxKind.CaseGreaterThanOrEqualClause, null, null, (KeywordSyntax)isKeyword.Node, (PunctuationSyntax)operatorToken.Node, value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax CaseGreaterThanOrEqualClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value)
		{
			return CaseGreaterThanOrEqualClause(default(SyntaxToken), Token(SyntaxKind.GreaterThanEqualsToken), value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax CaseGreaterThanClause(SyntaxToken isKeyword, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind != SyntaxKind.GreaterThanToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			SyntaxKind syntaxKind2 = value.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("value");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax(SyntaxKind.CaseGreaterThanClause, null, null, (KeywordSyntax)isKeyword.Node, (PunctuationSyntax)operatorToken.Node, value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax CaseGreaterThanClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value)
		{
			return CaseGreaterThanClause(default(SyntaxToken), Token(SyntaxKind.GreaterThanToken), value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax RelationalCaseClause(SyntaxKind kind, SyntaxToken isKeyword, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value)
		{
			if (!SyntaxFacts.IsRelationalCaseClause(kind))
			{
				throw new ArgumentException("kind");
			}
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(operatorToken, GetRelationalCaseClauseOperatorTokenKind(kind)))
			{
				throw new ArgumentException("operatorToken");
			}
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			SyntaxKind syntaxKind = value.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02fe;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02fe;
			}
			throw new ArgumentException("value");
			IL_02fe:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax(kind, null, null, (KeywordSyntax)isKeyword.Node, (PunctuationSyntax)operatorToken.Node, value);
		}

		private static SyntaxKind GetRelationalCaseClauseOperatorTokenKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.CaseEqualsClause => SyntaxKind.EqualsToken, 
				SyntaxKind.CaseNotEqualsClause => SyntaxKind.LessThanGreaterThanToken, 
				SyntaxKind.CaseLessThanClause => SyntaxKind.LessThanToken, 
				SyntaxKind.CaseLessThanOrEqualClause => SyntaxKind.LessThanEqualsToken, 
				SyntaxKind.CaseGreaterThanOrEqualClause => SyntaxKind.GreaterThanEqualsToken, 
				SyntaxKind.CaseGreaterThanClause => SyntaxKind.GreaterThanToken, 
				_ => throw new ArgumentException("OperatorToken"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax RelationalCaseClause(SyntaxKind kind, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value)
		{
			return RelationalCaseClause(kind, default(SyntaxToken), operatorToken, value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockStatementSyntax SyncLockStatement(SyntaxToken syncLockKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(syncLockKeyword);
			if (syntaxKind != SyntaxKind.SyncLockKeyword)
			{
				throw new ArgumentException("syncLockKeyword");
			}
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind2 = expression.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("expression");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockStatementSyntax(SyntaxKind.SyncLockStatement, null, null, (KeywordSyntax)syncLockKeyword.Node, expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockStatementSyntax SyncLockStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return SyncLockStatement(Token(SyntaxKind.SyncLockKeyword), expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax SimpleDoLoopBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax doStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax loopStatement)
		{
			if (doStatement == null)
			{
				throw new ArgumentNullException("doStatement");
			}
			SyntaxKind syntaxKind = doStatement.Kind();
			if (syntaxKind - 770 > SyntaxKind.EmptyStatement)
			{
				throw new ArgumentException("doStatement");
			}
			if (loopStatement == null)
			{
				throw new ArgumentNullException("loopStatement");
			}
			SyntaxKind syntaxKind2 = loopStatement.Kind();
			if (syntaxKind2 - 773 > SyntaxKind.EmptyStatement)
			{
				throw new ArgumentException("loopStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax(SyntaxKind.SimpleDoLoopBlock, null, null, doStatement, statements.Node, loopStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax SimpleDoLoopBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax doStatement, Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax loopStatement)
		{
			return SimpleDoLoopBlock(doStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), loopStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax DoWhileLoopBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax doStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax loopStatement)
		{
			if (doStatement == null)
			{
				throw new ArgumentNullException("doStatement");
			}
			SyntaxKind syntaxKind = doStatement.Kind();
			if (syntaxKind != SyntaxKind.DoWhileStatement)
			{
				throw new ArgumentException("doStatement");
			}
			if (loopStatement == null)
			{
				throw new ArgumentNullException("loopStatement");
			}
			SyntaxKind syntaxKind2 = loopStatement.Kind();
			if (syntaxKind2 != SyntaxKind.SimpleLoopStatement)
			{
				throw new ArgumentException("loopStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax(SyntaxKind.DoWhileLoopBlock, null, null, doStatement, statements.Node, loopStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax DoWhileLoopBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax doStatement, Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax loopStatement)
		{
			return DoWhileLoopBlock(doStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), loopStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax DoUntilLoopBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax doStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax loopStatement)
		{
			if (doStatement == null)
			{
				throw new ArgumentNullException("doStatement");
			}
			SyntaxKind syntaxKind = doStatement.Kind();
			if (syntaxKind != SyntaxKind.DoUntilStatement)
			{
				throw new ArgumentException("doStatement");
			}
			if (loopStatement == null)
			{
				throw new ArgumentNullException("loopStatement");
			}
			SyntaxKind syntaxKind2 = loopStatement.Kind();
			if (syntaxKind2 != SyntaxKind.SimpleLoopStatement)
			{
				throw new ArgumentException("loopStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax(SyntaxKind.DoUntilLoopBlock, null, null, doStatement, statements.Node, loopStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax DoUntilLoopBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax doStatement, Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax loopStatement)
		{
			return DoUntilLoopBlock(doStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), loopStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax DoLoopWhileBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax doStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax loopStatement)
		{
			if (doStatement == null)
			{
				throw new ArgumentNullException("doStatement");
			}
			SyntaxKind syntaxKind = doStatement.Kind();
			if (syntaxKind != SyntaxKind.SimpleDoStatement)
			{
				throw new ArgumentException("doStatement");
			}
			if (loopStatement == null)
			{
				throw new ArgumentNullException("loopStatement");
			}
			SyntaxKind syntaxKind2 = loopStatement.Kind();
			if (syntaxKind2 != SyntaxKind.LoopWhileStatement)
			{
				throw new ArgumentException("loopStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax(SyntaxKind.DoLoopWhileBlock, null, null, doStatement, statements.Node, loopStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax DoLoopWhileBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax doStatement, Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax loopStatement)
		{
			return DoLoopWhileBlock(doStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), loopStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax DoLoopUntilBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax doStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax loopStatement)
		{
			if (doStatement == null)
			{
				throw new ArgumentNullException("doStatement");
			}
			SyntaxKind syntaxKind = doStatement.Kind();
			if (syntaxKind != SyntaxKind.SimpleDoStatement)
			{
				throw new ArgumentException("doStatement");
			}
			if (loopStatement == null)
			{
				throw new ArgumentNullException("loopStatement");
			}
			SyntaxKind syntaxKind2 = loopStatement.Kind();
			if (syntaxKind2 != SyntaxKind.LoopUntilStatement)
			{
				throw new ArgumentException("loopStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax(SyntaxKind.DoLoopUntilBlock, null, null, doStatement, statements.Node, loopStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax DoLoopUntilBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax doStatement, Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax loopStatement)
		{
			return DoLoopUntilBlock(doStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), loopStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax DoLoopBlock(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax doStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax loopStatement)
		{
			if (!SyntaxFacts.IsDoLoopBlock(kind))
			{
				throw new ArgumentException("kind");
			}
			if (doStatement == null)
			{
				throw new ArgumentNullException("doStatement");
			}
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(doStatement, GetDoLoopBlockDoStatementKind(kind)))
			{
				throw new ArgumentException("doStatement");
			}
			if (loopStatement == null)
			{
				throw new ArgumentNullException("loopStatement");
			}
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(loopStatement, GetDoLoopBlockLoopStatementKind(kind)))
			{
				throw new ArgumentException("loopStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax(kind, null, null, doStatement, statements.Node, loopStatement);
		}

		private static SyntaxKind GetDoLoopBlockDoStatementKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.SimpleDoLoopBlock => SyntaxKind.SimpleDoStatement, 
				SyntaxKind.DoWhileLoopBlock => SyntaxKind.DoWhileStatement, 
				SyntaxKind.DoUntilLoopBlock => SyntaxKind.DoUntilStatement, 
				SyntaxKind.DoLoopWhileBlock => SyntaxKind.SimpleDoStatement, 
				SyntaxKind.DoLoopUntilBlock => SyntaxKind.SimpleDoStatement, 
				_ => throw new ArgumentException("DoStatement"), 
			};
		}

		private static SyntaxKind GetDoLoopBlockLoopStatementKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.SimpleDoLoopBlock => SyntaxKind.SimpleLoopStatement, 
				SyntaxKind.DoWhileLoopBlock => SyntaxKind.SimpleLoopStatement, 
				SyntaxKind.DoUntilLoopBlock => SyntaxKind.SimpleLoopStatement, 
				SyntaxKind.DoLoopWhileBlock => SyntaxKind.LoopWhileStatement, 
				SyntaxKind.DoLoopUntilBlock => SyntaxKind.LoopUntilStatement, 
				_ => throw new ArgumentException("LoopStatement"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax DoLoopBlock(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax doStatement, Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax loopStatement)
		{
			return DoLoopBlock(kind, doStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), loopStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax SimpleDoStatement(SyntaxToken doKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax whileOrUntilClause)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(doKeyword);
			if (syntaxKind != SyntaxKind.DoKeyword)
			{
				throw new ArgumentException("doKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax(SyntaxKind.SimpleDoStatement, null, null, (KeywordSyntax)doKeyword.Node, whileOrUntilClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax SimpleDoStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax whileOrUntilClause)
		{
			return SimpleDoStatement(Token(SyntaxKind.DoKeyword), whileOrUntilClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax SimpleDoStatement()
		{
			return SimpleDoStatement(Token(SyntaxKind.DoKeyword), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax DoWhileStatement(SyntaxToken doKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax whileOrUntilClause)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(doKeyword);
			if (syntaxKind != SyntaxKind.DoKeyword)
			{
				throw new ArgumentException("doKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax(SyntaxKind.DoWhileStatement, null, null, (KeywordSyntax)doKeyword.Node, whileOrUntilClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax DoWhileStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax whileOrUntilClause)
		{
			return DoWhileStatement(Token(SyntaxKind.DoKeyword), whileOrUntilClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax DoWhileStatement()
		{
			return DoWhileStatement(Token(SyntaxKind.DoKeyword), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax DoUntilStatement(SyntaxToken doKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax whileOrUntilClause)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(doKeyword);
			if (syntaxKind != SyntaxKind.DoKeyword)
			{
				throw new ArgumentException("doKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax(SyntaxKind.DoUntilStatement, null, null, (KeywordSyntax)doKeyword.Node, whileOrUntilClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax DoUntilStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax whileOrUntilClause)
		{
			return DoUntilStatement(Token(SyntaxKind.DoKeyword), whileOrUntilClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax DoUntilStatement()
		{
			return DoUntilStatement(Token(SyntaxKind.DoKeyword), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax DoStatement(SyntaxKind kind, SyntaxToken doKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax whileOrUntilClause)
		{
			if (!SyntaxFacts.IsDoStatement(kind))
			{
				throw new ArgumentException("kind");
			}
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(doKeyword);
			if (syntaxKind != SyntaxKind.DoKeyword)
			{
				throw new ArgumentException("doKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax(kind, null, null, (KeywordSyntax)doKeyword.Node, whileOrUntilClause);
		}

		private static SyntaxKind GetDoStatementWhileOrUntilClauseKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.DoWhileStatement => SyntaxKind.WhileClause, 
				SyntaxKind.DoUntilStatement => SyntaxKind.UntilClause, 
				_ => throw new ArgumentException("WhileOrUntilClause"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax DoStatement(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax whileOrUntilClause)
		{
			return DoStatement(kind, Token(SyntaxKind.DoKeyword), whileOrUntilClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax DoStatement(SyntaxKind kind)
		{
			return DoStatement(kind, Token(SyntaxKind.DoKeyword), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax SimpleLoopStatement(SyntaxToken loopKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax whileOrUntilClause)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(loopKeyword);
			if (syntaxKind != SyntaxKind.LoopKeyword)
			{
				throw new ArgumentException("loopKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax(SyntaxKind.SimpleLoopStatement, null, null, (KeywordSyntax)loopKeyword.Node, whileOrUntilClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax SimpleLoopStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax whileOrUntilClause)
		{
			return SimpleLoopStatement(Token(SyntaxKind.LoopKeyword), whileOrUntilClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax SimpleLoopStatement()
		{
			return SimpleLoopStatement(Token(SyntaxKind.LoopKeyword), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax LoopWhileStatement(SyntaxToken loopKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax whileOrUntilClause)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(loopKeyword);
			if (syntaxKind != SyntaxKind.LoopKeyword)
			{
				throw new ArgumentException("loopKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax(SyntaxKind.LoopWhileStatement, null, null, (KeywordSyntax)loopKeyword.Node, whileOrUntilClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax LoopWhileStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax whileOrUntilClause)
		{
			return LoopWhileStatement(Token(SyntaxKind.LoopKeyword), whileOrUntilClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax LoopWhileStatement()
		{
			return LoopWhileStatement(Token(SyntaxKind.LoopKeyword), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax LoopUntilStatement(SyntaxToken loopKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax whileOrUntilClause)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(loopKeyword);
			if (syntaxKind != SyntaxKind.LoopKeyword)
			{
				throw new ArgumentException("loopKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax(SyntaxKind.LoopUntilStatement, null, null, (KeywordSyntax)loopKeyword.Node, whileOrUntilClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax LoopUntilStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax whileOrUntilClause)
		{
			return LoopUntilStatement(Token(SyntaxKind.LoopKeyword), whileOrUntilClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax LoopUntilStatement()
		{
			return LoopUntilStatement(Token(SyntaxKind.LoopKeyword), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax LoopStatement(SyntaxKind kind, SyntaxToken loopKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax whileOrUntilClause)
		{
			if (!SyntaxFacts.IsLoopStatement(kind))
			{
				throw new ArgumentException("kind");
			}
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(loopKeyword);
			if (syntaxKind != SyntaxKind.LoopKeyword)
			{
				throw new ArgumentException("loopKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax(kind, null, null, (KeywordSyntax)loopKeyword.Node, whileOrUntilClause);
		}

		private static SyntaxKind GetLoopStatementWhileOrUntilClauseKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.LoopWhileStatement => SyntaxKind.WhileClause, 
				SyntaxKind.LoopUntilStatement => SyntaxKind.UntilClause, 
				_ => throw new ArgumentException("WhileOrUntilClause"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax LoopStatement(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax whileOrUntilClause)
		{
			return LoopStatement(kind, Token(SyntaxKind.LoopKeyword), whileOrUntilClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax LoopStatement(SyntaxKind kind)
		{
			return LoopStatement(kind, Token(SyntaxKind.LoopKeyword), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax WhileClause(SyntaxToken whileOrUntilKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(whileOrUntilKeyword);
			if (syntaxKind != SyntaxKind.WhileKeyword)
			{
				throw new ArgumentException("whileOrUntilKeyword");
			}
			if (condition == null)
			{
				throw new ArgumentNullException("condition");
			}
			SyntaxKind syntaxKind2 = condition.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("condition");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax(SyntaxKind.WhileClause, null, null, (KeywordSyntax)whileOrUntilKeyword.Node, condition);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax WhileClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition)
		{
			return WhileClause(Token(SyntaxKind.WhileKeyword), condition);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax UntilClause(SyntaxToken whileOrUntilKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(whileOrUntilKeyword);
			if (syntaxKind != SyntaxKind.UntilKeyword)
			{
				throw new ArgumentException("whileOrUntilKeyword");
			}
			if (condition == null)
			{
				throw new ArgumentNullException("condition");
			}
			SyntaxKind syntaxKind2 = condition.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("condition");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax(SyntaxKind.UntilClause, null, null, (KeywordSyntax)whileOrUntilKeyword.Node, condition);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax UntilClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition)
		{
			return UntilClause(Token(SyntaxKind.UntilKeyword), condition);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax WhileOrUntilClause(SyntaxKind kind, SyntaxToken whileOrUntilKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition)
		{
			if (!SyntaxFacts.IsWhileOrUntilClause(kind))
			{
				throw new ArgumentException("kind");
			}
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(whileOrUntilKeyword, GetWhileOrUntilClauseWhileOrUntilKeywordKind(kind)))
			{
				throw new ArgumentException("whileOrUntilKeyword");
			}
			if (condition == null)
			{
				throw new ArgumentNullException("condition");
			}
			SyntaxKind syntaxKind = condition.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02fe;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02fe;
			}
			throw new ArgumentException("condition");
			IL_02fe:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax(kind, null, null, (KeywordSyntax)whileOrUntilKeyword.Node, condition);
		}

		private static SyntaxKind GetWhileOrUntilClauseWhileOrUntilKeywordKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.WhileClause => SyntaxKind.WhileKeyword, 
				SyntaxKind.UntilClause => SyntaxKind.UntilKeyword, 
				_ => throw new ArgumentException("WhileOrUntilKeyword"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(whileKeyword);
			if (syntaxKind != SyntaxKind.WhileKeyword)
			{
				throw new ArgumentException("whileKeyword");
			}
			if (condition == null)
			{
				throw new ArgumentNullException("condition");
			}
			SyntaxKind syntaxKind2 = condition.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("condition");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileStatementSyntax(SyntaxKind.WhileStatement, null, null, (KeywordSyntax)whileKeyword.Node, condition);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileStatementSyntax WhileStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition)
		{
			return WhileStatement(Token(SyntaxKind.WhileKeyword), condition);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ForBlockSyntax ForBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax forStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.NextStatementSyntax nextStatement)
		{
			if (forStatement == null)
			{
				throw new ArgumentNullException("forStatement");
			}
			SyntaxKind syntaxKind = forStatement.Kind();
			if (syntaxKind != SyntaxKind.ForStatement)
			{
				throw new ArgumentException("forStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ForBlockSyntax(SyntaxKind.ForBlock, null, null, forStatement, statements.Node, nextStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ForBlockSyntax ForBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax forStatement)
		{
			return ForBlock(forStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax ForEachBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax forEachStatement, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.NextStatementSyntax nextStatement)
		{
			if (forEachStatement == null)
			{
				throw new ArgumentNullException("forEachStatement");
			}
			SyntaxKind syntaxKind = forEachStatement.Kind();
			if (syntaxKind != SyntaxKind.ForEachStatement)
			{
				throw new ArgumentException("forEachStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax(SyntaxKind.ForEachBlock, null, null, forEachStatement, statements.Node, nextStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax ForEachBlock(Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax forEachStatement)
		{
			return ForEachBlock(forEachStatement, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax ForStatement(SyntaxToken forKeyword, VisualBasicSyntaxNode controlVariable, SyntaxToken equalsToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax fromValue, SyntaxToken toKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax toValue, Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax stepClause)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(forKeyword);
			if (syntaxKind != SyntaxKind.ForKeyword)
			{
				throw new ArgumentException("forKeyword");
			}
			if (controlVariable == null)
			{
				throw new ArgumentNullException("controlVariable");
			}
			SyntaxKind syntaxKind2 = controlVariable.Kind();
			if (syntaxKind2 <= SyntaxKind.NextLabel)
			{
				if (syntaxKind2 - 114 <= SyntaxKind.EmptyStatement || syntaxKind2 == SyntaxKind.VariableDeclarator || syntaxKind2 - 150 <= SyntaxKind.EmptyStatement)
				{
					goto IL_0301;
				}
			}
			else
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
				case SyntaxKind.XmlCrefAttribute:
				case SyntaxKind.XmlNameAttribute:
				case SyntaxKind.ConditionalAccessExpression:
				case SyntaxKind.NameOfExpression:
				case SyntaxKind.InterpolatedStringExpression:
				case SyntaxKind.TupleExpression:
				case SyntaxKind.TupleType:
					goto IL_0301;
				}
			}
			throw new ArgumentException("controlVariable");
			IL_05ed:
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(toKeyword);
			if (syntaxKind3 != SyntaxKind.ToKeyword)
			{
				throw new ArgumentException("toKeyword");
			}
			if (toValue == null)
			{
				throw new ArgumentNullException("toValue");
			}
			SyntaxKind syntaxKind4 = toValue.Kind();
			if (syntaxKind4 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind4)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_08e6;
				}
			}
			else if (syntaxKind4 - 711 <= SyntaxKind.EmptyStatement || syntaxKind4 - 779 <= SyntaxKind.List || syntaxKind4 - 788 <= SyntaxKind.List)
			{
				goto IL_08e6;
			}
			throw new ArgumentException("toValue");
			IL_0301:
			SyntaxKind syntaxKind5 = VisualBasicExtensions.Kind(equalsToken);
			if (syntaxKind5 != SyntaxKind.EqualsToken)
			{
				throw new ArgumentException("equalsToken");
			}
			if (fromValue == null)
			{
				throw new ArgumentNullException("fromValue");
			}
			SyntaxKind syntaxKind6 = fromValue.Kind();
			if (syntaxKind6 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind6)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05ed;
				}
			}
			else if (syntaxKind6 - 711 <= SyntaxKind.EmptyStatement || syntaxKind6 - 779 <= SyntaxKind.List || syntaxKind6 - 788 <= SyntaxKind.List)
			{
				goto IL_05ed;
			}
			throw new ArgumentException("fromValue");
			IL_08e6:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax(SyntaxKind.ForStatement, null, null, (KeywordSyntax)forKeyword.Node, controlVariable, (PunctuationSyntax)equalsToken.Node, fromValue, (KeywordSyntax)toKeyword.Node, toValue, stepClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax ForStatement(VisualBasicSyntaxNode controlVariable, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax fromValue, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax toValue, Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax stepClause)
		{
			return ForStatement(Token(SyntaxKind.ForKeyword), controlVariable, Token(SyntaxKind.EqualsToken), fromValue, Token(SyntaxKind.ToKeyword), toValue, stepClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax ForStatement(VisualBasicSyntaxNode controlVariable, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax fromValue, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax toValue)
		{
			return ForStatement(Token(SyntaxKind.ForKeyword), controlVariable, Token(SyntaxKind.EqualsToken), fromValue, Token(SyntaxKind.ToKeyword), toValue, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax ForStepClause(SyntaxToken stepKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax stepValue)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(stepKeyword);
			if (syntaxKind != SyntaxKind.StepKeyword)
			{
				throw new ArgumentException("stepKeyword");
			}
			if (stepValue == null)
			{
				throw new ArgumentNullException("stepValue");
			}
			SyntaxKind syntaxKind2 = stepValue.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("stepValue");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax(SyntaxKind.ForStepClause, null, null, (KeywordSyntax)stepKeyword.Node, stepValue);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax ForStepClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax stepValue)
		{
			return ForStepClause(Token(SyntaxKind.StepKeyword), stepValue);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax ForEachStatement(SyntaxToken forKeyword, SyntaxToken eachKeyword, VisualBasicSyntaxNode controlVariable, SyntaxToken inKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(forKeyword);
			if (syntaxKind != SyntaxKind.ForKeyword)
			{
				throw new ArgumentException("forKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(eachKeyword);
			if (syntaxKind2 != SyntaxKind.EachKeyword)
			{
				throw new ArgumentException("eachKeyword");
			}
			if (controlVariable == null)
			{
				throw new ArgumentNullException("controlVariable");
			}
			SyntaxKind syntaxKind3 = controlVariable.Kind();
			if (syntaxKind3 <= SyntaxKind.NextLabel)
			{
				if (syntaxKind3 - 114 <= SyntaxKind.EmptyStatement || syntaxKind3 == SyntaxKind.VariableDeclarator || syntaxKind3 - 150 <= SyntaxKind.EmptyStatement)
				{
					goto IL_031b;
				}
			}
			else
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
				case SyntaxKind.XmlCrefAttribute:
				case SyntaxKind.XmlNameAttribute:
				case SyntaxKind.ConditionalAccessExpression:
				case SyntaxKind.NameOfExpression:
				case SyntaxKind.InterpolatedStringExpression:
				case SyntaxKind.TupleExpression:
				case SyntaxKind.TupleType:
					goto IL_031b;
				}
			}
			throw new ArgumentException("controlVariable");
			IL_0611:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax(SyntaxKind.ForEachStatement, null, null, (KeywordSyntax)forKeyword.Node, (KeywordSyntax)eachKeyword.Node, controlVariable, (KeywordSyntax)inKeyword.Node, expression);
			IL_031b:
			SyntaxKind syntaxKind4 = VisualBasicExtensions.Kind(inKeyword);
			if (syntaxKind4 != SyntaxKind.InKeyword)
			{
				throw new ArgumentException("inKeyword");
			}
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind5 = expression.Kind();
			if (syntaxKind5 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind5)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_0611;
				}
			}
			else if (syntaxKind5 - 711 <= SyntaxKind.EmptyStatement || syntaxKind5 - 779 <= SyntaxKind.List || syntaxKind5 - 788 <= SyntaxKind.List)
			{
				goto IL_0611;
			}
			throw new ArgumentException("expression");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax ForEachStatement(VisualBasicSyntaxNode controlVariable, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return ForEachStatement(Token(SyntaxKind.ForKeyword), Token(SyntaxKind.EachKeyword), controlVariable, Token(SyntaxKind.InKeyword), expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.NextStatementSyntax NextStatement(SyntaxToken nextKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax> controlVariables)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(nextKeyword);
			if (syntaxKind != SyntaxKind.NextKeyword)
			{
				throw new ArgumentException("nextKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.NextStatementSyntax(SyntaxKind.NextStatement, null, null, (KeywordSyntax)nextKeyword.Node, controlVariables.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.NextStatementSyntax NextStatement(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax> controlVariables)
		{
			return NextStatement(Token(SyntaxKind.NextKeyword), controlVariables);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.NextStatementSyntax NextStatement()
		{
			return NextStatement(Token(SyntaxKind.NextKeyword), default(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax>));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax UsingStatement(SyntaxToken usingKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax> variables)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(usingKeyword);
			if (syntaxKind != SyntaxKind.UsingKeyword)
			{
				throw new ArgumentException("usingKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax(SyntaxKind.UsingStatement, null, null, (KeywordSyntax)usingKeyword.Node, expression, variables.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax UsingStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax> variables)
		{
			return UsingStatement(Token(SyntaxKind.UsingKeyword), expression, variables);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax UsingStatement()
		{
			return UsingStatement(Token(SyntaxKind.UsingKeyword), null, default(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax>));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ThrowStatementSyntax ThrowStatement(SyntaxToken throwKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(throwKeyword);
			if (syntaxKind != SyntaxKind.ThrowKeyword)
			{
				throw new ArgumentException("throwKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ThrowStatementSyntax(SyntaxKind.ThrowStatement, null, null, (KeywordSyntax)throwKeyword.Node, expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ThrowStatementSyntax ThrowStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return ThrowStatement(Token(SyntaxKind.ThrowKeyword), expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ThrowStatementSyntax ThrowStatement()
		{
			return ThrowStatement(Token(SyntaxKind.ThrowKeyword), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax SimpleAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_02d2:
			switch (VisualBasicExtensions.Kind(operatorToken))
			{
			default:
				throw new ArgumentException("operatorToken");
			case SyntaxKind.EqualsToken:
			case SyntaxKind.AmpersandEqualsToken:
			case SyntaxKind.AsteriskEqualsToken:
			case SyntaxKind.PlusEqualsToken:
			case SyntaxKind.MinusEqualsToken:
			case SyntaxKind.SlashEqualsToken:
			case SyntaxKind.BackslashEqualsToken:
			case SyntaxKind.CaretEqualsToken:
			case SyntaxKind.LessThanLessThanEqualsToken:
			case SyntaxKind.GreaterThanGreaterThanEqualsToken:
				{
					if (right == null)
					{
						throw new ArgumentNullException("right");
					}
					SyntaxKind syntaxKind2 = right.Kind();
					if (syntaxKind2 <= SyntaxKind.AwaitExpression)
					{
						switch (syntaxKind2)
						{
						case SyntaxKind.KeywordEventContainer:
						case SyntaxKind.WithEventsEventContainer:
						case SyntaxKind.WithEventsPropertyEventContainer:
						case SyntaxKind.IdentifierLabel:
						case SyntaxKind.NumericLabel:
						case SyntaxKind.NextLabel:
						case SyntaxKind.MidExpression:
						case SyntaxKind.CharacterLiteralExpression:
						case SyntaxKind.TrueLiteralExpression:
						case SyntaxKind.FalseLiteralExpression:
						case SyntaxKind.NumericLiteralExpression:
						case SyntaxKind.DateLiteralExpression:
						case SyntaxKind.StringLiteralExpression:
						case SyntaxKind.NothingLiteralExpression:
						case SyntaxKind.ParenthesizedExpression:
						case SyntaxKind.MeExpression:
						case SyntaxKind.MyBaseExpression:
						case SyntaxKind.MyClassExpression:
						case SyntaxKind.GetTypeExpression:
						case SyntaxKind.TypeOfIsExpression:
						case SyntaxKind.TypeOfIsNotExpression:
						case SyntaxKind.GetXmlNamespaceExpression:
						case SyntaxKind.SimpleMemberAccessExpression:
						case SyntaxKind.DictionaryAccessExpression:
						case SyntaxKind.XmlElementAccessExpression:
						case SyntaxKind.XmlDescendantAccessExpression:
						case SyntaxKind.XmlAttributeAccessExpression:
						case SyntaxKind.InvocationExpression:
						case SyntaxKind.ObjectCreationExpression:
						case SyntaxKind.AnonymousObjectCreationExpression:
						case SyntaxKind.ArrayCreationExpression:
						case SyntaxKind.CollectionInitializer:
						case SyntaxKind.CTypeExpression:
						case SyntaxKind.DirectCastExpression:
						case SyntaxKind.TryCastExpression:
						case SyntaxKind.PredefinedCastExpression:
						case SyntaxKind.AddExpression:
						case SyntaxKind.SubtractExpression:
						case SyntaxKind.MultiplyExpression:
						case SyntaxKind.DivideExpression:
						case SyntaxKind.IntegerDivideExpression:
						case SyntaxKind.ExponentiateExpression:
						case SyntaxKind.LeftShiftExpression:
						case SyntaxKind.RightShiftExpression:
						case SyntaxKind.ConcatenateExpression:
						case SyntaxKind.ModuloExpression:
						case SyntaxKind.EqualsExpression:
						case SyntaxKind.NotEqualsExpression:
						case SyntaxKind.LessThanExpression:
						case SyntaxKind.LessThanOrEqualExpression:
						case SyntaxKind.GreaterThanOrEqualExpression:
						case SyntaxKind.GreaterThanExpression:
						case SyntaxKind.IsExpression:
						case SyntaxKind.IsNotExpression:
						case SyntaxKind.LikeExpression:
						case SyntaxKind.OrExpression:
						case SyntaxKind.ExclusiveOrExpression:
						case SyntaxKind.AndExpression:
						case SyntaxKind.OrElseExpression:
						case SyntaxKind.AndAlsoExpression:
						case SyntaxKind.UnaryPlusExpression:
						case SyntaxKind.UnaryMinusExpression:
						case SyntaxKind.NotExpression:
						case SyntaxKind.AddressOfExpression:
						case SyntaxKind.BinaryConditionalExpression:
						case SyntaxKind.TernaryConditionalExpression:
						case SyntaxKind.SingleLineFunctionLambdaExpression:
						case SyntaxKind.SingleLineSubLambdaExpression:
						case SyntaxKind.MultiLineFunctionLambdaExpression:
						case SyntaxKind.MultiLineSubLambdaExpression:
						case SyntaxKind.QueryExpression:
						case SyntaxKind.FunctionAggregation:
						case SyntaxKind.GroupAggregation:
						case SyntaxKind.XmlDocument:
						case SyntaxKind.XmlElement:
						case SyntaxKind.XmlText:
						case SyntaxKind.XmlElementStartTag:
						case SyntaxKind.XmlElementEndTag:
						case SyntaxKind.XmlEmptyElement:
						case SyntaxKind.XmlAttribute:
						case SyntaxKind.XmlString:
						case SyntaxKind.XmlPrefixName:
						case SyntaxKind.XmlName:
						case SyntaxKind.XmlBracketedName:
						case SyntaxKind.XmlComment:
						case SyntaxKind.XmlProcessingInstruction:
						case SyntaxKind.XmlCDataSection:
						case SyntaxKind.XmlEmbeddedExpression:
						case SyntaxKind.ArrayType:
						case SyntaxKind.NullableType:
						case SyntaxKind.PredefinedType:
						case SyntaxKind.IdentifierName:
						case SyntaxKind.GenericName:
						case SyntaxKind.QualifiedName:
						case SyntaxKind.GlobalName:
						case SyntaxKind.CrefOperatorReference:
						case SyntaxKind.QualifiedCrefOperatorReference:
						case SyntaxKind.AwaitExpression:
							goto IL_060e;
						}
					}
					else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
					{
						goto IL_060e;
					}
					throw new ArgumentException("right");
				}
				IL_060e:
				return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax(SyntaxKind.SimpleAssignmentStatement, null, null, left, (PunctuationSyntax)operatorToken.Node, right);
			}
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax SimpleAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return SimpleAssignmentStatement(left, Token(SyntaxKind.EqualsToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax MidAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax(SyntaxKind.MidAssignmentStatement, null, null, left, (PunctuationSyntax)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.EqualsToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax MidAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return MidAssignmentStatement(left, Token(SyntaxKind.EqualsToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax AddAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax(SyntaxKind.AddAssignmentStatement, null, null, left, (PunctuationSyntax)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.PlusEqualsToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax AddAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return AddAssignmentStatement(left, Token(SyntaxKind.PlusEqualsToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax SubtractAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax(SyntaxKind.SubtractAssignmentStatement, null, null, left, (PunctuationSyntax)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.MinusEqualsToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax SubtractAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return SubtractAssignmentStatement(left, Token(SyntaxKind.MinusEqualsToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax MultiplyAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax(SyntaxKind.MultiplyAssignmentStatement, null, null, left, (PunctuationSyntax)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.AsteriskEqualsToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax MultiplyAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return MultiplyAssignmentStatement(left, Token(SyntaxKind.AsteriskEqualsToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax DivideAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax(SyntaxKind.DivideAssignmentStatement, null, null, left, (PunctuationSyntax)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.SlashEqualsToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax DivideAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return DivideAssignmentStatement(left, Token(SyntaxKind.SlashEqualsToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax IntegerDivideAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax(SyntaxKind.IntegerDivideAssignmentStatement, null, null, left, (PunctuationSyntax)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.BackslashEqualsToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax IntegerDivideAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return IntegerDivideAssignmentStatement(left, Token(SyntaxKind.BackslashEqualsToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax ExponentiateAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax(SyntaxKind.ExponentiateAssignmentStatement, null, null, left, (PunctuationSyntax)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.CaretEqualsToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax ExponentiateAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return ExponentiateAssignmentStatement(left, Token(SyntaxKind.CaretEqualsToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax LeftShiftAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax(SyntaxKind.LeftShiftAssignmentStatement, null, null, left, (PunctuationSyntax)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.LessThanLessThanEqualsToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax LeftShiftAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return LeftShiftAssignmentStatement(left, Token(SyntaxKind.LessThanLessThanEqualsToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax RightShiftAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax(SyntaxKind.RightShiftAssignmentStatement, null, null, left, (PunctuationSyntax)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.GreaterThanGreaterThanEqualsToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax RightShiftAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return RightShiftAssignmentStatement(left, Token(SyntaxKind.GreaterThanGreaterThanEqualsToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax ConcatenateAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax(SyntaxKind.ConcatenateAssignmentStatement, null, null, left, (PunctuationSyntax)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.AmpersandEqualsToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax ConcatenateAssignmentStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return ConcatenateAssignmentStatement(left, Token(SyntaxKind.AmpersandEqualsToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax AssignmentStatement(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (!SyntaxFacts.IsAssignmentStatement(kind))
			{
				throw new ArgumentException("kind");
			}
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02e5;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02e5;
			}
			throw new ArgumentException("left");
			IL_05d0:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax(kind, null, null, left, (PunctuationSyntax)operatorToken.Node, right);
			IL_02e5:
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(operatorToken, GetAssignmentStatementOperatorTokenKind(kind)))
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind2 = right.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05d0;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_05d0;
			}
			throw new ArgumentException("right");
		}

		private static SyntaxKind GetAssignmentStatementOperatorTokenKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.SimpleAssignmentStatement => SyntaxKind.EqualsToken, 
				SyntaxKind.MidAssignmentStatement => SyntaxKind.EqualsToken, 
				SyntaxKind.AddAssignmentStatement => SyntaxKind.PlusEqualsToken, 
				SyntaxKind.SubtractAssignmentStatement => SyntaxKind.MinusEqualsToken, 
				SyntaxKind.MultiplyAssignmentStatement => SyntaxKind.AsteriskEqualsToken, 
				SyntaxKind.DivideAssignmentStatement => SyntaxKind.SlashEqualsToken, 
				SyntaxKind.IntegerDivideAssignmentStatement => SyntaxKind.BackslashEqualsToken, 
				SyntaxKind.ExponentiateAssignmentStatement => SyntaxKind.CaretEqualsToken, 
				SyntaxKind.LeftShiftAssignmentStatement => SyntaxKind.LessThanLessThanEqualsToken, 
				SyntaxKind.RightShiftAssignmentStatement => SyntaxKind.GreaterThanGreaterThanEqualsToken, 
				SyntaxKind.ConcatenateAssignmentStatement => SyntaxKind.AmpersandEqualsToken, 
				_ => throw new ArgumentException("OperatorToken"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax MidExpression(SyntaxToken mid, Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax argumentList)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(mid);
			if (syntaxKind != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("mid");
			}
			if (argumentList == null)
			{
				throw new ArgumentNullException("argumentList");
			}
			SyntaxKind syntaxKind2 = argumentList.Kind();
			if (syntaxKind2 != SyntaxKind.ArgumentList)
			{
				throw new ArgumentException("argumentList");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax(SyntaxKind.MidExpression, null, null, (IdentifierTokenSyntax)mid.Node, argumentList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax MidExpression(string mid, Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax argumentList)
		{
			return MidExpression(Identifier(mid), argumentList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CallStatementSyntax CallStatement(SyntaxToken callKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax invocation)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(callKeyword);
			if (syntaxKind != SyntaxKind.CallKeyword)
			{
				throw new ArgumentException("callKeyword");
			}
			if (invocation == null)
			{
				throw new ArgumentNullException("invocation");
			}
			SyntaxKind syntaxKind2 = invocation.Kind();
			if (syntaxKind2 != SyntaxKind.SimpleMemberAccessExpression && syntaxKind2 != SyntaxKind.InvocationExpression)
			{
				throw new ArgumentException("invocation");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CallStatementSyntax(SyntaxKind.CallStatement, null, null, (KeywordSyntax)callKeyword.Node, invocation);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CallStatementSyntax CallStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax invocation)
		{
			return CallStatement(Token(SyntaxKind.CallKeyword), invocation);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax AddHandlerStatement(SyntaxToken addHandlerOrRemoveHandlerKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax eventExpression, SyntaxToken commaToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax delegateExpression)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(addHandlerOrRemoveHandlerKeyword);
			if (syntaxKind != SyntaxKind.AddHandlerKeyword && syntaxKind != SyntaxKind.RemoveHandlerKeyword)
			{
				throw new ArgumentException("addHandlerOrRemoveHandlerKeyword");
			}
			if (eventExpression == null)
			{
				throw new ArgumentNullException("eventExpression");
			}
			SyntaxKind syntaxKind2 = eventExpression.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02f4;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02f4;
			}
			throw new ArgumentException("eventExpression");
			IL_05e0:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax(SyntaxKind.AddHandlerStatement, null, null, (KeywordSyntax)addHandlerOrRemoveHandlerKeyword.Node, eventExpression, (PunctuationSyntax)commaToken.Node, delegateExpression);
			IL_02f4:
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(commaToken);
			if (syntaxKind3 != SyntaxKind.CommaToken)
			{
				throw new ArgumentException("commaToken");
			}
			if (delegateExpression == null)
			{
				throw new ArgumentNullException("delegateExpression");
			}
			SyntaxKind syntaxKind4 = delegateExpression.Kind();
			if (syntaxKind4 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind4)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05e0;
				}
			}
			else if (syntaxKind4 - 711 <= SyntaxKind.EmptyStatement || syntaxKind4 - 779 <= SyntaxKind.List || syntaxKind4 - 788 <= SyntaxKind.List)
			{
				goto IL_05e0;
			}
			throw new ArgumentException("delegateExpression");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax AddHandlerStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax eventExpression, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax delegateExpression)
		{
			return AddHandlerStatement(Token(SyntaxKind.AddHandlerKeyword), eventExpression, Token(SyntaxKind.CommaToken), delegateExpression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax RemoveHandlerStatement(SyntaxToken addHandlerOrRemoveHandlerKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax eventExpression, SyntaxToken commaToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax delegateExpression)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(addHandlerOrRemoveHandlerKeyword);
			if (syntaxKind != SyntaxKind.RemoveHandlerKeyword)
			{
				throw new ArgumentException("addHandlerOrRemoveHandlerKeyword");
			}
			if (eventExpression == null)
			{
				throw new ArgumentNullException("eventExpression");
			}
			SyntaxKind syntaxKind2 = eventExpression.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("eventExpression");
			IL_05d8:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax(SyntaxKind.RemoveHandlerStatement, null, null, (KeywordSyntax)addHandlerOrRemoveHandlerKeyword.Node, eventExpression, (PunctuationSyntax)commaToken.Node, delegateExpression);
			IL_02ec:
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(commaToken);
			if (syntaxKind3 != SyntaxKind.CommaToken)
			{
				throw new ArgumentException("commaToken");
			}
			if (delegateExpression == null)
			{
				throw new ArgumentNullException("delegateExpression");
			}
			SyntaxKind syntaxKind4 = delegateExpression.Kind();
			if (syntaxKind4 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind4)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05d8;
				}
			}
			else if (syntaxKind4 - 711 <= SyntaxKind.EmptyStatement || syntaxKind4 - 779 <= SyntaxKind.List || syntaxKind4 - 788 <= SyntaxKind.List)
			{
				goto IL_05d8;
			}
			throw new ArgumentException("delegateExpression");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax RemoveHandlerStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax eventExpression, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax delegateExpression)
		{
			return RemoveHandlerStatement(Token(SyntaxKind.RemoveHandlerKeyword), eventExpression, Token(SyntaxKind.CommaToken), delegateExpression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax AddRemoveHandlerStatement(SyntaxKind kind, SyntaxToken addHandlerOrRemoveHandlerKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax eventExpression, SyntaxToken commaToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax delegateExpression)
		{
			if (!SyntaxFacts.IsAddRemoveHandlerStatement(kind))
			{
				throw new ArgumentException("kind");
			}
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(addHandlerOrRemoveHandlerKeyword, GetAddRemoveHandlerStatementAddHandlerOrRemoveHandlerKeywordKind(kind)))
			{
				throw new ArgumentException("addHandlerOrRemoveHandlerKeyword");
			}
			if (eventExpression == null)
			{
				throw new ArgumentNullException("eventExpression");
			}
			SyntaxKind syntaxKind = eventExpression.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02fe;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02fe;
			}
			throw new ArgumentException("eventExpression");
			IL_05ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax(kind, null, null, (KeywordSyntax)addHandlerOrRemoveHandlerKeyword.Node, eventExpression, (PunctuationSyntax)commaToken.Node, delegateExpression);
			IL_02fe:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(commaToken);
			if (syntaxKind2 != SyntaxKind.CommaToken)
			{
				throw new ArgumentException("commaToken");
			}
			if (delegateExpression == null)
			{
				throw new ArgumentNullException("delegateExpression");
			}
			SyntaxKind syntaxKind3 = delegateExpression.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05ec;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05ec;
			}
			throw new ArgumentException("delegateExpression");
		}

		private static SyntaxKind GetAddRemoveHandlerStatementAddHandlerOrRemoveHandlerKeywordKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.AddHandlerStatement => SyntaxKind.AddHandlerKeyword, 
				SyntaxKind.RemoveHandlerStatement => SyntaxKind.RemoveHandlerKeyword, 
				_ => throw new ArgumentException("AddHandlerOrRemoveHandlerKeyword"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax AddRemoveHandlerStatement(SyntaxKind kind, SyntaxToken addHandlerOrRemoveHandlerKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax eventExpression, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax delegateExpression)
		{
			return AddRemoveHandlerStatement(kind, addHandlerOrRemoveHandlerKeyword, eventExpression, Token(SyntaxKind.CommaToken), delegateExpression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RaiseEventStatementSyntax RaiseEventStatement(SyntaxToken raiseEventKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax name, Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax argumentList)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(raiseEventKeyword);
			if (syntaxKind != SyntaxKind.RaiseEventKeyword)
			{
				throw new ArgumentException("raiseEventKeyword");
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			SyntaxKind syntaxKind2 = name.Kind();
			if (syntaxKind2 != SyntaxKind.IdentifierName)
			{
				throw new ArgumentException("name");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.RaiseEventStatementSyntax(SyntaxKind.RaiseEventStatement, null, null, (KeywordSyntax)raiseEventKeyword.Node, name, argumentList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RaiseEventStatementSyntax RaiseEventStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax name, Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax argumentList)
		{
			return RaiseEventStatement(Token(SyntaxKind.RaiseEventKeyword), name, argumentList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RaiseEventStatementSyntax RaiseEventStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax name)
		{
			return RaiseEventStatement(Token(SyntaxKind.RaiseEventKeyword), name, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.WithStatementSyntax WithStatement(SyntaxToken withKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(withKeyword);
			if (syntaxKind != SyntaxKind.WithKeyword)
			{
				throw new ArgumentException("withKeyword");
			}
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind2 = expression.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("expression");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.WithStatementSyntax(SyntaxKind.WithStatement, null, null, (KeywordSyntax)withKeyword.Node, expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.WithStatementSyntax WithStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return WithStatement(Token(SyntaxKind.WithKeyword), expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax ReDimStatement(SyntaxToken reDimKeyword, SyntaxToken preserveKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax> clauses)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(reDimKeyword);
			if (syntaxKind != SyntaxKind.ReDimKeyword)
			{
				throw new ArgumentException("reDimKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax(SyntaxKind.ReDimStatement, null, null, (KeywordSyntax)reDimKeyword.Node, (KeywordSyntax)preserveKeyword.Node, clauses.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax ReDimStatement(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax> clauses)
		{
			return ReDimStatement(SyntaxKind.ReDimStatement, Token(SyntaxKind.ReDimKeyword), default(SyntaxToken), clauses);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax ReDimStatement(params Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax[] clauses)
		{
			return ReDimStatement(SyntaxKind.ReDimStatement, Token(SyntaxKind.ReDimKeyword), default(SyntaxToken), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax>().AddRange(clauses));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax ReDimPreserveStatement(SyntaxToken reDimKeyword, SyntaxToken preserveKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax> clauses)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(reDimKeyword);
			if (syntaxKind != SyntaxKind.ReDimKeyword)
			{
				throw new ArgumentException("reDimKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax(SyntaxKind.ReDimPreserveStatement, null, null, (KeywordSyntax)reDimKeyword.Node, (KeywordSyntax)preserveKeyword.Node, clauses.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax ReDimPreserveStatement(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax> clauses)
		{
			return ReDimPreserveStatement(Token(SyntaxKind.ReDimKeyword), default(SyntaxToken), clauses);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax ReDimPreserveStatement(params Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax[] clauses)
		{
			return ReDimPreserveStatement(Token(SyntaxKind.ReDimKeyword), default(SyntaxToken), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax>().AddRange(clauses));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax ReDimStatement(SyntaxKind kind, SyntaxToken reDimKeyword, SyntaxToken preserveKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax> clauses)
		{
			if (!SyntaxFacts.IsReDimStatement(kind))
			{
				throw new ArgumentException("kind");
			}
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(reDimKeyword);
			if (syntaxKind != SyntaxKind.ReDimKeyword)
			{
				throw new ArgumentException("reDimKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax(kind, null, null, (KeywordSyntax)reDimKeyword.Node, (KeywordSyntax)preserveKeyword.Node, clauses.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax ReDimStatement(SyntaxKind kind, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax> clauses)
		{
			return ReDimStatement(kind, Token(SyntaxKind.ReDimKeyword), default(SyntaxToken), clauses);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax ReDimStatement(SyntaxKind kind, params Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax[] clauses)
		{
			return ReDimStatement(kind, Token(SyntaxKind.ReDimKeyword), default(SyntaxToken), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax>().AddRange(clauses));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax RedimClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax arrayBounds)
		{
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind = expression.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("expression");
			IL_02d2:
			if (arrayBounds == null)
			{
				throw new ArgumentNullException("arrayBounds");
			}
			SyntaxKind syntaxKind2 = arrayBounds.Kind();
			if (syntaxKind2 != SyntaxKind.ArgumentList)
			{
				throw new ArgumentException("arrayBounds");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax(SyntaxKind.RedimClause, null, null, expression, arrayBounds);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EraseStatementSyntax EraseStatement(SyntaxToken eraseKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax> expressions)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(eraseKeyword);
			if (syntaxKind != SyntaxKind.EraseKeyword)
			{
				throw new ArgumentException("eraseKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EraseStatementSyntax(SyntaxKind.EraseStatement, null, null, (KeywordSyntax)eraseKeyword.Node, expressions.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EraseStatementSyntax EraseStatement(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax> expressions)
		{
			return EraseStatement(Token(SyntaxKind.EraseKeyword), expressions);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EraseStatementSyntax EraseStatement(params Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax[] expressions)
		{
			return EraseStatement(Token(SyntaxKind.EraseKeyword), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax>().AddRange(expressions));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax CharacterLiteralExpression(SyntaxToken token)
		{
			switch (VisualBasicExtensions.Kind(token))
			{
			default:
				throw new ArgumentException("token");
			case SyntaxKind.FalseKeyword:
			case SyntaxKind.NothingKeyword:
			case SyntaxKind.TrueKeyword:
			case SyntaxKind.IntegerLiteralToken:
			case SyntaxKind.FloatingLiteralToken:
			case SyntaxKind.DecimalLiteralToken:
			case SyntaxKind.DateLiteralToken:
			case SyntaxKind.StringLiteralToken:
			case SyntaxKind.CharacterLiteralToken:
				return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax(SyntaxKind.CharacterLiteralExpression, null, null, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)token.Node);
			}
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax TrueLiteralExpression(SyntaxToken token)
		{
			switch (VisualBasicExtensions.Kind(token))
			{
			default:
				throw new ArgumentException("token");
			case SyntaxKind.FalseKeyword:
			case SyntaxKind.NothingKeyword:
			case SyntaxKind.TrueKeyword:
			case SyntaxKind.IntegerLiteralToken:
			case SyntaxKind.FloatingLiteralToken:
			case SyntaxKind.DecimalLiteralToken:
			case SyntaxKind.DateLiteralToken:
			case SyntaxKind.StringLiteralToken:
			case SyntaxKind.CharacterLiteralToken:
				return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax(SyntaxKind.TrueLiteralExpression, null, null, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)token.Node);
			}
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax FalseLiteralExpression(SyntaxToken token)
		{
			switch (VisualBasicExtensions.Kind(token))
			{
			default:
				throw new ArgumentException("token");
			case SyntaxKind.FalseKeyword:
			case SyntaxKind.NothingKeyword:
			case SyntaxKind.TrueKeyword:
			case SyntaxKind.IntegerLiteralToken:
			case SyntaxKind.FloatingLiteralToken:
			case SyntaxKind.DecimalLiteralToken:
			case SyntaxKind.DateLiteralToken:
			case SyntaxKind.StringLiteralToken:
			case SyntaxKind.CharacterLiteralToken:
				return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax(SyntaxKind.FalseLiteralExpression, null, null, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)token.Node);
			}
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax NumericLiteralExpression(SyntaxToken token)
		{
			switch (VisualBasicExtensions.Kind(token))
			{
			default:
				throw new ArgumentException("token");
			case SyntaxKind.FalseKeyword:
			case SyntaxKind.NothingKeyword:
			case SyntaxKind.TrueKeyword:
			case SyntaxKind.IntegerLiteralToken:
			case SyntaxKind.FloatingLiteralToken:
			case SyntaxKind.DecimalLiteralToken:
			case SyntaxKind.DateLiteralToken:
			case SyntaxKind.StringLiteralToken:
			case SyntaxKind.CharacterLiteralToken:
				return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax(SyntaxKind.NumericLiteralExpression, null, null, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)token.Node);
			}
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax DateLiteralExpression(SyntaxToken token)
		{
			switch (VisualBasicExtensions.Kind(token))
			{
			default:
				throw new ArgumentException("token");
			case SyntaxKind.FalseKeyword:
			case SyntaxKind.NothingKeyword:
			case SyntaxKind.TrueKeyword:
			case SyntaxKind.IntegerLiteralToken:
			case SyntaxKind.FloatingLiteralToken:
			case SyntaxKind.DecimalLiteralToken:
			case SyntaxKind.DateLiteralToken:
			case SyntaxKind.StringLiteralToken:
			case SyntaxKind.CharacterLiteralToken:
				return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax(SyntaxKind.DateLiteralExpression, null, null, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)token.Node);
			}
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax StringLiteralExpression(SyntaxToken token)
		{
			switch (VisualBasicExtensions.Kind(token))
			{
			default:
				throw new ArgumentException("token");
			case SyntaxKind.FalseKeyword:
			case SyntaxKind.NothingKeyword:
			case SyntaxKind.TrueKeyword:
			case SyntaxKind.IntegerLiteralToken:
			case SyntaxKind.FloatingLiteralToken:
			case SyntaxKind.DecimalLiteralToken:
			case SyntaxKind.DateLiteralToken:
			case SyntaxKind.StringLiteralToken:
			case SyntaxKind.CharacterLiteralToken:
				return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax(SyntaxKind.StringLiteralExpression, null, null, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)token.Node);
			}
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax NothingLiteralExpression(SyntaxToken token)
		{
			switch (VisualBasicExtensions.Kind(token))
			{
			default:
				throw new ArgumentException("token");
			case SyntaxKind.FalseKeyword:
			case SyntaxKind.NothingKeyword:
			case SyntaxKind.TrueKeyword:
			case SyntaxKind.IntegerLiteralToken:
			case SyntaxKind.FloatingLiteralToken:
			case SyntaxKind.DecimalLiteralToken:
			case SyntaxKind.DateLiteralToken:
			case SyntaxKind.StringLiteralToken:
			case SyntaxKind.CharacterLiteralToken:
				return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax(SyntaxKind.NothingLiteralExpression, null, null, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)token.Node);
			}
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
		{
			if (!SyntaxFacts.IsLiteralExpression(kind))
			{
				throw new ArgumentException("kind");
			}
			switch (VisualBasicExtensions.Kind(token))
			{
			default:
				throw new ArgumentException("token");
			case SyntaxKind.FalseKeyword:
			case SyntaxKind.NothingKeyword:
			case SyntaxKind.TrueKeyword:
			case SyntaxKind.IntegerLiteralToken:
			case SyntaxKind.FloatingLiteralToken:
			case SyntaxKind.DecimalLiteralToken:
			case SyntaxKind.DateLiteralToken:
			case SyntaxKind.StringLiteralToken:
			case SyntaxKind.CharacterLiteralToken:
				return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax(kind, null, null, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)token.Node);
			}
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, SyntaxToken closeParenToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(openParenToken);
			if (syntaxKind != SyntaxKind.OpenParenToken)
			{
				throw new ArgumentException("openParenToken");
			}
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind2 = expression.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("expression");
			IL_02ec:
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(closeParenToken);
			if (syntaxKind3 != SyntaxKind.CloseParenToken)
			{
				throw new ArgumentException("closeParenToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ParenthesizedExpressionSyntax(SyntaxKind.ParenthesizedExpression, null, null, (PunctuationSyntax)openParenToken.Node, expression, (PunctuationSyntax)closeParenToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ParenthesizedExpressionSyntax ParenthesizedExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return ParenthesizedExpression(Token(SyntaxKind.OpenParenToken), expression, Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleExpressionSyntax TupleExpression(SyntaxToken openParenToken, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax> arguments, SyntaxToken closeParenToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(openParenToken);
			if (syntaxKind != SyntaxKind.OpenParenToken)
			{
				throw new ArgumentException("openParenToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(closeParenToken);
			if (syntaxKind2 != SyntaxKind.CloseParenToken)
			{
				throw new ArgumentException("closeParenToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleExpressionSyntax(SyntaxKind.TupleExpression, null, null, (PunctuationSyntax)openParenToken.Node, arguments.Node, (PunctuationSyntax)closeParenToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleExpressionSyntax TupleExpression(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax> arguments)
		{
			return TupleExpression(Token(SyntaxKind.OpenParenToken), arguments, Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleExpressionSyntax TupleExpression(params Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax[] arguments)
		{
			return TupleExpression(Token(SyntaxKind.OpenParenToken), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax>().AddRange(arguments), Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleTypeSyntax TupleType(SyntaxToken openParenToken, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleElementSyntax> elements, SyntaxToken closeParenToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(openParenToken);
			if (syntaxKind != SyntaxKind.OpenParenToken)
			{
				throw new ArgumentException("openParenToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(closeParenToken);
			if (syntaxKind2 != SyntaxKind.CloseParenToken)
			{
				throw new ArgumentException("closeParenToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleTypeSyntax(SyntaxKind.TupleType, null, null, (PunctuationSyntax)openParenToken.Node, elements.Node, (PunctuationSyntax)closeParenToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleTypeSyntax TupleType(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleElementSyntax> elements)
		{
			return TupleType(Token(SyntaxKind.OpenParenToken), elements, Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleTypeSyntax TupleType(params Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleElementSyntax[] elements)
		{
			return TupleType(Token(SyntaxKind.OpenParenToken), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleElementSyntax>().AddRange(elements), Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypedTupleElementSyntax TypedTupleElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			SyntaxKind syntaxKind = type.Kind();
			if (syntaxKind - 396 > SyntaxKind.EndUsingStatement && syntaxKind - 409 > SyntaxKind.List && syntaxKind != SyntaxKind.TupleType)
			{
				throw new ArgumentException("type");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TypedTupleElementSyntax(SyntaxKind.TypedTupleElement, null, null, type);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedTupleElementSyntax NamedTupleElement(SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedTupleElementSyntax(SyntaxKind.NamedTupleElement, null, null, (IdentifierTokenSyntax)identifier.Node, asClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedTupleElementSyntax NamedTupleElement(SyntaxToken identifier)
		{
			return NamedTupleElement(identifier, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedTupleElementSyntax NamedTupleElement(string identifier)
		{
			return NamedTupleElement(Identifier(identifier), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MeExpressionSyntax MeExpression(SyntaxToken keyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(keyword);
			if (syntaxKind != SyntaxKind.MeKeyword && syntaxKind != SyntaxKind.MyBaseKeyword && syntaxKind != SyntaxKind.MyClassKeyword)
			{
				throw new ArgumentException("keyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MeExpressionSyntax(SyntaxKind.MeExpression, null, null, (KeywordSyntax)keyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MeExpressionSyntax MeExpression()
		{
			return MeExpression(Token(SyntaxKind.MeKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MyBaseExpressionSyntax MyBaseExpression(SyntaxToken keyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(keyword);
			if (syntaxKind != SyntaxKind.MyBaseKeyword)
			{
				throw new ArgumentException("keyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MyBaseExpressionSyntax(SyntaxKind.MyBaseExpression, null, null, (KeywordSyntax)keyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MyBaseExpressionSyntax MyBaseExpression()
		{
			return MyBaseExpression(Token(SyntaxKind.MyBaseKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MyClassExpressionSyntax MyClassExpression(SyntaxToken keyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(keyword);
			if (syntaxKind != SyntaxKind.MyClassKeyword)
			{
				throw new ArgumentException("keyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MyClassExpressionSyntax(SyntaxKind.MyClassExpression, null, null, (KeywordSyntax)keyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MyClassExpressionSyntax MyClassExpression()
		{
			return MyClassExpression(Token(SyntaxKind.MyClassKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.GetTypeExpressionSyntax GetTypeExpression(SyntaxToken getTypeKeyword, SyntaxToken openParenToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type, SyntaxToken closeParenToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(getTypeKeyword);
			if (syntaxKind != SyntaxKind.GetTypeKeyword)
			{
				throw new ArgumentException("getTypeKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(openParenToken);
			if (syntaxKind2 != SyntaxKind.OpenParenToken)
			{
				throw new ArgumentException("openParenToken");
			}
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			SyntaxKind syntaxKind3 = type.Kind();
			if (syntaxKind3 - 396 > SyntaxKind.EndUsingStatement && syntaxKind3 - 409 > SyntaxKind.List && syntaxKind3 != SyntaxKind.TupleType)
			{
				throw new ArgumentException("type");
			}
			SyntaxKind syntaxKind4 = VisualBasicExtensions.Kind(closeParenToken);
			if (syntaxKind4 != SyntaxKind.CloseParenToken)
			{
				throw new ArgumentException("closeParenToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.GetTypeExpressionSyntax(SyntaxKind.GetTypeExpression, null, null, (KeywordSyntax)getTypeKeyword.Node, (PunctuationSyntax)openParenToken.Node, type, (PunctuationSyntax)closeParenToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.GetTypeExpressionSyntax GetTypeExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type)
		{
			return GetTypeExpression(Token(SyntaxKind.GetTypeKeyword), Token(SyntaxKind.OpenParenToken), type, Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax TypeOfIsExpression(SyntaxToken typeOfKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(typeOfKeyword);
			if (syntaxKind != SyntaxKind.TypeOfKeyword)
			{
				throw new ArgumentException("typeOfKeyword");
			}
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind2 = expression.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("expression");
			IL_02ec:
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind3 != SyntaxKind.IsKeyword && syntaxKind3 != SyntaxKind.IsNotKeyword)
			{
				throw new ArgumentException("operatorToken");
			}
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			SyntaxKind syntaxKind4 = type.Kind();
			if (syntaxKind4 - 396 > SyntaxKind.EndUsingStatement && syntaxKind4 - 409 > SyntaxKind.List && syntaxKind4 != SyntaxKind.TupleType)
			{
				throw new ArgumentException("type");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax(SyntaxKind.TypeOfIsExpression, null, null, (KeywordSyntax)typeOfKeyword.Node, expression, (KeywordSyntax)operatorToken.Node, type);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax TypeOfIsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type)
		{
			return TypeOfIsExpression(Token(SyntaxKind.TypeOfKeyword), expression, Token(SyntaxKind.IsKeyword), type);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax TypeOfIsNotExpression(SyntaxToken typeOfKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(typeOfKeyword);
			if (syntaxKind != SyntaxKind.TypeOfKeyword)
			{
				throw new ArgumentException("typeOfKeyword");
			}
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind2 = expression.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("expression");
			IL_02ec:
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind3 != SyntaxKind.IsNotKeyword)
			{
				throw new ArgumentException("operatorToken");
			}
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			SyntaxKind syntaxKind4 = type.Kind();
			if (syntaxKind4 - 396 > SyntaxKind.EndUsingStatement && syntaxKind4 - 409 > SyntaxKind.List && syntaxKind4 != SyntaxKind.TupleType)
			{
				throw new ArgumentException("type");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax(SyntaxKind.TypeOfIsNotExpression, null, null, (KeywordSyntax)typeOfKeyword.Node, expression, (KeywordSyntax)operatorToken.Node, type);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax TypeOfIsNotExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type)
		{
			return TypeOfIsNotExpression(Token(SyntaxKind.TypeOfKeyword), expression, Token(SyntaxKind.IsNotKeyword), type);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax TypeOfExpression(SyntaxKind kind, SyntaxToken typeOfKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type)
		{
			if (!SyntaxFacts.IsTypeOfExpression(kind))
			{
				throw new ArgumentException("kind");
			}
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(typeOfKeyword);
			if (syntaxKind != SyntaxKind.TypeOfKeyword)
			{
				throw new ArgumentException("typeOfKeyword");
			}
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind2 = expression.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ff;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ff;
			}
			throw new ArgumentException("expression");
			IL_02ff:
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(operatorToken, GetTypeOfExpressionOperatorTokenKind(kind)))
			{
				throw new ArgumentException("operatorToken");
			}
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			SyntaxKind syntaxKind3 = type.Kind();
			if (syntaxKind3 - 396 > SyntaxKind.EndUsingStatement && syntaxKind3 - 409 > SyntaxKind.List && syntaxKind3 != SyntaxKind.TupleType)
			{
				throw new ArgumentException("type");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax(kind, null, null, (KeywordSyntax)typeOfKeyword.Node, expression, (KeywordSyntax)operatorToken.Node, type);
		}

		private static SyntaxKind GetTypeOfExpressionOperatorTokenKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.TypeOfIsExpression => SyntaxKind.IsKeyword, 
				SyntaxKind.TypeOfIsNotExpression => SyntaxKind.IsNotKeyword, 
				_ => throw new ArgumentException("OperatorToken"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax TypeOfExpression(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type)
		{
			return TypeOfExpression(kind, Token(SyntaxKind.TypeOfKeyword), expression, operatorToken, type);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.GetXmlNamespaceExpressionSyntax GetXmlNamespaceExpression(SyntaxToken getXmlNamespaceKeyword, SyntaxToken openParenToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixNameSyntax name, SyntaxToken closeParenToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(getXmlNamespaceKeyword);
			if (syntaxKind != SyntaxKind.GetXmlNamespaceKeyword)
			{
				throw new ArgumentException("getXmlNamespaceKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(openParenToken);
			if (syntaxKind2 != SyntaxKind.OpenParenToken)
			{
				throw new ArgumentException("openParenToken");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(closeParenToken);
			if (syntaxKind3 != SyntaxKind.CloseParenToken)
			{
				throw new ArgumentException("closeParenToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.GetXmlNamespaceExpressionSyntax(SyntaxKind.GetXmlNamespaceExpression, null, null, (KeywordSyntax)getXmlNamespaceKeyword.Node, (PunctuationSyntax)openParenToken.Node, name, (PunctuationSyntax)closeParenToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.GetXmlNamespaceExpressionSyntax GetXmlNamespaceExpression()
		{
			return GetXmlNamespaceExpression(Token(SyntaxKind.GetXmlNamespaceKeyword), Token(SyntaxKind.OpenParenToken), null, Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax SimpleMemberAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax name)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind != SyntaxKind.ExclamationToken && syntaxKind != SyntaxKind.DotToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			SyntaxKind syntaxKind2 = name.Kind();
			if (syntaxKind2 - 399 > SyntaxKind.List)
			{
				throw new ArgumentException("name");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax(SyntaxKind.SimpleMemberAccessExpression, null, null, expression, (PunctuationSyntax)operatorToken.Node, name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax SimpleMemberAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax name)
		{
			return SimpleMemberAccessExpression(expression, Token(SyntaxKind.DotToken), name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax SimpleMemberAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax name)
		{
			return SimpleMemberAccessExpression(null, Token(SyntaxKind.DotToken), name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax DictionaryAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax name)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind != SyntaxKind.ExclamationToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			SyntaxKind syntaxKind2 = name.Kind();
			if (syntaxKind2 - 399 > SyntaxKind.List)
			{
				throw new ArgumentException("name");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax(SyntaxKind.DictionaryAccessExpression, null, null, expression, (PunctuationSyntax)operatorToken.Node, name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax DictionaryAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax name)
		{
			return DictionaryAccessExpression(expression, Token(SyntaxKind.ExclamationToken), name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax DictionaryAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax name)
		{
			return DictionaryAccessExpression(null, Token(SyntaxKind.ExclamationToken), name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax name)
		{
			if (!SyntaxFacts.IsMemberAccessExpression(kind))
			{
				throw new ArgumentException("kind");
			}
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(operatorToken, GetMemberAccessExpressionOperatorTokenKind(kind)))
			{
				throw new ArgumentException("operatorToken");
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			SyntaxKind syntaxKind = name.Kind();
			if (syntaxKind - 399 > SyntaxKind.List)
			{
				throw new ArgumentException("name");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax(kind, null, null, expression, (PunctuationSyntax)operatorToken.Node, name);
		}

		private static SyntaxKind GetMemberAccessExpressionOperatorTokenKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.SimpleMemberAccessExpression => SyntaxKind.DotToken, 
				SyntaxKind.DictionaryAccessExpression => SyntaxKind.ExclamationToken, 
				_ => throw new ArgumentException("OperatorToken"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax name)
		{
			return MemberAccessExpression(kind, null, operatorToken, name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax XmlElementAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax @base, SyntaxToken token1, SyntaxToken token2, SyntaxToken token3, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax name)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(token1);
			if (syntaxKind != SyntaxKind.DotToken)
			{
				throw new ArgumentException("token1");
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			SyntaxKind syntaxKind2 = name.Kind();
			if (syntaxKind2 - 389 > SyntaxKind.List)
			{
				throw new ArgumentException("name");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax(SyntaxKind.XmlElementAccessExpression, null, null, @base, (PunctuationSyntax)token1.Node, (PunctuationSyntax)token2.Node, (PunctuationSyntax)token3.Node, name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax XmlElementAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax @base, SyntaxToken token2, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax name)
		{
			return XmlElementAccessExpression(@base, Token(SyntaxKind.DotToken), token2, default(SyntaxToken), name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax XmlElementAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax name)
		{
			return XmlElementAccessExpression(null, Token(SyntaxKind.DotToken), default(SyntaxToken), default(SyntaxToken), name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax XmlDescendantAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax @base, SyntaxToken token1, SyntaxToken token2, SyntaxToken token3, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax name)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(token1);
			if (syntaxKind != SyntaxKind.DotToken)
			{
				throw new ArgumentException("token1");
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			SyntaxKind syntaxKind2 = name.Kind();
			if (syntaxKind2 - 389 > SyntaxKind.List)
			{
				throw new ArgumentException("name");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax(SyntaxKind.XmlDescendantAccessExpression, null, null, @base, (PunctuationSyntax)token1.Node, (PunctuationSyntax)token2.Node, (PunctuationSyntax)token3.Node, name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax XmlDescendantAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax @base, SyntaxToken token2, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax name)
		{
			return XmlDescendantAccessExpression(@base, Token(SyntaxKind.DotToken), token2, default(SyntaxToken), name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax XmlDescendantAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax name)
		{
			return XmlDescendantAccessExpression(null, Token(SyntaxKind.DotToken), default(SyntaxToken), default(SyntaxToken), name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax XmlAttributeAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax @base, SyntaxToken token1, SyntaxToken token2, SyntaxToken token3, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax name)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(token1);
			if (syntaxKind != SyntaxKind.DotToken)
			{
				throw new ArgumentException("token1");
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			SyntaxKind syntaxKind2 = name.Kind();
			if (syntaxKind2 - 389 > SyntaxKind.List)
			{
				throw new ArgumentException("name");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax(SyntaxKind.XmlAttributeAccessExpression, null, null, @base, (PunctuationSyntax)token1.Node, (PunctuationSyntax)token2.Node, (PunctuationSyntax)token3.Node, name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax XmlAttributeAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax @base, SyntaxToken token2, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax name)
		{
			return XmlAttributeAccessExpression(@base, Token(SyntaxKind.DotToken), token2, default(SyntaxToken), name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax XmlAttributeAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax name)
		{
			return XmlAttributeAccessExpression(null, Token(SyntaxKind.DotToken), default(SyntaxToken), default(SyntaxToken), name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax XmlMemberAccessExpression(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax @base, SyntaxToken token1, SyntaxToken token2, SyntaxToken token3, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax name)
		{
			if (!SyntaxFacts.IsXmlMemberAccessExpression(kind))
			{
				throw new ArgumentException("kind");
			}
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(token1);
			if (syntaxKind != SyntaxKind.DotToken)
			{
				throw new ArgumentException("token1");
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			SyntaxKind syntaxKind2 = name.Kind();
			if (syntaxKind2 - 389 > SyntaxKind.List)
			{
				throw new ArgumentException("name");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax(kind, null, null, @base, (PunctuationSyntax)token1.Node, (PunctuationSyntax)token2.Node, (PunctuationSyntax)token3.Node, name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax XmlMemberAccessExpression(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax @base, SyntaxToken token2, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax name)
		{
			return XmlMemberAccessExpression(kind, @base, Token(SyntaxKind.DotToken), token2, default(SyntaxToken), name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax XmlMemberAccessExpression(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax name)
		{
			return XmlMemberAccessExpression(kind, null, Token(SyntaxKind.DotToken), default(SyntaxToken), default(SyntaxToken), name);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax InvocationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax argumentList)
		{
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax(SyntaxKind.InvocationExpression, null, null, expression, argumentList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax InvocationExpression()
		{
			return InvocationExpression(null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax argumentList, Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationInitializerSyntax initializer)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(newKeyword);
			if (syntaxKind != SyntaxKind.NewKeyword)
			{
				throw new ArgumentException("newKeyword");
			}
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			SyntaxKind syntaxKind2 = type.Kind();
			if (syntaxKind2 - 397 > SyntaxKind.EndIfStatement && syntaxKind2 - 409 > SyntaxKind.List && syntaxKind2 != SyntaxKind.TupleType)
			{
				throw new ArgumentException("type");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax(SyntaxKind.ObjectCreationExpression, null, null, (KeywordSyntax)newKeyword.Node, attributeLists.Node, type, argumentList, initializer);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax argumentList, Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationInitializerSyntax initializer)
		{
			return ObjectCreationExpression(Token(SyntaxKind.NewKeyword), attributeLists, type, argumentList, initializer);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax ObjectCreationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type)
		{
			return ObjectCreationExpression(Token(SyntaxKind.NewKeyword), default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), type, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax initializer)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(newKeyword);
			if (syntaxKind != SyntaxKind.NewKeyword)
			{
				throw new ArgumentException("newKeyword");
			}
			if (initializer == null)
			{
				throw new ArgumentNullException("initializer");
			}
			SyntaxKind syntaxKind2 = initializer.Kind();
			if (syntaxKind2 != SyntaxKind.ObjectMemberInitializer)
			{
				throw new ArgumentException("initializer");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax(SyntaxKind.AnonymousObjectCreationExpression, null, null, (KeywordSyntax)newKeyword.Node, attributeLists.Node, initializer);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax initializer)
		{
			return AnonymousObjectCreationExpression(Token(SyntaxKind.NewKeyword), attributeLists, initializer);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax initializer)
		{
			return AnonymousObjectCreationExpression(Token(SyntaxKind.NewKeyword), default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), initializer);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax arrayBounds, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax> rankSpecifiers, Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax initializer)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(newKeyword);
			if (syntaxKind != SyntaxKind.NewKeyword)
			{
				throw new ArgumentException("newKeyword");
			}
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			SyntaxKind syntaxKind2 = type.Kind();
			if (syntaxKind2 - 397 > SyntaxKind.EndIfStatement && syntaxKind2 - 409 > SyntaxKind.List && syntaxKind2 != SyntaxKind.TupleType)
			{
				throw new ArgumentException("type");
			}
			if (initializer == null)
			{
				throw new ArgumentNullException("initializer");
			}
			SyntaxKind syntaxKind3 = initializer.Kind();
			if (syntaxKind3 != SyntaxKind.CollectionInitializer)
			{
				throw new ArgumentException("initializer");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax(SyntaxKind.ArrayCreationExpression, null, null, (KeywordSyntax)newKeyword.Node, attributeLists.Node, type, arrayBounds, rankSpecifiers.Node, initializer);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax arrayBounds, Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax initializer)
		{
			return ArrayCreationExpression(Token(SyntaxKind.NewKeyword), attributeLists, type, arrayBounds, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax>), initializer);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax ArrayCreationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax initializer)
		{
			return ArrayCreationExpression(Token(SyntaxKind.NewKeyword), default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), type, null, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax>), initializer);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax CollectionInitializer(SyntaxToken openBraceToken, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax> initializers, SyntaxToken closeBraceToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(openBraceToken);
			if (syntaxKind != SyntaxKind.OpenBraceToken)
			{
				throw new ArgumentException("openBraceToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(closeBraceToken);
			if (syntaxKind2 != SyntaxKind.CloseBraceToken)
			{
				throw new ArgumentException("closeBraceToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax(SyntaxKind.CollectionInitializer, null, null, (PunctuationSyntax)openBraceToken.Node, initializers.Node, (PunctuationSyntax)closeBraceToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax CollectionInitializer(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax> initializers)
		{
			return CollectionInitializer(Token(SyntaxKind.OpenBraceToken), initializers, Token(SyntaxKind.CloseBraceToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax CollectionInitializer()
		{
			return CollectionInitializer(Token(SyntaxKind.OpenBraceToken), default(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax>), Token(SyntaxKind.CloseBraceToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CTypeExpressionSyntax CTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, SyntaxToken commaToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type, SyntaxToken closeParenToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(keyword);
			if (syntaxKind != SyntaxKind.CTypeKeyword && syntaxKind != SyntaxKind.DirectCastKeyword && syntaxKind != SyntaxKind.TryCastKeyword)
			{
				throw new ArgumentException("keyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(openParenToken);
			if (syntaxKind2 != SyntaxKind.OpenParenToken)
			{
				throw new ArgumentException("openParenToken");
			}
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind3 = expression.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_0316;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_0316;
			}
			throw new ArgumentException("expression");
			IL_0316:
			SyntaxKind syntaxKind4 = VisualBasicExtensions.Kind(commaToken);
			if (syntaxKind4 != SyntaxKind.CommaToken)
			{
				throw new ArgumentException("commaToken");
			}
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			SyntaxKind syntaxKind5 = type.Kind();
			if (syntaxKind5 - 396 > SyntaxKind.EndUsingStatement && syntaxKind5 - 409 > SyntaxKind.List && syntaxKind5 != SyntaxKind.TupleType)
			{
				throw new ArgumentException("type");
			}
			SyntaxKind syntaxKind6 = VisualBasicExtensions.Kind(closeParenToken);
			if (syntaxKind6 != SyntaxKind.CloseParenToken)
			{
				throw new ArgumentException("closeParenToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CTypeExpressionSyntax(SyntaxKind.CTypeExpression, null, null, (KeywordSyntax)keyword.Node, (PunctuationSyntax)openParenToken.Node, expression, (PunctuationSyntax)commaToken.Node, type, (PunctuationSyntax)closeParenToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CTypeExpressionSyntax CTypeExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type)
		{
			return CTypeExpression(Token(SyntaxKind.CTypeKeyword), Token(SyntaxKind.OpenParenToken), expression, Token(SyntaxKind.CommaToken), type, Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectCastExpressionSyntax DirectCastExpression(SyntaxToken keyword, SyntaxToken openParenToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, SyntaxToken commaToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type, SyntaxToken closeParenToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(keyword);
			if (syntaxKind != SyntaxKind.DirectCastKeyword)
			{
				throw new ArgumentException("keyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(openParenToken);
			if (syntaxKind2 != SyntaxKind.OpenParenToken)
			{
				throw new ArgumentException("openParenToken");
			}
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind3 = expression.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_0306;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_0306;
			}
			throw new ArgumentException("expression");
			IL_0306:
			SyntaxKind syntaxKind4 = VisualBasicExtensions.Kind(commaToken);
			if (syntaxKind4 != SyntaxKind.CommaToken)
			{
				throw new ArgumentException("commaToken");
			}
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			SyntaxKind syntaxKind5 = type.Kind();
			if (syntaxKind5 - 396 > SyntaxKind.EndUsingStatement && syntaxKind5 - 409 > SyntaxKind.List && syntaxKind5 != SyntaxKind.TupleType)
			{
				throw new ArgumentException("type");
			}
			SyntaxKind syntaxKind6 = VisualBasicExtensions.Kind(closeParenToken);
			if (syntaxKind6 != SyntaxKind.CloseParenToken)
			{
				throw new ArgumentException("closeParenToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectCastExpressionSyntax(SyntaxKind.DirectCastExpression, null, null, (KeywordSyntax)keyword.Node, (PunctuationSyntax)openParenToken.Node, expression, (PunctuationSyntax)commaToken.Node, type, (PunctuationSyntax)closeParenToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectCastExpressionSyntax DirectCastExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type)
		{
			return DirectCastExpression(Token(SyntaxKind.DirectCastKeyword), Token(SyntaxKind.OpenParenToken), expression, Token(SyntaxKind.CommaToken), type, Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TryCastExpressionSyntax TryCastExpression(SyntaxToken keyword, SyntaxToken openParenToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, SyntaxToken commaToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type, SyntaxToken closeParenToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(keyword);
			if (syntaxKind != SyntaxKind.TryCastKeyword)
			{
				throw new ArgumentException("keyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(openParenToken);
			if (syntaxKind2 != SyntaxKind.OpenParenToken)
			{
				throw new ArgumentException("openParenToken");
			}
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind3 = expression.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_0306;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_0306;
			}
			throw new ArgumentException("expression");
			IL_0306:
			SyntaxKind syntaxKind4 = VisualBasicExtensions.Kind(commaToken);
			if (syntaxKind4 != SyntaxKind.CommaToken)
			{
				throw new ArgumentException("commaToken");
			}
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			SyntaxKind syntaxKind5 = type.Kind();
			if (syntaxKind5 - 396 > SyntaxKind.EndUsingStatement && syntaxKind5 - 409 > SyntaxKind.List && syntaxKind5 != SyntaxKind.TupleType)
			{
				throw new ArgumentException("type");
			}
			SyntaxKind syntaxKind6 = VisualBasicExtensions.Kind(closeParenToken);
			if (syntaxKind6 != SyntaxKind.CloseParenToken)
			{
				throw new ArgumentException("closeParenToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TryCastExpressionSyntax(SyntaxKind.TryCastExpression, null, null, (KeywordSyntax)keyword.Node, (PunctuationSyntax)openParenToken.Node, expression, (PunctuationSyntax)commaToken.Node, type, (PunctuationSyntax)closeParenToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TryCastExpressionSyntax TryCastExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type)
		{
			return TryCastExpression(Token(SyntaxKind.TryCastKeyword), Token(SyntaxKind.OpenParenToken), expression, Token(SyntaxKind.CommaToken), type, Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax PredefinedCastExpression(SyntaxToken keyword, SyntaxToken openParenToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, SyntaxToken closeParenToken)
		{
			SyntaxKind syntaxKind3;
			switch (VisualBasicExtensions.Kind(keyword))
			{
			default:
				throw new ArgumentException("keyword");
			case SyntaxKind.CBoolKeyword:
			case SyntaxKind.CByteKeyword:
			case SyntaxKind.CCharKeyword:
			case SyntaxKind.CDateKeyword:
			case SyntaxKind.CDecKeyword:
			case SyntaxKind.CDblKeyword:
			case SyntaxKind.CIntKeyword:
			case SyntaxKind.CLngKeyword:
			case SyntaxKind.CObjKeyword:
			case SyntaxKind.CSByteKeyword:
			case SyntaxKind.CShortKeyword:
			case SyntaxKind.CSngKeyword:
			case SyntaxKind.CStrKeyword:
			case SyntaxKind.CUIntKeyword:
			case SyntaxKind.CULngKeyword:
			case SyntaxKind.CUShortKeyword:
				{
					SyntaxKind syntaxKind = VisualBasicExtensions.Kind(openParenToken);
					if (syntaxKind != SyntaxKind.OpenParenToken)
					{
						throw new ArgumentException("openParenToken");
					}
					if (expression == null)
					{
						throw new ArgumentNullException("expression");
					}
					SyntaxKind syntaxKind2 = expression.Kind();
					if (syntaxKind2 <= SyntaxKind.AwaitExpression)
					{
						switch (syntaxKind2)
						{
						case SyntaxKind.KeywordEventContainer:
						case SyntaxKind.WithEventsEventContainer:
						case SyntaxKind.WithEventsPropertyEventContainer:
						case SyntaxKind.IdentifierLabel:
						case SyntaxKind.NumericLabel:
						case SyntaxKind.NextLabel:
						case SyntaxKind.MidExpression:
						case SyntaxKind.CharacterLiteralExpression:
						case SyntaxKind.TrueLiteralExpression:
						case SyntaxKind.FalseLiteralExpression:
						case SyntaxKind.NumericLiteralExpression:
						case SyntaxKind.DateLiteralExpression:
						case SyntaxKind.StringLiteralExpression:
						case SyntaxKind.NothingLiteralExpression:
						case SyntaxKind.ParenthesizedExpression:
						case SyntaxKind.MeExpression:
						case SyntaxKind.MyBaseExpression:
						case SyntaxKind.MyClassExpression:
						case SyntaxKind.GetTypeExpression:
						case SyntaxKind.TypeOfIsExpression:
						case SyntaxKind.TypeOfIsNotExpression:
						case SyntaxKind.GetXmlNamespaceExpression:
						case SyntaxKind.SimpleMemberAccessExpression:
						case SyntaxKind.DictionaryAccessExpression:
						case SyntaxKind.XmlElementAccessExpression:
						case SyntaxKind.XmlDescendantAccessExpression:
						case SyntaxKind.XmlAttributeAccessExpression:
						case SyntaxKind.InvocationExpression:
						case SyntaxKind.ObjectCreationExpression:
						case SyntaxKind.AnonymousObjectCreationExpression:
						case SyntaxKind.ArrayCreationExpression:
						case SyntaxKind.CollectionInitializer:
						case SyntaxKind.CTypeExpression:
						case SyntaxKind.DirectCastExpression:
						case SyntaxKind.TryCastExpression:
						case SyntaxKind.PredefinedCastExpression:
						case SyntaxKind.AddExpression:
						case SyntaxKind.SubtractExpression:
						case SyntaxKind.MultiplyExpression:
						case SyntaxKind.DivideExpression:
						case SyntaxKind.IntegerDivideExpression:
						case SyntaxKind.ExponentiateExpression:
						case SyntaxKind.LeftShiftExpression:
						case SyntaxKind.RightShiftExpression:
						case SyntaxKind.ConcatenateExpression:
						case SyntaxKind.ModuloExpression:
						case SyntaxKind.EqualsExpression:
						case SyntaxKind.NotEqualsExpression:
						case SyntaxKind.LessThanExpression:
						case SyntaxKind.LessThanOrEqualExpression:
						case SyntaxKind.GreaterThanOrEqualExpression:
						case SyntaxKind.GreaterThanExpression:
						case SyntaxKind.IsExpression:
						case SyntaxKind.IsNotExpression:
						case SyntaxKind.LikeExpression:
						case SyntaxKind.OrExpression:
						case SyntaxKind.ExclusiveOrExpression:
						case SyntaxKind.AndExpression:
						case SyntaxKind.OrElseExpression:
						case SyntaxKind.AndAlsoExpression:
						case SyntaxKind.UnaryPlusExpression:
						case SyntaxKind.UnaryMinusExpression:
						case SyntaxKind.NotExpression:
						case SyntaxKind.AddressOfExpression:
						case SyntaxKind.BinaryConditionalExpression:
						case SyntaxKind.TernaryConditionalExpression:
						case SyntaxKind.SingleLineFunctionLambdaExpression:
						case SyntaxKind.SingleLineSubLambdaExpression:
						case SyntaxKind.MultiLineFunctionLambdaExpression:
						case SyntaxKind.MultiLineSubLambdaExpression:
						case SyntaxKind.QueryExpression:
						case SyntaxKind.FunctionAggregation:
						case SyntaxKind.GroupAggregation:
						case SyntaxKind.XmlDocument:
						case SyntaxKind.XmlElement:
						case SyntaxKind.XmlText:
						case SyntaxKind.XmlElementStartTag:
						case SyntaxKind.XmlElementEndTag:
						case SyntaxKind.XmlEmptyElement:
						case SyntaxKind.XmlAttribute:
						case SyntaxKind.XmlString:
						case SyntaxKind.XmlPrefixName:
						case SyntaxKind.XmlName:
						case SyntaxKind.XmlBracketedName:
						case SyntaxKind.XmlComment:
						case SyntaxKind.XmlProcessingInstruction:
						case SyntaxKind.XmlCDataSection:
						case SyntaxKind.XmlEmbeddedExpression:
						case SyntaxKind.ArrayType:
						case SyntaxKind.NullableType:
						case SyntaxKind.PredefinedType:
						case SyntaxKind.IdentifierName:
						case SyntaxKind.GenericName:
						case SyntaxKind.QualifiedName:
						case SyntaxKind.GlobalName:
						case SyntaxKind.CrefOperatorReference:
						case SyntaxKind.QualifiedCrefOperatorReference:
						case SyntaxKind.AwaitExpression:
							goto IL_0372;
						}
					}
					else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
					{
						goto IL_0372;
					}
					throw new ArgumentException("expression");
				}
				IL_0372:
				syntaxKind3 = VisualBasicExtensions.Kind(closeParenToken);
				if (syntaxKind3 != SyntaxKind.CloseParenToken)
				{
					throw new ArgumentException("closeParenToken");
				}
				return new Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax(SyntaxKind.PredefinedCastExpression, null, null, (KeywordSyntax)keyword.Node, (PunctuationSyntax)openParenToken.Node, expression, (PunctuationSyntax)closeParenToken.Node);
			}
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax PredefinedCastExpression(SyntaxToken keyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return PredefinedCastExpression(keyword, Token(SyntaxKind.OpenParenToken), expression, Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax AddExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_02d2:
			switch (VisualBasicExtensions.Kind(operatorToken))
			{
			default:
				throw new ArgumentException("operatorToken");
			case SyntaxKind.AndKeyword:
			case SyntaxKind.AndAlsoKeyword:
			case SyntaxKind.IsKeyword:
			case SyntaxKind.IsNotKeyword:
			case SyntaxKind.LikeKeyword:
			case SyntaxKind.ModKeyword:
			case SyntaxKind.OrKeyword:
			case SyntaxKind.OrElseKeyword:
			case SyntaxKind.XorKeyword:
			case SyntaxKind.AmpersandToken:
			case SyntaxKind.AsteriskToken:
			case SyntaxKind.PlusToken:
			case SyntaxKind.MinusToken:
			case SyntaxKind.SlashToken:
			case SyntaxKind.LessThanToken:
			case SyntaxKind.LessThanEqualsToken:
			case SyntaxKind.LessThanGreaterThanToken:
			case SyntaxKind.EqualsToken:
			case SyntaxKind.GreaterThanToken:
			case SyntaxKind.GreaterThanEqualsToken:
			case SyntaxKind.BackslashToken:
			case SyntaxKind.CaretToken:
			case SyntaxKind.LessThanLessThanToken:
			case SyntaxKind.GreaterThanGreaterThanToken:
				{
					if (right == null)
					{
						throw new ArgumentNullException("right");
					}
					SyntaxKind syntaxKind2 = right.Kind();
					if (syntaxKind2 <= SyntaxKind.AwaitExpression)
					{
						switch (syntaxKind2)
						{
						case SyntaxKind.KeywordEventContainer:
						case SyntaxKind.WithEventsEventContainer:
						case SyntaxKind.WithEventsPropertyEventContainer:
						case SyntaxKind.IdentifierLabel:
						case SyntaxKind.NumericLabel:
						case SyntaxKind.NextLabel:
						case SyntaxKind.MidExpression:
						case SyntaxKind.CharacterLiteralExpression:
						case SyntaxKind.TrueLiteralExpression:
						case SyntaxKind.FalseLiteralExpression:
						case SyntaxKind.NumericLiteralExpression:
						case SyntaxKind.DateLiteralExpression:
						case SyntaxKind.StringLiteralExpression:
						case SyntaxKind.NothingLiteralExpression:
						case SyntaxKind.ParenthesizedExpression:
						case SyntaxKind.MeExpression:
						case SyntaxKind.MyBaseExpression:
						case SyntaxKind.MyClassExpression:
						case SyntaxKind.GetTypeExpression:
						case SyntaxKind.TypeOfIsExpression:
						case SyntaxKind.TypeOfIsNotExpression:
						case SyntaxKind.GetXmlNamespaceExpression:
						case SyntaxKind.SimpleMemberAccessExpression:
						case SyntaxKind.DictionaryAccessExpression:
						case SyntaxKind.XmlElementAccessExpression:
						case SyntaxKind.XmlDescendantAccessExpression:
						case SyntaxKind.XmlAttributeAccessExpression:
						case SyntaxKind.InvocationExpression:
						case SyntaxKind.ObjectCreationExpression:
						case SyntaxKind.AnonymousObjectCreationExpression:
						case SyntaxKind.ArrayCreationExpression:
						case SyntaxKind.CollectionInitializer:
						case SyntaxKind.CTypeExpression:
						case SyntaxKind.DirectCastExpression:
						case SyntaxKind.TryCastExpression:
						case SyntaxKind.PredefinedCastExpression:
						case SyntaxKind.AddExpression:
						case SyntaxKind.SubtractExpression:
						case SyntaxKind.MultiplyExpression:
						case SyntaxKind.DivideExpression:
						case SyntaxKind.IntegerDivideExpression:
						case SyntaxKind.ExponentiateExpression:
						case SyntaxKind.LeftShiftExpression:
						case SyntaxKind.RightShiftExpression:
						case SyntaxKind.ConcatenateExpression:
						case SyntaxKind.ModuloExpression:
						case SyntaxKind.EqualsExpression:
						case SyntaxKind.NotEqualsExpression:
						case SyntaxKind.LessThanExpression:
						case SyntaxKind.LessThanOrEqualExpression:
						case SyntaxKind.GreaterThanOrEqualExpression:
						case SyntaxKind.GreaterThanExpression:
						case SyntaxKind.IsExpression:
						case SyntaxKind.IsNotExpression:
						case SyntaxKind.LikeExpression:
						case SyntaxKind.OrExpression:
						case SyntaxKind.ExclusiveOrExpression:
						case SyntaxKind.AndExpression:
						case SyntaxKind.OrElseExpression:
						case SyntaxKind.AndAlsoExpression:
						case SyntaxKind.UnaryPlusExpression:
						case SyntaxKind.UnaryMinusExpression:
						case SyntaxKind.NotExpression:
						case SyntaxKind.AddressOfExpression:
						case SyntaxKind.BinaryConditionalExpression:
						case SyntaxKind.TernaryConditionalExpression:
						case SyntaxKind.SingleLineFunctionLambdaExpression:
						case SyntaxKind.SingleLineSubLambdaExpression:
						case SyntaxKind.MultiLineFunctionLambdaExpression:
						case SyntaxKind.MultiLineSubLambdaExpression:
						case SyntaxKind.QueryExpression:
						case SyntaxKind.FunctionAggregation:
						case SyntaxKind.GroupAggregation:
						case SyntaxKind.XmlDocument:
						case SyntaxKind.XmlElement:
						case SyntaxKind.XmlText:
						case SyntaxKind.XmlElementStartTag:
						case SyntaxKind.XmlElementEndTag:
						case SyntaxKind.XmlEmptyElement:
						case SyntaxKind.XmlAttribute:
						case SyntaxKind.XmlString:
						case SyntaxKind.XmlPrefixName:
						case SyntaxKind.XmlName:
						case SyntaxKind.XmlBracketedName:
						case SyntaxKind.XmlComment:
						case SyntaxKind.XmlProcessingInstruction:
						case SyntaxKind.XmlCDataSection:
						case SyntaxKind.XmlEmbeddedExpression:
						case SyntaxKind.ArrayType:
						case SyntaxKind.NullableType:
						case SyntaxKind.PredefinedType:
						case SyntaxKind.IdentifierName:
						case SyntaxKind.GenericName:
						case SyntaxKind.QualifiedName:
						case SyntaxKind.GlobalName:
						case SyntaxKind.CrefOperatorReference:
						case SyntaxKind.QualifiedCrefOperatorReference:
						case SyntaxKind.AwaitExpression:
							goto IL_06c0;
						}
					}
					else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
					{
						goto IL_06c0;
					}
					throw new ArgumentException("right");
				}
				IL_06c0:
				return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.AddExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			}
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax AddExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return AddExpression(left, Token(SyntaxKind.PlusToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax SubtractExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.SubtractExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.MinusToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax SubtractExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return SubtractExpression(left, Token(SyntaxKind.MinusToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax MultiplyExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.MultiplyExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.AsteriskToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax MultiplyExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return MultiplyExpression(left, Token(SyntaxKind.AsteriskToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax DivideExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.DivideExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.SlashToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax DivideExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return DivideExpression(left, Token(SyntaxKind.SlashToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax IntegerDivideExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.IntegerDivideExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.BackslashToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax IntegerDivideExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return IntegerDivideExpression(left, Token(SyntaxKind.BackslashToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax ExponentiateExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.ExponentiateExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.CaretToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax ExponentiateExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return ExponentiateExpression(left, Token(SyntaxKind.CaretToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax LeftShiftExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.LeftShiftExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.LessThanLessThanToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax LeftShiftExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return LeftShiftExpression(left, Token(SyntaxKind.LessThanLessThanToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax RightShiftExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.RightShiftExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.GreaterThanGreaterThanToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax RightShiftExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return RightShiftExpression(left, Token(SyntaxKind.GreaterThanGreaterThanToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax ConcatenateExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.ConcatenateExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.AmpersandToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax ConcatenateExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return ConcatenateExpression(left, Token(SyntaxKind.AmpersandToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax ModuloExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.ModuloExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.ModKeyword)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax ModuloExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return ModuloExpression(left, Token(SyntaxKind.ModKeyword), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax EqualsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.EqualsExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.EqualsToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax EqualsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return EqualsExpression(left, Token(SyntaxKind.EqualsToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax NotEqualsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.NotEqualsExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.LessThanGreaterThanToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax NotEqualsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return NotEqualsExpression(left, Token(SyntaxKind.LessThanGreaterThanToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax LessThanExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.LessThanExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.LessThanToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax LessThanExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return LessThanExpression(left, Token(SyntaxKind.LessThanToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax LessThanOrEqualExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.LessThanOrEqualExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.LessThanEqualsToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax LessThanOrEqualExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return LessThanOrEqualExpression(left, Token(SyntaxKind.LessThanEqualsToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax GreaterThanOrEqualExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.GreaterThanOrEqualExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.GreaterThanEqualsToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax GreaterThanOrEqualExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return GreaterThanOrEqualExpression(left, Token(SyntaxKind.GreaterThanEqualsToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax GreaterThanExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.GreaterThanExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.GreaterThanToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax GreaterThanExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return GreaterThanExpression(left, Token(SyntaxKind.GreaterThanToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax IsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.IsExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.IsKeyword)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax IsExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return IsExpression(left, Token(SyntaxKind.IsKeyword), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax IsNotExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.IsNotExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.IsNotKeyword)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax IsNotExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return IsNotExpression(left, Token(SyntaxKind.IsNotKeyword), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax LikeExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.LikeExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.LikeKeyword)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax LikeExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return LikeExpression(left, Token(SyntaxKind.LikeKeyword), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax OrExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.OrExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.OrKeyword)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax OrExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return OrExpression(left, Token(SyntaxKind.OrKeyword), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax ExclusiveOrExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.ExclusiveOrExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.XorKeyword)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax ExclusiveOrExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return ExclusiveOrExpression(left, Token(SyntaxKind.XorKeyword), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax AndExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.AndExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.AndKeyword)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax AndExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return AndExpression(left, Token(SyntaxKind.AndKeyword), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax OrElseExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.OrElseExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.OrElseKeyword)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax OrElseExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return OrElseExpression(left, Token(SyntaxKind.OrElseKeyword), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax AndAlsoExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(SyntaxKind.AndAlsoExpression, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind2 != SyntaxKind.AndAlsoKeyword)
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax AndAlsoExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return AndAlsoExpression(left, Token(SyntaxKind.AndAlsoKeyword), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (!SyntaxFacts.IsBinaryExpression(kind))
			{
				throw new ArgumentException("kind");
			}
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02e5;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02e5;
			}
			throw new ArgumentException("left");
			IL_05d0:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(kind, null, null, left, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right);
			IL_02e5:
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(operatorToken, GetBinaryExpressionOperatorTokenKind(kind)))
			{
				throw new ArgumentException("operatorToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind2 = right.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05d0;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_05d0;
			}
			throw new ArgumentException("right");
		}

		private static SyntaxKind GetBinaryExpressionOperatorTokenKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.AddExpression => SyntaxKind.PlusToken, 
				SyntaxKind.SubtractExpression => SyntaxKind.MinusToken, 
				SyntaxKind.MultiplyExpression => SyntaxKind.AsteriskToken, 
				SyntaxKind.DivideExpression => SyntaxKind.SlashToken, 
				SyntaxKind.IntegerDivideExpression => SyntaxKind.BackslashToken, 
				SyntaxKind.ExponentiateExpression => SyntaxKind.CaretToken, 
				SyntaxKind.LeftShiftExpression => SyntaxKind.LessThanLessThanToken, 
				SyntaxKind.RightShiftExpression => SyntaxKind.GreaterThanGreaterThanToken, 
				SyntaxKind.ConcatenateExpression => SyntaxKind.AmpersandToken, 
				SyntaxKind.ModuloExpression => SyntaxKind.ModKeyword, 
				SyntaxKind.EqualsExpression => SyntaxKind.EqualsToken, 
				SyntaxKind.NotEqualsExpression => SyntaxKind.LessThanGreaterThanToken, 
				SyntaxKind.LessThanExpression => SyntaxKind.LessThanToken, 
				SyntaxKind.LessThanOrEqualExpression => SyntaxKind.LessThanEqualsToken, 
				SyntaxKind.GreaterThanOrEqualExpression => SyntaxKind.GreaterThanEqualsToken, 
				SyntaxKind.GreaterThanExpression => SyntaxKind.GreaterThanToken, 
				SyntaxKind.IsExpression => SyntaxKind.IsKeyword, 
				SyntaxKind.IsNotExpression => SyntaxKind.IsNotKeyword, 
				SyntaxKind.LikeExpression => SyntaxKind.LikeKeyword, 
				SyntaxKind.OrExpression => SyntaxKind.OrKeyword, 
				SyntaxKind.ExclusiveOrExpression => SyntaxKind.XorKeyword, 
				SyntaxKind.AndExpression => SyntaxKind.AndKeyword, 
				SyntaxKind.OrElseExpression => SyntaxKind.OrElseKeyword, 
				SyntaxKind.AndAlsoExpression => SyntaxKind.AndAlsoKeyword, 
				_ => throw new ArgumentException("OperatorToken"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax UnaryPlusExpression(SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax operand)
		{
			switch (VisualBasicExtensions.Kind(operatorToken))
			{
			default:
				throw new ArgumentException("operatorToken");
			case SyntaxKind.AddressOfKeyword:
			case SyntaxKind.NotKeyword:
			case SyntaxKind.PlusToken:
			case SyntaxKind.MinusToken:
				{
					if (operand == null)
					{
						throw new ArgumentNullException("operand");
					}
					SyntaxKind syntaxKind = operand.Kind();
					if (syntaxKind <= SyntaxKind.AwaitExpression)
					{
						switch (syntaxKind)
						{
						case SyntaxKind.KeywordEventContainer:
						case SyntaxKind.WithEventsEventContainer:
						case SyntaxKind.WithEventsPropertyEventContainer:
						case SyntaxKind.IdentifierLabel:
						case SyntaxKind.NumericLabel:
						case SyntaxKind.NextLabel:
						case SyntaxKind.MidExpression:
						case SyntaxKind.CharacterLiteralExpression:
						case SyntaxKind.TrueLiteralExpression:
						case SyntaxKind.FalseLiteralExpression:
						case SyntaxKind.NumericLiteralExpression:
						case SyntaxKind.DateLiteralExpression:
						case SyntaxKind.StringLiteralExpression:
						case SyntaxKind.NothingLiteralExpression:
						case SyntaxKind.ParenthesizedExpression:
						case SyntaxKind.MeExpression:
						case SyntaxKind.MyBaseExpression:
						case SyntaxKind.MyClassExpression:
						case SyntaxKind.GetTypeExpression:
						case SyntaxKind.TypeOfIsExpression:
						case SyntaxKind.TypeOfIsNotExpression:
						case SyntaxKind.GetXmlNamespaceExpression:
						case SyntaxKind.SimpleMemberAccessExpression:
						case SyntaxKind.DictionaryAccessExpression:
						case SyntaxKind.XmlElementAccessExpression:
						case SyntaxKind.XmlDescendantAccessExpression:
						case SyntaxKind.XmlAttributeAccessExpression:
						case SyntaxKind.InvocationExpression:
						case SyntaxKind.ObjectCreationExpression:
						case SyntaxKind.AnonymousObjectCreationExpression:
						case SyntaxKind.ArrayCreationExpression:
						case SyntaxKind.CollectionInitializer:
						case SyntaxKind.CTypeExpression:
						case SyntaxKind.DirectCastExpression:
						case SyntaxKind.TryCastExpression:
						case SyntaxKind.PredefinedCastExpression:
						case SyntaxKind.AddExpression:
						case SyntaxKind.SubtractExpression:
						case SyntaxKind.MultiplyExpression:
						case SyntaxKind.DivideExpression:
						case SyntaxKind.IntegerDivideExpression:
						case SyntaxKind.ExponentiateExpression:
						case SyntaxKind.LeftShiftExpression:
						case SyntaxKind.RightShiftExpression:
						case SyntaxKind.ConcatenateExpression:
						case SyntaxKind.ModuloExpression:
						case SyntaxKind.EqualsExpression:
						case SyntaxKind.NotEqualsExpression:
						case SyntaxKind.LessThanExpression:
						case SyntaxKind.LessThanOrEqualExpression:
						case SyntaxKind.GreaterThanOrEqualExpression:
						case SyntaxKind.GreaterThanExpression:
						case SyntaxKind.IsExpression:
						case SyntaxKind.IsNotExpression:
						case SyntaxKind.LikeExpression:
						case SyntaxKind.OrExpression:
						case SyntaxKind.ExclusiveOrExpression:
						case SyntaxKind.AndExpression:
						case SyntaxKind.OrElseExpression:
						case SyntaxKind.AndAlsoExpression:
						case SyntaxKind.UnaryPlusExpression:
						case SyntaxKind.UnaryMinusExpression:
						case SyntaxKind.NotExpression:
						case SyntaxKind.AddressOfExpression:
						case SyntaxKind.BinaryConditionalExpression:
						case SyntaxKind.TernaryConditionalExpression:
						case SyntaxKind.SingleLineFunctionLambdaExpression:
						case SyntaxKind.SingleLineSubLambdaExpression:
						case SyntaxKind.MultiLineFunctionLambdaExpression:
						case SyntaxKind.MultiLineSubLambdaExpression:
						case SyntaxKind.QueryExpression:
						case SyntaxKind.FunctionAggregation:
						case SyntaxKind.GroupAggregation:
						case SyntaxKind.XmlDocument:
						case SyntaxKind.XmlElement:
						case SyntaxKind.XmlText:
						case SyntaxKind.XmlElementStartTag:
						case SyntaxKind.XmlElementEndTag:
						case SyntaxKind.XmlEmptyElement:
						case SyntaxKind.XmlAttribute:
						case SyntaxKind.XmlString:
						case SyntaxKind.XmlPrefixName:
						case SyntaxKind.XmlName:
						case SyntaxKind.XmlBracketedName:
						case SyntaxKind.XmlComment:
						case SyntaxKind.XmlProcessingInstruction:
						case SyntaxKind.XmlCDataSection:
						case SyntaxKind.XmlEmbeddedExpression:
						case SyntaxKind.ArrayType:
						case SyntaxKind.NullableType:
						case SyntaxKind.PredefinedType:
						case SyntaxKind.IdentifierName:
						case SyntaxKind.GenericName:
						case SyntaxKind.QualifiedName:
						case SyntaxKind.GlobalName:
						case SyntaxKind.CrefOperatorReference:
						case SyntaxKind.QualifiedCrefOperatorReference:
						case SyntaxKind.AwaitExpression:
							goto IL_030e;
						}
					}
					else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
					{
						goto IL_030e;
					}
					throw new ArgumentException("operand");
				}
				IL_030e:
				return new Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax(SyntaxKind.UnaryPlusExpression, null, null, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, operand);
			}
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax UnaryPlusExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax operand)
		{
			return UnaryPlusExpression(Token(SyntaxKind.PlusToken), operand);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax UnaryMinusExpression(SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax operand)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind != SyntaxKind.MinusToken)
			{
				throw new ArgumentException("operatorToken");
			}
			if (operand == null)
			{
				throw new ArgumentNullException("operand");
			}
			SyntaxKind syntaxKind2 = operand.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("operand");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax(SyntaxKind.UnaryMinusExpression, null, null, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, operand);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax UnaryMinusExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax operand)
		{
			return UnaryMinusExpression(Token(SyntaxKind.MinusToken), operand);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax NotExpression(SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax operand)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind != SyntaxKind.NotKeyword)
			{
				throw new ArgumentException("operatorToken");
			}
			if (operand == null)
			{
				throw new ArgumentNullException("operand");
			}
			SyntaxKind syntaxKind2 = operand.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("operand");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax(SyntaxKind.NotExpression, null, null, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, operand);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax NotExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax operand)
		{
			return NotExpression(Token(SyntaxKind.NotKeyword), operand);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax AddressOfExpression(SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax operand)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(operatorToken);
			if (syntaxKind != SyntaxKind.AddressOfKeyword)
			{
				throw new ArgumentException("operatorToken");
			}
			if (operand == null)
			{
				throw new ArgumentNullException("operand");
			}
			SyntaxKind syntaxKind2 = operand.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("operand");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax(SyntaxKind.AddressOfExpression, null, null, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, operand);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax AddressOfExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax operand)
		{
			return AddressOfExpression(Token(SyntaxKind.AddressOfKeyword), operand);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax UnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax operand)
		{
			if (!SyntaxFacts.IsUnaryExpression(kind))
			{
				throw new ArgumentException("kind");
			}
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(operatorToken, GetUnaryExpressionOperatorTokenKind(kind)))
			{
				throw new ArgumentException("operatorToken");
			}
			if (operand == null)
			{
				throw new ArgumentNullException("operand");
			}
			SyntaxKind syntaxKind = operand.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02fe;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02fe;
			}
			throw new ArgumentException("operand");
			IL_02fe:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax(kind, null, null, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, operand);
		}

		private static SyntaxKind GetUnaryExpressionOperatorTokenKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.UnaryPlusExpression => SyntaxKind.PlusToken, 
				SyntaxKind.UnaryMinusExpression => SyntaxKind.MinusToken, 
				SyntaxKind.NotExpression => SyntaxKind.NotKeyword, 
				SyntaxKind.AddressOfExpression => SyntaxKind.AddressOfKeyword, 
				_ => throw new ArgumentException("OperatorToken"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax BinaryConditionalExpression(SyntaxToken ifKeyword, SyntaxToken openParenToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax firstExpression, SyntaxToken commaToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax secondExpression, SyntaxToken closeParenToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(ifKeyword);
			if (syntaxKind != SyntaxKind.IfKeyword)
			{
				throw new ArgumentException("ifKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(openParenToken);
			if (syntaxKind2 != SyntaxKind.OpenParenToken)
			{
				throw new ArgumentException("openParenToken");
			}
			if (firstExpression == null)
			{
				throw new ArgumentNullException("firstExpression");
			}
			SyntaxKind syntaxKind3 = firstExpression.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_0306;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_0306;
			}
			throw new ArgumentException("firstExpression");
			IL_05fc:
			SyntaxKind syntaxKind4 = VisualBasicExtensions.Kind(closeParenToken);
			if (syntaxKind4 != SyntaxKind.CloseParenToken)
			{
				throw new ArgumentException("closeParenToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax(SyntaxKind.BinaryConditionalExpression, null, null, (KeywordSyntax)ifKeyword.Node, (PunctuationSyntax)openParenToken.Node, firstExpression, (PunctuationSyntax)commaToken.Node, secondExpression, (PunctuationSyntax)closeParenToken.Node);
			IL_0306:
			SyntaxKind syntaxKind5 = VisualBasicExtensions.Kind(commaToken);
			if (syntaxKind5 != SyntaxKind.CommaToken)
			{
				throw new ArgumentException("commaToken");
			}
			if (secondExpression == null)
			{
				throw new ArgumentNullException("secondExpression");
			}
			SyntaxKind syntaxKind6 = secondExpression.Kind();
			if (syntaxKind6 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind6)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05fc;
				}
			}
			else if (syntaxKind6 - 711 <= SyntaxKind.EmptyStatement || syntaxKind6 - 779 <= SyntaxKind.List || syntaxKind6 - 788 <= SyntaxKind.List)
			{
				goto IL_05fc;
			}
			throw new ArgumentException("secondExpression");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax BinaryConditionalExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax firstExpression, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax secondExpression)
		{
			return BinaryConditionalExpression(Token(SyntaxKind.IfKeyword), Token(SyntaxKind.OpenParenToken), firstExpression, Token(SyntaxKind.CommaToken), secondExpression, Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax TernaryConditionalExpression(SyntaxToken ifKeyword, SyntaxToken openParenToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition, SyntaxToken firstCommaToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax whenTrue, SyntaxToken secondCommaToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax whenFalse, SyntaxToken closeParenToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(ifKeyword);
			if (syntaxKind != SyntaxKind.IfKeyword)
			{
				throw new ArgumentException("ifKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(openParenToken);
			if (syntaxKind2 != SyntaxKind.OpenParenToken)
			{
				throw new ArgumentException("openParenToken");
			}
			if (condition == null)
			{
				throw new ArgumentNullException("condition");
			}
			SyntaxKind syntaxKind3 = condition.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_0306;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_0306;
			}
			throw new ArgumentException("condition");
			IL_05fc:
			SyntaxKind syntaxKind4 = VisualBasicExtensions.Kind(secondCommaToken);
			if (syntaxKind4 != SyntaxKind.CommaToken)
			{
				throw new ArgumentException("secondCommaToken");
			}
			if (whenFalse == null)
			{
				throw new ArgumentNullException("whenFalse");
			}
			SyntaxKind syntaxKind5 = whenFalse.Kind();
			if (syntaxKind5 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind5)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_08f5;
				}
			}
			else if (syntaxKind5 - 711 <= SyntaxKind.EmptyStatement || syntaxKind5 - 779 <= SyntaxKind.List || syntaxKind5 - 788 <= SyntaxKind.List)
			{
				goto IL_08f5;
			}
			throw new ArgumentException("whenFalse");
			IL_0306:
			SyntaxKind syntaxKind6 = VisualBasicExtensions.Kind(firstCommaToken);
			if (syntaxKind6 != SyntaxKind.CommaToken)
			{
				throw new ArgumentException("firstCommaToken");
			}
			if (whenTrue == null)
			{
				throw new ArgumentNullException("whenTrue");
			}
			SyntaxKind syntaxKind7 = whenTrue.Kind();
			if (syntaxKind7 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind7)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05fc;
				}
			}
			else if (syntaxKind7 - 711 <= SyntaxKind.EmptyStatement || syntaxKind7 - 779 <= SyntaxKind.List || syntaxKind7 - 788 <= SyntaxKind.List)
			{
				goto IL_05fc;
			}
			throw new ArgumentException("whenTrue");
			IL_08f5:
			SyntaxKind syntaxKind8 = VisualBasicExtensions.Kind(closeParenToken);
			if (syntaxKind8 != SyntaxKind.CloseParenToken)
			{
				throw new ArgumentException("closeParenToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax(SyntaxKind.TernaryConditionalExpression, null, null, (KeywordSyntax)ifKeyword.Node, (PunctuationSyntax)openParenToken.Node, condition, (PunctuationSyntax)firstCommaToken.Node, whenTrue, (PunctuationSyntax)secondCommaToken.Node, whenFalse, (PunctuationSyntax)closeParenToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax TernaryConditionalExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax whenTrue, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax whenFalse)
		{
			return TernaryConditionalExpression(Token(SyntaxKind.IfKeyword), Token(SyntaxKind.OpenParenToken), condition, Token(SyntaxKind.CommaToken), whenTrue, Token(SyntaxKind.CommaToken), whenFalse, Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineLambdaExpressionSyntax SingleLineFunctionLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax subOrFunctionHeader, VisualBasicSyntaxNode body)
		{
			if (subOrFunctionHeader == null)
			{
				throw new ArgumentNullException("subOrFunctionHeader");
			}
			SyntaxKind syntaxKind = subOrFunctionHeader.Kind();
			if (syntaxKind - 345 > SyntaxKind.List)
			{
				throw new ArgumentException("subOrFunctionHeader");
			}
			if (body == null)
			{
				throw new ArgumentNullException("body");
			}
			SyntaxKind syntaxKind2 = body.Kind();
			if (syntaxKind2 <= SyntaxKind.ConditionalAccessExpression)
			{
				switch (syntaxKind2)
				{
				default:
					if (syntaxKind2 - 711 > SyntaxKind.EmptyStatement)
					{
						break;
					}
					goto IL_0752;
				case (SyntaxKind)3:
				case (SyntaxKind)4:
				case (SyntaxKind)28:
				case (SyntaxKind)29:
				case (SyntaxKind)30:
				case (SyntaxKind)31:
				case (SyntaxKind)32:
				case (SyntaxKind)33:
				case (SyntaxKind)34:
				case (SyntaxKind)35:
				case (SyntaxKind)36:
				case (SyntaxKind)37:
				case SyntaxKind.CompilationUnit:
				case (SyntaxKind)39:
				case (SyntaxKind)40:
				case (SyntaxKind)43:
				case SyntaxKind.SimpleImportsClause:
				case SyntaxKind.XmlNamespaceImportsClause:
				case (SyntaxKind)46:
				case (SyntaxKind)47:
				case (SyntaxKind)55:
				case (SyntaxKind)56:
				case (SyntaxKind)64:
				case (SyntaxKind)65:
				case SyntaxKind.TypeParameterList:
				case SyntaxKind.TypeParameter:
				case (SyntaxKind)68:
				case (SyntaxKind)69:
				case SyntaxKind.TypeParameterSingleConstraintClause:
				case SyntaxKind.TypeParameterMultipleConstraintClause:
				case SyntaxKind.NewConstraint:
				case SyntaxKind.ClassConstraint:
				case SyntaxKind.StructureConstraint:
				case SyntaxKind.TypeConstraint:
				case (SyntaxKind)76:
				case (SyntaxKind)77:
				case (SyntaxKind)90:
				case (SyntaxKind)91:
				case SyntaxKind.ParameterList:
				case (SyntaxKind)100:
				case (SyntaxKind)101:
				case (SyntaxKind)109:
				case (SyntaxKind)110:
				case SyntaxKind.ImplementsClause:
				case SyntaxKind.HandlesClause:
				case SyntaxKind.HandlesClauseItem:
				case (SyntaxKind)120:
				case (SyntaxKind)121:
				case SyntaxKind.VariableDeclarator:
				case SyntaxKind.SimpleAsClause:
				case SyntaxKind.AsNewClause:
				case SyntaxKind.ObjectMemberInitializer:
				case SyntaxKind.ObjectCollectionInitializer:
				case SyntaxKind.InferredFieldInitializer:
				case SyntaxKind.NamedFieldInitializer:
				case SyntaxKind.EqualsValue:
				case (SyntaxKind)130:
				case (SyntaxKind)131:
				case SyntaxKind.Parameter:
				case SyntaxKind.ModifiedIdentifier:
				case SyntaxKind.ArrayRankSpecifier:
				case SyntaxKind.AttributeList:
				case SyntaxKind.Attribute:
				case SyntaxKind.AttributeTarget:
				case (SyntaxKind)142:
				case (SyntaxKind)143:
				case (SyntaxKind)154:
				case (SyntaxKind)155:
				case SyntaxKind.SingleLineIfPart:
				case SyntaxKind.SingleLineElseClause:
				case (SyntaxKind)174:
				case (SyntaxKind)175:
				case (SyntaxKind)176:
				case (SyntaxKind)177:
				case (SyntaxKind)178:
				case (SyntaxKind)179:
				case SyntaxKind.ElseIfBlock:
				case SyntaxKind.ElseBlock:
				case (SyntaxKind)186:
				case SyntaxKind.CatchBlock:
				case SyntaxKind.FinallyBlock:
				case SyntaxKind.CatchFilterClause:
				case (SyntaxKind)192:
				case (SyntaxKind)193:
				case (SyntaxKind)205:
				case (SyntaxKind)206:
				case SyntaxKind.CaseBlock:
				case (SyntaxKind)208:
				case (SyntaxKind)209:
				case SyntaxKind.CaseElseBlock:
				case SyntaxKind.ElseCaseClause:
				case SyntaxKind.SimpleCaseClause:
				case SyntaxKind.RangeCaseClause:
				case SyntaxKind.CaseEqualsClause:
				case SyntaxKind.CaseNotEqualsClause:
				case SyntaxKind.CaseLessThanClause:
				case SyntaxKind.CaseLessThanOrEqualClause:
				case (SyntaxKind)220:
				case (SyntaxKind)221:
				case SyntaxKind.CaseGreaterThanOrEqualClause:
				case SyntaxKind.CaseGreaterThanClause:
				case (SyntaxKind)224:
				case (SyntaxKind)225:
				case (SyntaxKind)227:
				case (SyntaxKind)228:
				case (SyntaxKind)229:
				case (SyntaxKind)230:
				case (SyntaxKind)231:
				case (SyntaxKind)232:
				case (SyntaxKind)233:
				case (SyntaxKind)235:
				case (SyntaxKind)236:
				case SyntaxKind.ForStepClause:
				case (SyntaxKind)244:
				case (SyntaxKind)245:
				case (SyntaxKind)256:
				case (SyntaxKind)257:
				case (SyntaxKind)268:
				case (SyntaxKind)269:
				case SyntaxKind.RedimClause:
				case (SyntaxKind)277:
				case (SyntaxKind)278:
				case (SyntaxKind)288:
				case (SyntaxKind)289:
				case (SyntaxKind)299:
				case (SyntaxKind)300:
				case (SyntaxKind)312:
				case (SyntaxKind)313:
				case (SyntaxKind)340:
				case (SyntaxKind)341:
				case SyntaxKind.ArgumentList:
				case SyntaxKind.OmittedArgument:
				case SyntaxKind.SimpleArgument:
				case (SyntaxKind)350:
				case SyntaxKind.RangeArgument:
				case SyntaxKind.CollectionRangeVariable:
				case SyntaxKind.ExpressionRangeVariable:
				case SyntaxKind.AggregationRangeVariable:
				case SyntaxKind.VariableNameEquals:
				case SyntaxKind.FromClause:
				case SyntaxKind.LetClause:
				case SyntaxKind.AggregateClause:
				case SyntaxKind.DistinctClause:
				case SyntaxKind.WhereClause:
				case SyntaxKind.SkipWhileClause:
				case SyntaxKind.TakeWhileClause:
				case SyntaxKind.SkipClause:
				case SyntaxKind.TakeClause:
				case SyntaxKind.GroupByClause:
				case SyntaxKind.JoinCondition:
				case SyntaxKind.SimpleJoinClause:
				case SyntaxKind.GroupJoinClause:
				case SyntaxKind.OrderByClause:
				case (SyntaxKind)373:
				case (SyntaxKind)374:
				case SyntaxKind.AscendingOrdering:
				case SyntaxKind.DescendingOrdering:
				case SyntaxKind.SelectClause:
				case SyntaxKind.XmlDeclaration:
				case SyntaxKind.XmlDeclarationOption:
				case SyntaxKind.XmlPrefix:
				case SyntaxKind.TypeArgumentList:
				case SyntaxKind.CrefReference:
				case (SyntaxKind)405:
				case (SyntaxKind)406:
				case SyntaxKind.CrefSignature:
				case SyntaxKind.CrefSignaturePart:
					break;
				case SyntaxKind.EmptyStatement:
				case SyntaxKind.EndIfStatement:
				case SyntaxKind.EndUsingStatement:
				case SyntaxKind.EndWithStatement:
				case SyntaxKind.EndSelectStatement:
				case SyntaxKind.EndStructureStatement:
				case SyntaxKind.EndEnumStatement:
				case SyntaxKind.EndInterfaceStatement:
				case SyntaxKind.EndClassStatement:
				case SyntaxKind.EndModuleStatement:
				case SyntaxKind.EndNamespaceStatement:
				case SyntaxKind.EndSubStatement:
				case SyntaxKind.EndFunctionStatement:
				case SyntaxKind.EndGetStatement:
				case SyntaxKind.EndSetStatement:
				case SyntaxKind.EndPropertyStatement:
				case SyntaxKind.EndOperatorStatement:
				case SyntaxKind.EndEventStatement:
				case SyntaxKind.EndAddHandlerStatement:
				case SyntaxKind.EndRemoveHandlerStatement:
				case SyntaxKind.EndRaiseEventStatement:
				case SyntaxKind.EndWhileStatement:
				case SyntaxKind.EndTryStatement:
				case SyntaxKind.EndSyncLockStatement:
				case SyntaxKind.OptionStatement:
				case SyntaxKind.ImportsStatement:
				case SyntaxKind.NamespaceBlock:
				case SyntaxKind.NamespaceStatement:
				case SyntaxKind.ModuleBlock:
				case SyntaxKind.StructureBlock:
				case SyntaxKind.InterfaceBlock:
				case SyntaxKind.ClassBlock:
				case SyntaxKind.EnumBlock:
				case SyntaxKind.InheritsStatement:
				case SyntaxKind.ImplementsStatement:
				case SyntaxKind.ModuleStatement:
				case SyntaxKind.StructureStatement:
				case SyntaxKind.InterfaceStatement:
				case SyntaxKind.ClassStatement:
				case SyntaxKind.EnumStatement:
				case SyntaxKind.EnumMemberDeclaration:
				case SyntaxKind.SubBlock:
				case SyntaxKind.FunctionBlock:
				case SyntaxKind.ConstructorBlock:
				case SyntaxKind.OperatorBlock:
				case SyntaxKind.GetAccessorBlock:
				case SyntaxKind.SetAccessorBlock:
				case SyntaxKind.AddHandlerAccessorBlock:
				case SyntaxKind.RemoveHandlerAccessorBlock:
				case SyntaxKind.RaiseEventAccessorBlock:
				case SyntaxKind.PropertyBlock:
				case SyntaxKind.EventBlock:
				case SyntaxKind.SubStatement:
				case SyntaxKind.FunctionStatement:
				case SyntaxKind.SubNewStatement:
				case SyntaxKind.DeclareSubStatement:
				case SyntaxKind.DeclareFunctionStatement:
				case SyntaxKind.DelegateSubStatement:
				case SyntaxKind.DelegateFunctionStatement:
				case SyntaxKind.EventStatement:
				case SyntaxKind.OperatorStatement:
				case SyntaxKind.PropertyStatement:
				case SyntaxKind.GetAccessorStatement:
				case SyntaxKind.SetAccessorStatement:
				case SyntaxKind.AddHandlerAccessorStatement:
				case SyntaxKind.RemoveHandlerAccessorStatement:
				case SyntaxKind.RaiseEventAccessorStatement:
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IncompleteMember:
				case SyntaxKind.FieldDeclaration:
				case SyntaxKind.AttributesStatement:
				case SyntaxKind.ExpressionStatement:
				case SyntaxKind.PrintStatement:
				case SyntaxKind.WhileBlock:
				case SyntaxKind.UsingBlock:
				case SyntaxKind.SyncLockBlock:
				case SyntaxKind.WithBlock:
				case SyntaxKind.LocalDeclarationStatement:
				case SyntaxKind.LabelStatement:
				case SyntaxKind.GoToStatement:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.StopStatement:
				case SyntaxKind.EndStatement:
				case SyntaxKind.ExitDoStatement:
				case SyntaxKind.ExitForStatement:
				case SyntaxKind.ExitSubStatement:
				case SyntaxKind.ExitFunctionStatement:
				case SyntaxKind.ExitOperatorStatement:
				case SyntaxKind.ExitPropertyStatement:
				case SyntaxKind.ExitTryStatement:
				case SyntaxKind.ExitSelectStatement:
				case SyntaxKind.ExitWhileStatement:
				case SyntaxKind.ContinueWhileStatement:
				case SyntaxKind.ContinueDoStatement:
				case SyntaxKind.ContinueForStatement:
				case SyntaxKind.ReturnStatement:
				case SyntaxKind.SingleLineIfStatement:
				case SyntaxKind.MultiLineIfBlock:
				case SyntaxKind.IfStatement:
				case SyntaxKind.ElseIfStatement:
				case SyntaxKind.ElseStatement:
				case SyntaxKind.TryBlock:
				case SyntaxKind.TryStatement:
				case SyntaxKind.CatchStatement:
				case SyntaxKind.FinallyStatement:
				case SyntaxKind.ErrorStatement:
				case SyntaxKind.OnErrorGoToZeroStatement:
				case SyntaxKind.OnErrorGoToMinusOneStatement:
				case SyntaxKind.OnErrorGoToLabelStatement:
				case SyntaxKind.OnErrorResumeNextStatement:
				case SyntaxKind.ResumeStatement:
				case SyntaxKind.ResumeLabelStatement:
				case SyntaxKind.ResumeNextStatement:
				case SyntaxKind.SelectBlock:
				case SyntaxKind.SelectStatement:
				case SyntaxKind.CaseStatement:
				case SyntaxKind.CaseElseStatement:
				case SyntaxKind.SyncLockStatement:
				case SyntaxKind.WhileStatement:
				case SyntaxKind.ForBlock:
				case SyntaxKind.ForEachBlock:
				case SyntaxKind.ForStatement:
				case SyntaxKind.ForEachStatement:
				case SyntaxKind.NextStatement:
				case SyntaxKind.UsingStatement:
				case SyntaxKind.ThrowStatement:
				case SyntaxKind.SimpleAssignmentStatement:
				case SyntaxKind.MidAssignmentStatement:
				case SyntaxKind.AddAssignmentStatement:
				case SyntaxKind.SubtractAssignmentStatement:
				case SyntaxKind.MultiplyAssignmentStatement:
				case SyntaxKind.DivideAssignmentStatement:
				case SyntaxKind.IntegerDivideAssignmentStatement:
				case SyntaxKind.ExponentiateAssignmentStatement:
				case SyntaxKind.LeftShiftAssignmentStatement:
				case SyntaxKind.RightShiftAssignmentStatement:
				case SyntaxKind.ConcatenateAssignmentStatement:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CallStatement:
				case SyntaxKind.AddHandlerStatement:
				case SyntaxKind.RemoveHandlerStatement:
				case SyntaxKind.RaiseEventStatement:
				case SyntaxKind.WithStatement:
				case SyntaxKind.ReDimStatement:
				case SyntaxKind.ReDimPreserveStatement:
				case SyntaxKind.EraseStatement:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.SubLambdaHeader:
				case SyntaxKind.FunctionLambdaHeader:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.YieldStatement:
				case SyntaxKind.AwaitExpression:
					goto IL_0752;
				}
			}
			else
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.SimpleDoLoopBlock:
				case SyntaxKind.DoWhileLoopBlock:
				case SyntaxKind.DoUntilLoopBlock:
				case SyntaxKind.DoLoopWhileBlock:
				case SyntaxKind.DoLoopUntilBlock:
				case SyntaxKind.SimpleDoStatement:
				case SyntaxKind.DoWhileStatement:
				case SyntaxKind.DoUntilStatement:
				case SyntaxKind.SimpleLoopStatement:
				case SyntaxKind.LoopWhileStatement:
				case SyntaxKind.LoopUntilStatement:
				case SyntaxKind.NameOfExpression:
				case SyntaxKind.InterpolatedStringExpression:
				case SyntaxKind.TupleExpression:
				case SyntaxKind.TupleType:
					goto IL_0752;
				}
			}
			throw new ArgumentException("body");
			IL_0752:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineLambdaExpressionSyntax(SyntaxKind.SingleLineFunctionLambdaExpression, null, null, subOrFunctionHeader, body);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineLambdaExpressionSyntax SingleLineSubLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax subOrFunctionHeader, VisualBasicSyntaxNode body)
		{
			if (subOrFunctionHeader == null)
			{
				throw new ArgumentNullException("subOrFunctionHeader");
			}
			SyntaxKind syntaxKind = subOrFunctionHeader.Kind();
			if (syntaxKind - 345 > SyntaxKind.List)
			{
				throw new ArgumentException("subOrFunctionHeader");
			}
			if (body == null)
			{
				throw new ArgumentNullException("body");
			}
			SyntaxKind syntaxKind2 = body.Kind();
			if (syntaxKind2 <= SyntaxKind.ConditionalAccessExpression)
			{
				switch (syntaxKind2)
				{
				default:
					if (syntaxKind2 - 711 > SyntaxKind.EmptyStatement)
					{
						break;
					}
					goto IL_0752;
				case (SyntaxKind)3:
				case (SyntaxKind)4:
				case (SyntaxKind)28:
				case (SyntaxKind)29:
				case (SyntaxKind)30:
				case (SyntaxKind)31:
				case (SyntaxKind)32:
				case (SyntaxKind)33:
				case (SyntaxKind)34:
				case (SyntaxKind)35:
				case (SyntaxKind)36:
				case (SyntaxKind)37:
				case SyntaxKind.CompilationUnit:
				case (SyntaxKind)39:
				case (SyntaxKind)40:
				case (SyntaxKind)43:
				case SyntaxKind.SimpleImportsClause:
				case SyntaxKind.XmlNamespaceImportsClause:
				case (SyntaxKind)46:
				case (SyntaxKind)47:
				case (SyntaxKind)55:
				case (SyntaxKind)56:
				case (SyntaxKind)64:
				case (SyntaxKind)65:
				case SyntaxKind.TypeParameterList:
				case SyntaxKind.TypeParameter:
				case (SyntaxKind)68:
				case (SyntaxKind)69:
				case SyntaxKind.TypeParameterSingleConstraintClause:
				case SyntaxKind.TypeParameterMultipleConstraintClause:
				case SyntaxKind.NewConstraint:
				case SyntaxKind.ClassConstraint:
				case SyntaxKind.StructureConstraint:
				case SyntaxKind.TypeConstraint:
				case (SyntaxKind)76:
				case (SyntaxKind)77:
				case (SyntaxKind)90:
				case (SyntaxKind)91:
				case SyntaxKind.ParameterList:
				case (SyntaxKind)100:
				case (SyntaxKind)101:
				case (SyntaxKind)109:
				case (SyntaxKind)110:
				case SyntaxKind.ImplementsClause:
				case SyntaxKind.HandlesClause:
				case SyntaxKind.HandlesClauseItem:
				case (SyntaxKind)120:
				case (SyntaxKind)121:
				case SyntaxKind.VariableDeclarator:
				case SyntaxKind.SimpleAsClause:
				case SyntaxKind.AsNewClause:
				case SyntaxKind.ObjectMemberInitializer:
				case SyntaxKind.ObjectCollectionInitializer:
				case SyntaxKind.InferredFieldInitializer:
				case SyntaxKind.NamedFieldInitializer:
				case SyntaxKind.EqualsValue:
				case (SyntaxKind)130:
				case (SyntaxKind)131:
				case SyntaxKind.Parameter:
				case SyntaxKind.ModifiedIdentifier:
				case SyntaxKind.ArrayRankSpecifier:
				case SyntaxKind.AttributeList:
				case SyntaxKind.Attribute:
				case SyntaxKind.AttributeTarget:
				case (SyntaxKind)142:
				case (SyntaxKind)143:
				case (SyntaxKind)154:
				case (SyntaxKind)155:
				case SyntaxKind.SingleLineIfPart:
				case SyntaxKind.SingleLineElseClause:
				case (SyntaxKind)174:
				case (SyntaxKind)175:
				case (SyntaxKind)176:
				case (SyntaxKind)177:
				case (SyntaxKind)178:
				case (SyntaxKind)179:
				case SyntaxKind.ElseIfBlock:
				case SyntaxKind.ElseBlock:
				case (SyntaxKind)186:
				case SyntaxKind.CatchBlock:
				case SyntaxKind.FinallyBlock:
				case SyntaxKind.CatchFilterClause:
				case (SyntaxKind)192:
				case (SyntaxKind)193:
				case (SyntaxKind)205:
				case (SyntaxKind)206:
				case SyntaxKind.CaseBlock:
				case (SyntaxKind)208:
				case (SyntaxKind)209:
				case SyntaxKind.CaseElseBlock:
				case SyntaxKind.ElseCaseClause:
				case SyntaxKind.SimpleCaseClause:
				case SyntaxKind.RangeCaseClause:
				case SyntaxKind.CaseEqualsClause:
				case SyntaxKind.CaseNotEqualsClause:
				case SyntaxKind.CaseLessThanClause:
				case SyntaxKind.CaseLessThanOrEqualClause:
				case (SyntaxKind)220:
				case (SyntaxKind)221:
				case SyntaxKind.CaseGreaterThanOrEqualClause:
				case SyntaxKind.CaseGreaterThanClause:
				case (SyntaxKind)224:
				case (SyntaxKind)225:
				case (SyntaxKind)227:
				case (SyntaxKind)228:
				case (SyntaxKind)229:
				case (SyntaxKind)230:
				case (SyntaxKind)231:
				case (SyntaxKind)232:
				case (SyntaxKind)233:
				case (SyntaxKind)235:
				case (SyntaxKind)236:
				case SyntaxKind.ForStepClause:
				case (SyntaxKind)244:
				case (SyntaxKind)245:
				case (SyntaxKind)256:
				case (SyntaxKind)257:
				case (SyntaxKind)268:
				case (SyntaxKind)269:
				case SyntaxKind.RedimClause:
				case (SyntaxKind)277:
				case (SyntaxKind)278:
				case (SyntaxKind)288:
				case (SyntaxKind)289:
				case (SyntaxKind)299:
				case (SyntaxKind)300:
				case (SyntaxKind)312:
				case (SyntaxKind)313:
				case (SyntaxKind)340:
				case (SyntaxKind)341:
				case SyntaxKind.ArgumentList:
				case SyntaxKind.OmittedArgument:
				case SyntaxKind.SimpleArgument:
				case (SyntaxKind)350:
				case SyntaxKind.RangeArgument:
				case SyntaxKind.CollectionRangeVariable:
				case SyntaxKind.ExpressionRangeVariable:
				case SyntaxKind.AggregationRangeVariable:
				case SyntaxKind.VariableNameEquals:
				case SyntaxKind.FromClause:
				case SyntaxKind.LetClause:
				case SyntaxKind.AggregateClause:
				case SyntaxKind.DistinctClause:
				case SyntaxKind.WhereClause:
				case SyntaxKind.SkipWhileClause:
				case SyntaxKind.TakeWhileClause:
				case SyntaxKind.SkipClause:
				case SyntaxKind.TakeClause:
				case SyntaxKind.GroupByClause:
				case SyntaxKind.JoinCondition:
				case SyntaxKind.SimpleJoinClause:
				case SyntaxKind.GroupJoinClause:
				case SyntaxKind.OrderByClause:
				case (SyntaxKind)373:
				case (SyntaxKind)374:
				case SyntaxKind.AscendingOrdering:
				case SyntaxKind.DescendingOrdering:
				case SyntaxKind.SelectClause:
				case SyntaxKind.XmlDeclaration:
				case SyntaxKind.XmlDeclarationOption:
				case SyntaxKind.XmlPrefix:
				case SyntaxKind.TypeArgumentList:
				case SyntaxKind.CrefReference:
				case (SyntaxKind)405:
				case (SyntaxKind)406:
				case SyntaxKind.CrefSignature:
				case SyntaxKind.CrefSignaturePart:
					break;
				case SyntaxKind.EmptyStatement:
				case SyntaxKind.EndIfStatement:
				case SyntaxKind.EndUsingStatement:
				case SyntaxKind.EndWithStatement:
				case SyntaxKind.EndSelectStatement:
				case SyntaxKind.EndStructureStatement:
				case SyntaxKind.EndEnumStatement:
				case SyntaxKind.EndInterfaceStatement:
				case SyntaxKind.EndClassStatement:
				case SyntaxKind.EndModuleStatement:
				case SyntaxKind.EndNamespaceStatement:
				case SyntaxKind.EndSubStatement:
				case SyntaxKind.EndFunctionStatement:
				case SyntaxKind.EndGetStatement:
				case SyntaxKind.EndSetStatement:
				case SyntaxKind.EndPropertyStatement:
				case SyntaxKind.EndOperatorStatement:
				case SyntaxKind.EndEventStatement:
				case SyntaxKind.EndAddHandlerStatement:
				case SyntaxKind.EndRemoveHandlerStatement:
				case SyntaxKind.EndRaiseEventStatement:
				case SyntaxKind.EndWhileStatement:
				case SyntaxKind.EndTryStatement:
				case SyntaxKind.EndSyncLockStatement:
				case SyntaxKind.OptionStatement:
				case SyntaxKind.ImportsStatement:
				case SyntaxKind.NamespaceBlock:
				case SyntaxKind.NamespaceStatement:
				case SyntaxKind.ModuleBlock:
				case SyntaxKind.StructureBlock:
				case SyntaxKind.InterfaceBlock:
				case SyntaxKind.ClassBlock:
				case SyntaxKind.EnumBlock:
				case SyntaxKind.InheritsStatement:
				case SyntaxKind.ImplementsStatement:
				case SyntaxKind.ModuleStatement:
				case SyntaxKind.StructureStatement:
				case SyntaxKind.InterfaceStatement:
				case SyntaxKind.ClassStatement:
				case SyntaxKind.EnumStatement:
				case SyntaxKind.EnumMemberDeclaration:
				case SyntaxKind.SubBlock:
				case SyntaxKind.FunctionBlock:
				case SyntaxKind.ConstructorBlock:
				case SyntaxKind.OperatorBlock:
				case SyntaxKind.GetAccessorBlock:
				case SyntaxKind.SetAccessorBlock:
				case SyntaxKind.AddHandlerAccessorBlock:
				case SyntaxKind.RemoveHandlerAccessorBlock:
				case SyntaxKind.RaiseEventAccessorBlock:
				case SyntaxKind.PropertyBlock:
				case SyntaxKind.EventBlock:
				case SyntaxKind.SubStatement:
				case SyntaxKind.FunctionStatement:
				case SyntaxKind.SubNewStatement:
				case SyntaxKind.DeclareSubStatement:
				case SyntaxKind.DeclareFunctionStatement:
				case SyntaxKind.DelegateSubStatement:
				case SyntaxKind.DelegateFunctionStatement:
				case SyntaxKind.EventStatement:
				case SyntaxKind.OperatorStatement:
				case SyntaxKind.PropertyStatement:
				case SyntaxKind.GetAccessorStatement:
				case SyntaxKind.SetAccessorStatement:
				case SyntaxKind.AddHandlerAccessorStatement:
				case SyntaxKind.RemoveHandlerAccessorStatement:
				case SyntaxKind.RaiseEventAccessorStatement:
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IncompleteMember:
				case SyntaxKind.FieldDeclaration:
				case SyntaxKind.AttributesStatement:
				case SyntaxKind.ExpressionStatement:
				case SyntaxKind.PrintStatement:
				case SyntaxKind.WhileBlock:
				case SyntaxKind.UsingBlock:
				case SyntaxKind.SyncLockBlock:
				case SyntaxKind.WithBlock:
				case SyntaxKind.LocalDeclarationStatement:
				case SyntaxKind.LabelStatement:
				case SyntaxKind.GoToStatement:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.StopStatement:
				case SyntaxKind.EndStatement:
				case SyntaxKind.ExitDoStatement:
				case SyntaxKind.ExitForStatement:
				case SyntaxKind.ExitSubStatement:
				case SyntaxKind.ExitFunctionStatement:
				case SyntaxKind.ExitOperatorStatement:
				case SyntaxKind.ExitPropertyStatement:
				case SyntaxKind.ExitTryStatement:
				case SyntaxKind.ExitSelectStatement:
				case SyntaxKind.ExitWhileStatement:
				case SyntaxKind.ContinueWhileStatement:
				case SyntaxKind.ContinueDoStatement:
				case SyntaxKind.ContinueForStatement:
				case SyntaxKind.ReturnStatement:
				case SyntaxKind.SingleLineIfStatement:
				case SyntaxKind.MultiLineIfBlock:
				case SyntaxKind.IfStatement:
				case SyntaxKind.ElseIfStatement:
				case SyntaxKind.ElseStatement:
				case SyntaxKind.TryBlock:
				case SyntaxKind.TryStatement:
				case SyntaxKind.CatchStatement:
				case SyntaxKind.FinallyStatement:
				case SyntaxKind.ErrorStatement:
				case SyntaxKind.OnErrorGoToZeroStatement:
				case SyntaxKind.OnErrorGoToMinusOneStatement:
				case SyntaxKind.OnErrorGoToLabelStatement:
				case SyntaxKind.OnErrorResumeNextStatement:
				case SyntaxKind.ResumeStatement:
				case SyntaxKind.ResumeLabelStatement:
				case SyntaxKind.ResumeNextStatement:
				case SyntaxKind.SelectBlock:
				case SyntaxKind.SelectStatement:
				case SyntaxKind.CaseStatement:
				case SyntaxKind.CaseElseStatement:
				case SyntaxKind.SyncLockStatement:
				case SyntaxKind.WhileStatement:
				case SyntaxKind.ForBlock:
				case SyntaxKind.ForEachBlock:
				case SyntaxKind.ForStatement:
				case SyntaxKind.ForEachStatement:
				case SyntaxKind.NextStatement:
				case SyntaxKind.UsingStatement:
				case SyntaxKind.ThrowStatement:
				case SyntaxKind.SimpleAssignmentStatement:
				case SyntaxKind.MidAssignmentStatement:
				case SyntaxKind.AddAssignmentStatement:
				case SyntaxKind.SubtractAssignmentStatement:
				case SyntaxKind.MultiplyAssignmentStatement:
				case SyntaxKind.DivideAssignmentStatement:
				case SyntaxKind.IntegerDivideAssignmentStatement:
				case SyntaxKind.ExponentiateAssignmentStatement:
				case SyntaxKind.LeftShiftAssignmentStatement:
				case SyntaxKind.RightShiftAssignmentStatement:
				case SyntaxKind.ConcatenateAssignmentStatement:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CallStatement:
				case SyntaxKind.AddHandlerStatement:
				case SyntaxKind.RemoveHandlerStatement:
				case SyntaxKind.RaiseEventStatement:
				case SyntaxKind.WithStatement:
				case SyntaxKind.ReDimStatement:
				case SyntaxKind.ReDimPreserveStatement:
				case SyntaxKind.EraseStatement:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.SubLambdaHeader:
				case SyntaxKind.FunctionLambdaHeader:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.YieldStatement:
				case SyntaxKind.AwaitExpression:
					goto IL_0752;
				}
			}
			else
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.SimpleDoLoopBlock:
				case SyntaxKind.DoWhileLoopBlock:
				case SyntaxKind.DoUntilLoopBlock:
				case SyntaxKind.DoLoopWhileBlock:
				case SyntaxKind.DoLoopUntilBlock:
				case SyntaxKind.SimpleDoStatement:
				case SyntaxKind.DoWhileStatement:
				case SyntaxKind.DoUntilStatement:
				case SyntaxKind.SimpleLoopStatement:
				case SyntaxKind.LoopWhileStatement:
				case SyntaxKind.LoopUntilStatement:
				case SyntaxKind.NameOfExpression:
				case SyntaxKind.InterpolatedStringExpression:
				case SyntaxKind.TupleExpression:
				case SyntaxKind.TupleType:
					goto IL_0752;
				}
			}
			throw new ArgumentException("body");
			IL_0752:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineLambdaExpressionSyntax(SyntaxKind.SingleLineSubLambdaExpression, null, null, subOrFunctionHeader, body);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineLambdaExpressionSyntax SingleLineLambdaExpression(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax subOrFunctionHeader, VisualBasicSyntaxNode body)
		{
			if (!SyntaxFacts.IsSingleLineLambdaExpression(kind))
			{
				throw new ArgumentException("kind");
			}
			if (subOrFunctionHeader == null)
			{
				throw new ArgumentNullException("subOrFunctionHeader");
			}
			SyntaxKind syntaxKind = subOrFunctionHeader.Kind();
			if (syntaxKind - 345 > SyntaxKind.List)
			{
				throw new ArgumentException("subOrFunctionHeader");
			}
			if (body == null)
			{
				throw new ArgumentNullException("body");
			}
			SyntaxKind syntaxKind2 = body.Kind();
			if (syntaxKind2 <= SyntaxKind.ConditionalAccessExpression)
			{
				switch (syntaxKind2)
				{
				default:
					if (syntaxKind2 - 711 > SyntaxKind.EmptyStatement)
					{
						break;
					}
					goto IL_0765;
				case (SyntaxKind)3:
				case (SyntaxKind)4:
				case (SyntaxKind)28:
				case (SyntaxKind)29:
				case (SyntaxKind)30:
				case (SyntaxKind)31:
				case (SyntaxKind)32:
				case (SyntaxKind)33:
				case (SyntaxKind)34:
				case (SyntaxKind)35:
				case (SyntaxKind)36:
				case (SyntaxKind)37:
				case SyntaxKind.CompilationUnit:
				case (SyntaxKind)39:
				case (SyntaxKind)40:
				case (SyntaxKind)43:
				case SyntaxKind.SimpleImportsClause:
				case SyntaxKind.XmlNamespaceImportsClause:
				case (SyntaxKind)46:
				case (SyntaxKind)47:
				case (SyntaxKind)55:
				case (SyntaxKind)56:
				case (SyntaxKind)64:
				case (SyntaxKind)65:
				case SyntaxKind.TypeParameterList:
				case SyntaxKind.TypeParameter:
				case (SyntaxKind)68:
				case (SyntaxKind)69:
				case SyntaxKind.TypeParameterSingleConstraintClause:
				case SyntaxKind.TypeParameterMultipleConstraintClause:
				case SyntaxKind.NewConstraint:
				case SyntaxKind.ClassConstraint:
				case SyntaxKind.StructureConstraint:
				case SyntaxKind.TypeConstraint:
				case (SyntaxKind)76:
				case (SyntaxKind)77:
				case (SyntaxKind)90:
				case (SyntaxKind)91:
				case SyntaxKind.ParameterList:
				case (SyntaxKind)100:
				case (SyntaxKind)101:
				case (SyntaxKind)109:
				case (SyntaxKind)110:
				case SyntaxKind.ImplementsClause:
				case SyntaxKind.HandlesClause:
				case SyntaxKind.HandlesClauseItem:
				case (SyntaxKind)120:
				case (SyntaxKind)121:
				case SyntaxKind.VariableDeclarator:
				case SyntaxKind.SimpleAsClause:
				case SyntaxKind.AsNewClause:
				case SyntaxKind.ObjectMemberInitializer:
				case SyntaxKind.ObjectCollectionInitializer:
				case SyntaxKind.InferredFieldInitializer:
				case SyntaxKind.NamedFieldInitializer:
				case SyntaxKind.EqualsValue:
				case (SyntaxKind)130:
				case (SyntaxKind)131:
				case SyntaxKind.Parameter:
				case SyntaxKind.ModifiedIdentifier:
				case SyntaxKind.ArrayRankSpecifier:
				case SyntaxKind.AttributeList:
				case SyntaxKind.Attribute:
				case SyntaxKind.AttributeTarget:
				case (SyntaxKind)142:
				case (SyntaxKind)143:
				case (SyntaxKind)154:
				case (SyntaxKind)155:
				case SyntaxKind.SingleLineIfPart:
				case SyntaxKind.SingleLineElseClause:
				case (SyntaxKind)174:
				case (SyntaxKind)175:
				case (SyntaxKind)176:
				case (SyntaxKind)177:
				case (SyntaxKind)178:
				case (SyntaxKind)179:
				case SyntaxKind.ElseIfBlock:
				case SyntaxKind.ElseBlock:
				case (SyntaxKind)186:
				case SyntaxKind.CatchBlock:
				case SyntaxKind.FinallyBlock:
				case SyntaxKind.CatchFilterClause:
				case (SyntaxKind)192:
				case (SyntaxKind)193:
				case (SyntaxKind)205:
				case (SyntaxKind)206:
				case SyntaxKind.CaseBlock:
				case (SyntaxKind)208:
				case (SyntaxKind)209:
				case SyntaxKind.CaseElseBlock:
				case SyntaxKind.ElseCaseClause:
				case SyntaxKind.SimpleCaseClause:
				case SyntaxKind.RangeCaseClause:
				case SyntaxKind.CaseEqualsClause:
				case SyntaxKind.CaseNotEqualsClause:
				case SyntaxKind.CaseLessThanClause:
				case SyntaxKind.CaseLessThanOrEqualClause:
				case (SyntaxKind)220:
				case (SyntaxKind)221:
				case SyntaxKind.CaseGreaterThanOrEqualClause:
				case SyntaxKind.CaseGreaterThanClause:
				case (SyntaxKind)224:
				case (SyntaxKind)225:
				case (SyntaxKind)227:
				case (SyntaxKind)228:
				case (SyntaxKind)229:
				case (SyntaxKind)230:
				case (SyntaxKind)231:
				case (SyntaxKind)232:
				case (SyntaxKind)233:
				case (SyntaxKind)235:
				case (SyntaxKind)236:
				case SyntaxKind.ForStepClause:
				case (SyntaxKind)244:
				case (SyntaxKind)245:
				case (SyntaxKind)256:
				case (SyntaxKind)257:
				case (SyntaxKind)268:
				case (SyntaxKind)269:
				case SyntaxKind.RedimClause:
				case (SyntaxKind)277:
				case (SyntaxKind)278:
				case (SyntaxKind)288:
				case (SyntaxKind)289:
				case (SyntaxKind)299:
				case (SyntaxKind)300:
				case (SyntaxKind)312:
				case (SyntaxKind)313:
				case (SyntaxKind)340:
				case (SyntaxKind)341:
				case SyntaxKind.ArgumentList:
				case SyntaxKind.OmittedArgument:
				case SyntaxKind.SimpleArgument:
				case (SyntaxKind)350:
				case SyntaxKind.RangeArgument:
				case SyntaxKind.CollectionRangeVariable:
				case SyntaxKind.ExpressionRangeVariable:
				case SyntaxKind.AggregationRangeVariable:
				case SyntaxKind.VariableNameEquals:
				case SyntaxKind.FromClause:
				case SyntaxKind.LetClause:
				case SyntaxKind.AggregateClause:
				case SyntaxKind.DistinctClause:
				case SyntaxKind.WhereClause:
				case SyntaxKind.SkipWhileClause:
				case SyntaxKind.TakeWhileClause:
				case SyntaxKind.SkipClause:
				case SyntaxKind.TakeClause:
				case SyntaxKind.GroupByClause:
				case SyntaxKind.JoinCondition:
				case SyntaxKind.SimpleJoinClause:
				case SyntaxKind.GroupJoinClause:
				case SyntaxKind.OrderByClause:
				case (SyntaxKind)373:
				case (SyntaxKind)374:
				case SyntaxKind.AscendingOrdering:
				case SyntaxKind.DescendingOrdering:
				case SyntaxKind.SelectClause:
				case SyntaxKind.XmlDeclaration:
				case SyntaxKind.XmlDeclarationOption:
				case SyntaxKind.XmlPrefix:
				case SyntaxKind.TypeArgumentList:
				case SyntaxKind.CrefReference:
				case (SyntaxKind)405:
				case (SyntaxKind)406:
				case SyntaxKind.CrefSignature:
				case SyntaxKind.CrefSignaturePart:
					break;
				case SyntaxKind.EmptyStatement:
				case SyntaxKind.EndIfStatement:
				case SyntaxKind.EndUsingStatement:
				case SyntaxKind.EndWithStatement:
				case SyntaxKind.EndSelectStatement:
				case SyntaxKind.EndStructureStatement:
				case SyntaxKind.EndEnumStatement:
				case SyntaxKind.EndInterfaceStatement:
				case SyntaxKind.EndClassStatement:
				case SyntaxKind.EndModuleStatement:
				case SyntaxKind.EndNamespaceStatement:
				case SyntaxKind.EndSubStatement:
				case SyntaxKind.EndFunctionStatement:
				case SyntaxKind.EndGetStatement:
				case SyntaxKind.EndSetStatement:
				case SyntaxKind.EndPropertyStatement:
				case SyntaxKind.EndOperatorStatement:
				case SyntaxKind.EndEventStatement:
				case SyntaxKind.EndAddHandlerStatement:
				case SyntaxKind.EndRemoveHandlerStatement:
				case SyntaxKind.EndRaiseEventStatement:
				case SyntaxKind.EndWhileStatement:
				case SyntaxKind.EndTryStatement:
				case SyntaxKind.EndSyncLockStatement:
				case SyntaxKind.OptionStatement:
				case SyntaxKind.ImportsStatement:
				case SyntaxKind.NamespaceBlock:
				case SyntaxKind.NamespaceStatement:
				case SyntaxKind.ModuleBlock:
				case SyntaxKind.StructureBlock:
				case SyntaxKind.InterfaceBlock:
				case SyntaxKind.ClassBlock:
				case SyntaxKind.EnumBlock:
				case SyntaxKind.InheritsStatement:
				case SyntaxKind.ImplementsStatement:
				case SyntaxKind.ModuleStatement:
				case SyntaxKind.StructureStatement:
				case SyntaxKind.InterfaceStatement:
				case SyntaxKind.ClassStatement:
				case SyntaxKind.EnumStatement:
				case SyntaxKind.EnumMemberDeclaration:
				case SyntaxKind.SubBlock:
				case SyntaxKind.FunctionBlock:
				case SyntaxKind.ConstructorBlock:
				case SyntaxKind.OperatorBlock:
				case SyntaxKind.GetAccessorBlock:
				case SyntaxKind.SetAccessorBlock:
				case SyntaxKind.AddHandlerAccessorBlock:
				case SyntaxKind.RemoveHandlerAccessorBlock:
				case SyntaxKind.RaiseEventAccessorBlock:
				case SyntaxKind.PropertyBlock:
				case SyntaxKind.EventBlock:
				case SyntaxKind.SubStatement:
				case SyntaxKind.FunctionStatement:
				case SyntaxKind.SubNewStatement:
				case SyntaxKind.DeclareSubStatement:
				case SyntaxKind.DeclareFunctionStatement:
				case SyntaxKind.DelegateSubStatement:
				case SyntaxKind.DelegateFunctionStatement:
				case SyntaxKind.EventStatement:
				case SyntaxKind.OperatorStatement:
				case SyntaxKind.PropertyStatement:
				case SyntaxKind.GetAccessorStatement:
				case SyntaxKind.SetAccessorStatement:
				case SyntaxKind.AddHandlerAccessorStatement:
				case SyntaxKind.RemoveHandlerAccessorStatement:
				case SyntaxKind.RaiseEventAccessorStatement:
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IncompleteMember:
				case SyntaxKind.FieldDeclaration:
				case SyntaxKind.AttributesStatement:
				case SyntaxKind.ExpressionStatement:
				case SyntaxKind.PrintStatement:
				case SyntaxKind.WhileBlock:
				case SyntaxKind.UsingBlock:
				case SyntaxKind.SyncLockBlock:
				case SyntaxKind.WithBlock:
				case SyntaxKind.LocalDeclarationStatement:
				case SyntaxKind.LabelStatement:
				case SyntaxKind.GoToStatement:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.StopStatement:
				case SyntaxKind.EndStatement:
				case SyntaxKind.ExitDoStatement:
				case SyntaxKind.ExitForStatement:
				case SyntaxKind.ExitSubStatement:
				case SyntaxKind.ExitFunctionStatement:
				case SyntaxKind.ExitOperatorStatement:
				case SyntaxKind.ExitPropertyStatement:
				case SyntaxKind.ExitTryStatement:
				case SyntaxKind.ExitSelectStatement:
				case SyntaxKind.ExitWhileStatement:
				case SyntaxKind.ContinueWhileStatement:
				case SyntaxKind.ContinueDoStatement:
				case SyntaxKind.ContinueForStatement:
				case SyntaxKind.ReturnStatement:
				case SyntaxKind.SingleLineIfStatement:
				case SyntaxKind.MultiLineIfBlock:
				case SyntaxKind.IfStatement:
				case SyntaxKind.ElseIfStatement:
				case SyntaxKind.ElseStatement:
				case SyntaxKind.TryBlock:
				case SyntaxKind.TryStatement:
				case SyntaxKind.CatchStatement:
				case SyntaxKind.FinallyStatement:
				case SyntaxKind.ErrorStatement:
				case SyntaxKind.OnErrorGoToZeroStatement:
				case SyntaxKind.OnErrorGoToMinusOneStatement:
				case SyntaxKind.OnErrorGoToLabelStatement:
				case SyntaxKind.OnErrorResumeNextStatement:
				case SyntaxKind.ResumeStatement:
				case SyntaxKind.ResumeLabelStatement:
				case SyntaxKind.ResumeNextStatement:
				case SyntaxKind.SelectBlock:
				case SyntaxKind.SelectStatement:
				case SyntaxKind.CaseStatement:
				case SyntaxKind.CaseElseStatement:
				case SyntaxKind.SyncLockStatement:
				case SyntaxKind.WhileStatement:
				case SyntaxKind.ForBlock:
				case SyntaxKind.ForEachBlock:
				case SyntaxKind.ForStatement:
				case SyntaxKind.ForEachStatement:
				case SyntaxKind.NextStatement:
				case SyntaxKind.UsingStatement:
				case SyntaxKind.ThrowStatement:
				case SyntaxKind.SimpleAssignmentStatement:
				case SyntaxKind.MidAssignmentStatement:
				case SyntaxKind.AddAssignmentStatement:
				case SyntaxKind.SubtractAssignmentStatement:
				case SyntaxKind.MultiplyAssignmentStatement:
				case SyntaxKind.DivideAssignmentStatement:
				case SyntaxKind.IntegerDivideAssignmentStatement:
				case SyntaxKind.ExponentiateAssignmentStatement:
				case SyntaxKind.LeftShiftAssignmentStatement:
				case SyntaxKind.RightShiftAssignmentStatement:
				case SyntaxKind.ConcatenateAssignmentStatement:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CallStatement:
				case SyntaxKind.AddHandlerStatement:
				case SyntaxKind.RemoveHandlerStatement:
				case SyntaxKind.RaiseEventStatement:
				case SyntaxKind.WithStatement:
				case SyntaxKind.ReDimStatement:
				case SyntaxKind.ReDimPreserveStatement:
				case SyntaxKind.EraseStatement:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.SubLambdaHeader:
				case SyntaxKind.FunctionLambdaHeader:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.YieldStatement:
				case SyntaxKind.AwaitExpression:
					goto IL_0765;
				}
			}
			else
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.SimpleDoLoopBlock:
				case SyntaxKind.DoWhileLoopBlock:
				case SyntaxKind.DoUntilLoopBlock:
				case SyntaxKind.DoLoopWhileBlock:
				case SyntaxKind.DoLoopUntilBlock:
				case SyntaxKind.SimpleDoStatement:
				case SyntaxKind.DoWhileStatement:
				case SyntaxKind.DoUntilStatement:
				case SyntaxKind.SimpleLoopStatement:
				case SyntaxKind.LoopWhileStatement:
				case SyntaxKind.LoopUntilStatement:
				case SyntaxKind.NameOfExpression:
				case SyntaxKind.InterpolatedStringExpression:
				case SyntaxKind.TupleExpression:
				case SyntaxKind.TupleType:
					goto IL_0765;
				}
			}
			throw new ArgumentException("body");
			IL_0765:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineLambdaExpressionSyntax(kind, null, null, subOrFunctionHeader, body);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax MultiLineFunctionLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax subOrFunctionHeader, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endSubOrFunctionStatement)
		{
			if (subOrFunctionHeader == null)
			{
				throw new ArgumentNullException("subOrFunctionHeader");
			}
			SyntaxKind syntaxKind = subOrFunctionHeader.Kind();
			if (syntaxKind - 345 > SyntaxKind.List)
			{
				throw new ArgumentException("subOrFunctionHeader");
			}
			if (endSubOrFunctionStatement == null)
			{
				throw new ArgumentNullException("endSubOrFunctionStatement");
			}
			SyntaxKind syntaxKind2 = endSubOrFunctionStatement.Kind();
			if (syntaxKind2 - 15 > SyntaxKind.List)
			{
				throw new ArgumentException("endSubOrFunctionStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax(SyntaxKind.MultiLineFunctionLambdaExpression, null, null, subOrFunctionHeader, statements.Node, endSubOrFunctionStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax MultiLineFunctionLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax subOrFunctionHeader, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endSubOrFunctionStatement)
		{
			return MultiLineFunctionLambdaExpression(subOrFunctionHeader, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), endSubOrFunctionStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax MultiLineSubLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax subOrFunctionHeader, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endSubOrFunctionStatement)
		{
			if (subOrFunctionHeader == null)
			{
				throw new ArgumentNullException("subOrFunctionHeader");
			}
			SyntaxKind syntaxKind = subOrFunctionHeader.Kind();
			if (syntaxKind - 345 > SyntaxKind.List)
			{
				throw new ArgumentException("subOrFunctionHeader");
			}
			if (endSubOrFunctionStatement == null)
			{
				throw new ArgumentNullException("endSubOrFunctionStatement");
			}
			SyntaxKind syntaxKind2 = endSubOrFunctionStatement.Kind();
			if (syntaxKind2 - 15 > SyntaxKind.List)
			{
				throw new ArgumentException("endSubOrFunctionStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax(SyntaxKind.MultiLineSubLambdaExpression, null, null, subOrFunctionHeader, statements.Node, endSubOrFunctionStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax MultiLineSubLambdaExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax subOrFunctionHeader, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endSubOrFunctionStatement)
		{
			return MultiLineSubLambdaExpression(subOrFunctionHeader, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), endSubOrFunctionStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax MultiLineLambdaExpression(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax subOrFunctionHeader, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endSubOrFunctionStatement)
		{
			if (!SyntaxFacts.IsMultiLineLambdaExpression(kind))
			{
				throw new ArgumentException("kind");
			}
			if (subOrFunctionHeader == null)
			{
				throw new ArgumentNullException("subOrFunctionHeader");
			}
			SyntaxKind syntaxKind = subOrFunctionHeader.Kind();
			if (syntaxKind - 345 > SyntaxKind.List)
			{
				throw new ArgumentException("subOrFunctionHeader");
			}
			if (endSubOrFunctionStatement == null)
			{
				throw new ArgumentNullException("endSubOrFunctionStatement");
			}
			SyntaxKind syntaxKind2 = endSubOrFunctionStatement.Kind();
			if (syntaxKind2 - 15 > SyntaxKind.List)
			{
				throw new ArgumentException("endSubOrFunctionStatement");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax(kind, null, null, subOrFunctionHeader, statements.Node, endSubOrFunctionStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax MultiLineLambdaExpression(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax subOrFunctionHeader, Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax endSubOrFunctionStatement)
		{
			return MultiLineLambdaExpression(kind, subOrFunctionHeader, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), endSubOrFunctionStatement);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax SubLambdaHeader(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken subOrFunctionKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(subOrFunctionKeyword);
			if (syntaxKind != SyntaxKind.FunctionKeyword && syntaxKind != SyntaxKind.SubKeyword)
			{
				throw new ArgumentException("subOrFunctionKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax(SyntaxKind.SubLambdaHeader, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)subOrFunctionKeyword.Node, parameterList, asClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax SubLambdaHeader(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause)
		{
			return SubLambdaHeader(attributeLists, modifiers, Token(SyntaxKind.SubKeyword), parameterList, asClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax SubLambdaHeader()
		{
			return SubLambdaHeader(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.SubKeyword), null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax FunctionLambdaHeader(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken subOrFunctionKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(subOrFunctionKeyword);
			if (syntaxKind != SyntaxKind.FunctionKeyword)
			{
				throw new ArgumentException("subOrFunctionKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax(SyntaxKind.FunctionLambdaHeader, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)subOrFunctionKeyword.Node, parameterList, asClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax FunctionLambdaHeader(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause)
		{
			return FunctionLambdaHeader(attributeLists, modifiers, Token(SyntaxKind.FunctionKeyword), parameterList, asClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax FunctionLambdaHeader()
		{
			return FunctionLambdaHeader(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), Token(SyntaxKind.FunctionKeyword), null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax LambdaHeader(SyntaxKind kind, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken subOrFunctionKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause)
		{
			if (!SyntaxFacts.IsLambdaHeader(kind))
			{
				throw new ArgumentException("kind");
			}
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(subOrFunctionKeyword, GetLambdaHeaderSubOrFunctionKeywordKind(kind)))
			{
				throw new ArgumentException("subOrFunctionKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax(kind, null, null, attributeLists.Node, modifiers.Node, (KeywordSyntax)subOrFunctionKeyword.Node, parameterList, asClause);
		}

		private static SyntaxKind GetLambdaHeaderSubOrFunctionKeywordKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.SubLambdaHeader => SyntaxKind.SubKeyword, 
				SyntaxKind.FunctionLambdaHeader => SyntaxKind.FunctionKeyword, 
				_ => throw new ArgumentException("SubOrFunctionKeyword"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax LambdaHeader(SyntaxKind kind, SyntaxToken subOrFunctionKeyword)
		{
			return LambdaHeader(kind, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), default(SyntaxTokenList), subOrFunctionKeyword, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax> arguments, SyntaxToken closeParenToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(openParenToken);
			if (syntaxKind != SyntaxKind.OpenParenToken)
			{
				throw new ArgumentException("openParenToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(closeParenToken);
			if (syntaxKind2 != SyntaxKind.CloseParenToken)
			{
				throw new ArgumentException("closeParenToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax(SyntaxKind.ArgumentList, null, null, (PunctuationSyntax)openParenToken.Node, arguments.Node, (PunctuationSyntax)closeParenToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax ArgumentList(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax> arguments)
		{
			return ArgumentList(Token(SyntaxKind.OpenParenToken), arguments, Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax ArgumentList()
		{
			return ArgumentList(Token(SyntaxKind.OpenParenToken), default(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax>), Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OmittedArgumentSyntax OmittedArgument(SyntaxToken empty)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(empty);
			if (syntaxKind != SyntaxKind.EmptyToken)
			{
				throw new ArgumentException("empty");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.OmittedArgumentSyntax(SyntaxKind.OmittedArgument, null, null, (PunctuationSyntax)empty.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OmittedArgumentSyntax OmittedArgument()
		{
			return OmittedArgument(Token(SyntaxKind.EmptyToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax SimpleArgument(Microsoft.CodeAnalysis.VisualBasic.Syntax.NameColonEqualsSyntax nameColonEquals, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind = expression.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("expression");
			IL_02d2:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax(SyntaxKind.SimpleArgument, null, null, nameColonEquals, expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax SimpleArgument(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return SimpleArgument(null, expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.NameColonEqualsSyntax NameColonEquals(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax name, SyntaxToken colonEqualsToken)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			SyntaxKind syntaxKind = name.Kind();
			if (syntaxKind != SyntaxKind.IdentifierName)
			{
				throw new ArgumentException("name");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(colonEqualsToken);
			if (syntaxKind2 != SyntaxKind.ColonEqualsToken)
			{
				throw new ArgumentException("colonEqualsToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.NameColonEqualsSyntax(SyntaxKind.NameColonEquals, null, null, name, (PunctuationSyntax)colonEqualsToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.NameColonEqualsSyntax NameColonEquals(Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax name)
		{
			return NameColonEquals(name, Token(SyntaxKind.ColonEqualsToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax RangeArgument(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax lowerBound, SyntaxToken toKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax upperBound)
		{
			if (lowerBound == null)
			{
				throw new ArgumentNullException("lowerBound");
			}
			SyntaxKind syntaxKind = lowerBound.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("lowerBound");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax(SyntaxKind.RangeArgument, null, null, lowerBound, (KeywordSyntax)toKeyword.Node, upperBound);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(toKeyword);
			if (syntaxKind2 != SyntaxKind.ToKeyword)
			{
				throw new ArgumentException("toKeyword");
			}
			if (upperBound == null)
			{
				throw new ArgumentNullException("upperBound");
			}
			SyntaxKind syntaxKind3 = upperBound.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("upperBound");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax RangeArgument(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax lowerBound, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax upperBound)
		{
			return RangeArgument(lowerBound, Token(SyntaxKind.ToKeyword), upperBound);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax QueryExpression(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax> clauses)
		{
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax(SyntaxKind.QueryExpression, null, null, clauses.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax QueryExpression(params Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax[] clauses)
		{
			return QueryExpression(List(clauses));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax CollectionRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause, SyntaxToken inKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			if (identifier == null)
			{
				throw new ArgumentNullException("identifier");
			}
			SyntaxKind syntaxKind = identifier.Kind();
			if (syntaxKind != SyntaxKind.ModifiedIdentifier)
			{
				throw new ArgumentException("identifier");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(inKeyword);
			if (syntaxKind2 != SyntaxKind.InKeyword)
			{
				throw new ArgumentException("inKeyword");
			}
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind3 = expression.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_0314;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_0314;
			}
			throw new ArgumentException("expression");
			IL_0314:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax(SyntaxKind.CollectionRangeVariable, null, null, identifier, asClause, (KeywordSyntax)inKeyword.Node, expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax CollectionRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return CollectionRangeVariable(identifier, asClause, Token(SyntaxKind.InKeyword), expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax CollectionRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return CollectionRangeVariable(identifier, null, Token(SyntaxKind.InKeyword), expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax ExpressionRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax nameEquals, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind = expression.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("expression");
			IL_02d2:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax(SyntaxKind.ExpressionRangeVariable, null, null, nameEquals, expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax ExpressionRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return ExpressionRangeVariable(null, expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax AggregationRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax nameEquals, Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationSyntax aggregation)
		{
			if (aggregation == null)
			{
				throw new ArgumentNullException("aggregation");
			}
			SyntaxKind syntaxKind = aggregation.Kind();
			if (syntaxKind - 357 > SyntaxKind.List)
			{
				throw new ArgumentException("aggregation");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax(SyntaxKind.AggregationRangeVariable, null, null, nameEquals, aggregation);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax AggregationRangeVariable(Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationSyntax aggregation)
		{
			return AggregationRangeVariable(null, aggregation);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax VariableNameEquals(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause, SyntaxToken equalsToken)
		{
			if (identifier == null)
			{
				throw new ArgumentNullException("identifier");
			}
			SyntaxKind syntaxKind = identifier.Kind();
			if (syntaxKind != SyntaxKind.ModifiedIdentifier)
			{
				throw new ArgumentException("identifier");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(equalsToken);
			if (syntaxKind2 != SyntaxKind.EqualsToken)
			{
				throw new ArgumentException("equalsToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax(SyntaxKind.VariableNameEquals, null, null, identifier, asClause, (PunctuationSyntax)equalsToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax VariableNameEquals(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause)
		{
			return VariableNameEquals(identifier, asClause, Token(SyntaxKind.EqualsToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax VariableNameEquals(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax identifier)
		{
			return VariableNameEquals(identifier, null, Token(SyntaxKind.EqualsToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax FunctionAggregation(SyntaxToken functionName, SyntaxToken openParenToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax argument, SyntaxToken closeParenToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(functionName);
			if (syntaxKind != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("functionName");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax(SyntaxKind.FunctionAggregation, null, null, (IdentifierTokenSyntax)functionName.Node, (PunctuationSyntax)openParenToken.Node, argument, (PunctuationSyntax)closeParenToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax FunctionAggregation(SyntaxToken functionName, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax argument)
		{
			return FunctionAggregation(functionName, default(SyntaxToken), argument, default(SyntaxToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax FunctionAggregation(SyntaxToken functionName)
		{
			return FunctionAggregation(functionName, default(SyntaxToken), null, default(SyntaxToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax FunctionAggregation(string functionName)
		{
			return FunctionAggregation(Identifier(functionName), default(SyntaxToken), null, default(SyntaxToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupAggregationSyntax GroupAggregation(SyntaxToken groupKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(groupKeyword);
			if (syntaxKind != SyntaxKind.GroupKeyword)
			{
				throw new ArgumentException("groupKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupAggregationSyntax(SyntaxKind.GroupAggregation, null, null, (KeywordSyntax)groupKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupAggregationSyntax GroupAggregation()
		{
			return GroupAggregation(Token(SyntaxKind.GroupKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax FromClause(SyntaxToken fromKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax> variables)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(fromKeyword);
			if (syntaxKind != SyntaxKind.FromKeyword)
			{
				throw new ArgumentException("fromKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax(SyntaxKind.FromClause, null, null, (KeywordSyntax)fromKeyword.Node, variables.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax FromClause(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax> variables)
		{
			return FromClause(Token(SyntaxKind.FromKeyword), variables);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax FromClause(params Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax[] variables)
		{
			return FromClause(Token(SyntaxKind.FromKeyword), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax>().AddRange(variables));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax LetClause(SyntaxToken letKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax> variables)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(letKeyword);
			if (syntaxKind != SyntaxKind.LetKeyword)
			{
				throw new ArgumentException("letKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax(SyntaxKind.LetClause, null, null, (KeywordSyntax)letKeyword.Node, variables.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax LetClause(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax> variables)
		{
			return LetClause(Token(SyntaxKind.LetKeyword), variables);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax LetClause(params Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax[] variables)
		{
			return LetClause(Token(SyntaxKind.LetKeyword), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax>().AddRange(variables));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax AggregateClause(SyntaxToken aggregateKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax> variables, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax> additionalQueryOperators, SyntaxToken intoKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax> aggregationVariables)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(aggregateKeyword);
			if (syntaxKind != SyntaxKind.AggregateKeyword)
			{
				throw new ArgumentException("aggregateKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(intoKeyword);
			if (syntaxKind2 != SyntaxKind.IntoKeyword)
			{
				throw new ArgumentException("intoKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax(SyntaxKind.AggregateClause, null, null, (KeywordSyntax)aggregateKeyword.Node, variables.Node, additionalQueryOperators.Node, (KeywordSyntax)intoKeyword.Node, aggregationVariables.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax AggregateClause(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax> variables, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax> additionalQueryOperators, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax> aggregationVariables)
		{
			return AggregateClause(Token(SyntaxKind.AggregateKeyword), variables, additionalQueryOperators, Token(SyntaxKind.IntoKeyword), aggregationVariables);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax AggregateClause(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax> variables, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax> aggregationVariables)
		{
			return AggregateClause(Token(SyntaxKind.AggregateKeyword), variables, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax>), Token(SyntaxKind.IntoKeyword), aggregationVariables);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DistinctClauseSyntax DistinctClause(SyntaxToken distinctKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(distinctKeyword);
			if (syntaxKind != SyntaxKind.DistinctKeyword)
			{
				throw new ArgumentException("distinctKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DistinctClauseSyntax(SyntaxKind.DistinctClause, null, null, (KeywordSyntax)distinctKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DistinctClauseSyntax DistinctClause()
		{
			return DistinctClause(Token(SyntaxKind.DistinctKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(whereKeyword);
			if (syntaxKind != SyntaxKind.WhereKeyword)
			{
				throw new ArgumentException("whereKeyword");
			}
			if (condition == null)
			{
				throw new ArgumentNullException("condition");
			}
			SyntaxKind syntaxKind2 = condition.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("condition");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.WhereClauseSyntax(SyntaxKind.WhereClause, null, null, (KeywordSyntax)whereKeyword.Node, condition);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.WhereClauseSyntax WhereClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition)
		{
			return WhereClause(Token(SyntaxKind.WhereKeyword), condition);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax SkipWhileClause(SyntaxToken skipOrTakeKeyword, SyntaxToken whileKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(skipOrTakeKeyword);
			if (syntaxKind != SyntaxKind.SkipKeyword && syntaxKind != SyntaxKind.TakeKeyword)
			{
				throw new ArgumentException("skipOrTakeKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(whileKeyword);
			if (syntaxKind2 != SyntaxKind.WhileKeyword)
			{
				throw new ArgumentException("whileKeyword");
			}
			if (condition == null)
			{
				throw new ArgumentNullException("condition");
			}
			SyntaxKind syntaxKind3 = condition.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_030e;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_030e;
			}
			throw new ArgumentException("condition");
			IL_030e:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax(SyntaxKind.SkipWhileClause, null, null, (KeywordSyntax)skipOrTakeKeyword.Node, (KeywordSyntax)whileKeyword.Node, condition);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax SkipWhileClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition)
		{
			return SkipWhileClause(Token(SyntaxKind.SkipKeyword), Token(SyntaxKind.WhileKeyword), condition);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax TakeWhileClause(SyntaxToken skipOrTakeKeyword, SyntaxToken whileKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(skipOrTakeKeyword);
			if (syntaxKind != SyntaxKind.TakeKeyword)
			{
				throw new ArgumentException("skipOrTakeKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(whileKeyword);
			if (syntaxKind2 != SyntaxKind.WhileKeyword)
			{
				throw new ArgumentException("whileKeyword");
			}
			if (condition == null)
			{
				throw new ArgumentNullException("condition");
			}
			SyntaxKind syntaxKind3 = condition.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_0306;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_0306;
			}
			throw new ArgumentException("condition");
			IL_0306:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax(SyntaxKind.TakeWhileClause, null, null, (KeywordSyntax)skipOrTakeKeyword.Node, (KeywordSyntax)whileKeyword.Node, condition);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax TakeWhileClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition)
		{
			return TakeWhileClause(Token(SyntaxKind.TakeKeyword), Token(SyntaxKind.WhileKeyword), condition);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax PartitionWhileClause(SyntaxKind kind, SyntaxToken skipOrTakeKeyword, SyntaxToken whileKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition)
		{
			if (!SyntaxFacts.IsPartitionWhileClause(kind))
			{
				throw new ArgumentException("kind");
			}
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(skipOrTakeKeyword, GetPartitionWhileClauseSkipOrTakeKeywordKind(kind)))
			{
				throw new ArgumentException("skipOrTakeKeyword");
			}
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(whileKeyword);
			if (syntaxKind != SyntaxKind.WhileKeyword)
			{
				throw new ArgumentException("whileKeyword");
			}
			if (condition == null)
			{
				throw new ArgumentNullException("condition");
			}
			SyntaxKind syntaxKind2 = condition.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_0318;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_0318;
			}
			throw new ArgumentException("condition");
			IL_0318:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax(kind, null, null, (KeywordSyntax)skipOrTakeKeyword.Node, (KeywordSyntax)whileKeyword.Node, condition);
		}

		private static SyntaxKind GetPartitionWhileClauseSkipOrTakeKeywordKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.SkipWhileClause => SyntaxKind.SkipKeyword, 
				SyntaxKind.TakeWhileClause => SyntaxKind.TakeKeyword, 
				_ => throw new ArgumentException("SkipOrTakeKeyword"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax PartitionWhileClause(SyntaxKind kind, SyntaxToken skipOrTakeKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition)
		{
			return PartitionWhileClause(kind, skipOrTakeKeyword, Token(SyntaxKind.WhileKeyword), condition);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax SkipClause(SyntaxToken skipOrTakeKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax count)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(skipOrTakeKeyword);
			if (syntaxKind != SyntaxKind.SkipKeyword && syntaxKind != SyntaxKind.TakeKeyword)
			{
				throw new ArgumentException("skipOrTakeKeyword");
			}
			if (count == null)
			{
				throw new ArgumentNullException("count");
			}
			SyntaxKind syntaxKind2 = count.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02f4;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02f4;
			}
			throw new ArgumentException("count");
			IL_02f4:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax(SyntaxKind.SkipClause, null, null, (KeywordSyntax)skipOrTakeKeyword.Node, count);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax SkipClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax count)
		{
			return SkipClause(Token(SyntaxKind.SkipKeyword), count);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax TakeClause(SyntaxToken skipOrTakeKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax count)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(skipOrTakeKeyword);
			if (syntaxKind != SyntaxKind.TakeKeyword)
			{
				throw new ArgumentException("skipOrTakeKeyword");
			}
			if (count == null)
			{
				throw new ArgumentNullException("count");
			}
			SyntaxKind syntaxKind2 = count.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("count");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax(SyntaxKind.TakeClause, null, null, (KeywordSyntax)skipOrTakeKeyword.Node, count);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax TakeClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax count)
		{
			return TakeClause(Token(SyntaxKind.TakeKeyword), count);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax PartitionClause(SyntaxKind kind, SyntaxToken skipOrTakeKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax count)
		{
			if (!SyntaxFacts.IsPartitionClause(kind))
			{
				throw new ArgumentException("kind");
			}
			if (!Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(skipOrTakeKeyword, GetPartitionClauseSkipOrTakeKeywordKind(kind)))
			{
				throw new ArgumentException("skipOrTakeKeyword");
			}
			if (count == null)
			{
				throw new ArgumentNullException("count");
			}
			SyntaxKind syntaxKind = count.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02fe;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02fe;
			}
			throw new ArgumentException("count");
			IL_02fe:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax(kind, null, null, (KeywordSyntax)skipOrTakeKeyword.Node, count);
		}

		private static SyntaxKind GetPartitionClauseSkipOrTakeKeywordKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.SkipClause => SyntaxKind.SkipKeyword, 
				SyntaxKind.TakeClause => SyntaxKind.TakeKeyword, 
				_ => throw new ArgumentException("SkipOrTakeKeyword"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax GroupByClause(SyntaxToken groupKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax> items, SyntaxToken byKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax> keys, SyntaxToken intoKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax> aggregationVariables)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(groupKeyword);
			if (syntaxKind != SyntaxKind.GroupKeyword)
			{
				throw new ArgumentException("groupKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(byKeyword);
			if (syntaxKind2 != SyntaxKind.ByKeyword)
			{
				throw new ArgumentException("byKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(intoKeyword);
			if (syntaxKind3 != SyntaxKind.IntoKeyword)
			{
				throw new ArgumentException("intoKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax(SyntaxKind.GroupByClause, null, null, (KeywordSyntax)groupKeyword.Node, items.Node, (KeywordSyntax)byKeyword.Node, keys.Node, (KeywordSyntax)intoKeyword.Node, aggregationVariables.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax GroupByClause(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax> items, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax> keys, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax> aggregationVariables)
		{
			return GroupByClause(Token(SyntaxKind.GroupKeyword), items, Token(SyntaxKind.ByKeyword), keys, Token(SyntaxKind.IntoKeyword), aggregationVariables);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax GroupByClause(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax> keys, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax> aggregationVariables)
		{
			return GroupByClause(Token(SyntaxKind.GroupKeyword), default(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax>), Token(SyntaxKind.ByKeyword), keys, Token(SyntaxKind.IntoKeyword), aggregationVariables);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax JoinCondition(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, SyntaxToken equalsKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("left");
			IL_05be:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax(SyntaxKind.JoinCondition, null, null, left, (KeywordSyntax)equalsKeyword.Node, right);
			IL_02d2:
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(equalsKeyword);
			if (syntaxKind2 != SyntaxKind.EqualsKeyword)
			{
				throw new ArgumentException("equalsKeyword");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_05be;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_05be;
			}
			throw new ArgumentException("right");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax JoinCondition(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax right)
		{
			return JoinCondition(left, Token(SyntaxKind.EqualsKeyword), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax SimpleJoinClause(SyntaxToken joinKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax> joinedVariables, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax> additionalJoins, SyntaxToken onKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax> joinConditions)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(joinKeyword);
			if (syntaxKind != SyntaxKind.JoinKeyword)
			{
				throw new ArgumentException("joinKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(onKeyword);
			if (syntaxKind2 != SyntaxKind.OnKeyword)
			{
				throw new ArgumentException("onKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax(SyntaxKind.SimpleJoinClause, null, null, (KeywordSyntax)joinKeyword.Node, joinedVariables.Node, additionalJoins.Node, (KeywordSyntax)onKeyword.Node, joinConditions.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax SimpleJoinClause(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax> joinedVariables, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax> additionalJoins, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax> joinConditions)
		{
			return SimpleJoinClause(Token(SyntaxKind.JoinKeyword), joinedVariables, additionalJoins, Token(SyntaxKind.OnKeyword), joinConditions);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax SimpleJoinClause(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax> joinedVariables, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax> joinConditions)
		{
			return SimpleJoinClause(Token(SyntaxKind.JoinKeyword), joinedVariables, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax>), Token(SyntaxKind.OnKeyword), joinConditions);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax GroupJoinClause(SyntaxToken groupKeyword, SyntaxToken joinKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax> joinedVariables, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax> additionalJoins, SyntaxToken onKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax> joinConditions, SyntaxToken intoKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax> aggregationVariables)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(groupKeyword);
			if (syntaxKind != SyntaxKind.GroupKeyword)
			{
				throw new ArgumentException("groupKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(joinKeyword);
			if (syntaxKind2 != SyntaxKind.JoinKeyword)
			{
				throw new ArgumentException("joinKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(onKeyword);
			if (syntaxKind3 != SyntaxKind.OnKeyword)
			{
				throw new ArgumentException("onKeyword");
			}
			SyntaxKind syntaxKind4 = VisualBasicExtensions.Kind(intoKeyword);
			if (syntaxKind4 != SyntaxKind.IntoKeyword)
			{
				throw new ArgumentException("intoKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax(SyntaxKind.GroupJoinClause, null, null, (KeywordSyntax)groupKeyword.Node, (KeywordSyntax)joinKeyword.Node, joinedVariables.Node, additionalJoins.Node, (KeywordSyntax)onKeyword.Node, joinConditions.Node, (KeywordSyntax)intoKeyword.Node, aggregationVariables.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax GroupJoinClause(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax> joinedVariables, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax> additionalJoins, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax> joinConditions, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax> aggregationVariables)
		{
			return GroupJoinClause(Token(SyntaxKind.GroupKeyword), Token(SyntaxKind.JoinKeyword), joinedVariables, additionalJoins, Token(SyntaxKind.OnKeyword), joinConditions, Token(SyntaxKind.IntoKeyword), aggregationVariables);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax GroupJoinClause(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax> joinedVariables, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax> joinConditions, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax> aggregationVariables)
		{
			return GroupJoinClause(Token(SyntaxKind.GroupKeyword), Token(SyntaxKind.JoinKeyword), joinedVariables, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax>), Token(SyntaxKind.OnKeyword), joinConditions, Token(SyntaxKind.IntoKeyword), aggregationVariables);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderByClauseSyntax OrderByClause(SyntaxToken orderKeyword, SyntaxToken byKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax> orderings)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(orderKeyword);
			if (syntaxKind != SyntaxKind.OrderKeyword)
			{
				throw new ArgumentException("orderKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(byKeyword);
			if (syntaxKind2 != SyntaxKind.ByKeyword)
			{
				throw new ArgumentException("byKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderByClauseSyntax(SyntaxKind.OrderByClause, null, null, (KeywordSyntax)orderKeyword.Node, (KeywordSyntax)byKeyword.Node, orderings.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderByClauseSyntax OrderByClause(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax> orderings)
		{
			return OrderByClause(Token(SyntaxKind.OrderKeyword), Token(SyntaxKind.ByKeyword), orderings);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderByClauseSyntax OrderByClause(params Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax[] orderings)
		{
			return OrderByClause(Token(SyntaxKind.OrderKeyword), Token(SyntaxKind.ByKeyword), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax>().AddRange(orderings));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax AscendingOrdering(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
		{
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind = expression.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("expression");
			IL_02d2:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax(SyntaxKind.AscendingOrdering, null, null, expression, (KeywordSyntax)ascendingOrDescendingKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax AscendingOrdering(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return AscendingOrdering(expression, default(SyntaxToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax DescendingOrdering(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
		{
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind = expression.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02d2;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02d2;
			}
			throw new ArgumentException("expression");
			IL_02d2:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax(SyntaxKind.DescendingOrdering, null, null, expression, (KeywordSyntax)ascendingOrDescendingKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax DescendingOrdering(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return DescendingOrdering(expression, default(SyntaxToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax Ordering(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
		{
			if (!SyntaxFacts.IsOrdering(kind))
			{
				throw new ArgumentException("kind");
			}
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind = expression.Kind();
			if (syntaxKind <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02e5;
				}
			}
			else if (syntaxKind - 711 <= SyntaxKind.EmptyStatement || syntaxKind - 779 <= SyntaxKind.List || syntaxKind - 788 <= SyntaxKind.List)
			{
				goto IL_02e5;
			}
			throw new ArgumentException("expression");
			IL_02e5:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax(kind, null, null, expression, (KeywordSyntax)ascendingOrDescendingKeyword.Node);
		}

		private static SyntaxKind GetOrderingAscendingOrDescendingKeywordKind(SyntaxKind kind)
		{
			return kind switch
			{
				SyntaxKind.AscendingOrdering => SyntaxKind.AscendingKeyword, 
				SyntaxKind.DescendingOrdering => SyntaxKind.DescendingKeyword, 
				_ => throw new ArgumentException("AscendingOrDescendingKeyword"), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax Ordering(SyntaxKind kind, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return Ordering(kind, expression, default(SyntaxToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax> variables)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(selectKeyword);
			if (syntaxKind != SyntaxKind.SelectKeyword)
			{
				throw new ArgumentException("selectKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax(SyntaxKind.SelectClause, null, null, (KeywordSyntax)selectKeyword.Node, variables.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax SelectClause(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax> variables)
		{
			return SelectClause(Token(SyntaxKind.SelectKeyword), variables);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax SelectClause(params Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax[] variables)
		{
			return SelectClause(Token(SyntaxKind.SelectKeyword), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax>().AddRange(variables));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDocumentSyntax XmlDocument(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax declaration, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> precedingMisc, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax root, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> followingMisc)
		{
			if (declaration == null)
			{
				throw new ArgumentNullException("declaration");
			}
			SyntaxKind syntaxKind = declaration.Kind();
			if (syntaxKind != SyntaxKind.XmlDeclaration)
			{
				throw new ArgumentException("declaration");
			}
			if (root == null)
			{
				throw new ArgumentNullException("root");
			}
			SyntaxKind syntaxKind2 = root.Kind();
			if (syntaxKind2 != SyntaxKind.XmlElement && syntaxKind2 != SyntaxKind.XmlEmptyElement && syntaxKind2 != SyntaxKind.XmlEmbeddedExpression)
			{
				throw new ArgumentException("root");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDocumentSyntax(SyntaxKind.XmlDocument, null, null, declaration, precedingMisc.Node, root, followingMisc.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDocumentSyntax XmlDocument(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax declaration, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax root)
		{
			return XmlDocument(declaration, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax>), root, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax>));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax XmlDeclaration(SyntaxToken lessThanQuestionToken, SyntaxToken xmlKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax version, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax encoding, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax standalone, SyntaxToken questionGreaterThanToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(lessThanQuestionToken);
			if (syntaxKind != SyntaxKind.LessThanQuestionToken)
			{
				throw new ArgumentException("lessThanQuestionToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(xmlKeyword);
			if (syntaxKind2 != SyntaxKind.XmlKeyword)
			{
				throw new ArgumentException("xmlKeyword");
			}
			if (version == null)
			{
				throw new ArgumentNullException("version");
			}
			SyntaxKind syntaxKind3 = version.Kind();
			if (syntaxKind3 != SyntaxKind.XmlDeclarationOption)
			{
				throw new ArgumentException("version");
			}
			SyntaxKind syntaxKind4 = VisualBasicExtensions.Kind(questionGreaterThanToken);
			if (syntaxKind4 != SyntaxKind.QuestionGreaterThanToken)
			{
				throw new ArgumentException("questionGreaterThanToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax(SyntaxKind.XmlDeclaration, null, null, (PunctuationSyntax)lessThanQuestionToken.Node, (KeywordSyntax)xmlKeyword.Node, version, encoding, standalone, (PunctuationSyntax)questionGreaterThanToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax XmlDeclaration(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax version, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax encoding, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax standalone)
		{
			return XmlDeclaration(Token(SyntaxKind.LessThanQuestionToken), Token(SyntaxKind.XmlKeyword), version, encoding, standalone, Token(SyntaxKind.QuestionGreaterThanToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax XmlDeclaration(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax version)
		{
			return XmlDeclaration(Token(SyntaxKind.LessThanQuestionToken), Token(SyntaxKind.XmlKeyword), version, null, null, Token(SyntaxKind.QuestionGreaterThanToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax XmlDeclarationOption(SyntaxToken name, SyntaxToken equals, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax value)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(name);
			if (syntaxKind != SyntaxKind.XmlNameToken)
			{
				throw new ArgumentException("name");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(equals);
			if (syntaxKind2 != SyntaxKind.EqualsToken)
			{
				throw new ArgumentException("equals");
			}
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			SyntaxKind syntaxKind3 = value.Kind();
			if (syntaxKind3 != SyntaxKind.XmlString)
			{
				throw new ArgumentException("value");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax(SyntaxKind.XmlDeclarationOption, null, null, (XmlNameTokenSyntax)name.Node, (PunctuationSyntax)equals.Node, value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax XmlDeclarationOption(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax value)
		{
			return XmlDeclarationOption(Token(SyntaxKind.XmlNameToken), Token(SyntaxKind.EqualsToken), value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementStartTagSyntax startTag, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> content, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementEndTagSyntax endTag)
		{
			if (startTag == null)
			{
				throw new ArgumentNullException("startTag");
			}
			SyntaxKind syntaxKind = startTag.Kind();
			if (syntaxKind != SyntaxKind.XmlElementStartTag)
			{
				throw new ArgumentException("startTag");
			}
			if (endTag == null)
			{
				throw new ArgumentNullException("endTag");
			}
			SyntaxKind syntaxKind2 = endTag.Kind();
			if (syntaxKind2 != SyntaxKind.XmlElementEndTag)
			{
				throw new ArgumentException("endTag");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax(SyntaxKind.XmlElement, null, null, startTag, content.Node, endTag);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementEndTagSyntax endTag)
		{
			return XmlElement(startTag, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax>), endTag);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlTextSyntax XmlText(SyntaxTokenList textTokens)
		{
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlTextSyntax(SyntaxKind.XmlText, null, null, textTokens.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlTextSyntax XmlText()
		{
			return XmlText(SyntaxTokenList.Create(Token(SyntaxKind.XmlTextLiteralToken)));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax name, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> attributes, SyntaxToken greaterThanToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(lessThanToken);
			if (syntaxKind != SyntaxKind.LessThanToken)
			{
				throw new ArgumentException("lessThanToken");
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			SyntaxKind syntaxKind2 = name.Kind();
			if (syntaxKind2 != SyntaxKind.XmlName && syntaxKind2 != SyntaxKind.XmlEmbeddedExpression)
			{
				throw new ArgumentException("name");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(greaterThanToken);
			if (syntaxKind3 != SyntaxKind.GreaterThanToken)
			{
				throw new ArgumentException("greaterThanToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementStartTagSyntax(SyntaxKind.XmlElementStartTag, null, null, (PunctuationSyntax)lessThanToken.Node, name, attributes.Node, (PunctuationSyntax)greaterThanToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementStartTagSyntax XmlElementStartTag(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax name, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> attributes)
		{
			return XmlElementStartTag(Token(SyntaxKind.LessThanToken), name, attributes, Token(SyntaxKind.GreaterThanToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementStartTagSyntax XmlElementStartTag(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax name)
		{
			return XmlElementStartTag(Token(SyntaxKind.LessThanToken), name, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax>), Token(SyntaxKind.GreaterThanToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax name, SyntaxToken greaterThanToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(lessThanSlashToken);
			if (syntaxKind != SyntaxKind.LessThanSlashToken)
			{
				throw new ArgumentException("lessThanSlashToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(greaterThanToken);
			if (syntaxKind2 != SyntaxKind.GreaterThanToken)
			{
				throw new ArgumentException("greaterThanToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementEndTagSyntax(SyntaxKind.XmlElementEndTag, null, null, (PunctuationSyntax)lessThanSlashToken.Node, name, (PunctuationSyntax)greaterThanToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementEndTagSyntax XmlElementEndTag(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax name)
		{
			return XmlElementEndTag(Token(SyntaxKind.LessThanSlashToken), name, Token(SyntaxKind.GreaterThanToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementEndTagSyntax XmlElementEndTag()
		{
			return XmlElementEndTag(Token(SyntaxKind.LessThanSlashToken), null, Token(SyntaxKind.GreaterThanToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax name, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> attributes, SyntaxToken slashGreaterThanToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(lessThanToken);
			if (syntaxKind != SyntaxKind.LessThanToken)
			{
				throw new ArgumentException("lessThanToken");
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			SyntaxKind syntaxKind2 = name.Kind();
			if (syntaxKind2 != SyntaxKind.XmlName && syntaxKind2 != SyntaxKind.XmlEmbeddedExpression)
			{
				throw new ArgumentException("name");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(slashGreaterThanToken);
			if (syntaxKind3 != SyntaxKind.SlashGreaterThanToken)
			{
				throw new ArgumentException("slashGreaterThanToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax(SyntaxKind.XmlEmptyElement, null, null, (PunctuationSyntax)lessThanToken.Node, name, attributes.Node, (PunctuationSyntax)slashGreaterThanToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax XmlEmptyElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax name, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> attributes)
		{
			return XmlEmptyElement(Token(SyntaxKind.LessThanToken), name, attributes, Token(SyntaxKind.SlashGreaterThanToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax XmlEmptyElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax name)
		{
			return XmlEmptyElement(Token(SyntaxKind.LessThanToken), name, default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax>), Token(SyntaxKind.SlashGreaterThanToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax XmlAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax name, SyntaxToken equalsToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax value)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			SyntaxKind syntaxKind = name.Kind();
			if (syntaxKind != SyntaxKind.XmlName && syntaxKind != SyntaxKind.XmlEmbeddedExpression)
			{
				throw new ArgumentException("name");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(equalsToken);
			if (syntaxKind2 != SyntaxKind.EqualsToken)
			{
				throw new ArgumentException("equalsToken");
			}
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			SyntaxKind syntaxKind3 = value.Kind();
			if (syntaxKind3 != SyntaxKind.XmlString && syntaxKind3 != SyntaxKind.XmlEmbeddedExpression)
			{
				throw new ArgumentException("value");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax(SyntaxKind.XmlAttribute, null, null, name, (PunctuationSyntax)equalsToken.Node, value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax XmlAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax name, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax value)
		{
			return XmlAttribute(name, Token(SyntaxKind.EqualsToken), value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax XmlString(SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(startQuoteToken);
			if (syntaxKind != SyntaxKind.SingleQuoteToken && syntaxKind != SyntaxKind.DoubleQuoteToken)
			{
				throw new ArgumentException("startQuoteToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(endQuoteToken);
			if (syntaxKind2 != SyntaxKind.SingleQuoteToken && syntaxKind2 != SyntaxKind.DoubleQuoteToken)
			{
				throw new ArgumentException("endQuoteToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax(SyntaxKind.XmlString, null, null, (PunctuationSyntax)startQuoteToken.Node, textTokens.Node, (PunctuationSyntax)endQuoteToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax XmlString(SyntaxToken startQuoteToken, SyntaxToken endQuoteToken)
		{
			return XmlString(startQuoteToken, default(SyntaxTokenList), endQuoteToken);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixNameSyntax XmlPrefixName(SyntaxToken name)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(name);
			if (syntaxKind != SyntaxKind.XmlNameToken)
			{
				throw new ArgumentException("name");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixNameSyntax(SyntaxKind.XmlPrefixName, null, null, (XmlNameTokenSyntax)name.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixNameSyntax XmlPrefixName()
		{
			return XmlPrefixName(Token(SyntaxKind.XmlNameToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax XmlName(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixSyntax prefix, SyntaxToken localName)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(localName);
			if (syntaxKind != SyntaxKind.XmlNameToken)
			{
				throw new ArgumentException("localName");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax(SyntaxKind.XmlName, null, null, prefix, (XmlNameTokenSyntax)localName.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax XmlName()
		{
			return XmlName(null, Token(SyntaxKind.XmlNameToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlBracketedNameSyntax XmlBracketedName(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax name, SyntaxToken greaterThanToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(lessThanToken);
			if (syntaxKind != SyntaxKind.LessThanToken)
			{
				throw new ArgumentException("lessThanToken");
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			SyntaxKind syntaxKind2 = name.Kind();
			if (syntaxKind2 != SyntaxKind.XmlName)
			{
				throw new ArgumentException("name");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(greaterThanToken);
			if (syntaxKind3 != SyntaxKind.GreaterThanToken)
			{
				throw new ArgumentException("greaterThanToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlBracketedNameSyntax(SyntaxKind.XmlBracketedName, null, null, (PunctuationSyntax)lessThanToken.Node, name, (PunctuationSyntax)greaterThanToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlBracketedNameSyntax XmlBracketedName(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax name)
		{
			return XmlBracketedName(Token(SyntaxKind.LessThanToken), name, Token(SyntaxKind.GreaterThanToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixSyntax XmlPrefix(SyntaxToken name, SyntaxToken colonToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(name);
			if (syntaxKind != SyntaxKind.XmlNameToken)
			{
				throw new ArgumentException("name");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(colonToken);
			if (syntaxKind2 != SyntaxKind.ColonToken)
			{
				throw new ArgumentException("colonToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixSyntax(SyntaxKind.XmlPrefix, null, null, (XmlNameTokenSyntax)name.Node, (PunctuationSyntax)colonToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixSyntax XmlPrefix()
		{
			return XmlPrefix(Token(SyntaxKind.XmlNameToken), Token(SyntaxKind.ColonToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxTokenList textTokens, SyntaxToken minusMinusGreaterThanToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(lessThanExclamationMinusMinusToken);
			if (syntaxKind != SyntaxKind.LessThanExclamationMinusMinusToken)
			{
				throw new ArgumentException("lessThanExclamationMinusMinusToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(minusMinusGreaterThanToken);
			if (syntaxKind2 != SyntaxKind.MinusMinusGreaterThanToken)
			{
				throw new ArgumentException("minusMinusGreaterThanToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCommentSyntax(SyntaxKind.XmlComment, null, null, (PunctuationSyntax)lessThanExclamationMinusMinusToken.Node, textTokens.Node, (PunctuationSyntax)minusMinusGreaterThanToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCommentSyntax XmlComment()
		{
			return XmlComment(Token(SyntaxKind.LessThanExclamationMinusMinusToken), SyntaxTokenList.Create(Token(SyntaxKind.XmlTextLiteralToken)), Token(SyntaxKind.MinusMinusGreaterThanToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken lessThanQuestionToken, SyntaxToken name, SyntaxTokenList textTokens, SyntaxToken questionGreaterThanToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(lessThanQuestionToken);
			if (syntaxKind != SyntaxKind.LessThanQuestionToken)
			{
				throw new ArgumentException("lessThanQuestionToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(name);
			if (syntaxKind2 != SyntaxKind.XmlNameToken)
			{
				throw new ArgumentException("name");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(questionGreaterThanToken);
			if (syntaxKind3 != SyntaxKind.QuestionGreaterThanToken)
			{
				throw new ArgumentException("questionGreaterThanToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlProcessingInstructionSyntax(SyntaxKind.XmlProcessingInstruction, null, null, (PunctuationSyntax)lessThanQuestionToken.Node, (XmlNameTokenSyntax)name.Node, textTokens.Node, (PunctuationSyntax)questionGreaterThanToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlProcessingInstructionSyntax XmlProcessingInstruction()
		{
			return XmlProcessingInstruction(Token(SyntaxKind.LessThanQuestionToken), Token(SyntaxKind.XmlNameToken), SyntaxTokenList.Create(Token(SyntaxKind.XmlTextLiteralToken)), Token(SyntaxKind.QuestionGreaterThanToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCDataSectionSyntax XmlCDataSection(SyntaxToken beginCDataToken, SyntaxTokenList textTokens, SyntaxToken endCDataToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(beginCDataToken);
			if (syntaxKind != SyntaxKind.BeginCDataToken)
			{
				throw new ArgumentException("beginCDataToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(endCDataToken);
			if (syntaxKind2 != SyntaxKind.EndCDataToken)
			{
				throw new ArgumentException("endCDataToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCDataSectionSyntax(SyntaxKind.XmlCDataSection, null, null, (PunctuationSyntax)beginCDataToken.Node, textTokens.Node, (PunctuationSyntax)endCDataToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCDataSectionSyntax XmlCDataSection()
		{
			return XmlCDataSection(Token(SyntaxKind.BeginCDataToken), SyntaxTokenList.Create(Token(SyntaxKind.XmlTextLiteralToken)), Token(SyntaxKind.EndCDataToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax XmlEmbeddedExpression(SyntaxToken lessThanPercentEqualsToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, SyntaxToken percentGreaterThanToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(lessThanPercentEqualsToken);
			if (syntaxKind != SyntaxKind.LessThanPercentEqualsToken)
			{
				throw new ArgumentException("lessThanPercentEqualsToken");
			}
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind2 = expression.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("expression");
			IL_02ec:
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(percentGreaterThanToken);
			if (syntaxKind3 != SyntaxKind.PercentGreaterThanToken)
			{
				throw new ArgumentException("percentGreaterThanToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax(SyntaxKind.XmlEmbeddedExpression, null, null, (PunctuationSyntax)lessThanPercentEqualsToken.Node, expression, (PunctuationSyntax)percentGreaterThanToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax XmlEmbeddedExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return XmlEmbeddedExpression(Token(SyntaxKind.LessThanPercentEqualsToken), expression, Token(SyntaxKind.PercentGreaterThanToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayTypeSyntax ArrayType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax elementType, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax> rankSpecifiers)
		{
			if (elementType == null)
			{
				throw new ArgumentNullException("elementType");
			}
			SyntaxKind syntaxKind = elementType.Kind();
			if (syntaxKind - 397 > SyntaxKind.EndIfStatement && syntaxKind - 409 > SyntaxKind.List && syntaxKind != SyntaxKind.TupleType)
			{
				throw new ArgumentException("elementType");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayTypeSyntax(SyntaxKind.ArrayType, null, null, elementType, rankSpecifiers.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayTypeSyntax ArrayType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax elementType)
		{
			return ArrayType(elementType, SingletonList(ArrayRankSpecifier()));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.NullableTypeSyntax NullableType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax elementType, SyntaxToken questionMarkToken)
		{
			if (elementType == null)
			{
				throw new ArgumentNullException("elementType");
			}
			SyntaxKind syntaxKind = elementType.Kind();
			if (syntaxKind - 398 > (SyntaxKind)4 && syntaxKind - 409 > SyntaxKind.List && syntaxKind != SyntaxKind.TupleType)
			{
				throw new ArgumentException("elementType");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(questionMarkToken);
			if (syntaxKind2 != SyntaxKind.QuestionToken)
			{
				throw new ArgumentException("questionMarkToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.NullableTypeSyntax(SyntaxKind.NullableType, null, null, elementType, (PunctuationSyntax)questionMarkToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.NullableTypeSyntax NullableType(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax elementType)
		{
			return NullableType(elementType, Token(SyntaxKind.QuestionToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedTypeSyntax PredefinedType(SyntaxToken keyword)
		{
			switch (VisualBasicExtensions.Kind(keyword))
			{
			default:
				throw new ArgumentException("keyword");
			case SyntaxKind.BooleanKeyword:
			case SyntaxKind.ByteKeyword:
			case SyntaxKind.CharKeyword:
			case SyntaxKind.DateKeyword:
			case SyntaxKind.DecimalKeyword:
			case SyntaxKind.DoubleKeyword:
			case SyntaxKind.IntegerKeyword:
			case SyntaxKind.LongKeyword:
			case SyntaxKind.ObjectKeyword:
			case SyntaxKind.SByteKeyword:
			case SyntaxKind.ShortKeyword:
			case SyntaxKind.SingleKeyword:
			case SyntaxKind.StringKeyword:
			case SyntaxKind.UIntegerKeyword:
			case SyntaxKind.ULongKeyword:
			case SyntaxKind.UShortKeyword:
				return new Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedTypeSyntax(SyntaxKind.PredefinedType, null, null, (KeywordSyntax)keyword.Node);
			}
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax(SyntaxKind.IdentifierName, null, null, (IdentifierTokenSyntax)identifier.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax IdentifierName(string identifier)
		{
			return IdentifierName(Identifier(identifier));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax GenericName(SyntaxToken identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax typeArgumentList)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(identifier);
			if (syntaxKind != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("identifier");
			}
			if (typeArgumentList == null)
			{
				throw new ArgumentNullException("typeArgumentList");
			}
			SyntaxKind syntaxKind2 = typeArgumentList.Kind();
			if (syntaxKind2 != SyntaxKind.TypeArgumentList)
			{
				throw new ArgumentException("typeArgumentList");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax(SyntaxKind.GenericName, null, null, (IdentifierTokenSyntax)identifier.Node, typeArgumentList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax GenericName(string identifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax typeArgumentList)
		{
			return GenericName(Identifier(identifier), typeArgumentList);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax QualifiedName(Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax left, SyntaxToken dotToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind - 399 > (SyntaxKind)3 && syntaxKind - 409 > SyntaxKind.List)
			{
				throw new ArgumentException("left");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(dotToken);
			if (syntaxKind2 != SyntaxKind.DotToken)
			{
				throw new ArgumentException("dotToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 - 399 > SyntaxKind.List)
			{
				throw new ArgumentException("right");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax(SyntaxKind.QualifiedName, null, null, left, (PunctuationSyntax)dotToken.Node, right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax QualifiedName(Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax right)
		{
			return QualifiedName(left, Token(SyntaxKind.DotToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.GlobalNameSyntax GlobalName(SyntaxToken globalKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(globalKeyword);
			if (syntaxKind != SyntaxKind.GlobalKeyword)
			{
				throw new ArgumentException("globalKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.GlobalNameSyntax(SyntaxKind.GlobalName, null, null, (KeywordSyntax)globalKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.GlobalNameSyntax GlobalName()
		{
			return GlobalName(Token(SyntaxKind.GlobalKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax TypeArgumentList(SyntaxToken openParenToken, SyntaxToken ofKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax> arguments, SyntaxToken closeParenToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(openParenToken);
			if (syntaxKind != SyntaxKind.OpenParenToken)
			{
				throw new ArgumentException("openParenToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(ofKeyword);
			if (syntaxKind2 != SyntaxKind.OfKeyword)
			{
				throw new ArgumentException("ofKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(closeParenToken);
			if (syntaxKind3 != SyntaxKind.CloseParenToken)
			{
				throw new ArgumentException("closeParenToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax(SyntaxKind.TypeArgumentList, null, null, (PunctuationSyntax)openParenToken.Node, (KeywordSyntax)ofKeyword.Node, arguments.Node, (PunctuationSyntax)closeParenToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax TypeArgumentList(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax> arguments)
		{
			return TypeArgumentList(Token(SyntaxKind.OpenParenToken), Token(SyntaxKind.OfKeyword), arguments, Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax TypeArgumentList(params Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax[] arguments)
		{
			return TypeArgumentList(Token(SyntaxKind.OpenParenToken), Token(SyntaxKind.OfKeyword), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax>().AddRange(arguments), Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax CrefReference(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax name, Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignatureSyntax signature, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax asClause)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			SyntaxKind syntaxKind = name.Kind();
			if (syntaxKind - 396 > SyntaxKind.EndUsingStatement && syntaxKind - 409 > SyntaxKind.List && syntaxKind != SyntaxKind.TupleType)
			{
				throw new ArgumentException("name");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax(SyntaxKind.CrefReference, null, null, name, signature, asClause);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax CrefReference(Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax name)
		{
			return CrefReference(name, null, null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignatureSyntax CrefSignature(SyntaxToken openParenToken, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignaturePartSyntax> argumentTypes, SyntaxToken closeParenToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(openParenToken);
			if (syntaxKind != SyntaxKind.OpenParenToken)
			{
				throw new ArgumentException("openParenToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(closeParenToken);
			if (syntaxKind2 != SyntaxKind.CloseParenToken)
			{
				throw new ArgumentException("closeParenToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignatureSyntax(SyntaxKind.CrefSignature, null, null, (PunctuationSyntax)openParenToken.Node, argumentTypes.Node, (PunctuationSyntax)closeParenToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignatureSyntax CrefSignature(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignaturePartSyntax> argumentTypes)
		{
			return CrefSignature(Token(SyntaxKind.OpenParenToken), argumentTypes, Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignatureSyntax CrefSignature(params Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignaturePartSyntax[] argumentTypes)
		{
			return CrefSignature(Token(SyntaxKind.OpenParenToken), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignaturePartSyntax>().AddRange(argumentTypes), Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignaturePartSyntax CrefSignaturePart(SyntaxToken modifier, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type)
		{
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignaturePartSyntax(SyntaxKind.CrefSignaturePart, null, null, (KeywordSyntax)modifier.Node, type);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignaturePartSyntax CrefSignaturePart()
		{
			return CrefSignaturePart(default(SyntaxToken), null);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefOperatorReferenceSyntax CrefOperatorReference(SyntaxToken operatorKeyword, SyntaxToken operatorToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(operatorKeyword);
			if (syntaxKind != SyntaxKind.OperatorKeyword)
			{
				throw new ArgumentException("operatorKeyword");
			}
			switch (VisualBasicExtensions.Kind(operatorToken))
			{
			default:
				throw new ArgumentException("operatorToken");
			case SyntaxKind.AndKeyword:
			case SyntaxKind.CTypeKeyword:
			case SyntaxKind.LikeKeyword:
			case SyntaxKind.ModKeyword:
			case SyntaxKind.NotKeyword:
			case SyntaxKind.OrKeyword:
			case SyntaxKind.XorKeyword:
			case SyntaxKind.IsFalseKeyword:
			case SyntaxKind.IsTrueKeyword:
			case SyntaxKind.AmpersandToken:
			case SyntaxKind.AsteriskToken:
			case SyntaxKind.PlusToken:
			case SyntaxKind.MinusToken:
			case SyntaxKind.SlashToken:
			case SyntaxKind.LessThanToken:
			case SyntaxKind.LessThanEqualsToken:
			case SyntaxKind.LessThanGreaterThanToken:
			case SyntaxKind.EqualsToken:
			case SyntaxKind.GreaterThanToken:
			case SyntaxKind.GreaterThanEqualsToken:
			case SyntaxKind.BackslashToken:
			case SyntaxKind.CaretToken:
			case SyntaxKind.LessThanLessThanToken:
			case SyntaxKind.GreaterThanGreaterThanToken:
				return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefOperatorReferenceSyntax(SyntaxKind.CrefOperatorReference, null, null, (KeywordSyntax)operatorKeyword.Node, (Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken)operatorToken.Node);
			}
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefOperatorReferenceSyntax CrefOperatorReference(SyntaxToken operatorToken)
		{
			return CrefOperatorReference(Token(SyntaxKind.OperatorKeyword), operatorToken);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedCrefOperatorReferenceSyntax QualifiedCrefOperatorReference(Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax left, SyntaxToken dotToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefOperatorReferenceSyntax right)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			SyntaxKind syntaxKind = left.Kind();
			if (syntaxKind - 399 > (SyntaxKind)3 && syntaxKind - 409 > SyntaxKind.List)
			{
				throw new ArgumentException("left");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(dotToken);
			if (syntaxKind2 != SyntaxKind.DotToken)
			{
				throw new ArgumentException("dotToken");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			SyntaxKind syntaxKind3 = right.Kind();
			if (syntaxKind3 != SyntaxKind.CrefOperatorReference)
			{
				throw new ArgumentException("right");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedCrefOperatorReferenceSyntax(SyntaxKind.QualifiedCrefOperatorReference, null, null, left, (PunctuationSyntax)dotToken.Node, right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedCrefOperatorReferenceSyntax QualifiedCrefOperatorReference(Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax left, Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefOperatorReferenceSyntax right)
		{
			return QualifiedCrefOperatorReference(left, Token(SyntaxKind.DotToken), right);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.YieldStatementSyntax YieldStatement(SyntaxToken yieldKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(yieldKeyword);
			if (syntaxKind != SyntaxKind.YieldKeyword)
			{
				throw new ArgumentException("yieldKeyword");
			}
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind2 = expression.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("expression");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.YieldStatementSyntax(SyntaxKind.YieldStatement, null, null, (KeywordSyntax)yieldKeyword.Node, expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.YieldStatementSyntax YieldStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return YieldStatement(Token(SyntaxKind.YieldKeyword), expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax AwaitExpression(SyntaxToken awaitKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(awaitKeyword);
			if (syntaxKind != SyntaxKind.AwaitKeyword)
			{
				throw new ArgumentException("awaitKeyword");
			}
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind2 = expression.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("expression");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax(SyntaxKind.AwaitExpression, null, null, (KeywordSyntax)awaitKeyword.Node, expression);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax AwaitExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return AwaitExpression(Token(SyntaxKind.AwaitKeyword), expression);
		}

		public static SyntaxToken XmlNameToken(SyntaxTriviaList leadingTrivia, string text, SyntaxKind possibleKeywordKind, SyntaxTriviaList trailingTrivia)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			return new SyntaxToken(null, new XmlNameTokenSyntax(SyntaxKind.XmlNameToken, null, null, text, leadingTrivia.Node, trailingTrivia.Node, possibleKeywordKind), 0, 0);
		}

		public static SyntaxToken XmlNameToken(string text, SyntaxKind possibleKeywordKind)
		{
			return XmlNameToken(default(SyntaxTriviaList), text, possibleKeywordKind, default(SyntaxTriviaList));
		}

		public static SyntaxToken XmlTextLiteralToken(SyntaxTriviaList leadingTrivia, string text, string value, SyntaxTriviaList trailingTrivia)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			return new SyntaxToken(null, new XmlTextTokenSyntax(SyntaxKind.XmlTextLiteralToken, null, null, text, leadingTrivia.Node, trailingTrivia.Node, value), 0, 0);
		}

		public static SyntaxToken XmlTextLiteralToken(string text, string value)
		{
			return XmlTextLiteralToken(default(SyntaxTriviaList), text, value, default(SyntaxTriviaList));
		}

		public static SyntaxToken XmlEntityLiteralToken(SyntaxTriviaList leadingTrivia, string text, string value, SyntaxTriviaList trailingTrivia)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			return new SyntaxToken(null, new XmlTextTokenSyntax(SyntaxKind.XmlEntityLiteralToken, null, null, text, leadingTrivia.Node, trailingTrivia.Node, value), 0, 0);
		}

		public static SyntaxToken XmlEntityLiteralToken(string text, string value)
		{
			return XmlEntityLiteralToken(default(SyntaxTriviaList), text, value, default(SyntaxTriviaList));
		}

		public static SyntaxToken DocumentationCommentLineBreakToken(SyntaxTriviaList leadingTrivia, string text, string value, SyntaxTriviaList trailingTrivia)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			return new SyntaxToken(null, new XmlTextTokenSyntax(SyntaxKind.DocumentationCommentLineBreakToken, null, null, text, leadingTrivia.Node, trailingTrivia.Node, value), 0, 0);
		}

		public static SyntaxToken DocumentationCommentLineBreakToken(string text, string value)
		{
			return DocumentationCommentLineBreakToken(default(SyntaxTriviaList), text, value, default(SyntaxTriviaList));
		}

		public static SyntaxToken XmlTextToken(SyntaxTriviaList leadingTrivia, SyntaxKind kind, string text, string value, SyntaxTriviaList trailingTrivia)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			if (!SyntaxFacts.IsXmlTextToken(kind))
			{
				throw new ArgumentException("kind");
			}
			return new SyntaxToken(null, new XmlTextTokenSyntax(kind, null, null, text, leadingTrivia.Node, trailingTrivia.Node, value), 0, 0);
		}

		public static SyntaxToken XmlTextToken(SyntaxKind kind, string text, string value)
		{
			return XmlTextToken(default(SyntaxTriviaList), kind, text, value, default(SyntaxTriviaList));
		}

		public static SyntaxToken InterpolatedStringTextToken(SyntaxTriviaList leadingTrivia, string text, string value, SyntaxTriviaList trailingTrivia)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			return new SyntaxToken(null, new InterpolatedStringTextTokenSyntax(SyntaxKind.InterpolatedStringTextToken, null, null, text, leadingTrivia.Node, trailingTrivia.Node, value), 0, 0);
		}

		public static SyntaxToken InterpolatedStringTextToken(string text, string value)
		{
			return InterpolatedStringTextToken(default(SyntaxTriviaList), text, value, default(SyntaxTriviaList));
		}

		public static SyntaxToken DecimalLiteralToken(SyntaxTriviaList leadingTrivia, string text, TypeCharacter typeSuffix, decimal value, SyntaxTriviaList trailingTrivia)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			return new SyntaxToken(null, new DecimalLiteralTokenSyntax(SyntaxKind.DecimalLiteralToken, null, null, text, leadingTrivia.Node, trailingTrivia.Node, typeSuffix, value), 0, 0);
		}

		public static SyntaxToken DecimalLiteralToken(string text, TypeCharacter typeSuffix, decimal value)
		{
			return DecimalLiteralToken(default(SyntaxTriviaList), text, typeSuffix, value, default(SyntaxTriviaList));
		}

		public static SyntaxToken DateLiteralToken(SyntaxTriviaList leadingTrivia, string text, DateTime value, SyntaxTriviaList trailingTrivia)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			return new SyntaxToken(null, new DateLiteralTokenSyntax(SyntaxKind.DateLiteralToken, null, null, text, leadingTrivia.Node, trailingTrivia.Node, value), 0, 0);
		}

		public static SyntaxToken DateLiteralToken(string text, DateTime value)
		{
			return DateLiteralToken(default(SyntaxTriviaList), text, value, default(SyntaxTriviaList));
		}

		public static SyntaxToken StringLiteralToken(SyntaxTriviaList leadingTrivia, string text, string value, SyntaxTriviaList trailingTrivia)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			return new SyntaxToken(null, new StringLiteralTokenSyntax(SyntaxKind.StringLiteralToken, null, null, text, leadingTrivia.Node, trailingTrivia.Node, value), 0, 0);
		}

		public static SyntaxToken StringLiteralToken(string text, string value)
		{
			return StringLiteralToken(default(SyntaxTriviaList), text, value, default(SyntaxTriviaList));
		}

		public static SyntaxToken CharacterLiteralToken(SyntaxTriviaList leadingTrivia, string text, char value, SyntaxTriviaList trailingTrivia)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			return new SyntaxToken(null, new CharacterLiteralTokenSyntax(SyntaxKind.CharacterLiteralToken, null, null, text, leadingTrivia.Node, trailingTrivia.Node, value), 0, 0);
		}

		public static SyntaxToken CharacterLiteralToken(string text, char value)
		{
			return CharacterLiteralToken(default(SyntaxTriviaList), text, value, default(SyntaxTriviaList));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SkippedTokensTriviaSyntax SkippedTokensTrivia(SyntaxTokenList tokens)
		{
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, null, null, tokens.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SkippedTokensTriviaSyntax SkippedTokensTrivia()
		{
			return SkippedTokensTrivia(default(SyntaxTokenList));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> content)
		{
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DocumentationCommentTriviaSyntax(SyntaxKind.DocumentationCommentTrivia, null, null, content.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DocumentationCommentTriviaSyntax DocumentationCommentTrivia()
		{
			return DocumentationCommentTrivia(default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax>));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCrefAttributeSyntax XmlCrefAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax reference, SyntaxToken endQuoteToken)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			SyntaxKind syntaxKind = name.Kind();
			if (syntaxKind != SyntaxKind.XmlName)
			{
				throw new ArgumentException("name");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(equalsToken);
			if (syntaxKind2 != SyntaxKind.EqualsToken)
			{
				throw new ArgumentException("equalsToken");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(startQuoteToken);
			if (syntaxKind3 != SyntaxKind.SingleQuoteToken && syntaxKind3 != SyntaxKind.DoubleQuoteToken)
			{
				throw new ArgumentException("startQuoteToken");
			}
			if (reference == null)
			{
				throw new ArgumentNullException("reference");
			}
			SyntaxKind syntaxKind4 = reference.Kind();
			if (syntaxKind4 != SyntaxKind.CrefReference)
			{
				throw new ArgumentException("reference");
			}
			SyntaxKind syntaxKind5 = VisualBasicExtensions.Kind(endQuoteToken);
			if (syntaxKind5 != SyntaxKind.SingleQuoteToken && syntaxKind5 != SyntaxKind.DoubleQuoteToken)
			{
				throw new ArgumentException("endQuoteToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCrefAttributeSyntax(SyntaxKind.XmlCrefAttribute, null, null, name, (PunctuationSyntax)equalsToken.Node, (PunctuationSyntax)startQuoteToken.Node, reference, (PunctuationSyntax)endQuoteToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCrefAttributeSyntax XmlCrefAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax name, SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax reference, SyntaxToken endQuoteToken)
		{
			return XmlCrefAttribute(name, Token(SyntaxKind.EqualsToken), startQuoteToken, reference, endQuoteToken);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameAttributeSyntax XmlNameAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax reference, SyntaxToken endQuoteToken)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			SyntaxKind syntaxKind = name.Kind();
			if (syntaxKind != SyntaxKind.XmlName)
			{
				throw new ArgumentException("name");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(equalsToken);
			if (syntaxKind2 != SyntaxKind.EqualsToken)
			{
				throw new ArgumentException("equalsToken");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(startQuoteToken);
			if (syntaxKind3 != SyntaxKind.SingleQuoteToken && syntaxKind3 != SyntaxKind.DoubleQuoteToken)
			{
				throw new ArgumentException("startQuoteToken");
			}
			if (reference == null)
			{
				throw new ArgumentNullException("reference");
			}
			SyntaxKind syntaxKind4 = reference.Kind();
			if (syntaxKind4 != SyntaxKind.IdentifierName)
			{
				throw new ArgumentException("reference");
			}
			SyntaxKind syntaxKind5 = VisualBasicExtensions.Kind(endQuoteToken);
			if (syntaxKind5 != SyntaxKind.SingleQuoteToken && syntaxKind5 != SyntaxKind.DoubleQuoteToken)
			{
				throw new ArgumentException("endQuoteToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameAttributeSyntax(SyntaxKind.XmlNameAttribute, null, null, name, (PunctuationSyntax)equalsToken.Node, (PunctuationSyntax)startQuoteToken.Node, reference, (PunctuationSyntax)endQuoteToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameAttributeSyntax XmlNameAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax name, SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax reference, SyntaxToken endQuoteToken)
		{
			return XmlNameAttribute(name, Token(SyntaxKind.EqualsToken), startQuoteToken, reference, endQuoteToken);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax ConditionalAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, SyntaxToken questionMarkToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax whenNotNull)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(questionMarkToken);
			if (syntaxKind != SyntaxKind.QuestionToken)
			{
				throw new ArgumentException("questionMarkToken");
			}
			if (whenNotNull == null)
			{
				throw new ArgumentNullException("whenNotNull");
			}
			SyntaxKind syntaxKind2 = whenNotNull.Kind();
			if (syntaxKind2 - 291 > SyntaxKind.EndIfStatement && syntaxKind2 != SyntaxKind.ConditionalAccessExpression)
			{
				throw new ArgumentException("whenNotNull");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax(SyntaxKind.ConditionalAccessExpression, null, null, expression, (PunctuationSyntax)questionMarkToken.Node, whenNotNull);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax ConditionalAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax whenNotNull)
		{
			return ConditionalAccessExpression(expression, Token(SyntaxKind.QuestionToken), whenNotNull);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax ConditionalAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax whenNotNull)
		{
			return ConditionalAccessExpression(null, Token(SyntaxKind.QuestionToken), whenNotNull);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.NameOfExpressionSyntax NameOfExpression(SyntaxToken nameOfKeyword, SyntaxToken openParenToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax argument, SyntaxToken closeParenToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(nameOfKeyword);
			if (syntaxKind != SyntaxKind.NameOfKeyword)
			{
				throw new ArgumentException("nameOfKeyword");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(openParenToken);
			if (syntaxKind2 != SyntaxKind.OpenParenToken)
			{
				throw new ArgumentException("openParenToken");
			}
			if (argument == null)
			{
				throw new ArgumentNullException("argument");
			}
			SyntaxKind syntaxKind3 = argument.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_0306;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_0306;
			}
			throw new ArgumentException("argument");
			IL_0306:
			SyntaxKind syntaxKind4 = VisualBasicExtensions.Kind(closeParenToken);
			if (syntaxKind4 != SyntaxKind.CloseParenToken)
			{
				throw new ArgumentException("closeParenToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.NameOfExpressionSyntax(SyntaxKind.NameOfExpression, null, null, (KeywordSyntax)nameOfKeyword.Node, (PunctuationSyntax)openParenToken.Node, argument, (PunctuationSyntax)closeParenToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.NameOfExpressionSyntax NameOfExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax argument)
		{
			return NameOfExpression(Token(SyntaxKind.NameOfKeyword), Token(SyntaxKind.OpenParenToken), argument, Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken dollarSignDoubleQuoteToken, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringContentSyntax> contents, SyntaxToken doubleQuoteToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(dollarSignDoubleQuoteToken);
			if (syntaxKind != SyntaxKind.DollarSignDoubleQuoteToken)
			{
				throw new ArgumentException("dollarSignDoubleQuoteToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(doubleQuoteToken);
			if (syntaxKind2 != SyntaxKind.DoubleQuoteToken)
			{
				throw new ArgumentException("doubleQuoteToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringExpressionSyntax(SyntaxKind.InterpolatedStringExpression, null, null, (PunctuationSyntax)dollarSignDoubleQuoteToken.Node, contents.Node, (PunctuationSyntax)doubleQuoteToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringContentSyntax> contents)
		{
			return InterpolatedStringExpression(Token(SyntaxKind.DollarSignDoubleQuoteToken), contents, Token(SyntaxKind.DoubleQuoteToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringExpressionSyntax InterpolatedStringExpression(params Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringContentSyntax[] contents)
		{
			return InterpolatedStringExpression(Token(SyntaxKind.DollarSignDoubleQuoteToken), List(contents), Token(SyntaxKind.DoubleQuoteToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(textToken);
			if (syntaxKind != SyntaxKind.InterpolatedStringTextToken)
			{
				throw new ArgumentException("textToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringTextSyntax(SyntaxKind.InterpolatedStringText, null, null, (InterpolatedStringTextTokenSyntax)textToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringTextSyntax InterpolatedStringText()
		{
			return InterpolatedStringText(Token(SyntaxKind.InterpolatedStringTextToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationSyntax Interpolation(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationAlignmentClauseSyntax alignmentClause, Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(openBraceToken);
			if (syntaxKind != SyntaxKind.OpenBraceToken)
			{
				throw new ArgumentException("openBraceToken");
			}
			if (expression == null)
			{
				throw new ArgumentNullException("expression");
			}
			SyntaxKind syntaxKind2 = expression.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("expression");
			IL_02ec:
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(closeBraceToken);
			if (syntaxKind3 != SyntaxKind.CloseBraceToken)
			{
				throw new ArgumentException("closeBraceToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationSyntax(SyntaxKind.Interpolation, null, null, (PunctuationSyntax)openBraceToken.Node, expression, alignmentClause, formatClause, (PunctuationSyntax)closeBraceToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationSyntax Interpolation(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationAlignmentClauseSyntax alignmentClause)
		{
			return Interpolation(Token(SyntaxKind.OpenBraceToken), expression, alignmentClause, null, Token(SyntaxKind.CloseBraceToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationSyntax Interpolation(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return Interpolation(Token(SyntaxKind.OpenBraceToken), expression, null, null, Token(SyntaxKind.CloseBraceToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(commaToken);
			if (syntaxKind != SyntaxKind.CommaToken)
			{
				throw new ArgumentException("commaToken");
			}
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			SyntaxKind syntaxKind2 = value.Kind();
			if (syntaxKind2 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind2)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_02ec;
				}
			}
			else if (syntaxKind2 - 711 <= SyntaxKind.EmptyStatement || syntaxKind2 - 779 <= SyntaxKind.List || syntaxKind2 - 788 <= SyntaxKind.List)
			{
				goto IL_02ec;
			}
			throw new ArgumentException("value");
			IL_02ec:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationAlignmentClauseSyntax(SyntaxKind.InterpolationAlignmentClause, null, null, (PunctuationSyntax)commaToken.Node, value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value)
		{
			return InterpolationAlignmentClause(Token(SyntaxKind.CommaToken), value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(colonToken);
			if (syntaxKind != SyntaxKind.ColonToken)
			{
				throw new ArgumentException("colonToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(formatStringToken);
			if (syntaxKind2 != SyntaxKind.InterpolatedStringTextToken)
			{
				throw new ArgumentException("formatStringToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationFormatClauseSyntax(SyntaxKind.InterpolationFormatClause, null, null, (PunctuationSyntax)colonToken.Node, (InterpolatedStringTextTokenSyntax)formatStringToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationFormatClauseSyntax InterpolationFormatClause()
		{
			return InterpolationFormatClause(Token(SyntaxKind.ColonToken), Token(SyntaxKind.InterpolatedStringTextToken));
		}

		public static SyntaxTrivia WhitespaceTrivia(string text)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			SyntaxToken token = default(SyntaxToken);
			return new SyntaxTrivia(in token, new Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxTrivia(SyntaxKind.WhitespaceTrivia, null, null, text), 0, 0);
		}

		public static SyntaxTrivia EndOfLineTrivia(string text)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			SyntaxToken token = default(SyntaxToken);
			return new SyntaxTrivia(in token, new Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxTrivia(SyntaxKind.EndOfLineTrivia, null, null, text), 0, 0);
		}

		public static SyntaxTrivia ColonTrivia(string text)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			SyntaxToken token = default(SyntaxToken);
			return new SyntaxTrivia(in token, new Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxTrivia(SyntaxKind.ColonTrivia, null, null, text), 0, 0);
		}

		public static SyntaxTrivia CommentTrivia(string text)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			SyntaxToken token = default(SyntaxToken);
			return new SyntaxTrivia(in token, new Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxTrivia(SyntaxKind.CommentTrivia, null, null, text), 0, 0);
		}

		public static SyntaxTrivia ConflictMarkerTrivia(string text)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			SyntaxToken token = default(SyntaxToken);
			return new SyntaxTrivia(in token, new Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxTrivia(SyntaxKind.ConflictMarkerTrivia, null, null, text), 0, 0);
		}

		public static SyntaxTrivia LineContinuationTrivia(string text)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			SyntaxToken token = default(SyntaxToken);
			return new SyntaxTrivia(in token, new Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxTrivia(SyntaxKind.LineContinuationTrivia, null, null, text), 0, 0);
		}

		public static SyntaxTrivia DocumentationCommentExteriorTrivia(string text)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			SyntaxToken token = default(SyntaxToken);
			return new SyntaxTrivia(in token, new Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxTrivia(SyntaxKind.DocumentationCommentExteriorTrivia, null, null, text), 0, 0);
		}

		public static SyntaxTrivia DisabledTextTrivia(string text)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			SyntaxToken token = default(SyntaxToken);
			return new SyntaxTrivia(in token, new Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxTrivia(SyntaxKind.DisabledTextTrivia, null, null, text), 0, 0);
		}

		public static SyntaxTrivia SyntaxTrivia(SyntaxKind kind, string text)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			if (!SyntaxFacts.IsSyntaxTrivia(kind))
			{
				throw new ArgumentException("kind");
			}
			SyntaxToken token = default(SyntaxToken);
			return new SyntaxTrivia(in token, new Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxTrivia(kind, null, null, text), 0, 0);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstDirectiveTriviaSyntax ConstDirectiveTrivia(SyntaxToken hashToken, SyntaxToken constKeyword, SyntaxToken name, SyntaxToken equalsToken, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(hashToken);
			if (syntaxKind != SyntaxKind.HashToken)
			{
				throw new ArgumentException("hashToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(constKeyword);
			if (syntaxKind2 != SyntaxKind.ConstKeyword)
			{
				throw new ArgumentException("constKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(name);
			if (syntaxKind3 != SyntaxKind.IdentifierToken)
			{
				throw new ArgumentException("name");
			}
			SyntaxKind syntaxKind4 = VisualBasicExtensions.Kind(equalsToken);
			if (syntaxKind4 != SyntaxKind.EqualsToken)
			{
				throw new ArgumentException("equalsToken");
			}
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			SyntaxKind syntaxKind5 = value.Kind();
			if (syntaxKind5 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind5)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_0344;
				}
			}
			else if (syntaxKind5 - 711 <= SyntaxKind.EmptyStatement || syntaxKind5 - 779 <= SyntaxKind.List || syntaxKind5 - 788 <= SyntaxKind.List)
			{
				goto IL_0344;
			}
			throw new ArgumentException("value");
			IL_0344:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstDirectiveTriviaSyntax(SyntaxKind.ConstDirectiveTrivia, null, null, (PunctuationSyntax)hashToken.Node, (KeywordSyntax)constKeyword.Node, (IdentifierTokenSyntax)name.Node, (PunctuationSyntax)equalsToken.Node, value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstDirectiveTriviaSyntax ConstDirectiveTrivia(SyntaxToken name, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value)
		{
			return ConstDirectiveTrivia(Token(SyntaxKind.HashToken), Token(SyntaxKind.ConstKeyword), name, Token(SyntaxKind.EqualsToken), value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstDirectiveTriviaSyntax ConstDirectiveTrivia(string name, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax value)
		{
			return ConstDirectiveTrivia(Token(SyntaxKind.HashToken), Token(SyntaxKind.ConstKeyword), Identifier(name), Token(SyntaxKind.EqualsToken), value);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken ifOrElseIfKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition, SyntaxToken thenKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(hashToken);
			if (syntaxKind != SyntaxKind.HashToken)
			{
				throw new ArgumentException("hashToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(ifOrElseIfKeyword);
			if (syntaxKind2 != SyntaxKind.ElseIfKeyword && syntaxKind2 != SyntaxKind.IfKeyword)
			{
				throw new ArgumentException("ifOrElseIfKeyword");
			}
			if (condition == null)
			{
				throw new ArgumentNullException("condition");
			}
			SyntaxKind syntaxKind3 = condition.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_030e;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_030e;
			}
			throw new ArgumentException("condition");
			IL_030e:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.IfDirectiveTriviaSyntax(SyntaxKind.IfDirectiveTrivia, null, null, (PunctuationSyntax)hashToken.Node, (KeywordSyntax)elseKeyword.Node, (KeywordSyntax)ifOrElseIfKeyword.Node, condition, (KeywordSyntax)thenKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken ifOrElseIfKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition)
		{
			return IfDirectiveTrivia(SyntaxKind.IfDirectiveTrivia, Token(SyntaxKind.HashToken), default(SyntaxToken), ifOrElseIfKeyword, condition, default(SyntaxToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.IfDirectiveTriviaSyntax ElseIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken ifOrElseIfKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition, SyntaxToken thenKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(hashToken);
			if (syntaxKind != SyntaxKind.HashToken)
			{
				throw new ArgumentException("hashToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(ifOrElseIfKeyword);
			if (syntaxKind2 != SyntaxKind.ElseIfKeyword && syntaxKind2 != SyntaxKind.IfKeyword)
			{
				throw new ArgumentException("ifOrElseIfKeyword");
			}
			if (condition == null)
			{
				throw new ArgumentNullException("condition");
			}
			SyntaxKind syntaxKind3 = condition.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_030e;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_030e;
			}
			throw new ArgumentException("condition");
			IL_030e:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.IfDirectiveTriviaSyntax(SyntaxKind.ElseIfDirectiveTrivia, null, null, (PunctuationSyntax)hashToken.Node, (KeywordSyntax)elseKeyword.Node, (KeywordSyntax)ifOrElseIfKeyword.Node, condition, (KeywordSyntax)thenKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.IfDirectiveTriviaSyntax ElseIfDirectiveTrivia(SyntaxToken ifOrElseIfKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition)
		{
			return ElseIfDirectiveTrivia(Token(SyntaxKind.HashToken), default(SyntaxToken), ifOrElseIfKeyword, condition, default(SyntaxToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken ifOrElseIfKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition, SyntaxToken thenKeyword)
		{
			if (!SyntaxFacts.IsIfDirectiveTrivia(kind))
			{
				throw new ArgumentException("kind");
			}
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(hashToken);
			if (syntaxKind != SyntaxKind.HashToken)
			{
				throw new ArgumentException("hashToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(ifOrElseIfKeyword);
			if (syntaxKind2 != SyntaxKind.ElseIfKeyword && syntaxKind2 != SyntaxKind.IfKeyword)
			{
				throw new ArgumentException("ifOrElseIfKeyword");
			}
			if (condition == null)
			{
				throw new ArgumentNullException("condition");
			}
			SyntaxKind syntaxKind3 = condition.Kind();
			if (syntaxKind3 <= SyntaxKind.AwaitExpression)
			{
				switch (syntaxKind3)
				{
				case SyntaxKind.KeywordEventContainer:
				case SyntaxKind.WithEventsEventContainer:
				case SyntaxKind.WithEventsPropertyEventContainer:
				case SyntaxKind.IdentifierLabel:
				case SyntaxKind.NumericLabel:
				case SyntaxKind.NextLabel:
				case SyntaxKind.MidExpression:
				case SyntaxKind.CharacterLiteralExpression:
				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
				case SyntaxKind.NumericLiteralExpression:
				case SyntaxKind.DateLiteralExpression:
				case SyntaxKind.StringLiteralExpression:
				case SyntaxKind.NothingLiteralExpression:
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.MeExpression:
				case SyntaxKind.MyBaseExpression:
				case SyntaxKind.MyClassExpression:
				case SyntaxKind.GetTypeExpression:
				case SyntaxKind.TypeOfIsExpression:
				case SyntaxKind.TypeOfIsNotExpression:
				case SyntaxKind.GetXmlNamespaceExpression:
				case SyntaxKind.SimpleMemberAccessExpression:
				case SyntaxKind.DictionaryAccessExpression:
				case SyntaxKind.XmlElementAccessExpression:
				case SyntaxKind.XmlDescendantAccessExpression:
				case SyntaxKind.XmlAttributeAccessExpression:
				case SyntaxKind.InvocationExpression:
				case SyntaxKind.ObjectCreationExpression:
				case SyntaxKind.AnonymousObjectCreationExpression:
				case SyntaxKind.ArrayCreationExpression:
				case SyntaxKind.CollectionInitializer:
				case SyntaxKind.CTypeExpression:
				case SyntaxKind.DirectCastExpression:
				case SyntaxKind.TryCastExpression:
				case SyntaxKind.PredefinedCastExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.IntegerDivideExpression:
				case SyntaxKind.ExponentiateExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.ConcatenateExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.EqualsExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.IsNotExpression:
				case SyntaxKind.LikeExpression:
				case SyntaxKind.OrExpression:
				case SyntaxKind.ExclusiveOrExpression:
				case SyntaxKind.AndExpression:
				case SyntaxKind.OrElseExpression:
				case SyntaxKind.AndAlsoExpression:
				case SyntaxKind.UnaryPlusExpression:
				case SyntaxKind.UnaryMinusExpression:
				case SyntaxKind.NotExpression:
				case SyntaxKind.AddressOfExpression:
				case SyntaxKind.BinaryConditionalExpression:
				case SyntaxKind.TernaryConditionalExpression:
				case SyntaxKind.SingleLineFunctionLambdaExpression:
				case SyntaxKind.SingleLineSubLambdaExpression:
				case SyntaxKind.MultiLineFunctionLambdaExpression:
				case SyntaxKind.MultiLineSubLambdaExpression:
				case SyntaxKind.QueryExpression:
				case SyntaxKind.FunctionAggregation:
				case SyntaxKind.GroupAggregation:
				case SyntaxKind.XmlDocument:
				case SyntaxKind.XmlElement:
				case SyntaxKind.XmlText:
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
				case SyntaxKind.XmlEmptyElement:
				case SyntaxKind.XmlAttribute:
				case SyntaxKind.XmlString:
				case SyntaxKind.XmlPrefixName:
				case SyntaxKind.XmlName:
				case SyntaxKind.XmlBracketedName:
				case SyntaxKind.XmlComment:
				case SyntaxKind.XmlProcessingInstruction:
				case SyntaxKind.XmlCDataSection:
				case SyntaxKind.XmlEmbeddedExpression:
				case SyntaxKind.ArrayType:
				case SyntaxKind.NullableType:
				case SyntaxKind.PredefinedType:
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.GlobalName:
				case SyntaxKind.CrefOperatorReference:
				case SyntaxKind.QualifiedCrefOperatorReference:
				case SyntaxKind.AwaitExpression:
					goto IL_0323;
				}
			}
			else if (syntaxKind3 - 711 <= SyntaxKind.EmptyStatement || syntaxKind3 - 779 <= SyntaxKind.List || syntaxKind3 - 788 <= SyntaxKind.List)
			{
				goto IL_0323;
			}
			throw new ArgumentException("condition");
			IL_0323:
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.IfDirectiveTriviaSyntax(kind, null, null, (PunctuationSyntax)hashToken.Node, (KeywordSyntax)elseKeyword.Node, (KeywordSyntax)ifOrElseIfKeyword.Node, condition, (KeywordSyntax)thenKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxKind kind, SyntaxToken ifOrElseIfKeyword, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax condition)
		{
			return IfDirectiveTrivia(kind, Token(SyntaxKind.HashToken), default(SyntaxToken), ifOrElseIfKeyword, condition, default(SyntaxToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseDirectiveTriviaSyntax ElseDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(hashToken);
			if (syntaxKind != SyntaxKind.HashToken)
			{
				throw new ArgumentException("hashToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(elseKeyword);
			if (syntaxKind2 != SyntaxKind.ElseKeyword)
			{
				throw new ArgumentException("elseKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseDirectiveTriviaSyntax(SyntaxKind.ElseDirectiveTrivia, null, null, (PunctuationSyntax)hashToken.Node, (KeywordSyntax)elseKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseDirectiveTriviaSyntax ElseDirectiveTrivia()
		{
			return ElseDirectiveTrivia(Token(SyntaxKind.HashToken), Token(SyntaxKind.ElseKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endKeyword, SyntaxToken ifKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(hashToken);
			if (syntaxKind != SyntaxKind.HashToken)
			{
				throw new ArgumentException("hashToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind2 != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(ifKeyword);
			if (syntaxKind3 != SyntaxKind.IfKeyword)
			{
				throw new ArgumentException("ifKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndIfDirectiveTriviaSyntax(SyntaxKind.EndIfDirectiveTrivia, null, null, (PunctuationSyntax)hashToken.Node, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)ifKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia()
		{
			return EndIfDirectiveTrivia(Token(SyntaxKind.HashToken), Token(SyntaxKind.EndKeyword), Token(SyntaxKind.IfKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RegionDirectiveTriviaSyntax RegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken name)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(hashToken);
			if (syntaxKind != SyntaxKind.HashToken)
			{
				throw new ArgumentException("hashToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(regionKeyword);
			if (syntaxKind2 != SyntaxKind.RegionKeyword)
			{
				throw new ArgumentException("regionKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(name);
			if (syntaxKind3 != SyntaxKind.StringLiteralToken)
			{
				throw new ArgumentException("name");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.RegionDirectiveTriviaSyntax(SyntaxKind.RegionDirectiveTrivia, null, null, (PunctuationSyntax)hashToken.Node, (KeywordSyntax)regionKeyword.Node, (StringLiteralTokenSyntax)name.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.RegionDirectiveTriviaSyntax RegionDirectiveTrivia()
		{
			return RegionDirectiveTrivia(Token(SyntaxKind.HashToken), Token(SyntaxKind.RegionKeyword), Token(SyntaxKind.StringLiteralToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endKeyword, SyntaxToken regionKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(hashToken);
			if (syntaxKind != SyntaxKind.HashToken)
			{
				throw new ArgumentException("hashToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind2 != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(regionKeyword);
			if (syntaxKind3 != SyntaxKind.RegionKeyword)
			{
				throw new ArgumentException("regionKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndRegionDirectiveTriviaSyntax(SyntaxKind.EndRegionDirectiveTrivia, null, null, (PunctuationSyntax)hashToken.Node, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)regionKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia()
		{
			return EndRegionDirectiveTrivia(Token(SyntaxKind.HashToken), Token(SyntaxKind.EndKeyword), Token(SyntaxKind.RegionKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalSourceDirectiveTriviaSyntax ExternalSourceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken externalSourceKeyword, SyntaxToken openParenToken, SyntaxToken externalSource, SyntaxToken commaToken, SyntaxToken lineStart, SyntaxToken closeParenToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(hashToken);
			if (syntaxKind != SyntaxKind.HashToken)
			{
				throw new ArgumentException("hashToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(externalSourceKeyword);
			if (syntaxKind2 != SyntaxKind.ExternalSourceKeyword)
			{
				throw new ArgumentException("externalSourceKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(openParenToken);
			if (syntaxKind3 != SyntaxKind.OpenParenToken)
			{
				throw new ArgumentException("openParenToken");
			}
			SyntaxKind syntaxKind4 = VisualBasicExtensions.Kind(externalSource);
			if (syntaxKind4 != SyntaxKind.StringLiteralToken)
			{
				throw new ArgumentException("externalSource");
			}
			SyntaxKind syntaxKind5 = VisualBasicExtensions.Kind(commaToken);
			if (syntaxKind5 != SyntaxKind.CommaToken)
			{
				throw new ArgumentException("commaToken");
			}
			SyntaxKind syntaxKind6 = VisualBasicExtensions.Kind(lineStart);
			if (syntaxKind6 != SyntaxKind.IntegerLiteralToken)
			{
				throw new ArgumentException("lineStart");
			}
			SyntaxKind syntaxKind7 = VisualBasicExtensions.Kind(closeParenToken);
			if (syntaxKind7 != SyntaxKind.CloseParenToken)
			{
				throw new ArgumentException("closeParenToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalSourceDirectiveTriviaSyntax(SyntaxKind.ExternalSourceDirectiveTrivia, null, null, (PunctuationSyntax)hashToken.Node, (KeywordSyntax)externalSourceKeyword.Node, (PunctuationSyntax)openParenToken.Node, (StringLiteralTokenSyntax)externalSource.Node, (PunctuationSyntax)commaToken.Node, (IntegerLiteralTokenSyntax)lineStart.Node, (PunctuationSyntax)closeParenToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalSourceDirectiveTriviaSyntax ExternalSourceDirectiveTrivia()
		{
			return ExternalSourceDirectiveTrivia(Token(SyntaxKind.HashToken), Token(SyntaxKind.ExternalSourceKeyword), Token(SyntaxKind.OpenParenToken), Token(SyntaxKind.StringLiteralToken), Token(SyntaxKind.CommaToken), Token(SyntaxKind.IntegerLiteralToken), Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndExternalSourceDirectiveTriviaSyntax EndExternalSourceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endKeyword, SyntaxToken externalSourceKeyword)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(hashToken);
			if (syntaxKind != SyntaxKind.HashToken)
			{
				throw new ArgumentException("hashToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(endKeyword);
			if (syntaxKind2 != SyntaxKind.EndKeyword)
			{
				throw new ArgumentException("endKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(externalSourceKeyword);
			if (syntaxKind3 != SyntaxKind.ExternalSourceKeyword)
			{
				throw new ArgumentException("externalSourceKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndExternalSourceDirectiveTriviaSyntax(SyntaxKind.EndExternalSourceDirectiveTrivia, null, null, (PunctuationSyntax)hashToken.Node, (KeywordSyntax)endKeyword.Node, (KeywordSyntax)externalSourceKeyword.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EndExternalSourceDirectiveTriviaSyntax EndExternalSourceDirectiveTrivia()
		{
			return EndExternalSourceDirectiveTrivia(Token(SyntaxKind.HashToken), Token(SyntaxKind.EndKeyword), Token(SyntaxKind.ExternalSourceKeyword));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalChecksumDirectiveTriviaSyntax ExternalChecksumDirectiveTrivia(SyntaxToken hashToken, SyntaxToken externalChecksumKeyword, SyntaxToken openParenToken, SyntaxToken externalSource, SyntaxToken firstCommaToken, SyntaxToken guid, SyntaxToken secondCommaToken, SyntaxToken checksum, SyntaxToken closeParenToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(hashToken);
			if (syntaxKind != SyntaxKind.HashToken)
			{
				throw new ArgumentException("hashToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(externalChecksumKeyword);
			if (syntaxKind2 != SyntaxKind.ExternalChecksumKeyword)
			{
				throw new ArgumentException("externalChecksumKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(openParenToken);
			if (syntaxKind3 != SyntaxKind.OpenParenToken)
			{
				throw new ArgumentException("openParenToken");
			}
			SyntaxKind syntaxKind4 = VisualBasicExtensions.Kind(externalSource);
			if (syntaxKind4 != SyntaxKind.StringLiteralToken)
			{
				throw new ArgumentException("externalSource");
			}
			SyntaxKind syntaxKind5 = VisualBasicExtensions.Kind(firstCommaToken);
			if (syntaxKind5 != SyntaxKind.CommaToken)
			{
				throw new ArgumentException("firstCommaToken");
			}
			SyntaxKind syntaxKind6 = VisualBasicExtensions.Kind(guid);
			if (syntaxKind6 != SyntaxKind.StringLiteralToken)
			{
				throw new ArgumentException("guid");
			}
			SyntaxKind syntaxKind7 = VisualBasicExtensions.Kind(secondCommaToken);
			if (syntaxKind7 != SyntaxKind.CommaToken)
			{
				throw new ArgumentException("secondCommaToken");
			}
			SyntaxKind syntaxKind8 = VisualBasicExtensions.Kind(checksum);
			if (syntaxKind8 != SyntaxKind.StringLiteralToken)
			{
				throw new ArgumentException("checksum");
			}
			SyntaxKind syntaxKind9 = VisualBasicExtensions.Kind(closeParenToken);
			if (syntaxKind9 != SyntaxKind.CloseParenToken)
			{
				throw new ArgumentException("closeParenToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalChecksumDirectiveTriviaSyntax(SyntaxKind.ExternalChecksumDirectiveTrivia, null, null, (PunctuationSyntax)hashToken.Node, (KeywordSyntax)externalChecksumKeyword.Node, (PunctuationSyntax)openParenToken.Node, (StringLiteralTokenSyntax)externalSource.Node, (PunctuationSyntax)firstCommaToken.Node, (StringLiteralTokenSyntax)guid.Node, (PunctuationSyntax)secondCommaToken.Node, (StringLiteralTokenSyntax)checksum.Node, (PunctuationSyntax)closeParenToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalChecksumDirectiveTriviaSyntax ExternalChecksumDirectiveTrivia()
		{
			return ExternalChecksumDirectiveTrivia(Token(SyntaxKind.HashToken), Token(SyntaxKind.ExternalChecksumKeyword), Token(SyntaxKind.OpenParenToken), Token(SyntaxKind.StringLiteralToken), Token(SyntaxKind.CommaToken), Token(SyntaxKind.StringLiteralToken), Token(SyntaxKind.CommaToken), Token(SyntaxKind.StringLiteralToken), Token(SyntaxKind.CloseParenToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EnableWarningDirectiveTriviaSyntax EnableWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken enableKeyword, SyntaxToken warningKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax> errorCodes)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(hashToken);
			if (syntaxKind != SyntaxKind.HashToken)
			{
				throw new ArgumentException("hashToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(enableKeyword);
			if (syntaxKind2 != SyntaxKind.EnableKeyword)
			{
				throw new ArgumentException("enableKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(warningKeyword);
			if (syntaxKind3 != SyntaxKind.WarningKeyword)
			{
				throw new ArgumentException("warningKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EnableWarningDirectiveTriviaSyntax(SyntaxKind.EnableWarningDirectiveTrivia, null, null, (PunctuationSyntax)hashToken.Node, (KeywordSyntax)enableKeyword.Node, (KeywordSyntax)warningKeyword.Node, errorCodes.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EnableWarningDirectiveTriviaSyntax EnableWarningDirectiveTrivia(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax> errorCodes)
		{
			return EnableWarningDirectiveTrivia(Token(SyntaxKind.HashToken), Token(SyntaxKind.EnableKeyword), Token(SyntaxKind.WarningKeyword), errorCodes);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.EnableWarningDirectiveTriviaSyntax EnableWarningDirectiveTrivia(params Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax[] errorCodes)
		{
			return EnableWarningDirectiveTrivia(Token(SyntaxKind.HashToken), Token(SyntaxKind.EnableKeyword), Token(SyntaxKind.WarningKeyword), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax>().AddRange(errorCodes));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DisableWarningDirectiveTriviaSyntax DisableWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken disableKeyword, SyntaxToken warningKeyword, SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax> errorCodes)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(hashToken);
			if (syntaxKind != SyntaxKind.HashToken)
			{
				throw new ArgumentException("hashToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(disableKeyword);
			if (syntaxKind2 != SyntaxKind.DisableKeyword)
			{
				throw new ArgumentException("disableKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(warningKeyword);
			if (syntaxKind3 != SyntaxKind.WarningKeyword)
			{
				throw new ArgumentException("warningKeyword");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DisableWarningDirectiveTriviaSyntax(SyntaxKind.DisableWarningDirectiveTrivia, null, null, (PunctuationSyntax)hashToken.Node, (KeywordSyntax)disableKeyword.Node, (KeywordSyntax)warningKeyword.Node, errorCodes.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DisableWarningDirectiveTriviaSyntax DisableWarningDirectiveTrivia(SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax> errorCodes)
		{
			return DisableWarningDirectiveTrivia(Token(SyntaxKind.HashToken), Token(SyntaxKind.DisableKeyword), Token(SyntaxKind.WarningKeyword), errorCodes);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DisableWarningDirectiveTriviaSyntax DisableWarningDirectiveTrivia(params Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax[] errorCodes)
		{
			return DisableWarningDirectiveTrivia(Token(SyntaxKind.HashToken), Token(SyntaxKind.DisableKeyword), Token(SyntaxKind.WarningKeyword), SeparatedList<Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax>().AddRange(errorCodes));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(hashToken);
			if (syntaxKind != SyntaxKind.HashToken)
			{
				throw new ArgumentException("hashToken");
			}
			SyntaxKind syntaxKind2 = VisualBasicExtensions.Kind(referenceKeyword);
			if (syntaxKind2 != SyntaxKind.ReferenceKeyword)
			{
				throw new ArgumentException("referenceKeyword");
			}
			SyntaxKind syntaxKind3 = VisualBasicExtensions.Kind(file);
			if (syntaxKind3 != SyntaxKind.StringLiteralToken)
			{
				throw new ArgumentException("file");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ReferenceDirectiveTriviaSyntax(SyntaxKind.ReferenceDirectiveTrivia, null, null, (PunctuationSyntax)hashToken.Node, (KeywordSyntax)referenceKeyword.Node, (StringLiteralTokenSyntax)file.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia()
		{
			return ReferenceDirectiveTrivia(Token(SyntaxKind.HashToken), Token(SyntaxKind.ReferenceKeyword), Token(SyntaxKind.StringLiteralToken));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken hashToken)
		{
			SyntaxKind syntaxKind = VisualBasicExtensions.Kind(hashToken);
			if (syntaxKind != SyntaxKind.HashToken)
			{
				throw new ArgumentException("hashToken");
			}
			return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BadDirectiveTriviaSyntax(SyntaxKind.BadDirectiveTrivia, null, null, (PunctuationSyntax)hashToken.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.BadDirectiveTriviaSyntax BadDirectiveTrivia()
		{
			return BadDirectiveTrivia(Token(SyntaxKind.HashToken));
		}

		public static SyntaxTrivia EndOfLine(string text)
		{
			return (SyntaxTrivia)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndOfLine(text);
		}

		public static SyntaxTrivia ElasticEndOfLine(string text)
		{
			return (SyntaxTrivia)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndOfLine(text, elastic: true);
		}

		[Obsolete("Use SyntaxFactory.EndOfLine or SyntaxFactory.ElasticEndOfLine")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public static SyntaxTrivia EndOfLine(string text, bool elastic)
		{
			return (SyntaxTrivia)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.EndOfLine(text, elastic);
		}

		public static SyntaxTrivia Whitespace(string text)
		{
			return (SyntaxTrivia)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.Whitespace(text);
		}

		public static SyntaxTrivia ElasticWhitespace(string text)
		{
			return (SyntaxTrivia)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.Whitespace(text, elastic: true);
		}

		[Obsolete("Use SyntaxFactory.Whitespace or SyntaxFactory.ElasticWhitespace")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public static SyntaxTrivia Whitespace(string text, bool elastic)
		{
			return (SyntaxTrivia)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.Whitespace(text, elastic);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax GetStandaloneExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax node)
		{
			if (node != null && node.Parent is Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expressionSyntax)
			{
				switch (node.Kind())
				{
				case SyntaxKind.IdentifierName:
				case SyntaxKind.GenericName:
					switch (expressionSyntax.Kind())
					{
					case SyntaxKind.QualifiedName:
						if (((Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax)expressionSyntax).Right == node)
						{
							return expressionSyntax;
						}
						break;
					case SyntaxKind.SimpleMemberAccessExpression:
						if (((Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax)expressionSyntax).Name == node)
						{
							return expressionSyntax;
						}
						break;
					}
					break;
				case SyntaxKind.XmlBracketedName:
				{
					SyntaxKind syntaxKind = expressionSyntax.Kind();
					if (syntaxKind - 293 <= SyntaxKind.EmptyStatement && ((Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax)expressionSyntax).Name == node)
					{
						return expressionSyntax;
					}
					break;
				}
				case SyntaxKind.XmlElementStartTag:
				case SyntaxKind.XmlElementEndTag:
					if (expressionSyntax.Kind() == SyntaxKind.XmlElement)
					{
						return expressionSyntax;
					}
					break;
				}
			}
			return node;
		}

		internal static void VerifySyntaxKindOfToken(SyntaxKind kind)
		{
			SyntaxKind syntaxKind = kind;
			if ((syntaxKind < SyntaxKind.AddHandlerKeyword || syntaxKind > SyntaxKind.EndOfXmlToken) && syntaxKind != SyntaxKind.NameOfKeyword && syntaxKind != SyntaxKind.DollarSignDoubleQuoteToken && syntaxKind != SyntaxKind.InterpolatedStringTextToken && syntaxKind != SyntaxKind.EndOfInterpolatedStringToken)
			{
				throw new ArgumentOutOfRangeException("kind");
			}
		}

		public static SyntaxToken Token(SyntaxKind kind, string text = null)
		{
			VerifySyntaxKindOfToken(kind);
			return (SyntaxToken)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.Token(ElasticMarker.UnderlyingNode, kind, ElasticMarker.UnderlyingNode, text);
		}

		internal static SyntaxToken Token(SyntaxKind kind, SyntaxTrivia trailing, string text = null)
		{
			return Token(kind, SyntaxTriviaList.Create(trailing), text);
		}

		public static SyntaxToken Token(SyntaxKind kind, SyntaxTriviaList trailing, string text = null)
		{
			VerifySyntaxKindOfToken(kind);
			return (SyntaxToken)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.Token(ElasticMarker.UnderlyingNode, kind, trailing.Node, text);
		}

		public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, string text = null)
		{
			VerifySyntaxKindOfToken(kind);
			return (SyntaxToken)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.Token(leading.Node, kind, ElasticMarker.UnderlyingNode, text);
		}

		internal static SyntaxToken Token(SyntaxTrivia leading, SyntaxKind kind, SyntaxTrivia trailing, string text = null)
		{
			return Token(SyntaxTriviaList.Create(leading), kind, SyntaxTriviaList.Create(trailing), text);
		}

		public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing, string text = null)
		{
			VerifySyntaxKindOfToken(kind);
			return (SyntaxToken)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.Token(leading.Node, kind, trailing.Node, text);
		}

		public static SyntaxToken Literal(int value)
		{
			return Literal(Microsoft.CodeAnalysis.VisualBasic.ObjectDisplay.ObjectDisplay.FormatLiteral(value, ObjectDisplayOptions.None), value);
		}

		public static SyntaxToken Literal(string text, int value)
		{
			return Literal(s_elasticMarkerList, text, value, s_elasticMarkerList);
		}

		public static SyntaxToken Literal(SyntaxTriviaList leading, string text, int value, SyntaxTriviaList trailing)
		{
			return (SyntaxToken)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.IntegerLiteralToken(text, text.StartsWith("&H", StringComparison.OrdinalIgnoreCase) ? LiteralBase.Hexadecimal : (text.StartsWith("&O", StringComparison.OrdinalIgnoreCase) ? LiteralBase.Octal : (text.StartsWith("&B", StringComparison.OrdinalIgnoreCase) ? LiteralBase.Binary : LiteralBase.Decimal)), text.EndsWith("I", StringComparison.OrdinalIgnoreCase) ? TypeCharacter.IntegerLiteral : TypeCharacter.None, (ulong)value, leading.Node, trailing.Node);
		}

		public static SyntaxToken Literal(uint value)
		{
			return Literal(Microsoft.CodeAnalysis.VisualBasic.ObjectDisplay.ObjectDisplay.FormatLiteral(value, ObjectDisplayOptions.IncludeTypeSuffix), value);
		}

		public static SyntaxToken Literal(string text, uint value)
		{
			return Literal(s_elasticMarkerList, text, value, s_elasticMarkerList);
		}

		public static SyntaxToken Literal(SyntaxTriviaList leading, string text, uint value, SyntaxTriviaList trailing)
		{
			return (SyntaxToken)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.IntegerLiteralToken(text, text.StartsWith("&H", StringComparison.OrdinalIgnoreCase) ? LiteralBase.Hexadecimal : (text.StartsWith("&O", StringComparison.OrdinalIgnoreCase) ? LiteralBase.Octal : (text.StartsWith("&B", StringComparison.OrdinalIgnoreCase) ? LiteralBase.Binary : LiteralBase.Decimal)), text.EndsWith("UI", StringComparison.OrdinalIgnoreCase) ? TypeCharacter.UIntegerLiteral : TypeCharacter.None, value, leading.Node, trailing.Node);
		}

		public static SyntaxToken Literal(long value)
		{
			return Literal(Microsoft.CodeAnalysis.VisualBasic.ObjectDisplay.ObjectDisplay.FormatLiteral(value, ObjectDisplayOptions.IncludeTypeSuffix), value);
		}

		public static SyntaxToken Literal(string text, long value)
		{
			return Literal(s_elasticMarkerList, text, value, s_elasticMarkerList);
		}

		public static SyntaxToken Literal(SyntaxTriviaList leading, string text, long value, SyntaxTriviaList trailing)
		{
			return (SyntaxToken)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.IntegerLiteralToken(text, text.StartsWith("&H", StringComparison.OrdinalIgnoreCase) ? LiteralBase.Hexadecimal : (text.StartsWith("&O", StringComparison.OrdinalIgnoreCase) ? LiteralBase.Octal : (text.StartsWith("&B", StringComparison.OrdinalIgnoreCase) ? LiteralBase.Binary : LiteralBase.Decimal)), text.EndsWith("L", StringComparison.OrdinalIgnoreCase) ? TypeCharacter.LongLiteral : TypeCharacter.None, (ulong)value, leading.Node, trailing.Node);
		}

		public static SyntaxToken Literal(ulong value)
		{
			return Literal(Microsoft.CodeAnalysis.VisualBasic.ObjectDisplay.ObjectDisplay.FormatLiteral(value, ObjectDisplayOptions.IncludeTypeSuffix), value);
		}

		public static SyntaxToken Literal(string text, ulong value)
		{
			return Literal(s_elasticMarkerList, text, value, s_elasticMarkerList);
		}

		public static SyntaxToken Literal(SyntaxTriviaList leading, string text, ulong value, SyntaxTriviaList trailing)
		{
			return (SyntaxToken)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.IntegerLiteralToken(text, text.StartsWith("&H", StringComparison.OrdinalIgnoreCase) ? LiteralBase.Hexadecimal : (text.StartsWith("&O", StringComparison.OrdinalIgnoreCase) ? LiteralBase.Octal : (text.StartsWith("&B", StringComparison.OrdinalIgnoreCase) ? LiteralBase.Binary : LiteralBase.Decimal)), text.EndsWith("UL", StringComparison.OrdinalIgnoreCase) ? TypeCharacter.ULongLiteral : TypeCharacter.None, value, leading.Node, trailing.Node);
		}

		public static SyntaxToken Literal(float value)
		{
			return Literal(Microsoft.CodeAnalysis.VisualBasic.ObjectDisplay.ObjectDisplay.FormatLiteral(value, ObjectDisplayOptions.IncludeTypeSuffix), value);
		}

		public static SyntaxToken Literal(string text, float value)
		{
			return Literal(s_elasticMarkerList, text, value, s_elasticMarkerList);
		}

		public static SyntaxToken Literal(SyntaxTriviaList leading, string text, float value, SyntaxTriviaList trailing)
		{
			return (SyntaxToken)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.FloatingLiteralToken(text, text.EndsWith("F", StringComparison.Ordinal) ? TypeCharacter.Single : TypeCharacter.None, value, leading.Node, trailing.Node);
		}

		public static SyntaxToken Literal(double value)
		{
			return Literal(Microsoft.CodeAnalysis.VisualBasic.ObjectDisplay.ObjectDisplay.FormatLiteral(value, ObjectDisplayOptions.None), value);
		}

		public static SyntaxToken Literal(string text, double value)
		{
			return Literal(s_elasticMarkerList, text, value, s_elasticMarkerList);
		}

		public static SyntaxToken Literal(SyntaxTriviaList leading, string text, double value, SyntaxTriviaList trailing)
		{
			return (SyntaxToken)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.FloatingLiteralToken(text, text.EndsWith("R", StringComparison.OrdinalIgnoreCase) ? TypeCharacter.DoubleLiteral : TypeCharacter.None, value, leading.Node, trailing.Node);
		}

		public static SyntaxToken Literal(decimal value)
		{
			return Literal(Microsoft.CodeAnalysis.VisualBasic.ObjectDisplay.ObjectDisplay.FormatLiteral(value, ObjectDisplayOptions.IncludeTypeSuffix), value);
		}

		public static SyntaxToken Literal(string text, decimal value)
		{
			return Literal(s_elasticMarkerList, text, value, s_elasticMarkerList);
		}

		public static SyntaxToken Literal(SyntaxTriviaList leading, string text, decimal value, SyntaxTriviaList trailing)
		{
			return (SyntaxToken)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DecimalLiteralToken(text, text.EndsWith("M", StringComparison.OrdinalIgnoreCase) ? TypeCharacter.DecimalLiteral : TypeCharacter.None, value, leading.Node, trailing.Node);
		}

		public static SyntaxToken Literal(string value)
		{
			return Literal(Microsoft.CodeAnalysis.VisualBasic.ObjectDisplay.ObjectDisplay.FormatLiteral(value, ObjectDisplayOptions.UseQuotes | ObjectDisplayOptions.EscapeNonPrintableCharacters), value);
		}

		public static SyntaxToken Literal(string text, string value)
		{
			return Literal(s_elasticMarkerList, text, value, s_elasticMarkerList);
		}

		public static SyntaxToken Literal(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)
		{
			return (SyntaxToken)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.StringLiteralToken(text, value, leading.Node, trailing.Node);
		}

		public static SyntaxToken Literal(char value)
		{
			return Literal(Microsoft.CodeAnalysis.VisualBasic.ObjectDisplay.ObjectDisplay.FormatLiteral(value, ObjectDisplayOptions.UseQuotes | ObjectDisplayOptions.EscapeNonPrintableCharacters), value);
		}

		public static SyntaxToken Literal(string text, char value)
		{
			return Literal(s_elasticMarkerList, text, value, s_elasticMarkerList);
		}

		public static SyntaxToken Literal(SyntaxTriviaList leading, string text, char value, SyntaxTriviaList trailing)
		{
			return (SyntaxToken)Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.CharacterLiteralToken(text, value, leading.Node, trailing.Node);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax TypeBlock(SyntaxKind blockKind, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax begin, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax> inherits = default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax>), SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax> implements = default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax>), SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax> members = default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax>), Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax end = null)
		{
			return blockKind switch
			{
				SyntaxKind.ModuleBlock => ModuleBlock((Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax)begin, inherits, implements, members, end), 
				SyntaxKind.ClassBlock => ClassBlock((Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax)begin, inherits, implements, members, end), 
				SyntaxKind.StructureBlock => StructureBlock((Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax)begin, inherits, implements, members, end), 
				SyntaxKind.InterfaceBlock => InterfaceBlock((Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax)begin, inherits, implements, members, end), 
				_ => throw ExceptionUtilities.UnexpectedValue(blockKind), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax TypeStatement(SyntaxKind statementKind, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax> attributes = default(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax>), SyntaxTokenList modifiers = default(SyntaxTokenList), SyntaxToken keyword = default(SyntaxToken), SyntaxToken identifier = default(SyntaxToken), Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax typeParameterList = null)
		{
			return statementKind switch
			{
				SyntaxKind.ModuleStatement => ModuleStatement(attributes, modifiers, keyword, identifier, typeParameterList), 
				SyntaxKind.ClassStatement => ClassStatement(attributes, modifiers, keyword, identifier, typeParameterList), 
				SyntaxKind.StructureStatement => StructureStatement(attributes, modifiers, keyword, identifier, typeParameterList), 
				SyntaxKind.InterfaceStatement => InterfaceStatement(attributes, modifiers, keyword, identifier, typeParameterList), 
				_ => throw ExceptionUtilities.UnexpectedValue(statementKind), 
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DocumentationCommentTriviaSyntax DocumentationComment(params Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax[] content)
		{
			return DocumentationCommentTrivia(List(content)).WithLeadingTrivia(DocumentationCommentExteriorTrivia("''' ")).WithTrailingTrivia(EndOfLine(""));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlSummaryElement(params Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax[] content)
		{
			return XmlSummaryElement(List(content));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlSummaryElement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> content)
		{
			return XmlMultiLineElement("summary", content);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax XmlSeeElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax cref)
		{
			return XmlEmptyElement("see").AddAttributes(XmlCrefAttribute(cref));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax XmlSeeAlsoElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax cref)
		{
			return XmlEmptyElement("seealso").AddAttributes(XmlCrefAttribute(cref));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlSeeAlsoElement(Uri linkAddress, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> linkText)
		{
			string text = linkAddress.ToString().ToLowerInvariant();
			Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax xmlElementSyntax = XmlElement("seealso", linkText);
			return xmlElementSyntax.WithStartTag(xmlElementSyntax.StartTag.AddAttributes(XmlAttribute(XmlName(null, XmlTextLiteralToken("cref", "cref")), XmlString(Token(SyntaxKind.DoubleQuoteToken), SyntaxTokenList.Create(XmlTextLiteralToken(text, text)), Token(SyntaxKind.DoubleQuoteToken)))));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax XmlThreadSafetyElement()
		{
			return XmlThreadSafetyElement(isStatic: true, isInstance: false);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax XmlThreadSafetyElement(bool isStatic, bool isInstance)
		{
			string text = isStatic.ToString().ToLowerInvariant();
			string text2 = isInstance.ToString().ToLowerInvariant();
			return XmlEmptyElement(XmlName(null, XmlNameToken("threadsafety", SyntaxKind.XmlNameToken)).WithTrailingTrivia(ElasticSpace)).AddAttributes(XmlAttribute(XmlName(null, XmlNameToken("static", SyntaxKind.XmlNameToken)), XmlString(Token(SyntaxKind.DoubleQuoteToken), SyntaxTokenList.Create(XmlTextLiteralToken(text, text)), Token(SyntaxKind.DoubleQuoteToken))).WithTrailingTrivia(ElasticSpace), XmlAttribute(XmlName(null, XmlNameToken("instance", SyntaxKind.XmlNameToken)), XmlString(Token(SyntaxKind.DoubleQuoteToken), SyntaxTokenList.Create(XmlTextLiteralToken(text2, text2)), Token(SyntaxKind.DoubleQuoteToken))));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameAttributeSyntax XmlNameAttribute(string parameterName)
		{
			return XmlNameAttribute(XmlName(null, XmlNameToken("name", SyntaxKind.XmlNameToken)), Token(SyntaxKind.DoubleQuoteToken), IdentifierName(parameterName), Token(SyntaxKind.DoubleQuoteToken)).WithLeadingTrivia(Whitespace(" "));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax XmlPreliminaryElement()
		{
			return XmlEmptyElement("preliminary");
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCrefAttributeSyntax XmlCrefAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax cref)
		{
			return XmlCrefAttribute(cref, SyntaxKind.DoubleQuoteToken);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCrefAttributeSyntax XmlCrefAttribute(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax cref, SyntaxKind quoteKind)
		{
			cref = cref.ReplaceTokens(cref.DescendantTokens(), XmlReplaceBracketTokens);
			return XmlCrefAttribute(XmlName(null, XmlNameToken("cref", SyntaxKind.XmlNameToken)), Token(quoteKind), cref, Token(quoteKind)).WithLeadingTrivia(Whitespace(" "));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlRemarksElement(params Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax[] content)
		{
			return XmlRemarksElement(List(content));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlRemarksElement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> content)
		{
			return XmlMultiLineElement("remarks", content);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlReturnsElement(params Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax[] content)
		{
			return XmlReturnsElement(List(content));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlReturnsElement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> content)
		{
			return XmlMultiLineElement("returns", content);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlValueElement(params Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax[] content)
		{
			return XmlValueElement(List(content));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlValueElement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> content)
		{
			return XmlMultiLineElement("value", content);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlExceptionElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax cref, params Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax[] content)
		{
			return XmlExceptionElement(cref, List(content));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlExceptionElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax cref, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> content)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax xmlElementSyntax = XmlElement("exception", content);
			return xmlElementSyntax.WithStartTag(xmlElementSyntax.StartTag.AddAttributes(XmlCrefAttribute(cref)));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlPermissionElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax cref, params Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax[] content)
		{
			return XmlPermissionElement(cref, List(content));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlPermissionElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax cref, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> content)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax xmlElementSyntax = XmlElement("permission", content);
			return xmlElementSyntax.WithStartTag(xmlElementSyntax.StartTag.AddAttributes(XmlCrefAttribute(cref)));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlExampleElement(params Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax[] content)
		{
			return XmlExampleElement(List(content));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlExampleElement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> content)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax xmlElementSyntax = XmlElement("example", content);
			return xmlElementSyntax.WithStartTag(xmlElementSyntax.StartTag);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlParaElement(params Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax[] content)
		{
			return XmlParaElement(List(content));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlParaElement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> content)
		{
			return XmlElement("para", content);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlParamElement(string parameterName, params Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax[] content)
		{
			return XmlParamElement(parameterName, List(content));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlParamElement(string parameterName, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> content)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax xmlElementSyntax = XmlElement("param", content);
			return xmlElementSyntax.WithStartTag(xmlElementSyntax.StartTag.AddAttributes(XmlNameAttribute(parameterName)));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax XmlParamRefElement(string parameterName)
		{
			return XmlEmptyElement("paramref").AddAttributes(XmlNameAttribute(parameterName));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax XmlNullKeywordElement()
		{
			return XmlKeywordElement("null");
		}

		private static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax XmlKeywordElement(string keyword)
		{
			Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax xmlAttributeSyntax = XmlAttribute(XmlName(null, XmlTextLiteralToken("langword", "langword")), XmlString(Token(SyntaxKind.DoubleQuoteToken), SyntaxTokenList.Create(XmlTextLiteralToken(keyword, keyword)), Token(SyntaxKind.DoubleQuoteToken)));
			return XmlEmptyElement("see").AddAttributes(xmlAttributeSyntax);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlPlaceholderElement(params Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax[] content)
		{
			return XmlPlaceholderElement(List(content));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlPlaceholderElement(SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> content)
		{
			return XmlElement("placeholder", content);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax XmlEmptyElement(string localName)
		{
			return XmlEmptyElement(XmlName(null, XmlNameToken(localName, SyntaxKind.XmlNameToken)));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlElement(string localName, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> content)
		{
			return XmlElement(XmlName(null, XmlNameToken(localName, SyntaxKind.XmlNameToken)), content);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax name, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> content)
		{
			return XmlElement(XmlElementStartTag(name), content, XmlElementEndTag(name));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlMultiLineElement(string localName, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> content)
		{
			return XmlMultiLineElement(XmlName(null, XmlNameToken(localName, SyntaxKind.XmlNameToken)), content);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax XmlMultiLineElement(Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax name, SyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax> content)
		{
			return XmlElement(XmlElementStartTag(name), content, XmlElementEndTag(name));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlTextSyntax XmlNewLine(string text)
		{
			return XmlText(XmlTextNewLine(text));
		}

		public static SyntaxToken XmlTextNewLine(string text)
		{
			return XmlTextNewLine(text, continueXmlDocumentationComment: true);
		}

		public static SyntaxToken XmlTextNewLine(string text, string value, SyntaxTriviaList leading, SyntaxTriviaList trailing)
		{
			return new SyntaxToken(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DocumentationCommentLineBreakToken(text, value, leading.Node, trailing.Node));
		}

		public static SyntaxToken XmlTextNewLine(string text, bool continueXmlDocumentationComment)
		{
			SyntaxToken result = new SyntaxToken(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.DocumentationCommentLineBreakToken(text, text, ElasticMarker.UnderlyingNode, ElasticMarker.UnderlyingNode));
			if (continueXmlDocumentationComment)
			{
				return result.WithTrailingTrivia(result.TrailingTrivia.Add(DocumentationCommentExteriorTrivia("''' ")));
			}
			return result;
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlTextSyntax XmlText(string value)
		{
			return XmlText(XmlTextLiteral(value));
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlTextSyntax XmlText(params SyntaxToken[] textTokens)
		{
			return XmlText(TokenList(textTokens));
		}

		public static SyntaxToken XmlTextLiteral(string value)
		{
			return XmlTextLiteral(new XText(value).ToString(), value);
		}

		public static SyntaxToken XmlTextLiteral(string text, string value)
		{
			return new SyntaxToken(Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlTextLiteralToken(text, value, ElasticMarker.UnderlyingNode, ElasticMarker.UnderlyingNode));
		}

		private static SyntaxToken XmlReplaceBracketTokens(SyntaxToken originalToken, SyntaxToken rewrittenToken)
		{
			if (Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(rewrittenToken, SyntaxKind.LessThanToken) && string.Equals("<", rewrittenToken.Text, StringComparison.Ordinal))
			{
				return Token(rewrittenToken.LeadingTrivia, SyntaxKind.LessThanToken, rewrittenToken.TrailingTrivia, rewrittenToken.ValueText);
			}
			if (Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(rewrittenToken, SyntaxKind.GreaterThanToken) && string.Equals(">", rewrittenToken.Text, StringComparison.Ordinal))
			{
				return Token(rewrittenToken.LeadingTrivia, SyntaxKind.GreaterThanToken, rewrittenToken.TrailingTrivia, rewrittenToken.ValueText);
			}
			return rewrittenToken;
		}

		public static bool AreEquivalent(SyntaxTree oldTree, SyntaxTree newTree, bool topLevel)
		{
			return SyntaxEquivalence.AreEquivalent(oldTree, newTree, null, topLevel);
		}

		public static bool AreEquivalent(SyntaxNode oldNode, SyntaxNode newNode, bool topLevel)
		{
			return SyntaxEquivalence.AreEquivalent(oldNode, newNode, null, topLevel);
		}

		public static bool AreEquivalent(SyntaxNode oldNode, SyntaxNode newNode, Func<SyntaxKind, bool> ignoreChildNode = null)
		{
			return SyntaxEquivalence.AreEquivalent(oldNode, newNode, ignoreChildNode, topLevel: false);
		}

		public static bool AreEquivalent(SyntaxToken oldToken, SyntaxToken newToken)
		{
			return SyntaxEquivalence.AreEquivalent(oldToken, newToken);
		}

		public static bool AreEquivalent(SyntaxTokenList oldList, SyntaxTokenList newList)
		{
			return SyntaxEquivalence.AreEquivalent(oldList, newList);
		}

		public static bool AreEquivalent<TNode>(SyntaxList<TNode> oldList, SyntaxList<TNode> newList, Func<SyntaxKind, bool> ignoreChildNode = null) where TNode : SyntaxNode
		{
			return SyntaxEquivalence.AreEquivalent(oldList.Node, newList.Node, ignoreChildNode, topLevel: false);
		}

		public static bool AreEquivalent<TNode>(SeparatedSyntaxList<TNode> oldList, SeparatedSyntaxList<TNode> newList, Func<SyntaxKind, bool> ignoreChildNode = null) where TNode : SyntaxNode
		{
			return SyntaxEquivalence.AreEquivalent(oldList.Node, newList.Node, ignoreChildNode, topLevel: false);
		}

		private static bool IsPartOfLinqQueryNotFollowedByNewLine(SyntaxToken token, SyntaxNode statementNode, SyntaxToken endOfFileToken)
		{
			SyntaxTriviaList.Enumerator enumerator = endOfFileToken.LeadingTrivia.GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(enumerator.Current, SyntaxKind.EndOfLineTrivia))
				{
					return false;
				}
			}
			SyntaxNode parent = token.Parent;
			while (true)
			{
				if (Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(parent, SyntaxKind.QueryExpression))
				{
					return true;
				}
				if (parent == statementNode)
				{
					break;
				}
				parent = parent.Parent;
			}
			return false;
		}

		internal static bool IsCompleteSubmission(SyntaxTree tree)
		{
			if (tree == null)
			{
				throw new ArgumentNullException("tree");
			}
			VisualBasicParseOptions obj = (VisualBasicParseOptions)tree.Options;
			if (obj.Kind == SourceCodeKind.Regular)
			{
				throw new ArgumentException(VBResources.SyntaxTreeIsNotASubmission);
			}
			LanguageVersion languageVersion = obj.LanguageVersion;
			if (!tree.HasCompilationUnitRoot)
			{
				return false;
			}
			Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax compilationUnitSyntax = (Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax)tree.GetRoot();
			using (IEnumerator<Diagnostic> enumerator = compilationUnitSyntax.GetDiagnostics().GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					switch (enumerator.Current.Code)
					{
					case 30012:
					case 30681:
						return false;
					case 30205:
						return true;
					}
				}
			}
			SyntaxNode syntaxNode = compilationUnitSyntax.ChildNodes().LastOrDefault();
			if (syntaxNode == null)
			{
				return true;
			}
			SyntaxToken lastToken = syntaxNode.GetLastToken(includeZeroWidth: true, includeSkipped: true);
			if (IsPartOfLinqQueryNotFollowedByNewLine(lastToken, syntaxNode, compilationUnitSyntax.EndOfFileToken) || (lastToken.HasTrailingTrivia && Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(lastToken.TrailingTrivia.Last(), SyntaxKind.LineContinuationTrivia)))
			{
				return false;
			}
			if (!compilationUnitSyntax.HasErrors)
			{
				return true;
			}
			if (Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(syntaxNode, SyntaxKind.IncompleteMember) || lastToken.IsMissing)
			{
				return false;
			}
			foreach (Diagnostic diagnostic in lastToken.GetDiagnostics())
			{
				ERRID code = (ERRID)diagnostic.Code;
				if (code == ERRID.ERR_UnterminatedStringLiteral && Parser.CheckFeatureAvailability(languageVersion, Feature.MultilineStringLiterals))
				{
					return false;
				}
			}
			return true;
		}

		public static SyntaxTree SyntaxTree(SyntaxNode root, ParseOptions options = null, string path = "", Encoding encoding = null)
		{
			return VisualBasicSyntaxTree.Create((VisualBasicSyntaxNode)root, (VisualBasicParseOptions)options, path, encoding);
		}

		public static SyntaxTree ParseSyntaxTree(string text, ParseOptions options, string path, Encoding encoding, CancellationToken cancellationToken)
		{
			return ParseSyntaxTree(SourceText.From(text, encoding), options, path, cancellationToken);
		}

		public static SyntaxTree ParseSyntaxTree(SourceText text, ParseOptions options, string path, CancellationToken cancellationToken)
		{
			return VisualBasicSyntaxTree.ParseText(text, (VisualBasicParseOptions)options, path, cancellationToken);
		}

		public static SyntaxTree ParseSyntaxTree(string text, ParseOptions options = null, string path = "", Encoding encoding = null, ImmutableDictionary<string, ReportDiagnostic> diagnosticOptions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return ParseSyntaxTree(SourceText.From(text, encoding), options, path, diagnosticOptions, cancellationToken);
		}

		public static SyntaxTree ParseSyntaxTree(SourceText text, ParseOptions options = null, string path = "", ImmutableDictionary<string, ReportDiagnostic> diagnosticOptions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return VisualBasicSyntaxTree.ParseText(text, (VisualBasicParseOptions)options, path, diagnosticOptions, cancellationToken);
		}

		public static SyntaxTriviaList ParseLeadingTrivia(string text, int offset = 0)
		{
			Scanner scanner = new Scanner(MakeSourceText(text, offset), VisualBasicParseOptions.Default);
			using (scanner)
			{
				SyntaxToken token = default(SyntaxToken);
				return new SyntaxTriviaList(in token, scanner.ScanMultilineTrivia().Node, 0);
			}
		}

		public static SyntaxTriviaList ParseTrailingTrivia(string text, int offset = 0)
		{
			Scanner scanner = new Scanner(MakeSourceText(text, offset), VisualBasicParseOptions.Default);
			using (scanner)
			{
				SyntaxToken token = default(SyntaxToken);
				return new SyntaxTriviaList(in token, scanner.ScanSingleLineTrivia().Node, 0);
			}
		}

		public static SyntaxToken ParseToken(string text, int offset = 0, bool startStatement = false)
		{
			Scanner scanner = new Scanner(MakeSourceText(text, offset), VisualBasicParseOptions.Default);
			using (scanner)
			{
				ScannerState state = (startStatement ? ScannerState.VBAllowLeadingMultilineTrivia : ScannerState.VB);
				scanner.GetNextTokenInState(state);
				return new SyntaxToken(null, scanner.GetCurrentToken(), 0, 0);
			}
		}

		[IteratorStateMachine(typeof(VB_0024StateMachine_1130_ParseTokens))]
		public static IEnumerable<SyntaxToken> ParseTokens(string text, int offset = 0, int initialTokenPosition = 0, VisualBasicParseOptions options = null)
		{
			//yield-return decompiler failed: Method not found
			return new VB_0024StateMachine_1130_ParseTokens(-2)
			{
				_0024P_text = text,
				_0024P_offset = offset,
				_0024P_initialTokenPosition = initialTokenPosition,
				_0024P_options = options
			};
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax ParseName(string text, int offset = 0, bool consumeFullText = true)
		{
			using Parser parser = new Parser(MakeSourceText(text, offset), VisualBasicParseOptions.Default);
			parser.GetNextToken();
			bool allowedEmptyGenericArguments = true;
			Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NameSyntax nameSyntax = parser.ParseName(requireQualification: false, allowGlobalNameSpace: true, allowGenericArguments: true, allowGenericsWithoutOf: false, nonArrayName: false, disallowGenericArgumentsOnLastQualifiedName: false, allowEmptyGenericArguments: true, ref allowedEmptyGenericArguments);
			return (Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax)(consumeFullText ? parser.ConsumeUnexpectedTokens(nameSyntax) : nameSyntax).CreateRed(null, 0);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax ParseTypeName(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)
		{
			using Parser parser = new Parser(MakeSourceText(text, offset), ((VisualBasicParseOptions)options) ?? VisualBasicParseOptions.Default);
			parser.GetNextToken();
			Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax typeSyntax = parser.ParseGeneralType();
			return (Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax)(consumeFullText ? parser.ConsumeUnexpectedTokens(typeSyntax) : typeSyntax).CreateRed(null, 0);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax ParseTypeName(string text, int offset, bool consumeFullText)
		{
			return ParseTypeName(text, offset, null, consumeFullText);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax ParseExpression(string text, int offset = 0, bool consumeFullText = true)
		{
			using Parser parser = new Parser(MakeSourceText(text, offset), VisualBasicParseOptions.Default);
			parser.GetNextToken();
			Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax expressionSyntax = parser.ParseExpression();
			return (Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)(consumeFullText ? parser.ConsumeUnexpectedTokens(expressionSyntax) : expressionSyntax).CreateRed(null, 0);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax ParseExecutableStatement(string text, int offset = 0, bool consumeFullText = true)
		{
			using Parser parser = new Parser(MakeSourceText(text, offset), VisualBasicParseOptions.Default);
			Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StatementSyntax statementSyntax = parser.ParseExecutableStatement();
			return (Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)(consumeFullText ? parser.ConsumeUnexpectedTokens(statementSyntax) : statementSyntax).CreateRed(null, 0);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax ParseCompilationUnit(string text, int offset = 0, VisualBasicParseOptions options = null)
		{
			using Parser parser = new Parser(MakeSourceText(text, offset), options ?? VisualBasicParseOptions.Default);
			return (Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax)parser.ParseCompilationUnit().CreateRed(null, 0);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax ParseParameterList(string text, int offset = 0, bool consumeFullText = true)
		{
			using Parser parser = new Parser(MakeSourceText(text, offset), VisualBasicParseOptions.Default);
			parser.GetNextToken();
			Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax parameterListSyntax = parser.ParseParameterList();
			return (Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)(consumeFullText ? parser.ConsumeUnexpectedTokens(parameterListSyntax) : parameterListSyntax).CreateRed(null, 0);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax ParseArgumentList(string text, int offset = 0, bool consumeFullText = true)
		{
			using Parser parser = new Parser(MakeSourceText(text, offset), VisualBasicParseOptions.Default);
			parser.GetNextToken();
			Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentListSyntax argumentListSyntax = parser.ParseParenthesizedArguments();
			return (Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax)(consumeFullText ? parser.ConsumeUnexpectedTokens(argumentListSyntax) : argumentListSyntax).CreateRed(null, 0);
		}

		internal static SourceText MakeSourceText(string text, int offset)
		{
			return SourceText.From(text, Encoding.UTF8).GetSubText(offset);
		}

		internal static Microsoft.CodeAnalysis.VisualBasic.Syntax.BaseXmlAttributeSyntax ParseDocCommentAttributeAsStandAloneEntity(string text, string parentElementName)
		{
			using Scanner scanner = new Scanner(MakeSourceText(text, 0), VisualBasicParseOptions.Default);
			scanner.ForceScanningXmlDocMode();
			Parser parser = new Parser(scanner);
			parser.GetNextToken(ScannerState.Element);
			Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameSyntax xmlElementName = Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlName(null, Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.XmlNameToken(parentElementName, SyntaxKind.XmlNameToken, null, null));
			return (Microsoft.CodeAnalysis.VisualBasic.Syntax.BaseXmlAttributeSyntax)parser.ParseXmlAttribute(requireLeadingWhitespace: false, AllowNameAsExpression: false, xmlElementName).CreateRed(null, 0);
		}

		public static SyntaxToken IntegerLiteralToken(string text, LiteralBase @base, TypeCharacter typeSuffix, ulong value)
		{
			return IntegerLiteralToken(TriviaList(ElasticMarker), text, @base, typeSuffix, value, TriviaList(ElasticMarker));
		}

		public static SyntaxToken IntegerLiteralToken(SyntaxTriviaList leadingTrivia, string text, LiteralBase @base, TypeCharacter typeSuffix, ulong value, SyntaxTriviaList trailingTrivia)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			return new SyntaxToken(null, Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.IntegerLiteralToken(text, @base, typeSuffix, value, leadingTrivia.Node, trailingTrivia.Node), 0, 0);
		}

		public static SyntaxToken FloatingLiteralToken(string text, TypeCharacter typeSuffix, double value)
		{
			return FloatingLiteralToken(TriviaList(ElasticMarker), text, typeSuffix, value, TriviaList(ElasticMarker));
		}

		public static SyntaxToken FloatingLiteralToken(SyntaxTriviaList leadingTrivia, string text, TypeCharacter typeSuffix, double value, SyntaxTriviaList trailingTrivia)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			return new SyntaxToken(null, Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory.FloatingLiteralToken(text, typeSuffix, value, leadingTrivia.Node, trailingTrivia.Node), 0, 0);
		}

		public static SyntaxToken Identifier(string text, bool isBracketed, string identifierText, TypeCharacter typeCharacter)
		{
			return Identifier(TriviaList(ElasticMarker), text, isBracketed, identifierText, typeCharacter, TriviaList(ElasticMarker));
		}

		internal static SyntaxToken Identifier(SyntaxTrivia leadingTrivia, string text, bool isBracketed, string identifierText, TypeCharacter typeCharacter, SyntaxTrivia trailingTrivia)
		{
			return Identifier(SyntaxTriviaList.Create(leadingTrivia), text, isBracketed, identifierText, typeCharacter, SyntaxTriviaList.Create(trailingTrivia));
		}

		public static SyntaxToken Identifier(SyntaxTriviaList leadingTrivia, string text, bool isBracketed, string identifierText, TypeCharacter typeCharacter, SyntaxTriviaList trailingTrivia)
		{
			if (text == null)
			{
				throw new ArgumentException("text");
			}
			return new SyntaxToken(null, new ComplexIdentifierSyntax(SyntaxKind.IdentifierToken, null, null, text, leadingTrivia.Node, trailingTrivia.Node, SyntaxKind.IdentifierToken, isBracketed, identifierText, typeCharacter), 0, 0);
		}

		public static SyntaxToken Identifier(string text)
		{
			return Identifier(TriviaList(ElasticMarker), text, TriviaList(ElasticMarker));
		}

		internal static SyntaxToken Identifier(SyntaxTrivia leadingTrivia, string text, SyntaxTrivia trailingTrivia)
		{
			return Identifier(SyntaxTriviaList.Create(leadingTrivia), text, SyntaxTriviaList.Create(trailingTrivia));
		}

		public static SyntaxToken Identifier(SyntaxTriviaList leadingTrivia, string text, SyntaxTriviaList trailingTrivia)
		{
			if (text == null)
			{
				throw new ArgumentException("text");
			}
			return new SyntaxToken(null, new ComplexIdentifierSyntax(SyntaxKind.IdentifierToken, null, null, text, leadingTrivia.Node, trailingTrivia.Node, SyntaxKind.IdentifierToken, isBracketed: false, text, TypeCharacter.None), 0, 0);
		}

		public static SyntaxToken BracketedIdentifier(string text)
		{
			return BracketedIdentifier(TriviaList(ElasticMarker), text, TriviaList(ElasticMarker));
		}

		public static SyntaxToken BracketedIdentifier(SyntaxTriviaList leadingTrivia, string text, SyntaxTriviaList trailingTrivia)
		{
			if (text == null)
			{
				throw new ArgumentException("text");
			}
			if (EmbeddedOperators.CompareString(SyntaxFacts.MakeHalfWidthIdentifier(Microsoft.VisualBasic.CompilerServices.Conversions.ToString(text.First())), "[", TextCompare: false) == 0 && EmbeddedOperators.CompareString(SyntaxFacts.MakeHalfWidthIdentifier(Microsoft.VisualBasic.CompilerServices.Conversions.ToString(text.Last())), "]", TextCompare: false) == 0)
			{
				throw new ArgumentException("text");
			}
			return new SyntaxToken(null, new ComplexIdentifierSyntax(SyntaxKind.IdentifierToken, null, null, "[" + text + "]", leadingTrivia.Node, trailingTrivia.Node, SyntaxKind.IdentifierToken, isBracketed: true, text, TypeCharacter.None), 0, 0);
		}

		internal static SyntaxToken MissingIdentifier()
		{
			return new SyntaxToken(null, new SimpleIdentifierSyntax(SyntaxKind.IdentifierToken, null, null, "", ElasticMarker.UnderlyingNode, ElasticMarker.UnderlyingNode), 0, 0);
		}

		internal static SyntaxToken MissingIdentifier(SyntaxKind kind)
		{
			return new SyntaxToken(null, new ComplexIdentifierSyntax(SyntaxKind.IdentifierToken, null, null, "", ElasticMarker.UnderlyingNode, ElasticMarker.UnderlyingNode, kind, isBracketed: false, "", TypeCharacter.None), 0, 0);
		}

		internal static SyntaxToken MissingKeyword(SyntaxKind kind)
		{
			return new SyntaxToken(null, new KeywordSyntax(kind, "", ElasticMarker.UnderlyingNode, ElasticMarker.UnderlyingNode), 0, 0);
		}

		internal static SyntaxToken MissingPunctuation(SyntaxKind kind)
		{
			return new SyntaxToken(null, new PunctuationSyntax(kind, "", ElasticMarker.UnderlyingNode, ElasticMarker.UnderlyingNode), 0, 0);
		}

		internal static SyntaxToken MissingStringLiteral()
		{
			return StringLiteralToken("", "");
		}

		internal static SyntaxToken MissingCharacterLiteralToken()
		{
			return CharacterLiteralToken("", '\0');
		}

		internal static SyntaxToken MissingIntegerLiteralToken()
		{
			return IntegerLiteralToken(TriviaList(ElasticMarker), "", LiteralBase.Decimal, TypeCharacter.None, 0uL, TriviaList(ElasticMarker));
		}

		internal static SyntaxToken MissingToken(SyntaxKind kind)
		{
			SyntaxToken result;
			switch (kind)
			{
			case SyntaxKind.StatementTerminatorToken:
				result = Token(SyntaxKind.StatementTerminatorToken);
				break;
			case SyntaxKind.EndOfFileToken:
				result = Token(SyntaxKind.EndOfFileToken);
				break;
			case SyntaxKind.AddHandlerKeyword:
			case SyntaxKind.AddressOfKeyword:
			case SyntaxKind.AliasKeyword:
			case SyntaxKind.AndKeyword:
			case SyntaxKind.AndAlsoKeyword:
			case SyntaxKind.AsKeyword:
			case SyntaxKind.BooleanKeyword:
			case SyntaxKind.ByRefKeyword:
			case SyntaxKind.ByteKeyword:
			case SyntaxKind.ByValKeyword:
			case SyntaxKind.CallKeyword:
			case SyntaxKind.CaseKeyword:
			case SyntaxKind.CatchKeyword:
			case SyntaxKind.CBoolKeyword:
			case SyntaxKind.CByteKeyword:
			case SyntaxKind.CCharKeyword:
			case SyntaxKind.CDateKeyword:
			case SyntaxKind.CDecKeyword:
			case SyntaxKind.CDblKeyword:
			case SyntaxKind.CharKeyword:
			case SyntaxKind.CIntKeyword:
			case SyntaxKind.ClassKeyword:
			case SyntaxKind.CLngKeyword:
			case SyntaxKind.CObjKeyword:
			case SyntaxKind.ConstKeyword:
			case SyntaxKind.ReferenceKeyword:
			case SyntaxKind.ContinueKeyword:
			case SyntaxKind.CSByteKeyword:
			case SyntaxKind.CShortKeyword:
			case SyntaxKind.CSngKeyword:
			case SyntaxKind.CStrKeyword:
			case SyntaxKind.CTypeKeyword:
			case SyntaxKind.CUIntKeyword:
			case SyntaxKind.CULngKeyword:
			case SyntaxKind.CUShortKeyword:
			case SyntaxKind.DateKeyword:
			case SyntaxKind.DecimalKeyword:
			case SyntaxKind.DeclareKeyword:
			case SyntaxKind.DefaultKeyword:
			case SyntaxKind.DelegateKeyword:
			case SyntaxKind.DimKeyword:
			case SyntaxKind.DirectCastKeyword:
			case SyntaxKind.DoKeyword:
			case SyntaxKind.DoubleKeyword:
			case SyntaxKind.EachKeyword:
			case SyntaxKind.ElseKeyword:
			case SyntaxKind.ElseIfKeyword:
			case SyntaxKind.EndKeyword:
			case SyntaxKind.EnumKeyword:
			case SyntaxKind.EraseKeyword:
			case SyntaxKind.ErrorKeyword:
			case SyntaxKind.EventKeyword:
			case SyntaxKind.ExitKeyword:
			case SyntaxKind.FalseKeyword:
			case SyntaxKind.FinallyKeyword:
			case SyntaxKind.ForKeyword:
			case SyntaxKind.FriendKeyword:
			case SyntaxKind.FunctionKeyword:
			case SyntaxKind.GetKeyword:
			case SyntaxKind.GetTypeKeyword:
			case SyntaxKind.GetXmlNamespaceKeyword:
			case SyntaxKind.GlobalKeyword:
			case SyntaxKind.GoToKeyword:
			case SyntaxKind.HandlesKeyword:
			case SyntaxKind.IfKeyword:
			case SyntaxKind.ImplementsKeyword:
			case SyntaxKind.ImportsKeyword:
			case SyntaxKind.InKeyword:
			case SyntaxKind.InheritsKeyword:
			case SyntaxKind.IntegerKeyword:
			case SyntaxKind.InterfaceKeyword:
			case SyntaxKind.IsKeyword:
			case SyntaxKind.IsNotKeyword:
			case SyntaxKind.LetKeyword:
			case SyntaxKind.LibKeyword:
			case SyntaxKind.LikeKeyword:
			case SyntaxKind.LongKeyword:
			case SyntaxKind.LoopKeyword:
			case SyntaxKind.MeKeyword:
			case SyntaxKind.ModKeyword:
			case SyntaxKind.ModuleKeyword:
			case SyntaxKind.MustInheritKeyword:
			case SyntaxKind.MustOverrideKeyword:
			case SyntaxKind.MyBaseKeyword:
			case SyntaxKind.MyClassKeyword:
			case SyntaxKind.NamespaceKeyword:
			case SyntaxKind.NarrowingKeyword:
			case SyntaxKind.NextKeyword:
			case SyntaxKind.NewKeyword:
			case SyntaxKind.NotKeyword:
			case SyntaxKind.NothingKeyword:
			case SyntaxKind.NotInheritableKeyword:
			case SyntaxKind.NotOverridableKeyword:
			case SyntaxKind.ObjectKeyword:
			case SyntaxKind.OfKeyword:
			case SyntaxKind.OnKeyword:
			case SyntaxKind.OperatorKeyword:
			case SyntaxKind.OptionKeyword:
			case SyntaxKind.OptionalKeyword:
			case SyntaxKind.OrKeyword:
			case SyntaxKind.OrElseKeyword:
			case SyntaxKind.OverloadsKeyword:
			case SyntaxKind.OverridableKeyword:
			case SyntaxKind.OverridesKeyword:
			case SyntaxKind.ParamArrayKeyword:
			case SyntaxKind.PartialKeyword:
			case SyntaxKind.PrivateKeyword:
			case SyntaxKind.PropertyKeyword:
			case SyntaxKind.ProtectedKeyword:
			case SyntaxKind.PublicKeyword:
			case SyntaxKind.RaiseEventKeyword:
			case SyntaxKind.ReadOnlyKeyword:
			case SyntaxKind.ReDimKeyword:
			case SyntaxKind.REMKeyword:
			case SyntaxKind.RemoveHandlerKeyword:
			case SyntaxKind.ResumeKeyword:
			case SyntaxKind.ReturnKeyword:
			case SyntaxKind.SByteKeyword:
			case SyntaxKind.SelectKeyword:
			case SyntaxKind.SetKeyword:
			case SyntaxKind.ShadowsKeyword:
			case SyntaxKind.SharedKeyword:
			case SyntaxKind.ShortKeyword:
			case SyntaxKind.SingleKeyword:
			case SyntaxKind.StaticKeyword:
			case SyntaxKind.StepKeyword:
			case SyntaxKind.StopKeyword:
			case SyntaxKind.StringKeyword:
			case SyntaxKind.StructureKeyword:
			case SyntaxKind.SubKeyword:
			case SyntaxKind.SyncLockKeyword:
			case SyntaxKind.ThenKeyword:
			case SyntaxKind.ThrowKeyword:
			case SyntaxKind.ToKeyword:
			case SyntaxKind.TrueKeyword:
			case SyntaxKind.TryKeyword:
			case SyntaxKind.TryCastKeyword:
			case SyntaxKind.TypeOfKeyword:
			case SyntaxKind.UIntegerKeyword:
			case SyntaxKind.ULongKeyword:
			case SyntaxKind.UShortKeyword:
			case SyntaxKind.UsingKeyword:
			case SyntaxKind.WhenKeyword:
			case SyntaxKind.WhileKeyword:
			case SyntaxKind.WideningKeyword:
			case SyntaxKind.WithKeyword:
			case SyntaxKind.WithEventsKeyword:
			case SyntaxKind.WriteOnlyKeyword:
			case SyntaxKind.XorKeyword:
			case SyntaxKind.EndIfKeyword:
			case SyntaxKind.GosubKeyword:
			case SyntaxKind.VariantKeyword:
			case SyntaxKind.WendKeyword:
			case SyntaxKind.OutKeyword:
			case SyntaxKind.NameOfKeyword:
				result = MissingKeyword(kind);
				break;
			case SyntaxKind.AggregateKeyword:
			case SyntaxKind.AllKeyword:
			case SyntaxKind.AnsiKeyword:
			case SyntaxKind.AscendingKeyword:
			case SyntaxKind.AssemblyKeyword:
			case SyntaxKind.AutoKeyword:
			case SyntaxKind.BinaryKeyword:
			case SyntaxKind.ByKeyword:
			case SyntaxKind.CompareKeyword:
			case SyntaxKind.CustomKeyword:
			case SyntaxKind.DescendingKeyword:
			case SyntaxKind.DisableKeyword:
			case SyntaxKind.DistinctKeyword:
			case SyntaxKind.EnableKeyword:
			case SyntaxKind.EqualsKeyword:
			case SyntaxKind.ExplicitKeyword:
			case SyntaxKind.ExternalSourceKeyword:
			case SyntaxKind.ExternalChecksumKeyword:
			case SyntaxKind.FromKeyword:
			case SyntaxKind.GroupKeyword:
			case SyntaxKind.InferKeyword:
			case SyntaxKind.IntoKeyword:
			case SyntaxKind.IsFalseKeyword:
			case SyntaxKind.IsTrueKeyword:
			case SyntaxKind.JoinKeyword:
			case SyntaxKind.KeyKeyword:
			case SyntaxKind.MidKeyword:
			case SyntaxKind.OffKeyword:
			case SyntaxKind.OrderKeyword:
			case SyntaxKind.PreserveKeyword:
			case SyntaxKind.RegionKeyword:
			case SyntaxKind.SkipKeyword:
			case SyntaxKind.StrictKeyword:
			case SyntaxKind.TakeKeyword:
			case SyntaxKind.TextKeyword:
			case SyntaxKind.UnicodeKeyword:
			case SyntaxKind.UntilKeyword:
			case SyntaxKind.WarningKeyword:
			case SyntaxKind.WhereKeyword:
				return MissingIdentifier(kind);
			case SyntaxKind.ExclamationToken:
			case SyntaxKind.CommaToken:
			case SyntaxKind.HashToken:
			case SyntaxKind.AmpersandToken:
			case SyntaxKind.SingleQuoteToken:
			case SyntaxKind.OpenParenToken:
			case SyntaxKind.CloseParenToken:
			case SyntaxKind.OpenBraceToken:
			case SyntaxKind.CloseBraceToken:
			case SyntaxKind.SemicolonToken:
			case SyntaxKind.AsteriskToken:
			case SyntaxKind.PlusToken:
			case SyntaxKind.MinusToken:
			case SyntaxKind.DotToken:
			case SyntaxKind.SlashToken:
			case SyntaxKind.ColonToken:
			case SyntaxKind.LessThanToken:
			case SyntaxKind.LessThanEqualsToken:
			case SyntaxKind.LessThanGreaterThanToken:
			case SyntaxKind.EqualsToken:
			case SyntaxKind.GreaterThanToken:
			case SyntaxKind.GreaterThanEqualsToken:
			case SyntaxKind.BackslashToken:
			case SyntaxKind.CaretToken:
			case SyntaxKind.ColonEqualsToken:
			case SyntaxKind.AmpersandEqualsToken:
			case SyntaxKind.AsteriskEqualsToken:
			case SyntaxKind.PlusEqualsToken:
			case SyntaxKind.MinusEqualsToken:
			case SyntaxKind.SlashEqualsToken:
			case SyntaxKind.BackslashEqualsToken:
			case SyntaxKind.CaretEqualsToken:
			case SyntaxKind.LessThanLessThanToken:
			case SyntaxKind.GreaterThanGreaterThanToken:
			case SyntaxKind.LessThanLessThanEqualsToken:
			case SyntaxKind.GreaterThanGreaterThanEqualsToken:
			case SyntaxKind.QuestionToken:
			case SyntaxKind.DoubleQuoteToken:
				result = MissingPunctuation(kind);
				break;
			case SyntaxKind.FloatingLiteralToken:
				result = FloatingLiteralToken("", TypeCharacter.None, 0.0);
				break;
			case SyntaxKind.DecimalLiteralToken:
				result = DecimalLiteralToken("", TypeCharacter.None, 0m);
				break;
			case SyntaxKind.DateLiteralToken:
				result = DateLiteralToken("", DateTime.MinValue);
				break;
			case SyntaxKind.XmlNameToken:
				result = XmlNameToken("", SyntaxKind.XmlNameToken);
				break;
			case SyntaxKind.XmlTextLiteralToken:
				result = XmlTextLiteralToken("", "");
				break;
			case SyntaxKind.SlashGreaterThanToken:
			case SyntaxKind.LessThanSlashToken:
			case SyntaxKind.LessThanExclamationMinusMinusToken:
			case SyntaxKind.MinusMinusGreaterThanToken:
			case SyntaxKind.LessThanQuestionToken:
			case SyntaxKind.QuestionGreaterThanToken:
			case SyntaxKind.LessThanPercentEqualsToken:
			case SyntaxKind.PercentGreaterThanToken:
			case SyntaxKind.BeginCDataToken:
			case SyntaxKind.EndCDataToken:
				result = MissingPunctuation(kind);
				break;
			case SyntaxKind.IdentifierToken:
				result = MissingIdentifier();
				break;
			case SyntaxKind.IntegerLiteralToken:
				result = MissingIntegerLiteralToken();
				break;
			case SyntaxKind.StringLiteralToken:
				result = MissingStringLiteral();
				break;
			case SyntaxKind.CharacterLiteralToken:
				result = MissingCharacterLiteralToken();
				break;
			default:
				throw ExceptionUtilities.UnexpectedValue(kind);
			}
			return result;
		}

		public static SyntaxToken BadToken(string text)
		{
			return BadToken(default(SyntaxTriviaList), text, default(SyntaxTriviaList));
		}

		public static SyntaxToken BadToken(SyntaxTriviaList leadingTrivia, string text, SyntaxTriviaList trailingTrivia)
		{
			if (text == null)
			{
				throw new ArgumentException("text");
			}
			return new SyntaxToken(null, new BadTokenSyntax(SyntaxKind.BadToken, SyntaxSubKind.None, null, null, text, leadingTrivia.Node, trailingTrivia.Node), 0, 0);
		}

		public static SyntaxTrivia Trivia(Microsoft.CodeAnalysis.VisualBasic.Syntax.StructuredTriviaSyntax node)
		{
			SyntaxToken token = default(SyntaxToken);
			return new SyntaxTrivia(in token, node.Green, 0, 0);
		}

		public static SyntaxList<TNode> List<TNode>() where TNode : SyntaxNode
		{
			return default(SyntaxList<TNode>);
		}

		public static SyntaxList<TNode> SingletonList<TNode>(TNode node) where TNode : SyntaxNode
		{
			return new SyntaxList<TNode>(node);
		}

		public static SyntaxList<TNode> List<TNode>(IEnumerable<TNode> nodes) where TNode : SyntaxNode
		{
			return new SyntaxList<TNode>(nodes);
		}

		public static SyntaxTokenList TokenList()
		{
			return default(SyntaxTokenList);
		}

		public static SyntaxTokenList TokenList(SyntaxToken token)
		{
			return new SyntaxTokenList(token);
		}

		public static SyntaxTokenList TokenList(params SyntaxToken[] tokens)
		{
			return new SyntaxTokenList(tokens);
		}

		public static SyntaxTokenList TokenList(IEnumerable<SyntaxToken> tokens)
		{
			return new SyntaxTokenList(tokens);
		}

		public static SyntaxTriviaList TriviaList()
		{
			return default(SyntaxTriviaList);
		}

		public static SyntaxTriviaList TriviaList(SyntaxTrivia trivia)
		{
			SyntaxToken token = default(SyntaxToken);
			return new SyntaxTriviaList(in token, trivia.UnderlyingNode);
		}

		public static SyntaxTriviaList TriviaList(params SyntaxTrivia[] trivias)
		{
			return new SyntaxTriviaList(trivias);
		}

		public static SyntaxTriviaList TriviaList(IEnumerable<SyntaxTrivia> trivias)
		{
			return new SyntaxTriviaList(trivias);
		}

		public static SeparatedSyntaxList<TNode> SeparatedList<TNode>() where TNode : SyntaxNode
		{
			return default(SeparatedSyntaxList<TNode>);
		}

		public static SeparatedSyntaxList<TNode> SingletonSeparatedList<TNode>(TNode node) where TNode : SyntaxNode
		{
			return new SeparatedSyntaxList<TNode>(node, 0);
		}

		public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<TNode> nodes) where TNode : SyntaxNode
		{
			SeparatedSyntaxList<TNode> result;
			if (nodes == null)
			{
				result = default(SeparatedSyntaxList<TNode>);
			}
			else
			{
				ICollection<TNode> collection = nodes as ICollection<TNode>;
				if (collection == null || collection.Count != 0)
				{
					using (IEnumerator<TNode> enumerator = nodes.GetEnumerator())
					{
						if (!enumerator.MoveNext())
						{
							return default(SeparatedSyntaxList<TNode>);
						}
						TNode current = enumerator.Current;
						if (!enumerator.MoveNext())
						{
							return SingletonSeparatedList(current);
						}
						SeparatedSyntaxListBuilder<TNode> separatedSyntaxListBuilder = new SeparatedSyntaxListBuilder<TNode>((collection != null) ? (collection.Count * 2 - 1) : 3);
						separatedSyntaxListBuilder.Add(current);
						SyntaxToken separatorToken = Token(SyntaxKind.CommaToken);
						do
						{
							separatedSyntaxListBuilder.AddSeparator(in separatorToken);
							separatedSyntaxListBuilder.Add(enumerator.Current);
						}
						while (enumerator.MoveNext());
						return separatedSyntaxListBuilder.ToList();
					}
				}
				result = default(SeparatedSyntaxList<TNode>);
			}
			return result;
		}

		public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<TNode> nodes, IEnumerable<SyntaxToken> separators) where TNode : SyntaxNode
		{
			if (nodes != null)
			{
				IEnumerator<TNode> enumerator = nodes.GetEnumerator();
				SeparatedSyntaxListBuilder<TNode> separatedSyntaxListBuilder = SeparatedSyntaxListBuilder<TNode>.Create();
				if (separators != null)
				{
					foreach (SyntaxToken separator in separators)
					{
						SyntaxToken separatorToken = separator;
						if (enumerator.MoveNext())
						{
							separatedSyntaxListBuilder.Add(enumerator.Current);
							separatedSyntaxListBuilder.AddSeparator(in separatorToken);
							continue;
						}
						throw new ArgumentException();
					}
				}
				if (enumerator.MoveNext())
				{
					separatedSyntaxListBuilder.Add(enumerator.Current);
					if (enumerator.MoveNext())
					{
						throw new ArgumentException();
					}
				}
				return separatedSyntaxListBuilder.ToList();
			}
			if (separators == null)
			{
				return default(SeparatedSyntaxList<TNode>);
			}
			throw new ArgumentException();
		}

		public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<SyntaxNodeOrToken> nodesAndTokens) where TNode : SyntaxNode
		{
			return SeparatedList<TNode>(NodeOrTokenList(nodesAndTokens));
		}

		public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(SyntaxNodeOrTokenList nodesAndTokens) where TNode : SyntaxNode
		{
			if (!HasSeparatedNodeTokenPattern(nodesAndTokens))
			{
				throw new ArgumentException(CodeAnalysisResources.NodeOrTokenOutOfSequence);
			}
			if (!NodesAreCorrectType<TNode>(nodesAndTokens))
			{
				throw new ArgumentException(CodeAnalysisResources.UnexpectedTypeOfNodeInList);
			}
			return new SeparatedSyntaxList<TNode>(nodesAndTokens);
		}

		private static bool NodesAreCorrectType<TNode>(SyntaxNodeOrTokenList list)
		{
			int num = list.Count - 1;
			for (int i = 0; i <= num; i++)
			{
				SyntaxNodeOrToken syntaxNodeOrToken = list[i];
				if (syntaxNodeOrToken.IsNode && !(syntaxNodeOrToken.AsNode() is TNode))
				{
					return false;
				}
			}
			return true;
		}

		private static bool HasSeparatedNodeTokenPattern(SyntaxNodeOrTokenList list)
		{
			int num = list.Count - 1;
			for (int i = 0; i <= num; i++)
			{
				if (list[i].IsToken == ((i & 1) == 0))
				{
					return false;
				}
			}
			return true;
		}

		public static SyntaxNodeOrTokenList NodeOrTokenList()
		{
			return default(SyntaxNodeOrTokenList);
		}

		public static SyntaxNodeOrTokenList NodeOrTokenList(IEnumerable<SyntaxNodeOrToken> nodesAndTokens)
		{
			return new SyntaxNodeOrTokenList(nodesAndTokens);
		}

		public static SyntaxNodeOrTokenList NodeOrTokenList(params SyntaxNodeOrToken[] nodesAndTokens)
		{
			return new SyntaxNodeOrTokenList(nodesAndTokens);
		}

		public static Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax InvocationExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression)
		{
			return InvocationExpression(expression, null);
		}
	}
}
