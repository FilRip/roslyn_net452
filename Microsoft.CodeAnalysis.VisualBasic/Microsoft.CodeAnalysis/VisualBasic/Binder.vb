Imports Microsoft.CodeAnalysis
Imports Microsoft.CodeAnalysis.PooledObjects
Imports Microsoft.CodeAnalysis.RuntimeMembers
Imports Microsoft.CodeAnalysis.Text
Imports Microsoft.CodeAnalysis.VisualBasic.Emit.NoPia
Imports Microsoft.CodeAnalysis.VisualBasic.Symbols
Imports Microsoft.CodeAnalysis.VisualBasic.Syntax
Imports Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax
Imports Microsoft.VisualBasic
Imports Microsoft.VisualBasic.CompilerServices
Imports Roslyn.Utilities
Imports System
Imports System.Collections
Imports System.Collections.Concurrent
Imports System.Collections.Generic
Imports System.Collections.Immutable
Imports System.Diagnostics
Imports System.Linq
Imports System.Runtime.CompilerServices
Imports System.Runtime.InteropServices
Imports System.Text
Imports System.Threading

Namespace Microsoft.CodeAnalysis.VisualBasic
	Friend MustInherit Class Binder
		Private ReadOnly Shared s_noArguments As ImmutableArray(Of BoundExpression)

		Protected ReadOnly m_containingBinder As Binder

		Private ReadOnly _syntaxTree As Microsoft.CodeAnalysis.SyntaxTree

		Private ReadOnly _compilation As VisualBasicCompilation

		Private ReadOnly _sourceModule As SourceModuleSymbol

		Private ReadOnly _isEarlyAttributeBinder As Boolean

		Private ReadOnly _ignoreBaseClassesInLookup As Boolean

		Private ReadOnly _basesBeingResolved As BasesBeingResolved

		Private ReadOnly Shared s_checkDelegateParameterModifierCallback As Binder.CheckParameterModifierDelegate

		Public Const ArrayRankLimit As Integer = 32

		Private ReadOnly Shared s_isFunctionWithoutArguments As Func(Of Symbol, Boolean)

		Private ReadOnly Shared s_isReadablePropertyWithoutArguments As Func(Of Symbol, Boolean)

		Private ReadOnly Shared s_friendKeyword As SyntaxKind()

		Private ReadOnly Shared s_checkOperatorParameterModifierCallback As Binder.CheckParameterModifierDelegate

		Private ReadOnly Shared s_checkPropertyParameterModifierCallback As Binder.CheckParameterModifierDelegate

		Private ReadOnly Shared s_notInheritableKeyword As SyntaxKind()

		Public Overridable ReadOnly Property AdditionalContainingMembers As ImmutableArray(Of Symbol)
			Get
				Return Me.m_containingBinder.AdditionalContainingMembers
			End Get
		End Property

		Public Overridable ReadOnly Property AllImplicitVariableDeclarationsAreHandled As Boolean
			Get
				Return Me.m_containingBinder.AllImplicitVariableDeclarationsAreHandled
			End Get
		End Property

		Public Overridable ReadOnly Property BindingLocation As Microsoft.CodeAnalysis.VisualBasic.BindingLocation
			Get
				Return Me.m_containingBinder.BindingLocation
			End Get
		End Property

		Friend ReadOnly Property BindingTopLevelScriptCode As Boolean
			Get
				Dim isScriptConstructor As Boolean
				Dim containingMember As Symbol = Me.ContainingMember
				Dim kind As SymbolKind = containingMember.Kind
				If (kind = SymbolKind.Method) Then
					isScriptConstructor = DirectCast(containingMember, MethodSymbol).IsScriptConstructor
				Else
					isScriptConstructor = If(kind = SymbolKind.NamedType, DirectCast(containingMember, NamedTypeSymbol).IsScriptClass, False)
				End If
				Return isScriptConstructor
			End Get
		End Property

		Public Overridable ReadOnly Property CheckOverflow As Boolean
			Get
				Return Me.m_containingBinder.CheckOverflow
			End Get
		End Property

		Public ReadOnly Property Compilation As VisualBasicCompilation
			Get
				Return Me._compilation
			End Get
		End Property

		Friend Overridable ReadOnly Property ConstantFieldsInProgress As Microsoft.CodeAnalysis.VisualBasic.ConstantFieldsInProgress
			Get
				Return Me.m_containingBinder.ConstantFieldsInProgress
			End Get
		End Property

		Public ReadOnly Property ContainingBinder As Binder
			Get
				Return Me.m_containingBinder
			End Get
		End Property

		Public Overridable ReadOnly Property ContainingMember As Symbol
			Get
				Return Me.m_containingBinder.ContainingMember
			End Get
		End Property

		Friend ReadOnly Property ContainingModule As ModuleSymbol
			Get
				Dim containingMember As Symbol = Me.ContainingMember
				Dim sourceModule As Object = TryCast(containingMember, ModuleSymbol)
				If (sourceModule Is Nothing) Then
					If (containingMember IsNot Nothing) Then
						sourceModule = containingMember.ContainingModule
					Else
						sourceModule = Nothing
					End If
					If (sourceModule Is Nothing) Then
						sourceModule = Me.Compilation.SourceModule
					End If
				End If
				Return sourceModule
			End Get
		End Property

		Public Overridable ReadOnly Property ContainingNamespaceOrType As NamespaceOrTypeSymbol
			Get
				Return Me.m_containingBinder.ContainingNamespaceOrType
			End Get
		End Property

		Public Overridable ReadOnly Property ContainingType As NamedTypeSymbol
			Get
				Return Me.m_containingBinder.ContainingType
			End Get
		End Property

		Friend Overridable ReadOnly Property DefaultParametersInProgress As SymbolsInProgress(Of ParameterSymbol)
			Get
				Return Me.m_containingBinder.DefaultParametersInProgress
			End Get
		End Property

		Friend Overridable ReadOnly Property HasImportedXmlNamespaces As Boolean
			Get
				Return Me.m_containingBinder.HasImportedXmlNamespaces
			End Get
		End Property

		Public ReadOnly Property IgnoreBaseClassesInLookup As Boolean
			Get
				Return Me._ignoreBaseClassesInLookup
			End Get
		End Property

		Friend ReadOnly Property IgnoresAccessibility As Boolean
			Get
				Return (Me.BinderSpecificLookupOptions(LookupOptions.[Default]) And LookupOptions.IgnoreAccessibility) = LookupOptions.IgnoreAccessibility
			End Get
		End Property

		Public Overridable ReadOnly Property ImplicitlyDeclaredVariables As ImmutableArray(Of LocalSymbol)
			Get
				Return Me.m_containingBinder.ImplicitlyDeclaredVariables
			End Get
		End Property

		Public Overridable ReadOnly Property ImplicitlyTypedLocalsBeingBound As ConsList(Of LocalSymbol)
			Get
				Return Me.m_containingBinder.ImplicitlyTypedLocalsBeingBound
			End Get
		End Property

		Public Overridable ReadOnly Property ImplicitVariableDeclarationAllowed As Boolean
			Get
				Return Me.m_containingBinder.ImplicitVariableDeclarationAllowed
			End Get
		End Property

		Friend Overridable ReadOnly Property IsDefaultInstancePropertyAllowed As Boolean
			Get
				Return Me.m_containingBinder.IsDefaultInstancePropertyAllowed
			End Get
		End Property

		Public ReadOnly Property IsEarlyAttributeBinder As Boolean
			Get
				Return Me._isEarlyAttributeBinder
			End Get
		End Property

		Friend ReadOnly Property IsInLambda As Boolean
			Get
				Return Me.ContainingMember.IsLambdaMethod
			End Get
		End Property

		Public Overridable ReadOnly Property IsInQuery As Boolean
			Get
				Return Me.m_containingBinder.IsInQuery
			End Get
		End Property

		Protected Overridable ReadOnly Property IsInsideChainedConstructorCallArguments As Boolean
			Get
				Return Me.ContainingBinder.IsInsideChainedConstructorCallArguments
			End Get
		End Property

		Public Overridable ReadOnly Property IsSemanticModelBinder As Boolean
			Get
				Return Me.m_containingBinder.IsSemanticModelBinder
			End Get
		End Property

		Public Overridable ReadOnly Property OptionCompareText As Boolean
			Get
				Return Me.m_containingBinder.OptionCompareText
			End Get
		End Property

		Public Overridable ReadOnly Property OptionExplicit As Boolean
			Get
				Return Me.m_containingBinder.OptionExplicit
			End Get
		End Property

		Public Overridable ReadOnly Property OptionInfer As Boolean
			Get
				Return Me.m_containingBinder.OptionInfer
			End Get
		End Property

		Public Overridable ReadOnly Property OptionStrict As Microsoft.CodeAnalysis.VisualBasic.OptionStrict
			Get
				Return Me.m_containingBinder.OptionStrict
			End Get
		End Property

		Public Overridable ReadOnly Property QuickAttributeChecker As Microsoft.CodeAnalysis.VisualBasic.Symbols.QuickAttributeChecker
			Get
				Return Me.m_containingBinder.QuickAttributeChecker
			End Get
		End Property

		Friend ReadOnly Property ShouldCheckConstraints As Boolean
			Get
				Dim flag As Boolean
				flag = If(CInt(Me.BindingLocation) - CInt(Microsoft.CodeAnalysis.VisualBasic.BindingLocation.BaseTypes) > CInt(Microsoft.CodeAnalysis.VisualBasic.BindingLocation.ProjectImportsDeclaration), True, False)
				Return flag
			End Get
		End Property

		Public ReadOnly Property SourceModule As SourceModuleSymbol
			Get
				Return Me._sourceModule
			End Get
		End Property

		Friend Overridable ReadOnly Property SuppressCallerInfo As Boolean
			Get
				Return Me.m_containingBinder.SuppressCallerInfo
			End Get
		End Property

		Friend Overridable ReadOnly Property SuppressObsoleteDiagnostics As Boolean
			Get
				Return Me.m_containingBinder.SuppressObsoleteDiagnostics
			End Get
		End Property

		Public ReadOnly Property SyntaxTree As Microsoft.CodeAnalysis.SyntaxTree
			Get
				Return Me._syntaxTree
			End Get
		End Property

		Shared Sub New()
			Binder.s_noArguments = ImmutableArray(Of BoundExpression).Empty
			Binder.s_checkDelegateParameterModifierCallback = New Binder.CheckParameterModifierDelegate(AddressOf Binder.CheckDelegateParameterModifier)
			Binder.s_isFunctionWithoutArguments = Function(sym As Symbol)
				Dim flag1 As Boolean
				If (sym.Kind <> SymbolKind.Method) Then
					flag1 = False
				Else
					Dim methodSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol = DirectCast(sym, Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)
					flag1 = If(methodSymbol.IsSub OrElse methodSymbol.IsGenericMethod, False, methodSymbol.CanBeCalledWithNoParameters())
				End If
				Return flag1
			End Function
			Binder.s_isReadablePropertyWithoutArguments = Function(sym As Symbol)
				Dim flag As Boolean
				If (sym.Kind <> SymbolKind.[Property]) Then
					flag = False
				Else
					Dim propertySymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol = DirectCast(sym, Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol)
					flag = If(Not propertySymbol.IsReadable OrElse propertySymbol.GetMostDerivedGetMethod().IsGenericMethod, False, propertySymbol.GetCanBeCalledWithNoParameters())
				End If
				Return flag
			End Function
			Binder.s_friendKeyword = New SyntaxKind() { SyntaxKind.FriendKeyword }
			Binder.s_checkOperatorParameterModifierCallback = New Binder.CheckParameterModifierDelegate(AddressOf Binder.CheckOperatorParameterModifier)
			Binder.s_checkPropertyParameterModifierCallback = New Binder.CheckParameterModifierDelegate(AddressOf Binder.CheckPropertyParameterModifier)
			Binder.s_notInheritableKeyword = New SyntaxKind() { SyntaxKind.NotInheritableKeyword }
		End Sub

		Protected Sub New(ByVal containingBinder As Binder)
			MyBase.New()
			Me.m_containingBinder = containingBinder
			If (containingBinder IsNot Nothing) Then
				Me._syntaxTree = containingBinder.SyntaxTree
				Me._compilation = containingBinder.Compilation
				Me._sourceModule = containingBinder.SourceModule
				Me._isEarlyAttributeBinder = containingBinder.IsEarlyAttributeBinder
				Me._ignoreBaseClassesInLookup = containingBinder.IgnoreBaseClassesInLookup
				Me._basesBeingResolved = containingBinder.BasesBeingResolved()
			End If
		End Sub

		Protected Sub New(ByVal containingBinder As Binder, ByVal syntaxTree As Microsoft.CodeAnalysis.SyntaxTree)
			MyClass.New(containingBinder)
			Me._syntaxTree = syntaxTree
		End Sub

		Protected Sub New(ByVal containingBinder As Binder, ByVal sourceModule As SourceModuleSymbol, ByVal compilation As VisualBasicCompilation)
			MyClass.New(containingBinder)
			Me._sourceModule = sourceModule
			Me._compilation = compilation
		End Sub

		Protected Sub New(ByVal containingBinder As Binder, Optional ByVal isEarlyAttributeBinder As Nullable(Of Boolean) = Nothing, Optional ByVal ignoreBaseClassesInLookup As Nullable(Of Boolean) = Nothing)
			MyClass.New(containingBinder)
			If (isEarlyAttributeBinder.HasValue) Then
				Me._isEarlyAttributeBinder = isEarlyAttributeBinder.Value
			End If
			If (ignoreBaseClassesInLookup.HasValue) Then
				Me._ignoreBaseClassesInLookup = ignoreBaseClassesInLookup.Value
			End If
		End Sub

		Protected Sub New(ByVal containingBinder As Binder, ByVal basesBeingResolved As Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolved)
			MyClass.New(containingBinder)
			Me._basesBeingResolved = basesBeingResolved
		End Sub

		Private Function AbsorbOperatorFollowingJoin(ByVal absorbingJoin As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClause, ByVal absorbNextOperator As Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax, ByVal operatorsEnumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator, ByVal joinSelectorDeclaredRangeVariables As ImmutableArray(Of RangeVariableSymbol), ByVal joinSelectorBinder As Binder.QueryLambdaBinder, ByVal leftRangeVariables As ImmutableArray(Of RangeVariableSymbol), ByVal rightRangeVariables As ImmutableArray(Of RangeVariableSymbol), ByVal group As BoundQueryClauseBase, ByVal intoBinder As Binder.IntoClauseDisallowGroupReferenceBinder, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundQueryClauseBase
			Dim boundQueryClause As BoundQueryClauseBase
			Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = absorbNextOperator.Kind()
			If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LetClause) Then
				Dim letClauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax = DirectCast(absorbNextOperator, Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax)
				Dim expressionRangeVariableSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax = letClauseSyntax.Variables.First()
				Dim boundQueryClause1 As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClause = New Microsoft.CodeAnalysis.VisualBasic.BoundQueryClause(expressionRangeVariableSyntax, absorbingJoin, Microsoft.CodeAnalysis.ImmutableArrayExtensions.Concat(Of RangeVariableSymbol)(absorbingJoin.RangeVariables, joinSelectorDeclaredRangeVariables), absorbingJoin.CompoundVariableType, ImmutableArray.Create(Of Binder)(absorbingJoin.Binders.Last()), absorbingJoin.Type, False)
				boundQueryClause = Me.BindLetClause(boundQueryClause1, letClauseSyntax, operatorsEnumerator, diagnostics, True)
			ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AggregateClause) Then
				boundQueryClause = Me.CompleteAggregateClauseBinding(DirectCast(absorbNextOperator, Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax), operatorsEnumerator, leftRangeVariables, rightRangeVariables, absorbingJoin, joinSelectorBinder, joinSelectorDeclaredRangeVariables, absorbingJoin.CompoundVariableType, group, intoBinder, diagnostics)
			Else
				If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SelectClause) Then
					Throw ExceptionUtilities.UnexpectedValue(absorbNextOperator.Kind())
				End If
				boundQueryClause = New Microsoft.CodeAnalysis.VisualBasic.BoundQueryClause(absorbNextOperator, absorbingJoin, joinSelectorDeclaredRangeVariables, absorbingJoin.CompoundVariableType, ImmutableArray.Create(Of Binder)(absorbingJoin.Binders.Last()), absorbingJoin.Type, False)
			End If
			Return boundQueryClause
		End Function

		Private Shared Function AddContainingNamespaces(ByVal namespaces As SmallDictionary(Of NamespaceSymbol, Boolean), ByVal candidate As Symbol, ByVal compilation As VisualBasicCompilation) As Boolean
			Dim flag As Boolean
			If (candidate Is Nothing OrElse candidate.Kind = SymbolKind.ErrorType) Then
				flag = False
			Else
				Dim containingNamespace As NamespaceSymbol = candidate.ContainingNamespace
				If (containingNamespace Is Nothing) Then
					flag = False
				Else
					namespaces(compilation.GetCompilationNamespace(containingNamespace)) = False
					flag = True
				End If
			End If
			Return flag
		End Function

		Protected Overridable Sub AddExtensionMethodLookupSymbolsInfoInSingleBinder(ByVal nameSet As LookupSymbolsInfo, ByVal options As LookupOptions, ByVal originalBinder As Binder)
		End Sub

		Private Shared Sub AddImportedNamespaceIfNecessary(ByVal importedNamespaces As ArrayBuilder(Of KeyValuePair(Of String, String)), ByVal prefix As String, ByVal [namespace] As String, ByVal forElement As Boolean)
			If (EmbeddedOperators.CompareString([namespace], "", False) = 0) Then
				If (Not forElement OrElse EmbeddedOperators.CompareString(prefix, "", False) = 0) Then
					Return
				End If
				prefix = ""
			End If
			Dim enumerator As ArrayBuilder(Of KeyValuePair(Of String, String)).Enumerator = importedNamespaces.GetEnumerator()
			While enumerator.MoveNext()
				Dim current As KeyValuePair(Of String, String) = enumerator.Current
				If (EmbeddedOperators.CompareString(current.Key, prefix, False) = 0) Then
					Return
				End If
			End While
			importedNamespaces.Add(New KeyValuePair(Of String, String)(prefix, [namespace]))
		End Sub

		Public Overridable Sub AddLookupSymbolsInfo(ByVal nameSet As LookupSymbolsInfo, ByVal options As LookupOptions)
			' 
			' Current member / type: System.Void Microsoft.CodeAnalysis.VisualBasic.Binder::AddLookupSymbolsInfo(Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.LookupOptions)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: System.Void AddLookupSymbolsInfo(Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.LookupOptions)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Sub

		Friend Overridable Sub AddLookupSymbolsInfoInSingleBinder(ByVal nameSet As LookupSymbolsInfo, ByVal options As LookupOptions, ByVal originalBinder As Binder)
		End Sub

		Friend Sub AddMemberLookupSymbolsInfo(ByVal nameSet As LookupSymbolsInfo, ByVal container As NamespaceOrTypeSymbol, ByVal options As LookupOptions)
			options = Me.BinderSpecificLookupOptions(options)
			Binder.MemberLookup.AddLookupSymbolsInfo(nameSet, container, options, Me)
		End Sub

		Friend Shared Function AddReceiverNamespaces(ByVal namespaces As SmallDictionary(Of NamespaceSymbol, Boolean), ByVal candidate As Symbol, ByVal compilation As VisualBasicCompilation) As Boolean
			Dim flag As Boolean
			If (candidate.Kind <> SymbolKind.[Namespace] OrElse CInt(DirectCast(candidate, NamespaceSymbol).NamespaceKind) <> 0) Then
				flag = Binder.AddContainingNamespaces(namespaces, candidate, compilation)
			Else
				Dim enumerator As ImmutableArray(Of NamespaceSymbol).Enumerator = DirectCast(candidate, NamespaceSymbol).ConstituentNamespaces.GetEnumerator()
				While enumerator.MoveNext()
					If (Binder.AddContainingNamespaces(namespaces, enumerator.Current, compilation)) Then
						Continue While
					End If
					flag = False
					Return flag
				End While
				flag = True
			End If
			Return flag
		End Function

		Public Sub AddTypesAssemblyAsDependency(ByVal namespaceOrType As NamespaceOrTypeSymbol, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Dim containingAssembly As Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol
			Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = TryCast(namespaceOrType, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)
			If (namedTypeSymbol IsNot Nothing) Then
				containingAssembly = namedTypeSymbol.ContainingAssembly
			Else
				containingAssembly = Nothing
			End If
			Dim assemblySymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol = containingAssembly
			If (assemblySymbol IsNot Nothing AndAlso assemblySymbol <> Me.Compilation.Assembly AndAlso assemblySymbol <> Me.Compilation.Assembly.CorLibrary) Then
				diagBag.AddDependency(assemblySymbol)
			End If
		End Sub

		Private Shared Function AddXmlAttributeIfNotDuplicate(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax, ByVal name As Binder.XmlName, ByVal attribute As BoundXmlAttribute, <Out> ByRef allAttributes As Dictionary(Of Binder.XmlName, BoundXmlAttribute), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
			Dim flag As Boolean
			If (allAttributes Is Nothing) Then
				allAttributes = New Dictionary(Of Binder.XmlName, BoundXmlAttribute)(Binder.XmlNameComparer.Instance)
			End If
			If (Not allAttributes.ContainsKey(name)) Then
				allAttributes.Add(name, attribute)
				flag = True
			Else
				Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_DuplicateXmlAttribute, New [Object]() { syntax.ToString() })
				flag = False
			End If
			Return flag
		End Function

		Friend Function AdjustAssignmentTarget(ByVal node As SyntaxNode, ByVal op1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByRef isError As Boolean) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim kind As BoundKind = op1.Kind
			If (kind <= BoundKind.LateInvocation) Then
				If (kind = BoundKind.LateMemberAccess) Then
					boundExpression = DirectCast(op1, BoundLateMemberAccess).SetAccessKind(LateBoundAccessKind.[Set])
				Else
					If (kind <> BoundKind.LateInvocation) Then
						boundExpression = op1
						Return boundExpression
					End If
					boundExpression = DirectCast(op1, BoundLateInvocation).SetAccessKind(LateBoundAccessKind.[Set])
				End If
			ElseIf (kind = BoundKind.PropertyAccess) Then
				Dim boundPropertyAccess As Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess = DirectCast(op1, Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess)
				Dim propertySymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol = boundPropertyAccess.PropertySymbol
				If (Not boundPropertyAccess.IsLValue) Then
					Dim mostDerivedSetMethod As MethodSymbol = propertySymbol.GetMostDerivedSetMethod()
					If (Not boundPropertyAccess.IsWriteable) Then
						If (mostDerivedSetMethod IsNot Nothing) Then
							Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_AssignmentInitOnly, New [Object]() { CustomSymbolDisplayFormatter.ShortErrorName(propertySymbol) })
						Else
							Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_NoSetProperty1, New [Object]() { CustomSymbolDisplayFormatter.ShortErrorName(propertySymbol) })
						End If
						isError = True
					End If
					If (mostDerivedSetMethod IsNot Nothing) Then
						If (boundPropertyAccess.IsWriteable AndAlso mostDerivedSetMethod.IsInitOnly) Then
							Parser.CheckFeatureAvailability(diagnostics, node.Location, DirectCast(node.SyntaxTree.Options, VisualBasicParseOptions).LanguageVersion, Feature.InitOnlySettersUsage)
						End If
						Me.ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagnostics, mostDerivedSetMethod, node)
						If (Not Binder.ReportUseSite(diagnostics, op1.Syntax, mostDerivedSetMethod)) Then
							Dim accessThroughType As TypeSymbol = Me.GetAccessThroughType(boundPropertyAccess.ReceiverOpt)
							Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
							Dim basesBeingResolved As Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolved = New Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolved()
							If (Not Me.IsAccessible(mostDerivedSetMethod, newCompoundUseSiteInfo, accessThroughType, basesBeingResolved)) Then
								basesBeingResolved = New Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolved()
								If (Me.IsAccessible(propertySymbol, newCompoundUseSiteInfo, accessThroughType, basesBeingResolved)) Then
									Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_NoAccessibleSet, New [Object]() { CustomSymbolDisplayFormatter.ShortErrorName(propertySymbol) })
									isError = True
								End If
							End If
							diagnostics.Add(node, newCompoundUseSiteInfo)
						Else
							isError = True
						End If
					End If
					Me.WarnOnRecursiveAccess(boundPropertyAccess, PropertyAccessKind.[Set], diagnostics)
					boundExpression = boundPropertyAccess.SetAccessKind(PropertyAccessKind.[Set])
				Else
					Me.WarnOnRecursiveAccess(boundPropertyAccess, PropertyAccessKind.[Get], diagnostics)
					boundExpression = boundPropertyAccess.SetAccessKind(PropertyAccessKind.[Get])
				End If
			Else
				If (kind <> BoundKind.XmlMemberAccess) Then
					boundExpression = op1
					Return boundExpression
				End If
				Dim boundXmlMemberAccess As Microsoft.CodeAnalysis.VisualBasic.BoundXmlMemberAccess = DirectCast(op1, Microsoft.CodeAnalysis.VisualBasic.BoundXmlMemberAccess)
				Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.AdjustAssignmentTarget(node, boundXmlMemberAccess.MemberAccess, diagnostics, isError)
				boundExpression = boundXmlMemberAccess.Update(boundExpression1)
			End If
			Return boundExpression
		End Function

		Private Shared Function AdjustReceiverAmbiguousTypeOrValue(ByVal receiver As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			If (receiver IsNot Nothing AndAlso receiver.Kind = BoundKind.TypeOrValueExpression) Then
				Dim boundTypeOrValueExpression As Microsoft.CodeAnalysis.VisualBasic.BoundTypeOrValueExpression = DirectCast(receiver, Microsoft.CodeAnalysis.VisualBasic.BoundTypeOrValueExpression)
				diagnostics.AddRange(boundTypeOrValueExpression.Data.ValueDiagnostics, False)
				receiver = boundTypeOrValueExpression.Data.ValueExpression
			End If
			Return receiver
		End Function

		Private Shared Function AdjustReceiverAmbiguousTypeOrValue(ByRef group As BoundMethodOrPropertyGroup, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim receiverOpt As BoundExpression = group.ReceiverOpt
			If (receiverOpt IsNot Nothing AndAlso receiverOpt.Kind = BoundKind.TypeOrValueExpression) Then
				receiverOpt = Binder.AdjustReceiverAmbiguousTypeOrValue(receiverOpt, diagnostics)
				Dim kind As BoundKind = group.Kind
				If (kind = BoundKind.MethodGroup) Then
					Dim boundMethodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup = DirectCast(group, Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup)
					group = boundMethodGroup.Update(boundMethodGroup.TypeArgumentsOpt, boundMethodGroup.Methods, boundMethodGroup.PendingExtensionMethodsOpt, boundMethodGroup.ResultKind, receiverOpt, boundMethodGroup.QualificationKind)
				Else
					If (kind <> BoundKind.PropertyGroup) Then
						Throw ExceptionUtilities.UnexpectedValue(group.Kind)
					End If
					Dim boundPropertyGroup As Microsoft.CodeAnalysis.VisualBasic.BoundPropertyGroup = DirectCast(group, Microsoft.CodeAnalysis.VisualBasic.BoundPropertyGroup)
					group = boundPropertyGroup.Update(boundPropertyGroup.Properties, boundPropertyGroup.ResultKind, receiverOpt, boundPropertyGroup.QualificationKind)
				End If
			End If
			Return receiverOpt
		End Function

		Private Function AdjustReceiverNamespace(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal receiver As BoundExpression) As BoundExpression
			If (receiver.Kind = BoundKind.NamespaceExpression) Then
				Dim boundNamespaceExpression As Microsoft.CodeAnalysis.VisualBasic.BoundNamespaceExpression = DirectCast(receiver, Microsoft.CodeAnalysis.VisualBasic.BoundNamespaceExpression)
				If (CInt(boundNamespaceExpression.NamespaceSymbol.NamespaceKind) = 0) Then
					Dim symbols As ArrayBuilder(Of Symbol) = lookupResult.Symbols
					If (lookupResult.HasDiagnostic) Then
						Dim diagnostic As DiagnosticInfo = lookupResult.Diagnostic
						If (TypeOf diagnostic Is AmbiguousSymbolDiagnostic) Then
							Dim ambiguousSymbols As ImmutableArray(Of Symbol) = DirectCast(diagnostic, AmbiguousSymbolDiagnostic).AmbiguousSymbols
							symbols = ArrayBuilder(Of Symbol).GetInstance()
							symbols.AddRange(ambiguousSymbols)
						End If
					End If
					receiver = Me.AdjustReceiverNamespace(boundNamespaceExpression, symbols)
					If (symbols <> lookupResult.Symbols) Then
						symbols.Free()
					End If
				End If
			End If
			Return receiver
		End Function

		Private Function AdjustReceiverNamespace(ByVal namespaceReceiver As Microsoft.CodeAnalysis.VisualBasic.BoundNamespaceExpression, ByVal symbols As ArrayBuilder(Of Symbol)) As Microsoft.CodeAnalysis.VisualBasic.BoundNamespaceExpression
			Dim boundNamespaceExpression As Microsoft.CodeAnalysis.VisualBasic.BoundNamespaceExpression
			If (symbols.Count > 0) Then
				Dim namespaceSymbols As SmallDictionary(Of NamespaceSymbol, Boolean) = New SmallDictionary(Of NamespaceSymbol, Boolean)()
				Dim enumerator As ArrayBuilder(Of Symbol).Enumerator = symbols.GetEnumerator()
				While enumerator.MoveNext()
					If (Binder.AddReceiverNamespaces(namespaceSymbols, enumerator.Current, Me.Compilation)) Then
						Continue While
					End If
					namespaceSymbols = Nothing
					Exit While
				End While
				If (namespaceSymbols Is Nothing OrElse namespaceSymbols.Count() >= namespaceReceiver.NamespaceSymbol.ConstituentNamespaces.Length) Then
					boundNamespaceExpression = namespaceReceiver
					Return boundNamespaceExpression
				End If
				boundNamespaceExpression = Me.AdjustReceiverNamespace(namespaceReceiver, DirectCast(namespaceReceiver.NamespaceSymbol, MergedNamespaceSymbol).Shrink(DirectCast(namespaceSymbols.Keys, IEnumerable(Of NamespaceSymbol))))
				Return boundNamespaceExpression
			End If
			boundNamespaceExpression = namespaceReceiver
			Return boundNamespaceExpression
		End Function

		Private Function AdjustReceiverNamespace(ByVal namespaceReceiver As Microsoft.CodeAnalysis.VisualBasic.BoundNamespaceExpression, ByVal adjustedNamespace As NamespaceSymbol) As Microsoft.CodeAnalysis.VisualBasic.BoundNamespaceExpression
			Dim boundNamespaceExpression As Microsoft.CodeAnalysis.VisualBasic.BoundNamespaceExpression
			If (CObj(adjustedNamespace) = CObj(namespaceReceiver.NamespaceSymbol)) Then
				boundNamespaceExpression = namespaceReceiver
			Else
				Dim unevaluatedReceiverOpt As BoundExpression = namespaceReceiver.UnevaluatedReceiverOpt
				If (unevaluatedReceiverOpt IsNot Nothing AndAlso unevaluatedReceiverOpt.Kind = BoundKind.NamespaceExpression) Then
					Dim boundNamespaceExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundNamespaceExpression = DirectCast(unevaluatedReceiverOpt, Microsoft.CodeAnalysis.VisualBasic.BoundNamespaceExpression)
					If (CInt(boundNamespaceExpression1.NamespaceSymbol.NamespaceKind) = 0 AndAlso Binder.IsNamespaceGroupIncludesButNotEquivalentTo(boundNamespaceExpression1.NamespaceSymbol, adjustedNamespace.ContainingNamespace)) Then
						unevaluatedReceiverOpt = Me.AdjustReceiverNamespace(boundNamespaceExpression1, adjustedNamespace.ContainingNamespace)
					End If
				End If
				boundNamespaceExpression = namespaceReceiver.Update(unevaluatedReceiverOpt, namespaceReceiver.AliasOpt, adjustedNamespace)
			End If
			Return boundNamespaceExpression
		End Function

		Private Function AdjustReceiverTypeOrValue(ByVal receiver As BoundExpression, ByVal node As SyntaxNode, ByVal isShared As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByRef resolvedTypeOrValueExpression As BoundExpression) As BoundExpression
			Dim qualificationKind As Microsoft.CodeAnalysis.VisualBasic.QualificationKind = 0
			Return Me.AdjustReceiverTypeOrValue(receiver, node, isShared, True, diagnostics, qualificationKind, resolvedTypeOrValueExpression)
		End Function

		Private Function AdjustReceiverTypeOrValue(ByVal receiver As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal node As SyntaxNode, ByVal isShared As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByRef qualKind As QualificationKind) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Return Me.AdjustReceiverTypeOrValue(receiver, node, isShared, False, diagnostics, qualKind, boundExpression)
		End Function

		Private Function AdjustReceiverTypeOrValue(ByVal receiver As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal node As SyntaxNode, ByVal isShared As Boolean, ByVal clearIfShared As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByRef qualKind As QualificationKind, ByRef resolvedTypeOrValueExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim data As BoundTypeOrValueData
			If (receiver IsNot Nothing) Then
				If (Not isShared) Then
					If (receiver.Kind = BoundKind.TypeOrValueExpression) Then
						Dim boundTypeOrValueExpression As Microsoft.CodeAnalysis.VisualBasic.BoundTypeOrValueExpression = DirectCast(receiver, Microsoft.CodeAnalysis.VisualBasic.BoundTypeOrValueExpression)
						data = boundTypeOrValueExpression.Data
						diagnostics.AddRange(data.ValueDiagnostics, False)
						data = boundTypeOrValueExpression.Data
						receiver = Me.MakeValue(data.ValueExpression, diagnostics)
						qualKind = QualificationKind.QualifiedViaValue
						resolvedTypeOrValueExpression = receiver
					End If
					receiver = Me.AdjustReceiverValue(receiver, node, diagnostics)
				Else
					If (receiver.Kind = BoundKind.TypeOrValueExpression) Then
						Dim boundTypeOrValueExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundTypeOrValueExpression = DirectCast(receiver, Microsoft.CodeAnalysis.VisualBasic.BoundTypeOrValueExpression)
						data = boundTypeOrValueExpression1.Data
						diagnostics.AddRange(data.TypeDiagnostics, False)
						receiver = boundTypeOrValueExpression1.Data.TypeExpression
						qualKind = QualificationKind.QualifiedViaTypeName
						resolvedTypeOrValueExpression = receiver
					End If
					If (clearIfShared) Then
						receiver = Nothing
					End If
				End If
				boundExpression = receiver
			Else
				boundExpression = receiver
			End If
			Return boundExpression
		End Function

		Private Function AdjustReceiverValue(ByVal receiver As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal node As SyntaxNode, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			If (Not receiver.IsValue()) Then
				receiver = Me.MakeValue(receiver, diagnostics)
			End If
			If (Not receiver.IsLValue AndAlso Not receiver.IsPropertyOrXmlPropertyAccess()) Then
				receiver = Me.MakeRValue(receiver, diagnostics)
			End If
			Dim type As TypeSymbol = receiver.Type
			If (type Is Nothing OrElse type.IsErrorType()) Then
				boundExpression = Binder.BadExpression(node, receiver, LookupResultKind.NotAValue, ErrorTypeSymbol.UnknownResultType)
			Else
				boundExpression = receiver
			End If
			Return boundExpression
		End Function

		Private Function AnalyzeConversionAndCreateBinaryConditionalExpression(ByVal syntax As Microsoft.CodeAnalysis.SyntaxNode, ByVal testExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal elseExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal constantValueOpt As ConstantValue, ByVal type As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, ByVal hasErrors As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal explicitConversion As Boolean = False) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim boundRValuePlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder = Nothing
			If (Not hasErrors) Then
				If (Not testExpression.IsConstant) Then
					boundRValuePlaceholder = New Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder(testExpression.Syntax, testExpression.Type.GetNullableUnderlyingTypeOrSelf())
				End If
				Dim syntaxNode As Microsoft.CodeAnalysis.SyntaxNode = testExpression.Syntax
				Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = type
				Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = boundRValuePlaceholder
				If (boundExpression1 Is Nothing) Then
					boundExpression1 = testExpression
				End If
				boundExpression = Me.ApplyConversion(syntaxNode, typeSymbol, boundExpression1, explicitConversion, diagnostics, False, False)
				Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = boundExpression
				Dim boundExpression3 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = boundRValuePlaceholder
				If (boundExpression3 Is Nothing) Then
					boundExpression3 = testExpression
				End If
				If (boundExpression2 = boundExpression3) Then
					boundExpression = Nothing
					boundRValuePlaceholder = Nothing
				End If
			End If
			Return New BoundBinaryConditionalExpression(syntax, testExpression, boundExpression, boundRValuePlaceholder, elseExpression, constantValueOpt, type, hasErrors)
		End Function

		Public Function ApplyArrayRankSpecifiersAndBoundsToType(ByVal elementType As TypeSymbol, ByVal arrayModifierSyntax As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax), ByVal arrayBoundsOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As TypeSymbol
			Dim type As TypeSymbol = elementType
			type = Me.ApplyArrayRankSpecifiersToType(elementType, arrayModifierSyntax, diagnostics)
			If (arrayBoundsOpt IsNot Nothing) Then
				Dim count As Integer = arrayBoundsOpt.Arguments.Count
				If (count = 0) Then
					count = 1
				End If
				If (count > 32) Then
					Binder.ReportDiagnostic(diagnostics, arrayBoundsOpt, ERRID.ERR_ArrayRankLimit)
				End If
				Dim customModifiers As ImmutableArray(Of CustomModifier) = New ImmutableArray(Of CustomModifier)()
				type = ArrayTypeSymbol.CreateVBArray(type, customModifiers, count, Me.Compilation)
			End If
			Return type
		End Function

		Public Function ApplyArrayRankSpecifiersToType(ByVal elementType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, ByVal arrayModifierSyntax As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = elementType
			For i As Integer = arrayModifierSyntax.Count - 1 To 0 Step -1
				Dim item As Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax = arrayModifierSyntax(i)
				If (item.Rank > 32) Then
					Binder.ReportDiagnostic(diagnostics, item, ERRID.ERR_ArrayRankLimit)
				End If
				Dim customModifiers As ImmutableArray(Of CustomModifier) = New ImmutableArray(Of CustomModifier)()
				typeSymbol = ArrayTypeSymbol.CreateVBArray(typeSymbol, customModifiers, item.Rank, Me.Compilation)
			Next

			Return typeSymbol
		End Function

		Private Function ApplyConversion(ByVal node As SyntaxNode, ByVal targetType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, ByVal argument As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal isExplicit As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal isOperandOfConditionalBranch As Boolean = False, Optional ByVal explicitSemanticForConcatArgument As Boolean = False) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundConversion As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim keyValuePair As KeyValuePair(Of ConversionKind, MethodSymbol)
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			If (Not targetType.IsErrorType()) Then
				If (argument.HasErrors) Then
					diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
				End If
				Dim flag As Boolean = False
				Dim overloadResolutionResult As OverloadResolution.OverloadResolutionResult = New OverloadResolution.OverloadResolutionResult()
				Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
				If (Not isOperandOfConditionalBranch OrElse Not targetType.IsBooleanType()) Then
					keyValuePair = Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyConversion(argument, targetType, Me, newCompoundUseSiteInfo)
					If (diagnostics.Add(node, newCompoundUseSiteInfo)) Then
						diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
					End If
					boundExpression = Me.CreateConversionAndReportDiagnostic(node, argument, keyValuePair, isExplicit, targetType, diagnostics, Nothing, explicitSemanticForConcatArgument)
				Else
					keyValuePair = Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyConversionOfOperandOfConditionalBranch(argument, targetType, Me, flag, overloadResolutionResult, newCompoundUseSiteInfo)
					If (diagnostics.Add(node, newCompoundUseSiteInfo)) Then
						diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
					End If
					If (Not overloadResolutionResult.BestResult.HasValue) Then
						If (Not flag) Then
							typeSymbol = targetType
						Else
							Me.Compilation.GetSpecialType(SpecialType.System_Nullable_T)
							typeSymbol = Me.Compilation.GetSpecialType(SpecialType.System_Nullable_T).Construct(ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)(targetType))
						End If
						boundExpression = Me.CreateConversionAndReportDiagnostic(node, argument, keyValuePair, isExplicit, typeSymbol, diagnostics, Nothing, False)
					Else
						Dim boundUserDefinedUnaryOperator As Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedUnaryOperator = Me.BindUserDefinedUnaryOperator(node, UnaryOperatorKind.IsTrue, argument, overloadResolutionResult, diagnostics)
						boundUserDefinedUnaryOperator.SetWasCompilerGenerated()
						boundUserDefinedUnaryOperator.UnderlyingExpression.SetWasCompilerGenerated()
						boundExpression = boundUserDefinedUnaryOperator
					End If
					If (flag) Then
						boundExpression = Binder.ApplyNullableIsTrueOperator(boundExpression, targetType)
					End If
				End If
				boundConversion = boundExpression
			Else
				argument = Me.MakeRValueAndIgnoreDiagnostics(argument)
				If (isExplicit OrElse Not argument.Type.IsSameTypeIgnoringAll(targetType)) Then
					boundConversion = New Microsoft.CodeAnalysis.VisualBasic.BoundConversion(node, argument, ConversionKind.DelegateRelaxationLevelNone, Me.CheckOverflow, isExplicit, targetType, True)
				Else
					boundConversion = argument
				End If
			End If
			Return boundConversion
		End Function

		Private Function ApplyDirectCastConversion(ByVal node As SyntaxNode, ByVal argument As BoundExpression, ByVal targetType As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim boundDirectCast As BoundExpression
			If (argument.HasErrors OrElse targetType.IsErrorType()) Then
				argument = Me.MakeRValue(argument, diagnostics)
				boundDirectCast = New Microsoft.CodeAnalysis.VisualBasic.BoundDirectCast(node, argument, Microsoft.CodeAnalysis.VisualBasic.ConversionKind.DelegateRelaxationLevelNone, targetType, True)
			Else
				Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
				Dim conversionKind As Microsoft.CodeAnalysis.VisualBasic.ConversionKind = Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyDirectCastConversion(argument, targetType, Me, newCompoundUseSiteInfo)
				If (diagnostics.Add(node, newCompoundUseSiteInfo)) Then
					diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
				End If
				If (Not Me.ReclassifyExpression(argument, SyntaxKind.DirectCastKeyword, node, conversionKind, True, targetType, diagnostics)) Then
					argument = Me.MakeRValue(argument, diagnostics)
					If (Not argument.HasErrors) Then
						Dim type As TypeSymbol = argument.Type
						If (type IsNot Nothing AndAlso type.IsErrorType()) Then
							boundDirectCast = New Microsoft.CodeAnalysis.VisualBasic.BoundDirectCast(node, argument, conversionKind, targetType, True)
						ElseIf (Not Microsoft.CodeAnalysis.VisualBasic.Conversions.NoConversion(conversionKind) OrElse Not type.IsValueType OrElse Not type.IsRestrictedType() OrElse Not targetType.IsObjectType() AndAlso targetType.SpecialType <> SpecialType.System_ValueType) Then
							Me.WarnOnNarrowingConversionBetweenSealedClassAndAnInterface(conversionKind, argument.Syntax, type, targetType, diagnostics)
							If (Not Microsoft.CodeAnalysis.VisualBasic.Conversions.NoConversion(conversionKind)) Then
								If (Microsoft.CodeAnalysis.VisualBasic.Conversions.IsIdentityConversion(conversionKind)) Then
									If (targetType.IsFloatingType()) Then
										Binder.ReportDiagnostic(diagnostics, argument.Syntax, ERRID.ERR_IdentityDirectCastForFloat)
									ElseIf (targetType.IsValueType) Then
										Binder.ReportDiagnostic(diagnostics, argument.Syntax, ERRID.WRN_ObsoleteIdentityDirectCastForValueType)
									End If
								End If
								Dim flag As Boolean = False
								Dim constantValue As Microsoft.CodeAnalysis.ConstantValue = If(Microsoft.CodeAnalysis.VisualBasic.Conversions.TryFoldConstantConversion(argument, targetType, flag), Microsoft.CodeAnalysis.VisualBasic.Conversions.TryFoldNothingReferenceConversion(argument, conversionKind, targetType))
								boundDirectCast = New Microsoft.CodeAnalysis.VisualBasic.BoundDirectCast(node, argument, conversionKind, constantValue, targetType, False)
							Else
								Me.ReportNoConversionError(argument.Syntax, type, targetType, diagnostics, Nothing)
								boundDirectCast = New Microsoft.CodeAnalysis.VisualBasic.BoundDirectCast(node, argument, conversionKind, targetType, True)
							End If
						Else
							Binder.ReportDiagnostic(diagnostics, argument.Syntax, ERRID.ERR_RestrictedConversion1, New [Object]() { type })
							boundDirectCast = New Microsoft.CodeAnalysis.VisualBasic.BoundDirectCast(node, argument, conversionKind, targetType, True)
						End If
					Else
						boundDirectCast = New Microsoft.CodeAnalysis.VisualBasic.BoundDirectCast(node, argument, conversionKind, targetType, True)
					End If
				Else
					If (argument.Syntax <> node) Then
						argument = New Microsoft.CodeAnalysis.VisualBasic.BoundDirectCast(node, argument, Microsoft.CodeAnalysis.VisualBasic.ConversionKind.Identity, targetType, False)
					End If
					boundDirectCast = argument
				End If
			End If
			Return boundDirectCast
		End Function

		Private Function ApplyImplicitCollectionConversion(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax, ByVal source As Microsoft.CodeAnalysis.VisualBasic.BoundQueryPart, ByVal variableType As TypeSymbol, ByVal targetVariableType As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundQueryPart
			Dim boundQueryPart As Microsoft.CodeAnalysis.VisualBasic.BoundQueryPart
			If (Not source.Type.IsErrorType()) Then
				Dim identifier As Microsoft.CodeAnalysis.SyntaxToken = syntax.Identifier.Identifier
				Dim boundLambdaParameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol = Binder.CreateQueryLambdaParameterSymbol(identifier.ValueText, 0, variableType, syntax.AsClause)
				Dim synthesizedLambdaSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaSymbol = Me.CreateQueryLambdaSymbol(syntax.AsClause, SynthesizedLambdaKind.ConversionNonUserCodeQueryLambda, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol)(boundLambdaParameterSymbol))
				synthesizedLambdaSymbol.SetQueryLambdaReturnType(targetVariableType)
				Dim queryLambdaBinder As Binder.QueryLambdaBinder = New Binder.QueryLambdaBinder(synthesizedLambdaSymbol, ImmutableArray(Of RangeVariableSymbol).Empty)
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = queryLambdaBinder.ApplyImplicitConversion(syntax.AsClause, targetVariableType, (New BoundParameter(boundLambdaParameterSymbol.Syntax, boundLambdaParameterSymbol, False, variableType)).MakeCompilerGenerated(), diagnostics, False)
				Dim boundQueryLambda As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Binder.CreateBoundQueryLambda(synthesizedLambdaSymbol, ImmutableArray(Of RangeVariableSymbol).Empty, boundExpression, False)
				boundQueryLambda.SetWasCompilerGenerated()
				If (Binder.ShouldSuppressDiagnostics(boundQueryLambda)) Then
					diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
				End If
				Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindQueryOperatorCall(syntax.AsClause, source, "Select", ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundQueryLambda), syntax.AsClause.Span, diagnostics)
				boundQueryPart = (New BoundQueryClause(source.Syntax, boundExpression1, ImmutableArray(Of RangeVariableSymbol).Empty, targetVariableType, ImmutableArray.Create(Of Binder)(queryLambdaBinder), boundExpression1.Type, False)).MakeCompilerGenerated()
			Else
				Dim boundRValuePlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder = New Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder(syntax.AsClause, variableType)
				Me.ApplyImplicitConversion(syntax.AsClause, targetVariableType, boundRValuePlaceholder, diagnostics, False)
				boundQueryPart = source
			End If
			Return boundQueryPart
		End Function

		Friend Function ApplyImplicitConversion(ByVal node As SyntaxNode, ByVal targetType As TypeSymbol, ByVal expression As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal isOperandOfConditionalBranch As Boolean = False) As BoundExpression
			Return Me.ApplyConversion(node, targetType, expression, False, diagnostics, isOperandOfConditionalBranch, False)
		End Function

		Private Shared Function ApplyNullableIsTrueOperator(ByVal argument As BoundExpression, ByVal booleanType As TypeSymbol) As BoundNullableIsTrueOperator
			Return (New BoundNullableIsTrueOperator(argument.Syntax, argument, booleanType, False)).MakeCompilerGenerated()
		End Function

		Private Function ApplyTryCastConversion(ByVal node As Microsoft.CodeAnalysis.SyntaxNode, ByVal argument As BoundExpression, ByVal targetType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim boundTryCast As BoundExpression
			Dim conversionKind As Microsoft.CodeAnalysis.VisualBasic.ConversionKind
			Dim type As Microsoft.CodeAnalysis.SyntaxNode
			Dim syntaxNode As Microsoft.CodeAnalysis.SyntaxNode
			If (argument.HasErrors OrElse targetType.IsErrorType()) Then
				argument = Me.MakeRValue(argument, diagnostics)
				boundTryCast = New Microsoft.CodeAnalysis.VisualBasic.BoundTryCast(node, argument, Microsoft.CodeAnalysis.VisualBasic.ConversionKind.DelegateRelaxationLevelNone, targetType, True)
			Else
				If (Not targetType.IsReferenceType) Then
					conversionKind = Microsoft.CodeAnalysis.VisualBasic.ConversionKind.DelegateRelaxationLevelNone
				Else
					Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
					conversionKind = Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyTryCastConversion(argument, targetType, Me, newCompoundUseSiteInfo)
					If (diagnostics.Add(node, newCompoundUseSiteInfo)) Then
						diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
					End If
				End If
				If (Not Me.ReclassifyExpression(argument, SyntaxKind.TryCastKeyword, node, conversionKind, True, targetType, diagnostics)) Then
					argument = Me.MakeRValue(argument, diagnostics)
					If (Not argument.HasErrors) Then
						Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = argument.Type
						If (typeSymbol Is Nothing OrElse Not typeSymbol.IsErrorType()) Then
							If (Microsoft.CodeAnalysis.VisualBasic.Conversions.NoConversion(conversionKind)) Then
								If (targetType.IsValueType) Then
									Dim castExpressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax = TryCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax)
									Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
									If (castExpressionSyntax IsNot Nothing) Then
										syntaxNode = castExpressionSyntax.Type
									Else
										syntaxNode = node
									End If
									Binder.ReportDiagnostic(bindingDiagnosticBag, syntaxNode, ERRID.ERR_TryCastOfValueType1, New [Object]() { targetType })
									boundTryCast = New Microsoft.CodeAnalysis.VisualBasic.BoundTryCast(node, argument, conversionKind, targetType, True)
									Return boundTryCast
								ElseIf (Not targetType.IsTypeParameter() OrElse targetType.IsReferenceType) Then
									If (Not typeSymbol.IsValueType OrElse Not typeSymbol.IsRestrictedType() OrElse Not targetType.IsObjectType() AndAlso targetType.SpecialType <> SpecialType.System_ValueType) Then
										GoTo Label1
									End If
									Binder.ReportDiagnostic(diagnostics, argument.Syntax, ERRID.ERR_RestrictedConversion1, New [Object]() { typeSymbol })
									boundTryCast = New Microsoft.CodeAnalysis.VisualBasic.BoundTryCast(node, argument, conversionKind, targetType, True)
									Return boundTryCast
								Else
									Dim castExpressionSyntax1 As Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax = TryCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax)
									Dim bindingDiagnosticBag1 As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
									If (castExpressionSyntax1 IsNot Nothing) Then
										type = castExpressionSyntax1.Type
									Else
										type = node
									End If
									Binder.ReportDiagnostic(bindingDiagnosticBag1, type, ERRID.ERR_TryCastOfUnconstrainedTypeParam1, New [Object]() { targetType })
									boundTryCast = New Microsoft.CodeAnalysis.VisualBasic.BoundTryCast(node, argument, conversionKind, targetType, True)
									Return boundTryCast
								End If
							End If
						Label1:
							Me.WarnOnNarrowingConversionBetweenSealedClassAndAnInterface(conversionKind, argument.Syntax, typeSymbol, targetType, diagnostics)
							If (Not Microsoft.CodeAnalysis.VisualBasic.Conversions.NoConversion(conversionKind)) Then
								Dim constantValue As Microsoft.CodeAnalysis.ConstantValue = Microsoft.CodeAnalysis.VisualBasic.Conversions.TryFoldNothingReferenceConversion(argument, conversionKind, targetType)
								boundTryCast = New Microsoft.CodeAnalysis.VisualBasic.BoundTryCast(node, argument, conversionKind, constantValue, targetType, False)
							Else
								Me.ReportNoConversionError(argument.Syntax, typeSymbol, targetType, diagnostics, Nothing)
								boundTryCast = New Microsoft.CodeAnalysis.VisualBasic.BoundTryCast(node, argument, conversionKind, targetType, True)
							End If
						Else
							boundTryCast = New Microsoft.CodeAnalysis.VisualBasic.BoundTryCast(node, argument, conversionKind, targetType, True)
						End If
					Else
						boundTryCast = New Microsoft.CodeAnalysis.VisualBasic.BoundTryCast(node, argument, conversionKind, targetType, True)
					End If
				Else
					If (argument.Syntax <> node) Then
						argument = New Microsoft.CodeAnalysis.VisualBasic.BoundTryCast(node, argument, Microsoft.CodeAnalysis.VisualBasic.ConversionKind.Identity, targetType, False)
					End If
					boundTryCast = argument
				End If
			End If
			Return boundTryCast
		End Function

		<Conditional("DEBUG")>
		Private Shared Sub AssertDeclaredNames(ByVal declaredNames As HashSet(Of String), ByVal rangeVariables As ImmutableArray(Of RangeVariableSymbol))
		End Sub

		Protected Shared Function BadExpression(ByVal node As SyntaxNode, ByVal resultType As TypeSymbol) As BoundBadExpression
			Return New BoundBadExpression(node, LookupResultKind.Empty, ImmutableArray(Of Symbol).Empty, ImmutableArray(Of BoundExpression).Empty, resultType, True)
		End Function

		Private Shared Function BadExpression(ByVal node As SyntaxNode, ByVal expr As BoundExpression, ByVal resultType As TypeSymbol) As BoundBadExpression
			Return New BoundBadExpression(node, LookupResultKind.Empty, ImmutableArray(Of Symbol).Empty, ImmutableArray.Create(Of BoundExpression)(expr), resultType, True)
		End Function

		Private Shared Function BadExpression(ByVal node As SyntaxNode, ByVal expr As BoundExpression, ByVal resultKind As LookupResultKind, ByVal resultType As TypeSymbol) As BoundBadExpression
			Return New BoundBadExpression(node, resultKind, ImmutableArray(Of Symbol).Empty, ImmutableArray.Create(Of BoundExpression)(expr), resultType, True)
		End Function

		Private Shared Function BadExpression(ByVal node As SyntaxNode, ByVal exprs As ImmutableArray(Of BoundExpression), ByVal resultType As TypeSymbol) As BoundBadExpression
			Return New BoundBadExpression(node, LookupResultKind.Empty, ImmutableArray(Of Symbol).Empty, exprs, resultType, True)
		End Function

		Private Shared Function BadExpression(ByVal expr As BoundExpression) As BoundBadExpression
			Return Binder.BadExpression(LookupResultKind.Empty, expr)
		End Function

		Private Shared Function BadExpression(ByVal resultKind As LookupResultKind, ByVal wrappedExpression As BoundExpression) As Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression
			Dim boundBadExpression As Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression
			Dim boundBadExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression = TryCast(wrappedExpression, Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression)
			boundBadExpression = If(boundBadExpression1 Is Nothing, New Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression(wrappedExpression.Syntax, resultKind, ImmutableArray(Of Symbol).Empty, ImmutableArray.Create(Of BoundExpression)(wrappedExpression), wrappedExpression.Type, True), New Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression(boundBadExpression1.Syntax, resultKind, boundBadExpression1.Symbols, boundBadExpression1.ChildBoundNodes, boundBadExpression1.Type, True))
			Return boundBadExpression
		End Function

		Public Function BasesBeingResolved() As BasesBeingResolved
			Return Me._basesBeingResolved
		End Function

		Private Function BindAddRemoveHandlerStatement(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundAddRemoveHandlerStatement
			Dim boundRemoveHandlerStatement As BoundAddRemoveHandlerStatement
			Dim eventSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.EventSymbol = Nothing
			Dim boundEventAccess As Microsoft.CodeAnalysis.VisualBasic.BoundEventAccess = Nothing
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindEventAccess(node.EventExpression, diagnostics, boundEventAccess, eventSymbol)
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindValue(node.DelegateExpression, diagnostics, False)
			Dim flag As Boolean = node.Kind() = SyntaxKind.RemoveHandlerStatement
			If (flag AndAlso boundExpression1.GetMostEnclosedParenthesizedExpression().Kind = BoundKind.UnboundLambda) Then
				Binder.ReportDiagnostic(diagnostics, node.DelegateExpression, ERRID.WRN_LambdaPassedToRemoveHandler)
			End If
			Dim flag1 As Boolean = True
			If (eventSymbol IsNot Nothing) Then
				Dim methodSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol = If(node.Kind() = SyntaxKind.AddHandlerStatement, eventSymbol.AddMethod, eventSymbol.RemoveMethod)
				If (methodSymbol IsNot Nothing) Then
					Dim type As TypeSymbol = eventSymbol.Type
					boundExpression1 = Me.ApplyImplicitConversion(node.DelegateExpression, type, boundExpression1, diagnostics, False)
					If (flag AndAlso boundExpression1.Kind = BoundKind.DelegateCreationExpression AndAlso node.DelegateExpression.Kind() = SyntaxKind.AddressOfExpression AndAlso DirectCast(boundExpression1, BoundDelegateCreationExpression).RelaxationLambdaOpt IsNot Nothing) Then
						Binder.ReportDiagnostic(diagnostics, DirectCast(node.DelegateExpression, Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax).Operand, ERRID.WRN_RelDelegatePassedToRemoveHandler)
					End If
					flag1 = False
					If (methodSymbol = Me.ContainingMember AndAlso (methodSymbol.IsShared OrElse boundEventAccess.ReceiverOpt.IsMeReference())) Then
						Binder.ReportDiagnostic(diagnostics, node, ERRID.WRN_RecursiveAddHandlerCall, New [Object]() { node.AddHandlerOrRemoveHandlerKeyword.ToString(), eventSymbol.Name })
					End If
					If (type.IsDelegateType()) Then
						Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
						Dim accessThroughType As TypeSymbol = Me.GetAccessThroughType(boundEventAccess.ReceiverOpt)
						Dim basesBeingResolved As Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolved = New Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolved()
						If (Not Me.IsAccessible(methodSymbol, newCompoundUseSiteInfo, accessThroughType, basesBeingResolved)) Then
							Binder.ReportDiagnostic(diagnostics, node.EventExpression, Me.GetInaccessibleErrorInfo(methodSymbol))
						End If
						diagnostics.Add(node.EventExpression, newCompoundUseSiteInfo)
						Dim flag2 As Boolean = False
						If (eventSymbol.GetUseSiteInfo().DiagnosticInfo Is Nothing AndAlso Binder.ReportUseSite(diagnostics, node.EventExpression, methodSymbol.GetUseSiteInfo())) Then
							flag1 = True
						ElseIf (methodSymbol.ParameterCount <> 1 OrElse methodSymbol.Parameters(0).IsByRef) Then
							flag2 = True
						ElseIf (eventSymbol.IsWindowsRuntimeEvent) Then
							Dim wellKnownType As NamedTypeSymbol = Me.Compilation.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType.System_Runtime_InteropServices_WindowsRuntime_EventRegistrationToken)
							If (node.Kind() = SyntaxKind.AddHandlerStatement) Then
								If (Not methodSymbol.Parameters(0).Type.IsSameTypeIgnoringAll(type) OrElse Not methodSymbol.ReturnType.IsSameTypeIgnoringAll(wellKnownType)) Then
									flag2 = True
								End If
							ElseIf (Not methodSymbol.Parameters(0).Type.IsSameTypeIgnoringAll(wellKnownType) OrElse Not methodSymbol.IsSub) Then
								flag2 = True
							End If
						ElseIf (Not methodSymbol.Parameters(0).Type.IsSameTypeIgnoringAll(type)) Then
							flag2 = True
						End If
						If (flag2) Then
							If (eventSymbol.DeclaringCompilation <> Me.Compilation) Then
								Binder.ReportDiagnostic(diagnostics, node.EventExpression, ErrorFactory.ErrorInfo(ERRID.ERR_UnsupportedMethod1, New [Object]() { methodSymbol }))
							End If
							flag1 = True
						End If
					Else
						If (eventSymbol.DeclaringCompilation <> Me.Compilation AndAlso Not TypeOf type Is MissingMetadataTypeSymbol) Then
							Binder.ReportDiagnostic(diagnostics, node.EventExpression, ErrorFactory.ErrorInfo(ERRID.ERR_UnsupportedEvent1, New [Object]() { eventSymbol }))
						End If
						flag1 = True
					End If
				ElseIf (eventSymbol.DeclaringCompilation <> Me.Compilation) Then
					Binder.ReportDiagnostic(diagnostics, node.EventExpression, ErrorFactory.ErrorInfo(ERRID.ERR_UnsupportedEvent1, New [Object]() { eventSymbol }))
				End If
			End If
			If (node.Kind() <> SyntaxKind.AddHandlerStatement) Then
				boundRemoveHandlerStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundRemoveHandlerStatement(node, boundExpression, boundExpression1, flag1)
			Else
				boundRemoveHandlerStatement = New BoundAddHandlerStatement(node, boundExpression, boundExpression1, flag1)
			End If
			Return boundRemoveHandlerStatement
		End Function

		Private Function BindAddressOfExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundLateAddressOfOperator As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim unaryExpressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax = DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax)
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindExpression(unaryExpressionSyntax.Operand, True, False, False, diagnostics)
			If (boundExpression.Kind = BoundKind.LateMemberAccess) Then
				boundLateAddressOfOperator = New Microsoft.CodeAnalysis.VisualBasic.BoundLateAddressOfOperator(node, Me, DirectCast(boundExpression, BoundLateMemberAccess), boundExpression.Type, False)
			ElseIf (boundExpression.Kind = BoundKind.MethodGroup) Then
				Dim flag As Boolean = False
				Dim boundMethodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup = DirectCast(boundExpression, Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup)
				If (Binder.IsGroupOfConstructors(boundMethodGroup)) Then
					Binder.ReportDiagnostic(diagnostics, unaryExpressionSyntax.Operand, ERRID.ERR_InvalidConstructorCall)
					flag = True
				End If
				boundLateAddressOfOperator = New BoundAddressOfOperator(node, Me, diagnostics.AccumulatesDependencies, boundMethodGroup, flag)
			Else
				If (Not boundExpression.HasErrors) Then
					Binder.ReportDiagnostic(diagnostics, unaryExpressionSyntax.Operand, ERRID.ERR_AddressOfOperandNotMethod)
				End If
				boundLateAddressOfOperator = Binder.BadExpression(unaryExpressionSyntax, boundExpression, LookupResultKind.NotAValue, ErrorTypeSymbol.UnknownResultType)
			End If
			Return boundLateAddressOfOperator
		End Function

		Private Function BindAggregateClause(ByVal source As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase, ByVal aggregate As Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax, ByVal operatorsEnumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundAggregateClause
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundLambdaParameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol = Me.CreateQueryLambdaParameterSymbol(Binder.GetQueryLambdaParameterName(source.RangeVariables), 0, source.CompoundVariableType, aggregate, source.RangeVariables)
			Dim synthesizedLambdaSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaSymbol = Me.CreateQueryLambdaSymbol(LambdaUtilities.GetAggregateLambdaBody(aggregate), SynthesizedLambdaKind.AggregateQueryLambda, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol)(boundLambdaParameterSymbol))
			Dim queryLambdaBinder As Binder.QueryLambdaBinder = New Binder.QueryLambdaBinder(synthesizedLambdaSymbol, source.RangeVariables)
			Dim rangeVariableSymbols As ImmutableArray(Of RangeVariableSymbol) = New ImmutableArray(Of RangeVariableSymbol)()
			Dim boundQueryClauseBase As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase = Nothing
			Dim intoClauseDisallowGroupReferenceBinder As Binder.IntoClauseDisallowGroupReferenceBinder = Nothing
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = queryLambdaBinder.BindAggregateClauseFirstSelector(aggregate, operatorsEnumerator, source.RangeVariables, ImmutableArray(Of RangeVariableSymbol).Empty, rangeVariableSymbols, boundQueryClauseBase, intoClauseDisallowGroupReferenceBinder, diagnostics)
			Dim boundQueryLambda As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Binder.CreateBoundQueryLambda(synthesizedLambdaSymbol, source.RangeVariables, boundExpression1, False)
			synthesizedLambdaSymbol.SetQueryLambdaReturnType(boundExpression1.Type)
			boundQueryLambda.SetWasCompilerGenerated()
			If (Not source.Type.IsErrorType()) Then
				Dim discarded As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
				If (Binder.ShouldSuppressDiagnostics(boundQueryLambda)) Then
					discarded = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
				End If
				Dim boundExpressions As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundQueryLambda)
				Dim aggregateKeyword As Microsoft.CodeAnalysis.SyntaxToken = aggregate.AggregateKeyword
				boundExpression = Me.BindQueryOperatorCall(aggregate, source, "Select", boundExpressions, aggregateKeyword.Span, discarded)
			Else
				boundExpression = Binder.BadExpression(aggregate, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(source, boundQueryLambda), ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
			End If
			Return Me.CompleteAggregateClauseBinding(aggregate, operatorsEnumerator, source.RangeVariables, ImmutableArray(Of RangeVariableSymbol).Empty, boundExpression, queryLambdaBinder, rangeVariableSymbols, boundQueryLambda.Expression.Type, boundQueryClauseBase, intoClauseDisallowGroupReferenceBinder, diagnostics)
		End Function

		Private Function BindAggregateQueryExpression(ByVal query As Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax, ByVal operators As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundQueryExpression
			Dim unknownResultType As TypeSymbol
			Dim current As Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax = DirectCast(operators.Current, Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax)
			Dim flag As Boolean = operators.MoveNext()
			operators = current.AdditionalQueryOperators.GetEnumerator()
			Dim boundAggregateClause As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase = Me.BindCollectionRangeVariables(current, Nothing, current.Variables, operators, diagnostics)
			boundAggregateClause = Me.BindSubsequentQueryOperators(boundAggregateClause, operators, diagnostics)
			Dim aggregationVariables As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax) = current.AggregationVariables
			Dim count As Integer = aggregationVariables.Count
			If (count = 0) Then
				Dim intoClauseDisallowGroupReferenceBinder As Binder.IntoClauseDisallowGroupReferenceBinder = New Binder.IntoClauseDisallowGroupReferenceBinder(Me, boundAggregateClause, boundAggregateClause.RangeVariables, boundAggregateClause.CompoundVariableType, boundAggregateClause.RangeVariables)
				boundAggregateClause = New Microsoft.CodeAnalysis.VisualBasic.BoundAggregateClause(current, Nothing, Nothing, Binder.BadExpression(current, boundAggregateClause, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated(), ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol).Empty, ErrorTypeSymbol.UnknownResultType, ImmutableArray.Create(Of Binder)(intoClauseDisallowGroupReferenceBinder), ErrorTypeSymbol.UnknownResultType, False)
			ElseIf (count = 1) Then
				Dim intoClauseDisallowGroupReferenceBinder1 As Binder.IntoClauseDisallowGroupReferenceBinder = New Binder.IntoClauseDisallowGroupReferenceBinder(Me, boundAggregateClause, boundAggregateClause.RangeVariables, boundAggregateClause.CompoundVariableType, boundAggregateClause.RangeVariables)
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
				intoClauseDisallowGroupReferenceBinder1.BindAggregationRangeVariable(aggregationVariables(0), Nothing, boundExpression, diagnostics)
				boundAggregateClause = New Microsoft.CodeAnalysis.VisualBasic.BoundAggregateClause(current, Nothing, Nothing, boundExpression, ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol).Empty, boundExpression.Type, ImmutableArray.Create(Of Binder)(intoClauseDisallowGroupReferenceBinder1), boundExpression.Type, False)
			Else
				Dim strs As HashSet(Of String) = Binder.CreateSetOfDeclaredNames()
				Dim boundExpressionArray(count - 1 + 1 - 1) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
				Dim anonymousTypeField(CInt(boundExpressionArray.Length) - 1 + 1 - 1) As Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField
				Dim boundRValuePlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder = (New Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder(current, boundAggregateClause.Type)).MakeCompilerGenerated()
				Dim intoClauseDisallowGroupReferenceBinder2 As Binder.IntoClauseDisallowGroupReferenceBinder = New Binder.IntoClauseDisallowGroupReferenceBinder(Me, boundRValuePlaceholder, boundAggregateClause.RangeVariables, boundAggregateClause.CompoundVariableType, boundAggregateClause.RangeVariables)
				Dim num As Integer = count - 1
				Dim num1 As Integer = 0
				Do
					Dim rangeVariableSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol = intoClauseDisallowGroupReferenceBinder2.BindAggregationRangeVariable(aggregationVariables(num1), strs, boundExpressionArray(num1), diagnostics)
					anonymousTypeField(num1) = New Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField(rangeVariableSymbol.Name, rangeVariableSymbol.Type, rangeVariableSymbol.Syntax.GetLocation(), True)
					num1 = num1 + 1
				Loop While num1 <= num
				Dim anonymousTypeFields As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField) = Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField)(anonymousTypeField)
				Dim intoKeyword As Microsoft.CodeAnalysis.SyntaxToken = current.IntoKeyword
				Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindAnonymousObjectCreationExpression(current, New AnonymousTypeDescriptor(anonymousTypeFields, intoKeyword.GetLocation(), True), Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpressionArray), diagnostics).MakeCompilerGenerated()
				boundAggregateClause = New Microsoft.CodeAnalysis.VisualBasic.BoundAggregateClause(current, boundAggregateClause, boundRValuePlaceholder, boundExpression1, ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol).Empty, boundExpression1.Type, ImmutableArray.Create(Of Binder)(intoClauseDisallowGroupReferenceBinder2), boundExpression1.Type, False)
			End If
			Dim queryExpressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax = query
			Dim boundQueryClauseBase As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase = boundAggregateClause
			If (flag) Then
				unknownResultType = ErrorTypeSymbol.UnknownResultType
			Else
				unknownResultType = boundAggregateClause.Type
			End If
			Return New BoundQueryExpression(queryExpressionSyntax, boundQueryClauseBase, unknownResultType, flag)
		End Function

		Private Function BindAnonymousObjectCreationExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Return Binder.AnonymousTypeCreationBinder.BindAnonymousObjectInitializer(Me, node, node.Initializer, node.NewKeyword, diagnostics)
		End Function

		Private Function BindAnonymousObjectCreationExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal typeDescr As AnonymousTypeDescriptor, ByVal initExpressions As ImmutableArray(Of BoundExpression), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim enumerator As ImmutableArray(Of AnonymousTypeField).Enumerator = typeDescr.Fields.GetEnumerator()
			While enumerator.MoveNext()
				Dim current As AnonymousTypeField = enumerator.Current
				Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
				If (Not current.Type.IsRestrictedTypeOrArrayType(typeSymbol)) Then
					Continue While
				End If
				Binder.ReportDiagnostic(diagnostics, current.Location, ERRID.ERR_RestrictedType1, New [Object]() { typeSymbol })
			End While
			Return Me.CreateAnonymousObjectCreationExpression(node, typeDescr, initExpressions, False)
		End Function

		Private Sub BindArgumentsAndNames(ByVal argumentListOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax, ByRef boundArguments As ImmutableArray(Of BoundExpression), ByRef argumentNames As ImmutableArray(Of String), ByRef argumentNamesLocations As ImmutableArray(Of Location), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Dim argumentSyntaxes As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax) = New ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax)()
			If (argumentListOpt IsNot Nothing) Then
				Dim arguments As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax) = argumentListOpt.Arguments
				Dim item(arguments.Count - 1 + 1 - 1) As Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax
				Dim length As Integer = CInt(item.Length) - 1
				Dim num As Integer = 0
				Do
					item(num) = arguments(num)
					num = num + 1
				Loop While num <= length
				argumentSyntaxes = Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax)(item)
			End If
			Me.BindArgumentsAndNames(argumentSyntaxes, boundArguments, argumentNames, argumentNamesLocations, diagnostics)
		End Sub

		Private Sub BindArgumentsAndNames(ByVal arguments As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax), ByRef boundArguments As ImmutableArray(Of BoundExpression), ByRef argumentNames As ImmutableArray(Of String), ByRef argumentNamesLocations As ImmutableArray(Of Location), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			If (arguments.IsDefaultOrEmpty) Then
				boundArguments = Binder.s_noArguments
				argumentNames = New ImmutableArray(Of String)()
				argumentNamesLocations = New ImmutableArray(Of Location)()
				Return
			End If
			Dim instance As ArrayBuilder(Of BoundExpression) = ArrayBuilder(Of BoundExpression).GetInstance()
			Dim strs As ArrayBuilder(Of String) = Nothing
			Dim locations As ArrayBuilder(Of Location) = Nothing
			Dim num As Integer = 0
			Dim enumerator As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax).Enumerator = arguments.GetEnumerator()
			While enumerator.MoveNext()
				Dim current As Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax = enumerator.Current
				Select Case current.Kind()
					Case SyntaxKind.OmittedArgument
						instance.Add(New BoundOmittedArgument(current, Nothing))
						If (strs Is Nothing) Then
							Exit Select
						End If
						strs.Add(Nothing)
						locations.Add(Nothing)
						Exit Select
					Case SyntaxKind.SimpleArgument
						Dim simpleArgumentSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax = DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax)
						instance.Add(Me.BindValue(simpleArgumentSyntax.Expression, diagnostics, False))
						If (Not simpleArgumentSyntax.IsNamed) Then
							If (strs Is Nothing) Then
								Exit Select
							End If
							strs.Add(Nothing)
							locations.Add(Nothing)
							Exit Select
						Else
							If (strs Is Nothing) Then
								strs = ArrayBuilder(Of String).GetInstance()
								locations = ArrayBuilder(Of Location).GetInstance()
								Dim num1 As Integer = num - 1
								For i As Integer = 0 To num1
									strs.Add(Nothing)
									locations.Add(Nothing)
								Next

							End If
							Dim identifier As Microsoft.CodeAnalysis.SyntaxToken = simpleArgumentSyntax.NameColonEquals.Name.Identifier
							If (identifier.ValueText.Length <= 0) Then
								strs.Add(Nothing)
							Else
								strs.Add(identifier.ValueText)
							End If
							locations.Add(identifier.GetLocation())
							Exit Select
						End If
					Case SyntaxKind.EmptyStatement Or SyntaxKind.EndUsingStatement Or SyntaxKind.EndSelectStatement Or SyntaxKind.EndEnumStatement Or SyntaxKind.EndClassStatement Or SyntaxKind.EndNamespaceStatement Or SyntaxKind.EndFunctionStatement Or SyntaxKind.EndSetStatement Or SyntaxKind.EndOperatorStatement Or SyntaxKind.EndAddHandlerStatement Or SyntaxKind.EndRaiseEventStatement Or SyntaxKind.EndTryStatement Or SyntaxKind.TypeParameterList Or SyntaxKind.TypeParameterSingleConstraintClause Or SyntaxKind.NewConstraint Or SyntaxKind.StructureConstraint Or SyntaxKind.EnumMemberDeclaration Or SyntaxKind.FunctionBlock Or SyntaxKind.OperatorBlock Or SyntaxKind.SetAccessorBlock Or SyntaxKind.RemoveHandlerAccessorBlock Or SyntaxKind.PropertyBlock Or SyntaxKind.ParameterList Or SyntaxKind.FunctionStatement Or SyntaxKind.RightShiftAssignmentStatement Or SyntaxKind.MidExpression Or SyntaxKind.AddHandlerStatement Or SyntaxKind.RaiseEventStatement Or SyntaxKind.ReDimStatement Or SyntaxKind.RedimClause Or SyntaxKind.CharacterLiteralExpression Or SyntaxKind.FalseLiteralExpression Or SyntaxKind.DateLiteralExpression Or SyntaxKind.NothingLiteralExpression Or SyntaxKind.MeExpression Or SyntaxKind.MyClassExpression Or SyntaxKind.TypeOfIsExpression Or SyntaxKind.NotEqualsExpression Or SyntaxKind.LessThanOrEqualExpression Or SyntaxKind.GreaterThanExpression Or SyntaxKind.IsNotExpression Or SyntaxKind.OrExpression Or SyntaxKind.AndExpression Or SyntaxKind.AndAlsoExpression Or SyntaxKind.UnaryMinusExpression Or SyntaxKind.AddressOfExpression Or SyntaxKind.TernaryConditionalExpression Or SyntaxKind.SingleLineSubLambdaExpression Or SyntaxKind.MultiLineSubLambdaExpression Or SyntaxKind.FunctionLambdaHeader Or SyntaxKind.OmittedArgument
						Throw ExceptionUtilities.UnexpectedValue(current.Kind())
					Case SyntaxKind.RangeArgument
						Dim rangeArgumentSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax = DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax)
						Me.CheckRangeArgumentLowerBound(rangeArgumentSyntax, diagnostics)
						instance.Add(Me.BindValue(rangeArgumentSyntax.UpperBound, diagnostics, False))
						If (strs Is Nothing) Then
							Exit Select
						End If
						strs.Add(Nothing)
						locations.Add(Nothing)
						Exit Select
					Case Else
						Throw ExceptionUtilities.UnexpectedValue(current.Kind())
				End Select
				num = num + 1
			End While
			boundArguments = instance.ToImmutableAndFree()
			argumentNames = If(strs Is Nothing, New ImmutableArray(Of String)(), strs.ToImmutableAndFree())
			argumentNamesLocations = If(locations Is Nothing, New ImmutableArray(Of Location)(), locations.ToImmutableAndFree())
		End Sub

		Private Function BindArrayAccess(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax, ByVal expr As BoundExpression, ByVal boundArguments As ImmutableArray(Of BoundExpression), ByVal argumentNames As ImmutableArray(Of String), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim boundArrayAccess As BoundExpression
			Dim eRRID As Microsoft.CodeAnalysis.VisualBasic.ERRID
			If (expr.IsLValue) Then
				expr = expr.MakeRValue()
			End If
			Dim instance As ArrayBuilder(Of BoundExpression) = ArrayBuilder(Of BoundExpression).GetInstance(boundArguments.Length)
			Dim specialType As NamedTypeSymbol = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Int32, node.ArgumentList, diagnostics)
			Dim enumerator As ImmutableArray(Of BoundExpression).Enumerator = boundArguments.GetEnumerator()
			While enumerator.MoveNext()
				Dim current As BoundExpression = enumerator.Current
				instance.Add(Me.ApplyImplicitConversion(current.Syntax, specialType, current, diagnostics, False))
			End While
			boundArguments = instance.ToImmutableAndFree()
			If (expr.Type IsNot Nothing) Then
				If (Not argumentNames.IsDefault AndAlso argumentNames.Length > 0) Then
					Binder.ReportDiagnostic(diagnostics, node, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_NamedSubscript)
				End If
				Dim type As ArrayTypeSymbol = DirectCast(expr.Type, ArrayTypeSymbol)
				Dim rank As Integer = type.Rank
				If (boundArguments.Length = type.Rank) Then
					boundArrayAccess = New Microsoft.CodeAnalysis.VisualBasic.BoundArrayAccess(node, expr, boundArguments, type.ElementType, False)
				Else
					eRRID = If(boundArguments.Length <= type.Rank, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_TooFewIndices, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_TooManyIndices)
					Binder.ReportDiagnostic(diagnostics, node.ArgumentList, eRRID, New [Object]() { node.ToString() })
					boundArrayAccess = New Microsoft.CodeAnalysis.VisualBasic.BoundArrayAccess(node, expr, boundArguments, type.ElementType, True)
				End If
			Else
				boundArrayAccess = New Microsoft.CodeAnalysis.VisualBasic.BoundArrayAccess(node, expr, boundArguments, Nothing, True)
			End If
			Return boundArrayAccess
		End Function

		Private Function BindArrayBounds(ByVal arrayBoundsOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal knownSizes As Binder.DimensionSize() = Nothing, Optional ByVal errorOnEmptyBound As Boolean = False) As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)
			Dim immutableAndFree As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)
			If (arrayBoundsOpt IsNot Nothing) Then
				Dim arguments As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax) = arrayBoundsOpt.Arguments
				Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance()
				Dim specialType As NamedTypeSymbol = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Int32, arrayBoundsOpt, diagnostics)
				Dim enumerator As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax).Enumerator = arguments.GetEnumerator()
				While enumerator.MoveNext()
					Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = enumerator.Current.Kind()
					If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleArgument AndAlso syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RangeArgument) Then
						Continue While
					End If
					errorOnEmptyBound = True
					Exit While
				End While
				Dim count As Integer = arguments.Count - 1
				Dim num As Integer = 0
				Do
					Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
					Dim expression As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = Nothing
					Dim item As Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax = arguments(num)
					Select Case item.Kind()
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OmittedArgument
							If (Not errorOnEmptyBound) Then
								GoTo Label0
							End If
							Binder.ReportDiagnostic(diagnostics, item, ERRID.ERR_MissingSubscript)
							GoTo Label1
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleArgument
							Dim simpleArgumentSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax = DirectCast(item, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax)
							If (simpleArgumentSyntax.NameColonEquals IsNot Nothing) Then
								Binder.ReportDiagnostic(diagnostics, item, ERRID.ERR_NamedSubscript)
							End If
							expression = simpleArgumentSyntax.Expression
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndUsingStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSelectStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndEnumStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndClassStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndNamespaceStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndOperatorStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndAddHandlerStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndRaiseEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndTryStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeParameterList Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeParameterSingleConstraintClause Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NewConstraint Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.StructureConstraint Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EnumMemberDeclaration Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OperatorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SetAccessorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RemoveHandlerAccessorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PropertyBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ParameterList Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RightShiftAssignmentStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MidExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddHandlerStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RaiseEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ReDimStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RedimClause Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CharacterLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FalseLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DateLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NothingLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MeExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MyClassExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeOfIsExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotEqualsExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LessThanOrEqualExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GreaterThanExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IsNotExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OrExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AndExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AndAlsoExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UnaryMinusExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddressOfExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TernaryConditionalExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineSubLambdaExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MultiLineSubLambdaExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionLambdaHeader Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OmittedArgument
						Label1:
							boundExpression = Binder.BadExpression(item, ErrorTypeSymbol.UnknownResultType)
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RangeArgument
							Dim rangeArgumentSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax = DirectCast(item, Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax)
							Me.CheckRangeArgumentLowerBound(rangeArgumentSyntax, diagnostics)
							expression = rangeArgumentSyntax.UpperBound
							Exit Select
						Case Else
							GoTo Label1
					End Select
					If (expression IsNot Nothing) Then
						boundExpression = Me.BindValue(expression, diagnostics, False)
						boundExpression = Me.ApplyImplicitConversion(expression, specialType, boundExpression, diagnostics, False)
					End If
					Dim constantValueOpt As Microsoft.CodeAnalysis.ConstantValue = boundExpression.ConstantValueOpt
					If (constantValueOpt IsNot Nothing AndAlso Not constantValueOpt.IsBad AndAlso constantValueOpt.Int32Value < -1) Then
						Binder.ReportDiagnostic(diagnostics, item, ERRID.ERR_NegativeArraySize)
					End If
					Dim boundLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundLiteral = New Microsoft.CodeAnalysis.VisualBasic.BoundLiteral(item, Microsoft.CodeAnalysis.ConstantValue.Create(1), specialType)
					boundLiteral.SetWasCompilerGenerated()
					Dim flag As Boolean = False
					Dim flag1 As Boolean = False
					Dim flag2 As Boolean = False
					Dim constantValue As Microsoft.CodeAnalysis.ConstantValue = OverloadResolution.TryFoldConstantBinaryOperator(BinaryOperatorKind.Add, boundExpression, boundLiteral, specialType, flag, flag1, flag2)
					If (knownSizes IsNot Nothing) Then
						If (constantValue Is Nothing) Then
							knownSizes(num) = Binder.DimensionSize.VariableSize()
						Else
							knownSizes(num) = Binder.DimensionSize.ConstantSize(constantValue.Int32Value)
						End If
					End If
					Dim boundBinaryOperator As Microsoft.CodeAnalysis.VisualBasic.BoundBinaryOperator = New Microsoft.CodeAnalysis.VisualBasic.BoundBinaryOperator(item, BinaryOperatorKind.Add, boundExpression, boundLiteral, Me.CheckOverflow, constantValue, specialType, False)
					boundBinaryOperator.SetWasCompilerGenerated()
					instance.Add(boundBinaryOperator)
				Label0:
					num = num + 1
				Loop While num <= count
				immutableAndFree = instance.ToImmutableAndFree()
			Else
				immutableAndFree = Binder.s_noArguments
			End If
			Return immutableAndFree
		End Function

		Private Function BindArrayCreationExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Me.BindTypeSyntax(node.Type, diagnostics, False, False, False)
			Dim arrayBounds As Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax = node.ArrayBounds
			Dim boundExpressions As ImmutableArray(Of BoundExpression) = New ImmutableArray(Of BoundExpression)()
			Dim arrayTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol = Me.CreateArrayOf(typeSymbol, node.RankSpecifiers, arrayBounds, diagnostics)
			Dim dimensionSizeArray(arrayTypeSymbol.Rank - 1 + 1 - 1) As Binder.DimensionSize
			boundExpressions = Me.BindArrayBounds(arrayBounds, diagnostics, dimensionSizeArray, False)
			Dim boundArrayInitialization As Microsoft.CodeAnalysis.VisualBasic.BoundArrayInitialization = Me.BindArrayInitializerList(node.Initializer, arrayTypeSymbol, dimensionSizeArray, diagnostics)
			If (boundExpressions.Length = 0) Then
				boundExpressions = Me.CreateArrayBounds(node, dimensionSizeArray, diagnostics)
			End If
			Return New BoundArrayCreation(node, boundExpressions, boundArrayInitialization, arrayTypeSymbol, False)
		End Function

		Public Sub BindArrayFieldImplicitInitializer(ByVal fieldSymbol As SourceFieldSymbol, ByVal boundInitializers As ArrayBuilder(Of BoundInitializer), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Dim boundMeReference As Microsoft.CodeAnalysis.VisualBasic.BoundMeReference
			Dim syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax = DirectCast(fieldSymbol.Syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax)
			Dim boundExpressions As ImmutableArray(Of BoundExpression) = Me.BindArrayBounds(syntax.ArrayBounds, diagnostics, Nothing, False)
			Dim boundArrayCreation As Microsoft.CodeAnalysis.VisualBasic.BoundArrayCreation = New Microsoft.CodeAnalysis.VisualBasic.BoundArrayCreation(syntax, boundExpressions, Nothing, fieldSymbol.Type, False)
			boundArrayCreation.SetWasCompilerGenerated()
			If (fieldSymbol.IsShared) Then
				boundMeReference = Nothing
			Else
				boundMeReference = Me.CreateMeReference(syntax, True)
			End If
			Dim boundMeReference1 As Microsoft.CodeAnalysis.VisualBasic.BoundMeReference = boundMeReference
			Dim boundFieldAccess As Microsoft.CodeAnalysis.VisualBasic.BoundFieldAccess = New Microsoft.CodeAnalysis.VisualBasic.BoundFieldAccess(syntax, boundMeReference1, fieldSymbol, True, fieldSymbol.Type, False)
			boundFieldAccess.SetWasCompilerGenerated()
			Dim boundFieldInitializer As Microsoft.CodeAnalysis.VisualBasic.BoundFieldInitializer = New Microsoft.CodeAnalysis.VisualBasic.BoundFieldInitializer(syntax, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol)(fieldSymbol), boundFieldAccess, boundArrayCreation, False)
			boundInitializers.Add(boundFieldInitializer)
		End Sub

		Private Function BindArrayInitializerList(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax, ByVal type As ArrayTypeSymbol, ByVal knownSizes As Binder.DimensionSize(), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundArrayInitialization
			Return Me.BindArrayInitializerList(node, type, knownSizes, 1, Nothing, diagnostics)
		End Function

		Private Function BindArrayInitializerList(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax, ByVal knownSizes As Binder.DimensionSize(), <Out> ByRef hasDominantType As Boolean, <Out> ByRef numberOfCandidates As Integer, <Out> ByRef inferredElementType As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundArrayInitialization
			Dim instance As ArrayBuilder(Of BoundExpression) = ArrayBuilder(Of BoundExpression).GetInstance()
			Dim boundArrayInitialization As Microsoft.CodeAnalysis.VisualBasic.BoundArrayInitialization = Me.BindArrayInitializerList(node, DirectCast(Nothing, ArrayTypeSymbol), knownSizes, 1, instance, diagnostics)
			Dim inferenceErrorReason As InferenceErrorReasons = InferenceErrorReasons.Other
			inferredElementType = Me.InferDominantTypeOfExpressions(node, instance, diagnostics, numberOfCandidates, inferenceErrorReason)
			If (inferredElementType IsNot Nothing) Then
				hasDominantType = True
			Else
				inferredElementType = Me.GetSpecialType(SpecialType.System_Object, node, diagnostics)
				hasDominantType = False
			End If
			instance.Free()
			Return boundArrayInitialization
		End Function

		Private Function BindArrayInitializerList(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax, ByVal type As ArrayTypeSymbol, ByVal knownSizes As Binder.DimensionSize(), ByVal dimension As Integer, ByVal allInitializers As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundArrayInitialization
			Dim boundArrayInitialization As Microsoft.CodeAnalysis.VisualBasic.BoundArrayInitialization
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim elementType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance()
			If (dimension <> 1) Then
				typeSymbol = Nothing
			Else
				typeSymbol = type
			End If
			Dim length As Integer = CInt(knownSizes.Length)
			If (dimension <> 1 OrElse node.Initializers.Count <> 0) Then
				If (dimension <> length) Then
					Dim enumerator As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax).Enumerator = node.Initializers.GetEnumerator()
					While enumerator.MoveNext()
						Dim current As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = enumerator.Current
						Dim boundArrayInitialization1 As Microsoft.CodeAnalysis.VisualBasic.BoundArrayInitialization = Nothing
						If (current.Kind() <> SyntaxKind.CollectionInitializer) Then
							Binder.ReportDiagnostic(diagnostics, current, ERRID.ERR_ArrayInitializerTooFewDimensions)
							boundArrayInitialization1 = New Microsoft.CodeAnalysis.VisualBasic.BoundArrayInitialization(current, ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty, typeSymbol, True)
						Else
							boundArrayInitialization1 = Me.BindArrayInitializerList(DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax), type, knownSizes, dimension + 1, allInitializers, diagnostics)
						End If
						instance.Add(boundArrayInitialization1)
					End While
				Else
					If (type IsNot Nothing) Then
						elementType = type.ElementType
					Else
						elementType = Nothing
					End If
					Dim typeSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = elementType
					Dim enumerator1 As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax).Enumerator = node.Initializers.GetEnumerator()
					While enumerator1.MoveNext()
						Dim expressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = enumerator1.Current
						If (expressionSyntax.Kind() = SyntaxKind.CollectionInitializer) Then
							boundExpression = Binder.ReportDiagnosticAndProduceBadExpression(diagnostics, expressionSyntax, ERRID.ERR_ArrayInitializerTooManyDimensions)
						Else
							boundExpression = Me.BindValue(expressionSyntax, diagnostics, False)
							If (typeSymbol1 IsNot Nothing) Then
								boundExpression = Me.ApplyImplicitConversion(expressionSyntax, typeSymbol1, boundExpression, diagnostics, False)
							End If
						End If
						instance.Add(boundExpression)
						If (allInitializers Is Nothing) Then
							Continue While
						End If
						allInitializers.Add(boundExpression)
					End While
				End If
				Dim dimensionSize As Binder.DimensionSize = knownSizes(dimension - 1)
				If (dimensionSize.Kind = Binder.DimensionSize.SizeKind.Unknown) Then
					knownSizes(dimension - 1) = Binder.DimensionSize.ConstantSize(instance.Count)
				ElseIf (dimensionSize.Kind = Binder.DimensionSize.SizeKind.NotConstant) Then
					Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_ArrayInitializerForNonConstDim)
					boundArrayInitialization = New Microsoft.CodeAnalysis.VisualBasic.BoundArrayInitialization(node, instance.ToImmutableAndFree(), typeSymbol, True)
					Return boundArrayInitialization
				ElseIf (dimensionSize.Size >= instance.Count) Then
					If (dimensionSize.Size <= instance.Count) Then
						boundArrayInitialization = New Microsoft.CodeAnalysis.VisualBasic.BoundArrayInitialization(node, instance.ToImmutableAndFree(), typeSymbol, False)
						Return boundArrayInitialization
					End If
					Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_InitializerTooFewElements1, New [Object]() { dimensionSize.Size - instance.Count })
					boundArrayInitialization = New Microsoft.CodeAnalysis.VisualBasic.BoundArrayInitialization(node, instance.ToImmutableAndFree(), typeSymbol, True)
					Return boundArrayInitialization
				Else
					Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_InitializerTooManyElements1, New [Object]() { instance.Count - dimensionSize.Size })
					boundArrayInitialization = New Microsoft.CodeAnalysis.VisualBasic.BoundArrayInitialization(node, instance.ToImmutableAndFree(), typeSymbol, True)
					Return boundArrayInitialization
				End If
			End If
			boundArrayInitialization = New Microsoft.CodeAnalysis.VisualBasic.BoundArrayInitialization(node, instance.ToImmutableAndFree(), typeSymbol, False)
			Return boundArrayInitialization
		End Function

		Private Function BindArrayLiteralExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim flag As Boolean
			Dim num As Integer
			Dim dimensionSizeArray(Binder.ComputeArrayLiteralRank(node) - 1 + 1 - 1) As Binder.DimensionSize
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
			Dim boundArrayInitialization As Microsoft.CodeAnalysis.VisualBasic.BoundArrayInitialization = Me.BindArrayInitializerList(node, dimensionSizeArray, flag, num, typeSymbol, diagnostics)
			boundArrayInitialization.SetWasCompilerGenerated()
			Dim customModifiers As ImmutableArray(Of CustomModifier) = New ImmutableArray(Of CustomModifier)()
			Dim arrayTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol = Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.CreateVBArray(typeSymbol, customModifiers, CInt(dimensionSizeArray.Length), Me.Compilation)
			Dim boundExpressions As ImmutableArray(Of BoundExpression) = Me.CreateArrayBounds(node, dimensionSizeArray, diagnostics)
			Return New BoundArrayLiteral(node, flag, num, arrayTypeSymbol, boundExpressions, boundArrayInitialization, Me, False)
		End Function

		Private Function BindAssignment(ByVal node As SyntaxNode, ByVal op1 As BoundExpression, ByVal op2 As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundAssignmentOperator
			Dim flag As Boolean = False
			op1 = Me.AdjustAssignmentTarget(node, op1, diagnostics, flag)
			Dim type As TypeSymbol = op1.Type
			If (type Is Nothing) Then
				op2 = Me.MakeRValueAndIgnoreDiagnostics(op2)
			Else
				op2 = Me.ApplyImplicitConversion(op2.Syntax, type, op2, diagnostics, False)
			End If
			Return New BoundAssignmentOperator(node, op1, op2, False, flag)
		End Function

		Private Function BindAssignmentStatement(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpressionStatement
			Dim boundAssignmentOperator As Microsoft.CodeAnalysis.VisualBasic.BoundAssignmentOperator
			Dim binaryOperatorKind As Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind
			Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindAssignmentTarget(node.Left, diagnostics)
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindValue(node.Right, diagnostics, False)
			If (Not boundExpression.HasErrors AndAlso Not boundExpression1.HasErrors) Then
				If (node.Kind() <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleAssignmentStatement) Then
					Select Case node.Kind()
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddAssignmentStatement
							binaryOperatorKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.Add
							syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PlusToken
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SubtractAssignmentStatement
							binaryOperatorKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.Subtract
							syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MinusToken
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MultiplyAssignmentStatement
							binaryOperatorKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.Multiply
							syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AsteriskToken
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DivideAssignmentStatement
							binaryOperatorKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.Divide
							syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SlashToken
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IntegerDivideAssignmentStatement
							binaryOperatorKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.IntegerDivide
							syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.BackslashToken
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExponentiateAssignmentStatement
							binaryOperatorKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.Power
							syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CaretToken
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LeftShiftAssignmentStatement
							binaryOperatorKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.LeftShift
							syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LessThanLessThanToken
							Exit Select
						Case 256
						Case 257
							Throw ExceptionUtilities.UnexpectedValue(node.Kind())
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RightShiftAssignmentStatement
							binaryOperatorKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.RightShift
							syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GreaterThanGreaterThanToken
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ConcatenateAssignmentStatement
							binaryOperatorKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.Concatenate
							syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AmpersandToken
							Exit Select
						Case Else
							Throw ExceptionUtilities.UnexpectedValue(node.Kind())
					End Select
					boundAssignmentOperator = Me.BindCompoundAssignment(node, boundExpression, boundExpression1, syntaxKind, binaryOperatorKind, diagnostics)
				Else
					boundAssignmentOperator = Me.BindAssignment(node, boundExpression, boundExpression1, diagnostics)
				End If
			ElseIf (boundExpression.HasErrors OrElse node.Kind() <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleAssignmentStatement) Then
				boundExpression1 = Me.MakeRValueAndIgnoreDiagnostics(boundExpression1)
				boundAssignmentOperator = New Microsoft.CodeAnalysis.VisualBasic.BoundAssignmentOperator(node, boundExpression, boundExpression1, False, boundExpression.Type, True)
			Else
				boundAssignmentOperator = New Microsoft.CodeAnalysis.VisualBasic.BoundAssignmentOperator(node, boundExpression, Me.ApplyImplicitConversion(node.Right, boundExpression.Type, boundExpression1, diagnostics, False), False, boundExpression.Type, True)
			End If
			Return New BoundExpressionStatement(node, boundAssignmentOperator.MakeCompilerGenerated(), False)
		End Function

		Private Function BindAssignmentTarget(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindExpression(node, diagnostics)
			Return Me.BindAssignmentTarget(node, boundExpression, diagnostics)
		End Function

		Private Function BindAssignmentTarget(ByVal node As SyntaxNode, ByVal expression As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			expression = Me.ReclassifyAsValue(expression, diagnostics)
			If (Not Binder.IsValidAssignmentTarget(expression)) Then
				If (Not expression.HasErrors) Then
					Binder.ReportAssignmentToRValue(expression, diagnostics)
				End If
				expression = Binder.BadExpression(node, expression, LookupResultKind.NotAVariable, ErrorTypeSymbol.UnknownResultType)
			ElseIf (expression.Kind = BoundKind.LateInvocation) Then
				Dim boundLateInvocation As Microsoft.CodeAnalysis.VisualBasic.BoundLateInvocation = DirectCast(expression, Microsoft.CodeAnalysis.VisualBasic.BoundLateInvocation)
				If (Not boundLateInvocation.ArgumentsOpt.IsEmpty) Then
					Dim argumentsOpt As ImmutableArray(Of BoundExpression) = boundLateInvocation.ArgumentsOpt
					Dim boundExpressionArray(argumentsOpt.Length - 1 + 1 - 1) As BoundExpression
					Dim length As Integer = CInt(boundExpressionArray.Length) - 1
					Dim num As Integer = 0
					Do
						argumentsOpt = boundLateInvocation.ArgumentsOpt
						boundExpressionArray(num) = Me.MakeRValue(argumentsOpt(num), diagnostics)
						num = num + 1
					Loop While num <= length
					expression = boundLateInvocation.Update(boundLateInvocation.Member, Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of BoundExpression)(boundExpressionArray), boundLateInvocation.ArgumentNamesOpt, boundLateInvocation.AccessKind, boundLateInvocation.MethodOrPropertyGroupOpt, boundLateInvocation.Type)
				End If
			End If
			Return expression
		End Function

		Friend Function BindAttribute(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundAttribute
			Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = DirectCast(Me.BindTypeSyntax(node.Name, diagnostics, False, False, False), Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)
			Return Me.BindAttribute(node, namedTypeSymbol, diagnostics)
		End Function

		Friend Function BindAttribute(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax, ByVal type As NamedTypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundAttribute
			Dim item As NamedTypeSymbol = type
			Dim resultKind As LookupResultKind = LookupResultKind.Good
			If (type.IsErrorType()) Then
				Dim errorTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.ErrorTypeSymbol = DirectCast(type, Microsoft.CodeAnalysis.VisualBasic.Symbols.ErrorTypeSymbol)
				resultKind = errorTypeSymbol.ResultKind
				If (errorTypeSymbol.CandidateSymbols.Length = 1 AndAlso errorTypeSymbol.CandidateSymbols(0).Kind = SymbolKind.NamedType) Then
					item = DirectCast(errorTypeSymbol.CandidateSymbols(0), NamedTypeSymbol)
				End If
			End If
			Dim argumentList As Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax = node.ArgumentList
			Dim underlyingSymbol As MethodSymbol = Nothing
			Dim analyzedAttributeArgument As Binder.AnalyzedAttributeArguments = Me.BindAttributeArguments(item, argumentList, diagnostics)
			Dim item1 As ImmutableArray(Of BoundExpression) = analyzedAttributeArgument.positionalArguments
			Dim boundExpressions As ImmutableArray(Of BoundExpression) = analyzedAttributeArgument.namedArguments
			If (Not item.IsErrorType()) Then
				Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
				Dim accessibleConstructors As ImmutableArray(Of MethodSymbol) = Me.GetAccessibleConstructors(item, newCompoundUseSiteInfo)
				If (accessibleConstructors.Length <> 0) Then
					Dim boundMethodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup = New Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup(node.Name, Nothing, accessibleConstructors, LookupResultKind.Good, Nothing, QualificationKind.QualifiedViaTypeName, False)
					Dim strs As ImmutableArray(Of String) = New ImmutableArray(Of String)()
					Dim overloadResolutionResult As OverloadResolution.OverloadResolutionResult = OverloadResolution.MethodInvocationOverloadResolution(boundMethodGroup, item1, strs, Me, node.Name, newCompoundUseSiteInfo, False, Nothing, Nothing, True, False, False)
					If (diagnostics.Add(node.Name, newCompoundUseSiteInfo)) Then
						diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
					End If
					If (overloadResolutionResult.BestResult.HasValue) Then
						Dim value As OverloadResolution.CandidateAnalysisResult = overloadResolutionResult.BestResult.Value
						underlyingSymbol = DirectCast(value.Candidate.UnderlyingSymbol, MethodSymbol)
						Dim flag As Boolean = False
						Me.ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagnostics, underlyingSymbol, node)
						Dim enumerator As ImmutableArray(Of ParameterSymbol).Enumerator = underlyingSymbol.Parameters.GetEnumerator()
						While enumerator.MoveNext()
							Dim current As ParameterSymbol = enumerator.Current
							If (Not Me.IsValidTypeForAttributeArgument(current.Type)) Then
								flag = True
								Binder.ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_BadAttributeConstructor1, New [Object]() { current.Type })
							ElseIf (current.IsByRef) Then
								flag = True
								Binder.ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_BadAttributeConstructor2, New [Object]() { current.Type })
							End If
							If (current.Type.DigThroughArrayType().DeclaredAccessibility = Accessibility.[Public]) Then
								Dim containingType As NamedTypeSymbol = current.Type.ContainingType
								While containingType IsNot Nothing
									If (containingType.DigThroughArrayType().DeclaredAccessibility <> Accessibility.[Public]) Then
										flag = True
										Binder.ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_BadAttributeNonPublicContType2, New [Object]() { current.Type, containingType })
									End If
									containingType = containingType.ContainingType
								End While
							Else
								flag = True
								Binder.ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_BadAttributeNonPublicType1, New [Object]() { current.Type })
							End If
						End While
						If (Not flag) Then
							item1 = Me.PassArguments(node.Name, value, item1, diagnostics).Item1
							If (underlyingSymbol.DeclaredAccessibility <> Accessibility.[Public]) Then
								Binder.ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_BadAttributeNonPublicConstructor)
							End If
						End If
					Else
						resultKind = LookupResult.WorseResultKind(resultKind, LookupResultKind.OverloadResolutionFailure)
						If (Not type.IsErrorType()) Then
							If (overloadResolutionResult.Candidates.Length = 0) Then
								strs = New ImmutableArray(Of String)()
								Dim name As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax = node.Name
								Dim discarded As CompoundUseSiteInfo(Of AssemblySymbol) = CompoundUseSiteInfo(Of AssemblySymbol).Discarded
								overloadResolutionResult = OverloadResolution.MethodInvocationOverloadResolution(boundMethodGroup, item1, strs, Me, name, discarded, True, Nothing, Nothing, True, False, False)
							End If
							strs = New ImmutableArray(Of String)()
							Me.ReportOverloadResolutionFailureAndProduceBoundNode(node, boundMethodGroup, item1, strs, overloadResolutionResult, diagnostics, node.Name, Nothing, False, Nothing, Nothing, Nothing)
						End If
					End If
				Else
					diagnostics.Add(node, newCompoundUseSiteInfo)
					If (Not type.IsErrorType()) Then
						Binder.ReportDiagnostic(diagnostics, node, ErrorFactory.ErrorInfo(ERRID.ERR_NoViableOverloadCandidates1, New [Object]() { "New" }))
					End If
					resultKind = If(Not item.InstanceConstructors.IsEmpty, LookupResult.WorseResultKind(resultKind, LookupResultKind.Inaccessible), LookupResult.WorseResultKind(resultKind, LookupResultKind.Empty))
				End If
			End If
			Return New BoundAttribute(node, underlyingSymbol, item1, boundExpressions, resultKind, type, resultKind <> LookupResultKind.Good)
		End Function

		Private Function BindAttributeArguments(ByVal type As NamedTypeSymbol, ByVal argumentListOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Binder.AnalyzedAttributeArguments
			Dim immutableAndFree As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = New ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)()
			Dim sNoArguments As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = New ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)()
			If (argumentListOpt IsNot Nothing) Then
				Dim arguments As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax) = argumentListOpt.Arguments
				Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance()
				Dim boundExpressions As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = Nothing
				Dim num As Integer = 0
				Try
					Dim enumerator As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax).Enumerator = arguments.GetEnumerator()
					While enumerator.MoveNext()
						Dim current As Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax = enumerator.Current
						Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = current.Kind()
						If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OmittedArgument) Then
							instance.Add(New BoundOmittedArgument(current, Nothing))
						ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleArgument) Then
							Dim simpleArgumentSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax = DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax)
							If (simpleArgumentSyntax.IsNamed) Then
								If (boundExpressions Is Nothing) Then
									boundExpressions = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance()
								End If
								boundExpressions.Add(Me.BindAttributeNamedArgument(type, simpleArgumentSyntax, diagnostics))
							Else
								Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindValue(simpleArgumentSyntax.Expression, diagnostics, False)
								Me.MarkEmbeddedTypeReferenceIfNeeded(boundExpression)
								instance.Add(boundExpression)
							End If
						End If
						num = num + 1
					End While
				Finally
					immutableAndFree = instance.ToImmutableAndFree()
					sNoArguments = If(boundExpressions Is Nothing, Binder.s_noArguments, boundExpressions.ToImmutableAndFree())
				End Try
			Else
				immutableAndFree = Binder.s_noArguments
				sNoArguments = Binder.s_noArguments
			End If
			Return New Binder.AnalyzedAttributeArguments(immutableAndFree, sNoArguments)
		End Function

		Private Function BindAttributeNamedArgument(ByVal container As TypeSymbol, ByVal namedArg As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim instance As LookupResult = LookupResult.GetInstance()
			Dim name As Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax = namedArg.NameColonEquals.Name
			Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
			Dim identifier As Microsoft.CodeAnalysis.SyntaxToken = name.Identifier
			Me.LookupMember(instance, container, identifier.ValueText, 0, LookupOptions.IgnoreExtensionMethods, newCompoundUseSiteInfo)
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindValue(namedArg.Expression, diagnostics, False)
			Me.MarkEmbeddedTypeReferenceIfNeeded(boundExpression)
			Dim boundPropertyAccess As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			If (Not instance.IsGood) Then
				If (Not instance.HasDiagnostic) Then
					Dim syntaxNodeOrToken As Microsoft.CodeAnalysis.SyntaxNodeOrToken = name
					Dim valueText(0) As [Object]
					identifier = name.Identifier
					valueText(0) = identifier.ValueText
					Binder.ReportDiagnostic(diagnostics, syntaxNodeOrToken, ERRID.ERR_PropertyOrFieldNotDefined1, valueText)
				Else
					Binder.ReportDiagnostic(diagnostics, name, instance.Diagnostic)
				End If
				boundPropertyAccess = Binder.BadExpression(name, ErrorTypeSymbol.UnknownResultType)
				boundExpression = Me.MakeRValue(boundExpression, diagnostics)
			Else
				Dim bestAttributeFieldOrProperty As Symbol = Binder.GetBestAttributeFieldOrProperty(instance)
				Dim fieldSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol = Nothing
				Dim propertySymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol = Nothing
				Dim type As TypeSymbol = Nothing
				Dim isReadOnly As Boolean = False
				Dim flag As Boolean = False
				Me.ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagnostics, bestAttributeFieldOrProperty, namedArg)
				Dim kind As SymbolKind = bestAttributeFieldOrProperty.Kind
				If (kind = SymbolKind.Field) Then
					fieldSymbol = DirectCast(bestAttributeFieldOrProperty, Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol)
					type = fieldSymbol.Type
					isReadOnly = fieldSymbol.IsReadOnly
					Binder.ReportUseSite(diagnostics, name.Identifier, bestAttributeFieldOrProperty)
				ElseIf (kind = SymbolKind.[Property]) Then
					propertySymbol = DirectCast(bestAttributeFieldOrProperty, Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol)
					type = propertySymbol.GetTypeFromSetMethod()
					Dim setMethod As MethodSymbol = propertySymbol.SetMethod
					isReadOnly = setMethod Is Nothing
					If (setMethod IsNot Nothing) Then
						Binder.ReportUseSite(diagnostics, name.Identifier, setMethod)
						If (setMethod.ParameterCount <> 1) Then
							Binder.ReportDiagnostic(diagnostics, name, ERRID.ERR_NoNonIndexProperty1, New [Object]() { bestAttributeFieldOrProperty.Name })
							flag = True
						End If
						Dim basesBeingResolved As Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolved = New Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolved()
						If (Not Me.IsAccessible(setMethod, newCompoundUseSiteInfo, Nothing, basesBeingResolved)) Then
							Binder.ReportDiagnostic(diagnostics, name, ERRID.ERR_InaccessibleMember3, New [Object]() { propertySymbol.ContainingSymbol, propertySymbol, AccessCheck.GetAccessibilityForErrorMessage(setMethod, Me.Compilation.Assembly) })
							flag = True
						End If
						If (setMethod.IsInitOnly) Then
							Parser.CheckFeatureAvailability(diagnostics, name.Location, DirectCast(name.SyntaxTree.Options, VisualBasicParseOptions).LanguageVersion, Feature.InitOnlySettersUsage)
						End If
					End If
				Else
					Dim syntaxNodeOrToken1 As Microsoft.CodeAnalysis.SyntaxNodeOrToken = name
					Dim objArray(0) As [Object]
					identifier = name.Identifier
					objArray(0) = identifier.ValueText
					Binder.ReportDiagnostic(diagnostics, syntaxNodeOrToken1, ERRID.ERR_AttrAssignmentNotFieldOrProp1, objArray)
					flag = True
				End If
				If (bestAttributeFieldOrProperty.DeclaredAccessibility <> Accessibility.[Public]) Then
					Binder.ReportDiagnostic(diagnostics, name, ERRID.ERR_BadAttributeNonPublicProperty1, New [Object]() { bestAttributeFieldOrProperty.Name })
					flag = True
				End If
				If (bestAttributeFieldOrProperty.IsShared) Then
					Binder.ReportDiagnostic(diagnostics, name, ERRID.ERR_BadAttributeSharedProperty1, New [Object]() { bestAttributeFieldOrProperty.Name })
					flag = True
				End If
				If (isReadOnly) Then
					Binder.ReportDiagnostic(diagnostics, name, ERRID.ERR_BadAttributeReadOnlyProperty1, New [Object]() { bestAttributeFieldOrProperty.Name })
					flag = True
				End If
				If (type Is Nothing) Then
					boundExpression = Me.MakeRValue(boundExpression, diagnostics)
				Else
					If (Not Me.IsValidTypeForAttributeArgument(type)) Then
						Binder.ReportDiagnostic(diagnostics, name, ERRID.ERR_BadAttributePropertyType1, New [Object]() { bestAttributeFieldOrProperty.Name })
						flag = True
					End If
					boundExpression = Me.ApplyImplicitConversion(namedArg.Expression, type, boundExpression, diagnostics, False)
				End If
				If (propertySymbol IsNot Nothing) Then
					boundPropertyAccess = New Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess(name, propertySymbol, Nothing, PropertyAccessKind.[Set], Not isReadOnly, Nothing, ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty, BitVector.Null, flag)
				ElseIf (fieldSymbol Is Nothing) Then
					boundPropertyAccess = Binder.BadExpression(name, ErrorTypeSymbol.UnknownResultType)
				Else
					boundPropertyAccess = New BoundFieldAccess(name, Nothing, fieldSymbol, True, type, flag)
				End If
			End If
			diagnostics.Add(namedArg, newCompoundUseSiteInfo)
			instance.Free()
			Return New BoundAssignmentOperator(namedArg, boundPropertyAccess, boundExpression, True, False)
		End Function

		Friend Shared Function BindAttributeType(ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal attribute As Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax, ByVal ownerSymbol As Symbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As NamedTypeSymbol
			binder = New LocationSpecificBinder(Microsoft.CodeAnalysis.VisualBasic.BindingLocation.Attribute, ownerSymbol, binder)
			Return DirectCast(binder.BindTypeSyntax(attribute.Name, diagnostics, False, False, False), NamedTypeSymbol)
		End Function

		Friend Shared Function BindAttributeTypes(ByVal binders As ImmutableArray(Of Binder), ByVal attributesToBind As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax), ByVal ownerSymbol As Symbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As ImmutableArray(Of NamedTypeSymbol)
			Dim length As Integer = attributesToBind.Length
			Dim namedTypeSymbolArray(length - 1 + 1 - 1) As NamedTypeSymbol
			Dim num As Integer = length - 1
			Dim num1 As Integer = 0
			Do
				namedTypeSymbolArray(num1) = Binder.BindAttributeType(binders(num1), attributesToBind(num1), ownerSymbol, diagnostics)
				num1 = num1 + 1
			Loop While num1 <= num
			Return Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of NamedTypeSymbol)(namedTypeSymbolArray)
		End Function

		Private Function BindAwait(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal bindAsStatement As Boolean = False) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			If (Me.IsInQuery) Then
				Binder.ReportDiagnostic(diagnostics, node.AwaitKeyword, ERRID.ERR_BadAsyncInQuery)
			ElseIf (Not Me.IsInAsyncContext()) Then
				Binder.ReportDiagnostic(diagnostics, node.AwaitKeyword, Me.GetAwaitInNonAsyncError())
			End If
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindExpression(node.Expression, diagnostics)
			Return Me.BindAwait(node, boundExpression, diagnostics, bindAsStatement)
		End Function

		Private Function BindAwait(ByVal node As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal operand As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal bindAsStatement As Boolean) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundAwaitOperator As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim type As TypeSymbol
			Dim strs As ImmutableArray(Of String)
			If (Not operand.HasErrors AndAlso operand.Type IsNot Nothing AndAlso operand.Type.IsVoidType() AndAlso operand.Kind = BoundKind.[Call]) Then
				Dim method As Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol = DirectCast(operand, BoundCall).Method
				If (Not method.IsSub OrElse Not method.IsAsync) Then
					GoTo Label1
				End If
				Binder.ReportDiagnostic(diagnostics, operand.Syntax, ERRID.ERR_CantAwaitAsyncSub1, New [Object]() { method.Name })
				boundAwaitOperator = Binder.BadExpression(node, operand, ErrorTypeSymbol.UnknownResultType)
				Return boundAwaitOperator
			End If
		Label1:
			operand = Me.MakeRValue(operand, diagnostics)
			If (Not operand.IsNothingLiteral()) Then
				If (operand.Type.IsObjectType()) Then
					If (Me.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.[On]) Then
						Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_StrictDisallowsLateBinding)
						boundAwaitOperator = Binder.BadExpression(node, operand, ErrorTypeSymbol.UnknownResultType)
						Return boundAwaitOperator
					End If
					If (Me.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.Custom) Then
						Binder.ReportDiagnostic(diagnostics, node, ERRID.WRN_LateBindingResolution)
					End If
				End If
				If (operand.HasErrors) Then
					diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
				End If
				Dim instance As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.GetInstance(True, diagnostics.AccumulatesDependencies)
				Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.GetInstance(diagnostics)
				Dim boundRValuePlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder = (New Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder(operand.Syntax, operand.Type)).MakeCompilerGenerated()
				Dim boundLValuePlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundLValuePlaceholder = Nothing
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
				Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
				Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
				If (Not operand.Type.IsObjectType()) Then
					Dim lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult = Microsoft.CodeAnalysis.VisualBasic.LookupResult.GetInstance()
					Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
					Me.LookupMember(lookupResult, boundRValuePlaceholder.Type, "GetAwaiter", 0, LookupOptions.AllMethodsOfAnyArity, newCompoundUseSiteInfo)
					Dim boundMethodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup = Nothing
					If (lookupResult.Kind = LookupResultKind.Good AndAlso lookupResult.Symbols(0).Kind = SymbolKind.Method) Then
						boundMethodGroup = Me.CreateBoundMethodGroup(node, lookupResult, LookupOptions.[Default], instance.AccumulatesDependencies, boundRValuePlaceholder, Nothing, QualificationKind.QualifiedViaValue, False).MakeCompilerGenerated()
						instance.Clear()
						Dim syntax As Microsoft.CodeAnalysis.SyntaxNode = operand.Syntax
						Dim empty As ImmutableArray(Of !0) = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty
						strs = New ImmutableArray(Of String)()
						boundExpression = Me.MakeRValue(Me.BindInvocationExpression(node, syntax, TypeCharacter.None, boundMethodGroup, empty, strs, instance, node, False, False, False, Nothing, False).MakeCompilerGenerated(), instance).MakeCompilerGenerated()
						If (boundExpression.HasErrors OrElse Binder.DiagnosticBagHasErrorsOtherThanObsoleteOnes(instance.DiagnosticBag) OrElse boundExpression.Kind <> BoundKind.[Call] OrElse boundExpression.Type.IsObjectType()) Then
							boundExpression = Nothing
						Else
							bindingDiagnosticBag.AddRange(instance, False)
							Dim methodSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol = DirectCast(boundExpression, BoundCall).Method
							If (methodSymbol.IsShared OrElse methodSymbol.ParameterCount <> 0) Then
								boundExpression = Nothing
							End If
						End If
					End If
					If (boundExpression IsNot Nothing AndAlso Not boundExpression.Type.IsErrorType()) Then
						boundLValuePlaceholder = (New Microsoft.CodeAnalysis.VisualBasic.BoundLValuePlaceholder(operand.Syntax, boundExpression.Type)).MakeCompilerGenerated()
						lookupResult.Clear()
						Me.LookupMember(lookupResult, boundLValuePlaceholder.Type, "IsCompleted", 0, LookupOptions.AllMethodsOfAnyArity Or LookupOptions.IgnoreExtensionMethods, newCompoundUseSiteInfo)
						If (lookupResult.Kind = LookupResultKind.Good AndAlso lookupResult.Symbols(0).Kind = SymbolKind.[Property]) Then
							Dim boundPropertyGroup As Microsoft.CodeAnalysis.VisualBasic.BoundPropertyGroup = (New Microsoft.CodeAnalysis.VisualBasic.BoundPropertyGroup(node, lookupResult.Symbols.ToDowncastedImmutable(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol)(), lookupResult.Kind, boundLValuePlaceholder, QualificationKind.QualifiedViaValue, False)).MakeCompilerGenerated()
							instance.Clear()
							Dim syntaxNode As Microsoft.CodeAnalysis.SyntaxNode = operand.Syntax
							Dim u00210s As ImmutableArray(Of !0) = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty
							strs = New ImmutableArray(Of String)()
							boundExpression1 = Me.MakeRValue(Me.BindInvocationExpression(node, syntaxNode, TypeCharacter.None, boundPropertyGroup, u00210s, strs, instance, node, False, False, False, Nothing, False).MakeCompilerGenerated(), instance).MakeCompilerGenerated()
							If (boundExpression1.HasErrors OrElse Binder.DiagnosticBagHasErrorsOtherThanObsoleteOnes(instance.DiagnosticBag) OrElse boundExpression1.Kind <> BoundKind.PropertyAccess OrElse Not boundExpression1.Type.IsBooleanType()) Then
								boundExpression1 = Nothing
							Else
								bindingDiagnosticBag.AddRange(instance, False)
								Dim propertySymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol = DirectCast(boundExpression1, BoundPropertyAccess).PropertySymbol
								If (propertySymbol.IsShared OrElse propertySymbol.ParameterCount <> 0) Then
									boundExpression1 = Nothing
								End If
							End If
						End If
						lookupResult.Clear()
						Me.LookupMember(lookupResult, boundLValuePlaceholder.Type, "GetResult", 0, LookupOptions.AllMethodsOfAnyArity Or LookupOptions.IgnoreExtensionMethods, newCompoundUseSiteInfo)
						If (lookupResult.Kind = LookupResultKind.Good AndAlso lookupResult.Symbols(0).Kind = SymbolKind.Method) Then
							boundMethodGroup = Me.CreateBoundMethodGroup(node, lookupResult, LookupOptions.[Default], instance.AccumulatesDependencies, boundLValuePlaceholder, Nothing, QualificationKind.QualifiedViaValue, False).MakeCompilerGenerated()
							instance.Clear()
							Dim syntax1 As Microsoft.CodeAnalysis.SyntaxNode = operand.Syntax
							Dim empty1 As ImmutableArray(Of !0) = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty
							strs = New ImmutableArray(Of String)()
							boundExpression2 = Me.BindInvocationExpression(node, syntax1, TypeCharacter.None, boundMethodGroup, empty1, strs, instance, node, False, False, False, Nothing, False).MakeCompilerGenerated()
							If (boundExpression2.HasErrors OrElse Binder.DiagnosticBagHasErrorsOtherThanObsoleteOnes(instance.DiagnosticBag) OrElse boundExpression2.Kind <> BoundKind.[Call]) Then
								boundExpression2 = Nothing
							Else
								bindingDiagnosticBag.AddRange(instance, False)
								Dim method1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol = DirectCast(boundExpression2, BoundCall).Method
								If (method1.IsShared OrElse method1.ParameterCount <> 0 OrElse method1.IsSub AndAlso method1.IsConditional) Then
									boundExpression2 = Nothing
								End If
							End If
						End If
						Dim wellKnownType As NamedTypeSymbol = Me.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType.System_Runtime_CompilerServices_INotifyCompletion, node, diagnostics)
						If (Not wellKnownType.IsErrorType() AndAlso Not Microsoft.CodeAnalysis.VisualBasic.Conversions.IsWideningConversion(Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyDirectCastConversion(boundExpression.Type, wellKnownType, newCompoundUseSiteInfo))) Then
							Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_DoesntImplementAwaitInterface2, New [Object]() { boundExpression.Type, wellKnownType })
						End If
					End If
					diagnostics.Add(node, newCompoundUseSiteInfo)
					lookupResult.Free()
				Else
					boundExpression = Me.BindLateBoundMemberAccess(node, "GetAwaiter", Nothing, boundRValuePlaceholder, operand.Type, instance, True).MakeCompilerGenerated()
					boundExpression = DirectCast(boundExpression, BoundLateMemberAccess).SetAccessKind(LateBoundAccessKind.[Get])
					boundLValuePlaceholder = (New Microsoft.CodeAnalysis.VisualBasic.BoundLValuePlaceholder(operand.Syntax, boundExpression.Type)).MakeCompilerGenerated()
					boundExpression1 = Me.BindLateBoundMemberAccess(node, "IsCompleted", Nothing, boundLValuePlaceholder, boundLValuePlaceholder.Type, instance, True).MakeCompilerGenerated()
					boundExpression1 = DirectCast(boundExpression1, BoundLateMemberAccess).SetAccessKind(LateBoundAccessKind.[Get])
					boundExpression2 = Me.BindLateBoundMemberAccess(node, "GetResult", Nothing, boundLValuePlaceholder, boundLValuePlaceholder.Type, instance, True).MakeCompilerGenerated()
					boundExpression2 = DirectCast(boundExpression2, BoundLateMemberAccess).SetAccessKind(If(bindAsStatement, LateBoundAccessKind.[Call], LateBoundAccessKind.[Get]))
				End If
				Dim flag As Boolean = False
				If (boundExpression Is Nothing) Then
					flag = True
					Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_BadGetAwaiterMethod1, New [Object]() { operand.Type })
					boundExpression = Binder.BadExpression(node, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
				ElseIf (boundExpression.Type.IsErrorType()) Then
					flag = True
				ElseIf (boundExpression1 Is Nothing OrElse boundExpression2 Is Nothing) Then
					flag = True
					Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_BadIsCompletedOnCompletedGetResult2, New [Object]() { boundExpression.Type, operand.Type })
				End If
				If (boundLValuePlaceholder Is Nothing) Then
					boundLValuePlaceholder = (New Microsoft.CodeAnalysis.VisualBasic.BoundLValuePlaceholder(node, boundExpression.Type)).MakeCompilerGenerated()
				End If
				If (boundExpression1 Is Nothing) Then
					boundExpression1 = Binder.BadExpression(node, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
				End If
				If (boundExpression2 Is Nothing) Then
					boundExpression2 = Binder.BadExpression(node, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
				End If
				If (Not bindAsStatement) Then
					type = boundExpression2.Type
				Else
					type = Me.GetSpecialType(SpecialType.System_Void, node, diagnostics)
				End If
				If (Not flag) Then
					diagnostics.AddRange(bindingDiagnosticBag, False)
				End If
				bindingDiagnosticBag.Free()
				instance.Free()
				boundAwaitOperator = New Microsoft.CodeAnalysis.VisualBasic.BoundAwaitOperator(node, operand, boundRValuePlaceholder, boundExpression, boundLValuePlaceholder, boundExpression1, boundExpression2, type, flag)
			Else
				Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_BadAwaitNothing)
				boundAwaitOperator = Binder.BadExpression(node, operand, ErrorTypeSymbol.UnknownResultType)
			End If
			Return boundAwaitOperator
		End Function

		Private Function BindBinaryConditionalExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim type As TypeSymbol
			Dim constantValueOpt As ConstantValue
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindValue(node.FirstExpression, diagnostics, False)
			Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindValue(node.SecondExpression, diagnostics, False)
			Dim hasErrors As Boolean = If(boundExpression1.HasErrors OrElse boundExpression2.HasErrors, True, node.ContainsDiagnostics)
			If (boundExpression1.IsNothingLiteral() AndAlso boundExpression2.IsNothingLiteral()) Then
				Dim specialType As Object = boundExpression1.Type
				If (specialType Is Nothing) Then
					specialType = boundExpression2.Type
					If (specialType Is Nothing) Then
						specialType = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Object, node, diagnostics)
					End If
				End If
				type = specialType
			ElseIf (boundExpression1.Type Is Nothing OrElse Not boundExpression1.Type.IsNullableType() OrElse Not boundExpression2.IsNothingLiteral()) Then
				Dim num As Integer = 0
				Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance(2)
				If (boundExpression1.Type Is Nothing OrElse Not boundExpression1.Type.IsNullableType() OrElse boundExpression2.Type IsNot Nothing AndAlso boundExpression2.Type.IsNullableType()) Then
					instance.Add(boundExpression1)
				Else
					Dim nullableUnderlyingType As TypeSymbol = boundExpression1.Type.GetNullableUnderlyingType()
					instance.Add(New BoundRValuePlaceholder(node.FirstExpression, nullableUnderlyingType))
				End If
				instance.Add(boundExpression2)
				Dim inferenceErrorReason As InferenceErrorReasons = InferenceErrorReasons.Other
				type = Me.InferDominantTypeOfExpressions(node, instance, diagnostics, num, inferenceErrorReason)
				instance.Free()
				If (Not hasErrors) Then
					hasErrors = Me.GenerateDiagnosticsForDominantTypeInferenceInIfExpression(type, num, node, diagnostics)
				End If
			Else
				type = boundExpression1.Type
			End If
			If (hasErrors OrElse Not Binder.IsConstantAllowingCompileTimeFolding(boundExpression1) OrElse Not Binder.IsConstantAllowingCompileTimeFolding(boundExpression2) OrElse Not boundExpression1.IsNothingLiteral() AndAlso Not boundExpression1.ConstantValueOpt.IsString) Then
				If (Not hasErrors AndAlso boundExpression1.Type Is Nothing AndAlso Not boundExpression1.IsNothingLiteral()) Then
					boundExpression1 = Me.ApplyImplicitConversion(node.FirstExpression, type, boundExpression1, diagnostics, False)
					hasErrors = boundExpression1.HasErrors
				End If
				If (Not boundExpression1.IsNothingLiteral()) Then
					If (hasErrors) Then
						boundExpression1 = Me.MakeRValueAndIgnoreDiagnostics(boundExpression1)
					Else
						boundExpression1 = Me.MakeRValue(boundExpression1, diagnostics)
						hasErrors = boundExpression1.HasErrors
					End If
				End If
				Dim boundExpression3 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = boundExpression2
				If (hasErrors) Then
					boundExpression3 = Me.MakeRValueAndIgnoreDiagnostics(boundExpression2)
				Else
					boundExpression3 = Me.ApplyImplicitConversion(node.SecondExpression, type, boundExpression2, diagnostics, False)
					hasErrors = boundExpression3.HasErrors
				End If
				If (Not hasErrors AndAlso Not boundExpression1.IsNothingLiteral() AndAlso Not boundExpression1.Type.IsNullableType() AndAlso Not boundExpression1.Type.IsReferenceType) Then
					If (boundExpression1.Type.IsValueType) Then
						Binder.ReportDiagnostic(diagnostics, node.FirstExpression, ERRID.ERR_IllegalCondTypeInIIF)
						hasErrors = True
					Else
						Parser.CheckFeatureAvailability(diagnostics, node.Location, DirectCast(node.SyntaxTree.Options, VisualBasicParseOptions).LanguageVersion, Feature.UnconstrainedTypeParameterInConditional)
					End If
				End If
				Dim binaryConditionalExpressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax = node
				Dim boundExpression4 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = boundExpression1
				Dim boundExpression5 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = boundExpression3
				Dim unknownResultType As Object = type
				If (unknownResultType Is Nothing) Then
					unknownResultType = ErrorTypeSymbol.UnknownResultType
				End If
				boundExpression = Me.AnalyzeConversionAndCreateBinaryConditionalExpression(binaryConditionalExpressionSyntax, boundExpression4, boundExpression5, Nothing, unknownResultType, hasErrors, diagnostics, False)
			Else
				If (Not boundExpression1.IsNothingLiteral()) Then
					constantValueOpt = boundExpression1.ConstantValueOpt
					type = boundExpression1.Type
				Else
					constantValueOpt = boundExpression2.ConstantValueOpt
					If (Not boundExpression2.IsNothingLiteral()) Then
						type = boundExpression2.Type
					End If
				End If
				boundExpression = Me.AnalyzeConversionAndCreateBinaryConditionalExpression(node, boundExpression1, boundExpression2, constantValueOpt, type, False, diagnostics, False)
			End If
			Return boundExpression
		End Function

		Private Function BindBinaryOperator(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax, ByVal isOperandOfConditionalBranch As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim left As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax
			Dim flag As Boolean
			Dim binaryOperatorKind As Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind = OverloadResolution.MapBinaryOperatorKind(node.Kind())
			If (Not isOperandOfConditionalBranch) Then
				flag = False
			Else
				flag = If(binaryOperatorKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.[AndAlso], True, binaryOperatorKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.[OrElse])
			End If
			Dim flag1 As Boolean = flag
			Dim parent As Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax = node
			While True
				left = parent.Left
				Select Case left.Kind()
					Case SyntaxKind.AddExpression
					Case SyntaxKind.SubtractExpression
					Case SyntaxKind.MultiplyExpression
					Case SyntaxKind.DivideExpression
					Case SyntaxKind.IntegerDivideExpression
					Case SyntaxKind.ExponentiateExpression
					Case SyntaxKind.LeftShiftExpression
					Case SyntaxKind.RightShiftExpression
					Case SyntaxKind.ConcatenateExpression
					Case SyntaxKind.ModuloExpression
					Case SyntaxKind.EqualsExpression
					Case SyntaxKind.NotEqualsExpression
					Case SyntaxKind.LessThanExpression
					Case SyntaxKind.LessThanOrEqualExpression
					Case SyntaxKind.GreaterThanOrEqualExpression
					Case SyntaxKind.GreaterThanExpression
					Case SyntaxKind.LikeExpression
					Case SyntaxKind.OrExpression
					Case SyntaxKind.ExclusiveOrExpression
					Case SyntaxKind.AndExpression
						If (Not flag1) Then
							GoTo Label0
						End If

					Case SyntaxKind.OrElseExpression
					Case SyntaxKind.AndAlsoExpression
					Label0:
						parent = DirectCast(left, Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax)
						Continue While
				End Select
			End While
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindValue(left, diagnostics, flag1)
			Do
				parent = DirectCast(left.Parent, Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax)
				Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindValue(parent.Right, diagnostics, flag1)
				boundExpression = Me.BindBinaryOperator(parent, boundExpression, boundExpression1, parent.OperatorToken.Kind(), OverloadResolution.MapBinaryOperatorKind(parent.Kind()), If(parent = node, isOperandOfConditionalBranch, flag1), diagnostics, False)
				left = parent
			Loop While left <> node
			Return boundExpression
		End Function

		Private Function BindBinaryOperator(ByVal node As SyntaxNode, ByVal left As BoundExpression, ByVal right As BoundExpression, ByVal operatorTokenKind As SyntaxKind, ByVal preliminaryOperatorKind As BinaryOperatorKind, ByVal isOperandOfConditionalBranch As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal isSelectCase As Boolean = False) As BoundExpression
			' 
			' Current member / type: Microsoft.CodeAnalysis.VisualBasic.BoundExpression Microsoft.CodeAnalysis.VisualBasic.Binder::BindBinaryOperator(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag,System.Boolean)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: Microsoft.CodeAnalysis.VisualBasic.BoundExpression BindBinaryOperator(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag,System.Boolean)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Function

		Friend Function BindBlock(ByVal syntax As SyntaxNode, ByVal stmtList As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundBlock
			Dim binder As Microsoft.CodeAnalysis.VisualBasic.Binder = Me.GetBinder(stmtList)
			Return Me.BindBlock(syntax, stmtList, diagnostics, binder)
		End Function

		Friend Function BindBlock(ByVal syntax As SyntaxNode, ByVal stmtList As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal stmtListBinder As Binder) As Microsoft.CodeAnalysis.VisualBasic.BoundBlock
			Dim boundBlock As Microsoft.CodeAnalysis.VisualBasic.BoundBlock
			Dim boundStatementArray(stmtList.Count - 1 + 1 - 1) As Microsoft.CodeAnalysis.VisualBasic.BoundStatement
			Dim localSymbols As ArrayBuilder(Of LocalSymbol) = Nothing
			Dim length As Integer = CInt(boundStatementArray.Length) - 1
			Dim num As Integer = 0
			Do
				Dim boundStatement As Microsoft.CodeAnalysis.VisualBasic.BoundStatement = stmtListBinder.BindStatement(stmtList(num), diagnostics)
				boundStatementArray(num) = boundStatement
				Select Case boundStatement.Kind
					Case BoundKind.LocalDeclaration
						Binder.DeclareLocal(localSymbols, DirectCast(boundStatement, BoundLocalDeclaration))
						Exit Select
					Case BoundKind.AsNewLocalDeclarations
						Binder.DeclareLocal(localSymbols, DirectCast(boundStatement, BoundAsNewLocalDeclarations))
						Exit Select
					Case BoundKind.DimStatement
						Dim enumerator As ImmutableArray(Of BoundLocalDeclarationBase).Enumerator = DirectCast(boundStatement, BoundDimStatement).LocalDeclarations.GetEnumerator()
						While enumerator.MoveNext()
							Binder.DeclareLocal(localSymbols, enumerator.Current)
						End While

				End Select
				num = num + 1
			Loop While num <= length
			boundBlock = If(localSymbols IsNot Nothing, New Microsoft.CodeAnalysis.VisualBasic.BoundBlock(syntax, stmtList, localSymbols.ToImmutableAndFree(), Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.BoundStatement)(boundStatementArray), False), New Microsoft.CodeAnalysis.VisualBasic.BoundBlock(syntax, stmtList, ImmutableArray(Of LocalSymbol).Empty, Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.BoundStatement)(boundStatementArray), False))
			Return boundBlock
		End Function

		Private Function BindBooleanExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindValue(node, diagnostics, True)
			Dim specialType As NamedTypeSymbol = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Boolean, node, diagnostics)
			Return Me.ApplyImplicitConversion(node, specialType, boundExpression, diagnostics, True)
		End Function

		Private Function BindCallStatement(ByVal callStmt As Microsoft.CodeAnalysis.VisualBasic.Syntax.CallStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindInvocationExpressionAsStatement(callStmt.Invocation, diagnostics)
			Return New BoundExpressionStatement(callStmt, boundExpression, False)
		End Function

		Private Function BindCaseBlock(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax, ByVal selectExpression As BoundRValuePlaceholder, ByVal convertCaseElements As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundCaseBlock
			Dim boundCaseStatement As Microsoft.CodeAnalysis.VisualBasic.BoundCaseStatement = Me.BindCaseStatement(node.CaseStatement, selectExpression, convertCaseElements, diagnostics)
			Dim statements As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax) = node.Statements
			Dim boundBlock As Microsoft.CodeAnalysis.VisualBasic.BoundBlock = Me.GetBinder(statements).BindBlock(node, statements, diagnostics).MakeCompilerGenerated()
			Return New BoundCaseBlock(node, boundCaseStatement, boundBlock, False)
		End Function

		Private Function BindCaseBlocks(ByVal caseBlocks As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax), ByVal selectExpression As BoundRValuePlaceholder, ByVal convertCaseElements As Boolean, ByRef recommendSwitchTable As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As ImmutableArray(Of BoundCaseBlock)
			Dim empty As ImmutableArray(Of BoundCaseBlock)
			If (DirectCast(caseBlocks, IReadOnlyCollection(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax)).IsEmpty()) Then
				empty = ImmutableArray(Of BoundCaseBlock).Empty
			Else
				Dim instance As ArrayBuilder(Of BoundCaseBlock) = ArrayBuilder(Of BoundCaseBlock).GetInstance()
				Dim enumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax).Enumerator = caseBlocks.GetEnumerator()
				While enumerator.MoveNext()
					Dim current As Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax = enumerator.Current
					instance.Add(Me.BindCaseBlock(current, selectExpression, convertCaseElements, diagnostics))
				End While
				empty = Me.OptimizeSelectStatement(selectExpression, instance, recommendSwitchTable, diagnostics)
			End If
			Return empty
		End Function

		Private Function BindCaseClause(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax, ByVal selectExpressionOpt As BoundRValuePlaceholder, ByVal convertCaseElements As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundCaseClause
			Dim boundCaseClause As Microsoft.CodeAnalysis.VisualBasic.BoundCaseClause
			Select Case node.Kind()
				Case SyntaxKind.SimpleCaseClause
					boundCaseClause = Me.BindSimpleCaseClause(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleCaseClauseSyntax), selectExpressionOpt, convertCaseElements, diagnostics)
					Exit Select
				Case SyntaxKind.RangeCaseClause
					boundCaseClause = Me.BindRangeCaseClause(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeCaseClauseSyntax), selectExpressionOpt, convertCaseElements, diagnostics)
					Exit Select
				Case SyntaxKind.CaseEqualsClause
				Case SyntaxKind.CaseNotEqualsClause
				Case SyntaxKind.CaseLessThanClause
				Case SyntaxKind.CaseLessThanOrEqualClause
				Case SyntaxKind.CaseGreaterThanOrEqualClause
				Case SyntaxKind.CaseGreaterThanClause
					boundCaseClause = Me.BindRelationalCaseClause(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax), selectExpressionOpt, convertCaseElements, diagnostics)
					Exit Select
				Case SyntaxKind.EndSelectStatement Or SyntaxKind.EndClassStatement Or SyntaxKind.EndFunctionStatement Or SyntaxKind.EndOperatorStatement Or SyntaxKind.EndRaiseEventStatement Or SyntaxKind.NewConstraint Or SyntaxKind.FunctionBlock Or SyntaxKind.SetAccessorBlock Or SyntaxKind.PropertyBlock Or SyntaxKind.ParameterList Or SyntaxKind.NamedFieldInitializer Or SyntaxKind.Parameter Or SyntaxKind.Attribute Or SyntaxKind.PrintStatement Or SyntaxKind.UsingBlock Or SyntaxKind.LabelStatement Or SyntaxKind.NextLabel Or SyntaxKind.EndStatement Or SyntaxKind.OnErrorGoToZeroStatement Or SyntaxKind.ResumeStatement Or SyntaxKind.SelectStatement Or SyntaxKind.CaseElseStatement Or SyntaxKind.CaseEqualsClause
				Case SyntaxKind.List Or SyntaxKind.EndIfStatement Or SyntaxKind.EndSelectStatement Or SyntaxKind.EndStructureStatement Or SyntaxKind.EndClassStatement Or SyntaxKind.EndModuleStatement Or SyntaxKind.EndFunctionStatement Or SyntaxKind.EndGetStatement Or SyntaxKind.EndOperatorStatement Or SyntaxKind.EndEventStatement Or SyntaxKind.EndRaiseEventStatement Or SyntaxKind.EndWhileStatement Or SyntaxKind.NewConstraint Or SyntaxKind.ClassConstraint Or SyntaxKind.FunctionBlock Or SyntaxKind.ConstructorBlock Or SyntaxKind.SetAccessorBlock Or SyntaxKind.AddHandlerAccessorBlock Or SyntaxKind.PropertyBlock Or SyntaxKind.EventBlock Or SyntaxKind.ParameterList Or SyntaxKind.SubStatement Or SyntaxKind.NamedFieldInitializer Or SyntaxKind.EqualsValue Or SyntaxKind.Parameter Or SyntaxKind.ModifiedIdentifier Or SyntaxKind.Attribute Or SyntaxKind.AttributeTarget Or SyntaxKind.PrintStatement Or SyntaxKind.WhileBlock Or SyntaxKind.UsingBlock Or SyntaxKind.SyncLockBlock Or SyntaxKind.LabelStatement Or SyntaxKind.GoToStatement Or SyntaxKind.NextLabel Or SyntaxKind.StopStatement Or SyntaxKind.EndStatement Or SyntaxKind.ExitDoStatement Or SyntaxKind.OnErrorGoToZeroStatement Or SyntaxKind.OnErrorGoToMinusOneStatement Or SyntaxKind.ResumeStatement Or SyntaxKind.ResumeLabelStatement Or SyntaxKind.SelectStatement Or SyntaxKind.CaseElseStatement Or SyntaxKind.ElseCaseClause Or SyntaxKind.CaseEqualsClause Or SyntaxKind.CaseNotEqualsClause
					Throw ExceptionUtilities.UnexpectedValue(node.Kind())
				Case Else
					Throw ExceptionUtilities.UnexpectedValue(node.Kind())
			End Select
			Return boundCaseClause
		End Function

		Private Function BindCaseClauseExpression(ByVal expressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax, ByVal caseClauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax, ByVal selectExpressionOpt As BoundRValuePlaceholder, ByVal operatorTokenKind As SyntaxKind, ByVal operatorKind As BinaryOperatorKind, ByVal convertCaseElements As Boolean, ByRef conditionOpt As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindValue(expressionSyntax, diagnostics, False)
			If (selectExpressionOpt Is Nothing) Then
				conditionOpt = Nothing
				boundExpression = Me.MakeRValue(boundExpression1, diagnostics)
			ElseIf (Not convertCaseElements OrElse Not boundExpression1.Type.IsIntrinsicOrEnumType()) Then
				conditionOpt = Me.BindBinaryOperator(caseClauseSyntax, selectExpressionOpt, boundExpression1, operatorTokenKind, operatorKind, False, diagnostics, True).MakeCompilerGenerated()
				boundExpression = Nothing
			Else
				boundExpression = Me.ApplyImplicitConversion(expressionSyntax, selectExpressionOpt.Type, boundExpression1, diagnostics, False)
			End If
			Return boundExpression
		End Function

		Private Function BindCaseStatement(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax, ByVal selectExpressionOpt As BoundRValuePlaceholder, ByVal convertCaseElements As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundCaseStatement
			Dim empty As ImmutableArray(Of BoundCaseClause)
			If (node.Kind() <> SyntaxKind.CaseStatement) Then
				empty = ImmutableArray(Of BoundCaseClause).Empty
			Else
				Dim instance As ArrayBuilder(Of BoundCaseClause) = ArrayBuilder(Of BoundCaseClause).GetInstance()
				Dim enumerator As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax).Enumerator = node.Cases.GetEnumerator()
				While enumerator.MoveNext()
					Dim current As Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax = enumerator.Current
					instance.Add(Me.BindCaseClause(current, selectExpressionOpt, convertCaseElements, diagnostics))
				End While
				empty = instance.ToImmutableAndFree()
			End If
			Return New BoundCaseStatement(node, empty, Nothing, False)
		End Function

		Private Function BindCastExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = node.Keyword.Kind()
			If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CTypeKeyword) Then
				boundExpression = Me.BindCTypeExpression(node, diagnostics)
			ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DirectCastKeyword) Then
				boundExpression = Me.BindDirectCastExpression(node, diagnostics)
			Else
				If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TryCastKeyword) Then
					Throw ExceptionUtilities.UnexpectedValue(node.Keyword.Kind())
				End If
				boundExpression = Me.BindTryCastExpression(node, diagnostics)
			End If
			Return boundExpression
		End Function

		Private Function BindCatchBlock(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax, ByVal previousBlocks As ArrayBuilder(Of BoundCatchBlock), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundCatchBlock
			Dim wellKnownType As TypeSymbol
			Dim boundBlock As Microsoft.CodeAnalysis.VisualBasic.BoundBlock
			Dim type As TypeSymbol
			Dim flag As Boolean
			Dim syntaxNode As Microsoft.CodeAnalysis.SyntaxNode
			Dim type1 As Microsoft.CodeAnalysis.SyntaxNode
			Dim localSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol = Nothing
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim flag1 As Boolean = False
			Dim catchStatement As Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax = node.CatchStatement
			Dim identifierName As Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax = catchStatement.IdentifierName
			Dim asClause As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax = catchStatement.AsClause
			If (asClause IsNot Nothing) Then
				Dim boundLocal As Microsoft.CodeAnalysis.VisualBasic.BoundLocal = Me.BindCatchVariableDeclaration(identifierName, asClause, diagnostics)
				boundExpression = boundLocal
				localSymbol = boundLocal.LocalSymbol
			ElseIf (identifierName IsNot Nothing) Then
				boundExpression = Me.BindSimpleName(identifierName, False, diagnostics, False)
			End If
			If (boundExpression Is Nothing) Then
				wellKnownType = Me.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType.System_Exception, node, diagnostics)
			Else
				Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = boundExpression
				If (Not boundExpression.IsValue() OrElse boundExpression.Type Is Nothing OrElse boundExpression.Type.IsVoidType()) Then
					boundExpression = Binder.BadExpression(boundExpression.Syntax, boundExpression, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
				End If
				wellKnownType = boundExpression.Type
				If (Not boundExpression2.HasErrors) Then
					Dim kind As BoundKind = boundExpression.Kind
					If (kind = BoundKind.Parameter OrElse kind = BoundKind.Local AndAlso Not DirectCast(boundExpression, Microsoft.CodeAnalysis.VisualBasic.BoundLocal).LocalSymbol.IsStatic) Then
						Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
						If (wellKnownType.IsErrorType()) Then
							flag1 = True
						ElseIf (Not wellKnownType.IsOrDerivedFromWellKnownClass(Microsoft.CodeAnalysis.WellKnownType.System_Exception, Me.Compilation, newCompoundUseSiteInfo)) Then
							Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
							If (asClause IsNot Nothing) Then
								type1 = asClause.Type
							Else
								type1 = identifierName
							End If
							Binder.ReportDiagnostic(bindingDiagnosticBag, type1, ERRID.ERR_CatchNotException1, New [Object]() { wellKnownType })
							flag1 = True
						End If
						Dim bindingDiagnosticBag1 As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
						If (asClause IsNot Nothing) Then
							syntaxNode = asClause.Type
						Else
							syntaxNode = identifierName
						End If
						bindingDiagnosticBag1.Add(syntaxNode, newCompoundUseSiteInfo)
					Else
						Binder.ReportDiagnostic(diagnostics, identifierName, ERRID.ERR_CatchVariableNotLocal1, New [Object]() { identifierName.ToString() })
						flag1 = True
					End If
				Else
					flag1 = True
				End If
			End If
			Dim whenClause As Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchFilterClauseSyntax = catchStatement.WhenClause
			If (whenClause IsNot Nothing) Then
				boundExpression1 = Me.BindBooleanExpression(whenClause.Filter, diagnostics)
			End If
			If (Not flag1) Then
				Dim enumerator As ArrayBuilder(Of BoundCatchBlock).Enumerator = previousBlocks.GetEnumerator()
				Do
				Label1:
					If (Not enumerator.MoveNext()) Then
						boundBlock = Me.BindBlock(node, node.Statements, diagnostics).MakeCompilerGenerated()
						Return New BoundCatchBlock(node, localSymbol, boundExpression, Nothing, boundExpression1, boundBlock, False, flag1)
					End If
					Dim current As BoundCatchBlock = enumerator.Current
					If (current.ExceptionFilterOpt Is Nothing) Then
						If (current.ExceptionSourceOpt Is Nothing) Then
							type = Me.Compilation.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType.System_Exception)
						Else
							type = current.ExceptionSourceOpt.Type
						End If
						If (type.IsErrorType()) Then
							GoTo Label1
						ElseIf (Not TypeSymbol.Equals(type, wellKnownType, TypeCompareKind.ConsiderEverything)) Then
							Dim compoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
							flag = wellKnownType.IsOrDerivedFrom(type, compoundUseSiteInfo)
							diagnostics.Add(catchStatement, compoundUseSiteInfo)
						Else
							Binder.ReportDiagnostic(diagnostics, catchStatement, ERRID.WRN_DuplicateCatch, New [Object]() { wellKnownType })
							boundBlock = Me.BindBlock(node, node.Statements, diagnostics).MakeCompilerGenerated()
							Return New BoundCatchBlock(node, localSymbol, boundExpression, Nothing, boundExpression1, boundBlock, False, flag1)
						End If
					Else
						GoTo Label1
					End If
				Loop While Not flag
				Binder.ReportDiagnostic(diagnostics, catchStatement, ERRID.WRN_OverlappingCatch, New [Object]() { wellKnownType, type })
			End If
			boundBlock = Me.BindBlock(node, node.Statements, diagnostics).MakeCompilerGenerated()
			Return New BoundCatchBlock(node, localSymbol, boundExpression, Nothing, boundExpression1, boundBlock, False, flag1)
		End Function

		Public Function BindCatchBlocks(ByVal catchClauses As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundCatchBlock)
			Dim immutableAndFree As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundCatchBlock)
			Dim count As Integer = catchClauses.Count
			If (count <> 0) Then
				Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundCatchBlock) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundCatchBlock).GetInstance(count)
				Dim enumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax).Enumerator = catchClauses.GetEnumerator()
				While enumerator.MoveNext()
					Dim current As Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax = enumerator.Current
					Dim boundCatchBlock As Microsoft.CodeAnalysis.VisualBasic.BoundCatchBlock = Me.GetBinder(current).BindCatchBlock(current, instance, diagnostics)
					instance.Add(boundCatchBlock)
				End While
				immutableAndFree = instance.ToImmutableAndFree()
			Else
				immutableAndFree = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundCatchBlock).Empty
			End If
			Return immutableAndFree
		End Function

		Friend Overridable Function BindCatchVariableDeclaration(ByVal name As Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax, ByVal asClause As Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundLocal
			Dim identifier As Microsoft.CodeAnalysis.SyntaxToken = name.Identifier
			Dim localForDeclaration As LocalSymbol = Me.GetLocalForDeclaration(identifier)
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Me.BindTypeSyntax(asClause.Type(), diagnostics, False, False, False)
			Me.VerifyLocalSymbolNameAndSetType(localForDeclaration, typeSymbol, name, identifier, diagnostics)
			Return New BoundLocal(name, localForDeclaration, localForDeclaration.Type)
		End Function

		Private Function BindCollectionInitializer(ByVal objectCreationSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax, ByVal initializedObjectType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundCollectionInitializerExpression
			Dim kind As Func(Of Symbol, Boolean)
			Dim initializer As Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCollectionInitializerSyntax = DirectCast(objectCreationSyntax.Initializer, Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCollectionInitializerSyntax)
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = initializedObjectType
			Dim typeSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim boundLValuePlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundLValuePlaceholder = Nothing
			Dim boundRValuePlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder = Nothing
			Dim instance As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.GetInstance(diagnostics)
			Dim flag As Boolean = False
			If (Not Me.MatchesForEachCollectionDesignPattern(typeSymbol, New Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder(initializer, initializedObjectType), typeSymbol1, boundExpression, boundLValuePlaceholder, boundExpression, boundExpression, boundRValuePlaceholder, instance)) Then
				Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.GetInstance(diagnostics)
				Dim specialType As NamedTypeSymbol = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Collections_IEnumerable, objectCreationSyntax, bindingDiagnosticBag)
				Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
				If (Not Binder.IsOrInheritsFromOrImplementsInterface(typeSymbol, specialType, newCompoundUseSiteInfo, Nothing)) Then
					Binder.ReportDiagnostic(diagnostics, initializer, ErrorFactory.ErrorInfo(ERRID.ERR_NotACollection1, New [Object]() { typeSymbol.Name }))
				Else
					diagnostics.AddRange(bindingDiagnosticBag, False)
					flag = True
				End If
				diagnostics.Add(initializer, newCompoundUseSiteInfo)
				bindingDiagnosticBag.Free()
			Else
				diagnostics.AddRange(instance, False)
				flag = True
			End If
			Dim lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult = Microsoft.CodeAnalysis.VisualBasic.LookupResult.GetInstance()
			instance.Clear()
			Dim typeSymbol2 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = typeSymbol
			If (Binder._Closure$__.$I457-0 Is Nothing) Then
				kind = Function(y As Symbol) y.Kind = SymbolKind.Method
				Binder._Closure$__.$I457-0 = kind
			Else
				kind = Binder._Closure$__.$I457-0
			End If
			Me.GetMemberIfMatchesRequirements("Add", typeSymbol2, kind, lookupResult, initializer, instance)
			Dim initializers As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax) = initializer.Initializer.Initializers
			Dim count As Integer = initializers.Count
			Dim boundWithLValueExpressionPlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundWithLValueExpressionPlaceholder = Nothing
			If (lookupResult.IsGood) Then
				diagnostics.AddRange(instance, False)
			ElseIf (flag) Then
				Binder.ReportDiagnostic(diagnostics, initializer, ErrorFactory.ErrorInfo(ERRID.ERR_NoAddMethod1, New [Object]() { typeSymbol }))
			End If
			instance.Free()
			Dim boundExpressionArray(count - 1 + 1 - 1) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			boundWithLValueExpressionPlaceholder = New Microsoft.CodeAnalysis.VisualBasic.BoundWithLValueExpressionPlaceholder(objectCreationSyntax, typeSymbol)
			boundWithLValueExpressionPlaceholder.SetWasCompilerGenerated()
			Dim num As Integer = count - 1
			Dim num1 As Integer = 0
			Do
				boundExpressionArray(num1) = Me.BindCollectionInitializerElement(initializers(num1), boundWithLValueExpressionPlaceholder, lookupResult, diagnostics)
				num1 = num1 + 1
			Loop While num1 <= num
			Dim boundExpressions As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpressionArray)
			lookupResult.Free()
			Return New BoundCollectionInitializerExpression(objectCreationSyntax.Initializer, boundWithLValueExpressionPlaceholder, boundExpressions, typeSymbol, False)
		End Function

		Private Function BindCollectionInitializerElement(ByVal topLevelInitializer As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax, ByVal placeholder As BoundWithLValueExpressionPlaceholder, ByVal result As LookupResult, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance()
			If (topLevelInitializer.Kind() <> SyntaxKind.CollectionInitializer) Then
				instance.Add(Me.BindValue(topLevelInitializer, diagnostics, False))
			Else
				Dim initializers As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax) = DirectCast(topLevelInitializer, Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax).Initializers
				If (Not DirectCast(initializers, IReadOnlyCollection(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)).IsEmpty()) Then
					Dim enumerator As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax).Enumerator = initializers.GetEnumerator()
					While enumerator.MoveNext()
						Dim current As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = enumerator.Current
						instance.Add(Me.BindValue(current, diagnostics, False))
					End While
				Else
					Binder.ReportDiagnostic(diagnostics, topLevelInitializer, ErrorFactory.ErrorInfo(ERRID.ERR_EmptyAggregateInitializer))
				End If
			End If
			If (Not result.IsGood OrElse instance.IsEmpty()) Then
				boundExpression = (New BoundBadExpression(topLevelInitializer, LookupResultKind.Empty, ImmutableArray(Of Symbol).Empty, instance.ToImmutableAndFree(), ErrorTypeSymbol.UnknownResultType, True)).MakeCompilerGenerated()
			Else
				Dim boundMethodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup = Me.CreateBoundMethodGroup(topLevelInitializer, result, LookupOptions.AllMethodsOfAnyArity, diagnostics.AccumulatesDependencies, placeholder, Nothing, QualificationKind.QualifiedViaValue, False).MakeCompilerGenerated()
				Dim immutableAndFree As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = instance.ToImmutableAndFree()
				Dim strs As ImmutableArray(Of String) = New ImmutableArray(Of String)()
				Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindInvocationExpression(topLevelInitializer, topLevelInitializer, TypeCharacter.None, boundMethodGroup, immutableAndFree, strs, diagnostics, topLevelInitializer, False, False, False, Nothing, False)
				boundExpression1.SetWasCompilerGenerated()
				If (boundExpression1.Kind = BoundKind.LateInvocation) Then
					boundExpression1 = DirectCast(boundExpression1, BoundLateInvocation).SetLateBoundAccessKind(LateBoundAccessKind.[Call])
				End If
				boundExpression = boundExpression1
			End If
			Return boundExpression
		End Function

		Private Function BindCollectionRangeVariable(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax, ByVal beginsTheQuery As Boolean, ByVal declaredNames As HashSet(Of String), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundQueryableSource
			Dim unknownResultType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim boundQuerySource As Microsoft.CodeAnalysis.VisualBasic.BoundQueryPart = New Microsoft.CodeAnalysis.VisualBasic.BoundQuerySource(Me.BindRValue(syntax.Expression, diagnostics, False))
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
			Dim queryableType As BoundExpression = Me.ConvertToQueryableType(boundQuerySource, diagnostics, typeSymbol)
			Dim flag As Boolean = False
			If (typeSymbol Is Nothing) Then
				If (Not boundQuerySource.HasErrors) Then
					Binder.ReportDiagnostic(diagnostics, syntax.Expression, ERRID.ERR_ExpectedQueryableSource, New [Object]() { boundQuerySource.Type })
				End If
				flag = True
			ElseIf (boundQuerySource <> queryableType) Then
				boundQuerySource = (New BoundToQueryableCollectionConversion(DirectCast(queryableType, BoundCall))).MakeCompilerGenerated()
			End If
			Dim typeSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
			If (syntax.AsClause IsNot Nothing) Then
				typeSymbol1 = Me.DecodeModifiedIdentifierType(syntax.Identifier, syntax.AsClause, Nothing, Nothing, diagnostics, Binder.ModifiedIdentifierTypeDecoderContext.LocalType Or Binder.ModifiedIdentifierTypeDecoderContext.QueryRangeVariableType)
			ElseIf (syntax.Identifier.Nullable.Node IsNot Nothing) Then
				Binder.ReportDiagnostic(diagnostics, syntax.Identifier.Nullable, ERRID.ERR_NullableTypeInferenceNotSupported)
			End If
			If (typeSymbol Is Nothing) Then
				If (typeSymbol1 IsNot Nothing) Then
					typeSymbol = typeSymbol1
				Else
					typeSymbol = ErrorTypeSymbol.UnknownResultType
				End If
			ElseIf (typeSymbol1 IsNot Nothing AndAlso Not typeSymbol1.IsSameTypeIgnoringAll(typeSymbol)) Then
				boundQuerySource = Me.ApplyImplicitCollectionConversion(syntax, boundQuerySource, typeSymbol, typeSymbol1, diagnostics)
				typeSymbol = typeSymbol1
			End If
			Dim rangeVariableSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol = Nothing
			Dim valueText As String = syntax.Identifier.Identifier.ValueText
			Dim rangeVariableSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol = Nothing
			If (valueText IsNot Nothing AndAlso valueText.Length = 0) Then
				valueText = Nothing
			End If
			If (valueText Is Nothing) Then
				rangeVariableSymbol = Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol.CreateForErrorRecovery(Me, syntax, typeSymbol)
			Else
				rangeVariableSymbol = Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol.Create(Me, syntax.Identifier.Identifier, typeSymbol)
				rangeVariableSymbol1 = rangeVariableSymbol
				Dim flag1 As Boolean = False
				If (declaredNames Is Nothing OrElse declaredNames.Add(valueText)) Then
					Me.VerifyRangeVariableName(rangeVariableSymbol, syntax.Identifier.Identifier, diagnostics)
					If (Not beginsTheQuery AndAlso declaredNames Is Nothing AndAlso Binder.ShadowsRangeVariableInTheChildScope(Me, rangeVariableSymbol)) Then
						flag1 = True
					End If
				Else
					Binder.ReportDiagnostic(diagnostics, syntax.Identifier.Identifier, ERRID.ERR_QueryDuplicateAnonTypeMemberName1, New [Object]() { valueText })
					flag1 = True
				End If
				If (flag1) Then
					rangeVariableSymbol = Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol.CreateForErrorRecovery(Me, rangeVariableSymbol.Syntax, typeSymbol)
				End If
			End If
			Dim collectionRangeVariableSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax = syntax
			Dim boundQueryPart As Microsoft.CodeAnalysis.VisualBasic.BoundQueryPart = boundQuerySource
			Dim rangeVariableSymbol2 As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol = rangeVariableSymbol1
			Dim rangeVariableSymbols As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol) = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)(rangeVariableSymbol)
			Dim typeSymbol2 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = typeSymbol
			Dim empty As ImmutableArray(Of !0) = ImmutableArray(Of Binder).Empty
			If (flag) Then
				unknownResultType = ErrorTypeSymbol.UnknownResultType
			Else
				unknownResultType = boundQuerySource.Type
			End If
			Return New BoundQueryableSource(collectionRangeVariableSyntax, boundQueryPart, rangeVariableSymbol2, rangeVariableSymbols, typeSymbol2, empty, unknownResultType, flag)
		End Function

		Private Function BindCollectionRangeVariables(ByVal clauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax, ByVal sourceOpt As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase, ByVal variables As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax), ByRef operatorsEnumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase
			Dim boundQueryClause As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase
			Dim binders As ImmutableArray(Of Binder)
			Dim empty As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim span As TextSpan
			Dim separator As Microsoft.CodeAnalysis.SyntaxToken
			Dim num As Integer
			If (variables.Count <> 0) Then
				Dim boundQueryClauseBase As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase = sourceOpt
				If (boundQueryClauseBase Is Nothing) Then
					boundQueryClauseBase = Me.BindCollectionRangeVariable(variables(0), True, Nothing, diagnostics)
				End If
				Dim discarded As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
				num = If(boundQueryClauseBase = sourceOpt, 0, 1)
				Dim count As Integer = variables.Count - 1
				Dim num1 As Integer = num
				While num1 <= count
					Dim item As Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax = variables(num1)
					Dim boundLambdaParameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol = Me.CreateQueryLambdaParameterSymbol(Binder.GetQueryLambdaParameterName(boundQueryClauseBase.RangeVariables), 0, boundQueryClauseBase.CompoundVariableType, item, boundQueryClauseBase.RangeVariables)
					Dim synthesizedLambdaSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaSymbol = Me.CreateQueryLambdaSymbol(LambdaUtilities.GetFromOrAggregateVariableLambdaBody(item), Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaKind.FromOrAggregateVariableQueryLambda, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol)(boundLambdaParameterSymbol))
					Dim queryLambdaBinder As Binder.QueryLambdaBinder = New Binder.QueryLambdaBinder(synthesizedLambdaSymbol, boundQueryClauseBase.RangeVariables)
					Dim boundQueryableSource As Microsoft.CodeAnalysis.VisualBasic.BoundQueryableSource = queryLambdaBinder.BindCollectionRangeVariable(item, False, Nothing, diagnostics)
					Dim boundQueryLambda As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Binder.CreateBoundQueryLambda(synthesizedLambdaSymbol, boundQueryClauseBase.RangeVariables, boundQueryableSource, False)
					boundQueryLambda.SetWasCompilerGenerated()
					Dim boundLambdaParameterSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol = Me.CreateQueryLambdaParameterSymbol(Binder.GetQueryLambdaParameterNameLeft(boundQueryClauseBase.RangeVariables), 0, boundQueryClauseBase.CompoundVariableType, item, boundQueryClauseBase.RangeVariables)
					Dim boundLambdaParameterSymbol2 As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol = Me.CreateQueryLambdaParameterSymbol(Binder.GetQueryLambdaParameterNameRight(boundQueryableSource.RangeVariables), 1, boundQueryableSource.CompoundVariableType, item, boundQueryableSource.RangeVariables)
					Dim queryClauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax = Nothing
					If (num1 = variables.Count - 1) Then
						queryClauseSyntax = Binder.JoinShouldAbsorbNextOperator(operatorsEnumerator)
					End If
					Dim rangeVariables As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol) = boundQueryClauseBase.RangeVariables
					Dim rangeVariableSymbols As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol) = Microsoft.CodeAnalysis.ImmutableArrayExtensions.Concat(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)(rangeVariables, boundQueryableSource.RangeVariables)
					Dim boundQueryClauseBase1 As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase = Nothing
					Dim intoClauseDisallowGroupReferenceBinder As Binder.IntoClauseDisallowGroupReferenceBinder = Nothing
					Dim queryLambdaBinder1 As Binder.QueryLambdaBinder = Nothing
					Dim synthesizedLambdaKind As Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaKind = Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaKind.UserDefined
					Dim visualBasicSyntaxNode As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode = Nothing
					Binder.GetAbsorbingJoinSelectorLambdaKindAndSyntax(clauseSyntax, queryClauseSyntax, synthesizedLambdaKind, visualBasicSyntaxNode)
					Dim synthesizedLambdaSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaSymbol = Me.CreateQueryLambdaSymbol(visualBasicSyntaxNode, synthesizedLambdaKind, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol)(boundLambdaParameterSymbol1, boundLambdaParameterSymbol2))
					If (queryClauseSyntax Is Nothing) Then
						empty = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol).Empty
						If (rangeVariables.Length <= 0) Then
							boundExpression = (New BoundParameter(boundLambdaParameterSymbol2.Syntax, boundLambdaParameterSymbol2, False, boundLambdaParameterSymbol2.Type)).MakeCompilerGenerated()
						Else
							queryLambdaBinder1 = New Binder.QueryLambdaBinder(synthesizedLambdaSymbol1, rangeVariableSymbols)
							boundExpression = queryLambdaBinder1.BuildJoinSelector(item, If(num1 <> variables.Count - 1, False, Binder.MustProduceFlatCompoundVariable(operatorsEnumerator)), diagnostics, Nothing, Nothing)
						End If
						binders = ImmutableArray.Create(Of Binder)(queryLambdaBinder)
					Else
						queryLambdaBinder1 = New Binder.QueryLambdaBinder(synthesizedLambdaSymbol1, rangeVariableSymbols)
						empty = New ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)()
						boundExpression = queryLambdaBinder1.BindAbsorbingJoinSelector(queryClauseSyntax, operatorsEnumerator, rangeVariables, boundQueryableSource.RangeVariables, empty, boundQueryClauseBase1, intoClauseDisallowGroupReferenceBinder, diagnostics)
						binders = ImmutableArray.Create(Of Binder)(queryLambdaBinder, queryLambdaBinder1)
					End If
					Dim boundQueryLambda1 As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Binder.CreateBoundQueryLambda(synthesizedLambdaSymbol1, rangeVariableSymbols, boundExpression, False)
					synthesizedLambdaSymbol1.SetQueryLambdaReturnType(boundExpression.Type)
					boundQueryLambda1.SetWasCompilerGenerated()
					If (Not boundQueryClauseBase.Type.IsErrorType()) Then
						If (discarded <> Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded AndAlso (Binder.ShouldSuppressDiagnostics(boundQueryLambda) OrElse Binder.ShouldSuppressDiagnostics(boundQueryLambda1))) Then
							discarded = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
						End If
						If (num1 <> 0) Then
							separator = variables.GetSeparator(num1 - 1)
							span = separator.Span
						Else
							separator = clauseSyntax.GetFirstToken(False, False, False, False)
							span = separator.Span
						End If
						boundExpression1 = Me.BindQueryOperatorCall(item, boundQueryClauseBase, "SelectMany", ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundQueryLambda, boundQueryLambda1), span, discarded)
					Else
						boundExpression1 = Binder.BadExpression(item, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundQueryClauseBase, boundQueryLambda, boundQueryLambda1), ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
					End If
					boundQueryClauseBase = New Microsoft.CodeAnalysis.VisualBasic.BoundQueryClause(item, boundExpression1, rangeVariableSymbols, boundQueryLambda1.Expression.Type, binders, boundExpression1.Type, False)
					If (queryClauseSyntax Is Nothing) Then
						num1 = num1 + 1
					Else
						boundQueryClauseBase = Me.AbsorbOperatorFollowingJoin(DirectCast(boundQueryClauseBase, Microsoft.CodeAnalysis.VisualBasic.BoundQueryClause), queryClauseSyntax, operatorsEnumerator, empty, queryLambdaBinder1, rangeVariables, boundQueryableSource.RangeVariables, boundQueryClauseBase1, intoClauseDisallowGroupReferenceBinder, diagnostics)
						Exit While
					End If
				End While
				boundQueryClause = boundQueryClauseBase
			Else
				Dim rangeVariableSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol = Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol.CreateForErrorRecovery(Me, clauseSyntax, ErrorTypeSymbol.UnknownResultType)
				If (sourceOpt IsNot Nothing) Then
					Dim boundBadExpression As Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression = Binder.BadExpression(clauseSyntax, sourceOpt, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
					Dim rangeVariables1 As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol) = sourceOpt.RangeVariables
					boundQueryClause = New Microsoft.CodeAnalysis.VisualBasic.BoundQueryClause(clauseSyntax, boundBadExpression, rangeVariables1.Add(rangeVariableSymbol), ErrorTypeSymbol.UnknownResultType, ImmutableArray.Create(Of Binder)(Me), ErrorTypeSymbol.UnknownResultType, True)
				Else
					boundQueryClause = New Microsoft.CodeAnalysis.VisualBasic.BoundQueryableSource(clauseSyntax, (New BoundQuerySource(Binder.BadExpression(clauseSyntax, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated())).MakeCompilerGenerated(), Nothing, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)(rangeVariableSymbol), ErrorTypeSymbol.UnknownResultType, ImmutableArray.Create(Of Binder)(Me), ErrorTypeSymbol.UnknownResultType, True)
				End If
			End If
			Return boundQueryClause
		End Function

		Private Function BindCompoundAssignment(ByVal node As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal left As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal right As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal operatorTokenKind As SyntaxKind, ByVal operatorKind As BinaryOperatorKind, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundAssignmentOperator
			Dim hasErrors As Boolean = False
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.AdjustAssignmentTarget(node, left, diagnostics, hasErrors)
			If (Not hasErrors) Then
				hasErrors = Me.MakeRValue(left, diagnostics).HasErrors
			Else
				Me.MakeRValueAndIgnoreDiagnostics(left)
			End If
			Dim type As TypeSymbol = boundExpression.Type
			Dim boundCompoundAssignmentTargetPlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundCompoundAssignmentTargetPlaceholder = Nothing
			If (hasErrors) Then
				diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
			End If
			boundCompoundAssignmentTargetPlaceholder = (New Microsoft.CodeAnalysis.VisualBasic.BoundCompoundAssignmentTargetPlaceholder(left.Syntax, type)).MakeCompilerGenerated()
			right = Me.BindBinaryOperator(node, boundCompoundAssignmentTargetPlaceholder, right, operatorTokenKind, operatorKind, False, diagnostics, False)
			right.SetWasCompilerGenerated()
			right = Me.ApplyImplicitConversion(node, type, right, diagnostics, False)
			left = left.SetGetSetAccessKindIfAppropriate()
			Return New BoundAssignmentOperator(node, left, boundCompoundAssignmentTargetPlaceholder, right, False, hasErrors)
		End Function

		Private Function BindConditionalAccessExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundRValuePlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder = Nothing
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindConditionalAccessReceiver(node, diagnostics, boundRValuePlaceholder)
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = (New ConditionalAccessBinder(Me, node, boundRValuePlaceholder)).BindExpression(node.WhenNotNull, diagnostics)
			Return New BoundConditionalAccess(node, boundExpression, boundRValuePlaceholder, boundExpression1, Nothing, False)
		End Function

		Private Function BindConditionalAccessReceiver(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, <Out> ByRef placeholder As BoundRValuePlaceholder) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			If (node.Expression IsNot Nothing) Then
				boundExpression = Me.BindValue(node.Expression, diagnostics, False)
				If (Not boundExpression.IsLValue) Then
					boundExpression = Me.MakeRValue(boundExpression, diagnostics)
				End If
			Else
				boundExpression = If(Me.TryBindOmittedLeftForConditionalAccess(node, Me, diagnostics), Binder.ReportDiagnosticAndProduceBadExpression(diagnostics, node, ERRID.ERR_BadConditionalWithRef).MakeCompilerGenerated())
			End If
			Dim type As TypeSymbol = boundExpression.Type
			Dim nullableUnderlyingType As TypeSymbol = type
			If (type.IsValueType) Then
				If (Not type.IsNullableType()) Then
					Binder.ReportDiagnostic(diagnostics, node.QuestionMarkToken, ERRID.ERR_UnaryOperand2, New [Object]() { node.QuestionMarkToken.ValueText, type })
				Else
					nullableUnderlyingType = type.GetNullableUnderlyingType()
				End If
			End If
			placeholder = New BoundRValuePlaceholder(node, nullableUnderlyingType)
			placeholder.SetWasCompilerGenerated()
			Return boundExpression
		End Function

		Private Shared Sub BindConstFieldInitializer(ByVal fieldSymbol As SourceFieldSymbol, ByVal equalsValueOrAsNewSyntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal boundInitializers As ArrayBuilder(Of BoundInitializer))
			If (fieldSymbol.IsConstButNotMetadataConstant) Then
				Dim constantValue As Microsoft.CodeAnalysis.ConstantValue = fieldSymbol.GetConstantValue(Microsoft.CodeAnalysis.VisualBasic.ConstantFieldsInProgress.Empty)
				If (constantValue IsNot Nothing) Then
					Dim boundFieldAccess As Microsoft.CodeAnalysis.VisualBasic.BoundFieldAccess = New Microsoft.CodeAnalysis.VisualBasic.BoundFieldAccess(equalsValueOrAsNewSyntax, Nothing, fieldSymbol, True, fieldSymbol.Type, False)
					boundFieldAccess.SetWasCompilerGenerated()
					Dim boundLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundLiteral = New Microsoft.CodeAnalysis.VisualBasic.BoundLiteral(equalsValueOrAsNewSyntax, constantValue, fieldSymbol.Type)
					boundInitializers.Add(New BoundFieldInitializer(equalsValueOrAsNewSyntax, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol)(fieldSymbol), boundFieldAccess, boundLiteral, False))
				End If
			End If
		End Sub

		Private Function BindContinueStatement(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim boundContinueStatement As BoundStatement
			Dim eRRID As Microsoft.CodeAnalysis.VisualBasic.ERRID = 0
			Dim continueLabel As LabelSymbol = Me.GetContinueLabel(node.Kind())
			If (continueLabel IsNot Nothing) Then
				boundContinueStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundContinueStatement(node, continueLabel)
			Else
				Select Case node.Kind()
					Case SyntaxKind.ContinueWhileStatement
						eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_ContinueWhileNotWithinWhile
						Exit Select
					Case SyntaxKind.ContinueDoStatement
						eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_ContinueDoNotWithinDo
						Exit Select
					Case SyntaxKind.ContinueForStatement
						eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_ContinueForNotWithinFor
						Exit Select
					Case Else
						ExceptionUtilities.UnexpectedValue(node.Kind())
						Exit Select
				End Select
				Binder.ReportDiagnostic(diagnostics, node, eRRID)
				boundContinueStatement = New BoundBadStatement(node, ImmutableArray(Of BoundNode).Empty, True)
			End If
			Return boundContinueStatement
		End Function

		Private Function BindCTypeExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindValue(node.Expression, diagnostics, False)
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Me.BindTypeSyntax(node.Type, diagnostics, False, False, False)
			Return Me.ApplyConversion(node, typeSymbol, boundExpression, True, diagnostics, False, False)
		End Function

		Private Function BindDefaultPropertyGroup(ByVal node As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal target As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim instance As LookupResult = LookupResult.GetInstance()
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
			Binder.MemberLookup.LookupDefaultProperty(instance, target.Type, Me, newCompoundUseSiteInfo)
			If (Not instance.HasSymbol) Then
				Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.GetInstance(diagnostics)
				target = Me.MakeRValue(target, bindingDiagnosticBag)
				Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
				target = Me.ConvertToQueryableType(target, bindingDiagnosticBag, typeSymbol)
				If (typeSymbol IsNot Nothing) Then
					instance.Clear()
					Me.LookupMember(instance, target.Type, "ElementAtOrDefault", 0, LookupOptions.AllMethodsOfAnyArity, newCompoundUseSiteInfo)
					If (instance.IsGood) Then
						Dim kind As SymbolKind = instance.Symbols(0).Kind
						If (kind = SymbolKind.Method OrElse kind = SymbolKind.[Property]) Then
							diagnostics.AddRange(bindingDiagnosticBag, False)
							boundExpression = Me.BindSymbolAccess(node, instance, LookupOptions.AllMethodsOfAnyArity, target, Nothing, QualificationKind.QualifiedViaValue, diagnostics)
						End If
					End If
				End If
				bindingDiagnosticBag.Free()
			Else
				boundExpression = Me.BindSymbolAccess(node, instance, LookupOptions.[Default], target, Nothing, QualificationKind.QualifiedViaValue, diagnostics)
			End If
			diagnostics.Add(node, newCompoundUseSiteInfo)
			instance.Free()
			If (boundExpression IsNot Nothing) Then
				boundExpression.SetWasCompilerGenerated()
			End If
			Return boundExpression
		End Function

		Private Function BindDelegateCreationExpression(ByVal delegateType As TypeSymbol, ByVal argumentListOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax, ByVal node As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim num As Integer
			Dim boundBadExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim count As Integer = 0
			If (argumentListOpt IsNot Nothing) Then
				count = argumentListOpt.Arguments.Count
			End If
			Dim hasErrors As Boolean = False
			If (count > 0) Then
				Dim item As Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax = argumentListOpt.Arguments(0)
				Dim expression As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = Nothing
				If (item.Kind() = SyntaxKind.SimpleArgument) Then
					expression = item.GetExpression()
				End If
				If (expression Is Nothing) Then
					boundBadExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression(item, LookupResultKind.Empty, ImmutableArray(Of Symbol).Empty, ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty, ErrorTypeSymbol.UnknownResultType, True)
				Else
					If (expression.Kind() = SyntaxKind.AddressOfExpression) Then
						boundBadExpression = Me.BindAddressOfExpression(expression, diagnostics)
					ElseIf (expression.IsLambdaExpressionSyntax()) Then
						boundBadExpression = Me.BindExpression(expression, diagnostics)
					End If
					If (boundBadExpression IsNot Nothing) Then
						hasErrors = boundBadExpression.HasErrors
						If (count <> 1) Then
							GoTo Label1
						End If
						boundBadExpression = Me.ApplyImplicitConversion(node, delegateType, boundBadExpression, diagnostics, False)
						If (boundBadExpression.Syntax <> node) Then
							boundBadExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundConversion(node, boundBadExpression, ConversionKind.Identity, Me.CheckOverflow, True, delegateType, False)
						ElseIf (boundBadExpression.Kind = BoundKind.Conversion) Then
							Dim boundConversion As Microsoft.CodeAnalysis.VisualBasic.BoundConversion = DirectCast(boundBadExpression, Microsoft.CodeAnalysis.VisualBasic.BoundConversion)
							boundBadExpression = boundConversion.Update(boundConversion.Operand, boundConversion.ConversionKind, boundConversion.Checked, True, boundConversion.ConstantValueOpt, boundConversion.ExtendedInfoOpt, boundConversion.Type)
						End If
						boundExpression = boundBadExpression
						Return boundExpression
					End If
				End If
			End If
		Label1:
			Dim boundExpressionArray(count - 1 + 1 - 1) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			If (boundBadExpression IsNot Nothing) Then
				boundBadExpression = Me.MakeRValueAndIgnoreDiagnostics(boundBadExpression)
				boundExpressionArray(0) = boundBadExpression
			End If
			num = If(boundBadExpression Is Nothing, 0, 1)
			Dim num1 As Integer = count - 1
			Dim num2 As Integer = num
			Do
				Dim expressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = Nothing
				Dim argumentSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax = argumentListOpt.Arguments(num2)
				If (argumentSyntax.Kind() = SyntaxKind.SimpleArgument) Then
					expressionSyntax = argumentSyntax.GetExpression()
				End If
				If (expressionSyntax Is Nothing) Then
					boundExpressionArray(num2) = New Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression(argumentSyntax, LookupResultKind.Empty, ImmutableArray(Of Symbol).Empty, ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty, ErrorTypeSymbol.UnknownResultType, True)
				Else
					boundExpressionArray(num2) = Me.BindValue(expressionSyntax, Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded, False)
				End If
				num2 = num2 + 1
			Loop While num2 <= num1
			If (Not hasErrors OrElse count <> 1) Then
				Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
				Dim visualBasicSyntaxNode As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode = argumentListOpt
				If (visualBasicSyntaxNode Is Nothing) Then
					visualBasicSyntaxNode = node
				End If
				Binder.ReportDiagnostic(bindingDiagnosticBag, visualBasicSyntaxNode, ERRID.ERR_NoDirectDelegateConstruction1, New [Object]() { delegateType })
			End If
			boundExpression = Binder.BadExpression(node, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpressionArray), delegateType)
			Return boundExpression
		End Function

		Private Function BindDictionaryAccess(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim identifier As Microsoft.CodeAnalysis.SyntaxToken
			Dim strs As ImmutableArray(Of String)
			Dim expression As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = node.Expression
			If (expression IsNot Nothing) Then
				boundExpression1 = Me.BindExpression(expression, diagnostics)
			Else
				Dim correspondingConditionalAccessExpression As Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax = node.GetCorrespondingConditionalAccessExpression()
				boundExpression1 = If(correspondingConditionalAccessExpression Is Nothing, Me.TryBindOmittedLeftForDictionaryAccess(node, Me, diagnostics), Me.GetConditionalAccessReceiver(correspondingConditionalAccessExpression))
				If (boundExpression1 IsNot Nothing) Then
					GoTo Label1
				End If
				Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Binder.ReportDiagnosticAndProduceBadExpression(diagnostics, node, ERRID.ERR_BadWithRef)
				Dim name As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax = node.Name
				identifier = node.Name.Identifier
				boundExpression = Binder.BadExpression(node, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpression2, New Microsoft.CodeAnalysis.VisualBasic.BoundLiteral(name, ConstantValue.Create(identifier.ValueText), Me.GetSpecialType(SpecialType.System_String, node.Name, diagnostics))), ErrorTypeSymbol.UnknownResultType)
				Return boundExpression
			End If
		Label1:
			If (Not boundExpression1.IsLValue AndAlso boundExpression1.Kind <> BoundKind.LateMemberAccess) Then
				boundExpression1 = Me.MakeRValue(boundExpression1, diagnostics)
			End If
			Dim type As TypeSymbol = boundExpression1.Type
			If (Not type.IsErrorType()) Then
				If (type.SpecialType = SpecialType.System_Object OrElse type.IsExtensibleInterfaceNoUseSiteDiagnostics()) Then
					Dim simpleNameSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax = node.Name
					identifier = node.Name.Identifier
					Dim boundExpressions As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(New Microsoft.CodeAnalysis.VisualBasic.BoundLiteral(simpleNameSyntax, ConstantValue.Create(identifier.ValueText), Me.GetSpecialType(SpecialType.System_String, simpleNameSyntax, diagnostics)))
					strs = New ImmutableArray(Of String)()
					boundExpression = Me.BindLateBoundInvocation(node, Nothing, boundExpression1, boundExpressions, strs, diagnostics, False)
					Return boundExpression
				Else
					If (type.IsInterfaceType()) Then
						Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
						type.AllInterfacesWithDefinitionUseSiteDiagnostics(newCompoundUseSiteInfo)
						diagnostics.Add(node, newCompoundUseSiteInfo)
					End If
					Dim boundExpression3 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindDefaultPropertyGroup(node, boundExpression1, diagnostics)
					If (boundExpression3 IsNot Nothing AndAlso boundExpression3.Kind = BoundKind.PropertyGroup) Then
						Dim name1 As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax = node.Name
						identifier = node.Name.Identifier
						Dim boundLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundLiteral = New Microsoft.CodeAnalysis.VisualBasic.BoundLiteral(name1, ConstantValue.Create(identifier.ValueText), Me.GetSpecialType(SpecialType.System_String, name1, diagnostics))
						Dim syntax As SyntaxNode = boundExpression1.Syntax
						Dim boundPropertyGroup As Microsoft.CodeAnalysis.VisualBasic.BoundPropertyGroup = DirectCast(boundExpression3, Microsoft.CodeAnalysis.VisualBasic.BoundPropertyGroup)
						Dim boundExpressions1 As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundLiteral)
						strs = New ImmutableArray(Of String)()
						boundExpression = Me.BindInvocationExpression(node, syntax, TypeCharacter.None, boundPropertyGroup, boundExpressions1, strs, diagnostics, node, False, False, True, Nothing, False)
						Return boundExpression
					End If
					If (boundExpression3 Is Nothing OrElse Not boundExpression3.HasErrors) Then
						Select Case type.TypeKind
							Case Microsoft.CodeAnalysis.TypeKind.Array
							Case Microsoft.CodeAnalysis.TypeKind.[Enum]
								Binder.ReportQualNotObjectRecord(boundExpression1, diagnostics)
								Exit Select
							Case Microsoft.CodeAnalysis.TypeKind.[Class]
								If (type.SpecialType <> SpecialType.System_Array) Then
									Binder.ReportNoDefaultProperty(boundExpression1, diagnostics)
									Exit Select
								Else
									Binder.ReportDefaultMemberNotProperty(boundExpression1, diagnostics)
									Exit Select
								End If
							Case Microsoft.CodeAnalysis.TypeKind.[Delegate]
							Case Microsoft.CodeAnalysis.TypeKind.Dynamic
							Case Microsoft.CodeAnalysis.TypeKind.[Error]
							Case Microsoft.CodeAnalysis.TypeKind.[Module]
							Case Microsoft.CodeAnalysis.TypeKind.Pointer
							Label3:
								Binder.ReportDefaultMemberNotProperty(boundExpression1, diagnostics)
								Exit Select
							Case Microsoft.CodeAnalysis.TypeKind.[Interface]
							Case Microsoft.CodeAnalysis.TypeKind.TypeParameter
								Binder.ReportNoDefaultProperty(boundExpression1, diagnostics)
								Exit Select
							Case Microsoft.CodeAnalysis.TypeKind.Struct
								If (Not type.IsIntrinsicValueType()) Then
									Binder.ReportNoDefaultProperty(boundExpression1, diagnostics)
									Exit Select
								Else
									Binder.ReportQualNotObjectRecord(boundExpression1, diagnostics)
									Exit Select
								End If
							Case Else
								GoTo Label3
						End Select
					End If
				End If
			End If
			Dim simpleNameSyntax1 As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax = node.Name
			identifier = node.Name.Identifier
			boundExpression = Binder.BadExpression(node, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpression1, New Microsoft.CodeAnalysis.VisualBasic.BoundLiteral(simpleNameSyntax1, ConstantValue.Create(identifier.ValueText), Me.GetSpecialType(SpecialType.System_String, node.Name, diagnostics))), ErrorTypeSymbol.UnknownResultType)
			Return boundExpression
		End Function

		Private Function BindDirectCastExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindValue(node.Expression, diagnostics, False)
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Me.BindTypeSyntax(node.Type, diagnostics, False, False, False)
			Return Me.ApplyDirectCastConversion(node, boundExpression, typeSymbol, diagnostics)
		End Function

		Private Function BindDirectConstructorCall(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax, ByVal group As BoundMethodGroup, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpressions As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = New ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)()
			Dim strs As ImmutableArray(Of String) = New ImmutableArray(Of String)()
			Dim locations As ImmutableArray(Of Location) = New ImmutableArray(Of Location)()
			Dim argumentList As Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax = node.ArgumentList
			If (Not Me.IsConstructorCallAllowed(node, group)) Then
				If (Not group.HasErrors) Then
					Binder.ReportDiagnostic(diagnostics, group.Syntax, ERRID.ERR_InvalidConstructorCall)
				End If
				Me.BindArgumentsAndNames(argumentList, boundExpressions, strs, locations, diagnostics)
				Dim boundCall As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindInvocationExpression(node, node.Expression, Binder.ExtractTypeCharacter(node.Expression), group, boundExpressions, strs, Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded, group.Syntax, True, False, False, Nothing, False)
				If (boundCall.Kind = BoundKind.[Call]) Then
					Dim boundCall1 As Microsoft.CodeAnalysis.VisualBasic.BoundCall = DirectCast(boundCall, Microsoft.CodeAnalysis.VisualBasic.BoundCall)
					boundCall = New Microsoft.CodeAnalysis.VisualBasic.BoundCall(boundCall1.Syntax, boundCall1.Method, boundCall1.MethodGroupOpt, boundCall1.ReceiverOpt, boundCall1.Arguments, boundCall1.DefaultArguments, boundCall1.ConstantValueOpt, False, False, boundCall1.Type, True)
				End If
				boundExpression = boundCall
			Else
				Dim constructorCallArgumentsBinder As Binder.ConstructorCallArgumentsBinder = New Binder.ConstructorCallArgumentsBinder(Me)
				constructorCallArgumentsBinder.BindArgumentsAndNames(argumentList, boundExpressions, strs, locations, diagnostics)
				boundExpression = Me.BindInvocationExpression(node, node.Expression, Binder.ExtractTypeCharacter(node.Expression), group, boundExpressions, strs, diagnostics, group.Syntax, True, False, False, Nothing, False)
			End If
			Return boundExpression
		End Function

		Private Function BindDistinctClause(ByVal source As BoundQueryClauseBase, ByVal distinct As Microsoft.CodeAnalysis.VisualBasic.Syntax.DistinctClauseSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundQueryClause
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			If (Not source.Type.IsErrorType()) Then
				Dim empty As ImmutableArray(Of !0) = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty
				Dim distinctKeyword As Microsoft.CodeAnalysis.SyntaxToken = distinct.DistinctKeyword
				boundExpression = Me.BindQueryOperatorCall(distinct, source, "Distinct", empty, distinctKeyword.Span, diagnostics)
			Else
				boundExpression = Binder.BadExpression(distinct, source, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
			End If
			Return New BoundQueryClause(distinct, boundExpression, source.RangeVariables, source.CompoundVariableType, ImmutableArray(Of Binder).Empty, boundExpression.Type, False)
		End Function

		Private Function BindDoLoop(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim flag As Boolean = False
			Dim flag1 As Boolean = False
			Dim whileOrUntilClause As Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax = node.DoStatement.WhileOrUntilClause
			If (whileOrUntilClause IsNot Nothing) Then
				boundExpression = Me.BindBooleanExpression(whileOrUntilClause.Condition, diagnostics)
				flag = whileOrUntilClause.Kind() = SyntaxKind.UntilClause
			End If
			Dim binder As Microsoft.CodeAnalysis.VisualBasic.Binder = Me.GetBinder(node)
			Dim boundBlock As Microsoft.CodeAnalysis.VisualBasic.BoundBlock = binder.BindBlock(node, node.Statements, diagnostics).MakeCompilerGenerated()
			Dim whileOrUntilClauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax = node.LoopStatement.WhileOrUntilClause
			If (whileOrUntilClauseSyntax IsNot Nothing) Then
				boundExpression1 = Me.BindBooleanExpression(whileOrUntilClauseSyntax.Condition, diagnostics)
				flag1 = whileOrUntilClauseSyntax.Kind() = SyntaxKind.UntilClause
			End If
			Return New BoundDoLoopStatement(node, boundExpression, boundExpression1, flag, flag1, boundBlock, binder.GetContinueLabel(SyntaxKind.ContinueDoStatement), binder.GetExitLabel(SyntaxKind.ExitDoStatement), If(boundExpression Is Nothing, False, boundExpression1 IsNot Nothing))
		End Function

		Private Function BindEndStatement(ByVal endStatementSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.StopOrEndStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			If (Not Me.Compilation.Options.OutputKind.IsApplication()) Then
				Binder.ReportDiagnostic(diagnostics, endStatementSyntax, ERRID.ERR_EndDisallowedInDllProjects)
			End If
			Return New BoundEndStatement(endStatementSyntax)
		End Function

		Private Function BindEraseStatement(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.EraseStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim boundAssignmentOperator As Microsoft.CodeAnalysis.VisualBasic.BoundAssignmentOperator
			Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundAssignmentOperator) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundAssignmentOperator).GetInstance()
			Dim enumerator As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax).Enumerator = node.Expressions.GetEnumerator()
			While enumerator.MoveNext()
				Dim current As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = enumerator.Current
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindAssignmentTarget(current, diagnostics)
				Dim boundLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundLiteral = (New Microsoft.CodeAnalysis.VisualBasic.BoundLiteral(current, ConstantValue.[Nothing], Nothing)).MakeCompilerGenerated()
				If (boundExpression.HasErrors) Then
					boundAssignmentOperator = (New Microsoft.CodeAnalysis.VisualBasic.BoundAssignmentOperator(current, boundExpression, boundLiteral, False, boundExpression.Type, True)).MakeCompilerGenerated()
				ElseIf (boundExpression.Type.IsErrorType() OrElse boundExpression.Type.IsArrayType() OrElse boundExpression.Type.SpecialType = SpecialType.System_Array OrElse boundExpression.Type.SpecialType = SpecialType.System_Object) Then
					boundAssignmentOperator = Me.BindAssignment(current, boundExpression, Me.ApplyImplicitConversion(current, boundExpression.Type, boundLiteral, diagnostics, False).MakeCompilerGenerated(), diagnostics).MakeCompilerGenerated()
				Else
					Binder.ReportDiagnostic(diagnostics, current, ERRID.ERR_ExpectedArray1, New [Object]() { "Erase" })
					boundAssignmentOperator = (New Microsoft.CodeAnalysis.VisualBasic.BoundAssignmentOperator(current, boundExpression, boundLiteral, False, boundExpression.Type, True)).MakeCompilerGenerated()
				End If
				instance.Add(boundAssignmentOperator)
			End While
			Return New BoundEraseStatement(node, instance.ToImmutableAndFree(), False)
		End Function

		Private Function BindError(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ErrorStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.ApplyImplicitConversion(node.ErrorNumber, Me.GetSpecialType(SpecialType.System_Int32, node.ErrorNumber, diagnostics), Me.BindValue(node.ErrorNumber, diagnostics, False), diagnostics, False)
			Return New BoundThrowStatement(node, boundExpression, False)
		End Function

		Friend Overridable Function BinderSpecificLookupOptions(ByVal options As LookupOptions) As LookupOptions
			Return Me.m_containingBinder.BinderSpecificLookupOptions(options)
		End Function

		Private Function BindEventAccess(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, <Out> ByRef actualEventAccess As BoundEventAccess, <Out> ByRef eventSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.EventSymbol) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim containingSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbol
			Dim expression As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = node
			While expression.Kind() = SyntaxKind.ParenthesizedExpression
				expression = DirectCast(expression, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParenthesizedExpressionSyntax).Expression
			End While
			Dim name As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = expression
			If (name.Kind() = SyntaxKind.SimpleMemberAccessExpression) Then
				name = DirectCast(name, Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax).Name
			End If
			If (name.Kind() = SyntaxKind.IdentifierName) Then
				boundExpression1 = If(expression.Kind() <> SyntaxKind.IdentifierName, Me.BindExpression(node, False, False, True, diagnostics), Me.BindSimpleName(DirectCast(expression, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax), False, diagnostics, True))
				Dim mostEnclosedParenthesizedExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = boundExpression1.GetMostEnclosedParenthesizedExpression()
				If (mostEnclosedParenthesizedExpression.Kind <> BoundKind.EventAccess) Then
					mostEnclosedParenthesizedExpression = Me.MakeRValue(mostEnclosedParenthesizedExpression, diagnostics)
					If (Not mostEnclosedParenthesizedExpression.HasErrors) Then
						Dim valueText As String = DirectCast(name, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax).Identifier.ValueText
						Dim expressionSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbol = mostEnclosedParenthesizedExpression.ExpressionSymbol
						If (expressionSymbol IsNot Nothing) Then
							containingSymbol = expressionSymbol.ContainingSymbol
						Else
							containingSymbol = Me.Compilation.GetSpecialType(SpecialType.System_Object)
						End If
						Dim symbol As Microsoft.CodeAnalysis.VisualBasic.Symbol = containingSymbol
						Binder.ReportDiagnostic(diagnostics, name, ERRID.ERR_NameNotEvent2, New [Object]() { valueText, symbol })
					End If
				Else
					actualEventAccess = DirectCast(mostEnclosedParenthesizedExpression, BoundEventAccess)
					eventSymbol = actualEventAccess.EventSymbol
				End If
				boundExpression = boundExpression1
			Else
				Binder.ReportDiagnostic(diagnostics, name, ERRID.ERR_AddOrRemoveHandlerEvent)
				boundExpression = Me.BindRValue(node, Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded, False)
			End If
			Return boundExpression
		End Function

		Private Function BindExitStatement(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim boundExitStatement As BoundStatement
			Dim eRRID As Microsoft.CodeAnalysis.VisualBasic.ERRID = 0
			Dim exitLabel As LabelSymbol = Me.GetExitLabel(node.Kind())
			If (exitLabel IsNot Nothing) Then
				boundExitStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundExitStatement(node, exitLabel)
			Else
				Select Case node.Kind()
					Case SyntaxKind.ExitDoStatement
						eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_ExitDoNotWithinDo
						Exit Select
					Case SyntaxKind.ExitForStatement
						eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_ExitForNotWithinFor
						Exit Select
					Case SyntaxKind.ExitSubStatement
						eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_ExitSubOfFunc
						Exit Select
					Case SyntaxKind.ExitFunctionStatement
						eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_ExitFuncOfSub
						Exit Select
					Case SyntaxKind.ExitOperatorStatement
					Label0:
						ExceptionUtilities.UnexpectedValue(node.Kind())
						Exit Select
					Case SyntaxKind.ExitPropertyStatement
						eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_ExitPropNot
						Exit Select
					Case SyntaxKind.ExitTryStatement
						eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_ExitTryNotWithinTry
						Exit Select
					Case SyntaxKind.ExitSelectStatement
						eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_ExitSelectNotWithinSelect
						Exit Select
					Case SyntaxKind.ExitWhileStatement
						eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_ExitWhileNotWithinWhile
						Exit Select
					Case Else
						GoTo Label0
				End Select
				Binder.ReportDiagnostic(diagnostics, node, eRRID)
				boundExitStatement = New BoundBadStatement(node, ImmutableArray(Of BoundNode).Empty, True)
			End If
			Return boundExitStatement
		End Function

		Public Function BindExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Return Me.BindExpression(node, False, False, False, diagnostics)
		End Function

		Public Function BindExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax, ByVal isInvocationOrAddressOf As Boolean, ByVal isOperandOfConditionalBranch As Boolean, ByVal eventContext As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundTypeExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			If (Not Me.IsEarlyAttributeBinder OrElse EarlyWellKnownAttributeBinder.CanBeValidAttributeArgument(node, Me)) Then
				Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = node.Kind()
				If (syntaxKind <= Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ConditionalAccessExpression) Then
					If (CUShort(syntaxKind) - CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IdentifierLabel) <= CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement)) Then
						boundTypeExpression = Me.BindLabel(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax), diagnostics)
						Return boundTypeExpression
					Else
						Select Case syntaxKind
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CharacterLiteralExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TrueLiteralExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FalseLiteralExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NumericLiteralExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DateLiteralExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.StringLiteralExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NothingLiteralExpression
								boundTypeExpression = Me.BindLiteralConstant(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndIfStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndGetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndOperatorStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MidExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CallStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CharacterLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TrueLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DateLiteralExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndUsingStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndOperatorStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndAddHandlerStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RightShiftAssignmentStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MidExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddHandlerStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CharacterLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FalseLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DateLiteralExpression
							Case 288
							Case 289
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSelectStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndStructureStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndEnumStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndInterfaceStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OptionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ImportsStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RightShiftAssignmentStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ConcatenateAssignmentStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RaiseEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ReDimStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ReDimPreserveStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GetXmlNamespaceExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleMemberAccessExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InvocationExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ObjectCreationExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AnonymousObjectCreationExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSelectStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndClassStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleImportsClause Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MidExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RaiseEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DictionaryAccessExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InvocationExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSelectStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndRaiseEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamespaceBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RaiseEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CharacterLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NothingLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InvocationExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DirectCastExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSelectStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndStructureStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndGetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndRaiseEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndWhileStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OptionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamespaceBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamespaceStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InheritsStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RaiseEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CharacterLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TrueLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NothingLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ParenthesizedExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InvocationExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ObjectCreationExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DirectCastExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TryCastExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndOperatorStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SetAccessorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MidExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CharacterLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DateLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotEqualsExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GreaterThanExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddressOfExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndIfStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndGetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndOperatorStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ConstructorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SetAccessorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddHandlerAccessorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MidExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CallStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CharacterLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TrueLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DateLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotEqualsExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LessThanExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GreaterThanExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IsExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddressOfExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.BinaryConditionalExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SubLambdaHeader
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionLambdaHeader
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ArgumentList
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OmittedArgument
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleArgument
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndUsingStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSelectStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndEnumStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndClassStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndNamespaceStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndOperatorStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndAddHandlerStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndRaiseEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndTryStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeParameterList Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeParameterSingleConstraintClause Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NewConstraint Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.StructureConstraint Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EnumMemberDeclaration Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OperatorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SetAccessorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RemoveHandlerAccessorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PropertyBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ParameterList Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RightShiftAssignmentStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MidExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddHandlerStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RaiseEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ReDimStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RedimClause Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CharacterLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FalseLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DateLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NothingLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MeExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MyClassExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeOfIsExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotEqualsExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LessThanOrEqualExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GreaterThanExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IsNotExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OrExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AndExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AndAlsoExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UnaryMinusExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddressOfExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TernaryConditionalExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineSubLambdaExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MultiLineSubLambdaExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionLambdaHeader Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OmittedArgument
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RangeArgument
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CollectionRangeVariable
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExpressionRangeVariable
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AggregationRangeVariable
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.VariableNameEquals
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FromClause
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LetClause
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AggregateClause
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DistinctClause
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WhereClause
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SkipWhileClause
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TakeWhileClause
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SkipClause
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TakeClause
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GroupByClause
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.JoinCondition
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleJoinClause
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GroupJoinClause
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OrderByClause
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndIfStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndGetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndOperatorStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamespaceBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamespaceStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InterfaceBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ClassBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ConstructorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SetAccessorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddHandlerAccessorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DeclareSubStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DeclareFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ImplementsClause Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.HandlesClause Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithEventsPropertyEventContainer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.HandlesClauseItem Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MidExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CallStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CharacterLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TrueLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DateLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DictionaryAccessExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlElementAccessExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DirectCastExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TryCastExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SubtractExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MultiplyExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotEqualsExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LessThanExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GreaterThanExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IsExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddressOfExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.BinaryConditionalExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.QueryExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CollectionRangeVariable Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.VariableNameEquals Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionAggregation Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GroupByClause Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.JoinCondition Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OrderByClause
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndUsingStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndOperatorStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndAddHandlerStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CompilationUnit Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamespaceBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ModuleBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InterfaceBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EnumBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeParameterList Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeParameterSingleConstraintClause Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OperatorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SetAccessorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RemoveHandlerAccessorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DeclareSubStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DelegateSubStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ImplementsClause Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.KeywordEventContainer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithEventsPropertyEventContainer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IncompleteMember Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RightShiftAssignmentStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MidExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddHandlerStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CharacterLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FalseLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DateLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GetXmlNamespaceExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DictionaryAccessExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlDescendantAccessExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DirectCastExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PredefinedCastExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SubtractExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DivideExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotEqualsExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LessThanOrEqualExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GreaterThanExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IsNotExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddressOfExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TernaryConditionalExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineSubLambdaExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.QueryExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExpressionRangeVariable Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.VariableNameEquals Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GroupAggregation Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GroupByClause Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleJoinClause Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OrderByClause
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AscendingOrdering
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DescendingOrdering
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SelectClause
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlDeclaration
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlDeclarationOption
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlText
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlElementStartTag
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlElementEndTag
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlAttribute
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlString
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlPrefixName
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlName
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlBracketedName
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlPrefix
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ArrayType
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeArgumentList
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CrefReference
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndIfStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndGetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndOperatorStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamedFieldInitializer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EqualsValue Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Parameter Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ModifiedIdentifier Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UsingBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SyncLockBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LabelStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GoToStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MidExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CallStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CharacterLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TrueLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DateLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlElementEndTag Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlEmptyElement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlPrefixName Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlName Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GenericName Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.QualifiedName Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CrefReference
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndUsingStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndOperatorStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndAddHandlerStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamedFieldInitializer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Parameter Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ArrayRankSpecifier Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UsingBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LabelStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IdentifierLabel Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RightShiftAssignmentStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MidExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddHandlerStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CharacterLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FalseLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DateLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlElementEndTag Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlAttribute Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlPrefixName Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlBracketedName Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GenericName Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GlobalName Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CrefReference
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CrefSignature
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CrefSignaturePart
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CrefOperatorReference
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.QualifiedCrefOperatorReference
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.YieldStatement
								Exit Select
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ParenthesizedExpression
								Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParenthesizedExpressionSyntax).Expression, False, isOperandOfConditionalBranch, eventContext, diagnostics)
								If (boundExpression.Kind = BoundKind.TypeExpression) Then
									Dim boundTypeExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundTypeExpression = DirectCast(boundExpression, Microsoft.CodeAnalysis.VisualBasic.BoundTypeExpression)
									boundTypeExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundTypeExpression(node, boundTypeExpression1.UnevaluatedReceiverOpt, boundTypeExpression1.AliasOpt, boundExpression.Type, boundExpression.HasErrors)
									Return boundTypeExpression
								ElseIf (boundExpression.Kind <> BoundKind.ArrayLiteral) Then
									boundTypeExpression = New BoundParenthesized(node, boundExpression, boundExpression.Type, False)
									Return boundTypeExpression
								Else
									Dim boundArrayLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundArrayLiteral = DirectCast(boundExpression, Microsoft.CodeAnalysis.VisualBasic.BoundArrayLiteral)
									Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.ReclassifyArrayLiteralExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CTypeKeyword, boundArrayLiteral.Syntax, ConversionKind.[Widening], False, boundArrayLiteral, boundArrayLiteral.InferredType, diagnostics)
									boundTypeExpression = New BoundParenthesized(node, boundExpression1, boundExpression1.Type, False)
									Return boundTypeExpression
								End If
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MeExpression
								boundTypeExpression = Me.BindMeExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.MeExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MyBaseExpression
								boundTypeExpression = Me.BindMyBaseExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.MyBaseExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MyClassExpression
								boundTypeExpression = Me.BindMyClassExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.MyClassExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GetTypeExpression
								boundTypeExpression = Me.BindGetTypeExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.GetTypeExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeOfIsExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeOfIsNotExpression
								boundTypeExpression = Me.BindTypeOfExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GetXmlNamespaceExpression
								boundTypeExpression = Me.BindGetXmlNamespace(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.GetXmlNamespaceExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleMemberAccessExpression
								boundTypeExpression = Me.BindMemberAccess(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax), eventContext, diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DictionaryAccessExpression
								boundTypeExpression = Me.BindDictionaryAccess(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlElementAccessExpression
								boundTypeExpression = Me.BindXmlElementAccess(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlDescendantAccessExpression
								boundTypeExpression = Me.BindXmlDescendantAccess(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlAttributeAccessExpression
								boundTypeExpression = Me.BindXmlAttributeAccess(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InvocationExpression
								boundTypeExpression = Me.BindInvocationExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ObjectCreationExpression
								boundTypeExpression = Me.BindObjectCreationExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AnonymousObjectCreationExpression
								boundTypeExpression = Me.BindAnonymousObjectCreationExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ArrayCreationExpression
								boundTypeExpression = Me.BindArrayCreationExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CollectionInitializer
								boundTypeExpression = Me.BindArrayLiteralExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DirectCastExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TryCastExpression
								boundTypeExpression = Me.BindCastExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PredefinedCastExpression
								boundTypeExpression = Me.BindPredefinedCastExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SubtractExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MultiplyExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DivideExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IntegerDivideExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExponentiateExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LeftShiftExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RightShiftExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ConcatenateExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ModuloExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EqualsExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotEqualsExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LessThanExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LessThanOrEqualExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GreaterThanOrEqualExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GreaterThanExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LikeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OrExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExclusiveOrExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AndExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OrElseExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AndAlsoExpression
								boundTypeExpression = Me.BindBinaryOperator(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax), isOperandOfConditionalBranch, diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IsExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IsNotExpression
								boundTypeExpression = Me.BindIsExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UnaryPlusExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UnaryMinusExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotExpression
								boundTypeExpression = Me.BindUnaryOperator(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddressOfExpression
								boundTypeExpression = Me.BindAddressOfExpression(node, diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.BinaryConditionalExpression
								boundTypeExpression = Me.BindBinaryConditionalExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TernaryConditionalExpression
								boundTypeExpression = Me.BindTernaryConditionalExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineFunctionLambdaExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineSubLambdaExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MultiLineFunctionLambdaExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MultiLineSubLambdaExpression
								boundTypeExpression = Me.BindLambdaExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.QueryExpression
								boundTypeExpression = Me.BindQueryExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionAggregation
								boundTypeExpression = Me.BindFunctionAggregationExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GroupAggregation
								boundTypeExpression = Me.BindGroupAggregationExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupAggregationSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlDocument
								boundTypeExpression = Me.BindXmlDocument(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDocumentSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlElement
								boundTypeExpression = Me.BindXmlElement(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax), Nothing, diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlEmptyElement
								boundTypeExpression = Me.BindXmlEmptyElement(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax), Nothing, diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlComment
								boundTypeExpression = Me.BindXmlComment(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCommentSyntax), Nothing, diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlProcessingInstruction
								boundTypeExpression = Me.BindXmlProcessingInstruction(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlProcessingInstructionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlCDataSection
								boundTypeExpression = Me.BindXmlCData(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCDataSectionSyntax), Nothing, diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlEmbeddedExpression
								boundTypeExpression = Me.BindXmlEmbeddedExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NullableType
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PredefinedType
								boundTypeExpression = Me.BindNamespaceOrTypeExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IdentifierName
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GenericName
								boundTypeExpression = Me.BindSimpleName(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax), isInvocationOrAddressOf, diagnostics, False)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.QualifiedName
								boundTypeExpression = Me.BindQualifiedName(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax), diagnostics)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GlobalName
								boundTypeExpression = New BoundNamespaceExpression(node, Nothing, Me.Compilation.GlobalNamespace)
								Return boundTypeExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AwaitExpression
								boundTypeExpression = Me.BindAwait(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax), diagnostics, False)
								Return boundTypeExpression
							Case Else
								If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ConditionalAccessExpression) Then
									boundTypeExpression = Me.BindConditionalAccessExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax), diagnostics)
									Return boundTypeExpression
								Else
									Exit Select
								End If
						End Select
					End If
				ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NameOfExpression) Then
					boundTypeExpression = Me.BindNameOfExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.NameOfExpressionSyntax), diagnostics)
					Return boundTypeExpression
				ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InterpolatedStringExpression) Then
					boundTypeExpression = Me.BindInterpolatedStringExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringExpressionSyntax), diagnostics)
					Return boundTypeExpression
				Else
					If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TupleExpression) Then
						GoTo Label2
					End If
					boundTypeExpression = Me.BindTupleExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleExpressionSyntax), diagnostics)
					Return boundTypeExpression
				End If
			Label2:
				boundTypeExpression = Binder.BadExpression(node, ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty, ErrorTypeSymbol.UnknownResultType)
			Else
				boundTypeExpression = Binder.BadExpression(node, ErrorTypeSymbol.UnknownResultType)
			End If
			Return boundTypeExpression
		End Function

		Private Function BindExpressionStatement(ByVal statement As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim expression As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = statement.Expression
			Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = expression.Kind()
			If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InvocationExpression) Then
				If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AwaitExpression) Then
					boundExpression = Me.BindAwait(DirectCast(expression, Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax), diagnostics, True)
					Me.WarnOnUnobservedCallThatReturnsAnAwaitable(statement, boundExpression, diagnostics)
					Return New BoundExpressionStatement(statement, boundExpression, False)
				Else
					If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ConditionalAccessExpression) Then
						boundExpression = Me.BindInvocationExpressionAsStatement(expression, diagnostics)
						Me.WarnOnUnobservedCallThatReturnsAnAwaitable(statement, boundExpression, diagnostics)
						Return New BoundExpressionStatement(statement, boundExpression, False)
					End If
					boundExpression = Me.BindRValue(expression, diagnostics, False)
					Me.WarnOnUnobservedCallThatReturnsAnAwaitable(statement, boundExpression, diagnostics)
					Return New BoundExpressionStatement(statement, boundExpression, False)
				End If
			End If
			boundExpression = Me.BindInvocationExpressionAsStatement(expression, diagnostics)
			Me.WarnOnUnobservedCallThatReturnsAnAwaitable(statement, boundExpression, diagnostics)
			Return New BoundExpressionStatement(statement, boundExpression, False)
		End Function

		Friend Function BindFieldAndEnumConstantInitializer(ByVal fieldSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol, ByVal equalsValueOrAsNewSyntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal isEnum As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, <Out> ByRef constValue As ConstantValue) As BoundExpression
			Dim type As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim specialType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim flag As Boolean
			constValue = Nothing
			Dim boundBadExpression As BoundExpression = Nothing
			Dim instance As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.GetInstance(True, diagnostics.AccumulatesDependencies)
			If (equalsValueOrAsNewSyntax.Kind() <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EqualsValue) Then
				Dim asNewClauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax = DirectCast(equalsValueOrAsNewSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax)
				If (fieldSymbol.HasDeclaredType) Then
					specialType = fieldSymbol.Type
				Else
					specialType = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Object, asNewClauseSyntax, Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded)
				End If
				Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = specialType
				Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = asNewClauseSyntax.NewExpression.Kind()
				If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ObjectCreationExpression) Then
					Dim newExpression As Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax = DirectCast(asNewClauseSyntax.NewExpression, Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax)
					boundBadExpression = Me.BindObjectCreationExpression(asNewClauseSyntax.Type(), newExpression.ArgumentList, typeSymbol, newExpression, Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded, Nothing)
				Else
					If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AnonymousObjectCreationExpression) Then
						Throw ExceptionUtilities.UnexpectedValue(asNewClauseSyntax.NewExpression.Kind())
					End If
					boundBadExpression = Me.BindAnonymousObjectCreationExpression(DirectCast(asNewClauseSyntax.NewExpression, Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax), Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded)
				End If
				boundBadExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression(boundBadExpression.Syntax, LookupResultKind.Empty, ImmutableArray(Of Symbol).Empty, ImmutableArray.Create(Of BoundExpression)(boundBadExpression), typeSymbol, True)
			Else
				Dim equalsValueSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax = DirectCast(equalsValueOrAsNewSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax)
				boundBadExpression = Me.BindValue(equalsValueSyntax.Value, instance, False)
			End If
			If (Not boundBadExpression.HasErrors) Then
				If (Not fieldSymbol.HasDeclaredType) Then
					Dim unknownResultType As Object = boundBadExpression.Type
					If (unknownResultType Is Nothing) Then
						unknownResultType = ErrorTypeSymbol.UnknownResultType
					End If
					type = unknownResultType
				Else
					type = fieldSymbol.Type
					If (isEnum) Then
						type = type.GetEnumUnderlyingTypeOrSelf()
					End If
					boundBadExpression = Me.ApplyImplicitConversion(boundBadExpression.Syntax, type, boundBadExpression, instance, False)
				End If
				If (instance.HasAnyErrors()) Then
					flag = True
				Else
					flag = If(Not fieldSymbol.HasDeclaredType, False, Not type.IsValidTypeForConstField())
				End If
				If (Not flag) Then
					constValue = Me.GetExpressionConstantValueIfAny(boundBadExpression, instance, Binder.ConstantContext.[Default])
				Else
					constValue = Me.GetExpressionConstantValueIfAny(boundBadExpression, Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded, Binder.ConstantContext.[Default])
				End If
				If (constValue Is Nothing) Then
					boundBadExpression = Binder.BadExpression(boundBadExpression.Syntax, boundBadExpression, type)
				End If
			End If
			diagnostics.AddRange(instance, False)
			instance.Free()
			Return boundBadExpression
		End Function

		Friend Shared Function BindFieldAndPropertyInitializers(ByVal symbol As SourceMemberContainerTypeSymbol, ByVal initializers As ImmutableArray(Of ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer)), ByVal scriptInitializerOpt As SynthesizedInteractiveInitializerMethod, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As ImmutableArray(Of BoundInitializer)
			Dim immutableAndFree As ImmutableArray(Of BoundInitializer)
			Dim empty As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbol)
			If (Not initializers.IsDefaultOrEmpty) Then
				Dim containingModule As SourceModuleSymbol = DirectCast(symbol.ContainingModule, SourceModuleSymbol)
				Dim declaringCompilation As VisualBasicCompilation = containingModule.ContainingSourceAssembly.DeclaringCompilation
				Dim instance As ArrayBuilder(Of BoundInitializer) = ArrayBuilder(Of BoundInitializer).GetInstance()
				Dim length As Integer = initializers.Length - 1
				Dim num As Integer = 0
				Do
					Dim item As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer) = initializers(num)
					Dim topLevelCodeBinder As Microsoft.CodeAnalysis.VisualBasic.Binder = Nothing
					Dim length1 As Integer = item.Length - 1
					Dim num1 As Integer = 0
					Do
						Dim fieldOrPropertyInitializer As Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer = item(num1)
						If (fieldOrPropertyInitializer.FieldsOrProperties.IsDefault OrElse Not fieldOrPropertyInitializer.FieldsOrProperties.First().ContainingType.IsEnumType()) Then
							Dim syntax As SyntaxReference = fieldOrPropertyInitializer.Syntax
							Dim syntaxTree As Microsoft.CodeAnalysis.SyntaxTree = syntax.SyntaxTree
							Dim visualBasicSyntaxNode As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode = DirectCast(syntax.GetSyntax(New CancellationToken()), Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)
							If (topLevelCodeBinder Is Nothing) Then
								topLevelCodeBinder = BinderBuilder.CreateBinderForType(containingModule, syntaxTree, symbol)
								If (scriptInitializerOpt IsNot Nothing) Then
									topLevelCodeBinder = New Microsoft.CodeAnalysis.VisualBasic.TopLevelCodeBinder(scriptInitializerOpt, topLevelCodeBinder)
								End If
							End If
							If (Not fieldOrPropertyInitializer.FieldsOrProperties.IsDefault) Then
								Dim symbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbol = fieldOrPropertyInitializer.FieldsOrProperties.First()
								If (fieldOrPropertyInitializer.FieldsOrProperties.Length > 1) Then
									empty = fieldOrPropertyInitializer.FieldsOrProperties.RemoveAt(0)
								Else
									empty = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbol).Empty
								End If
								Dim binder As Microsoft.CodeAnalysis.VisualBasic.Binder = BinderBuilder.CreateBinderForInitializer(topLevelCodeBinder, symbol1, empty)
								If (visualBasicSyntaxNode.Kind() = SyntaxKind.ModifiedIdentifier) Then
									binder.BindArrayFieldImplicitInitializer(DirectCast(symbol1, Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFieldSymbol), instance, diagnostics)
								ElseIf (symbol1.Kind <> SymbolKind.Field) Then
									binder.BindPropertyInitializer(DirectCast(fieldOrPropertyInitializer.FieldsOrProperties, IEnumerable).Cast(Of PropertySymbol)().ToImmutableArray(), visualBasicSyntaxNode, instance, diagnostics)
								Else
									Dim sourceFieldSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFieldSymbol = DirectCast(symbol1, Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFieldSymbol)
									If (Not sourceFieldSymbol.IsConst) Then
										If (sourceFieldSymbol.Type.IsObjectType() AndAlso binder.OptionStrict <> Microsoft.CodeAnalysis.VisualBasic.OptionStrict.[On] AndAlso sourceFieldSymbol.Syntax IsNot Nothing AndAlso sourceFieldSymbol.Syntax.Kind() = SyntaxKind.ModifiedIdentifier) Then
											Dim modifiedIdentifierSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax = DirectCast(sourceFieldSymbol.Syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax)
											If (modifiedIdentifierSyntax.Nullable.Node IsNot Nothing AndAlso modifiedIdentifierSyntax.Parent IsNot Nothing AndAlso modifiedIdentifierSyntax.Parent.Kind() = SyntaxKind.VariableDeclarator AndAlso DirectCast(modifiedIdentifierSyntax.Parent, Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax).AsClause Is Nothing) Then
												Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagnostics, modifiedIdentifierSyntax, ERRID.ERR_NullableTypeInferenceNotSupported)
											End If
										End If
										binder.BindFieldInitializer(DirectCast(fieldOrPropertyInitializer.FieldsOrProperties, IEnumerable).Cast(Of FieldSymbol)().ToImmutableArray(), visualBasicSyntaxNode, instance, diagnostics, False)
									Else
										Microsoft.CodeAnalysis.VisualBasic.Binder.BindConstFieldInitializer(sourceFieldSymbol, visualBasicSyntaxNode, instance)
										If (sourceFieldSymbol.Type.SpecialType = SpecialType.System_DateTime) Then
											binder.ReportUseSiteInfoForSynthesizedAttribute(WellKnownMember.System_Runtime_CompilerServices_DateTimeConstantAttribute__ctor, visualBasicSyntaxNode, diagnostics)
										ElseIf (sourceFieldSymbol.Type.SpecialType = SpecialType.System_Decimal) Then
											binder.ReportUseSiteInfoForSynthesizedAttribute(WellKnownMember.System_Runtime_CompilerServices_DecimalConstantAttribute__ctor, visualBasicSyntaxNode, diagnostics)
										End If
									End If
								End If
							Else
								Dim flag As Boolean = If(num <> initializers.Length - 1, False, num1 = item.Length - 1)
								instance.Add(topLevelCodeBinder.BindGlobalStatement(scriptInitializerOpt, DirectCast(visualBasicSyntaxNode, Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax), diagnostics, flag))
							End If
						End If
						num1 = num1 + 1
					Loop While num1 <= length1
					num = num + 1
				Loop While num <= length
				immutableAndFree = instance.ToImmutableAndFree()
			Else
				immutableAndFree = ImmutableArray(Of BoundInitializer).Empty
			End If
			Return immutableAndFree
		End Function

		Friend Sub BindFieldInitializer(ByVal fieldSymbols As ImmutableArray(Of FieldSymbol), ByVal equalsValueOrAsNewSyntax As Microsoft.CodeAnalysis.SyntaxNode, ByVal boundInitializers As ArrayBuilder(Of BoundInitializer), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal bindingForSemanticModel As Boolean = False)
			Dim boundMeReference As Microsoft.CodeAnalysis.VisualBasic.BoundMeReference
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim sourceFieldSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFieldSymbol = DirectCast(fieldSymbols.First(), Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFieldSymbol)
			If (sourceFieldSymbol.IsShared) Then
				boundMeReference = Nothing
			Else
				boundMeReference = Me.CreateMeReference(sourceFieldSymbol.Syntax, True)
			End If
			Dim boundMeReference1 As Microsoft.CodeAnalysis.VisualBasic.BoundMeReference = boundMeReference
			Dim boundFieldAccess As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundFieldAccess(sourceFieldSymbol.Syntax, boundMeReference1, sourceFieldSymbol, True, sourceFieldSymbol.Type, False)
			boundFieldAccess.SetWasCompilerGenerated()
			Dim boundWithLValueExpressionPlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundWithLValueExpressionPlaceholder = Nothing
			If (equalsValueOrAsNewSyntax.Kind() = SyntaxKind.AsNewClause) Then
				boundWithLValueExpressionPlaceholder = New Microsoft.CodeAnalysis.VisualBasic.BoundWithLValueExpressionPlaceholder(equalsValueOrAsNewSyntax, sourceFieldSymbol.Type)
				boundWithLValueExpressionPlaceholder.SetWasCompilerGenerated()
			End If
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindFieldOrPropertyInitializerExpression(equalsValueOrAsNewSyntax, sourceFieldSymbol.Type, boundWithLValueExpressionPlaceholder, diagnostics)
			Dim flag As Boolean = False
			If (equalsValueOrAsNewSyntax.Parent IsNot Nothing AndAlso equalsValueOrAsNewSyntax.Kind() = SyntaxKind.AsNewClause) Then
				Dim enumerator As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax).Enumerator = DirectCast(equalsValueOrAsNewSyntax.Parent, Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax).Names.GetEnumerator()
				While enumerator.MoveNext()
					Dim current As Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax = enumerator.Current
					If (DirectCast(current.ArrayRankSpecifiers, IReadOnlyCollection(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax)).IsEmpty() AndAlso current.ArrayBounds Is Nothing) Then
						Continue While
					End If
					Binder.ReportDiagnostic(diagnostics, current, ERRID.ERR_AsNewArray)
					flag = True
				End While
			End If
			Dim boundInitializers1 As ArrayBuilder(Of BoundInitializer) = boundInitializers
			Dim syntaxNode As Microsoft.CodeAnalysis.SyntaxNode = equalsValueOrAsNewSyntax
			Dim fieldSymbols1 As ImmutableArray(Of FieldSymbol) = fieldSymbols
			If (fieldSymbols.Length = 1) Then
				boundExpression = boundFieldAccess
			Else
				boundExpression = Nothing
			End If
			boundInitializers1.Add(New BoundFieldInitializer(syntaxNode, fieldSymbols1, boundExpression, boundExpression1, flag))
		End Sub

		Private Function BindFieldOrPropertyInitializerExpression(ByVal equalsValueOrAsNewSyntax As SyntaxNode, ByVal targetType As TypeSymbol, ByVal asNewVariablePlaceholderOpt As BoundWithLValueExpressionPlaceholder, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim value As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			If (equalsValueOrAsNewSyntax.Kind() <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AsNewClause) Then
				value = DirectCast(equalsValueOrAsNewSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax).Value
				boundExpression = Me.BindValue(DirectCast(value, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax), diagnostics, False)
			Else
				Dim asNewClauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax = DirectCast(equalsValueOrAsNewSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax)
				Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = asNewClauseSyntax.NewExpression.Kind()
				If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ObjectCreationExpression) Then
					Binder.DisallowNewOnTupleType(asNewClauseSyntax.Type(), diagnostics)
					Dim newExpression As Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax = DirectCast(asNewClauseSyntax.NewExpression, Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax)
					boundExpression = Me.BindObjectCreationExpression(asNewClauseSyntax.NewExpression.Type(), newExpression.ArgumentList, targetType, newExpression, diagnostics, asNewVariablePlaceholderOpt)
				Else
					If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AnonymousObjectCreationExpression) Then
						Throw ExceptionUtilities.UnexpectedValue(asNewClauseSyntax.NewExpression.Kind())
					End If
					boundExpression = Me.BindAnonymousObjectCreationExpression(DirectCast(asNewClauseSyntax.NewExpression, Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax), diagnostics)
				End If
				value = asNewClauseSyntax
			End If
			boundExpression = If(targetType Is Nothing, Me.MakeRValueAndIgnoreDiagnostics(boundExpression), Me.ApplyImplicitConversion(boundExpression.Syntax, targetType, boundExpression, diagnostics, False))
			Return boundExpression
		End Function

		Private Function BindFilterQueryOperator(ByVal source As BoundQueryClauseBase, ByVal operatorSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax, ByVal operatorName As String, ByVal operatorNameLocation As TextSpan, ByVal condition As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundQueryClause
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundLambdaParameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol = Me.CreateQueryLambdaParameterSymbol(Binder.GetQueryLambdaParameterName(source.RangeVariables), 0, source.CompoundVariableType, condition, source.RangeVariables)
			Dim synthesizedLambdaSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaSymbol = Me.CreateQueryLambdaSymbol(condition, SynthesizedLambdaKind.FilterConditionQueryLambda, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol)(boundLambdaParameterSymbol))
			Dim queryLambdaBinder As Binder.QueryLambdaBinder = New Binder.QueryLambdaBinder(synthesizedLambdaSymbol, source.RangeVariables)
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = queryLambdaBinder.BindValue(condition, diagnostics, False)
			Dim instance As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.GetInstance(True, diagnostics.AccumulatesDependencies)
			Dim specialType As NamedTypeSymbol = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Boolean, condition, diagnostics)
			Dim type As TypeSymbol = boundExpression1.Type
			Dim flag As Boolean = False
			If (type Is Nothing) Then
				If (boundExpression1.IsNothingLiteral()) Then
					flag = True
				End If
			ElseIf (type.IsObjectType()) Then
				flag = True
			End If
			Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = queryLambdaBinder.ApplyImplicitConversion(condition, specialType, boundExpression1, instance, True)
			If (flag) Then
				boundExpression1 = boundExpression2
				diagnostics.AddRange(instance, False)
			ElseIf (Not boundExpression2.HasErrors OrElse Not instance.HasAnyErrors()) Then
				diagnostics.AddDependencies(instance, False)
			Else
				diagnostics.AddRange(instance, False)
				diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
			End If
			instance.Free()
			Dim boundQueryLambda As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Binder.CreateBoundQueryLambda(synthesizedLambdaSymbol, source.RangeVariables, boundExpression1, True)
			boundQueryLambda.SetWasCompilerGenerated()
			If (Not source.Type.IsErrorType()) Then
				If (diagnostics <> Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded AndAlso Binder.ShouldSuppressDiagnostics(boundQueryLambda)) Then
					diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
				End If
				boundExpression = Me.BindQueryOperatorCall(operatorSyntax, source, operatorName, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundQueryLambda), operatorNameLocation, diagnostics)
			Else
				boundExpression = Binder.BadExpression(operatorSyntax, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(source, boundQueryLambda), ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
			End If
			Return New BoundQueryClause(operatorSyntax, boundExpression, source.RangeVariables, source.CompoundVariableType, ImmutableArray.Create(Of Binder)(queryLambdaBinder), boundExpression.Type, False)
		End Function

		Private Function BindFinalImplicitSelectClause(ByVal source As BoundQueryClauseBase, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundQueryClause
			Dim parent As Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax = DirectCast(source.Syntax.Parent, Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax)
			Dim boundLambdaParameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol = Me.CreateQueryLambdaParameterSymbol(Binder.GetQueryLambdaParameterName(source.RangeVariables), 0, source.CompoundVariableType, parent, source.RangeVariables)
			LambdaUtilities.IsNonUserCodeQueryLambda(parent)
			Dim synthesizedLambdaSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaSymbol = Me.CreateQueryLambdaSymbol(parent, SynthesizedLambdaKind.FromNonUserCodeQueryLambda, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol)(boundLambdaParameterSymbol))
			synthesizedLambdaSymbol.SetQueryLambdaReturnType(source.CompoundVariableType)
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = (New BoundParameter(boundLambdaParameterSymbol.Syntax, boundLambdaParameterSymbol, False, boundLambdaParameterSymbol.Type)).MakeCompilerGenerated()
			Dim boundQueryLambda As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Binder.CreateBoundQueryLambda(synthesizedLambdaSymbol, ImmutableArray(Of RangeVariableSymbol).Empty, boundExpression, False)
			boundQueryLambda.SetWasCompilerGenerated()
			If (boundLambdaParameterSymbol.Type.IsErrorType()) Then
				diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
			End If
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindQueryOperatorCall(source.Syntax.Parent, source, "Select", ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundQueryLambda), source.Syntax.Span, diagnostics)
			Return (New BoundQueryClause(source.Syntax.Parent, boundExpression1, ImmutableArray(Of RangeVariableSymbol).Empty, source.CompoundVariableType, ImmutableArray(Of Binder).Empty, boundExpression1.Type, False)).MakeCompilerGenerated()
		End Function

		Private Function BindForBlockParts(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax, ByVal controlVariableSyntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, <Out> ByRef declaredOrInferredLocalOpt As LocalSymbol, <Out> ByRef controlVariable As BoundExpression, <Out> ByRef isInferredLocal As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
			Dim flag As Boolean = False
			declaredOrInferredLocalOpt = Nothing
			isInferredLocal = False
			If (controlVariableSyntax.Kind() <> SyntaxKind.VariableDeclarator) Then
				If (controlVariableSyntax.Kind() = SyntaxKind.IdentifierName) Then
					Dim identifier As Microsoft.CodeAnalysis.SyntaxToken = DirectCast(controlVariableSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax).Identifier
					Dim valueText As String = identifier.ValueText
					Dim instance As LookupResult = LookupResult.GetInstance()
					Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
					Me.Lookup(instance, valueText, 0, LookupOptions.AllMethodsOfAnyArity, newCompoundUseSiteInfo)
					diagnostics.Add(node, newCompoundUseSiteInfo)
					If (instance.IsGood AndAlso instance.Symbols(0).Kind = SymbolKind.Local) Then
						Dim item As LocalSymbol = DirectCast(instance.Symbols(0), LocalSymbol)
						If (item.IdentifierToken = identifier) Then
							isInferredLocal = True
							declaredOrInferredLocalOpt = item
						End If
					End If
					instance.Free()
				End If
				If (isInferredLocal) Then
					controlVariable = Nothing
				ElseIf (Not Me.TryBindLoopControlVariable(controlVariableSyntax, controlVariable, diagnostics)) Then
					flag = True
				End If
			Else
				Dim variableDeclaratorSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax = DirectCast(controlVariableSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax)
				flag = Not Binder.VerifyForControlVariableDeclaration(variableDeclaratorSyntax, diagnostics)
				Dim asClause As Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax = variableDeclaratorSyntax.AsClause
				Dim names As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax) = variableDeclaratorSyntax.Names
				Dim boundLocalDeclaration As Microsoft.CodeAnalysis.VisualBasic.BoundLocalDeclaration = Me.BindVariableDeclaration(variableDeclaratorSyntax, names(0), asClause, Nothing, diagnostics, False)
				declaredOrInferredLocalOpt = boundLocalDeclaration.LocalSymbol
				controlVariable = New BoundLocal(variableDeclaratorSyntax, declaredOrInferredLocalOpt, declaredOrInferredLocalOpt.Type)
			End If
			Return flag
		End Function

		Public Function BindForEachBlock(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim binder As Microsoft.CodeAnalysis.VisualBasic.Binder = Me.GetBinder(node)
			Dim localSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol = Nothing
			Dim flag As Boolean = False
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			binder.BindForBlockParts(node, DirectCast(node.ForOrForEachStatement, Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax).ControlVariable, localSymbol, boundExpression, flag, diagnostics)
			Return binder.BindForEachBlockParts(node, localSymbol, boundExpression, flag, diagnostics)
		End Function

		Private Function BindForEachBlockParts(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax, ByVal declaredOrInferredLocalOpt As LocalSymbol, ByVal controlVariableOpt As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal isInferredLocal As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundForEachStatement
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim forOrForEachStatement As Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax = DirectCast(node.ForOrForEachStatement, Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax)
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
			Dim typeSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
			Dim flag As Boolean = False
			Dim flag1 As Boolean = False
			Dim flag2 As Boolean = False
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim boundLValuePlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundLValuePlaceholder = Nothing
			Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim boundExpression3 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim boundRValuePlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder = Nothing
			Dim boundExpression4 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim boundTryCast As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim boundExpression5 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim boundRValuePlaceholder1 As Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder = Nothing
			Dim boundExpression6 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			If (isInferredLocal) Then
				Dim typeSymbol2 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Me.InferForEachVariableType(declaredOrInferredLocalOpt, forOrForEachStatement.Expression, boundExpression6, typeSymbol, typeSymbol1, flag, boundExpression1, boundLValuePlaceholder, boundExpression2, boundExpression3, boundRValuePlaceholder, flag1, flag2, diagnostics)
				Dim identifierToken As Microsoft.CodeAnalysis.SyntaxToken = declaredOrInferredLocalOpt.IdentifierToken
				Me.VerifyLocalSymbolNameAndSetType(declaredOrInferredLocalOpt, typeSymbol2, DirectCast(identifierToken.Parent, Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode), identifierToken, diagnostics)
				controlVariableOpt = New BoundLocal(forOrForEachStatement.ControlVariable, declaredOrInferredLocalOpt, typeSymbol2)
			End If
			If (boundExpression6 Is Nothing) Then
				boundExpression6 = Me.BindValue(forOrForEachStatement.Expression, diagnostics, False)
				If (Not boundExpression6.IsLValue AndAlso Not boundExpression6.IsNothingLiteral()) Then
					boundExpression6 = Me.MakeRValue(boundExpression6, diagnostics)
				End If
				boundExpression6 = Me.InterpretForEachStatementCollection(boundExpression6, typeSymbol, typeSymbol1, flag, boundExpression1, boundLValuePlaceholder, boundExpression2, boundExpression3, boundRValuePlaceholder, flag1, flag2, diagnostics)
			End If
			Dim syntax As SyntaxNode = boundExpression6.Syntax
			If (typeSymbol IsNot Nothing AndAlso Not controlVariableOpt.HasErrors) Then
				Dim type As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = controlVariableOpt.Type
				If (Not type.IsErrorType() AndAlso Not typeSymbol.IsErrorType() AndAlso Not typeSymbol1.IsErrorType()) Then
					Dim discarded As CompoundUseSiteInfo(Of AssemblySymbol) = CompoundUseSiteInfo(Of AssemblySymbol).Discarded
					If (Not Microsoft.CodeAnalysis.VisualBasic.Conversions.IsIdentityConversion(Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyConversion(typeSymbol1, typeSymbol, discarded).Key)) Then
						boundRValuePlaceholder1 = New Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder(syntax, typeSymbol)
						boundExpression = Me.ApplyConversion(syntax, typeSymbol1, boundRValuePlaceholder1, True, diagnostics, False, False)
						boundExpression.SetWasCompilerGenerated()
					Else
						boundRValuePlaceholder1 = New Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder(syntax, typeSymbol1)
						boundExpression = boundRValuePlaceholder1
					End If
					If (boundExpression <> boundRValuePlaceholder1) Then
						discarded = CompoundUseSiteInfo(Of AssemblySymbol).Discarded
						If (Not Microsoft.CodeAnalysis.VisualBasic.Conversions.IsIdentityConversion(Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyConversion(type, typeSymbol1, discarded).Key)) Then
							GoTo Label1
						End If
						boundExpression5 = boundExpression
						GoTo Label0
					End If
				Label1:
					boundExpression5 = Me.ApplyConversion(syntax, type, boundExpression, True, diagnostics, False, False)
					boundExpression5.SetWasCompilerGenerated()
				End If
			End If
		Label0:
			If (flag1) Then
				Dim specialType As NamedTypeSymbol = Me.Compilation.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_IDisposable)
				Dim type1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = boundExpression1.Type
				If (Not flag2) Then
					Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
					Dim conversionKind As Microsoft.CodeAnalysis.VisualBasic.ConversionKind = Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyTryCastConversion(type1, specialType, newCompoundUseSiteInfo)
					If (diagnostics.Add(syntax, newCompoundUseSiteInfo)) Then
						diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
					End If
					boundTryCast = New Microsoft.CodeAnalysis.VisualBasic.BoundTryCast(syntax, boundLValuePlaceholder.MakeRValue(), conversionKind, specialType, False)
					boundExpression4 = Me.BindIsExpression(boundTryCast, New BoundLiteral(syntax, ConstantValue.[Nothing], Nothing), syntax, True, diagnostics)
				ElseIf (Not type1.IsValueType) Then
					boundExpression4 = Me.BindIsExpression(boundLValuePlaceholder, New BoundLiteral(syntax, ConstantValue.[Nothing], Nothing), syntax, True, diagnostics)
					boundTryCast = Me.ApplyConversion(syntax, specialType, boundLValuePlaceholder, True, diagnostics, False, False)
				End If
			End If
			Dim boundBlock As Microsoft.CodeAnalysis.VisualBasic.BoundBlock = Nothing
			Dim boundExpressions As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = New ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)()
			Me.BindForLoopBodyAndNextControlVariables(node, boundExpressions, boundBlock, diagnostics)
			Dim forEachEnumeratorInfo As Microsoft.CodeAnalysis.VisualBasic.ForEachEnumeratorInfo = New Microsoft.CodeAnalysis.VisualBasic.ForEachEnumeratorInfo(boundExpression1, boundExpression2, boundExpression3, typeSymbol1, flag1, flag2, boundExpression4, boundTryCast, boundExpression5, boundLValuePlaceholder, boundRValuePlaceholder1, boundRValuePlaceholder)
			Return New BoundForEachStatement(node, boundExpression6, forEachEnumeratorInfo, declaredOrInferredLocalOpt, controlVariableOpt, boundBlock, boundExpressions, Me.GetContinueLabel(SyntaxKind.ContinueForStatement), Me.GetExitLabel(SyntaxKind.ExitForStatement), False)
		End Function

		Private Sub BindForLoopBodyAndNextControlVariables(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax, <Out> ByRef nextVariables As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression), <Out> ByRef loopBody As BoundBlock, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			loopBody = Me.BindBlock(node, node.Statements, diagnostics).MakeCompilerGenerated()
			nextVariables = New ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)()
			Dim nextStatement As Microsoft.CodeAnalysis.VisualBasic.Syntax.NextStatementSyntax = node.NextStatement
			If (nextStatement IsNot Nothing) Then
				Dim controlVariables As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax) = nextStatement.ControlVariables
				If (DirectCast(controlVariables, IReadOnlyCollection(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)).IsEmpty()) Then
					nextVariables = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty
					Return
				End If
				If (controlVariables.Count = 1) Then
					Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindExpression(controlVariables(0), diagnostics)
					boundExpression = Me.ReclassifyAsValue(boundExpression, diagnostics)
					nextVariables = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpression)
					Return
				End If
				Dim count As Integer = controlVariables.Count
				Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance()
				Dim containingBinder As Binder = Me
				Dim num As Integer = count - 1
				Dim num1 As Integer = 0
				Do
					Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = containingBinder.BindExpression(controlVariables(num1), diagnostics)
					instance.Add(Me.ReclassifyAsValue(boundExpression1, diagnostics))
					Do
						containingBinder = containingBinder.ContainingBinder
					Loop While containingBinder IsNot Nothing AndAlso Not TypeOf containingBinder Is StatementListBinder
					If (containingBinder IsNot Nothing) Then
						containingBinder = containingBinder.ContainingBinder
					End If
					If (Not TypeOf containingBinder Is ForOrForEachBlockBinder) Then
						Exit Do
					End If
					num1 = num1 + 1
				Loop While num1 <= num
				nextVariables = instance.ToImmutableAndFree()
			End If
		End Sub

		Private Function BindForLoopUserDefinedOperator(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal opCode As BinaryOperatorKind, ByVal left As BoundExpression, ByVal right As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedBinaryOperator
			Dim boundUserDefinedBinaryOperator As Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedBinaryOperator
			Dim flag As Boolean = If(opCode = BinaryOperatorKind.LessThanOrEqual, True, opCode = BinaryOperatorKind.GreaterThanOrEqual)
			Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
			Dim overloadResolutionResult As OverloadResolution.OverloadResolutionResult = OverloadResolution.ResolveUserDefinedBinaryOperator(left, right, opCode, Me, newCompoundUseSiteInfo, False)
			If (diagnostics.Add(syntax, newCompoundUseSiteInfo)) Then
				diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
			End If
			If (overloadResolutionResult.ResolutionIsLateBound OrElse Not overloadResolutionResult.BestResult.HasValue) Then
				Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_ForLoopOperatorRequired2, New [Object]() { left.Type, SyntaxFacts.GetText(OverloadResolution.GetOperatorTokenKind(opCode)) })
				boundUserDefinedBinaryOperator = Nothing
			Else
				Dim candidate As OverloadResolution.Candidate = overloadResolutionResult.BestResult.Value.Candidate
				If (Not candidate.Parameters(0).Type.IsSameTypeIgnoringAll(left.Type) OrElse Not candidate.Parameters(1).Type.IsSameTypeIgnoringAll(left.Type) OrElse Not flag AndAlso Not candidate.ReturnType.IsSameTypeIgnoringAll(left.Type)) Then
					If (Not flag) Then
						Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
						Dim syntaxNodeOrToken As Microsoft.CodeAnalysis.SyntaxNodeOrToken = syntax
						Dim underlyingSymbol() As [Object] = { candidate.UnderlyingSymbol, Nothing }
						underlyingSymbol(1) = If(candidate.IsLifted, left.Type.GetNullableUnderlyingTypeOrSelf(), left.Type)
						Binder.ReportDiagnostic(bindingDiagnosticBag, syntaxNodeOrToken, ERRID.ERR_UnacceptableForLoopOperator2, underlyingSymbol)
					Else
						Dim bindingDiagnosticBag1 As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
						Dim syntaxNodeOrToken1 As Microsoft.CodeAnalysis.SyntaxNodeOrToken = syntax
						Dim objArray() As [Object] = { candidate.UnderlyingSymbol, Nothing }
						objArray(1) = If(candidate.IsLifted, left.Type.GetNullableUnderlyingTypeOrSelf(), left.Type)
						Binder.ReportDiagnostic(bindingDiagnosticBag1, syntaxNodeOrToken1, ERRID.ERR_UnacceptableForLoopRelOperator2, objArray)
					End If
					boundUserDefinedBinaryOperator = Nothing
				Else
					Dim boundUserDefinedBinaryOperator1 As Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedBinaryOperator = Me.BindUserDefinedNonShortCircuitingBinaryOperator(syntax, opCode, left, right, overloadResolutionResult, diagnostics).MakeCompilerGenerated()
					boundUserDefinedBinaryOperator1.UnderlyingExpression.MakeCompilerGenerated()
					boundUserDefinedBinaryOperator = boundUserDefinedBinaryOperator1
				End If
			End If
			Return boundUserDefinedBinaryOperator
		End Function

		Public Function BindForToBlock(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim binder As Microsoft.CodeAnalysis.VisualBasic.Binder = Me.GetBinder(node)
			Dim localSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol = Nothing
			Dim flag As Boolean = False
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim flag1 As Boolean = False
			flag1 = binder.BindForBlockParts(node, node.ForOrForEachStatement.ControlVariable, localSymbol, boundExpression, flag, diagnostics)
			Return binder.BindForToBlockParts(node, localSymbol, boundExpression, flag, flag1, diagnostics)
		End Function

		Private Function BindForToBlockParts(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax, ByVal declaredOrInferredLocalOpt As LocalSymbol, ByVal controlVariableOpt As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal isInferredLocal As Boolean, ByVal hasErrors As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundForStatement
			Dim forOrForEachStatement As Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax = DirectCast(node.ForOrForEachStatement, Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax)
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim boundLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			If (isInferredLocal) Then
				Dim variableType As TypeSymbol = Me.InferForFromToVariableType(declaredOrInferredLocalOpt, forOrForEachStatement.FromValue, forOrForEachStatement.ToValue, forOrForEachStatement.StepClause, boundExpression, boundExpression1, boundLiteral, diagnostics)
				Dim identifierToken As Microsoft.CodeAnalysis.SyntaxToken = declaredOrInferredLocalOpt.IdentifierToken
				Me.VerifyLocalSymbolNameAndSetType(declaredOrInferredLocalOpt, variableType, DirectCast(identifierToken.Parent, Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode), identifierToken, diagnostics)
				controlVariableOpt = New BoundLocal(forOrForEachStatement.ControlVariable, declaredOrInferredLocalOpt, variableType)
			End If
			Dim type As TypeSymbol = controlVariableOpt.Type
			Dim flag As Boolean = False
			If (type IsNot Nothing AndAlso Not type.IsErrorType()) Then
				flag = Me.IsValidForControlVariableType(node, type.GetEnumUnderlyingTypeOrSelf(), diagnostics)
				hasErrors = Not flag Or hasErrors
			End If
			If (boundExpression Is Nothing) Then
				boundExpression = Me.BindValue(forOrForEachStatement.FromValue, diagnostics, False)
			End If
			If (boundExpression1 Is Nothing) Then
				boundExpression1 = Me.BindValue(forOrForEachStatement.ToValue, diagnostics, False)
			End If
			If (boundLiteral Is Nothing) Then
				Dim stepClause As Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax = forOrForEachStatement.StepClause
				If (stepClause Is Nothing) Then
					boundLiteral = New Microsoft.CodeAnalysis.VisualBasic.BoundLiteral(node, ConstantValue.Create(1), Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Int32, forOrForEachStatement, diagnostics))
					boundLiteral.SetWasCompilerGenerated()
				Else
					boundLiteral = Me.BindValue(stepClause.StepValue, diagnostics, False)
				End If
			End If
			If (Not flag) Then
				boundExpression = Me.MakeRValueAndIgnoreDiagnostics(boundExpression)
				boundExpression1 = Me.MakeRValueAndIgnoreDiagnostics(boundExpression1)
				boundLiteral = Me.MakeRValueAndIgnoreDiagnostics(boundLiteral)
			Else
				boundExpression = Me.ApplyImplicitConversion(boundExpression.Syntax, type, boundExpression, diagnostics, False)
				boundExpression1 = Me.ApplyImplicitConversion(boundExpression1.Syntax, type, boundExpression1, diagnostics, False)
				Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = boundLiteral
				boundLiteral = Me.ApplyConversion(boundLiteral.Syntax, type, boundLiteral, forOrForEachStatement.StepClause Is Nothing, diagnostics, False, False)
				If (boundLiteral <> boundExpression2 AndAlso boundLiteral.Kind = BoundKind.Conversion AndAlso forOrForEachStatement.StepClause Is Nothing) Then
					boundLiteral.MakeCompilerGenerated()
				End If
			End If
			Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Int32, node, diagnostics)
			Dim specialType As NamedTypeSymbol = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Boolean, node, diagnostics)
			Dim boundForToUserDefinedOperator As BoundForToUserDefinedOperators = Nothing
			Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
			If (Not hasErrors AndAlso Not boundExpression.HasErrors AndAlso Not boundExpression1.HasErrors AndAlso Not boundLiteral.HasErrors AndAlso type.CanContainUserDefinedOperators(newCompoundUseSiteInfo)) Then
				Dim visualBasicSyntaxNode As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode = node.ForOrForEachStatement
				Dim boundRValuePlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder = (New Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder(visualBasicSyntaxNode, type)).MakeCompilerGenerated()
				Dim boundRValuePlaceholder1 As Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder = (New Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder(visualBasicSyntaxNode, type)).MakeCompilerGenerated()
				Dim boundUserDefinedBinaryOperator As Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedBinaryOperator = Me.BindForLoopUserDefinedOperator(visualBasicSyntaxNode, BinaryOperatorKind.Add, boundRValuePlaceholder, boundRValuePlaceholder1, diagnostics)
				Dim boundUserDefinedBinaryOperator1 As Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedBinaryOperator = Me.BindForLoopUserDefinedOperator(visualBasicSyntaxNode, BinaryOperatorKind.Subtract, boundRValuePlaceholder, boundRValuePlaceholder1, diagnostics)
				Dim boundExpression3 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindForLoopUserDefinedOperator(visualBasicSyntaxNode, BinaryOperatorKind.LessThanOrEqual, boundRValuePlaceholder, boundRValuePlaceholder1, diagnostics)
				If (boundExpression3 IsNot Nothing) Then
					boundExpression3 = Me.ApplyImplicitConversion(visualBasicSyntaxNode, specialType, boundExpression3, diagnostics, True).MakeCompilerGenerated()
				End If
				Dim boundExpression4 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindForLoopUserDefinedOperator(visualBasicSyntaxNode, BinaryOperatorKind.GreaterThanOrEqual, boundRValuePlaceholder, boundRValuePlaceholder1, diagnostics)
				If (boundExpression4 IsNot Nothing) Then
					boundExpression4 = Me.ApplyImplicitConversion(visualBasicSyntaxNode, specialType, boundExpression4, If(boundExpression3 Is Nothing OrElse Not boundExpression3.HasErrors, diagnostics, Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded), True).MakeCompilerGenerated()
				End If
				If (boundUserDefinedBinaryOperator Is Nothing OrElse boundUserDefinedBinaryOperator1 Is Nothing OrElse boundExpression3 Is Nothing OrElse boundExpression4 Is Nothing) Then
					hasErrors = True
				Else
					boundForToUserDefinedOperator = New BoundForToUserDefinedOperators(visualBasicSyntaxNode, boundRValuePlaceholder, boundRValuePlaceholder1, boundUserDefinedBinaryOperator, boundUserDefinedBinaryOperator1, boundExpression3, boundExpression4, False)
				End If
			End If
			diagnostics.Add(node, newCompoundUseSiteInfo)
			hasErrors = If(hasErrors OrElse type.IsErrorType() OrElse boundExpression.HasErrors OrElse boundLiteral.HasErrors, True, controlVariableOpt.HasErrors)
			Dim boundBlock As Microsoft.CodeAnalysis.VisualBasic.BoundBlock = Nothing
			Dim boundExpressions As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = New ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)()
			Me.BindForLoopBodyAndNextControlVariables(node, boundExpressions, boundBlock, diagnostics)
			Return New BoundForToStatement(node, boundExpression, boundExpression1, boundLiteral, Me.CheckOverflow, boundForToUserDefinedOperator, declaredOrInferredLocalOpt, controlVariableOpt, boundBlock, boundExpressions, Me.GetContinueLabel(SyntaxKind.ContinueForStatement), Me.GetExitLabel(SyntaxKind.ExitForStatement), hasErrors)
		End Function

		Private Function BindFromClause(ByVal sourceOpt As BoundQueryClauseBase, ByVal from As Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax, ByRef operatorsEnumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundQueryClauseBase
			Return Me.BindCollectionRangeVariables(from, sourceOpt, from.Variables, operatorsEnumerator, diagnostics)
		End Function

		Private Function BindFromQueryExpression(ByVal query As Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax, ByVal operators As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundQueryExpression
			Dim boundQueryClauseBase As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase = Me.BindFromClause(Nothing, DirectCast(operators.Current, Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax), operators, diagnostics)
			boundQueryClauseBase = Me.BindSubsequentQueryOperators(boundQueryClauseBase, operators, diagnostics)
			If (Not boundQueryClauseBase.Type.IsErrorType() AndAlso boundQueryClauseBase.Kind = BoundKind.QueryableSource AndAlso DirectCast(boundQueryClauseBase, BoundQueryableSource).Source.Kind = BoundKind.QuerySource) Then
				boundQueryClauseBase = Me.BindFinalImplicitSelectClause(boundQueryClauseBase, diagnostics)
			End If
			Return New BoundQueryExpression(query, boundQueryClauseBase, boundQueryClauseBase.Type, False)
		End Function

		Friend Overridable Function BindFunctionAggregationExpression(ByVal [function] As Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Return Binder.BadExpression([function], ErrorTypeSymbol.UnknownResultType)
		End Function

		Private Function BindGetTypeExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.GetTypeExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim target As Object
			Dim getTypeBinder As Microsoft.CodeAnalysis.VisualBasic.GetTypeBinder = New Microsoft.CodeAnalysis.VisualBasic.GetTypeBinder(node.Type, Me)
			Dim symbol As Microsoft.CodeAnalysis.VisualBasic.Symbol = Binder.TypeBinder.BindTypeOrAliasSyntax(node.Type, getTypeBinder, diagnostics, False, True, False)
			Dim aliasSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol = TryCast(symbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol)
			If (aliasSymbol IsNot Nothing) Then
				target = aliasSymbol.Target
			Else
				target = symbol
			End If
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = DirectCast(target, Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)
			Dim boundTypeExpression As Microsoft.CodeAnalysis.VisualBasic.BoundTypeExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundTypeExpression(node.Type, Nothing, aliasSymbol, typeSymbol, typeSymbol.IsErrorType())
			If (typeSymbol.IsArrayType() AndAlso DirectCast(typeSymbol, ArrayTypeSymbol).ElementType.SpecialType = SpecialType.System_Void) Then
				Binder.ReportDiagnostic(diagnostics, node.Type, ErrorFactory.ErrorInfo(ERRID.ERR_VoidArrayDisallowed))
			End If
			Return New BoundGetType(node, boundTypeExpression, Me.GetWellKnownType(WellKnownType.System_Type, node, diagnostics), False)
		End Function

		Private Function BindGetXmlNamespace(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.GetXmlNamespaceExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			diagnostics = Me.CheckXmlFeaturesAllowed(syntax, diagnostics)
			Dim name As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixNameSyntax = syntax.Name
			Dim str As String = Nothing
			Dim flag As Boolean = False
			If (name Is Nothing) Then
				Me.LookupXmlNamespace("", False, str, flag)
				boundExpression = Me.CreateStringLiteral(syntax, str, True, diagnostics, False)
			Else
				Dim syntaxToken As Microsoft.CodeAnalysis.SyntaxToken = name.Name
				Dim xmlName As String = Binder.GetXmlName(syntaxToken)
				If (Not Me.LookupXmlNamespace(xmlName, False, str, flag)) Then
					boundExpression = Me.ReportXmlNamespacePrefixNotDefined(name, syntaxToken, xmlName, False, diagnostics)
				Else
					boundExpression = Me.CreateStringLiteral(name, str, False, diagnostics, False)
				End If
			End If
			Return Me.BindXmlNamespace(syntax, boundExpression, diagnostics)
		End Function

		Private Function BindGlobalStatement(ByVal scriptInitializerOpt As SynthesizedInteractiveInitializerMethod, ByVal statementNode As Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal isLast As Boolean) As BoundInitializer
			Dim boundExpressionStatement As BoundStatement = Me.BindStatement(statementNode, diagnostics)
			If (Me.Compilation.IsSubmission AndAlso isLast AndAlso boundExpressionStatement.Kind = BoundKind.ExpressionStatement AndAlso Not boundExpressionStatement.HasErrors) Then
				Dim expression As BoundExpression = DirectCast(boundExpressionStatement, Microsoft.CodeAnalysis.VisualBasic.BoundExpressionStatement).Expression
				If (expression.Type Is Nothing OrElse expression.Type.SpecialType <> SpecialType.System_Void) Then
					Dim resultType As TypeSymbol = scriptInitializerOpt.ResultType
					expression = Me.ApplyImplicitConversion(expression.Syntax, resultType, expression, diagnostics, False)
					boundExpressionStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundExpressionStatement(boundExpressionStatement.Syntax, expression, expression.HasErrors)
				End If
			End If
			Return New BoundGlobalStatementInitializer(statementNode, boundExpressionStatement, False)
		End Function

		Private Function BindGoToStatement(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.GoToStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim boundBadStatement As BoundStatement
			Dim label As LabelSymbol = Nothing
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindExpression(node.Label, diagnostics)
			If (boundExpression.Kind <> BoundKind.Label) Then
				boundBadStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement(node, ImmutableArray.Create(Of BoundNode)(boundExpression), True)
			Else
				Dim boundLabel As Microsoft.CodeAnalysis.VisualBasic.BoundLabel = DirectCast(boundExpression, Microsoft.CodeAnalysis.VisualBasic.BoundLabel)
				label = boundLabel.Label
				boundBadStatement = New BoundGotoStatement(node, label, boundLabel, If(boundLabel.HasErrors, True, Not Me.IsValidLabelForGoto(label, node.Label, diagnostics)))
			End If
			Return boundBadStatement
		End Function

		Friend Overridable Function BindGroupAggregationExpression(ByVal group As Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupAggregationSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Return Binder.BadExpression(group, ErrorTypeSymbol.UnknownResultType)
		End Function

		Private Function BindGroupByClause(ByVal source As BoundQueryClauseBase, ByVal groupBy As Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundQueryClause
			Dim rangeVariables As ImmutableArray(Of RangeVariableSymbol)
			Dim type As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim boundExpressionArray As Microsoft.CodeAnalysis.VisualBasic.BoundExpression()
			Dim binders As ImmutableArray(Of Binder)
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim queryLambdaBinder As Binder.QueryLambdaBinder = Nothing
			Dim rangeVariableSymbols As ImmutableArray(Of RangeVariableSymbol) = New ImmutableArray(Of RangeVariableSymbol)()
			Dim boundQueryLambda As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Me.BindGroupByItems(source, groupBy, queryLambdaBinder, rangeVariableSymbols, diagnostics)
			Dim queryLambdaBinder1 As Binder.QueryLambdaBinder = Nothing
			Dim rangeVariableSymbols1 As ImmutableArray(Of RangeVariableSymbol) = New ImmutableArray(Of RangeVariableSymbol)()
			Dim boundQueryLambda1 As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Me.BindGroupByKeys(source, groupBy, queryLambdaBinder1, rangeVariableSymbols1, diagnostics)
			Dim boundMethodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup = Nothing
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Me.InferGroupType(source, groupBy, boundQueryLambda, boundQueryLambda1, rangeVariableSymbols1, boundMethodGroup, diagnostics)
			If (boundQueryLambda IsNot Nothing) Then
				rangeVariables = rangeVariableSymbols
				type = boundQueryLambda.Expression.Type
			Else
				rangeVariables = source.RangeVariables
				type = source.CompoundVariableType
			End If
			Dim intoClauseBinder As Binder.IntoClauseBinder = Nothing
			Dim rangeVariableSymbols2 As ImmutableArray(Of RangeVariableSymbol) = New ImmutableArray(Of RangeVariableSymbol)()
			Dim boundQueryLambda2 As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Me.BindIntoSelectorLambda(groupBy, rangeVariableSymbols1, boundQueryLambda1.Expression.Type, False, Nothing, typeSymbol, rangeVariables, type, groupBy.AggregationVariables, True, diagnostics, intoClauseBinder, rangeVariableSymbols2)
			If (boundQueryLambda IsNot Nothing) Then
				boundExpressionArray = New Microsoft.CodeAnalysis.VisualBasic.BoundExpression() { boundQueryLambda1, boundQueryLambda, boundQueryLambda2 }
				binders = ImmutableArray.Create(Of Binder)(queryLambdaBinder1, queryLambdaBinder, intoClauseBinder)
			Else
				boundExpressionArray = New Microsoft.CodeAnalysis.VisualBasic.BoundExpression() { boundQueryLambda1, boundQueryLambda2 }
				binders = ImmutableArray.Create(Of Binder)(queryLambdaBinder1, intoClauseBinder)
			End If
			If (source.Type.IsErrorType() OrElse boundMethodGroup Is Nothing) Then
				Dim boundExpressions As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(source)
				boundExpression = Binder.BadExpression(groupBy, boundExpressions.AddRange(boundExpressionArray), ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
			Else
				Dim discarded As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
				If (Binder.ShouldSuppressDiagnostics(boundQueryLambda1) OrElse Binder.ShouldSuppressDiagnostics(boundQueryLambda2) OrElse boundQueryLambda IsNot Nothing AndAlso Binder.ShouldSuppressDiagnostics(boundQueryLambda)) Then
					discarded = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
				End If
				boundExpression = Me.BindQueryOperatorCall(groupBy, source, "GroupBy", boundMethodGroup, Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpressionArray), Binder.GetGroupByOperatorNameSpan(groupBy), discarded)
			End If
			Return New BoundQueryClause(groupBy, boundExpression, Microsoft.CodeAnalysis.ImmutableArrayExtensions.Concat(Of RangeVariableSymbol)(rangeVariableSymbols1, rangeVariableSymbols2), boundQueryLambda2.Expression.Type, binders, boundExpression.Type, False)
		End Function

		Private Function BindGroupByItems(ByVal source As BoundQueryClauseBase, ByVal groupBy As Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax, <Out> ByRef itemsLambdaBinder As Binder.QueryLambdaBinder, <Out> ByRef itemsRangeVariables As ImmutableArray(Of RangeVariableSymbol), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda
			Dim boundQueryLambda As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Nothing
			Dim items As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax) = groupBy.Items
			If (items.Count <= 0) Then
				itemsLambdaBinder = Nothing
				itemsRangeVariables = ImmutableArray(Of RangeVariableSymbol).Empty
			Else
				Dim boundLambdaParameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol = Me.CreateQueryLambdaParameterSymbol(Binder.GetQueryLambdaParameterName(source.RangeVariables), 0, source.CompoundVariableType, groupBy, source.RangeVariables)
				Dim synthesizedLambdaSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaSymbol = Me.CreateQueryLambdaSymbol(LambdaUtilities.GetGroupByItemsLambdaBody(groupBy), SynthesizedLambdaKind.GroupByItemsQueryLambda, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol)(boundLambdaParameterSymbol))
				itemsLambdaBinder = New Binder.QueryLambdaBinder(synthesizedLambdaSymbol, source.RangeVariables)
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = itemsLambdaBinder.BindExpressionRangeVariables(items, False, groupBy, itemsRangeVariables, diagnostics)
				boundQueryLambda = Binder.CreateBoundQueryLambda(synthesizedLambdaSymbol, source.RangeVariables, boundExpression, False)
				synthesizedLambdaSymbol.SetQueryLambdaReturnType(boundExpression.Type)
				boundQueryLambda.SetWasCompilerGenerated()
			End If
			Return boundQueryLambda
		End Function

		Private Function BindGroupByKeys(ByVal source As BoundQueryClauseBase, ByVal groupBy As Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax, <Out> ByRef keysLambdaBinder As Binder.QueryLambdaBinder, <Out> ByRef keysRangeVariables As ImmutableArray(Of RangeVariableSymbol), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda
			Dim keys As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax) = groupBy.Keys
			Dim boundLambdaParameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol = Me.CreateQueryLambdaParameterSymbol(Binder.GetQueryLambdaParameterName(source.RangeVariables), 0, source.CompoundVariableType, groupBy, source.RangeVariables)
			Dim synthesizedLambdaSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaSymbol = Me.CreateQueryLambdaSymbol(LambdaUtilities.GetGroupByKeysLambdaBody(groupBy), SynthesizedLambdaKind.GroupByKeysQueryLambda, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol)(boundLambdaParameterSymbol))
			keysLambdaBinder = New Binder.QueryLambdaBinder(synthesizedLambdaSymbol, source.RangeVariables)
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = keysLambdaBinder.BindExpressionRangeVariables(keys, True, groupBy, keysRangeVariables, diagnostics)
			Dim boundQueryLambda As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Binder.CreateBoundQueryLambda(synthesizedLambdaSymbol, source.RangeVariables, boundExpression, False)
			synthesizedLambdaSymbol.SetQueryLambdaReturnType(boundExpression.Type)
			boundQueryLambda.SetWasCompilerGenerated()
			Return boundQueryLambda
		End Function

		Private Function BindGroupJoinClause(ByVal outer As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase, ByVal groupJoin As Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax, ByVal declaredNames As HashSet(Of String), ByVal operatorsEnumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundQueryClause
			Dim boundQueryClauseBase As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim enumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator
			Dim strs As HashSet(Of String) = Binder.CreateSetOfDeclaredNames(outer.RangeVariables)
			If (declaredNames Is Nothing) Then
				declaredNames = Binder.CreateSetOfDeclaredNames(outer.RangeVariables)
			End If
			If (groupJoin.JoinedVariables.Count <> 0) Then
				Dim joinedVariables As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax) = groupJoin.JoinedVariables
				boundQueryClauseBase = Me.BindCollectionRangeVariable(joinedVariables(0), False, strs, diagnostics)
			Else
				Dim rangeVariableSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol = Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol.CreateForErrorRecovery(Me, groupJoin, ErrorTypeSymbol.UnknownResultType)
				boundQueryClauseBase = (New BoundQueryableSource(groupJoin, (New BoundQuerySource(Binder.BadExpression(groupJoin, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated())).MakeCompilerGenerated(), Nothing, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)(rangeVariableSymbol), ErrorTypeSymbol.UnknownResultType, ImmutableArray(Of Binder).Empty, ErrorTypeSymbol.UnknownResultType, True)).MakeCompilerGenerated()
			End If
			Dim enumerator1 As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax).Enumerator = groupJoin.AdditionalJoins.GetEnumerator()
			While enumerator1.MoveNext()
				Dim current As Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax = enumerator1.Current
				Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = current.Kind()
				If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleJoinClause) Then
					Dim simpleJoinClauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax = DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax)
					enumerator = New SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator()
					boundQueryClauseBase = Me.BindInnerJoinClause(boundQueryClauseBase, simpleJoinClauseSyntax, strs, enumerator, diagnostics)
				ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GroupJoinClause) Then
					Dim groupJoinClauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax = DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax)
					enumerator = New SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator()
					boundQueryClauseBase = Me.BindGroupJoinClause(boundQueryClauseBase, groupJoinClauseSyntax, strs, enumerator, diagnostics)
				End If
			End While
			Dim boundQueryLambda As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Nothing
			Dim boundQueryLambda1 As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Nothing
			Dim queryLambdaBinder As Binder.QueryLambdaBinder = Nothing
			Dim queryLambdaBinder1 As Binder.QueryLambdaBinder = Nothing
			Binder.QueryLambdaBinder.BindJoinKeys(Me, groupJoin, outer, boundQueryClauseBase, Microsoft.CodeAnalysis.ImmutableArrayExtensions.Concat(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)(outer.RangeVariables, boundQueryClauseBase.RangeVariables), boundQueryLambda, queryLambdaBinder, boundQueryLambda1, queryLambdaBinder1, diagnostics)
			Dim boundMethodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup = Nothing
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Me.InferGroupType(outer, boundQueryClauseBase, groupJoin, boundQueryLambda, boundQueryLambda1, boundMethodGroup, diagnostics)
			Dim intoClauseBinder As Binder.IntoClauseBinder = Nothing
			Dim rangeVariableSymbols As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol) = New ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)()
			Dim boundQueryLambda2 As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Me.BindIntoSelectorLambda(groupJoin, outer.RangeVariables, outer.CompoundVariableType, True, declaredNames, typeSymbol, boundQueryClauseBase.RangeVariables, boundQueryClauseBase.CompoundVariableType, groupJoin.AggregationVariables, Binder.MustProduceFlatCompoundVariable(groupJoin, operatorsEnumerator), diagnostics, intoClauseBinder, rangeVariableSymbols)
			If (outer.Type.IsErrorType() OrElse boundMethodGroup Is Nothing) Then
				boundExpression = Binder.BadExpression(groupJoin, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(New Microsoft.CodeAnalysis.VisualBasic.BoundExpression() { outer, boundQueryClauseBase, boundQueryLambda, boundQueryLambda1, boundQueryLambda2 }), ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
			Else
				Dim discarded As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
				If (boundQueryClauseBase.HasErrors OrElse boundQueryClauseBase.Type.IsErrorType() OrElse Binder.ShouldSuppressDiagnostics(boundQueryLambda) OrElse Binder.ShouldSuppressDiagnostics(boundQueryLambda1) OrElse Binder.ShouldSuppressDiagnostics(boundQueryLambda2)) Then
					discarded = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
				End If
				Dim boundExpressions As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundQueryClauseBase, boundQueryLambda, boundQueryLambda1, boundQueryLambda2)
				Dim joinKeyword As Microsoft.CodeAnalysis.SyntaxToken = groupJoin.JoinKeyword
				boundExpression = Me.BindQueryOperatorCall(groupJoin, outer, "GroupJoin", boundMethodGroup, boundExpressions, joinKeyword.Span, discarded)
			End If
			Return New BoundQueryClause(groupJoin, boundExpression, Microsoft.CodeAnalysis.ImmutableArrayExtensions.Concat(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)(outer.RangeVariables, rangeVariableSymbols), boundQueryLambda2.Expression.Type, ImmutableArray.Create(Of Binder)(queryLambdaBinder, queryLambdaBinder1, intoClauseBinder), boundExpression.Type, False)
		End Function

		Public Sub BindImportClause(ByVal importClauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsClauseSyntax, ByVal data As ImportData, ByVal diagBag As DiagnosticBag)
			Binder.ImportsBinder.BindImportClause(importClauseSyntax, Me, data, diagBag)
		End Sub

		Private Function BindIndexedInvocationExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax, ByVal target As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal boundArguments As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression), ByVal argumentNames As ImmutableArray(Of String), ByVal argumentNamesLocations As ImmutableArray(Of Location), ByVal allowBindingWithoutArguments As Boolean, <Out> ByRef hasIndexableTarget As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			hasIndexableTarget = False
			If (Not target.IsLValue AndAlso target.Kind <> BoundKind.LateMemberAccess) Then
				target = Me.MakeRValue(target, diagnostics)
			End If
			Dim type As TypeSymbol = target.Type
			If (type IsNot Nothing) Then
				If (Not type.IsArrayType()) Then
					If (type.Kind <> SymbolKind.NamedType OrElse type.TypeKind <> Microsoft.CodeAnalysis.TypeKind.[Delegate]) Then
						GoTo Label1
					End If
					hasIndexableTarget = True
					Dim delegateInvokeMethod As MethodSymbol = DirectCast(type, NamedTypeSymbol).DelegateInvokeMethod
					If (delegateInvokeMethod Is Nothing) Then
						If (Not target.HasErrors) Then
							Binder.ReportDiagnostic(diagnostics, target.Syntax, ERRID.ERR_DelegateNoInvoke1, New [Object]() { target.Type })
						End If
					ElseIf (Binder.ReportDelegateInvokeUseSite(diagnostics, target.Syntax, type, delegateInvokeMethod)) Then
						delegateInvokeMethod = Nothing
					End If
					If (delegateInvokeMethod Is Nothing) Then
						Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance()
						instance.Add(target)
						instance.AddRange(boundArguments)
						boundExpression = Binder.BadExpression(node, instance.ToImmutableAndFree(), ErrorTypeSymbol.UnknownResultType)
						Return boundExpression
					Else
						Dim expression As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = node.Expression
						If (expression Is Nothing) Then
							expression = node
						End If
						Dim boundMethodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup = (New Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup(expression, Nothing, ImmutableArray.Create(Of MethodSymbol)(delegateInvokeMethod), LookupResultKind.Good, target, QualificationKind.QualifiedViaValue, False)).MakeCompilerGenerated()
						Dim invocationExpressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax = node
						Dim expressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = node.Expression
						If (expressionSyntax Is Nothing) Then
							expressionSyntax = node
						End If
						boundExpression = Me.BindInvocationExpression(invocationExpressionSyntax, expressionSyntax, Binder.ExtractTypeCharacter(node.Expression), boundMethodGroup, boundArguments, argumentNames, diagnostics, node, False, False, False, type, False)
						Return boundExpression
					End If
				Else
					hasIndexableTarget = True
					If (Binder.IsCallStatementContext(node)) Then
						GoTo Label1
					End If
					boundExpression = Me.BindArrayAccess(node, target, boundArguments, argumentNames, diagnostics)
					Return boundExpression
				End If
			End If
		Label1:
			If (target.Kind <> BoundKind.BadExpression) Then
				If (Binder.IsCallStatementContext(node)) Then
					If (target.Kind = BoundKind.LateMemberAccess) Then
						hasIndexableTarget = True
						Dim boundLateMemberAccess As Microsoft.CodeAnalysis.VisualBasic.BoundLateMemberAccess = DirectCast(target, Microsoft.CodeAnalysis.VisualBasic.BoundLateMemberAccess)
						boundExpression = Me.BindLateBoundInvocation(node, Nothing, boundLateMemberAccess, boundArguments, argumentNames, diagnostics, False)
						Return boundExpression
					End If
					If (Not target.HasErrors) Then
						Dim diagnosticInfo As Microsoft.CodeAnalysis.DiagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_ExpectedProcedure)
						Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
						Dim expression1 As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = node.Expression
						If (expression1 Is Nothing) Then
							expression1 = node
						End If
						Binder.ReportDiagnostic(bindingDiagnosticBag, expression1, diagnosticInfo)
					End If
				ElseIf (target.Type.SpecialType = SpecialType.System_Object OrElse target.Type.SpecialType = SpecialType.System_Array) Then
					hasIndexableTarget = True
					boundExpression = Me.BindLateBoundInvocation(node, Nothing, target, boundArguments, argumentNames, diagnostics, target.Kind = BoundKind.LateMemberAccess)
					Return boundExpression
				ElseIf (Not target.HasErrors) Then
					Dim expressionSyntax1 As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = node.Expression
					If (expressionSyntax1 Is Nothing) Then
						expressionSyntax1 = node
					End If
					Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindDefaultPropertyGroup(expressionSyntax1, target, diagnostics)
					If (boundExpression1 Is Nothing) Then
						Binder.ReportNoDefaultProperty(target, diagnostics)
					Else
						hasIndexableTarget = True
						If (boundExpression1.Kind <> BoundKind.PropertyGroup AndAlso boundExpression1.Kind <> BoundKind.MethodGroup) Then
							boundExpression = Binder.GenerateBadExpression(node, target, boundArguments)
							Return boundExpression
						End If
						boundExpression = Me.BindInvocationExpressionPossiblyWithoutArguments(node, TypeCharacter.None, DirectCast(boundExpression1, BoundMethodOrPropertyGroup), boundArguments, argumentNames, argumentNamesLocations, allowBindingWithoutArguments, diagnostics)
						Return boundExpression
					End If
				End If
			End If
			boundExpression = Binder.GenerateBadExpression(node, target, boundArguments)
			Return boundExpression
		End Function

		Private Function BindInnerJoinClause(ByVal outer As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase, ByVal join As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax, ByVal declaredNames As HashSet(Of String), ByRef operatorsEnumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase
			Dim flag As Boolean
			Dim boundQueryClauseBase As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase
			Dim binders As ImmutableArray(Of Binder)
			Dim empty As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim enumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator
			If (declaredNames IsNot Nothing) Then
				flag = True
			Else
				flag = False
				declaredNames = Binder.CreateSetOfDeclaredNames(outer.RangeVariables)
			End If
			If (join.JoinedVariables.Count <> 0) Then
				Dim joinedVariables As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax) = join.JoinedVariables
				boundQueryClauseBase = Me.BindCollectionRangeVariable(joinedVariables(0), False, declaredNames, diagnostics)
			Else
				Dim rangeVariableSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol = Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol.CreateForErrorRecovery(Me, join, ErrorTypeSymbol.UnknownResultType)
				boundQueryClauseBase = (New BoundQueryableSource(join, (New BoundQuerySource(Binder.BadExpression(join, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated())).MakeCompilerGenerated(), Nothing, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)(rangeVariableSymbol), ErrorTypeSymbol.UnknownResultType, ImmutableArray(Of Binder).Empty, ErrorTypeSymbol.UnknownResultType, True)).MakeCompilerGenerated()
			End If
			Dim enumerator1 As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax).Enumerator = join.AdditionalJoins.GetEnumerator()
			While enumerator1.MoveNext()
				Dim current As Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax = enumerator1.Current
				Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = current.Kind()
				If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleJoinClause) Then
					Dim simpleJoinClauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax = DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax)
					enumerator = New SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator()
					boundQueryClauseBase = Me.BindInnerJoinClause(boundQueryClauseBase, simpleJoinClauseSyntax, declaredNames, enumerator, diagnostics)
				ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GroupJoinClause) Then
					Dim groupJoinClauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax = DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax)
					enumerator = New SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator()
					boundQueryClauseBase = Me.BindGroupJoinClause(boundQueryClauseBase, groupJoinClauseSyntax, declaredNames, enumerator, diagnostics)
				End If
			End While
			Dim boundQueryLambda As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Nothing
			Dim boundQueryLambda1 As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Nothing
			Dim queryLambdaBinder As Binder.QueryLambdaBinder = Nothing
			Dim queryLambdaBinder1 As Binder.QueryLambdaBinder = Nothing
			Dim rangeVariableSymbols As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol) = Microsoft.CodeAnalysis.ImmutableArrayExtensions.Concat(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)(outer.RangeVariables, boundQueryClauseBase.RangeVariables)
			Binder.QueryLambdaBinder.BindJoinKeys(Me, join, outer, boundQueryClauseBase, rangeVariableSymbols, boundQueryLambda, queryLambdaBinder, boundQueryLambda1, queryLambdaBinder1, diagnostics)
			Dim boundLambdaParameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol = Me.CreateQueryLambdaParameterSymbol(Binder.GetQueryLambdaParameterNameLeft(outer.RangeVariables), 0, outer.CompoundVariableType, join, outer.RangeVariables)
			Dim boundLambdaParameterSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol = Me.CreateQueryLambdaParameterSymbol(Binder.GetQueryLambdaParameterNameRight(boundQueryClauseBase.RangeVariables), 1, boundQueryClauseBase.CompoundVariableType, join, boundQueryClauseBase.RangeVariables)
			Dim queryClauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax = Nothing
			If (Not flag) Then
				queryClauseSyntax = Binder.JoinShouldAbsorbNextOperator(operatorsEnumerator)
			End If
			Dim boundQueryClauseBase1 As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase = Nothing
			Dim intoClauseDisallowGroupReferenceBinder As Binder.IntoClauseDisallowGroupReferenceBinder = Nothing
			Dim synthesizedLambdaKind As Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaKind = Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaKind.UserDefined
			Dim visualBasicSyntaxNode As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode = Nothing
			Binder.GetAbsorbingJoinSelectorLambdaKindAndSyntax(join, queryClauseSyntax, synthesizedLambdaKind, visualBasicSyntaxNode)
			Dim synthesizedLambdaSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaSymbol = Me.CreateQueryLambdaSymbol(visualBasicSyntaxNode, synthesizedLambdaKind, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol)(boundLambdaParameterSymbol, boundLambdaParameterSymbol1))
			Dim queryLambdaBinder2 As Binder.QueryLambdaBinder = New Binder.QueryLambdaBinder(synthesizedLambdaSymbol, rangeVariableSymbols)
			If (queryClauseSyntax Is Nothing) Then
				empty = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol).Empty
				boundExpression = queryLambdaBinder2.BuildJoinSelector(join, Binder.MustProduceFlatCompoundVariable(join, operatorsEnumerator), diagnostics, Nothing, Nothing)
				binders = ImmutableArray.Create(Of Binder)(queryLambdaBinder, queryLambdaBinder1)
			Else
				empty = New ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)()
				visualBasicSyntaxNode = Nothing
				boundExpression = queryLambdaBinder2.BindAbsorbingJoinSelector(queryClauseSyntax, operatorsEnumerator, outer.RangeVariables, boundQueryClauseBase.RangeVariables, empty, boundQueryClauseBase1, intoClauseDisallowGroupReferenceBinder, diagnostics)
				binders = ImmutableArray.Create(Of Binder)(queryLambdaBinder, queryLambdaBinder1, queryLambdaBinder2)
			End If
			Dim boundQueryLambda2 As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Binder.CreateBoundQueryLambda(synthesizedLambdaSymbol, rangeVariableSymbols, boundExpression, False)
			synthesizedLambdaSymbol.SetQueryLambdaReturnType(boundExpression.Type)
			boundQueryLambda2.SetWasCompilerGenerated()
			If (Not outer.Type.IsErrorType()) Then
				Dim discarded As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
				If (boundQueryClauseBase.HasErrors OrElse boundQueryClauseBase.Type.IsErrorType() OrElse Binder.ShouldSuppressDiagnostics(boundQueryLambda) OrElse Binder.ShouldSuppressDiagnostics(boundQueryLambda1) OrElse Binder.ShouldSuppressDiagnostics(boundQueryLambda2)) Then
					discarded = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
				End If
				Dim boundExpressions As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundQueryClauseBase, boundQueryLambda, boundQueryLambda1, boundQueryLambda2)
				Dim joinKeyword As Microsoft.CodeAnalysis.SyntaxToken = join.JoinKeyword
				boundExpression1 = Me.BindQueryOperatorCall(join, outer, "Join", boundExpressions, joinKeyword.Span, discarded)
			Else
				boundExpression1 = Binder.BadExpression(join, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(New Microsoft.CodeAnalysis.VisualBasic.BoundExpression() { outer, boundQueryClauseBase, boundQueryLambda, boundQueryLambda1, boundQueryLambda2 }), ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
			End If
			Dim boundQueryClause As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase = New Microsoft.CodeAnalysis.VisualBasic.BoundQueryClause(join, boundExpression1, rangeVariableSymbols, boundQueryLambda2.Expression.Type, binders, boundExpression1.Type, False)
			If (queryClauseSyntax IsNot Nothing) Then
				boundQueryClause = Me.AbsorbOperatorFollowingJoin(DirectCast(boundQueryClause, Microsoft.CodeAnalysis.VisualBasic.BoundQueryClause), queryClauseSyntax, operatorsEnumerator, empty, queryLambdaBinder2, outer.RangeVariables, boundQueryClauseBase.RangeVariables, boundQueryClauseBase1, intoClauseDisallowGroupReferenceBinder, diagnostics)
			End If
			Return boundQueryClause
		End Function

		Friend Overridable Function BindInsideCrefAttributeValue(ByVal name As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax, ByVal preserveAliases As Boolean, ByVal diagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol)) As ImmutableArray(Of Symbol)
			Return Me.ContainingBinder.BindInsideCrefAttributeValue(name, preserveAliases, diagnosticBag, useSiteInfo)
		End Function

		Friend Overridable Function BindInsideCrefAttributeValue(ByVal reference As Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax, ByVal preserveAliases As Boolean, ByVal diagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol)) As ImmutableArray(Of Symbol)
			Return Me.ContainingBinder.BindInsideCrefAttributeValue(reference, preserveAliases, diagnosticBag, useSiteInfo)
		End Function

		Private Function BindInterpolatedStringExpression(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim instance As ArrayBuilder(Of BoundNode) = ArrayBuilder(Of BoundNode).GetInstance()
			Dim enumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringContentSyntax).Enumerator = syntax.Contents.GetEnumerator()
			While enumerator.MoveNext()
				Dim current As Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringContentSyntax = enumerator.Current
				Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = current.Kind()
				If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InterpolatedStringText) Then
					instance.Add(Me.BindInterpolatedStringText(DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringTextSyntax), diagnostics))
				Else
					If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Interpolation) Then
						Throw ExceptionUtilities.Unreachable
					End If
					instance.Add(Me.BindInterpolation(DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationSyntax), diagnostics))
				End If
			End While
			Return New BoundInterpolatedStringExpression(syntax, instance.ToImmutableAndFree(), Me, Me.GetSpecialType(SpecialType.System_String, syntax, diagnostics), False)
		End Function

		Private Function BindInterpolatedStringText(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringTextSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundLiteral
			Dim textToken As Microsoft.CodeAnalysis.SyntaxToken = syntax.TextToken
			Return Me.CreateStringLiteral(syntax, textToken.ValueText, False, diagnostics, False)
		End Function

		Private Function BindInterpolation(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundInterpolation
			Dim boundLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundLiteral
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindRValue(syntax.Expression, diagnostics, False)
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			If (syntax.AlignmentClause IsNot Nothing) Then
				boundExpression1 = Me.BindRValue(syntax.AlignmentClause.Value, diagnostics, False)
				If (Not boundExpression1.IsConstant OrElse Not boundExpression1.ConstantValueOpt.IsIntegral) Then
					Binder.ReportDiagnostic(diagnostics, syntax.AlignmentClause.Value, ERRID.ERR_ExpectedIntLiteral)
				Else
					Dim constantValueOpt As ConstantValue = boundExpression1.ConstantValueOpt
					If (constantValueOpt.IsNegativeNumeric) Then
						If (constantValueOpt.Int64Value < CLng(-32767)) Then
							Binder.ReportDiagnostic(diagnostics, syntax.AlignmentClause.Value, ERRID.ERR_InterpolationAlignmentOutOfRange)
						End If
					ElseIf ([Decimal].Compare(New [Decimal](constantValueOpt.UInt64Value), New [Decimal](CLng(32767))) > 0) Then
						Binder.ReportDiagnostic(diagnostics, syntax.AlignmentClause.Value, ERRID.ERR_InterpolationAlignmentOutOfRange)
					End If
				End If
			End If
			If (syntax.FormatClause IsNot Nothing) Then
				Dim formatClause As Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationFormatClauseSyntax = syntax.FormatClause
				Dim formatStringToken As Microsoft.CodeAnalysis.SyntaxToken = syntax.FormatClause.FormatStringToken
				boundLiteral = Me.CreateStringLiteral(formatClause, formatStringToken.ValueText, False, diagnostics, False)
			Else
				boundLiteral = Nothing
			End If
			Return New BoundInterpolation(syntax, boundExpression, boundExpression1, boundLiteral, False)
		End Function

		Private Function BindIntoSelectorLambda(ByVal clauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax, ByVal keysRangeVariables As ImmutableArray(Of RangeVariableSymbol), ByVal keysCompoundVariableType As TypeSymbol, ByVal addKeysInScope As Boolean, ByVal declaredNames As HashSet(Of String), ByVal groupType As TypeSymbol, ByVal groupRangeVariables As ImmutableArray(Of RangeVariableSymbol), ByVal groupCompoundVariableType As TypeSymbol, ByVal aggregationVariables As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax), ByVal mustProduceFlatCompoundVariable As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, <Out> ByRef intoBinder As Binder.IntoClauseBinder, <Out> ByRef intoRangeVariables As ImmutableArray(Of RangeVariableSymbol)) As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda
			Dim boundLambdaParameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol = Me.CreateQueryLambdaParameterSymbol(Binder.GetQueryLambdaParameterName(keysRangeVariables), 0, keysCompoundVariableType, clauseSyntax, keysRangeVariables)
			Dim boundLambdaParameterSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol = Binder.CreateQueryLambdaParameterSymbol("$VB$ItAnonymous", 1, groupType, clauseSyntax)
			Dim synthesizedLambdaSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaSymbol = Me.CreateQueryLambdaSymbol(clauseSyntax, SynthesizedLambdaKind.GroupNonUserCodeQueryLambda, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol)(boundLambdaParameterSymbol, boundLambdaParameterSymbol1))
			Dim queryLambdaBinder As Binder.QueryLambdaBinder = New Binder.QueryLambdaBinder(synthesizedLambdaSymbol, ImmutableArray(Of RangeVariableSymbol).Empty)
			Dim boundParameter As Microsoft.CodeAnalysis.VisualBasic.BoundParameter = (New Microsoft.CodeAnalysis.VisualBasic.BoundParameter(boundLambdaParameterSymbol1.Syntax, boundLambdaParameterSymbol1, False, boundLambdaParameterSymbol1.Type)).MakeCompilerGenerated()
			intoBinder = New Binder.IntoClauseBinder(queryLambdaBinder, boundParameter, groupRangeVariables, groupCompoundVariableType, If(addKeysInScope, Microsoft.CodeAnalysis.ImmutableArrayExtensions.Concat(Of RangeVariableSymbol)(keysRangeVariables, groupRangeVariables), groupRangeVariables))
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = intoBinder.BindIntoSelector(clauseSyntax, keysRangeVariables, (New Microsoft.CodeAnalysis.VisualBasic.BoundParameter(boundLambdaParameterSymbol.Syntax, boundLambdaParameterSymbol, False, boundLambdaParameterSymbol.Type)).MakeCompilerGenerated(), keysRangeVariables, Nothing, ImmutableArray(Of RangeVariableSymbol).Empty, declaredNames, aggregationVariables, mustProduceFlatCompoundVariable, intoRangeVariables, diagnostics)
			Dim boundQueryLambda As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Binder.CreateBoundQueryLambda(synthesizedLambdaSymbol, keysRangeVariables, boundExpression, False)
			synthesizedLambdaSymbol.SetQueryLambdaReturnType(boundExpression.Type)
			boundQueryLambda.SetWasCompilerGenerated()
			Return boundQueryLambda
		End Function

		Private Function BindInvocationExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim flag As Boolean
			If (node.Expression IsNot Nothing) Then
				boundExpression1 = Me.BindExpression(node.Expression, True, False, False, diagnostics)
			Else
				Dim correspondingConditionalAccessExpression As Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax = node.GetCorrespondingConditionalAccessExpression()
				boundExpression1 = If(correspondingConditionalAccessExpression Is Nothing, Binder.ReportDiagnosticAndProduceBadExpression(diagnostics, node, ERRID.ERR_Syntax).MakeCompilerGenerated(), Me.GetConditionalAccessReceiver(correspondingConditionalAccessExpression))
			End If
			If (boundExpression1.Kind = BoundKind.MethodGroup) Then
				Dim boundMethodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup = DirectCast(boundExpression1, Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup)
				If (Not Binder.IsGroupOfConstructors(boundMethodGroup)) Then
					GoTo Label1
				End If
				boundExpression = Me.BindDirectConstructorCall(node, boundMethodGroup, diagnostics)
				Return boundExpression
			End If
		Label1:
			Dim boundExpressions As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = New ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)()
			Dim strs As ImmutableArray(Of String) = New ImmutableArray(Of String)()
			Dim locations As ImmutableArray(Of Location) = New ImmutableArray(Of Location)()
			Me.BindArgumentsAndNames(node.ArgumentList, boundExpressions, strs, locations, diagnostics)
			If (boundExpression1.Kind = BoundKind.MethodGroup OrElse boundExpression1.Kind = BoundKind.PropertyGroup) Then
				boundExpression = Me.BindInvocationExpressionPossiblyWithoutArguments(node, Binder.ExtractTypeCharacter(node.Expression), DirectCast(boundExpression1, BoundMethodOrPropertyGroup), boundExpressions, strs, locations, True, diagnostics)
			Else
				If (boundExpression1.Kind = BoundKind.NamespaceExpression) Then
					Dim boundNamespaceExpression As Microsoft.CodeAnalysis.VisualBasic.BoundNamespaceExpression = DirectCast(boundExpression1, Microsoft.CodeAnalysis.VisualBasic.BoundNamespaceExpression)
					Dim diagnosticInfo As Microsoft.CodeAnalysis.DiagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_NamespaceNotExpression1, New [Object]() { boundNamespaceExpression.NamespaceSymbol })
					Binder.ReportDiagnostic(diagnostics, node.Expression, diagnosticInfo)
				ElseIf (boundExpression1.Kind <> BoundKind.TypeExpression) Then
					flag = False
					boundExpression = Me.BindIndexedInvocationExpression(node, boundExpression1, boundExpressions, strs, locations, True, flag, diagnostics)
					Return boundExpression
				Else
					Dim boundTypeExpression As Microsoft.CodeAnalysis.VisualBasic.BoundTypeExpression = DirectCast(boundExpression1, Microsoft.CodeAnalysis.VisualBasic.BoundTypeExpression)
					If (Not Binder.IsCallStatementContext(node)) Then
						Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.TryDefaultInstanceProperty(boundTypeExpression, diagnostics)
						If (boundExpression2 Is Nothing) Then
							GoTo Label2
						End If
						flag = False
						boundExpression = Me.BindIndexedInvocationExpression(node, boundExpression2, boundExpressions, strs, locations, False, flag, diagnostics)
						Return boundExpression
					End If
				Label2:
					Dim typeNotExpressionErrorId As ERRID = Binder.GetTypeNotExpressionErrorId(boundTypeExpression.Type)
					Dim diagnosticInfo1 As Microsoft.CodeAnalysis.DiagnosticInfo = ErrorFactory.ErrorInfo(typeNotExpressionErrorId, New [Object]() { boundTypeExpression.Type })
					Binder.ReportDiagnostic(diagnostics, node.Expression, diagnosticInfo1)
				End If
				boundExpression = Binder.GenerateBadExpression(node, boundExpression1, boundExpressions)
			End If
			Return boundExpression
		End Function

		Friend Function BindInvocationExpression(ByVal node As SyntaxNode, ByVal target As SyntaxNode, ByVal typeChar As TypeCharacter, ByVal group As BoundMethodOrPropertyGroup, ByVal boundArguments As ImmutableArray(Of BoundExpression), ByVal argumentNames As ImmutableArray(Of String), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal callerInfoOpt As SyntaxNode, Optional ByVal allowConstructorCall As Boolean = False, Optional ByVal suppressAbstractCallDiagnostics As Boolean = False, Optional ByVal isDefaultMemberAccess As Boolean = False, Optional ByVal representCandidateInDiagnosticsOpt As Symbol = Nothing, Optional ByVal forceExpandedForm As Boolean = False) As BoundExpression
			Dim boundBadExpression As BoundExpression
			Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
			Dim overloadResolutionResult As OverloadResolution.OverloadResolutionResult = OverloadResolution.MethodOrPropertyInvocationOverloadResolution(group, boundArguments, argumentNames, Me, callerInfoOpt, newCompoundUseSiteInfo, False, forceExpandedForm)
			If (diagnostics.Add(node, newCompoundUseSiteInfo) AndAlso group.ResultKind <> LookupResultKind.Inaccessible) Then
				diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
			End If
			If (overloadResolutionResult.BestResult.HasValue) Then
				Dim bestResult As Nullable(Of OverloadResolution.CandidateAnalysisResult) = overloadResolutionResult.BestResult
				boundBadExpression = Me.CreateBoundCallOrPropertyAccess(node, target, typeChar, group, boundArguments, bestResult.Value, overloadResolutionResult.AsyncLambdaSubToFunctionMismatch, diagnostics, suppressAbstractCallDiagnostics)
			ElseIf (Not overloadResolutionResult.ResolutionIsLateBound) Then
				If (overloadResolutionResult.Candidates.Length = 0) Then
					Dim discarded As CompoundUseSiteInfo(Of AssemblySymbol) = CompoundUseSiteInfo(Of AssemblySymbol).Discarded
					overloadResolutionResult = OverloadResolution.MethodOrPropertyInvocationOverloadResolution(group, boundArguments, argumentNames, Me, callerInfoOpt, discarded, True, forceExpandedForm)
				End If
				boundBadExpression = Me.ReportOverloadResolutionFailureAndProduceBoundNode(node, group, boundArguments, argumentNames, overloadResolutionResult, diagnostics, callerInfoOpt, Nothing, False, Nothing, representCandidateInDiagnosticsOpt, Nothing)
			Else
				If (group.Kind = BoundKind.MethodGroup) Then
					Dim isEmpty As Boolean = False
					Dim boundMethodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup = DirectCast(group, Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup)
					Dim enumerator As ImmutableArray(Of MethodSymbol).Enumerator = boundMethodGroup.Methods.GetEnumerator()
					While enumerator.MoveNext()
						If (enumerator.Current.ReducedFrom Is Nothing) Then
							Continue While
						End If
						isEmpty = True
						Exit While
					End While
					If (Not isEmpty) Then
						newCompoundUseSiteInfo = New CompoundUseSiteInfo(Of AssemblySymbol)(newCompoundUseSiteInfo)
						isEmpty = Not boundMethodGroup.AdditionalExtensionMethods(newCompoundUseSiteInfo).IsEmpty
						diagnostics.Add(node, newCompoundUseSiteInfo)
					End If
					If (Not isEmpty) Then
						GoTo Label1
					End If
					Binder.ReportDiagnostic(diagnostics, Binder.GetLocationForOverloadResolutionDiagnostic(node, group), ERRID.ERR_ExtensionMethodCannotBeLateBound)
					Dim instance As ArrayBuilder(Of BoundExpression) = ArrayBuilder(Of BoundExpression).GetInstance()
					instance.Add(group)
					If (Not boundArguments.IsEmpty) Then
						instance.AddRange(boundArguments)
					End If
					boundBadExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression(node, LookupResultKind.OverloadResolutionFailure, ImmutableArray(Of Symbol).Empty, instance.ToImmutableAndFree(), ErrorTypeSymbol.UnknownResultType, True)
					Return boundBadExpression
				End If
			Label1:
				boundBadExpression = Me.BindLateBoundInvocation(node, group, isDefaultMemberAccess, boundArguments, argumentNames, diagnostics)
			End If
			Return boundBadExpression
		End Function

		Private Function BindInvocationExpressionAsStatement(ByVal expression As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Return Me.ReclassifyInvocationExpressionAsStatement(Me.BindExpression(expression, diagnostics), diagnostics)
		End Function

		Private Function BindInvocationExpressionIfGroupNotNothing(ByVal syntax As SyntaxNode, ByVal groupOpt As BoundMethodOrPropertyGroup, ByVal arguments As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			If (groupOpt IsNot Nothing) Then
				Dim strs As ImmutableArray(Of String) = New ImmutableArray(Of String)()
				boundExpression = Me.BindInvocationExpression(syntax, syntax, TypeCharacter.None, groupOpt, arguments, strs, diagnostics, Nothing, False, False, False, Nothing, False)
			Else
				boundExpression = Binder.BadExpression(syntax, arguments, ErrorTypeSymbol.UnknownResultType)
			End If
			Return boundExpression
		End Function

		Private Function BindInvocationExpressionPossiblyWithoutArguments(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax, ByVal typeChar As TypeCharacter, ByVal group As BoundMethodOrPropertyGroup, ByVal boundArguments As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression), ByVal argumentNames As ImmutableArray(Of String), ByVal argumentNamesLocations As ImmutableArray(Of Location), ByVal allowBindingWithoutArguments As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim expression As Microsoft.CodeAnalysis.SyntaxNode
			Dim invocationExpressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax
			Dim syntax As Microsoft.CodeAnalysis.SyntaxNode
			Dim syntaxNode As Microsoft.CodeAnalysis.SyntaxNode
			Dim syntaxNode1 As Microsoft.CodeAnalysis.SyntaxNode
			If (allowBindingWithoutArguments AndAlso boundArguments.Length > 0 AndAlso Not Binder.IsCallStatementContext(node) AndAlso Me.ShouldBindWithoutArguments(node, group, diagnostics)) Then
				Dim instance As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.GetInstance(diagnostics)
				Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
				Dim expressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = node.Expression
				Dim expression1 As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = node.Expression
				Dim empty As ImmutableArray(Of !0) = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty
				Dim strs As ImmutableArray(Of String) = New ImmutableArray(Of String)()
				Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindInvocationExpression(expressionSyntax, expression1, typeChar, group, empty, strs, instance, group.Syntax, False, False, False, Nothing, False)
				If (boundExpression2.Kind = BoundKind.[Call] OrElse boundExpression2.Kind = BoundKind.PropertyAccess) Then
					diagnostics.AddRange(instance, False)
					instance.Clear()
					If (boundExpression2.Kind <> BoundKind.PropertyAccess) Then
						Dim receiverOpt As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = DirectCast(boundExpression2, BoundCall).ReceiverOpt
						If (receiverOpt IsNot Nothing) Then
							syntax = receiverOpt.Syntax
						Else
							syntax = Nothing
						End If
						If (syntax = boundExpression2.Syntax AndAlso Not receiverOpt.WasCompilerGenerated) Then
							boundExpression2.MakeCompilerGenerated()
						End If
					Else
						Dim receiverOpt1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = DirectCast(boundExpression2, BoundPropertyAccess).ReceiverOpt
						If (receiverOpt1 IsNot Nothing) Then
							syntaxNode = receiverOpt1.Syntax
						Else
							syntaxNode = Nothing
						End If
						If (syntaxNode = boundExpression2.Syntax AndAlso Not receiverOpt1.WasCompilerGenerated) Then
							boundExpression2.MakeCompilerGenerated()
						End If
						boundExpression2 = Me.MakeRValue(boundExpression2, diagnostics)
					End If
					If (boundExpression2.Kind <> BoundKind.BadExpression) Then
						Dim flag As Boolean = False
						Dim boundExpression3 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindIndexedInvocationExpression(node, boundExpression2, boundArguments, argumentNames, argumentNamesLocations, False, flag, instance)
						If (Not flag) Then
							Binder.ReportDiagnostic(diagnostics, node.Expression, ERRID.ERR_FunctionResultCannotBeIndexed1, New [Object]() { boundExpression2.ExpressionSymbol })
							boundExpression1 = Me.BindInvocationExpression(node, node.Expression, typeChar, group, boundArguments, argumentNames, Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded, group.Syntax, False, False, False, Nothing, False)
						Else
							diagnostics.AddRange(instance, False)
							boundExpression1 = boundExpression3
						End If
					Else
						boundExpression1 = Binder.GenerateBadExpression(node, boundExpression2, boundArguments)
					End If
				End If
				instance.Free()
				If (boundExpression1 Is Nothing) Then
					invocationExpressionSyntax = node
					expression = node.Expression
					If (expression Is Nothing) Then
						syntaxNode1 = expression
						expression = group.Syntax
					End If
					boundExpression = Me.BindInvocationExpression(invocationExpressionSyntax, expression, typeChar, group, boundArguments, argumentNames, diagnostics, group.Syntax, False, False, False, Nothing, False)
					Return boundExpression
				End If
				boundExpression = boundExpression1
				Return boundExpression
			End If
			invocationExpressionSyntax = node
			expression = node.Expression
			If (expression Is Nothing) Then
				syntaxNode1 = expression
				expression = group.Syntax
			End If
			boundExpression = Me.BindInvocationExpression(invocationExpressionSyntax, expression, typeChar, group, boundArguments, argumentNames, diagnostics, group.Syntax, False, False, False, Nothing, False)
			Return boundExpression
		End Function

		Private Function BindIsExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim flag As Boolean = node.Kind() = SyntaxKind.IsNotExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindExpression(node.Left, diagnostics)
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindExpression(node.Right, diagnostics)
			Return Me.BindIsExpression(boundExpression, boundExpression1, node, flag, diagnostics)
		End Function

		Private Function BindIsExpression(ByVal left As BoundExpression, ByVal right As BoundExpression, ByVal node As SyntaxNode, ByVal [isNot] As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			left = Me.MakeRValue(left, diagnostics)
			right = Me.MakeRValue(right, diagnostics)
			left = Me.ValidateAndConvertIsExpressionArgument(left, right, [isNot], diagnostics)
			right = Me.ValidateAndConvertIsExpressionArgument(right, left, [isNot], diagnostics)
			Dim specialType As NamedTypeSymbol = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Boolean, node, diagnostics)
			Return New BoundBinaryOperator(node, If([isNot], BinaryOperatorKind.[IsNot], BinaryOperatorKind.[Is]), left, right, False, specialType, specialType.IsErrorType())
		End Function

		Public Function BindLabel(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim boundLabel As BoundExpression
			Dim valueText As String = node.LabelToken.ValueText
			Dim instance As LookupResult = LookupResult.GetInstance()
			Dim discarded As CompoundUseSiteInfo(Of AssemblySymbol) = CompoundUseSiteInfo(Of AssemblySymbol).Discarded
			Me.Lookup(instance, valueText, 0, LookupOptions.LabelsOnly, discarded)
			Dim labelSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.LabelSymbol = Nothing
			Dim flag As Boolean = False
			If (Not instance.IsGood OrElse Not instance.HasSingleSymbol) Then
				If (Not instance.HasDiagnostic) Then
					Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_LabelNotDefined1, New [Object]() { valueText })
				Else
					Binder.ReportDiagnostic(diagnostics, node, instance.Diagnostic)
				End If
				flag = True
			Else
				labelSymbol = DirectCast(instance.Symbols.First(), Microsoft.CodeAnalysis.VisualBasic.Symbols.LabelSymbol)
			End If
			instance.Free()
			If (labelSymbol IsNot Nothing) Then
				boundLabel = New Microsoft.CodeAnalysis.VisualBasic.BoundLabel(node, labelSymbol, Nothing, flag)
			Else
				boundLabel = New BoundBadExpression(node, LookupResultKind.Empty, ImmutableArray(Of Symbol).Empty, ImmutableArray(Of BoundExpression).Empty, Nothing, True)
			End If
			Return boundLabel
		End Function

		Private Function BindLabelStatement(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim labelToken As Microsoft.CodeAnalysis.SyntaxToken = node.LabelToken
			Dim valueText As String = labelToken.ValueText
			Dim instance As LookupResult = LookupResult.GetInstance()
			Dim discarded As CompoundUseSiteInfo(Of AssemblySymbol) = CompoundUseSiteInfo(Of AssemblySymbol).Discarded
			Me.Lookup(instance, valueText, 0, LookupOptions.LabelsOnly, discarded)
			Dim singleSymbol As SourceLabelSymbol = DirectCast(instance.SingleSymbol, SourceLabelSymbol)
			Dim flag As Boolean = False
			If (singleSymbol.LabelName <> labelToken) Then
				Binder.ReportDiagnostic(diagnostics, labelToken, ERRID.ERR_MultiplyDefined1, New [Object]() { valueText })
				flag = True
			End If
			instance.Free()
			Return New BoundLabelStatement(node, singleSymbol, flag)
		End Function

		Private Function BindLambdaBody(ByVal lambdaSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.LambdaSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByRef lambdaBinder As LambdaBodyBinder) As Microsoft.CodeAnalysis.VisualBasic.BoundBlock
			Dim boundBlock As Microsoft.CodeAnalysis.VisualBasic.BoundBlock
			Dim implicitVariableBinder As Microsoft.CodeAnalysis.VisualBasic.Binder = Nothing
			If (Me.ContainingBinder.OptionExplicit OrElse Me.ContainingBinder.ImplicitVariableDeclarationAllowed) Then
				lambdaBinder = New LambdaBodyBinder(lambdaSymbol, Me)
			Else
				implicitVariableBinder = New Microsoft.CodeAnalysis.VisualBasic.ImplicitVariableBinder(Me, lambdaSymbol)
				lambdaBinder = New LambdaBodyBinder(lambdaSymbol, implicitVariableBinder)
			End If
			Dim syntax As SyntaxNode = lambdaSymbol.Syntax
			Dim binder As Microsoft.CodeAnalysis.VisualBasic.Binder = lambdaBinder.GetBinder(syntax)
			Dim endSubOrFunctionStatement As SyntaxNode = syntax
			Select Case syntax.Kind()
				Case SyntaxKind.SingleLineFunctionLambdaExpression
					Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = binder.BindValue(DirectCast(DirectCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineLambdaExpressionSyntax).Body, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax), diagnostics, False)
					If (CObj(lambdaSymbol.ReturnType) <> CObj(Microsoft.CodeAnalysis.VisualBasic.Symbols.LambdaSymbol.ReturnTypeIsBeingInferred)) Then
						If (CObj(lambdaSymbol.ReturnType) = CObj(Microsoft.CodeAnalysis.VisualBasic.Symbols.LambdaSymbol.ReturnTypeIsUnknown)) Then
							boundExpression = binder.MakeRValueAndIgnoreDiagnostics(boundExpression)
						Else
							Dim returnType As TypeSymbol = lambdaSymbol.ReturnType
							If (lambdaSymbol.IsAsync AndAlso returnType.OriginalDefinition.Equals(Me.Compilation.GetWellKnownType(WellKnownType.System_Threading_Tasks_Task_T))) Then
								returnType = DirectCast(returnType, NamedTypeSymbol).TypeArgumentsNoUseSiteDiagnostics(0)
							End If
							boundExpression = binder.ApplyImplicitConversion(boundExpression.Syntax, returnType, boundExpression, diagnostics, False)
						End If
					End If
					Dim boundReturnStatement As Microsoft.CodeAnalysis.VisualBasic.BoundReturnStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundReturnStatement(boundExpression.Syntax, boundExpression, binder.GetLocalForFunctionValue(), binder.GetReturnLabel(), boundExpression.HasErrors)
					boundReturnStatement.SetWasCompilerGenerated()
					Dim statementSyntaxes As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax) = New SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)()
					boundBlock = (New Microsoft.CodeAnalysis.VisualBasic.BoundBlock(syntax, statementSyntaxes, ImmutableArray(Of LocalSymbol).Empty, ImmutableArray.Create(Of BoundStatement)(boundReturnStatement), boundExpression.HasErrors)).MakeCompilerGenerated()
					Exit Select
				Case SyntaxKind.EndFunctionStatement Or SyntaxKind.EndOperatorStatement Or SyntaxKind.FunctionBlock Or SyntaxKind.SetAccessorBlock Or SyntaxKind.MidExpression Or SyntaxKind.CharacterLiteralExpression Or SyntaxKind.DateLiteralExpression Or SyntaxKind.NotEqualsExpression Or SyntaxKind.GreaterThanExpression Or SyntaxKind.AddressOfExpression
				Case SyntaxKind.List Or SyntaxKind.EndIfStatement Or SyntaxKind.EndFunctionStatement Or SyntaxKind.EndGetStatement Or SyntaxKind.EndOperatorStatement Or SyntaxKind.EndEventStatement Or SyntaxKind.FunctionBlock Or SyntaxKind.ConstructorBlock Or SyntaxKind.SetAccessorBlock Or SyntaxKind.AddHandlerAccessorBlock Or SyntaxKind.MidExpression Or SyntaxKind.CallStatement Or SyntaxKind.CharacterLiteralExpression Or SyntaxKind.TrueLiteralExpression Or SyntaxKind.DateLiteralExpression Or SyntaxKind.NotEqualsExpression Or SyntaxKind.LessThanExpression Or SyntaxKind.GreaterThanExpression Or SyntaxKind.IsExpression Or SyntaxKind.AddressOfExpression Or SyntaxKind.BinaryConditionalExpression
					Throw ExceptionUtilities.UnexpectedValue(syntax.Kind())
				Case SyntaxKind.SingleLineSubLambdaExpression
					Dim singleLineLambdaExpressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineLambdaExpressionSyntax = DirectCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineLambdaExpressionSyntax)
					Dim body As Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax = DirectCast(singleLineLambdaExpressionSyntax.Body, Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)
					If (body.Kind() <> SyntaxKind.LocalDeclarationStatement) Then
						boundBlock = binder.BindBlock(syntax, singleLineLambdaExpressionSyntax.Statements, diagnostics).MakeCompilerGenerated()
						Exit Select
					Else
						boundBlock = binder.BindBlock(syntax, singleLineLambdaExpressionSyntax.Statements, Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded).MakeCompilerGenerated()
						Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagnostics, body, ERRID.ERR_SubDisallowsStatement)
						Exit Select
					End If
				Case SyntaxKind.MultiLineFunctionLambdaExpression
				Case SyntaxKind.MultiLineSubLambdaExpression
					Dim multiLineLambdaExpressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax = DirectCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax)
					endSubOrFunctionStatement = multiLineLambdaExpressionSyntax.EndSubOrFunctionStatement
					boundBlock = binder.BindBlock(syntax, multiLineLambdaExpressionSyntax.Statements, diagnostics).MakeCompilerGenerated()
					Exit Select
				Case Else
					Throw ExceptionUtilities.UnexpectedValue(syntax.Kind())
			End Select
			Dim instance As ArrayBuilder(Of LocalSymbol) = ArrayBuilder(Of LocalSymbol).GetInstance()
			Dim boundStatements As ArrayBuilder(Of BoundStatement) = ArrayBuilder(Of BoundStatement).GetInstance()
			boundStatements.AddRange(boundBlock.Statements)
			Select Case syntax.Kind()
				Case SyntaxKind.SingleLineFunctionLambdaExpression
				Case SyntaxKind.MultiLineFunctionLambdaExpression
					Dim localForFunctionValue As LocalSymbol = binder.GetLocalForFunctionValue()
					instance.Add(localForFunctionValue)
					Dim boundLabelStatement As Microsoft.CodeAnalysis.VisualBasic.BoundLabelStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundLabelStatement(endSubOrFunctionStatement, binder.GetReturnLabel())
					Dim boundLocal As Microsoft.CodeAnalysis.VisualBasic.BoundLocal = (New Microsoft.CodeAnalysis.VisualBasic.BoundLocal(endSubOrFunctionStatement, localForFunctionValue, False, localForFunctionValue.Type)).MakeCompilerGenerated()
					Dim boundReturnStatement1 As Microsoft.CodeAnalysis.VisualBasic.BoundReturnStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundReturnStatement(endSubOrFunctionStatement, boundLocal, Nothing, Nothing, False)
					If (syntax.Kind() = SyntaxKind.SingleLineFunctionLambdaExpression OrElse endSubOrFunctionStatement = syntax) Then
						boundLabelStatement.SetWasCompilerGenerated()
						boundReturnStatement1.SetWasCompilerGenerated()
					End If
					boundStatements.Add(boundLabelStatement)
					boundStatements.Add(boundReturnStatement1)
					If (implicitVariableBinder IsNot Nothing) Then
						implicitVariableBinder.DisallowFurtherImplicitVariableDeclaration(diagnostics)
						instance.AddRange(implicitVariableBinder.ImplicitlyDeclaredVariables)
					End If
					If (Not boundBlock.Locals.IsEmpty) Then
						instance.AddRange(boundBlock.Locals)
					End If
					boundBlock = boundBlock.Update(boundBlock.StatementListSyntax, instance.ToImmutableAndFree(), boundStatements.ToImmutableAndFree())
					boundBlock.SetWasCompilerGenerated()
					If (lambdaSymbol.IsAsync AndAlso Not Microsoft.CodeAnalysis.VisualBasic.Binder.CheckAwaitWalker.VisitBlock(binder, boundBlock, diagnostics) AndAlso Not boundBlock.HasErrors AndAlso Not lambdaSymbol.IsIterator) Then
						Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagnostics, DirectCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaExpressionSyntax).SubOrFunctionHeader.DeclarationKeyword, ERRID.WRN_AsyncLacksAwaits)
					End If
					Return boundBlock
				Case SyntaxKind.EndFunctionStatement Or SyntaxKind.EndOperatorStatement Or SyntaxKind.FunctionBlock Or SyntaxKind.SetAccessorBlock Or SyntaxKind.MidExpression Or SyntaxKind.CharacterLiteralExpression Or SyntaxKind.DateLiteralExpression Or SyntaxKind.NotEqualsExpression Or SyntaxKind.GreaterThanExpression Or SyntaxKind.AddressOfExpression
				Case SyntaxKind.List Or SyntaxKind.EndIfStatement Or SyntaxKind.EndFunctionStatement Or SyntaxKind.EndGetStatement Or SyntaxKind.EndOperatorStatement Or SyntaxKind.EndEventStatement Or SyntaxKind.FunctionBlock Or SyntaxKind.ConstructorBlock Or SyntaxKind.SetAccessorBlock Or SyntaxKind.AddHandlerAccessorBlock Or SyntaxKind.MidExpression Or SyntaxKind.CallStatement Or SyntaxKind.CharacterLiteralExpression Or SyntaxKind.TrueLiteralExpression Or SyntaxKind.DateLiteralExpression Or SyntaxKind.NotEqualsExpression Or SyntaxKind.LessThanExpression Or SyntaxKind.GreaterThanExpression Or SyntaxKind.IsExpression Or SyntaxKind.AddressOfExpression Or SyntaxKind.BinaryConditionalExpression
					If (implicitVariableBinder IsNot Nothing) Then
						implicitVariableBinder.DisallowFurtherImplicitVariableDeclaration(diagnostics)
						instance.AddRange(implicitVariableBinder.ImplicitlyDeclaredVariables)
					End If
					If (Not boundBlock.Locals.IsEmpty) Then
						instance.AddRange(boundBlock.Locals)
					End If
					boundBlock = boundBlock.Update(boundBlock.StatementListSyntax, instance.ToImmutableAndFree(), boundStatements.ToImmutableAndFree())
					boundBlock.SetWasCompilerGenerated()
					If (lambdaSymbol.IsAsync AndAlso Not Microsoft.CodeAnalysis.VisualBasic.Binder.CheckAwaitWalker.VisitBlock(binder, boundBlock, diagnostics) AndAlso Not boundBlock.HasErrors AndAlso Not lambdaSymbol.IsIterator) Then
						Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagnostics, DirectCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaExpressionSyntax).SubOrFunctionHeader.DeclarationKeyword, ERRID.WRN_AsyncLacksAwaits)
					End If
					Return boundBlock
				Case SyntaxKind.SingleLineSubLambdaExpression
				Case SyntaxKind.MultiLineSubLambdaExpression
					Dim boundLabelStatement1 As Microsoft.CodeAnalysis.VisualBasic.BoundLabelStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundLabelStatement(endSubOrFunctionStatement, binder.GetReturnLabel())
					Dim boundReturnStatement2 As Microsoft.CodeAnalysis.VisualBasic.BoundReturnStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundReturnStatement(endSubOrFunctionStatement, Nothing, Nothing, Nothing, False)
					If (syntax.Kind() = SyntaxKind.SingleLineSubLambdaExpression OrElse endSubOrFunctionStatement = syntax) Then
						boundLabelStatement1.SetWasCompilerGenerated()
						boundReturnStatement2.SetWasCompilerGenerated()
					End If
					boundStatements.Add(boundLabelStatement1)
					boundStatements.Add(boundReturnStatement2)
					If (implicitVariableBinder IsNot Nothing) Then
						implicitVariableBinder.DisallowFurtherImplicitVariableDeclaration(diagnostics)
						instance.AddRange(implicitVariableBinder.ImplicitlyDeclaredVariables)
					End If
					If (Not boundBlock.Locals.IsEmpty) Then
						instance.AddRange(boundBlock.Locals)
					End If
					boundBlock = boundBlock.Update(boundBlock.StatementListSyntax, instance.ToImmutableAndFree(), boundStatements.ToImmutableAndFree())
					boundBlock.SetWasCompilerGenerated()
					If (lambdaSymbol.IsAsync AndAlso Not Microsoft.CodeAnalysis.VisualBasic.Binder.CheckAwaitWalker.VisitBlock(binder, boundBlock, diagnostics) AndAlso Not boundBlock.HasErrors AndAlso Not lambdaSymbol.IsIterator) Then
						Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagnostics, DirectCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaExpressionSyntax).SubOrFunctionHeader.DeclarationKeyword, ERRID.WRN_AsyncLacksAwaits)
					End If
					Return boundBlock
				Case Else
					If (implicitVariableBinder IsNot Nothing) Then
						implicitVariableBinder.DisallowFurtherImplicitVariableDeclaration(diagnostics)
						instance.AddRange(implicitVariableBinder.ImplicitlyDeclaredVariables)
					End If
					If (Not boundBlock.Locals.IsEmpty) Then
						instance.AddRange(boundBlock.Locals)
					End If
					boundBlock = boundBlock.Update(boundBlock.StatementListSyntax, instance.ToImmutableAndFree(), boundStatements.ToImmutableAndFree())
					boundBlock.SetWasCompilerGenerated()
					If (lambdaSymbol.IsAsync AndAlso Not Microsoft.CodeAnalysis.VisualBasic.Binder.CheckAwaitWalker.VisitBlock(binder, boundBlock, diagnostics) AndAlso Not boundBlock.HasErrors AndAlso Not lambdaSymbol.IsIterator) Then
						Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagnostics, DirectCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaExpressionSyntax).SubOrFunctionHeader.DeclarationKeyword, ERRID.WRN_AsyncLacksAwaits)
					End If
					Return boundBlock
			End Select
		End Function

		Private Function BindLambdaExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim memberModifier As MemberModifiers = Me.DecodeModifiers(node.SubOrFunctionHeader.Modifiers, SourceMemberFlags.Async Or SourceMemberFlags.Iterator, ERRID.ERR_InvalidLambdaModifier, Accessibility.[Public], If(diagnostics.DiagnosticBag, New DiagnosticBag()))
			Dim foundFlags As SourceMemberFlags = memberModifier.FoundFlags And (SourceMemberFlags.Async Or SourceMemberFlags.Iterator)
			If ((foundFlags And (SourceMemberFlags.Async Or SourceMemberFlags.Iterator)) = (SourceMemberFlags.Async Or SourceMemberFlags.Iterator) AndAlso diagnostics.AccumulatesDiagnostics) Then
				Me.ReportModifierError(node.SubOrFunctionHeader.Modifiers, ERRID.ERR_InvalidAsyncIteratorModifiers, diagnostics.DiagnosticBag, InvalidModifiers.InvalidAsyncIterator)
			End If
			Dim parameterSymbols As ImmutableArray(Of ParameterSymbol) = Me.DecodeParameterList(Me.ContainingMember, True, foundFlags, node.SubOrFunctionHeader.ParameterList, diagnostics)
			Dim enumerator As ImmutableArray(Of ParameterSymbol).Enumerator = parameterSymbols.GetEnumerator()
			While enumerator.MoveNext()
				Dim current As ParameterSymbol = enumerator.Current
				Dim identifierSyntax As SyntaxNodeOrToken = DirectCast(current, UnboundLambdaParameterSymbol).IdentifierSyntax
				Me.VerifyNameShadowingInMethodBody(current, identifierSyntax, identifierSyntax, diagnostics)
			End While
			Dim specialType As TypeSymbol = Nothing
			Dim flag As Boolean = False
			If (node.Kind() = SyntaxKind.MultiLineFunctionLambdaExpression AndAlso node.SubOrFunctionHeader.AsClause IsNot Nothing) Then
				specialType = Me.BindTypeSyntax(node.SubOrFunctionHeader.AsClause.Type, diagnostics, False, False, False)
				If (specialType.IsRestrictedType()) Then
					Binder.ReportDiagnostic(diagnostics, node.SubOrFunctionHeader.AsClause.Type, ERRID.ERR_RestrictedType1, New [Object]() { specialType })
					flag = True
				ElseIf (Not specialType.IsErrorType() AndAlso (foundFlags And (SourceMemberFlags.Async Or SourceMemberFlags.Iterator)) <> (SourceMemberFlags.Async Or SourceMemberFlags.Iterator)) Then
					If (foundFlags = SourceMemberFlags.Async AndAlso Not specialType.OriginalDefinition.Equals(Me.Compilation.GetWellKnownType(WellKnownType.System_Threading_Tasks_Task_T)) AndAlso Not specialType.Equals(Me.Compilation.GetWellKnownType(WellKnownType.System_Threading_Tasks_Task))) Then
						Binder.ReportDiagnostic(diagnostics, node.SubOrFunctionHeader.AsClause.Type, ERRID.ERR_BadAsyncReturn)
					End If
					If (foundFlags = SourceMemberFlags.Iterator) Then
						Dim originalDefinition As TypeSymbol = specialType.OriginalDefinition
						If (originalDefinition.SpecialType <> Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_IEnumerable_T AndAlso originalDefinition.SpecialType <> Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_IEnumerator_T AndAlso specialType.SpecialType <> Microsoft.CodeAnalysis.SpecialType.System_Collections_IEnumerable AndAlso specialType.SpecialType <> Microsoft.CodeAnalysis.SpecialType.System_Collections_IEnumerator) Then
							Binder.ReportDiagnostic(diagnostics, node.SubOrFunctionHeader.AsClause.Type, ERRID.ERR_BadIteratorReturn)
						End If
					End If
				End If
			ElseIf (node.Kind() = SyntaxKind.MultiLineSubLambdaExpression OrElse node.Kind() = SyntaxKind.SingleLineSubLambdaExpression) Then
				specialType = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Void, node.SubOrFunctionHeader, diagnostics)
				If (foundFlags = SourceMemberFlags.Iterator) Then
					Binder.ReportDiagnostic(diagnostics, node.SubOrFunctionHeader.DeclarationKeyword, ERRID.ERR_BadIteratorReturn)
				End If
			End If
			Return New UnboundLambda(node, Me, foundFlags, parameterSymbols, specialType, New UnboundLambda.UnboundLambdaBindingCache(diagnostics.AccumulatesDependencies), flag)
		End Function

		Friend Function BindLambdaForErrorRecovery(ByVal source As UnboundLambda) As BoundLambda
			Dim enumerator As IEnumerator(Of KeyValuePair(Of UnboundLambda.TargetSignature, KeyValuePair(Of TypeSymbol, ImmutableBindingDiagnostic(Of AssemblySymbol)))) = Nothing
			Dim parameterTypes As ImmutableArray(Of TypeSymbol)
			Dim value As KeyValuePair(Of TypeSymbol, ImmutableBindingDiagnostic(Of AssemblySymbol))
			Dim enumerator1 As IEnumerator(Of KeyValuePair(Of UnboundLambda.TargetSignature, BoundLambda)) = Nothing
			If (source.BindingCache.ErrorRecoverySignature Is Nothing) Then
				Dim key As TypeSymbol = Nothing
				Dim parameters As ImmutableArray(Of ParameterSymbol) = source.Parameters
				Using type(parameters.Length - 1 + 1 - 1) As TypeSymbol
					enumerator = source.BindingCache.InferredReturnType.GetEnumerator()
					While enumerator.MoveNext()
						Dim current As KeyValuePair(Of UnboundLambda.TargetSignature, KeyValuePair(Of TypeSymbol, ImmutableBindingDiagnostic(Of AssemblySymbol))) = enumerator.Current
						Dim targetSignature As UnboundLambda.TargetSignature = current.Key
						parameterTypes = targetSignature.ParameterTypes
						Dim num As Integer = Math.Min(parameterTypes.Length, CInt(type.Length)) - 1
						Dim num1 As Integer = 0
						Do
							parameterTypes = targetSignature.ParameterTypes
							Binder.BindLambdaForErrorRecoveryInferCommonType(type(num1), parameterTypes(num1))
							num1 = num1 + 1
						Loop While num1 <= num
						value = current.Value
						Binder.BindLambdaForErrorRecoveryInferCommonType(key, value.Key)
					End While
				End Using
				Using enumerator1
					enumerator1 = source.BindingCache.BoundLambdas.GetEnumerator()
					While enumerator1.MoveNext()
						Dim key1 As UnboundLambda.TargetSignature = enumerator1.Current.Key
						parameterTypes = key1.ParameterTypes
						Dim num2 As Integer = Math.Min(parameterTypes.Length, CInt(type.Length)) - 1
						Dim num3 As Integer = 0
						Do
							parameterTypes = key1.ParameterTypes
							Binder.BindLambdaForErrorRecoveryInferCommonType(type(num3), parameterTypes(num3))
							num3 = num3 + 1
						Loop While num3 <= num2
						Binder.BindLambdaForErrorRecoveryInferCommonType(key, key1.ReturnType)
					End While
				End Using
				Dim empty As BitVector = BitVector.Empty
				Dim length As Integer = CInt(type.Length) - 1
				Dim num4 As Integer = 0
				Do
					If (source.Parameters(num4).Type IsNot Nothing) Then
						parameters = source.Parameters
						type(num4) = parameters(num4).Type
					ElseIf (type(num4) Is Nothing OrElse CObj(type(num4)) = CObj(LambdaSymbol.ErrorRecoveryInferenceError)) Then
						type(num4) = Me.Compilation.GetSpecialType(SpecialType.System_Object)
					End If
					If (source.Parameters(num4).IsByRef) Then
						empty(num4) = True
					End If
					num4 = num4 + 1
				Loop While num4 <= length
				If (source.ReturnType IsNot Nothing) Then
					key = If(Not source.IsFunctionLambda OrElse Not source.ReturnType.IsVoidType(), source.ReturnType, LambdaSymbol.ReturnTypeVoidReplacement)
				ElseIf (key Is Nothing OrElse CObj(key) = CObj(LambdaSymbol.ErrorRecoveryInferenceError)) Then
					value = source.InferReturnType(New UnboundLambda.TargetSignature(Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of TypeSymbol)(type), empty, Me.Compilation.GetSpecialType(SpecialType.System_Void), False))
					key = value.Key
				End If
				Interlocked.CompareExchange(Of UnboundLambda.TargetSignature)(source.BindingCache.ErrorRecoverySignature, New UnboundLambda.TargetSignature(Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of TypeSymbol)(type), empty, key, False), Nothing)
			End If
			Return source.Bind(source.BindingCache.ErrorRecoverySignature)
		End Function

		Private Shared Sub BindLambdaForErrorRecoveryInferCommonType(ByRef result As TypeSymbol, ByVal candidate As TypeSymbol)
			If (result Is Nothing) Then
				result = candidate
				Return
			End If
			If (CObj(result) <> CObj(LambdaSymbol.ErrorRecoveryInferenceError) AndAlso Not result.IsSameTypeIgnoringAll(candidate)) Then
				result = LambdaSymbol.ErrorRecoveryInferenceError
			End If
		End Sub

		Private Function BindLateBoundInvocation(ByVal node As Microsoft.CodeAnalysis.SyntaxNode, ByVal group As BoundMethodOrPropertyGroup, ByVal isDefaultMemberAccess As Boolean, ByVal arguments As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression), ByVal argumentNames As ImmutableArray(Of String), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim syntaxNode As Microsoft.CodeAnalysis.SyntaxNode
			Dim memberName As String
			If (isDefaultMemberAccess) Then
				memberName = Nothing
			Else
				memberName = group.MemberName
			End If
			Dim str As String = memberName
			Dim boundTypeArgument As BoundTypeArguments = group.TypeArguments()
			Dim containerOfFirstInGroup As TypeSymbol = group.ContainerOfFirstInGroup
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Binder.AdjustReceiverAmbiguousTypeOrValue(group, diagnostics)
			If (boundExpression IsNot Nothing AndAlso (boundExpression.Kind = BoundKind.TypeExpression OrElse boundExpression.Kind = BoundKind.NamespaceExpression)) Then
				boundExpression = Nothing
			End If
			Dim invocationExpressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax = TryCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax)
			If (invocationExpressionSyntax Is Nothing) Then
				syntaxNode = node
			Else
				Dim expression As Microsoft.CodeAnalysis.SyntaxNode = invocationExpressionSyntax.Expression
				If (expression Is Nothing) Then
					expression = group.Syntax
				End If
				syntaxNode = expression
			End If
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindLateBoundMemberAccess(syntaxNode, str, boundTypeArgument, boundExpression, containerOfFirstInGroup, diagnostics, True)
			If (group.WasCompilerGenerated) Then
				boundExpression1.SetWasCompilerGenerated()
			End If
			If (boundExpression IsNot Nothing AndAlso boundExpression.Type IsNot Nothing AndAlso boundExpression.Type.IsInterfaceType()) Then
				Binder.ReportDiagnostic(diagnostics, Binder.GetLocationForOverloadResolutionDiagnostic(node, group), ERRID.ERR_LateBoundOverloadInterfaceCall1, New [Object]() { str })
			End If
			Return Me.BindLateBoundInvocation(node, group, boundExpression1, arguments, argumentNames, diagnostics, False)
		End Function

		Friend Function BindLateBoundInvocation(ByVal node As SyntaxNode, ByVal groupOpt As BoundMethodOrPropertyGroup, ByVal receiver As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal arguments As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression), ByVal argumentNames As ImmutableArray(Of String), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal suppressLateBindingResolutionDiagnostics As Boolean = False) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundLateInvocation As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			If (receiver.IsNothingLiteral()) Then
				Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_IllegalCallOrIndex)
				boundLateInvocation = Binder.BadExpression(node, arguments, ErrorTypeSymbol.UnknownResultType)
			ElseIf (Me.OptionStrict <> Microsoft.CodeAnalysis.VisualBasic.OptionStrict.[On]) Then
				If (Me.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.Custom AndAlso Not suppressLateBindingResolutionDiagnostics) Then
					Binder.ReportDiagnostic(diagnostics, Binder.GetLocationForOverloadResolutionDiagnostic(node, groupOpt), ERRID.WRN_LateBindingResolution)
				End If
				Dim flag As Boolean = If(receiver Is Nothing, False, receiver.Kind <> BoundKind.LateMemberAccess)
				Dim specialType As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Object, node, diagnostics)
				If (Not arguments.IsEmpty) Then
					Me.CheckNamedArgumentsForLateboundInvocation(argumentNames, arguments, diagnostics)
					Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = Nothing
					Dim length As Integer = arguments.Length - 1
					Dim num As Integer = 0
					Do
						Dim item As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = arguments(num)
						Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = item
						If (boundExpression.Kind = BoundKind.OmittedArgument) Then
							boundExpression = DirectCast(boundExpression, BoundOmittedArgument).Update(Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Object, boundExpression.Syntax, diagnostics))
						End If
						Dim num1 As Integer = If(flag, False, boundExpression.IsSupportingAssignment())
						If (flag OrElse Not boundExpression.IsSupportingAssignment()) Then
							boundExpression = Me.ApplyImplicitConversion(boundExpression.Syntax, specialType, boundExpression, diagnostics, False)
						End If
						If (instance IsNot Nothing) Then
							instance.Add(boundExpression)
						ElseIf (boundExpression <> item) Then
							instance = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance(arguments.Length)
							Dim num2 As Integer = num - 1
							Dim num3 As Integer = 0
							Do
								instance.Add(arguments(num3))
								num3 = num3 + 1
							Loop While num3 <= num2
							instance.Add(boundExpression)
						End If
						num = num + 1
					Loop While num <= length
					If (instance IsNot Nothing) Then
						arguments = instance.ToImmutableAndFree()
					End If
				End If
				If (receiver IsNot Nothing AndAlso receiver.Kind = BoundKind.MeReference AndAlso (Me.IsMeOrMyBaseOrMyClassInSharedContext() OrElse Me.IsInsideChainedConstructorCallArguments)) Then
					receiver = Nothing
				End If
				If (receiver IsNot Nothing AndAlso Not receiver.IsLValue AndAlso receiver.Kind <> BoundKind.LateMemberAccess) Then
					receiver = Me.MakeRValue(receiver, diagnostics)
				End If
				Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Object, node, diagnostics)
				boundLateInvocation = New Microsoft.CodeAnalysis.VisualBasic.BoundLateInvocation(node, receiver, arguments, argumentNames, LateBoundAccessKind.Unknown, groupOpt, namedTypeSymbol, False)
			Else
				Binder.ReportDiagnostic(diagnostics, Binder.GetLocationForOverloadResolutionDiagnostic(node, groupOpt), ERRID.ERR_StrictDisallowsLateBinding)
				Dim boundExpressions As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance()
				If (receiver IsNot Nothing) Then
					boundExpressions.Add(receiver)
				End If
				If (Not arguments.IsEmpty) Then
					boundExpressions.AddRange(arguments)
				End If
				boundLateInvocation = Binder.BadExpression(node, boundExpressions.ToImmutableAndFree(), ErrorTypeSymbol.UnknownResultType)
			End If
			Return boundLateInvocation
		End Function

		Private Function BindLateBoundMemberAccess(ByVal node As SyntaxNode, ByVal name As String, ByVal typeArguments As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax, ByVal receiver As BoundExpression, ByVal containerType As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim boundTypeArgument As BoundTypeArguments = Me.BindTypeArguments(typeArguments, diagnostics)
			Return Me.BindLateBoundMemberAccess(node, name, boundTypeArgument, receiver, containerType, diagnostics, False)
		End Function

		Private Function BindLateBoundMemberAccess(ByVal node As SyntaxNode, ByVal name As String, ByVal boundTypeArguments As Microsoft.CodeAnalysis.VisualBasic.BoundTypeArguments, ByVal receiver As BoundExpression, ByVal containerType As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal suppressLateBindingResolutionDiagnostics As Boolean = False) As BoundExpression
			Dim boundLateMemberAccess As BoundExpression
			receiver = Binder.AdjustReceiverAmbiguousTypeOrValue(receiver, diagnostics)
			If (Me.OptionStrict <> Microsoft.CodeAnalysis.VisualBasic.OptionStrict.[On]) Then
				If (Me.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.Custom AndAlso Not suppressLateBindingResolutionDiagnostics) Then
					Binder.ReportDiagnostic(diagnostics, node, ERRID.WRN_LateBindingResolution)
				End If
				Dim specialType As NamedTypeSymbol = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Object, node, diagnostics)
				If (receiver IsNot Nothing AndAlso receiver.Kind = BoundKind.MeReference AndAlso (Me.IsMeOrMyBaseOrMyClassInSharedContext() OrElse Me.IsInsideChainedConstructorCallArguments)) Then
					receiver = Nothing
				End If
				If (receiver IsNot Nothing AndAlso Not receiver.IsLValue) Then
					receiver = Me.MakeRValue(receiver, diagnostics)
				End If
				boundLateMemberAccess = New Microsoft.CodeAnalysis.VisualBasic.BoundLateMemberAccess(node, name, containerType, receiver, boundTypeArguments, LateBoundAccessKind.Unknown, specialType, False)
			Else
				If (Not suppressLateBindingResolutionDiagnostics) Then
					Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_StrictDisallowsLateBinding)
				End If
				Dim instance As ArrayBuilder(Of BoundExpression) = ArrayBuilder(Of BoundExpression).GetInstance()
				If (receiver IsNot Nothing) Then
					instance.Add(receiver)
				End If
				If (boundTypeArguments IsNot Nothing) Then
					instance.Add(boundTypeArguments)
				End If
				boundLateMemberAccess = Binder.BadExpression(node, instance.ToImmutableAndFree(), ErrorTypeSymbol.UnknownResultType)
			End If
			Return boundLateMemberAccess
		End Function

		Private Function BindLeftOfPotentialColorColorMemberAccess(ByVal parentNode As Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax, ByVal leftOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundTypeOrValueExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim type As TypeSymbol
			Dim isShared As Boolean
			If (leftOpt.Kind() <> SyntaxKind.IdentifierName) Then
				boundTypeOrValueExpression = If(leftOpt.Kind() <> SyntaxKind.SimpleMemberAccessExpression, Me.BindExpression(leftOpt, diagnostics), Me.BindMemberAccess(DirectCast(leftOpt, Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax), False, diagnostics))
			Else
				Dim simpleNameSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax = DirectCast(leftOpt, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax)
				Dim instance As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.GetInstance(diagnostics)
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindSimpleName(simpleNameSyntax, False, instance, False)
				Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = boundExpression
				Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Nothing
				If (boundExpression.Kind = BoundKind.PropertyGroup) Then
					bindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.GetInstance(diagnostics)
					boundExpression1 = Me.AdjustReceiverValue(boundExpression, simpleNameSyntax, bindingDiagnosticBag)
				End If
				Dim expressionSymbol As Symbol = boundExpression1.ExpressionSymbol
				If (expressionSymbol IsNot Nothing) Then
					Dim kind As SymbolKind = expressionSymbol.Kind
					If (kind <> SymbolKind.Field) Then
						If (kind <> SymbolKind.Local) Then
							Select Case kind
								Case SymbolKind.Parameter
								Case SymbolKind.RangeVariable
									Exit Select
								Case SymbolKind.PointerType
								Label3:
									type = Nothing
									isShared = False
									GoTo Label1
								Case SymbolKind.[Property]
									GoTo Label2
								Case Else
									GoTo Label3
							End Select
						End If
						type = boundExpression1.Type
						isShared = False
						GoTo Label1
					End If
				Label2:
					type = boundExpression1.Type
					isShared = Not expressionSymbol.IsShared
				Label1:
					If (type IsNot Nothing) Then
						Dim valueText As String = simpleNameSyntax.Identifier.ValueText
						If (CaseInsensitiveComparison.Equals(type.Name, valueText) AndAlso type.TypeKind <> Microsoft.CodeAnalysis.TypeKind.TypeParameter) Then
							Dim bindingDiagnosticBag1 As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Create(diagnostics)
							Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindNamespaceOrTypeExpression(simpleNameSyntax, bindingDiagnosticBag1)
							If (Not TypeSymbol.Equals(boundExpression2.Type, type, TypeCompareKind.ConsiderEverything)) Then
								GoTo Label4
							End If
							Dim eRRID As Microsoft.CodeAnalysis.VisualBasic.ERRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_None
							If (Not isShared OrElse Me.CanAccessMe(True, eRRID) AndAlso Binder.BindSimpleNameIsMemberOfType(expressionSymbol, Me.ContainingType)) Then
								Dim bindingDiagnosticBag2 As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Create(diagnostics)
								bindingDiagnosticBag2.AddRangeAndFree(instance)
								If (bindingDiagnosticBag IsNot Nothing) Then
									bindingDiagnosticBag2.AddRangeAndFree(bindingDiagnosticBag)
								End If
								boundTypeOrValueExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundTypeOrValueExpression(leftOpt, New BoundTypeOrValueData(boundExpression1, bindingDiagnosticBag2, boundExpression2, bindingDiagnosticBag1), type)
								Return boundTypeOrValueExpression
							Else
								diagnostics.AddRange(bindingDiagnosticBag1, False)
								instance.Free()
								boundTypeOrValueExpression = boundExpression2
								Return boundTypeOrValueExpression
							End If
						End If
					End If
				End If
			Label4:
				If (bindingDiagnosticBag IsNot Nothing) Then
					bindingDiagnosticBag.Free()
				End If
				diagnostics.AddRangeAndFree(instance)
				boundTypeOrValueExpression = boundExpression
			End If
			Return boundTypeOrValueExpression
		End Function

		Private Function BindLetClause(ByVal source As BoundQueryClauseBase, ByVal clauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax, ByVal operatorsEnumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal skipFirstVariable As Boolean = False) As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClause
			Dim boundQueryClause As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClause
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim textSpan As Microsoft.CodeAnalysis.Text.TextSpan
			Dim num As Integer
			Dim discarded As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
			Dim variables As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax) = clauseSyntax.Variables
			If (variables.Count <> 0) Then
				num = If(skipFirstVariable, 1, 0)
				Dim count As Integer = variables.Count - 1
				Dim num1 As Integer = num
				Do
					Dim item As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax = variables(num1)
					Dim boundLambdaParameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol = Me.CreateQueryLambdaParameterSymbol(Binder.GetQueryLambdaParameterName(source.RangeVariables), 0, source.CompoundVariableType, item, source.RangeVariables)
					Dim synthesizedLambdaSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaSymbol = Me.CreateQueryLambdaSymbol(LambdaUtilities.GetLetVariableLambdaBody(item), SynthesizedLambdaKind.LetVariableQueryLambda, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol)(boundLambdaParameterSymbol))
					Dim queryLambdaBinder As Binder.QueryLambdaBinder = New Binder.QueryLambdaBinder(synthesizedLambdaSymbol, source.RangeVariables)
					Dim rangeVariableSymbols As ImmutableArray(Of RangeVariableSymbol) = New ImmutableArray(Of RangeVariableSymbol)()
					Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = queryLambdaBinder.BindLetClauseVariableSelector(item, operatorsEnumerator, rangeVariableSymbols, diagnostics)
					Dim boundQueryLambda As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Binder.CreateBoundQueryLambda(synthesizedLambdaSymbol, source.RangeVariables, boundExpression1, False)
					synthesizedLambdaSymbol.SetQueryLambdaReturnType(boundExpression1.Type)
					boundQueryLambda.SetWasCompilerGenerated()
					If (Not source.Type.IsErrorType()) Then
						If (discarded <> Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded AndAlso Binder.ShouldSuppressDiagnostics(boundQueryLambda)) Then
							discarded = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
						End If
						textSpan = If(num1 <> 0, variables.GetSeparator(num1 - 1).Span, clauseSyntax.LetKeyword.Span)
						boundExpression = Me.BindQueryOperatorCall(item, source, "Select", ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundQueryLambda), textSpan, discarded)
					Else
						boundExpression = Binder.BadExpression(item, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(source, boundQueryLambda), ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
					End If
					source = New Microsoft.CodeAnalysis.VisualBasic.BoundQueryClause(item, boundExpression, Microsoft.CodeAnalysis.ImmutableArrayExtensions.Concat(Of RangeVariableSymbol)(source.RangeVariables, rangeVariableSymbols), boundQueryLambda.Expression.Type, ImmutableArray.Create(Of Binder)(queryLambdaBinder), boundExpression.Type, False)
					num1 = num1 + 1
				Loop While num1 <= count
				boundQueryClause = DirectCast(source, Microsoft.CodeAnalysis.VisualBasic.BoundQueryClause)
			Else
				Dim boundBadExpression As Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression = Binder.BadExpression(clauseSyntax, source, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
				Dim rangeVariables As ImmutableArray(Of RangeVariableSymbol) = source.RangeVariables
				boundQueryClause = New Microsoft.CodeAnalysis.VisualBasic.BoundQueryClause(clauseSyntax, boundBadExpression, rangeVariables.Add(RangeVariableSymbol.CreateForErrorRecovery(Me, clauseSyntax, ErrorTypeSymbol.UnknownResultType)), ErrorTypeSymbol.UnknownResultType, ImmutableArray.Create(Of Binder)(Me), ErrorTypeSymbol.UnknownResultType, True)
			End If
			Return boundQueryClause
		End Function

		Private Function BindLiteralConstant(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundLiteral
			Dim null As ConstantValue
			Dim objectValue As Object = RuntimeHelpers.GetObjectValue(node.Token.Value)
			Dim specialType As TypeSymbol = Nothing
			If (objectValue IsNot Nothing) Then
				Dim specialType1 As Microsoft.CodeAnalysis.SpecialType = Microsoft.CodeAnalysis.SpecialTypeExtensions.FromRuntimeTypeOfLiteralValue(RuntimeHelpers.GetObjectValue(objectValue))
				null = ConstantValue.Create(RuntimeHelpers.GetObjectValue(objectValue), specialType1)
				specialType = Me.GetSpecialType(specialType1, node, diagnostics)
			Else
				null = ConstantValue.Null
			End If
			Return New BoundLiteral(node, null, specialType)
		End Function

		Friend Function BindLocalConstantInitializer(ByVal symbol As LocalSymbol, ByVal type As TypeSymbol, ByVal name As Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax, ByVal equalsValueOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, <Out> ByRef constValue As ConstantValue) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			constValue = Nothing
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			If (equalsValueOpt Is Nothing) Then
				boundExpression1 = Binder.BadExpression(name, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
				Binder.ReportDiagnostic(diagnostics, name, ERRID.ERR_ConstantWithNoValue)
			Else
				Dim value As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = equalsValueOpt.Value
				If (Not Me.IsBindingImplicitlyTypedLocal(symbol)) Then
					Dim localInProgressBinder As Microsoft.CodeAnalysis.VisualBasic.LocalInProgressBinder = New Microsoft.CodeAnalysis.VisualBasic.LocalInProgressBinder(Me, symbol)
					boundExpression1 = localInProgressBinder.BindValue(value, diagnostics, False)
					If (type IsNot Nothing) Then
						boundExpression1 = localInProgressBinder.ApplyImplicitConversion(value, type, boundExpression1, diagnostics, False)
					End If
					If (boundExpression1.HasErrors) Then
						boundExpression = boundExpression1
						Return boundExpression
					End If
					If (boundExpression1.Type Is Nothing OrElse Not boundExpression1.Type.IsErrorType()) Then
						constValue = localInProgressBinder.GetExpressionConstantValueIfAny(boundExpression1, diagnostics, Binder.ConstantContext.[Default])
						If (constValue Is Nothing) Then
							boundExpression = Binder.BadExpression(value, boundExpression1, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
							Return boundExpression
						End If
						boundExpression = boundExpression1
						Return boundExpression
					End If
					boundExpression = Binder.BadExpression(value, boundExpression1, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
					Return boundExpression
				Else
					Binder.ReportDiagnostic(diagnostics, name, ERRID.ERR_CircularEvaluation1, New [Object]() { symbol })
					boundExpression = Binder.BadExpression(value, ErrorTypeSymbol.UnknownResultType)
					Return boundExpression
				End If
			End If
			boundExpression = boundExpression1
			Return boundExpression
		End Function

		Private Function BindLocalDeclaration(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.LocalDeclarationStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Me.DecodeLocalModifiersAndReportErrors(node.Modifiers, diagnostics)
			Dim boundLocalDeclarationBases As ImmutableArray(Of BoundLocalDeclarationBase) = Me.BindVariableDeclarators(node.Declarators, diagnostics)
			Return New BoundDimStatement(node, boundLocalDeclarationBases, Nothing, False)
		End Function

		Private Function BindMeExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.MeExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundMeReference
			Dim boundMeReference As Microsoft.CodeAnalysis.VisualBasic.BoundMeReference
			Dim eRRID As Microsoft.CodeAnalysis.VisualBasic.ERRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_None
			If (Me.CanAccessMe(False, eRRID)) Then
				boundMeReference = Me.CreateMeReference(node, False)
			Else
				Binder.ReportDiagnostic(diagnostics, node, eRRID, New [Object]() { SyntaxFacts.GetText(node.Keyword.Kind()) })
				Dim meExpressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.MeExpressionSyntax = node
				Dim containingType As Object = Me.ContainingType
				If (containingType Is Nothing) Then
					containingType = ErrorTypeSymbol.UnknownResultType
				End If
				boundMeReference = New Microsoft.CodeAnalysis.VisualBasic.BoundMeReference(meExpressionSyntax, containingType, True)
			End If
			Return boundMeReference
		End Function

		Private Function BindMemberAccess(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax, ByVal eventContext As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim expression As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = node.Expression
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim name As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax = node.Name
			If (expression IsNot Nothing) Then
				boundExpression1 = Me.BindLeftOfPotentialColorColorMemberAccess(node, expression, diagnostics)
			Else
				Dim flag As Boolean = False
				Dim correspondingConditionalAccessExpression As Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax = node.GetCorrespondingConditionalAccessExpression()
				boundExpression1 = If(correspondingConditionalAccessExpression Is Nothing, Me.TryBindOmittedLeftForMemberAccess(node, diagnostics, Me, flag), Me.GetConditionalAccessReceiver(correspondingConditionalAccessExpression))
				If (boundExpression1 IsNot Nothing) Then
					If (Not flag) Then
						boundExpression = Me.BindMemberAccess(node, boundExpression1, name, eventContext, diagnostics)
						Return boundExpression
					End If
					boundExpression = boundExpression1
					Return boundExpression
				Else
					boundExpression = Binder.ReportDiagnosticAndProduceBadExpression(diagnostics, node, ERRID.ERR_BadWithRef)
					Return boundExpression
				End If
			End If
			boundExpression = Me.BindMemberAccess(node, boundExpression1, name, eventContext, diagnostics)
			Return boundExpression
		End Function

		Protected Function BindMemberAccess(ByVal node As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal left As BoundExpression, ByVal right As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax, ByVal eventContext As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim boundMethodGroup As BoundExpression
			Dim type As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim valueText As String
			Dim typeArgumentList As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax
			Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = left.Type
			If (typeSymbol IsNot Nothing AndAlso (right.Kind() = SyntaxKind.IdentifierName OrElse right.Kind() = SyntaxKind.GenericName)) Then
				Dim syntaxToken As Microsoft.CodeAnalysis.SyntaxToken = If(right.Kind() = SyntaxKind.IdentifierName, DirectCast(right, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax).Identifier, DirectCast(right, Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax).Identifier)
				If (Not syntaxToken.IsBracketed() AndAlso CaseInsensitiveComparison.Equals(syntaxToken.ValueText, SyntaxFacts.GetText(SyntaxKind.NewKeyword))) Then
					If (Not typeSymbol.IsArrayType()) Then
						Dim typeKind As Microsoft.CodeAnalysis.TypeKind = typeSymbol.TypeKind
						If (typeKind <> Microsoft.CodeAnalysis.TypeKind.[Class] AndAlso typeKind <> Microsoft.CodeAnalysis.TypeKind.Struct AndAlso typeKind <> Microsoft.CodeAnalysis.TypeKind.[Module]) Then
							GoTo Label1
						End If
						Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = DirectCast(typeSymbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)
						Dim accessibleConstructors As ImmutableArray(Of MethodSymbol) = Me.GetAccessibleConstructors(namedTypeSymbol, newCompoundUseSiteInfo)
						diagnostics.Add(node, newCompoundUseSiteInfo)
						newCompoundUseSiteInfo = New CompoundUseSiteInfo(Of AssemblySymbol)(newCompoundUseSiteInfo)
						If (Not accessibleConstructors.IsEmpty) Then
							Dim hasErrors As Boolean = left.HasErrors
							If (Not hasErrors AndAlso right.Kind() = SyntaxKind.GenericName) Then
								Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_InvalidConstructorCall)
								hasErrors = True
							End If
							boundMethodGroup = New Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup(node, Nothing, accessibleConstructors, LookupResultKind.Good, left, If(left.Kind = BoundKind.TypeExpression, QualificationKind.QualifiedViaTypeName, QualificationKind.QualifiedViaValue), hasErrors)
							Return boundMethodGroup
						ElseIf (Not left.HasErrors) Then
							boundMethodGroup = Binder.ReportDiagnosticAndProduceBadExpression(diagnostics, node, ErrorFactory.ErrorInfo(ERRID.ERR_ConstructorNotFound1, New [Object]() { namedTypeSymbol }), New BoundExpression() { left })
							Return boundMethodGroup
						Else
							boundMethodGroup = Binder.BadExpression(node, left, ErrorTypeSymbol.UnknownResultType)
							Return boundMethodGroup
						End If
					ElseIf (Not left.HasErrors) Then
						boundMethodGroup = Binder.ReportDiagnosticAndProduceBadExpression(diagnostics, node, ErrorFactory.ErrorInfo(ERRID.ERR_ConstructorNotFound1, New [Object]() { typeSymbol }), New BoundExpression() { left })
						Return boundMethodGroup
					Else
						boundMethodGroup = Binder.BadExpression(node, left, ErrorTypeSymbol.UnknownResultType)
						Return boundMethodGroup
					End If
				End If
			End If
		Label1:
			If (right.Kind() <> SyntaxKind.GenericName) Then
				typeArgumentList = Nothing
				valueText = DirectCast(right, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax).Identifier.ValueText
			Else
				Dim genericNameSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax = DirectCast(right, Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax)
				typeArgumentList = genericNameSyntax.TypeArgumentList
				valueText = genericNameSyntax.Identifier.ValueText
			End If
			Dim num As Integer = If(typeArgumentList IsNot Nothing, typeArgumentList.Arguments.Count, 0)
			Dim instance As LookupResult = LookupResult.GetInstance()
			Dim lookupOption As LookupOptions = LookupOptions.AllMethodsOfAnyArity
			Try
				If (left.Kind = BoundKind.NamespaceExpression) Then
					If (Not [String].IsNullOrEmpty(valueText)) Then
						Dim namespaceSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol = DirectCast(left, BoundNamespaceExpression).NamespaceSymbol
						If (right.Kind() = SyntaxKind.IdentifierName AndAlso node.Kind() = SyntaxKind.SimpleMemberAccessExpression) Then
							lookupOption = lookupOption Or LookupOptions.AllowIntrinsicAliases
						End If
						Binder.MemberLookup.Lookup(instance, namespaceSymbol, valueText, num, lookupOption, Me, newCompoundUseSiteInfo)
						boundMethodGroup = If(Not instance.HasSymbol, Binder.ReportDiagnosticAndProduceBadExpression(diagnostics, node, ErrorFactory.ErrorInfo(ERRID.ERR_NameNotMember2, New [Object]() { valueText, namespaceSymbol }), New BoundExpression() { left }), Me.BindSymbolAccess(node, instance, lookupOption, left, typeArgumentList, QualificationKind.QualifiedViaNamespace, diagnostics))
					Else
						boundMethodGroup = Binder.BadExpression(node, left, ErrorTypeSymbol.UnknownResultType)
					End If
				ElseIf (left.Kind <> BoundKind.TypeExpression) Then
					left = Me.AdjustReceiverValue(left, node, diagnostics)
					type = left.Type
					If (type Is Nothing OrElse type.IsErrorType()) Then
						boundMethodGroup = Binder.BadExpression(node, left, ErrorTypeSymbol.UnknownResultType)
					ElseIf (Not [String].IsNullOrEmpty(valueText)) Then
						Dim lookupOption1 As LookupOptions = If(left.Kind <> BoundKind.MyBaseReference, lookupOption, lookupOption Or LookupOptions.UseBaseReferenceAccessibility)
						If (eventContext) Then
							lookupOption1 = lookupOption1 Or LookupOptions.EventsOnly
						End If
						Me.LookupMember(instance, type, valueText, num, lookupOption1, newCompoundUseSiteInfo)
						If (instance.HasSymbol) Then
							boundMethodGroup = Me.BindSymbolAccess(node, instance, lookupOption1, left, typeArgumentList, QualificationKind.QualifiedViaValue, diagnostics)
						ElseIf (type.IsObjectType() AndAlso Not left.IsMyBaseReference() OrElse type.IsExtensibleInterfaceNoUseSiteDiagnostics()) Then
							boundMethodGroup = Me.BindLateBoundMemberAccess(node, valueText, typeArgumentList, left, type, diagnostics)
						ElseIf (Not left.HasErrors) Then
							If (type.IsInterfaceType()) Then
								type.AllInterfacesWithDefinitionUseSiteDiagnostics(newCompoundUseSiteInfo)
							End If
							boundMethodGroup = Binder.ReportDiagnosticAndProduceBadExpression(diagnostics, node, ErrorFactory.ErrorInfo(ERRID.ERR_NameNotMember2, New [Object]() { valueText, type }), New BoundExpression() { left })
						Else
							boundMethodGroup = Binder.BadExpression(node, left, ErrorTypeSymbol.UnknownResultType)
						End If
					Else
						boundMethodGroup = Binder.BadExpression(node, left, ErrorTypeSymbol.UnknownResultType)
					End If
				Else
					type = DirectCast(left, BoundTypeExpression).Type
					If (type.TypeKind = Microsoft.CodeAnalysis.TypeKind.TypeParameter) Then
						boundMethodGroup = Binder.ReportDiagnosticAndProduceBadExpression(diagnostics, node, ErrorFactory.ErrorInfo(ERRID.ERR_TypeParamQualifierDisallowed), New BoundExpression() { left })
					ElseIf (Not [String].IsNullOrEmpty(valueText)) Then
						Me.LookupMember(instance, type, valueText, num, lookupOption, newCompoundUseSiteInfo)
						boundMethodGroup = If(Not instance.HasSymbol, Binder.ReportDiagnosticAndProduceBadExpression(diagnostics, node, ErrorFactory.ErrorInfo(ERRID.ERR_NameNotMember2, New [Object]() { valueText, type }), New BoundExpression() { left }), Me.BindSymbolAccess(node, instance, lookupOption, left, typeArgumentList, QualificationKind.QualifiedViaTypeName, diagnostics))
					Else
						boundMethodGroup = Binder.BadExpression(node, left, ErrorTypeSymbol.UnknownResultType)
					End If
				End If
			Finally
				diagnostics.Add(node, newCompoundUseSiteInfo)
				instance.Free()
			End Try
			Return boundMethodGroup
		End Function

		Private Function BindMethodBlock(ByVal methodBlock As Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundBlock
			Dim localForFunctionValue As LocalSymbol
			Dim flag As Boolean
			Dim flag1 As Boolean
			Dim flag2 As Boolean
			Dim flag3 As Boolean
			Dim flag4 As Boolean
			Dim flag5 As Boolean
			Dim statements As ImmutableArray(Of BoundStatement)
			Dim instance As ArrayBuilder(Of BoundStatement) = ArrayBuilder(Of BoundStatement).GetInstance()
			Dim empty As ImmutableArray(Of LocalSymbol) = ImmutableArray(Of LocalSymbol).Empty
			Dim containingMember As MethodSymbol = DirectCast(Me.ContainingMember, MethodSymbol)
			If (containingMember.IsIterator OrElse containingMember.IsAsync AndAlso containingMember.ReturnType.Equals(Me.Compilation.GetWellKnownType(WellKnownType.System_Threading_Tasks_Task))) Then
				localForFunctionValue = Nothing
			Else
				localForFunctionValue = Me.GetLocalForFunctionValue()
			End If
			If (localForFunctionValue IsNot Nothing) Then
				Dim boundLocalDeclaration As Microsoft.CodeAnalysis.VisualBasic.BoundLocalDeclaration = New Microsoft.CodeAnalysis.VisualBasic.BoundLocalDeclaration(methodBlock.BlockStatement, localForFunctionValue, Nothing)
				boundLocalDeclaration.SetWasCompilerGenerated()
				instance.Add(boundLocalDeclaration)
			End If
			Dim binder As Microsoft.CodeAnalysis.VisualBasic.Binder = Me.GetBinder(methodBlock)
			Dim boundBlock As Microsoft.CodeAnalysis.VisualBasic.BoundBlock = binder.BindBlock(methodBlock, methodBlock.Statements, diagnostics)
			Dim boundLabelStatement As Microsoft.CodeAnalysis.VisualBasic.BoundLabelStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundLabelStatement(methodBlock.EndBlockStatement, binder.GetReturnLabel())
			If (boundBlock Is Nothing) Then
				instance.Add(boundLabelStatement)
			Else
				Dim statementSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax = Nothing
				Microsoft.CodeAnalysis.VisualBasic.Binder.CheckOnErrorAndAwaitWalker.VisitBlock(binder, boundBlock, diagnostics, flag, flag1, flag2, statementSyntax, flag3, flag4, flag5)
				If (binder.IsInAsyncContext() AndAlso Not binder.IsInIteratorContext() AndAlso Not flag AndAlso Not boundBlock.HasErrors AndAlso TypeOf methodBlock.BlockStatement Is Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax) Then
					Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagnostics, DirectCast(methodBlock.BlockStatement, Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax).Identifier, ERRID.WRN_AsyncLacksAwaits)
				End If
				If (flag5 OrElse Not flag1 AndAlso Not flag2 AndAlso (Not flag4 OrElse Not flag3)) Then
					empty = boundBlock.Locals
					instance.AddRange(boundBlock.Statements)
					instance.Add(boundLabelStatement)
				Else
					If (containingMember.MethodKind = MethodKind.Constructor) Then
						Dim flag6 As Boolean = False
						If (InitializerRewriter.HasExplicitMeConstructorCall(boundBlock, Me.ContainingMember.ContainingType, flag6) OrElse flag6) Then
							statements = boundBlock.Statements
							instance.Add(statements(0))
							Dim statementListSyntax As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax) = boundBlock.StatementListSyntax
							Dim locals As ImmutableArray(Of LocalSymbol) = boundBlock.Locals
							statements = boundBlock.Statements
							boundBlock = boundBlock.Update(statementListSyntax, locals, statements.RemoveAt(0))
						End If
					End If
					Dim statementSyntaxes As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax) = boundBlock.StatementListSyntax
					Dim localSymbols As ImmutableArray(Of LocalSymbol) = boundBlock.Locals
					statements = boundBlock.Statements
					boundBlock = boundBlock.Update(statementSyntaxes, localSymbols, statements.Add(boundLabelStatement))
					instance.Add((New BoundUnstructuredExceptionHandlingStatement(methodBlock, flag1, flag2, statementSyntax, flag3, boundBlock.MakeCompilerGenerated(), False)).MakeCompilerGenerated())
				End If
				Me.DisallowFurtherImplicitVariableDeclaration(diagnostics)
				Dim implicitlyDeclaredVariables As ImmutableArray(Of LocalSymbol) = Me.ImplicitlyDeclaredVariables
				If (implicitlyDeclaredVariables.Length > 0) Then
					empty = If(Not empty.IsEmpty, Microsoft.CodeAnalysis.ImmutableArrayExtensions.Concat(Of LocalSymbol)(implicitlyDeclaredVariables, empty), implicitlyDeclaredVariables)
				End If
				Microsoft.CodeAnalysis.VisualBasic.Binder.ReportNameConfictsBetweenStaticLocals(binder, diagnostics)
			End If
			If (localForFunctionValue Is Nothing) Then
				instance.Add(New BoundReturnStatement(methodBlock.EndBlockStatement, Nothing, Nothing, Nothing, False))
			Else
				If (Not empty.IsEmpty) Then
					Dim instance1 As ArrayBuilder(Of LocalSymbol) = ArrayBuilder(Of LocalSymbol).GetInstance()
					instance1.Add(localForFunctionValue)
					instance1.AddRange(empty)
					empty = instance1.ToImmutableAndFree()
				Else
					empty = ImmutableArray.Create(Of LocalSymbol)(localForFunctionValue)
				End If
				instance.Add(New BoundReturnStatement(methodBlock.EndBlockStatement, (New BoundLocal(methodBlock.EndBlockStatement, localForFunctionValue, False, localForFunctionValue.Type)).MakeCompilerGenerated(), Nothing, Nothing, False))
			End If
			Return New Microsoft.CodeAnalysis.VisualBasic.BoundBlock(methodBlock, If(methodBlock IsNot Nothing, methodBlock.Statements, New SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)()), empty, instance.ToImmutableAndFree(), False)
		End Function

		Private Function BindMidAssignmentStatement(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpressionStatement
			Dim hasErrors As Boolean = False
			Dim boundCompoundAssignmentTargetPlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundCompoundAssignmentTargetPlaceholder
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim left As Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax = DirectCast(node.Left, Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax)
			Dim arguments As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax) = left.ArgumentList.Arguments
			Dim expression As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = DirectCast(arguments(0), Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax).Expression
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindAssignmentTarget(expression, diagnostics)
			Dim specialType As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Int32, left, diagnostics)
			Dim expressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = DirectCast(arguments(1), Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax).Expression
			Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.ApplyImplicitConversion(expressionSyntax, specialType, Me.BindValue(expressionSyntax, diagnostics, False), diagnostics, False)
			Dim boundExpression3 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			If (arguments.Count > 2) Then
				Dim expression1 As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = DirectCast(arguments(2), Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax).Expression
				boundExpression3 = Me.ApplyImplicitConversion(expression1, specialType, Me.BindValue(expression1, diagnostics, False), diagnostics, False)
			End If
			Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_String, left, diagnostics)
			Binder.VerifyTypeCharacterConsistency(left.Mid, namedTypeSymbol, left.Mid.GetTypeCharacter(), diagnostics)
			Dim boundExpression4 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.ApplyImplicitConversion(node.Right, namedTypeSymbol, Me.BindValue(node.Right, diagnostics, False), diagnostics, False)
			Dim boundExpression5 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.AdjustAssignmentTarget(expression, boundExpression1, diagnostics, hasErrors)
			If (Not hasErrors) Then
				hasErrors = Me.MakeRValue(boundExpression1, diagnostics).HasErrors
			End If
			Dim type As TypeSymbol = boundExpression5.Type
			If (hasErrors) Then
				boundCompoundAssignmentTargetPlaceholder = Nothing
				boundExpression = Binder.BadExpression(expression, namedTypeSymbol).MakeCompilerGenerated()
			Else
				boundCompoundAssignmentTargetPlaceholder = (New Microsoft.CodeAnalysis.VisualBasic.BoundCompoundAssignmentTargetPlaceholder(expression, type)).MakeCompilerGenerated()
				boundExpression = Me.ApplyImplicitConversion(expression, namedTypeSymbol, boundCompoundAssignmentTargetPlaceholder, diagnostics, False)
			End If
			Dim boundExpression6 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = (New BoundMidResult(node, New BoundParenthesized(left, boundExpression, boundExpression.Type, False), boundExpression2, boundExpression3, boundExpression4, namedTypeSymbol, False)).MakeCompilerGenerated()
			If (Not hasErrors) Then
				boundExpression6 = Me.ApplyImplicitConversion(node, type, boundExpression6, diagnostics, False).MakeCompilerGenerated()
			End If
			boundExpression1 = boundExpression1.SetGetSetAccessKindIfAppropriate()
			Return New BoundExpressionStatement(node, (New BoundAssignmentOperator(node, boundExpression1, boundCompoundAssignmentTargetPlaceholder, boundExpression6, False, Me.Compilation.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Void), hasErrors)).MakeCompilerGenerated(), False)
		End Function

		Private Function BindMultiLineIfBlock(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineIfBlockSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim item As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode
			Dim instance As ArrayBuilder(Of BoundStatement) = ArrayBuilder(Of BoundStatement).GetInstance()
			Dim boundExpressions As ArrayBuilder(Of BoundExpression) = ArrayBuilder(Of BoundExpression).GetInstance()
			boundExpressions.Add(Me.BindBooleanExpression(node.IfStatement.Condition, diagnostics))
			instance.Add(Me.BindBlock(node, node.Statements, diagnostics).MakeCompilerGenerated())
			Dim elseIfBlocks As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfBlockSyntax) = node.ElseIfBlocks
			Dim count As Integer = elseIfBlocks.Count - 1
			Dim num As Integer = 0
			Do
				Dim elseIfBlockSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfBlockSyntax = node.ElseIfBlocks(num)
				boundExpressions.Add(Me.BindBooleanExpression(elseIfBlockSyntax.ElseIfStatement.Condition, diagnostics))
				instance.Add(Me.BindBlock(elseIfBlockSyntax, elseIfBlockSyntax.Statements, diagnostics).MakeCompilerGenerated())
				num = num + 1
			Loop While num <= count
			Dim boundIfStatement As BoundStatement = Nothing
			If (node.ElseBlock IsNot Nothing) Then
				boundIfStatement = Me.BindBlock(node.ElseBlock, node.ElseBlock.Statements, diagnostics)
			End If
			For i As Integer = boundExpressions.Count - 1 To 0 Step -1
				If (i <> 0) Then
					elseIfBlocks = node.ElseIfBlocks
					item = elseIfBlocks(i - 1)
				Else
					item = node
				End If
				boundIfStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundIfStatement(item, boundExpressions(i), instance(i), boundIfStatement, False)
			Next

			instance.Free()
			boundExpressions.Free()
			Return boundIfStatement
		End Function

		Private Function BindMyBaseExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.MyBaseExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundMyBaseReference
			Dim boundMyBaseReference As Microsoft.CodeAnalysis.VisualBasic.BoundMyBaseReference
			Dim baseTypeNoUseSiteDiagnostics As TypeSymbol
			Dim unknownResultType As TypeSymbol
			Dim eRRID As Microsoft.CodeAnalysis.VisualBasic.ERRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_None
			If (Me.CanAccessMyBase(False, eRRID)) Then
				Dim containingMember As Symbol = Me.ContainingMember
				Dim myBaseExpressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.MyBaseExpressionSyntax = node
				If (Me.ContainingType IsNot Nothing) Then
					baseTypeNoUseSiteDiagnostics = Me.ContainingType.BaseTypeNoUseSiteDiagnostics
				Else
					baseTypeNoUseSiteDiagnostics = ErrorTypeSymbol.UnknownResultType
				End If
				boundMyBaseReference = New Microsoft.CodeAnalysis.VisualBasic.BoundMyBaseReference(myBaseExpressionSyntax, baseTypeNoUseSiteDiagnostics)
			Else
				Binder.ReportDiagnostic(diagnostics, node, eRRID, New [Object]() { SyntaxFacts.GetText(node.Keyword.Kind()) })
				Dim myBaseExpressionSyntax1 As Microsoft.CodeAnalysis.VisualBasic.Syntax.MyBaseExpressionSyntax = node
				If (Me.ContainingType IsNot Nothing) Then
					unknownResultType = Me.ContainingType.BaseTypeNoUseSiteDiagnostics
				Else
					unknownResultType = ErrorTypeSymbol.UnknownResultType
				End If
				boundMyBaseReference = New Microsoft.CodeAnalysis.VisualBasic.BoundMyBaseReference(myBaseExpressionSyntax1, unknownResultType, True)
			End If
			Return boundMyBaseReference
		End Function

		Private Function BindMyClassExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.MyClassExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundMyClassReference
			Dim boundMyClassReference As Microsoft.CodeAnalysis.VisualBasic.BoundMyClassReference
			Dim eRRID As Microsoft.CodeAnalysis.VisualBasic.ERRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_None
			If (Me.CanAccessMyClass(False, eRRID)) Then
				Dim containingMember As Symbol = Me.ContainingMember
				Dim myClassExpressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.MyClassExpressionSyntax = node
				Dim containingType As Object = Me.ContainingType
				If (containingType Is Nothing) Then
					containingType = ErrorTypeSymbol.UnknownResultType
				End If
				boundMyClassReference = New Microsoft.CodeAnalysis.VisualBasic.BoundMyClassReference(myClassExpressionSyntax, containingType)
			Else
				Binder.ReportDiagnostic(diagnostics, node, eRRID, New [Object]() { SyntaxFacts.GetText(node.Keyword.Kind()) })
				Dim myClassExpressionSyntax1 As Microsoft.CodeAnalysis.VisualBasic.Syntax.MyClassExpressionSyntax = node
				Dim unknownResultType As Object = Me.ContainingType
				If (unknownResultType Is Nothing) Then
					unknownResultType = ErrorTypeSymbol.UnknownResultType
				End If
				boundMyClassReference = New Microsoft.CodeAnalysis.VisualBasic.BoundMyClassReference(myClassExpressionSyntax1, unknownResultType, True)
			End If
			Return boundMyClassReference
		End Function

		Private Function BindNameOfExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.NameOfExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim identifier As Microsoft.CodeAnalysis.SyntaxToken
			Dim name As SyntaxNode
			Dim argument As SyntaxNode
			If (node.Argument.HasErrors) Then
				diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
			End If
			Dim valueText As String = Nothing
			Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = node.Argument.Kind()
			If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleMemberAccessExpression) Then
				identifier = DirectCast(node.Argument, Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax).Name.Identifier
				valueText = identifier.ValueText
			ElseIf (CUShort(syntaxKind) - CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IdentifierName) <= CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List)) Then
				identifier = DirectCast(node.Argument, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax).Identifier
				valueText = identifier.ValueText
			End If
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindExpression(node.Argument, diagnostics)
			Dim kind As BoundKind = boundExpression.Kind
			If (kind = BoundKind.NamespaceExpression) Then
				diagnostics.AddAssembliesUsedByNamespaceReference(DirectCast(boundExpression, BoundNamespaceExpression).NamespaceSymbol)
			ElseIf (kind = BoundKind.MethodGroup) Then
				Dim boundMethodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup = DirectCast(boundExpression, Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup)
				If (boundMethodGroup.ResultKind = LookupResultKind.Inaccessible) Then
					Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
					If (node.Argument.Kind() = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleMemberAccessExpression) Then
						name = DirectCast(node.Argument, Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax).Name
					Else
						name = node.Argument
					End If
					Binder.ReportDiagnostic(bindingDiagnosticBag, name, Me.GetInaccessibleErrorInfo(boundMethodGroup.Methods.First()))
				ElseIf (boundMethodGroup.ResultKind <> LookupResultKind.Good OrElse boundMethodGroup.TypeArgumentsOpt Is Nothing) Then
					Dim enumerator As ImmutableArray(Of MethodSymbol).Enumerator = boundMethodGroup.Methods.GetEnumerator()
					While enumerator.MoveNext()
						diagnostics.AddDependency(enumerator.Current.ContainingAssembly)
					End While
				Else
					Binder.ReportDiagnostic(diagnostics, boundMethodGroup.TypeArgumentsOpt.Syntax, ERRID.ERR_MethodTypeArgsUnexpected)
				End If
			ElseIf (kind = BoundKind.PropertyGroup) Then
				Dim boundPropertyGroup As Microsoft.CodeAnalysis.VisualBasic.BoundPropertyGroup = DirectCast(boundExpression, Microsoft.CodeAnalysis.VisualBasic.BoundPropertyGroup)
				If (boundPropertyGroup.ResultKind <> LookupResultKind.Inaccessible) Then
					Dim enumerator1 As ImmutableArray(Of PropertySymbol).Enumerator = boundPropertyGroup.Properties.GetEnumerator()
					While enumerator1.MoveNext()
						diagnostics.AddDependency(enumerator1.Current.ContainingAssembly)
					End While
				Else
					Dim bindingDiagnosticBag1 As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
					If (node.Argument.Kind() = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleMemberAccessExpression) Then
						argument = DirectCast(node.Argument, Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax).Name
					Else
						argument = node.Argument
					End If
					Binder.ReportDiagnostic(bindingDiagnosticBag1, argument, Me.GetInaccessibleErrorInfo(boundPropertyGroup.Properties.First()))
				End If
			End If
			Return New BoundNameOfOperator(node, boundExpression, ConstantValue.Create(valueText), Me.GetSpecialType(SpecialType.System_String, node, diagnostics), False)
		End Function

		Public Function BindNamespaceOrTypeExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim boundNamespaceExpression As BoundExpression
			Dim target As Symbol = Me.BindNamespaceOrTypeOrAliasSyntax(node, diagnostics, False)
			Dim aliasSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol = TryCast(target, Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol)
			If (aliasSymbol IsNot Nothing) Then
				target = aliasSymbol.Target
				Binder.ReportUseSite(diagnostics, node, target)
			End If
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = TryCast(target, Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)
			If (typeSymbol Is Nothing) Then
				Dim namespaceSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol = TryCast(target, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol)
				If (namespaceSymbol Is Nothing) Then
					Throw ExceptionUtilities.Unreachable
				End If
				boundNamespaceExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundNamespaceExpression(node, Nothing, aliasSymbol, namespaceSymbol, False)
			Else
				boundNamespaceExpression = New BoundTypeExpression(node, Nothing, aliasSymbol, typeSymbol, False)
			End If
			Return boundNamespaceExpression
		End Function

		Public Function BindNamespaceOrTypeOrAliasSyntax(ByVal typeSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal suppressUseSiteError As Boolean = False) As Symbol
			Return Binder.TypeBinder.BindNamespaceOrTypeOrAliasSyntax(typeSyntax, Me, diagBag, suppressUseSiteError)
		End Function

		Public Function BindNamespaceOrTypeOrExpressionSyntaxForSemanticModel(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			If (node.Kind() = SyntaxKind.PredefinedType OrElse (TypeOf node Is Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax OrElse node.Kind() = SyntaxKind.ArrayType OrElse node.Kind() = SyntaxKind.TupleType) AndAlso SyntaxFacts.IsInNamespaceOrTypeContext(node)) Then
				Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindNamespaceOrTypeExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax), diagnostics)
				If (node.Parent IsNot Nothing AndAlso node.Parent.Kind() = SyntaxKind.QualifiedName AndAlso DirectCast(node.Parent, Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax).Left = node AndAlso boundExpression1.Kind = BoundKind.NamespaceExpression) Then
					Dim boundNamespaceExpression As Microsoft.CodeAnalysis.VisualBasic.BoundNamespaceExpression = DirectCast(boundExpression1, Microsoft.CodeAnalysis.VisualBasic.BoundNamespaceExpression)
					If (CInt(boundNamespaceExpression.NamespaceSymbol.NamespaceKind) = 0) Then
						Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindNamespaceOrTypeOrExpressionSyntaxForSemanticModel(DirectCast(node.Parent, Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax), Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded)
						Dim instance As ArrayBuilder(Of Symbol) = ArrayBuilder(Of Symbol).GetInstance()
						Binder.BindNamespaceOrTypeSyntaxForSemanticModelGetExpressionSymbols(boundExpression2, instance)
						If (instance.Count = 0) Then
							Binder.BindNamespaceOrTypeSyntaxForSemanticModelGetExpressionSymbols(Me.BindExpression(DirectCast(node.Parent, Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax), Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded), instance)
						End If
						boundExpression1 = Me.AdjustReceiverNamespace(boundNamespaceExpression, instance)
						instance.Free()
					End If
				End If
				boundExpression = boundExpression1
			Else
				boundExpression = Me.BindExpression(node, SyntaxFacts.IsInvocationOrAddressOfOperand(node), False, False, diagnostics)
			End If
			Return boundExpression
		End Function

		Public Function BindNamespaceOrTypeSyntax(ByVal typeSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal suppressUseSiteError As Boolean = False) As NamespaceOrTypeSymbol
			Return Binder.TypeBinder.BindNamespaceOrTypeSyntax(typeSyntax, Me, diagBag, suppressUseSiteError)
		End Function

		Private Shared Sub BindNamespaceOrTypeSyntaxForSemanticModelGetExpressionSymbols(ByVal expression As BoundExpression, ByVal symbols As ArrayBuilder(Of Symbol))
			expression.GetExpressionSymbols(symbols)
			If (symbols.Count = 1 AndAlso symbols(0).Kind = SymbolKind.ErrorType) Then
				Dim item As ErrorTypeSymbol = DirectCast(symbols(0), ErrorTypeSymbol)
				symbols.Clear()
				Dim errorInfo As IDiagnosticInfoWithSymbols = TryCast(item.ErrorInfo, IDiagnosticInfoWithSymbols)
				If (errorInfo IsNot Nothing) Then
					errorInfo.GetAssociatedSymbols(symbols)
				End If
			End If
		End Sub

		Private Function BindNoPiaObjectCreationExpression(ByVal node As SyntaxNode, ByVal [interface] As TypeSymbol, ByVal coClass As NamedTypeSymbol, ByVal boundArguments As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression), ByVal initializerOpt As BoundObjectInitializerExpressionBase, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim flag As Boolean = False
			Dim str As String = Nothing
			If (Not coClass.GetGuidString(str)) Then
				Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_NoPIAAttributeMissing2, New [Object]() { coClass, AttributeDescription.GuidAttribute.FullName })
				flag = True
			End If
			Dim boundNoPiaObjectCreationExpression As Microsoft.CodeAnalysis.VisualBasic.BoundNoPiaObjectCreationExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundNoPiaObjectCreationExpression(node, str, initializerOpt, [interface], flag)
			If (Not System.Linq.ImmutableArrayExtensions.Any(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundArguments)) Then
				boundExpression = boundNoPiaObjectCreationExpression
			Else
				Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_NoArgumentCountOverloadCandidates1, New [Object]() { "New" })
				Dim boundExpressions As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = boundArguments.Add(boundNoPiaObjectCreationExpression)
				boundExpression = Binder.BadExpression(node, boundExpressions, boundNoPiaObjectCreationExpression.Type)
			End If
			Return boundExpression
		End Function

		Private Function BindObjectCollectionOrMemberInitializer(ByVal syntaxNode As Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax, ByVal initializedObjectType As TypeSymbol, ByVal asNewVariablePlaceholderOpt As BoundWithLValueExpressionPlaceholder, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundObjectInitializerExpressionBase
			Dim boundObjectInitializerExpressionBase As Microsoft.CodeAnalysis.VisualBasic.BoundObjectInitializerExpressionBase
			If (syntaxNode.Initializer Is Nothing) Then
				boundObjectInitializerExpressionBase = Nothing
			ElseIf (syntaxNode.Initializer.Kind() <> SyntaxKind.ObjectMemberInitializer) Then
				If (syntaxNode.Initializer.Kind() <> SyntaxKind.ObjectCollectionInitializer) Then
					Throw ExceptionUtilities.UnexpectedValue(syntaxNode.Initializer.Kind())
				End If
				boundObjectInitializerExpressionBase = Me.BindCollectionInitializer(syntaxNode, initializedObjectType, diagnostics)
			Else
				boundObjectInitializerExpressionBase = Me.BindObjectInitializer(syntaxNode, initializedObjectType, asNewVariablePlaceholderOpt, diagnostics)
			End If
			Return boundObjectInitializerExpressionBase
		End Function

		Private Function BindObjectCreationExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Binder.DisallowNewOnTupleType(node.Type, diagnostics)
			Dim item As TypeSymbol = Me.BindTypeSyntax(node.Type, diagnostics, False, False, False)
			If (item.IsErrorType()) Then
				Dim extendedErrorTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.ExtendedErrorTypeSymbol = TryCast(item, Microsoft.CodeAnalysis.VisualBasic.Symbols.ExtendedErrorTypeSymbol)
				If (extendedErrorTypeSymbol IsNot Nothing AndAlso extendedErrorTypeSymbol.CandidateSymbols.Length = 1 AndAlso extendedErrorTypeSymbol.CandidateSymbols(0).Kind = SymbolKind.NamedType) Then
					item = DirectCast(extendedErrorTypeSymbol.CandidateSymbols(0), TypeSymbol)
					diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
					boundExpression = Me.BindObjectCreationExpression(node.Type, node.ArgumentList, item, node, diagnostics, Nothing)
					Return boundExpression
				End If
				Dim discarded As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
				Dim boundExpressions As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = New ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)()
				Dim strs As ImmutableArray(Of String) = New ImmutableArray(Of String)()
				Dim locations As ImmutableArray(Of Location) = New ImmutableArray(Of Location)()
				Me.BindArgumentsAndNames(node.ArgumentList, boundExpressions, strs, locations, discarded)
				Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance()
				Dim enumerator As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Enumerator = boundExpressions.GetEnumerator()
				While enumerator.MoveNext()
					instance.Add(Me.MakeRValueAndIgnoreDiagnostics(enumerator.Current))
				End While
				Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindObjectCollectionOrMemberInitializer(node, item, Nothing, discarded)
				If (boundExpression1 IsNot Nothing) Then
					instance.Add(boundExpression1)
				End If
				discarded.Free()
				boundExpression = Binder.BadExpression(node, instance.ToImmutableAndFree(), item)
				Return boundExpression
			End If
			boundExpression = Me.BindObjectCreationExpression(node.Type, node.ArgumentList, item, node, diagnostics, Nothing)
			Return boundExpression
		End Function

		Friend Function BindObjectCreationExpression(ByVal typeNode As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax, ByVal argumentListOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax, ByVal type0 As TypeSymbol, ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal asNewVariablePlaceholderOpt As BoundWithLValueExpressionPlaceholder) As BoundExpression
			Dim boundObjectCreationExpression As BoundExpression
			Dim current As Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol
			Dim objectCreationExpressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax
			Dim methodSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol
			Dim boundMethodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup
			Dim typeKind As Microsoft.CodeAnalysis.TypeKind = type0.TypeKind
			If (typeKind = Microsoft.CodeAnalysis.TypeKind.[Delegate]) Then
				boundObjectCreationExpression = Me.BindDelegateCreationExpression(type0, argumentListOpt, node, diagnostics)
			Else
				If (typeKind = Microsoft.CodeAnalysis.TypeKind.Struct) Then
					If (argumentListOpt IsNot Nothing AndAlso argumentListOpt.Arguments.Count <> 0) Then
						GoTo Label1
					End If
					Dim methodSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol = Nothing
					Dim instanceConstructors As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol) = DirectCast(type0, NamedTypeSymbol).InstanceConstructors
					If (Not instanceConstructors.IsEmpty) Then
						Dim enumerator As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol).Enumerator = instanceConstructors.GetEnumerator()
						Do
							If (Not enumerator.MoveNext()) Then
								objectCreationExpressionSyntax = node
								methodSymbol = methodSymbol1
								If (methodSymbol1 Is Nothing) Then
									boundMethodGroup = Nothing
								Else
									boundMethodGroup = New Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup(typeNode, Nothing, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)(methodSymbol1), LookupResultKind.Good, Nothing, QualificationKind.QualifiedViaTypeName, False)
								End If
								boundObjectCreationExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundObjectCreationExpression(objectCreationExpressionSyntax, methodSymbol, boundMethodGroup, ImmutableArray(Of BoundExpression).Empty, BitVector.Null, Me.BindObjectCollectionOrMemberInitializer(node, type0, asNewVariablePlaceholderOpt, diagnostics), type0, False)
								Return boundObjectCreationExpression
							End If
							current = enumerator.Current
						Loop While current.ParameterCount <> 0
						Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
						Dim basesBeingResolved As Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolved = New Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolved()
						If (Me.IsAccessible(current, newCompoundUseSiteInfo, Nothing, basesBeingResolved)) Then
							methodSymbol1 = current
							Binder.ReportUseSite(diagnostics, node, methodSymbol1)
						End If
						diagnostics.Add(node, newCompoundUseSiteInfo)
					End If
					objectCreationExpressionSyntax = node
					methodSymbol = methodSymbol1
					If (methodSymbol1 Is Nothing) Then
						boundMethodGroup = Nothing
					Else
						boundMethodGroup = New Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup(typeNode, Nothing, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)(methodSymbol1), LookupResultKind.Good, Nothing, QualificationKind.QualifiedViaTypeName, False)
					End If
					boundObjectCreationExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundObjectCreationExpression(objectCreationExpressionSyntax, methodSymbol, boundMethodGroup, ImmutableArray(Of BoundExpression).Empty, BitVector.Null, Me.BindObjectCollectionOrMemberInitializer(node, type0, asNewVariablePlaceholderOpt, diagnostics), type0, False)
					Return boundObjectCreationExpression
				End If
			Label1:
				Dim boundExpressions As ImmutableArray(Of BoundExpression) = New ImmutableArray(Of BoundExpression)()
				Dim strs As ImmutableArray(Of String) = New ImmutableArray(Of String)()
				Dim locations As ImmutableArray(Of Location) = New ImmutableArray(Of Location)()
				Me.BindArgumentsAndNames(argumentListOpt, boundExpressions, strs, locations, diagnostics)
				Dim boundObjectInitializerExpressionBase As Microsoft.CodeAnalysis.VisualBasic.BoundObjectInitializerExpressionBase = Me.BindObjectCollectionOrMemberInitializer(node, type0, asNewVariablePlaceholderOpt, diagnostics)
				boundObjectCreationExpression = Me.BindObjectCreationExpression(typeNode, argumentListOpt, type0, node, boundExpressions, strs, boundObjectInitializerExpressionBase, diagnostics, typeNode)
			End If
			Return boundObjectCreationExpression
		End Function

		Friend Function BindObjectCreationExpression(ByVal syntax As SyntaxNode, ByVal type As TypeSymbol, ByVal arguments As ImmutableArray(Of BoundExpression), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim strs As ImmutableArray(Of String) = New ImmutableArray(Of String)()
			Return Me.BindObjectCreationExpression(syntax, Nothing, type, syntax, arguments, strs, Nothing, diagnostics, Nothing)
		End Function

		Private Function BindObjectCreationExpression(ByVal typeNode As SyntaxNode, ByVal argumentListOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax, ByVal type0 As TypeSymbol, ByVal node As SyntaxNode, ByVal boundArguments As ImmutableArray(Of BoundExpression), ByVal argumentNames As ImmutableArray(Of String), ByVal objectInitializerExpressionOpt As BoundObjectInitializerExpressionBase, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal callerInfoOpt As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode) As BoundExpression
			Dim boundBadExpression As BoundExpression
			Dim boundObjectCreationExpression As BoundExpression
			Dim diagnosticInfo As Microsoft.CodeAnalysis.DiagnosticInfo
			Dim right As SyntaxNode
			Dim lookupResultKind As Microsoft.CodeAnalysis.VisualBasic.LookupResultKind = Microsoft.CodeAnalysis.VisualBasic.LookupResultKind.Good
			Dim flag As Boolean = False
			Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = Nothing
			Select Case type0.TypeKind
				Case Microsoft.CodeAnalysis.TypeKind.Array
					lookupResultKind = Microsoft.CodeAnalysis.VisualBasic.LookupResultKind.NotCreatable
					flag = True
					Exit Select
				Case Microsoft.CodeAnalysis.TypeKind.[Class]
					If (DirectCast(type0, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol).IsMustInherit) Then
						Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_NewOnAbstractClass)
						lookupResultKind = Microsoft.CodeAnalysis.VisualBasic.LookupResultKind.NotCreatable
						flag = True
					End If
					namedTypeSymbol = DirectCast(type0, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)
					Exit Select
				Case Microsoft.CodeAnalysis.TypeKind.[Delegate]
				Case Microsoft.CodeAnalysis.TypeKind.Dynamic
				Case Microsoft.CodeAnalysis.TypeKind.Pointer
					Throw ExceptionUtilities.UnexpectedValue(type0.TypeKind)
				Case Microsoft.CodeAnalysis.TypeKind.[Enum]
				Case Microsoft.CodeAnalysis.TypeKind.Struct
					namedTypeSymbol = DirectCast(type0, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)
					Exit Select
				Case Microsoft.CodeAnalysis.TypeKind.[Error]
					boundBadExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression(node, Microsoft.CodeAnalysis.VisualBasic.LookupResultKind.Empty, ImmutableArray(Of Symbol).Empty, Binder.MergeBoundChildNodesWithObjectInitializerForBadNode(boundArguments, objectInitializerExpressionOpt), type0, True)
					Return boundBadExpression
				Case Microsoft.CodeAnalysis.TypeKind.[Interface]
					Dim coClassType As TypeSymbol = DirectCast(type0, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol).CoClassType
					If (coClassType Is Nothing) Then
						diagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_NewIfNullOnNonClass)
					Else
						Select Case coClassType.TypeKind
							Case Microsoft.CodeAnalysis.TypeKind.Array
								diagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_InvalidCoClass1, New [Object]() { coClassType })
								Exit Select
							Case Microsoft.CodeAnalysis.TypeKind.[Class]
							Case Microsoft.CodeAnalysis.TypeKind.[Delegate]
							Case Microsoft.CodeAnalysis.TypeKind.[Enum]
							Case Microsoft.CodeAnalysis.TypeKind.[Module]
							Case Microsoft.CodeAnalysis.TypeKind.Struct
								Dim namedTypeSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = DirectCast(coClassType, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)
								If (Not namedTypeSymbol1.IsUnboundGenericType) Then
									Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
									Dim basesBeingResolved As Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolved = New Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolved()
									diagnostics.Add(node, newCompoundUseSiteInfo)
									If (Me.CheckAccessibility(namedTypeSymbol1, newCompoundUseSiteInfo, Nothing, basesBeingResolved) <> AccessCheckResult.Accessible) Then
										diagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_InAccessibleCoClass3, New [Object]() { coClassType, type0, coClassType.DeclaredAccessibility.ToDiagnosticString() })
										Exit Select
									ElseIf (type0.ContainingAssembly.IsLinked) Then
										boundBadExpression = Me.BindNoPiaObjectCreationExpression(node, type0, namedTypeSymbol1, boundArguments, objectInitializerExpressionOpt, diagnostics)
										Return boundBadExpression
									ElseIf (Not namedTypeSymbol1.IsMustInherit) Then
										namedTypeSymbol = namedTypeSymbol1
										diagnosticInfo = Nothing
										Exit Select
									Else
										diagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_InvalidCoClass1, New [Object]() { coClassType })
										Exit Select
									End If
								Else
									diagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_InvalidCoClass1, New [Object]() { coClassType })
									Exit Select
								End If
							Case Microsoft.CodeAnalysis.TypeKind.Dynamic
							Case Microsoft.CodeAnalysis.TypeKind.Pointer
								Throw ExceptionUtilities.UnexpectedValue(coClassType.TypeKind)
							Case Microsoft.CodeAnalysis.TypeKind.[Error]
							Case Microsoft.CodeAnalysis.TypeKind.[Interface]
								diagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_CoClassMissing2, New [Object]() { coClassType, type0 })
								Exit Select
							Case Else
								Throw ExceptionUtilities.UnexpectedValue(coClassType.TypeKind)
						End Select
					End If
					If (diagnosticInfo Is Nothing) Then
						Exit Select
					End If
					Binder.ReportDiagnostic(diagnostics, node, diagnosticInfo)
					lookupResultKind = Microsoft.CodeAnalysis.VisualBasic.LookupResultKind.NotCreatable
					flag = True
					namedTypeSymbol = DirectCast(type0, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)
					Exit Select
				Case Microsoft.CodeAnalysis.TypeKind.[Module]
					namedTypeSymbol = DirectCast(type0, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)
					lookupResultKind = Microsoft.CodeAnalysis.VisualBasic.LookupResultKind.NotCreatable
					flag = True
					Exit Select
				Case Microsoft.CodeAnalysis.TypeKind.TypeParameter
					Dim typeParameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol = DirectCast(type0, Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol)
					If (Not typeParameterSymbol.HasConstructorConstraint AndAlso Not typeParameterSymbol.IsValueType) Then
						Binder.ReportDiagnostic(diagnostics, typeNode, ERRID.ERR_NewIfNullOnGenericParam)
					ElseIf (boundArguments.IsEmpty) Then
						boundBadExpression = New BoundNewT(node, objectInitializerExpressionOpt, typeParameterSymbol, False)
						Return boundBadExpression
					Else
						Dim span As TextSpan = argumentListOpt.Arguments.Span
						Binder.ReportDiagnostic(diagnostics, Me.GetLocation(span), ERRID.ERR_NewArgsDisallowedForTypeParam)
					End If
					lookupResultKind = Microsoft.CodeAnalysis.VisualBasic.LookupResultKind.NotCreatable
					flag = True
					Exit Select
				Case Else
					Throw ExceptionUtilities.UnexpectedValue(type0.TypeKind)
			End Select
			Dim boundMethodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup = Nothing
			If (namedTypeSymbol IsNot Nothing AndAlso Not namedTypeSymbol.IsInterface) Then
				Dim compoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
				Dim accessibleConstructors As ImmutableArray(Of MethodSymbol) = Me.GetAccessibleConstructors(namedTypeSymbol, compoundUseSiteInfo)
				diagnostics.Add(node, compoundUseSiteInfo)
				Dim lookupResultKind1 As Microsoft.CodeAnalysis.VisualBasic.LookupResultKind = Microsoft.CodeAnalysis.VisualBasic.LookupResultKind.Good
				If (accessibleConstructors.Length = 0) Then
					accessibleConstructors = namedTypeSymbol.InstanceConstructors
					lookupResultKind1 = Microsoft.CodeAnalysis.VisualBasic.LookupResultKind.Inaccessible
				End If
				If (accessibleConstructors.Length > 0) Then
					boundMethodGroup = (New Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup(typeNode, Nothing, accessibleConstructors, lookupResultKind1, Nothing, QualificationKind.QualifiedViaTypeName, False)).MakeCompilerGenerated()
				End If
			End If
			If (boundMethodGroup Is Nothing OrElse boundMethodGroup.ResultKind = Microsoft.CodeAnalysis.VisualBasic.LookupResultKind.Inaccessible) Then
				If (Not flag) Then
					Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
					If (typeNode.IsKind(SyntaxKind.QualifiedName)) Then
						right = DirectCast(typeNode, Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax).Right
					Else
						right = typeNode
					End If
					Binder.ReportDiagnostic(bindingDiagnosticBag, right, ErrorFactory.ErrorInfo(ERRID.ERR_NoViableOverloadCandidates1, New [Object]() { "New" }))
				End If
				diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
			End If
			If (boundMethodGroup IsNot Nothing) Then
				Dim newCompoundUseSiteInfo1 As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
				Dim overloadResolutionResult As OverloadResolution.OverloadResolutionResult = OverloadResolution.MethodInvocationOverloadResolution(boundMethodGroup, boundArguments, argumentNames, Me, callerInfoOpt, newCompoundUseSiteInfo1, False, Nothing, Nothing, True, False, False)
				If (diagnostics.Add(node, newCompoundUseSiteInfo1) AndAlso boundMethodGroup.ResultKind <> Microsoft.CodeAnalysis.VisualBasic.LookupResultKind.Inaccessible) Then
					diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
				End If
				If (overloadResolutionResult.BestResult.HasValue) Then
					Dim value As OverloadResolution.CandidateAnalysisResult = overloadResolutionResult.BestResult.Value
					Dim valueTuple As ValueTuple(Of ImmutableArray(Of BoundExpression), BitVector) = Me.PassArguments(typeNode, value, boundArguments, diagnostics)
					boundArguments = valueTuple.Item1
					Me.ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagnostics, value.Candidate.UnderlyingSymbol, node)
					If (type0.IsInterfaceType()) Then
						Me.ApplyImplicitConversion(node, type0, New BoundRValuePlaceholder(node, namedTypeSymbol), diagnostics, False)
					End If
					If (lookupResultKind = Microsoft.CodeAnalysis.VisualBasic.LookupResultKind.Good) Then
						boundObjectCreationExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundObjectCreationExpression(node, DirectCast(value.Candidate.UnderlyingSymbol, MethodSymbol), boundMethodGroup, boundArguments, valueTuple.Item2, objectInitializerExpressionOpt, type0, False)
					Else
						Dim instance As ArrayBuilder(Of BoundExpression) = ArrayBuilder(Of BoundExpression).GetInstance()
						instance.Add(boundMethodGroup)
						instance.AddRange(boundArguments)
						If (objectInitializerExpressionOpt IsNot Nothing) Then
							instance.Add(objectInitializerExpressionOpt)
						End If
						boundObjectCreationExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression(node, lookupResultKind, ImmutableArray.Create(Of Symbol)(value.Candidate.UnderlyingSymbol), instance.ToImmutableAndFree(), type0, True)
					End If
				Else
					If (overloadResolutionResult.Candidates.Length = 0) Then
						Dim discarded As CompoundUseSiteInfo(Of AssemblySymbol) = CompoundUseSiteInfo(Of AssemblySymbol).Discarded
						overloadResolutionResult = OverloadResolution.MethodInvocationOverloadResolution(boundMethodGroup, boundArguments, argumentNames, Me, callerInfoOpt, discarded, True, Nothing, Nothing, True, False, False)
					End If
					boundObjectCreationExpression = Me.ReportOverloadResolutionFailureAndProduceBoundNode(node, boundMethodGroup, boundArguments, argumentNames, overloadResolutionResult, diagnostics, callerInfoOpt, type0, False, Nothing, Nothing, Nothing)
					Dim boundBadExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression = DirectCast(boundObjectCreationExpression, Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression)
					Dim boundExpressions As ArrayBuilder(Of BoundExpression) = ArrayBuilder(Of BoundExpression).GetInstance()
					Dim enumerator As ImmutableArray(Of BoundExpression).Enumerator = boundBadExpression1.ChildBoundNodes.GetEnumerator()
					While enumerator.MoveNext()
						Dim current As BoundExpression = enumerator.Current
						If (current <> boundMethodGroup) Then
							boundExpressions.Add(current)
						Else
							boundExpressions.Add(boundMethodGroup.Update(boundMethodGroup.TypeArgumentsOpt, boundMethodGroup.Methods, boundMethodGroup.PendingExtensionMethodsOpt, LookupResult.WorseResultKind(boundMethodGroup.ResultKind, boundBadExpression1.ResultKind), boundMethodGroup.ReceiverOpt, boundMethodGroup.QualificationKind))
						End If
					End While
					If (objectInitializerExpressionOpt IsNot Nothing) Then
						boundExpressions.Add(objectInitializerExpressionOpt)
					End If
					boundObjectCreationExpression = boundBadExpression1.Update(LookupResult.WorseResultKind(lookupResultKind, boundBadExpression1.ResultKind), boundBadExpression1.Symbols, boundExpressions.ToImmutableAndFree(), boundBadExpression1.Type)
				End If
			Else
				boundObjectCreationExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression(node, LookupResult.WorseResultKind(lookupResultKind, Microsoft.CodeAnalysis.VisualBasic.LookupResultKind.Empty), ImmutableArray(Of Symbol).Empty, Binder.MergeBoundChildNodesWithObjectInitializerForBadNode(boundArguments, objectInitializerExpressionOpt), type0, True)
			End If
			boundBadExpression = boundObjectCreationExpression
			Return boundBadExpression
		End Function

		Private Function BindObjectInitializer(ByVal objectCreationSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax, ByVal initializedObjectType As TypeSymbol, ByVal asNewVariablePlaceholderOpt As Microsoft.CodeAnalysis.VisualBasic.BoundWithLValueExpressionPlaceholder, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundObjectInitializerExpression
			Dim boundObjectInitializerExpression As Microsoft.CodeAnalysis.VisualBasic.BoundObjectInitializerExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim isShared As Boolean
			Dim initializer As Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax = DirectCast(objectCreationSyntax.Initializer, Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax)
			Dim flag As Boolean = If(asNewVariablePlaceholderOpt Is Nothing, True, Not initializedObjectType.IsValueType)
			Dim boundWithLValueExpressionPlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundWithLValueExpressionPlaceholder = Nothing
			If (Not flag) Then
				boundWithLValueExpressionPlaceholder = asNewVariablePlaceholderOpt
			Else
				boundWithLValueExpressionPlaceholder = New Microsoft.CodeAnalysis.VisualBasic.BoundWithLValueExpressionPlaceholder(objectCreationSyntax, initializedObjectType)
				boundWithLValueExpressionPlaceholder.SetWasCompilerGenerated()
			End If
			Dim objectInitializerBinder As Microsoft.CodeAnalysis.VisualBasic.ObjectInitializerBinder = New Microsoft.CodeAnalysis.VisualBasic.ObjectInitializerBinder(Me, boundWithLValueExpressionPlaceholder)
			If (initializedObjectType.SpecialType = SpecialType.System_Object OrElse initializedObjectType.IsErrorType()) Then
				If (initializedObjectType.SpecialType = SpecialType.System_Object) Then
					Binder.ReportDiagnostic(diagnostics, initializer, ErrorFactory.ErrorInfo(ERRID.ERR_AggrInitInvalidForObject))
				End If
				Dim count As Integer = initializer.Initializers.Count
				Dim boundExpressionArray(count - 1 + 1 - 1) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
				Dim num As Integer = count - 1
				Dim num1 As Integer = 0
				Do
					Dim initializers As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax) = initializer.Initializers
					Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = objectInitializerBinder.BindValue(DirectCast(initializers(num1), Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax).Expression, diagnostics, False)
					boundExpressionArray(num1) = Me.MakeRValueAndIgnoreDiagnostics(boundExpression1)
					num1 = num1 + 1
				Loop While num1 <= num
				boundObjectInitializerExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundObjectInitializerExpression(objectCreationSyntax.Initializer, True, Me, boundWithLValueExpressionPlaceholder, Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpressionArray), initializedObjectType, True)
			Else
				Dim strs As HashSet(Of String) = New HashSet(Of String)(CaseInsensitiveComparison.Comparer)
				Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance()
				Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.GetInstance(True, diagnostics.AccumulatesDependencies)
				Dim enumerator As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax).Enumerator = initializer.Initializers.GetEnumerator()
				While enumerator.MoveNext()
					Dim current As Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax = DirectCast(enumerator.Current, Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax)
					Dim name As Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax = current.Name
					If (name.HasErrors) Then
						boundExpression = Binder.BadExpression(current, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
					Else
						boundExpression = Me.BindMemberAccess(name, boundWithLValueExpressionPlaceholder, name, False, bindingDiagnosticBag)
						diagnostics.AddRange(bindingDiagnosticBag, False)
						Dim valueText As String = name.Identifier.ValueText
						If (boundExpression.Kind = BoundKind.FieldAccess OrElse boundExpression.Kind = BoundKind.PropertyGroup) Then
							boundExpression = Me.BindAssignmentTarget(name, boundExpression, diagnostics)
							Dim boundPropertyAccess As Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess = TryCast(boundExpression, Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess)
							If (boundPropertyAccess IsNot Nothing AndAlso boundPropertyAccess.AccessKind <> PropertyAccessKind.[Get] AndAlso Not boundPropertyAccess.IsWriteable AndAlso boundPropertyAccess.PropertySymbol.IsWritable(boundPropertyAccess.ReceiverOpt, Me, True)) Then
								boundPropertyAccess = boundPropertyAccess.Update(boundPropertyAccess.PropertySymbol, boundPropertyAccess.PropertyGroupOpt, boundPropertyAccess.AccessKind, True, boundPropertyAccess.IsLValue, boundPropertyAccess.ReceiverOpt, boundPropertyAccess.Arguments, boundPropertyAccess.DefaultArguments, boundPropertyAccess.Type)
								boundExpression = boundPropertyAccess
							End If
							If (Not boundExpression.HasErrors) Then
								If (boundExpression.Kind <> BoundKind.FieldAccess) Then
									Dim propertySymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol = boundPropertyAccess.PropertySymbol
									isShared = If(propertySymbol.ReducedFrom IsNot Nothing, True, propertySymbol.IsShared)
								Else
									isShared = DirectCast(boundExpression, BoundFieldAccess).FieldSymbol.IsShared
								End If
								If (isShared) Then
									Binder.ReportDiagnostic(diagnostics, name, ErrorFactory.ErrorInfo(ERRID.ERR_SharedMemberAggrMemberInit1, New [Object]() { valueText }))
								ElseIf (Not strs.Add(valueText)) Then
									Binder.ReportDiagnostic(diagnostics, name, ErrorFactory.ErrorInfo(ERRID.ERR_DuplicateAggrMemberInit1, New [Object]() { valueText }))
								End If
							End If
						Else
							If (Not bindingDiagnosticBag.HasAnyErrors()) Then
								Binder.ReportDiagnostic(diagnostics, name, ErrorFactory.ErrorInfo(ERRID.ERR_NonFieldPropertyAggrMemberInit1, New [Object]() { valueText }))
							End If
							boundExpression = Binder.BadExpression(current, boundExpression, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
						End If
					End If
					Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = objectInitializerBinder.BindValue(current.Expression, diagnostics, False)
					instance.Add(Me.BindAssignment(current, boundExpression, boundExpression2, diagnostics))
					bindingDiagnosticBag.Clear()
				End While
				bindingDiagnosticBag.Free()
				boundObjectInitializerExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundObjectInitializerExpression(objectCreationSyntax.Initializer, flag, Me, boundWithLValueExpressionPlaceholder, instance.ToImmutableAndFree(), initializedObjectType, False)
			End If
			Return boundObjectInitializerExpression
		End Function

		Private Function BindOnErrorStatement(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundOnErrorStatement
			Dim boundOnErrorStatement As Microsoft.CodeAnalysis.VisualBasic.BoundOnErrorStatement
			If (Me.IsInLambda) Then
				Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_MultilineLambdasCannotContainOnError)
			ElseIf (Me.IsInAsyncContext() OrElse Me.IsInIteratorContext()) Then
				Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_ResumablesCannotContainOnError)
			End If
			Select Case node.Kind()
				Case SyntaxKind.OnErrorGoToZeroStatement
					boundOnErrorStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundOnErrorStatement(node, OnErrorStatementKind.GoToZero, Nothing, Nothing, False)
					Exit Select
				Case SyntaxKind.OnErrorGoToMinusOneStatement
					boundOnErrorStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundOnErrorStatement(node, OnErrorStatementKind.GoToMinusOne, Nothing, Nothing, False)
					Exit Select
				Case SyntaxKind.OnErrorGoToLabelStatement
					Dim onErrorGoToStatementSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax = DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax)
					Dim label As LabelSymbol = Nothing
					Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindExpression(onErrorGoToStatementSyntax.Label, diagnostics)
					If (boundExpression.Kind <> BoundKind.Label) Then
						boundOnErrorStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundOnErrorStatement(node, Nothing, boundExpression, True)
						Exit Select
					Else
						Dim boundLabel As Microsoft.CodeAnalysis.VisualBasic.BoundLabel = DirectCast(boundExpression, Microsoft.CodeAnalysis.VisualBasic.BoundLabel)
						label = boundLabel.Label
						boundOnErrorStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundOnErrorStatement(node, label, boundLabel, Not Me.IsValidLabelForGoto(label, onErrorGoToStatementSyntax.Label, diagnostics))
						Exit Select
					End If
				Case SyntaxKind.OnErrorResumeNextStatement
					boundOnErrorStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundOnErrorStatement(node, OnErrorStatementKind.ResumeNext, Nothing, Nothing, False)
					Exit Select
				Case Else
					Throw ExceptionUtilities.UnexpectedValue(node.Kind())
			End Select
			Return boundOnErrorStatement
		End Function

		Private Function BindOrderByClause(ByVal source As BoundQueryClauseBase, ByVal orderBy As Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderByClauseSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClause
			Dim boundQueryClause As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClause
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim str As String
			Dim span As TextSpan
			Dim separator As Microsoft.CodeAnalysis.SyntaxToken
			Dim diagnosticBag As Microsoft.CodeAnalysis.DiagnosticBag = Nothing
			Dim discarded As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
			Dim queryLambdaParameterName As String = Binder.GetQueryLambdaParameterName(source.RangeVariables)
			Dim boundOrdering As BoundQueryPart = source
			Dim orderings As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax) = orderBy.Orderings
			If (orderings.Count <> 0) Then
				Dim queryLambdaBinder As Binder.QueryLambdaBinder = Nothing
				Dim count As Integer = orderings.Count - 1
				Dim num As Integer = 0
				Do
					Dim item As Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax = orderings(num)
					Dim boundLambdaParameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol = Me.CreateQueryLambdaParameterSymbol(queryLambdaParameterName, 0, source.CompoundVariableType, item.Expression, source.RangeVariables)
					Dim synthesizedLambdaSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaSymbol = Me.CreateQueryLambdaSymbol(LambdaUtilities.GetOrderingLambdaBody(item), SynthesizedLambdaKind.OrderingQueryLambda, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol)(boundLambdaParameterSymbol))
					queryLambdaBinder = New Binder.QueryLambdaBinder(synthesizedLambdaSymbol, source.RangeVariables)
					Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = queryLambdaBinder.BindValue(item.Expression, diagnostics, False)
					Dim boundQueryLambda As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Binder.CreateBoundQueryLambda(synthesizedLambdaSymbol, source.RangeVariables, boundExpression1, False)
					boundQueryLambda.SetWasCompilerGenerated()
					If (Not boundOrdering.Type.IsErrorType()) Then
						If (discarded <> Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded AndAlso Binder.ShouldSuppressDiagnostics(boundQueryLambda)) Then
							discarded = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
						End If
						If (num <> 0) Then
							str = If(item.Kind() <> SyntaxKind.AscendingOrdering, "ThenByDescending", "ThenBy")
							separator = orderings.GetSeparator(num - 1)
							span = separator.Span
						Else
							str = If(item.Kind() <> SyntaxKind.AscendingOrdering, "OrderByDescending", "OrderBy")
							Dim orderKeyword As Microsoft.CodeAnalysis.SyntaxToken = orderBy.OrderKeyword
							separator = orderBy.ByKeyword
							span = Binder.GetQueryOperatorNameSpan(orderKeyword, separator)
						End If
						boundExpression = Me.BindQueryOperatorCall(item, boundOrdering, str, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundQueryLambda), span, discarded)
					Else
						boundExpression = Binder.BadExpression(item, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundOrdering, boundQueryLambda), ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
					End If
					boundOrdering = New Microsoft.CodeAnalysis.VisualBasic.BoundOrdering(item, boundExpression, boundExpression.Type, False)
					num = num + 1
				Loop While num <= count
				If (diagnosticBag IsNot Nothing) Then
					diagnosticBag.Free()
				End If
				boundQueryClause = New Microsoft.CodeAnalysis.VisualBasic.BoundQueryClause(orderBy, boundOrdering, source.RangeVariables, source.CompoundVariableType, ImmutableArray.Create(Of Binder)(queryLambdaBinder), boundOrdering.Type, False)
			Else
				boundQueryClause = New Microsoft.CodeAnalysis.VisualBasic.BoundQueryClause(orderBy, Binder.BadExpression(orderBy, source, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated(), source.RangeVariables, source.CompoundVariableType, ImmutableArray.Create(Of Binder)(Me), ErrorTypeSymbol.UnknownResultType, True)
			End If
			Return boundQueryClause
		End Function

		Friend Function BindParameterDefaultValue(ByVal targetType As TypeSymbol, ByVal equalsValueSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, <Out> ByRef constValue As ConstantValue) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			constValue = Nothing
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindValue(equalsValueSyntax.Value, diagnostics, False)
			If (Not boundExpression.HasErrors) Then
				If (Not targetType.IsErrorType()) Then
					boundExpression = Me.ApplyImplicitConversion(boundExpression.Syntax, targetType, boundExpression, diagnostics, False)
				End If
				constValue = Me.GetExpressionConstantValueIfAny(boundExpression, diagnostics, Binder.ConstantContext.ParameterDefaultValue)
				If (constValue Is Nothing) Then
					boundExpression = Binder.BadExpression(boundExpression.Syntax, boundExpression, targetType)
				End If
			End If
			Return boundExpression
		End Function

		Private Function BindPartitionClause(ByVal source As BoundQueryClauseBase, ByVal partition As Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax, ByVal operatorName As String, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundQueryClause
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindValue(partition.Count, diagnostics, False)
			If (Not source.Type.IsErrorType()) Then
				If (boundExpression1.HasErrors OrElse boundExpression1.Type IsNot Nothing AndAlso boundExpression1.Type.IsErrorType()) Then
					diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
				End If
				Dim boundExpressions As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpression1)
				Dim skipOrTakeKeyword As Microsoft.CodeAnalysis.SyntaxToken = partition.SkipOrTakeKeyword
				boundExpression = Me.BindQueryOperatorCall(partition, source, operatorName, boundExpressions, skipOrTakeKeyword.Span, diagnostics)
			Else
				boundExpression = Binder.BadExpression(partition, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(source, boundExpression1), ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
			End If
			Return New BoundQueryClause(partition, boundExpression, source.RangeVariables, source.CompoundVariableType, ImmutableArray(Of Binder).Empty, boundExpression.Type, False)
		End Function

		Private Function BindPredefinedCastExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim specialType As Microsoft.CodeAnalysis.SpecialType
			Select Case node.Keyword.Kind()
				Case SyntaxKind.CBoolKeyword
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Boolean
					Exit Select
				Case SyntaxKind.CByteKeyword
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Byte
					Exit Select
				Case SyntaxKind.EmptyStatement Or SyntaxKind.EndUsingStatement Or SyntaxKind.EndSelectStatement Or SyntaxKind.EndEnumStatement Or SyntaxKind.EndClassStatement Or SyntaxKind.EndNamespaceStatement Or SyntaxKind.CompilationUnit Or SyntaxKind.ImportsStatement Or SyntaxKind.SimpleImportsClause Or SyntaxKind.NamedFieldInitializer Or SyntaxKind.Parameter Or SyntaxKind.ArrayRankSpecifier Or SyntaxKind.Attribute Or SyntaxKind.AttributesStatement Or SyntaxKind.PrintStatement Or SyntaxKind.ExitFunctionStatement Or SyntaxKind.ExitPropertyStatement Or SyntaxKind.ExitSelectStatement Or SyntaxKind.ContinueWhileStatement Or SyntaxKind.ContinueForStatement Or SyntaxKind.SingleLineIfStatement Or SyntaxKind.SingleLineElseClause Or SyntaxKind.RightShiftAssignmentStatement Or SyntaxKind.MidExpression Or SyntaxKind.AddHandlerStatement Or SyntaxKind.RaiseEventStatement Or SyntaxKind.ReDimStatement Or SyntaxKind.RedimClause Or SyntaxKind.GetXmlNamespaceExpression Or SyntaxKind.DictionaryAccessExpression Or SyntaxKind.XmlDescendantAccessExpression Or SyntaxKind.InvocationExpression Or SyntaxKind.AnonymousObjectCreationExpression Or SyntaxKind.CollectionInitializer Or SyntaxKind.XmlElementEndTag Or SyntaxKind.XmlAttribute Or SyntaxKind.XmlPrefixName Or SyntaxKind.XmlBracketedName Or SyntaxKind.XmlComment Or SyntaxKind.XmlCDataSection Or SyntaxKind.ArrayType Or SyntaxKind.PredefinedType Or SyntaxKind.AndKeyword Or SyntaxKind.AsKeyword Or SyntaxKind.ByRefKeyword Or SyntaxKind.ByValKeyword Or SyntaxKind.CaseKeyword Or SyntaxKind.CBoolKeyword
				Case SyntaxKind.List Or SyntaxKind.EmptyStatement Or SyntaxKind.EndIfStatement Or SyntaxKind.EndUsingStatement Or SyntaxKind.EndWithStatement Or SyntaxKind.EndSelectStatement Or SyntaxKind.EndStructureStatement Or SyntaxKind.EndEnumStatement Or SyntaxKind.EndInterfaceStatement Or SyntaxKind.EndClassStatement Or SyntaxKind.EndModuleStatement Or SyntaxKind.EndNamespaceStatement Or SyntaxKind.EndSubStatement Or SyntaxKind.CompilationUnit Or SyntaxKind.OptionStatement Or SyntaxKind.ImportsStatement Or SyntaxKind.SimpleImportsClause Or SyntaxKind.XmlNamespaceImportsClause Or SyntaxKind.NamedFieldInitializer Or SyntaxKind.EqualsValue Or SyntaxKind.Parameter Or SyntaxKind.ModifiedIdentifier Or SyntaxKind.ArrayRankSpecifier Or SyntaxKind.AttributeList Or SyntaxKind.Attribute Or SyntaxKind.AttributeTarget Or SyntaxKind.AttributesStatement Or SyntaxKind.ExpressionStatement Or SyntaxKind.PrintStatement Or SyntaxKind.WhileBlock Or SyntaxKind.ExitFunctionStatement Or SyntaxKind.ExitOperatorStatement Or SyntaxKind.ExitPropertyStatement Or SyntaxKind.ExitTryStatement Or SyntaxKind.ExitSelectStatement Or SyntaxKind.ExitWhileStatement Or SyntaxKind.ContinueWhileStatement Or SyntaxKind.ContinueDoStatement Or SyntaxKind.ContinueForStatement Or SyntaxKind.ReturnStatement Or SyntaxKind.SingleLineIfStatement Or SyntaxKind.SingleLineIfPart Or SyntaxKind.SingleLineElseClause Or SyntaxKind.MultiLineIfBlock Or SyntaxKind.RightShiftAssignmentStatement Or SyntaxKind.ConcatenateAssignmentStatement Or SyntaxKind.MidExpression Or SyntaxKind.CallStatement Or SyntaxKind.AddHandlerStatement Or SyntaxKind.RemoveHandlerStatement Or SyntaxKind.RaiseEventStatement Or SyntaxKind.WithStatement Or SyntaxKind.ReDimStatement Or SyntaxKind.ReDimPreserveStatement Or SyntaxKind.RedimClause Or SyntaxKind.EraseStatement Or SyntaxKind.GetXmlNamespaceExpression Or SyntaxKind.SimpleMemberAccessExpression Or SyntaxKind.DictionaryAccessExpression Or SyntaxKind.XmlElementAccessExpression Or SyntaxKind.XmlDescendantAccessExpression Or SyntaxKind.XmlAttributeAccessExpression Or SyntaxKind.InvocationExpression Or SyntaxKind.ObjectCreationExpression Or SyntaxKind.AnonymousObjectCreationExpression Or SyntaxKind.ArrayCreationExpression Or SyntaxKind.CollectionInitializer Or SyntaxKind.CTypeExpression Or SyntaxKind.XmlElementEndTag Or SyntaxKind.XmlEmptyElement Or SyntaxKind.XmlAttribute Or SyntaxKind.XmlString Or SyntaxKind.XmlPrefixName Or SyntaxKind.XmlName Or SyntaxKind.XmlBracketedName Or SyntaxKind.XmlPrefix Or SyntaxKind.XmlComment Or SyntaxKind.XmlProcessingInstruction Or SyntaxKind.XmlCDataSection Or SyntaxKind.XmlEmbeddedExpression Or SyntaxKind.ArrayType Or SyntaxKind.NullableType Or SyntaxKind.PredefinedType Or SyntaxKind.IdentifierName Or SyntaxKind.AndKeyword Or SyntaxKind.AndAlsoKeyword Or SyntaxKind.AsKeyword Or SyntaxKind.BooleanKeyword Or SyntaxKind.ByRefKeyword Or SyntaxKind.ByteKeyword Or SyntaxKind.ByValKeyword Or SyntaxKind.CallKeyword Or SyntaxKind.CaseKeyword Or SyntaxKind.CatchKeyword Or SyntaxKind.CBoolKeyword Or SyntaxKind.CByteKeyword
				Case SyntaxKind.CharKeyword
				Case SyntaxKind.ClassKeyword
				Case SyntaxKind.ConstKeyword
				Case SyntaxKind.ReferenceKeyword
				Case SyntaxKind.ContinueKeyword
				Case SyntaxKind.CTypeKeyword
				Case SyntaxKind.List Or SyntaxKind.EmptyStatement Or SyntaxKind.TypeParameterList Or SyntaxKind.TypeParameter Or SyntaxKind.NamedFieldInitializer Or SyntaxKind.EqualsValue Or SyntaxKind.FinallyStatement Or SyntaxKind.ErrorStatement Or SyntaxKind.RightShiftAssignmentStatement Or SyntaxKind.ConcatenateAssignmentStatement Or SyntaxKind.NotEqualsExpression Or SyntaxKind.LessThanExpression Or SyntaxKind.LessThanOrEqualExpression Or SyntaxKind.GreaterThanOrEqualExpression Or SyntaxKind.XmlElementEndTag Or SyntaxKind.XmlEmptyElement Or SyntaxKind.XmlAttribute Or SyntaxKind.XmlString Or SyntaxKind.CTypeKeyword Or SyntaxKind.CUIntKeyword Or SyntaxKind.CULngKeyword
				Case SyntaxKind.NamedFieldInitializer Or SyntaxKind.Parameter Or SyntaxKind.OnErrorGoToZeroStatement Or SyntaxKind.MidExpression Or SyntaxKind.NotEqualsExpression Or SyntaxKind.GreaterThanExpression Or SyntaxKind.XmlElementEndTag Or SyntaxKind.XmlPrefixName Or SyntaxKind.CTypeKeyword
					Throw ExceptionUtilities.UnexpectedValue(node.Keyword.Kind())
				Case SyntaxKind.CCharKeyword
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Char
					Exit Select
				Case SyntaxKind.CDateKeyword
					specialType = Microsoft.CodeAnalysis.SpecialType.System_DateTime
					Exit Select
				Case SyntaxKind.CDecKeyword
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Decimal
					Exit Select
				Case SyntaxKind.CDblKeyword
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Double
					Exit Select
				Case SyntaxKind.CIntKeyword
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Int32
					Exit Select
				Case SyntaxKind.CLngKeyword
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Int64
					Exit Select
				Case SyntaxKind.CObjKeyword
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Object
					Exit Select
				Case SyntaxKind.CSByteKeyword
					specialType = Microsoft.CodeAnalysis.SpecialType.System_SByte
					Exit Select
				Case SyntaxKind.CShortKeyword
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Int16
					Exit Select
				Case SyntaxKind.CSngKeyword
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Single
					Exit Select
				Case SyntaxKind.CStrKeyword
					specialType = Microsoft.CodeAnalysis.SpecialType.System_String
					Exit Select
				Case SyntaxKind.CUIntKeyword
					specialType = Microsoft.CodeAnalysis.SpecialType.System_UInt32
					Exit Select
				Case SyntaxKind.CULngKeyword
					specialType = Microsoft.CodeAnalysis.SpecialType.System_UInt64
					Exit Select
				Case SyntaxKind.CUShortKeyword
					specialType = Microsoft.CodeAnalysis.SpecialType.System_UInt16
					Exit Select
				Case Else
					Throw ExceptionUtilities.UnexpectedValue(node.Keyword.Kind())
			End Select
			Return Me.ApplyConversion(node, Me.GetSpecialType(specialType, node.Keyword, diagnostics), Me.BindValue(node.Expression, diagnostics, False), True, diagnostics, False, False)
		End Function

		Private Function BindPrintStatement(ByVal printStmt As Microsoft.CodeAnalysis.VisualBasic.Syntax.PrintStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindRValue(printStmt.Expression, diagnostics, False)
			Return New BoundExpressionStatement(printStmt, boundExpression, False)
		End Function

		Friend Sub BindPropertyInitializer(ByVal propertySymbols As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol), ByVal initValueOrAsNewNode As Microsoft.CodeAnalysis.SyntaxNode, ByVal boundInitializers As ArrayBuilder(Of BoundInitializer), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Dim boundPropertyAccess As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim flag As Boolean = False
			Dim boundMeReference As Microsoft.CodeAnalysis.VisualBasic.BoundMeReference
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim propertySymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol = propertySymbols.First()
			Dim syntaxNode As Microsoft.CodeAnalysis.SyntaxNode = initValueOrAsNewNode
			If (propertySymbol.IsShared) Then
				boundMeReference = Nothing
			Else
				boundMeReference = Me.CreateMeReference(syntaxNode, True)
			End If
			Dim boundMeReference1 As Microsoft.CodeAnalysis.VisualBasic.BoundMeReference = boundMeReference
			Dim parameterCount As Boolean = propertySymbol.ParameterCount > 0
			If (Not propertySymbol.IsReadOnly OrElse propertySymbol.AssociatedField Is Nothing) Then
				Dim hasSet As Boolean = propertySymbol.HasSet
				Dim empty As ImmutableArray(Of !0) = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty
				Dim bitVector As Microsoft.CodeAnalysis.BitVector = New Microsoft.CodeAnalysis.BitVector()
				boundPropertyAccess = New Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess(syntaxNode, propertySymbol, Nothing, PropertyAccessKind.[Set], hasSet, boundMeReference1, empty, bitVector, parameterCount)
			Else
				boundPropertyAccess = New BoundFieldAccess(syntaxNode, boundMeReference1, propertySymbol.AssociatedField, True, propertySymbol.Type, parameterCount)
			End If
			boundPropertyAccess = Me.BindAssignmentTarget(syntaxNode, boundPropertyAccess, diagnostics)
			boundPropertyAccess = Me.AdjustAssignmentTarget(syntaxNode, boundPropertyAccess, diagnostics, flag)
			boundPropertyAccess.SetWasCompilerGenerated()
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindFieldOrPropertyInitializerExpression(initValueOrAsNewNode, propertySymbol.Type, Nothing, diagnostics)
			Dim boundInitializers1 As ArrayBuilder(Of BoundInitializer) = boundInitializers
			Dim syntaxNode1 As Microsoft.CodeAnalysis.SyntaxNode = initValueOrAsNewNode
			Dim propertySymbols1 As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol) = propertySymbols
			If (propertySymbols.Length = 1) Then
				boundExpression = boundPropertyAccess
			Else
				boundExpression = Nothing
			End If
			boundInitializers1.Add(New BoundPropertyInitializer(syntaxNode1, propertySymbols1, boundExpression, boundExpression1, False))
		End Sub

		Private Function BindQualifiedName(ByVal name As Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Return Me.BindMemberAccess(name, Me.BindExpression(name.Left, diagnostics), name.Right, False, diagnostics)
		End Function

		Private Function BindQueryExpression(ByVal query As Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			If (query.Clauses.Count >= 1) Then
				Dim enumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator = query.Clauses.GetEnumerator()
				enumerator.MoveNext()
				Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = enumerator.Current.Kind()
				If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FromClause) Then
					boundExpression = Me.BindFromQueryExpression(query, enumerator, diagnostics)
				ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AggregateClause) Then
					boundExpression = Me.BindAggregateQueryExpression(query, enumerator, diagnostics)
				Else
					boundExpression = Binder.BadExpression(query, ErrorTypeSymbol.UnknownResultType)
				End If
			Else
				boundExpression = Binder.BadExpression(query, ErrorTypeSymbol.UnknownResultType)
			End If
			Return boundExpression
		End Function

		Private Function BindQueryOperatorCall(ByVal node As SyntaxNode, ByVal source As BoundExpression, ByVal operatorName As String, ByVal arguments As ImmutableArray(Of BoundExpression), ByVal operatorNameLocation As TextSpan, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Return Me.BindQueryOperatorCall(node, source, operatorName, Me.LookupQueryOperator(node, source, operatorName, Nothing, diagnostics), arguments, operatorNameLocation, diagnostics)
		End Function

		Private Function BindQueryOperatorCall(ByVal node As SyntaxNode, ByVal source As BoundExpression, ByVal operatorName As String, ByVal typeArgumentsOpt As BoundTypeArguments, ByVal arguments As ImmutableArray(Of BoundExpression), ByVal operatorNameLocation As TextSpan, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Return Me.BindQueryOperatorCall(node, source, operatorName, Me.LookupQueryOperator(node, source, operatorName, typeArgumentsOpt, diagnostics), arguments, operatorNameLocation, diagnostics)
		End Function

		Private Function BindQueryOperatorCall(ByVal node As SyntaxNode, ByVal source As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal operatorName As String, ByVal methodGroup As BoundMethodGroup, ByVal arguments As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression), ByVal operatorNameLocation As TextSpan, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim immutableAndFree As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)
			Dim boundBadExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			If (methodGroup IsNot Nothing) Then
				Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
				Dim overloadResolutionResult As OverloadResolution.OverloadResolutionResult = OverloadResolution.QueryOperatorInvocationOverloadResolution(methodGroup, arguments, Me, newCompoundUseSiteInfo, False)
				If (diagnostics.Add(node, newCompoundUseSiteInfo) AndAlso methodGroup.ResultKind <> LookupResultKind.Inaccessible) Then
					diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
				End If
				If (overloadResolutionResult.BestResult.HasValue) Then
					Dim bestResult As Nullable(Of OverloadResolution.CandidateAnalysisResult) = overloadResolutionResult.BestResult
					boundBadExpression = Me.CreateBoundCallOrPropertyAccess(node, node, TypeCharacter.None, methodGroup, arguments, bestResult.Value, overloadResolutionResult.AsyncLambdaSubToFunctionMismatch, diagnostics, False)
					Dim length As Integer = arguments.Length - 1
					For i As Integer = 0 To length
						Dim item As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = arguments(i)
						If (item.Kind = BoundKind.QueryLambda) Then
							Dim boundQueryLambda As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = DirectCast(item, Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda)
							If (CObj(boundQueryLambda.LambdaSymbol.ReturnType) = CObj(LambdaSymbol.ReturnTypePendingDelegate)) Then
								Dim parameters As ImmutableArray(Of ParameterSymbol) = DirectCast(boundBadExpression, BoundCall).Method.Parameters
								Dim returnType As TypeSymbol = parameters(i).Type.DelegateOrExpressionDelegate(Me).DelegateInvokeMethod.ReturnType
								boundQueryLambda.LambdaSymbol.SetQueryLambdaReturnType(returnType)
							End If
						End If
					Next

				Else
					If (overloadResolutionResult.Candidates.Length = 0) Then
						Dim discarded As CompoundUseSiteInfo(Of AssemblySymbol) = CompoundUseSiteInfo(Of AssemblySymbol).Discarded
						overloadResolutionResult = OverloadResolution.QueryOperatorInvocationOverloadResolution(methodGroup, arguments, Me, discarded, True)
					End If
					If (overloadResolutionResult.Candidates.Length > 0) Then
						Dim strs As ImmutableArray(Of String) = New ImmutableArray(Of String)()
						boundBadExpression = Me.ReportOverloadResolutionFailureAndProduceBoundNode(node, methodGroup, arguments, strs, overloadResolutionResult, diagnostics, Nothing, Nothing, True, Nothing, Nothing, Location.Create(node.SyntaxTree, operatorNameLocation))
					End If
				End If
			End If
			If (boundBadExpression Is Nothing) Then
				If (Not arguments.IsEmpty) Then
					Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance()
					Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = methodGroup
					If (boundExpression Is Nothing) Then
						boundExpression = source
					End If
					instance.Add(boundExpression)
					instance.AddRange(arguments)
					immutableAndFree = instance.ToImmutableAndFree()
				Else
					Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = methodGroup
					If (boundExpression1 Is Nothing) Then
						boundExpression1 = source
					End If
					immutableAndFree = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpression1)
				End If
				If (methodGroup IsNot Nothing) Then
					Dim symbols As ArrayBuilder(Of Symbol) = ArrayBuilder(Of Symbol).GetInstance()
					methodGroup.GetExpressionSymbols(symbols)
					Dim resultKind As LookupResultKind = LookupResultKind.OverloadResolutionFailure
					If (methodGroup.ResultKind < resultKind) Then
						resultKind = methodGroup.ResultKind
					End If
					boundBadExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression(node, resultKind, symbols.ToImmutableAndFree(), immutableAndFree, ErrorTypeSymbol.UnknownResultType, True)
				Else
					boundBadExpression = Binder.BadExpression(node, immutableAndFree, ErrorTypeSymbol.UnknownResultType)
				End If
			End If
			If (boundBadExpression.HasErrors AndAlso Not source.HasErrors) Then
				Binder.ReportDiagnostic(diagnostics, Location.Create(node.SyntaxTree, operatorNameLocation), ERRID.ERR_QueryOperatorNotFound, New [Object]() { operatorName })
			End If
			boundBadExpression.SetWasCompilerGenerated()
			Return boundBadExpression
		End Function

		Private Function BindRaiseEventStatement(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.RaiseEventStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim boundBadStatement As BoundStatement
			Dim receiverOpt As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim raiseMethod As MethodSymbol
			Dim boundNodes As ImmutableArray(Of BoundNode)
			Dim flag As Boolean = False
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindSimpleName(node.Name, False, diagnostics, True)
			If (boundExpression.Kind = BoundKind.EventAccess) Then
				Dim boundEventAccess As Microsoft.CodeAnalysis.VisualBasic.BoundEventAccess = DirectCast(boundExpression, Microsoft.CodeAnalysis.VisualBasic.BoundEventAccess)
				Dim boundExpressions As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = New ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)()
				Dim strs As ImmutableArray(Of String) = New ImmutableArray(Of String)()
				Dim locations As ImmutableArray(Of Location) = New ImmutableArray(Of Location)()
				Me.BindArgumentsAndNames(node.ArgumentList, boundExpressions, strs, locations, diagnostics)
				Dim eventSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.EventSymbol = boundEventAccess.EventSymbol
				If (Not eventSymbol.HasAssociatedField) Then
					receiverOpt = boundEventAccess.ReceiverOpt
					raiseMethod = eventSymbol.RaiseMethod
					If (raiseMethod IsNot Nothing) Then
						If (Binder.ReportUseSite(diagnostics, node.Name, raiseMethod)) Then
							flag = True
						End If
						If (raiseMethod.IsSub) Then
							If (TypeSymbol.Equals(raiseMethod.ContainingType, Me.ContainingType, TypeCompareKind.ConsiderEverything)) Then
								GoTo Label1
							End If
							Binder.ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_CantRaiseBaseEvent, New [Object]() { node.Name.ToString() })
							boundNodes = StaticCast(Of BoundNode).From(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpressions)
							boundBadStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement(node, boundNodes.Add(boundExpression), True)
							Return boundBadStatement
						Else
							Binder.ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_EventsCantBeFunctions)
							boundNodes = StaticCast(Of BoundNode).From(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpressions)
							boundBadStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement(node, boundNodes.Add(boundExpression), True)
							Return boundBadStatement
						End If
					Else
						Binder.ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_MissingRaiseEventDef1, New [Object]() { node.Name.ToString() })
						boundNodes = StaticCast(Of BoundNode).From(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpressions)
						boundBadStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement(node, boundNodes.Add(boundExpression), True)
						Return boundBadStatement
					End If
				Else
					Dim associatedField As FieldSymbol = eventSymbol.AssociatedField
					Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
					Dim containingType As NamedTypeSymbol = Me.ContainingType
					Dim basesBeingResolved As Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolved = New Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolved()
					If (Not Me.IsAccessible(associatedField, newCompoundUseSiteInfo, containingType, basesBeingResolved)) Then
						Binder.ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_CantRaiseBaseEvent)
						flag = True
					End If
					diagnostics.Add(node.Name, newCompoundUseSiteInfo)
					receiverOpt = (New BoundFieldAccess(node.Name, boundEventAccess.ReceiverOpt, associatedField, False, associatedField.Type, False)).MakeCompilerGenerated()
					Dim type As NamedTypeSymbol = TryCast(eventSymbol.Type, NamedTypeSymbol)
					If (type Is Nothing OrElse type.DelegateInvokeMethod Is Nothing) Then
						If (type IsNot Nothing AndAlso type.IsDelegateType()) Then
							Binder.ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_EventTypeNotDelegate)
						End If
						boundNodes = StaticCast(Of BoundNode).From(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpressions)
						boundBadStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement(node, boundNodes.Add(boundExpression), True)
						Return boundBadStatement
					Else
						raiseMethod = type.DelegateInvokeMethod
						If (Binder.ReportUseSite(diagnostics, node.Name, raiseMethod)) Then
							flag = True
						End If
						If (raiseMethod.IsSub) Then
							GoTo Label1
						End If
						Binder.ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_EventsCantBeFunctions)
						boundNodes = StaticCast(Of BoundNode).From(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpressions)
						boundBadStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement(node, boundNodes.Add(boundExpression), True)
						Return boundBadStatement
					End If
				End If
			Label1:
				If (raiseMethod = Me.ContainingMember AndAlso (raiseMethod.IsShared OrElse receiverOpt.IsMeReference())) Then
					Binder.ReportDiagnostic(diagnostics, node, ERRID.WRN_RecursiveAddHandlerCall, New [Object]() { node.RaiseEventKeyword.ToString(), eventSymbol.Name })
				End If
				Dim boundMethodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup = (New Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup(node, Nothing, ImmutableArray.Create(Of MethodSymbol)(raiseMethod), LookupResultKind.Good, receiverOpt, QualificationKind.QualifiedViaValue, False)).MakeCompilerGenerated()
				Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindInvocationExpression(node, node.Name, TypeCharacter.None, boundMethodGroup, boundExpressions, strs, diagnostics, Nothing, False, False, False, eventSymbol, False).MakeCompilerGenerated()
				boundBadStatement = New BoundRaiseEventStatement(node, eventSymbol, boundExpression1, flag)
			Else
				If (Not boundExpression.HasErrors) Then
					Binder.ReportDiagnostic(diagnostics, node.Name, ERRID.ERR_NameNotEvent2, New [Object]() { node.Name.ToString(), Me.ContainingType })
				End If
				boundBadStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement(node, ImmutableArray.Create(Of BoundNode)(boundExpression), True)
			End If
			Return boundBadStatement
		End Function

		Private Function BindRangeCaseClause(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeCaseClauseSyntax, ByVal selectExpressionOpt As BoundRValuePlaceholder, ByVal convertCaseElements As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundCaseClause
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindCaseClauseExpression(node.LowerBound, node, selectExpressionOpt, SyntaxKind.GreaterThanEqualsToken, BinaryOperatorKind.GreaterThanOrEqual, convertCaseElements, boundExpression, diagnostics)
			Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim boundExpression3 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindCaseClauseExpression(node.UpperBound, node, selectExpressionOpt, SyntaxKind.LessThanEqualsToken, BinaryOperatorKind.LessThanOrEqual, convertCaseElements, boundExpression2, diagnostics)
			Return New BoundRangeCaseClause(node, boundExpression1, boundExpression3, boundExpression, boundExpression2, False)
		End Function

		Private Function BindRedimStatement(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim instance As ArrayBuilder(Of BoundRedimClause) = ArrayBuilder(Of BoundRedimClause).GetInstance()
			Dim flag As Boolean = node.Kind() = SyntaxKind.ReDimPreserveStatement
			Dim enumerator As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax).Enumerator = node.Clauses.GetEnumerator()
			While enumerator.MoveNext()
				Dim current As Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax = enumerator.Current
				Dim flag1 As Boolean = False
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindAssignmentTarget(current.Expression, diagnostics)
				If (boundExpression.HasErrors) Then
					flag1 = True
				End If
				Me.AdjustAssignmentTarget(current.Expression, boundExpression, diagnostics, flag1)
				If (Not flag1 AndAlso flag AndAlso Me.MakeRValue(boundExpression, diagnostics).HasErrors) Then
					flag1 = True
				End If
				Dim empty As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty
				If (current.ArrayBounds IsNot Nothing) Then
					empty = Me.BindArrayBounds(current.ArrayBounds, diagnostics, Nothing, True)
					Dim enumerator1 As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Enumerator = empty.GetEnumerator()
					While enumerator1.MoveNext()
						If (Not enumerator1.Current.HasErrors) Then
							Continue While
						End If
						flag1 = True
					End While
				End If
				Dim arrayTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol = Nothing
				If (Not flag1) Then
					Dim type As TypeSymbol = boundExpression.Type
					If (type.IsArrayType()) Then
						arrayTypeSymbol = DirectCast(type, Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol)
					ElseIf (Not type.IsObjectType()) Then
						Binder.ReportDiagnostic(diagnostics, current.Expression, ERRID.ERR_ExpectedArray1, New [Object]() { "Redim" })
						flag1 = True
					ElseIf (empty.Length > 0) Then
						Dim customModifiers As ImmutableArray(Of CustomModifier) = New ImmutableArray(Of CustomModifier)()
						arrayTypeSymbol = Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol.CreateVBArray(type, customModifiers, empty.Length, Me.Compilation)
					End If
				End If
				If (Not flag1) Then
					If (empty.Length = 0) Then
						Binder.ReportDiagnostic(diagnostics, current, ERRID.ERR_RedimNoSizes)
						flag1 = True
					ElseIf (arrayTypeSymbol.Rank <> empty.Length) Then
						Binder.ReportDiagnostic(diagnostics, current, ERRID.ERR_RedimRankMismatch)
						flag1 = True
					End If
				End If
				If (Not flag1 AndAlso empty.Length > 32) Then
					Binder.ReportDiagnostic(diagnostics, current, ERRID.ERR_ArrayRankLimit)
					flag1 = True
				End If
				instance.Add(New BoundRedimClause(current, boundExpression, empty, arrayTypeSymbol, flag, flag1))
			End While
			Return New BoundRedimStatement(node, instance.ToImmutableAndFree(), False)
		End Function

		Private Function BindRelationalCaseClause(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax, ByVal selectExpressionOpt As BoundRValuePlaceholder, ByVal convertCaseElements As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundCaseClause
			Dim binaryOperatorKind As Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind
			Select Case node.Kind()
				Case SyntaxKind.CaseEqualsClause
					binaryOperatorKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.Equals
					Exit Select
				Case SyntaxKind.CaseNotEqualsClause
					binaryOperatorKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.NotEquals
					Exit Select
				Case SyntaxKind.CaseLessThanClause
					binaryOperatorKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.LessThan
					Exit Select
				Case SyntaxKind.CaseLessThanOrEqualClause
					binaryOperatorKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.LessThanOrEqual
					Exit Select
				Case SyntaxKind.EndSelectStatement Or SyntaxKind.EndClassStatement Or SyntaxKind.EndFunctionStatement Or SyntaxKind.EndOperatorStatement Or SyntaxKind.EndRaiseEventStatement Or SyntaxKind.NewConstraint Or SyntaxKind.FunctionBlock Or SyntaxKind.SetAccessorBlock Or SyntaxKind.PropertyBlock Or SyntaxKind.ParameterList Or SyntaxKind.NamedFieldInitializer Or SyntaxKind.Parameter Or SyntaxKind.Attribute Or SyntaxKind.PrintStatement Or SyntaxKind.UsingBlock Or SyntaxKind.LabelStatement Or SyntaxKind.NextLabel Or SyntaxKind.EndStatement Or SyntaxKind.OnErrorGoToZeroStatement Or SyntaxKind.ResumeStatement Or SyntaxKind.SelectStatement Or SyntaxKind.CaseElseStatement Or SyntaxKind.CaseEqualsClause
				Case SyntaxKind.List Or SyntaxKind.EndIfStatement Or SyntaxKind.EndSelectStatement Or SyntaxKind.EndStructureStatement Or SyntaxKind.EndClassStatement Or SyntaxKind.EndModuleStatement Or SyntaxKind.EndFunctionStatement Or SyntaxKind.EndGetStatement Or SyntaxKind.EndOperatorStatement Or SyntaxKind.EndEventStatement Or SyntaxKind.EndRaiseEventStatement Or SyntaxKind.EndWhileStatement Or SyntaxKind.NewConstraint Or SyntaxKind.ClassConstraint Or SyntaxKind.FunctionBlock Or SyntaxKind.ConstructorBlock Or SyntaxKind.SetAccessorBlock Or SyntaxKind.AddHandlerAccessorBlock Or SyntaxKind.PropertyBlock Or SyntaxKind.EventBlock Or SyntaxKind.ParameterList Or SyntaxKind.SubStatement Or SyntaxKind.NamedFieldInitializer Or SyntaxKind.EqualsValue Or SyntaxKind.Parameter Or SyntaxKind.ModifiedIdentifier Or SyntaxKind.Attribute Or SyntaxKind.AttributeTarget Or SyntaxKind.PrintStatement Or SyntaxKind.WhileBlock Or SyntaxKind.UsingBlock Or SyntaxKind.SyncLockBlock Or SyntaxKind.LabelStatement Or SyntaxKind.GoToStatement Or SyntaxKind.NextLabel Or SyntaxKind.StopStatement Or SyntaxKind.EndStatement Or SyntaxKind.ExitDoStatement Or SyntaxKind.OnErrorGoToZeroStatement Or SyntaxKind.OnErrorGoToMinusOneStatement Or SyntaxKind.ResumeStatement Or SyntaxKind.ResumeLabelStatement Or SyntaxKind.SelectStatement Or SyntaxKind.CaseElseStatement Or SyntaxKind.ElseCaseClause Or SyntaxKind.CaseEqualsClause Or SyntaxKind.CaseNotEqualsClause
					Throw ExceptionUtilities.UnexpectedValue(node.Kind())
				Case SyntaxKind.CaseGreaterThanOrEqualClause
					binaryOperatorKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.GreaterThanOrEqual
					Exit Select
				Case SyntaxKind.CaseGreaterThanClause
					binaryOperatorKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.GreaterThan
					Exit Select
				Case Else
					Throw ExceptionUtilities.UnexpectedValue(node.Kind())
			End Select
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindCaseClauseExpression(node.Value, node, selectExpressionOpt, node.OperatorToken.Kind(), binaryOperatorKind, convertCaseElements, boundExpression, diagnostics)
			Return New BoundRelationalCaseClause(node, binaryOperatorKind, boundExpression1, boundExpression, False)
		End Function

		Private Function BindRemoveNamespaceAttributesInvocation(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal expr As BoundExpression, ByVal prefixesPlaceholder As BoundRValuePlaceholder, ByVal namespacesPlaceholder As BoundRValuePlaceholder, <Out> ByRef xmlnsAttributesPlaceholder As BoundRValuePlaceholder, <Out> ByRef removeNamespacesGroup As BoundMethodOrPropertyGroup, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			If (xmlnsAttributesPlaceholder Is Nothing) Then
				Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = Me.GetWellKnownType(WellKnownType.System_Collections_Generic_List_T, syntax, diagnostics).Construct(New TypeSymbol() { Me.GetWellKnownType(WellKnownType.System_Xml_Linq_XAttribute, syntax, diagnostics) })
				xmlnsAttributesPlaceholder = (New BoundRValuePlaceholder(syntax, namedTypeSymbol)).MakeCompilerGenerated()
				removeNamespacesGroup = Me.GetXmlMethodOrPropertyGroup(syntax, Me.GetInternalXmlHelperType(syntax, diagnostics), "RemoveNamespaceAttributes", Nothing, diagnostics)
			End If
			Return Me.BindInvocationExpressionIfGroupNotNothing(expr.Syntax, removeNamespacesGroup, ImmutableArray.Create(Of BoundExpression)(prefixesPlaceholder, namespacesPlaceholder, xmlnsAttributesPlaceholder, expr), diagnostics).MakeCompilerGenerated()
		End Function

		Private Function BindResumeStatement(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundResumeStatement
			Dim boundResumeStatement As Microsoft.CodeAnalysis.VisualBasic.BoundResumeStatement
			If (Me.IsInLambda) Then
				Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_MultilineLambdasCannotContainOnError)
			ElseIf (Me.IsInAsyncContext() OrElse Me.IsInIteratorContext()) Then
				Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_ResumablesCannotContainOnError)
			End If
			Select Case node.Kind()
				Case SyntaxKind.ResumeStatement
					boundResumeStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundResumeStatement(node, False)
					Exit Select
				Case SyntaxKind.ResumeLabelStatement
					Dim label As LabelSymbol = Nothing
					Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindExpression(node.Label, diagnostics)
					If (boundExpression.Kind <> BoundKind.Label) Then
						boundResumeStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundResumeStatement(node, Nothing, boundExpression, True)
						Exit Select
					Else
						Dim boundLabel As Microsoft.CodeAnalysis.VisualBasic.BoundLabel = DirectCast(boundExpression, Microsoft.CodeAnalysis.VisualBasic.BoundLabel)
						label = boundLabel.Label
						boundResumeStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundResumeStatement(node, label, boundLabel, Not Me.IsValidLabelForGoto(label, node.Label, diagnostics))
						Exit Select
					End If
				Case SyntaxKind.ResumeNextStatement
					boundResumeStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundResumeStatement(node, True)
					Exit Select
				Case Else
					Throw ExceptionUtilities.UnexpectedValue(node.Kind())
			End Select
			Return boundResumeStatement
		End Function

		Private Function BindReturn(ByVal originalSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ReturnStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim boundReturnStatement As BoundStatement
			Dim flag As Boolean
			Dim flag1 As Boolean
			Dim eRRID As Microsoft.CodeAnalysis.VisualBasic.ERRID
			Dim expression As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = originalSyntax.Expression
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
			Dim currentReturnType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Me.GetCurrentReturnType(flag, flag1, typeSymbol)
			Dim returnLabel As LabelSymbol = Me.GetReturnLabel()
			If (Me.BindingTopLevelScriptCode) Then
				Binder.ReportDiagnostic(diagnostics, originalSyntax, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_KeywordNotAllowedInScript, New [Object]() { SyntaxFacts.GetText(SyntaxKind.ReturnKeyword) })
				boundReturnStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundReturnStatement(originalSyntax, Nothing, Nothing, returnLabel, True)
			ElseIf (currentReturnType.SpecialType <> SpecialType.System_Void) Then
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
				If (expression IsNot Nothing) Then
					boundExpression = Me.BindValue(expression, diagnostics, False)
				End If
				If (boundExpression IsNot Nothing) Then
					If (CObj(currentReturnType) = CObj(LambdaSymbol.ReturnTypeIsUnknown)) Then
						boundExpression = Me.MakeRValueAndIgnoreDiagnostics(boundExpression)
					ElseIf (CObj(currentReturnType) <> CObj(LambdaSymbol.ReturnTypeIsBeingInferred)) Then
						Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
						If (Not flag OrElse currentReturnType.IsErrorType() OrElse Not typeSymbol.Equals(boundExpression.Type) OrElse Not typeSymbol.OriginalDefinition.Equals(Me.Compilation.GetWellKnownType(WellKnownType.System_Threading_Tasks_Task_T)) OrElse Microsoft.CodeAnalysis.VisualBasic.Conversions.ConversionExists(Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyConversion(boundExpression, currentReturnType, Me, newCompoundUseSiteInfo).Key)) Then
							diagnostics.Add(boundExpression, newCompoundUseSiteInfo)
							boundExpression = Me.ApplyImplicitConversion(boundExpression.Syntax, currentReturnType, boundExpression, diagnostics, False)
						Else
							If (Not diagnostics.Add(boundExpression, newCompoundUseSiteInfo)) Then
								Binder.ReportDiagnostic(diagnostics, boundExpression.Syntax, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_BadAsyncReturnOperand1, New [Object]() { currentReturnType })
							End If
							boundExpression = Me.MakeRValueAndIgnoreDiagnostics(boundExpression)
						End If
					End If
				End If
				If (boundExpression IsNot Nothing) Then
					boundReturnStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundReturnStatement(originalSyntax, boundExpression, Me.GetLocalForFunctionValue(), returnLabel, False)
				ElseIf (Not flag OrElse CObj(currentReturnType) <> CObj(LambdaSymbol.ReturnTypeIsBeingInferred)) Then
					Binder.ReportDiagnostic(diagnostics, originalSyntax, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_ReturnWithoutValue)
					boundReturnStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundReturnStatement(originalSyntax, Nothing, Nothing, returnLabel, True)
				Else
					boundReturnStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundReturnStatement(originalSyntax, Nothing, Nothing, returnLabel, False)
				End If
			ElseIf (expression Is Nothing) Then
				boundReturnStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundReturnStatement(originalSyntax, Nothing, Nothing, returnLabel, False)
			Else
				Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
				Dim syntaxNodeOrToken As Microsoft.CodeAnalysis.SyntaxNodeOrToken = originalSyntax
				If (flag1) Then
					eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_BadReturnValueInIterator
				Else
					eRRID = If(Not flag OrElse typeSymbol.SpecialType = SpecialType.System_Void, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_ReturnFromNonFunction, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_ReturnFromNonGenericTaskAsync)
				End If
				Binder.ReportDiagnostic(bindingDiagnosticBag, syntaxNodeOrToken, eRRID)
				Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindValue(expression, diagnostics, False)
				boundExpression1 = Me.MakeRValueAndIgnoreDiagnostics(boundExpression1)
				boundReturnStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundReturnStatement(originalSyntax, boundExpression1, Nothing, returnLabel, True)
			End If
			Return boundReturnStatement
		End Function

		Private Function BindRValue(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal isOperandOfConditionalBranch As Boolean = False) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindExpression(node, False, isOperandOfConditionalBranch, False, diagnostics)
			Return Me.MakeRValue(boundExpression, diagnostics)
		End Function

		Private Function BindSelectBlock(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectBlockSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim selectStatement As Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax = node.SelectStatement
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindSelectExpression(selectStatement.Expression, diagnostics)
			If (boundExpression.HasErrors) Then
				diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
			End If
			Dim boundRValuePlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder = New Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder(selectStatement.Expression, boundExpression.Type)
			boundRValuePlaceholder.SetWasCompilerGenerated()
			Dim boundExpressionStatement As Microsoft.CodeAnalysis.VisualBasic.BoundExpressionStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundExpressionStatement(selectStatement, boundExpression, False)
			Dim binder As Microsoft.CodeAnalysis.VisualBasic.Binder = Me.GetBinder(node)
			Dim flag As Boolean = False
			Dim boundCaseBlocks As ImmutableArray(Of BoundCaseBlock) = binder.BindCaseBlocks(node.CaseBlocks, boundRValuePlaceholder, boundExpression.Type.IsIntrinsicOrEnumType(), flag, diagnostics)
			Return New BoundSelectStatement(node, boundExpressionStatement, boundRValuePlaceholder, boundCaseBlocks, flag, binder.GetExitLabel(SyntaxKind.ExitSelectStatement), False)
		End Function

		Private Function BindSelectClause(ByVal source As BoundQueryClauseBase, ByVal clauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax, ByVal operatorsEnumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundQueryClause
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundLambdaParameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol = Me.CreateQueryLambdaParameterSymbol(Binder.GetQueryLambdaParameterName(source.RangeVariables), 0, source.CompoundVariableType, clauseSyntax, source.RangeVariables)
			Dim synthesizedLambdaSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaSymbol = Me.CreateQueryLambdaSymbol(LambdaUtilities.GetSelectLambdaBody(clauseSyntax), SynthesizedLambdaKind.SelectQueryLambda, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol)(boundLambdaParameterSymbol))
			Dim queryLambdaBinder As Binder.QueryLambdaBinder = New Binder.QueryLambdaBinder(synthesizedLambdaSymbol, source.RangeVariables)
			Dim rangeVariableSymbols As ImmutableArray(Of RangeVariableSymbol) = New ImmutableArray(Of RangeVariableSymbol)()
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = queryLambdaBinder.BindSelectClauseSelector(clauseSyntax, operatorsEnumerator, rangeVariableSymbols, diagnostics)
			Dim boundQueryLambda As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Binder.CreateBoundQueryLambda(synthesizedLambdaSymbol, source.RangeVariables, boundExpression1, False)
			synthesizedLambdaSymbol.SetQueryLambdaReturnType(boundExpression1.Type)
			boundQueryLambda.SetWasCompilerGenerated()
			If (Not source.Type.IsErrorType()) Then
				If (Binder.ShouldSuppressDiagnostics(boundQueryLambda)) Then
					diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
				End If
				Dim boundExpressions As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundQueryLambda)
				Dim selectKeyword As Microsoft.CodeAnalysis.SyntaxToken = clauseSyntax.SelectKeyword
				boundExpression = Me.BindQueryOperatorCall(clauseSyntax, source, "Select", boundExpressions, selectKeyword.Span, diagnostics)
			Else
				boundExpression = Binder.BadExpression(clauseSyntax, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(source, boundQueryLambda), ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
			End If
			Return New BoundQueryClause(clauseSyntax, boundExpression, rangeVariableSymbols, boundQueryLambda.Expression.Type, ImmutableArray.Create(Of Binder)(queryLambdaBinder), boundExpression.Type, False)
		End Function

		Private Function BindSelectExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundParenthesized As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim eRRID As Microsoft.CodeAnalysis.VisualBasic.ERRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_None
			Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = node.Kind()
			If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ParenthesizedExpression) Then
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindSelectExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParenthesizedExpressionSyntax).Expression, diagnostics)
				boundParenthesized = New Microsoft.CodeAnalysis.VisualBasic.BoundParenthesized(node, boundExpression, boundExpression.Type, False)
			Else
				Select Case syntaxKind
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddressOfExpression
						eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_AddressOfInSelectCaseExpr
						GoTo Label0
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.BinaryConditionalExpression
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TernaryConditionalExpression
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndOperatorStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SetAccessorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MidExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CharacterLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DateLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotEqualsExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GreaterThanExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddressOfExpression
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndIfStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndGetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndOperatorStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ConstructorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SetAccessorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddHandlerAccessorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MidExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CallStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CharacterLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TrueLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DateLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotEqualsExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LessThanExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GreaterThanExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IsExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddressOfExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.BinaryConditionalExpression
					Label0:
						Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindExpression(node, diagnostics)
						If (boundExpression1.HasErrors) Then
							boundExpression1 = Me.MakeRValue(boundExpression1, diagnostics)
						ElseIf (eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_None) Then
							boundExpression1 = Me.MakeRValue(boundExpression1, diagnostics)
						Else
							Binder.ReportDiagnostic(diagnostics, node, eRRID)
							boundExpression1 = Me.MakeRValueAndIgnoreDiagnostics(boundExpression1)
						End If
						boundParenthesized = boundExpression1
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineFunctionLambdaExpression
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineSubLambdaExpression
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MultiLineFunctionLambdaExpression
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MultiLineSubLambdaExpression
						eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_LambdaInSelectCaseExpr
						GoTo Label0
					Case Else
						GoTo Label0
				End Select
			End If
			Return boundParenthesized
		End Function

		Private Function BindSimpleCaseClause(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleCaseClauseSyntax, ByVal selectExpressionOpt As BoundRValuePlaceholder, ByVal convertCaseElements As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundCaseClause
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindCaseClauseExpression(node.Value, node, selectExpressionOpt, SyntaxKind.EqualsToken, BinaryOperatorKind.Equals, convertCaseElements, boundExpression, diagnostics)
			Return New BoundSimpleCaseClause(node, boundExpression1, boundExpression, False)
		End Function

		Private Function BindSimpleName(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax, ByVal isInvocationOrAddressOf As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal skipLocalsAndParameters As Boolean = False) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim valueText As String
			Dim typeArgumentList As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax
			If (node.Kind() <> SyntaxKind.GenericName) Then
				typeArgumentList = Nothing
				valueText = DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax).Identifier.ValueText
			Else
				Dim genericNameSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax = DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax)
				typeArgumentList = genericNameSyntax.TypeArgumentList
				valueText = genericNameSyntax.Identifier.ValueText
			End If
			If (Not [String].IsNullOrEmpty(valueText)) Then
				Dim lookupOption As LookupOptions = LookupOptions.AllMethodsOfAnyArity
				If (isInvocationOrAddressOf) Then
					lookupOption = lookupOption Or LookupOptions.MustNotBeReturnValueVariable
				End If
				If (skipLocalsAndParameters) Then
					lookupOption = lookupOption Or LookupOptions.MustNotBeLocalOrParameter
				End If
				If (node.Kind() = SyntaxKind.IdentifierName AndAlso DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax).Identifier.IsBracketed() AndAlso Binder.MemberLookup.GetTypeForIntrinsicAlias(valueText) <> SpecialType.None) Then
					lookupOption = lookupOption Or LookupOptions.AllowIntrinsicAliases
				End If
				Dim num As Integer = If(typeArgumentList IsNot Nothing, typeArgumentList.Arguments.Count, 0)
				Dim instance As LookupResult = LookupResult.GetInstance()
				Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
				Me.Lookup(instance, valueText, num, lookupOption, newCompoundUseSiteInfo)
				diagnostics.Add(node, newCompoundUseSiteInfo)
				If (Not instance.IsGoodOrAmbiguous AndAlso Me.ImplicitVariableDeclarationAllowed AndAlso Not Me.AllImplicitVariableDeclarationsAreHandled AndAlso Binder.CanBeImplicitVariableDeclaration(node)) Then
					instance.SetFrom(Me.DeclareImplicitLocalVariable(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax), diagnostics))
				End If
				If (instance.HasSymbol) Then
					Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindSimpleName(instance, node, lookupOption, typeArgumentList, diagnostics)
					instance.Free()
					boundExpression = boundExpression1
				Else
					instance.Free()
					Dim str As String = Nothing
					Dim flag As Boolean = False
					If (Not Me.LookupXmlNamespace(valueText, True, str, flag)) Then
						Dim awaitInNonAsyncError As DiagnosticInfo = Nothing
						If (node.Kind() = SyntaxKind.IdentifierName AndAlso KeywordTable.TokenOfString(valueText) = SyntaxKind.AwaitKeyword) Then
							awaitInNonAsyncError = Me.GetAwaitInNonAsyncError()
						End If
						If (awaitInNonAsyncError Is Nothing) Then
							awaitInNonAsyncError = If(Not CaseInsensitiveComparison.Equals("My", valueText) OrElse Not Me.Compilation.Options.EmbedVbCoreRuntime, ErrorFactory.ErrorInfo(If(Me.IsInQuery, ERRID.ERR_QueryNameNotDeclared, ERRID.ERR_NameNotDeclared1), New [Object]() { valueText }), ErrorFactory.ErrorInfo(ERRID.ERR_PlatformDoesntSupport, New [Object]() { "My" }))
						End If
						boundExpression = Binder.ReportDiagnosticAndProduceBadExpression(diagnostics, node, awaitInNonAsyncError, New Microsoft.CodeAnalysis.VisualBasic.BoundExpression(-1) {})
					Else
						boundExpression = Binder.ReportDiagnosticAndProduceBadExpression(diagnostics, node, ERRID.ERR_XmlPrefixNotExpression, New [Object]() { valueText })
					End If
				End If
			Else
				boundExpression = Binder.BadExpression(node, ErrorTypeSymbol.UnknownResultType)
			End If
			Return boundExpression
		End Function

		Private Function BindSimpleName(ByVal result As LookupResult, ByVal node As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal options As LookupOptions, ByVal typeArguments As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim containingType As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = Me.ContainingType
			If (containingType IsNot Nothing) Then
				If (containingType.IsScriptClass) Then
					Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = result.Symbols(0).ContainingType
					If (namedTypeSymbol IsNot Nothing) Then
						boundExpression = Me.TryBindInteractiveReceiver(node, Me.ContainingMember, containingType, namedTypeSymbol)
					End If
				End If
				If (boundExpression Is Nothing) Then
					Dim item As Symbol = result.Symbols(0)
					If (item.IsReducedExtensionMethod() OrElse Binder.BindSimpleNameIsMemberOfType(item, containingType)) Then
						boundExpression = Me.CreateMeReference(node, True)
					End If
				End If
			End If
			Return Me.BindSymbolAccess(node, result, options, boundExpression, typeArguments, QualificationKind.Unqualified, diagnostics)
		End Function

		Private Shared Function BindSimpleNameIsMemberOfType(ByVal member As Symbol, ByVal type As NamedTypeSymbol) As Boolean
			Dim flag As Boolean
			Dim kind As SymbolKind = member.Kind
			If (CInt(kind) - CInt(SymbolKind.[Event]) <= CInt(SymbolKind.ArrayType) OrElse kind = SymbolKind.Method OrElse kind = SymbolKind.[Property]) Then
				Dim containingType As NamedTypeSymbol = member.ContainingType
				If (containingType IsNot Nothing) Then
					Dim baseTypeNoUseSiteDiagnostics As NamedTypeSymbol = type
					While baseTypeNoUseSiteDiagnostics IsNot Nothing
						If (Not containingType.Equals(baseTypeNoUseSiteDiagnostics)) Then
							baseTypeNoUseSiteDiagnostics = baseTypeNoUseSiteDiagnostics.BaseTypeNoUseSiteDiagnostics
						Else
							flag = True
							Return flag
						End If
					End While
				Else
					flag = False
					Return flag
				End If
			End If
			flag = False
			Return flag
		End Function

		Private Function BindSingleLineIfStatement(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineIfStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundStatement
			Dim boundStatement As Microsoft.CodeAnalysis.VisualBasic.BoundStatement = Nothing
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindBooleanExpression(node.Condition, diagnostics)
			Dim boundBlock As Microsoft.CodeAnalysis.VisualBasic.BoundBlock = Me.BindBlock(node, node.Statements, diagnostics).MakeCompilerGenerated()
			If (node.ElseClause IsNot Nothing) Then
				boundStatement = Me.BindBlock(node.ElseClause, node.ElseClause.Statements, diagnostics)
			End If
			Return New BoundIfStatement(node, boundExpression, boundBlock, boundStatement, False)
		End Function

		Private Function BindSkipClause(ByVal source As BoundQueryClauseBase, ByVal skip As Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundQueryClause
			Return Me.BindPartitionClause(source, skip, "Skip", diagnostics)
		End Function

		Private Function BindSkipWhileClause(ByVal source As BoundQueryClauseBase, ByVal skipWhile As Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundQueryClause
			Dim skipOrTakeKeyword As Microsoft.CodeAnalysis.SyntaxToken = skipWhile.SkipOrTakeKeyword
			Dim whileKeyword As Microsoft.CodeAnalysis.SyntaxToken = skipWhile.WhileKeyword
			Return Me.BindFilterQueryOperator(source, skipWhile, "SkipWhile", Binder.GetQueryOperatorNameSpan(skipOrTakeKeyword, whileKeyword), skipWhile.Condition, diagnostics)
		End Function

		Private Function BindStandAloneCaseStatement(ByVal caseStatement As Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundBadStatement
			Dim boundCaseStatement As Microsoft.CodeAnalysis.VisualBasic.BoundCaseStatement = Me.BindCaseStatement(caseStatement, Nothing, False, diagnostics)
			Dim instance As ArrayBuilder(Of BoundNode) = ArrayBuilder(Of BoundNode).GetInstance(boundCaseStatement.CaseClauses.Length)
			Dim enumerator As ImmutableArray(Of BoundCaseClause).Enumerator = boundCaseStatement.CaseClauses.GetEnumerator()
			While enumerator.MoveNext()
				Dim current As BoundCaseClause = enumerator.Current
				Select Case current.Kind
					Case BoundKind.SimpleCaseClause
					Case BoundKind.RelationalCaseClause
						instance.Add(DirectCast(current, BoundSingleValueCaseClause).ValueOpt)
						Continue While
					Case BoundKind.RangeCaseClause
						Dim boundRangeCaseClause As Microsoft.CodeAnalysis.VisualBasic.BoundRangeCaseClause = DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.BoundRangeCaseClause)
						instance.Add(boundRangeCaseClause.LowerBoundOpt)
						instance.Add(boundRangeCaseClause.UpperBoundOpt)
						Continue While
				End Select
				Throw ExceptionUtilities.UnexpectedValue(current.Kind)
			End While
			Return New BoundBadStatement(caseStatement, instance.ToImmutableAndFree(), True)
		End Function

		Public Overridable Function BindStatement(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim boundBadStatement As BoundStatement
			Dim empty As ImmutableArray(Of BoundNode)
			Dim boundNodes As ImmutableArray(Of BoundNode)
			Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = node.Kind()
			If (syntaxKind <= Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IncompleteMember) Then
				If (syntaxKind > Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSyncLockStatement) Then
					If (CUShort(syntaxKind) - CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SubBlock) > CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSelectStatement)) Then
						If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IncompleteMember) Then
							boundBadStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement(node, ImmutableArray(Of BoundNode).Empty, True)
							Return boundBadStatement
						End If
						boundBadStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement(node, ImmutableArray(Of BoundNode).Empty, True)
						Return boundBadStatement
					End If
					boundBadStatement = Me.BindMethodBlock(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax), diagnostics)
				Else
					If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement) Then
						If (CUShort(syntaxKind) - CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndIfStatement) <= CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndAddHandlerStatement)) Then
							boundBadStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement(node, ImmutableArray(Of BoundNode).Empty, True)
							Return boundBadStatement
						End If
						boundBadStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement(node, ImmutableArray(Of BoundNode).Empty, True)
						Return boundBadStatement
					End If
					boundBadStatement = New BoundNoOpStatement(node)
				End If
			ElseIf (syntaxKind <= Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EraseStatement) Then
				Select Case syntaxKind
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExpressionStatement
						boundBadStatement = Me.BindExpressionStatement(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionStatementSyntax), diagnostics)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PrintStatement
						boundBadStatement = Me.BindPrintStatement(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.PrintStatementSyntax), diagnostics)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WhileBlock
						boundBadStatement = Me.BindWhileBlock(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileBlockSyntax), diagnostics)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndUsingStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSelectStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndEnumStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndClassStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndNamespaceStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamedFieldInitializer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Parameter Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ArrayRankSpecifier Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Attribute Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AttributesStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PrintStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndIfStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndUsingStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndWithStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSelectStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndStructureStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndEnumStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndInterfaceStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndClassStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndModuleStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndNamespaceStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSubStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamedFieldInitializer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EqualsValue Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Parameter Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ModifiedIdentifier Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ArrayRankSpecifier Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AttributeList Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Attribute Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AttributeTarget Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AttributesStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExpressionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PrintStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WhileBlock
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IdentifierLabel
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NumericLabel
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NextLabel
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSelectStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndEnumStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndRaiseEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndTryStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamedFieldInitializer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Attribute Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AttributesStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UsingBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NextLabel
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSelectStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndStructureStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndEnumStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndInterfaceStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndGetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndPropertyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndRaiseEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndWhileStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndTryStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSyncLockStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamedFieldInitializer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EqualsValue Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Attribute Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AttributeTarget Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AttributesStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExpressionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UsingBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SyncLockBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LocalDeclarationStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NextLabel Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.StopStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitOperatorStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineIfPart
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineElseClause
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndUsingStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSelectStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndEnumStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndClassStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndNamespaceStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CompilationUnit Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ImportsStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleImportsClause Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamedFieldInitializer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Parameter Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ArrayRankSpecifier Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Attribute Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AttributesStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PrintStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitPropertyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitSelectStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ContinueWhileStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ContinueForStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineIfStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineElseClause
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndIfStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndUsingStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndWithStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSelectStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndStructureStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndEnumStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndInterfaceStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndClassStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndModuleStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndNamespaceStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSubStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CompilationUnit Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OptionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ImportsStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleImportsClause Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlNamespaceImportsClause Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamedFieldInitializer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EqualsValue Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Parameter Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ModifiedIdentifier Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ArrayRankSpecifier Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AttributeList Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Attribute Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AttributeTarget Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AttributesStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExpressionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PrintStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WhileBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitOperatorStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitPropertyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitTryStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitSelectStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitWhileStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ContinueWhileStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ContinueDoStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ContinueForStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ReturnStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineIfStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineIfPart Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineElseClause Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MultiLineIfBlock
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamespaceBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamedFieldInitializer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UsingBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitFunctionStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndGetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamespaceBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamespaceStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamedFieldInitializer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EqualsValue Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UsingBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SyncLockBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitOperatorStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamespaceBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ModuleBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamedFieldInitializer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UsingBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitPropertyStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndGetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndPropertyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamespaceBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamespaceStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ModuleBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.StructureBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamedFieldInitializer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EqualsValue Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UsingBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SyncLockBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LocalDeclarationStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitOperatorStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitPropertyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitTryStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ElseIfBlock
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ElseBlock
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IfStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ElseStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSelectStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndEnumStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndRaiseEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndTryStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ImportsStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamespaceBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ModuleBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ImplementsStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamedFieldInitializer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Attribute Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AttributesStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UsingBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NextLabel Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitPropertyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ContinueForStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineIfStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ElseStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CatchBlock
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FinallyBlock
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TryStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CatchFilterClause
					Case 192
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamedFieldInitializer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EqualsValue
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SelectStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndIfStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSelectStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndStructureStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndClassStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndModuleStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NewConstraint Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ClassConstraint Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamedFieldInitializer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EqualsValue Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Parameter Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ModifiedIdentifier Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Attribute Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AttributeTarget Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PrintStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WhileBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OnErrorGoToZeroStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OnErrorGoToMinusOneStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ResumeStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ResumeLabelStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SelectStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndUsingStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSelectStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndEnumStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndClassStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndNamespaceStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeParameterList Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeParameterSingleConstraintClause Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NewConstraint Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.StructureConstraint Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EnumMemberDeclaration Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamedFieldInitializer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Parameter Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ArrayRankSpecifier Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Attribute Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AttributesStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PrintStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FinallyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OnErrorGoToZeroStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OnErrorGoToLabelStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ResumeStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ResumeNextStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SelectStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CaseBlock
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamedFieldInitializer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UsingBlock
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndGetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ConstructorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamedFieldInitializer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EqualsValue Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UsingBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SyncLockBlock
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CaseElseBlock
						boundBadStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement(node, ImmutableArray(Of BoundNode).Empty, True)
						Return boundBadStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UsingBlock
						boundBadStatement = Me.BindUsingBlock(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingBlockSyntax), diagnostics)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SyncLockBlock
						boundBadStatement = Me.BindSyncLockBlock(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockBlockSyntax), diagnostics)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithBlock
						boundBadStatement = Me.BindWithBlock(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.WithBlockSyntax), diagnostics)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LocalDeclarationStatement
						boundBadStatement = Me.BindLocalDeclaration(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.LocalDeclarationStatementSyntax), diagnostics)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LabelStatement
						boundBadStatement = Me.BindLabelStatement(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax), diagnostics)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GoToStatement
						boundBadStatement = Me.BindGoToStatement(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.GoToStatementSyntax), diagnostics)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.StopStatement
						boundBadStatement = Me.BindStopStatement(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.StopOrEndStatementSyntax))
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndStatement
						boundBadStatement = Me.BindEndStatement(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.StopOrEndStatementSyntax), diagnostics)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitDoStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitForStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitSubStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitFunctionStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitPropertyStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitTryStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitSelectStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitWhileStatement
						boundBadStatement = Me.BindExitStatement(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax), diagnostics)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ContinueWhileStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ContinueDoStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ContinueForStatement
						boundBadStatement = Me.BindContinueStatement(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax), diagnostics)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ReturnStatement
						boundBadStatement = Me.BindReturn(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.ReturnStatementSyntax), diagnostics)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineIfStatement
						boundBadStatement = Me.BindSingleLineIfStatement(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineIfStatementSyntax), diagnostics)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MultiLineIfBlock
						boundBadStatement = Me.BindMultiLineIfBlock(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineIfBlockSyntax), diagnostics)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ElseIfStatement
						Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindBooleanExpression(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfStatementSyntax).Condition, diagnostics)
						boundBadStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement(node, ImmutableArray.Create(Of BoundNode)(boundExpression), True)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TryBlock
						boundBadStatement = Me.BindTryBlock(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.TryBlockSyntax), diagnostics)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CatchStatement
						If (node.Parent.Kind() = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CatchBlock) Then
							boundBadStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement(node, ImmutableArray(Of BoundNode).Empty, True)
							Return boundBadStatement
						End If
						Dim whenClause As Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchFilterClauseSyntax = DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax).WhenClause
						If (whenClause Is Nothing) Then
							boundNodes = ImmutableArray(Of BoundNode).Empty
						Else
							boundNodes = ImmutableArray.Create(Of BoundNode)(Me.BindBooleanExpression(whenClause.Filter, diagnostics))
						End If
						boundBadStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement(node, boundNodes, True)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FinallyStatement
						boundBadStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement(node, ImmutableArray(Of BoundNode).Empty, True)
						Return boundBadStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ErrorStatement
						boundBadStatement = Me.BindError(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.ErrorStatementSyntax), diagnostics)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OnErrorGoToZeroStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OnErrorGoToMinusOneStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OnErrorGoToLabelStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OnErrorResumeNextStatement
						boundBadStatement = Me.BindOnErrorStatement(node, diagnostics)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ResumeStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ResumeLabelStatement
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ResumeNextStatement
						boundBadStatement = Me.BindResumeStatement(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax), diagnostics)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SelectBlock
						boundBadStatement = Me.BindSelectBlock(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectBlockSyntax), diagnostics)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CaseStatement
						boundBadStatement = Me.BindStandAloneCaseStatement(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax), diagnostics)
						Exit Select
					Case Else
						Select Case syntaxKind
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ForBlock
								boundBadStatement = Me.BindForToBlock(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax), diagnostics)

							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ForEachBlock
								boundBadStatement = Me.BindForEachBlock(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax), diagnostics)

							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ForStatement
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ForStepClause
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ForEachStatement
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UsingStatement
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndOperatorStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamespaceBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InterfaceBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SetAccessorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DeclareSubStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ImplementsClause Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithEventsPropertyEventContainer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamedFieldInitializer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Parameter Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UsingBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LabelStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitSelectStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ElseIfBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OnErrorGoToZeroStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CaseElseStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ForStepClause
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndIfStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndGetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndOperatorStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamespaceBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamespaceStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InterfaceBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ClassBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ConstructorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SetAccessorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddHandlerAccessorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DeclareSubStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DeclareFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ImplementsClause Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.HandlesClause Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithEventsPropertyEventContainer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.HandlesClauseItem Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NamedFieldInitializer Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EqualsValue Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.Parameter Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ModifiedIdentifier Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UsingBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SyncLockBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LabelStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GoToStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitOperatorStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitSelectStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExitWhileStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ElseIfBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ElseBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OnErrorGoToZeroStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OnErrorGoToMinusOneStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CaseElseStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ElseCaseClause Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ForStepClause Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ForEachStatement
							Case 256
							Case 257
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MidExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithStatement
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSelectStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndClassStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MidExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RaiseEventStatement
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndIfStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSelectStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndStructureStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndClassStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndModuleStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MidExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CallStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RaiseEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithStatement
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RedimClause
								boundBadStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement(node, ImmutableArray(Of BoundNode).Empty, True)
								Return boundBadStatement
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NextStatement
								boundBadStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement(node, ImmutableArray(Of BoundNode).Empty, True)
								Return boundBadStatement
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ThrowStatement
								boundBadStatement = Me.BindThrow(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.ThrowStatementSyntax), diagnostics)

							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleAssignmentStatement
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddAssignmentStatement
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SubtractAssignmentStatement
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MultiplyAssignmentStatement
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DivideAssignmentStatement
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IntegerDivideAssignmentStatement
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ExponentiateAssignmentStatement
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LeftShiftAssignmentStatement
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RightShiftAssignmentStatement
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ConcatenateAssignmentStatement
								boundBadStatement = Me.BindAssignmentStatement(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax), diagnostics)

							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MidAssignmentStatement
								boundBadStatement = Me.BindMidAssignmentStatement(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax), diagnostics)

							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CallStatement
								boundBadStatement = Me.BindCallStatement(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.CallStatementSyntax), diagnostics)

							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddHandlerStatement
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RemoveHandlerStatement
								boundBadStatement = Me.BindAddRemoveHandlerStatement(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax), diagnostics)

							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RaiseEventStatement
								boundBadStatement = Me.BindRaiseEventStatement(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.RaiseEventStatementSyntax), diagnostics)

							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ReDimStatement
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ReDimPreserveStatement
								boundBadStatement = Me.BindRedimStatement(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax), diagnostics)

							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EraseStatement
								boundBadStatement = Me.BindEraseStatement(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.EraseStatementSyntax), diagnostics)

							Case Else
								boundBadStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement(node, ImmutableArray(Of BoundNode).Empty, True)
								Return boundBadStatement
						End Select

				End Select
			ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.YieldStatement) Then
				boundBadStatement = Me.BindYield(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.YieldStatementSyntax), diagnostics)
			ElseIf (CUShort(syntaxKind) - CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleDoLoopBlock) <= 4) Then
				boundBadStatement = Me.BindDoLoop(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax), diagnostics)
			ElseIf (CUShort(syntaxKind) - CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleLoopStatement) <= CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement)) Then
				If (SyntaxFacts.IsDoLoopBlock(node.Parent.Kind())) Then
					boundBadStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement(node, ImmutableArray(Of BoundNode).Empty, True)
					Return boundBadStatement
				End If
				Dim whileOrUntilClause As Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax = DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax).WhileOrUntilClause
				If (whileOrUntilClause Is Nothing) Then
					empty = ImmutableArray(Of BoundNode).Empty
				Else
					empty = ImmutableArray.Create(Of BoundNode)(Me.BindBooleanExpression(whileOrUntilClause.Condition, diagnostics))
				End If
				boundBadStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement(node, empty, True)
			Else
				boundBadStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement(node, ImmutableArray(Of BoundNode).Empty, True)
				Return boundBadStatement
			End If
			Return boundBadStatement
		End Function

		Private Function BindStopStatement(ByVal stopStatementSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.StopOrEndStatementSyntax) As BoundStatement
			Return New BoundStopStatement(stopStatementSyntax)
		End Function

		Private Function BindSubsequentQueryOperators(ByVal source As BoundQueryClauseBase, ByVal operators As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundQueryClauseBase
			While operators.MoveNext()
				Dim current As Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax = operators.Current
				Select Case current.Kind()
					Case SyntaxKind.FromClause
						source = Me.BindFromClause(source, DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax), operators, diagnostics)
						Continue While
					Case SyntaxKind.LetClause
						source = Me.BindLetClause(source, DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax), operators, diagnostics, False)
						Continue While
					Case SyntaxKind.AggregateClause
						source = Me.BindAggregateClause(source, DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax), operators, diagnostics)
						Continue While
					Case SyntaxKind.DistinctClause
						source = Me.BindDistinctClause(source, DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.DistinctClauseSyntax), diagnostics)
						Continue While
					Case SyntaxKind.WhereClause
						source = Me.BindWhereClause(source, DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.WhereClauseSyntax), diagnostics)
						Continue While
					Case SyntaxKind.SkipWhileClause
						source = Me.BindSkipWhileClause(source, DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax), diagnostics)
						Continue While
					Case SyntaxKind.TakeWhileClause
						source = Me.BindTakeWhileClause(source, DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax), diagnostics)
						Continue While
					Case SyntaxKind.SkipClause
						source = Me.BindSkipClause(source, DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax), diagnostics)
						Continue While
					Case SyntaxKind.TakeClause
						source = Me.BindTakeClause(source, DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax), diagnostics)
						Continue While
					Case SyntaxKind.GroupByClause
						source = Me.BindGroupByClause(source, DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax), diagnostics)
						Continue While
					Case SyntaxKind.JoinCondition
					Case SyntaxKind.List Or SyntaxKind.EndIfStatement Or SyntaxKind.EndFunctionStatement Or SyntaxKind.EndGetStatement Or SyntaxKind.EndOperatorStatement Or SyntaxKind.EndEventStatement Or SyntaxKind.NamespaceBlock Or SyntaxKind.NamespaceStatement Or SyntaxKind.InterfaceBlock Or SyntaxKind.ClassBlock Or SyntaxKind.FunctionBlock Or SyntaxKind.ConstructorBlock Or SyntaxKind.SetAccessorBlock Or SyntaxKind.AddHandlerAccessorBlock Or SyntaxKind.DeclareSubStatement Or SyntaxKind.DeclareFunctionStatement Or SyntaxKind.ImplementsClause Or SyntaxKind.HandlesClause Or SyntaxKind.WithEventsPropertyEventContainer Or SyntaxKind.HandlesClauseItem Or SyntaxKind.MidExpression Or SyntaxKind.CallStatement Or SyntaxKind.CharacterLiteralExpression Or SyntaxKind.TrueLiteralExpression Or SyntaxKind.DateLiteralExpression Or SyntaxKind.DictionaryAccessExpression Or SyntaxKind.XmlElementAccessExpression Or SyntaxKind.DirectCastExpression Or SyntaxKind.TryCastExpression Or SyntaxKind.SubtractExpression Or SyntaxKind.MultiplyExpression Or SyntaxKind.NotEqualsExpression Or SyntaxKind.LessThanExpression Or SyntaxKind.GreaterThanExpression Or SyntaxKind.IsExpression Or SyntaxKind.AddressOfExpression Or SyntaxKind.BinaryConditionalExpression Or SyntaxKind.QueryExpression Or SyntaxKind.CollectionRangeVariable Or SyntaxKind.VariableNameEquals Or SyntaxKind.FunctionAggregation Or SyntaxKind.GroupByClause Or SyntaxKind.JoinCondition Or SyntaxKind.OrderByClause
					Case SyntaxKind.EmptyStatement Or SyntaxKind.EndUsingStatement Or SyntaxKind.EndFunctionStatement Or SyntaxKind.EndSetStatement Or SyntaxKind.EndOperatorStatement Or SyntaxKind.EndAddHandlerStatement Or SyntaxKind.CompilationUnit Or SyntaxKind.NamespaceBlock Or SyntaxKind.ModuleBlock Or SyntaxKind.InterfaceBlock Or SyntaxKind.EnumBlock Or SyntaxKind.TypeParameterList Or SyntaxKind.TypeParameterSingleConstraintClause Or SyntaxKind.FunctionBlock Or SyntaxKind.OperatorBlock Or SyntaxKind.SetAccessorBlock Or SyntaxKind.RemoveHandlerAccessorBlock Or SyntaxKind.DeclareSubStatement Or SyntaxKind.DelegateSubStatement Or SyntaxKind.EventStatement Or SyntaxKind.ImplementsClause Or SyntaxKind.KeywordEventContainer Or SyntaxKind.WithEventsPropertyEventContainer Or SyntaxKind.IncompleteMember Or SyntaxKind.RightShiftAssignmentStatement Or SyntaxKind.MidExpression Or SyntaxKind.AddHandlerStatement Or SyntaxKind.CharacterLiteralExpression Or SyntaxKind.FalseLiteralExpression Or SyntaxKind.DateLiteralExpression Or SyntaxKind.GetXmlNamespaceExpression Or SyntaxKind.DictionaryAccessExpression Or SyntaxKind.XmlDescendantAccessExpression Or SyntaxKind.DirectCastExpression Or SyntaxKind.PredefinedCastExpression Or SyntaxKind.SubtractExpression Or SyntaxKind.DivideExpression Or SyntaxKind.NotEqualsExpression Or SyntaxKind.LessThanOrEqualExpression Or SyntaxKind.GreaterThanExpression Or SyntaxKind.IsNotExpression Or SyntaxKind.AddressOfExpression Or SyntaxKind.TernaryConditionalExpression Or SyntaxKind.SingleLineSubLambdaExpression Or SyntaxKind.QueryExpression Or SyntaxKind.ExpressionRangeVariable Or SyntaxKind.VariableNameEquals Or SyntaxKind.GroupAggregation Or SyntaxKind.GroupByClause Or SyntaxKind.SimpleJoinClause Or SyntaxKind.OrderByClause
					Case SyntaxKind.AscendingOrdering
					Case SyntaxKind.DescendingOrdering
						Throw ExceptionUtilities.UnexpectedValue(current.Kind())
					Case SyntaxKind.SimpleJoinClause
						source = Me.BindInnerJoinClause(source, DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax), Nothing, operators, diagnostics)
						Continue While
					Case SyntaxKind.GroupJoinClause
						source = Me.BindGroupJoinClause(source, DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax), Nothing, operators, diagnostics)
						Continue While
					Case SyntaxKind.OrderByClause
						source = Me.BindOrderByClause(source, DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderByClauseSyntax), diagnostics)
						Continue While
					Case SyntaxKind.SelectClause
						source = Me.BindSelectClause(source, DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax), operators, diagnostics)
						Continue While
					Case Else
						Throw ExceptionUtilities.UnexpectedValue(current.Kind())
				End Select
			End While
			Return source
		End Function

		Private Function BindSymbolAccess(ByVal node As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal lookupOptionsUsed As LookupOptions, ByVal receiver As BoundExpression, ByVal typeArgumentsOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax, ByVal qualKind As QualificationKind, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim boundTypeExpression As BoundExpression
			Dim symbols As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbol)
			Dim empty As ImmutableArray(Of BoundExpression)
			Dim hasErrors As Boolean = False
			If (receiver IsNot Nothing) Then
				hasErrors = receiver.HasErrors
				receiver = Me.AdjustReceiverNamespace(lookupResult, receiver)
			End If
			Dim flag As Boolean = False
			Dim kind As Microsoft.CodeAnalysis.VisualBasic.LookupResultKind = lookupResult.Kind
			If (Not lookupResult.HasDiagnostic OrElse (lookupResult.Symbols(0).Kind = Microsoft.CodeAnalysis.SymbolKind.Method OrElse lookupResult.Symbols(0).Kind = Microsoft.CodeAnalysis.SymbolKind.[Property]) AndAlso kind = Microsoft.CodeAnalysis.VisualBasic.LookupResultKind.Inaccessible) Then
				Select Case lookupResult.Symbols(0).Kind
					Case Microsoft.CodeAnalysis.SymbolKind.[Alias]
						Dim singleSymbol As AliasSymbol = DirectCast(lookupResult.SingleSymbol, AliasSymbol)
						Dim target As NamespaceOrTypeSymbol = singleSymbol.Target
						Dim symbolKind As Microsoft.CodeAnalysis.SymbolKind = target.Kind
						If (symbolKind = Microsoft.CodeAnalysis.SymbolKind.ErrorType OrElse symbolKind = Microsoft.CodeAnalysis.SymbolKind.NamedType) Then
							If (Not flag) Then
								Binder.ReportUseSite(diagnostics, node, target)
							End If
							boundTypeExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundTypeExpression(node, Nothing, singleSymbol, DirectCast(target, Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol), hasErrors)
							Exit Select
						Else
							If (symbolKind <> Microsoft.CodeAnalysis.SymbolKind.[Namespace]) Then
								Throw ExceptionUtilities.UnexpectedValue(target.Kind)
							End If
							boundTypeExpression = New BoundNamespaceExpression(node, Nothing, singleSymbol, DirectCast(target, NamespaceSymbol), hasErrors)
							Exit Select
						End If
					Case Microsoft.CodeAnalysis.SymbolKind.ArrayType
					Case Microsoft.CodeAnalysis.SymbolKind.Assembly
					Case Microsoft.CodeAnalysis.SymbolKind.DynamicType
					Case Microsoft.CodeAnalysis.SymbolKind.Label
					Case Microsoft.CodeAnalysis.SymbolKind.NetModule
					Case Microsoft.CodeAnalysis.SymbolKind.PointerType
						Throw ExceptionUtilities.UnexpectedValue(lookupResult.Symbols(0).Kind)
					Case Microsoft.CodeAnalysis.SymbolKind.ErrorType
					Case Microsoft.CodeAnalysis.SymbolKind.NamedType
						Dim boundTypeArgument As BoundTypeArguments = Nothing
						If (typeArgumentsOpt IsNot Nothing) Then
							boundTypeArgument = Me.BindTypeArguments(typeArgumentsOpt, diagnostics)
						End If
						Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = TryCast(lookupResult.SingleSymbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)
						If (namedTypeSymbol IsNot Nothing AndAlso boundTypeArgument IsNot Nothing) Then
							Dim namedTypeSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = Me.ConstructAndValidateConstraints(namedTypeSymbol, boundTypeArgument.Arguments, node, typeArgumentsOpt.Arguments, diagnostics)
							lookupResult.ReplaceSymbol(namedTypeSymbol1)
						End If
						Me.ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagnostics, namedTypeSymbol, node)
						If (Not hasErrors) Then
							receiver = Me.AdjustReceiverTypeOrValue(receiver, node, True, diagnostics, qualKind)
							hasErrors = Me.CheckSharedSymbolAccess(node, True, receiver, qualKind, diagnostics)
						End If
						If (Not flag) Then
							Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
							Dim syntaxNodeOrToken As Microsoft.CodeAnalysis.SyntaxNodeOrToken = node
							Dim symbol As Microsoft.CodeAnalysis.VisualBasic.Symbol = namedTypeSymbol
							If (symbol Is Nothing) Then
								symbol = lookupResult.SingleSymbol
							End If
							Binder.ReportUseSite(bindingDiagnosticBag, syntaxNodeOrToken, symbol)
						End If
						Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = DirectCast(lookupResult.SingleSymbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)
						Dim simpleNameSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax = TryCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax)
						If (simpleNameSyntax IsNot Nothing AndAlso Not typeSymbol.IsErrorType()) Then
							Binder.VerifyTypeCharacterConsistency(simpleNameSyntax, typeSymbol.GetEnumUnderlyingTypeOrSelf(), diagnostics)
						End If
						boundTypeExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundTypeExpression(node, receiver, Nothing, typeSymbol, hasErrors)
						Exit Select
					Case Microsoft.CodeAnalysis.SymbolKind.[Event]
						Dim eventSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.EventSymbol = DirectCast(lookupResult.SingleSymbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.EventSymbol)
						If (eventSymbol.IsShared And qualKind = QualificationKind.Unqualified) Then
							receiver = Nothing
						End If
						If (Not flag) Then
							Binder.ReportUseSite(diagnostics, node, eventSymbol)
						End If
						If (Not hasErrors) Then
							If (receiver IsNot Nothing AndAlso receiver.Kind = BoundKind.TypeOrValueExpression) Then
								receiver = Me.AdjustReceiverTypeOrValue(receiver, node, eventSymbol.IsShared, diagnostics, qualKind)
							End If
							hasErrors = Me.CheckSharedSymbolAccess(node, eventSymbol.IsShared, receiver, qualKind, diagnostics)
						End If
						Me.ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagnostics, eventSymbol, node)
						If (receiver IsNot Nothing AndAlso receiver.IsPropertyOrXmlPropertyAccess()) Then
							receiver = Me.MakeRValue(receiver, diagnostics)
						End If
						boundTypeExpression = New BoundEventAccess(node, receiver, eventSymbol, eventSymbol.Type, hasErrors)
						Exit Select
					Case Microsoft.CodeAnalysis.SymbolKind.Field
						Dim fieldSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol = DirectCast(lookupResult.SingleSymbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol)
						If (fieldSymbol.IsShared And qualKind = QualificationKind.Unqualified) Then
							receiver = Nothing
						End If
						If (Not hasErrors) Then
							If (receiver IsNot Nothing AndAlso receiver.Kind = BoundKind.TypeOrValueExpression) Then
								receiver = Me.AdjustReceiverTypeOrValue(receiver, node, fieldSymbol.IsShared, diagnostics, qualKind)
							End If
							hasErrors = Me.CheckSharedSymbolAccess(node, fieldSymbol.IsShared, receiver, qualKind, diagnostics)
						End If
						If (Not flag AndAlso Not Binder.ReportUseSite(diagnostics, node, fieldSymbol)) Then
							Me.CheckMemberTypeAccessibility(diagnostics, node, fieldSymbol)
						End If
						Me.ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagnostics, fieldSymbol, node)
						Dim inferredType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = fieldSymbol.GetInferredType(Me.ConstantFieldsInProgress)
						Dim memberAccessExpressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax = TryCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax)
						If (memberAccessExpressionSyntax IsNot Nothing AndAlso Not inferredType.IsErrorType()) Then
							Binder.VerifyTypeCharacterConsistency(memberAccessExpressionSyntax.Name, inferredType.GetEnumUnderlyingTypeOrSelf(), diagnostics)
						End If
						If (receiver IsNot Nothing AndAlso receiver.IsPropertyOrXmlPropertyAccess()) Then
							receiver = Me.MakeRValue(receiver, diagnostics)
						End If
						boundTypeExpression = New BoundFieldAccess(node, receiver, fieldSymbol, Me.IsLValueFieldAccess(fieldSymbol, receiver), False, Me.ConstantFieldsInProgress, inferredType, If(hasErrors, True, inferredType.IsErrorType()))
						Exit Select
					Case Microsoft.CodeAnalysis.SymbolKind.Local
						Dim localSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol = DirectCast(lookupResult.SingleSymbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol)
						If (localSymbol.IsFunctionValue AndAlso Not Binder.IsNameOfArgument(node)) Then
							Dim containingSymbol As MethodSymbol = DirectCast(localSymbol.ContainingSymbol, MethodSymbol)
							If (containingSymbol.IsAsync OrElse containingSymbol.IsIterator) Then
								Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_BadResumableAccessReturnVariable)
								boundTypeExpression = Binder.BadExpression(node, ErrorTypeSymbol.UnknownResultType)
								Exit Select
							End If
						End If
						Dim localSymbolType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Me.GetLocalSymbolType(localSymbol, node, diagnostics)
						Dim simpleNameSyntax1 As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax = TryCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax)
						If (simpleNameSyntax1 IsNot Nothing AndAlso Not localSymbolType.IsErrorType()) Then
							Binder.VerifyTypeCharacterConsistency(simpleNameSyntax1, localSymbolType.GetEnumUnderlyingTypeOrSelf(), diagnostics)
						End If
						If (localSymbol.IsFor) Then
							Dim containingSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbol = localSymbol.ContainingSymbol
							If (CObj(Me.ContainingMember) <> CObj(containingSymbol1)) Then
								If (Not Binder.IsTopMostEnclosingLambdaAQueryLambda(Me.ContainingMember, containingSymbol1)) Then
									Binder.ReportDiagnostic(diagnostics, node, ERRID.WRN_LiftControlVariableLambda, New [Object]() { localSymbol.Name })
								Else
									Binder.ReportDiagnostic(diagnostics, node, ERRID.WRN_LiftControlVariableQuery, New [Object]() { localSymbol.Name })
								End If
							End If
						End If
						boundTypeExpression = New BoundLocal(node, localSymbol, localSymbolType, hasErrors)
						Exit Select
					Case Microsoft.CodeAnalysis.SymbolKind.Method
						boundTypeExpression = Me.CreateBoundMethodGroup(node, lookupResult, lookupOptionsUsed, diagnostics.AccumulatesDependencies, receiver, Me.BindTypeArguments(typeArgumentsOpt, diagnostics), qualKind, hasErrors)
						Exit Select
					Case Microsoft.CodeAnalysis.SymbolKind.[Namespace]
						boundTypeExpression = New BoundNamespaceExpression(node, receiver, DirectCast(lookupResult.SingleSymbol, NamespaceSymbol), hasErrors)
						Exit Select
					Case Microsoft.CodeAnalysis.SymbolKind.Parameter
						Dim parameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol = DirectCast(lookupResult.SingleSymbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol)
						Dim type As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = parameterSymbol.Type
						Dim simpleNameSyntax2 As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax = TryCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax)
						If (simpleNameSyntax2 IsNot Nothing AndAlso Not type.IsErrorType()) Then
							Binder.VerifyTypeCharacterConsistency(simpleNameSyntax2, type.GetEnumUnderlyingTypeOrSelf(), diagnostics)
						End If
						boundTypeExpression = New BoundParameter(node, parameterSymbol, type, hasErrors)
						Exit Select
					Case Microsoft.CodeAnalysis.SymbolKind.[Property]
						boundTypeExpression = New BoundPropertyGroup(node, lookupResult.Symbols.ToDowncastedImmutable(Of PropertySymbol)(), lookupResult.Kind, receiver, qualKind, hasErrors)
						Exit Select
					Case Microsoft.CodeAnalysis.SymbolKind.RangeVariable
						Dim rangeVariableSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol = DirectCast(lookupResult.SingleSymbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)
						boundTypeExpression = New BoundRangeVariable(node, rangeVariableSymbol, rangeVariableSymbol.Type, hasErrors)
						Exit Select
					Case Microsoft.CodeAnalysis.SymbolKind.TypeParameter
						boundTypeExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundTypeExpression(node, DirectCast(lookupResult.SingleSymbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol), hasErrors)
						Exit Select
					Case Else
						Throw ExceptionUtilities.UnexpectedValue(lookupResult.Symbols(0).Kind)
				End Select
			Else
				Dim diagnostic As DiagnosticInfo = lookupResult.Diagnostic
				If (Not hasErrors) Then
					If (typeArgumentsOpt Is Nothing OrElse lookupResult.Kind <> Microsoft.CodeAnalysis.VisualBasic.LookupResultKind.WrongArity AndAlso lookupResult.Kind <> Microsoft.CodeAnalysis.VisualBasic.LookupResultKind.WrongArityAndStopLookup) Then
						Binder.ReportDiagnostic(diagnostics, node, diagnostic)
					Else
						Binder.ReportDiagnostic(diagnostics, typeArgumentsOpt, diagnostic)
					End If
					If (diagnostic.Severity = DiagnosticSeverity.[Error]) Then
						hasErrors = True
						flag = True
					End If
				End If
				symbols = If(Not TypeOf diagnostic Is AmbiguousSymbolDiagnostic, lookupResult.Symbols.ToImmutable(), DirectCast(diagnostic, AmbiguousSymbolDiagnostic).AmbiguousSymbols)
				Dim visualBasicSyntaxNode As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode = node
				Dim lookupResultKind As Microsoft.CodeAnalysis.VisualBasic.LookupResultKind = lookupResult.Kind
				Dim symbols1 As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbol) = symbols
				If (receiver IsNot Nothing) Then
					empty = ImmutableArray.Create(Of BoundExpression)(receiver)
				Else
					empty = ImmutableArray(Of BoundExpression).Empty
				End If
				boundTypeExpression = New BoundBadExpression(visualBasicSyntaxNode, lookupResultKind, symbols1, empty, Me.GetCommonExpressionTypeForErrorRecovery(node, symbols, Me.ConstantFieldsInProgress), True)
			End If
			Return boundTypeExpression
		End Function

		Public Function BindSyncLockBlock(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockBlockSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundSyncLockStatement
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindRValue(node.SyncLockStatement.Expression, diagnostics, False)
			Dim type As TypeSymbol = boundExpression.Type
			If (Not boundExpression.HasErrors AndAlso Not type.IsReferenceType) Then
				Binder.ReportDiagnostic(diagnostics, boundExpression.Syntax, ErrorFactory.ErrorInfo(ERRID.ERR_SyncLockRequiresReferenceType1, New [Object]() { type }))
			End If
			Dim boundBlock As Microsoft.CodeAnalysis.VisualBasic.BoundBlock = Me.BindBlock(node, node.Statements, diagnostics).MakeCompilerGenerated()
			Return New BoundSyncLockStatement(node, boundExpression, boundBlock, False)
		End Function

		Private Function BindTakeClause(ByVal source As BoundQueryClauseBase, ByVal take As Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundQueryClause
			Return Me.BindPartitionClause(source, take, "Take", diagnostics)
		End Function

		Private Function BindTakeWhileClause(ByVal source As BoundQueryClauseBase, ByVal takeWhile As Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundQueryClause
			Dim skipOrTakeKeyword As Microsoft.CodeAnalysis.SyntaxToken = takeWhile.SkipOrTakeKeyword
			Dim whileKeyword As Microsoft.CodeAnalysis.SyntaxToken = takeWhile.WhileKeyword
			Return Me.BindFilterQueryOperator(source, takeWhile, "TakeWhile", Binder.GetQueryOperatorNameSpan(skipOrTakeKeyword, whileKeyword), takeWhile.Condition, diagnostics)
		End Function

		Private Function BindTernaryConditionalExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim specialType As TypeSymbol
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindBooleanExpression(node.Condition, diagnostics)
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindValue(node.WhenTrue, diagnostics, False)
			Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindValue(node.WhenFalse, diagnostics, False)
			Dim flag As Boolean = If(boundExpression.HasErrors OrElse boundExpression1.HasErrors, True, boundExpression2.HasErrors)
			If (Not boundExpression1.IsNothingLiteral() OrElse Not boundExpression2.IsNothingLiteral()) Then
				Dim num As Integer = 0
				Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance(2)
				instance.Add(boundExpression1)
				instance.Add(boundExpression2)
				Dim inferenceErrorReason As InferenceErrorReasons = InferenceErrorReasons.Other
				specialType = Me.InferDominantTypeOfExpressions(node, instance, diagnostics, num, inferenceErrorReason)
				instance.Free()
				If (Not flag) Then
					flag = Me.GenerateDiagnosticsForDominantTypeInferenceInIfExpression(specialType, num, node, diagnostics)
				End If
			Else
				specialType = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Object, node, diagnostics)
			End If
			If (Not flag OrElse specialType IsNot Nothing) Then
				boundExpression1 = Me.ApplyImplicitConversion(node.WhenTrue, specialType, boundExpression1, diagnostics, False)
				boundExpression2 = Me.ApplyImplicitConversion(node.WhenFalse, specialType, boundExpression2, diagnostics, False)
				flag = If(flag OrElse boundExpression1.HasErrors, True, boundExpression2.HasErrors)
			Else
				boundExpression1 = Me.MakeRValueAndIgnoreDiagnostics(boundExpression1)
				boundExpression2 = Me.MakeRValueAndIgnoreDiagnostics(boundExpression2)
			End If
			Dim constantValue As Microsoft.CodeAnalysis.ConstantValue = Nothing
			If (Not flag AndAlso Binder.IsConstantAllowingCompileTimeFolding(boundExpression1) AndAlso Binder.IsConstantAllowingCompileTimeFolding(boundExpression2) AndAlso Binder.IsConstantAllowingCompileTimeFolding(boundExpression)) Then
				constantValue = If(boundExpression.ConstantValueOpt.BooleanValue, boundExpression1.ConstantValueOpt, boundExpression2.ConstantValueOpt)
			End If
			Dim ternaryConditionalExpressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax = node
			Dim boundExpression3 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = boundExpression
			Dim boundExpression4 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = boundExpression1
			Dim boundExpression5 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = boundExpression2
			Dim constantValue1 As Microsoft.CodeAnalysis.ConstantValue = constantValue
			Dim unknownResultType As Object = specialType
			If (unknownResultType Is Nothing) Then
				unknownResultType = ErrorTypeSymbol.UnknownResultType
			End If
			Return New BoundTernaryConditionalExpression(ternaryConditionalExpressionSyntax, boundExpression3, boundExpression4, boundExpression5, constantValue1, unknownResultType, flag)
		End Function

		Private Function BindThrow(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ThrowStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim boundThrowStatement As BoundStatement
			Dim expression As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = node.Expression
			Dim flag As Boolean = False
			If (expression IsNot Nothing) Then
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindRValue(expression, diagnostics, False)
				Dim type As TypeSymbol = boundExpression.Type
				If (type.IsErrorType()) Then
					flag = True
				Else
					Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
					If (Not type.IsOrDerivedFromWellKnownClass(WellKnownType.System_Exception, Me.Compilation, newCompoundUseSiteInfo)) Then
						flag = True
						Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_CantThrowNonException, New [Object]() { type })
					End If
					diagnostics.Add(node, newCompoundUseSiteInfo)
				End If
				boundThrowStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundThrowStatement(node, boundExpression, flag)
			Else
				Dim parent As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode = node.Parent
				Dim flag1 As Boolean = False
				While parent IsNot Nothing
					Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = parent.Kind()
					If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CatchBlock) Then
						flag1 = True
						Exit While
					Else
						If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FinallyBlock) Then
							Exit While
						End If
						Select Case syntaxKind
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineFunctionLambdaExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleLineSubLambdaExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MultiLineFunctionLambdaExpression
							Label0:
								parent = parent.Parent
								Continue While
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndOperatorStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SetAccessorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MidExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CharacterLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DateLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotEqualsExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GreaterThanExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddressOfExpression
							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndIfStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndGetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndOperatorStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ConstructorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SetAccessorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddHandlerAccessorBlock Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MidExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CallStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CharacterLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TrueLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DateLiteralExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotEqualsExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LessThanExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GreaterThanExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IsExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddressOfExpression Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.BinaryConditionalExpression
							Label1:
								If (Not TypeOf parent Is Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax) Then
									GoTo Label0
								End If

							Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MultiLineSubLambdaExpression
								Exit Select
							Case Else
								GoTo Label1
						End Select
					End If
				End While
				If (Not flag1) Then
					flag = True
					Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_MustBeInCatchToRethrow)
				End If
				boundThrowStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundThrowStatement(node, Nothing, flag)
			End If
			Return boundThrowStatement
		End Function

		Public Function BindTryBlock(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.TryBlockSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundTryStatement
			Dim boundBlock As Microsoft.CodeAnalysis.VisualBasic.BoundBlock
			Dim boundBlock1 As Microsoft.CodeAnalysis.VisualBasic.BoundBlock = Me.BindBlock(node, node.Statements, diagnostics).MakeCompilerGenerated()
			Dim boundCatchBlocks As ImmutableArray(Of BoundCatchBlock) = Me.BindCatchBlocks(node.CatchBlocks, diagnostics)
			If (node.FinallyBlock Is Nothing) Then
				boundBlock = Nothing
			Else
				boundBlock = Me.GetBinder(node.FinallyBlock).BindBlock(node.FinallyBlock, node.FinallyBlock.Statements, diagnostics)
			End If
			If (boundCatchBlocks.IsEmpty AndAlso boundBlock Is Nothing) Then
				Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagnostics, node.TryStatement, ERRID.ERR_TryWithoutCatchOrFinally)
			End If
			Dim binder As Microsoft.CodeAnalysis.VisualBasic.Binder = Me.GetBinder(node)
			Return New BoundTryStatement(node, boundBlock1, boundCatchBlocks, boundBlock, binder.GetExitLabel(SyntaxKind.ExitTryStatement), False)
		End Function

		Private Function BindTryCastExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindValue(node.Expression, diagnostics, False)
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Me.BindTypeSyntax(node.Type, diagnostics, False, False, False)
			Return Me.ApplyTryCastConversion(node, boundExpression, typeSymbol, diagnostics)
		End Function

		Private Function BindTupleExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundTupleLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim name As Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax
			Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol
			Dim empty As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)
			Dim arguments As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax) = node.Arguments
			Dim count As Integer = arguments.Count
			If (count >= 2) Then
				Dim flag As Boolean = True
				Dim flag1 As Boolean = True
				Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance(arguments.Count)
				Dim typeSymbols As ArrayBuilder(Of TypeSymbol) = ArrayBuilder(Of TypeSymbol).GetInstance(arguments.Count)
				Dim locations As ArrayBuilder(Of Location) = ArrayBuilder(Of Location).GetInstance(arguments.Count)
				Dim valueTuple As ValueTuple(Of ImmutableArray(Of String), ImmutableArray(Of Boolean), Boolean) = Binder.ExtractTupleElementNames(arguments, diagnostics)
				Dim item1 As ImmutableArray(Of String) = valueTuple.Item1
				Dim item2 As ImmutableArray(Of Boolean) = valueTuple.Item2
				Dim item3 As Boolean = valueTuple.Item3
				Dim num As Integer = count - 1
				Dim num1 As Integer = 0
				Do
					Dim item As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax = arguments(num1)
					Dim nameColonEquals As Microsoft.CodeAnalysis.VisualBasic.Syntax.NameColonEqualsSyntax = item.NameColonEquals
					If (nameColonEquals IsNot Nothing) Then
						name = nameColonEquals.Name
					Else
						name = Nothing
					End If
					Dim identifierNameSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax = name
					If (identifierNameSyntax Is Nothing) Then
						locations.Add(item.GetLocation())
					Else
						locations.Add(identifierNameSyntax.GetLocation())
						If (identifierNameSyntax.Identifier.GetTypeCharacter() <> TypeCharacter.None) Then
							Binder.ReportDiagnostic(diagnostics, identifierNameSyntax, ERRID.ERR_TupleLiteralDisallowsTypeChar)
						End If
					End If
					Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindValue(item.Expression, diagnostics, False)
					Dim tupleFieldType As TypeSymbol = Me.GetTupleFieldType(boundExpression, item, diagnostics, flag)
					If (tupleFieldType Is Nothing) Then
						flag1 = False
					End If
					If (boundExpression.Type IsNot Nothing) Then
						boundExpression = Me.MakeRValue(boundExpression, diagnostics)
					End If
					instance.Add(boundExpression)
					typeSymbols.Add(tupleFieldType)
					num1 = num1 + 1
				Loop While num1 <= num
				Dim immutableAndFree As ImmutableArray(Of TypeSymbol) = typeSymbols.ToImmutableAndFree()
				Dim immutableAndFree1 As ImmutableArray(Of Location) = locations.ToImmutableAndFree()
				Dim tupleTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TupleTypeSymbol = Nothing
				If (flag1) Then
					Dim flag2 As Boolean = Me.Compilation.LanguageVersion.DisallowInferredTupleElementNames()
					tupleTypeSymbol = Microsoft.CodeAnalysis.VisualBasic.Symbols.TupleTypeSymbol.Create(node.GetLocation(), immutableAndFree, immutableAndFree1, item1, Me.Compilation, True, If(flag2, item2, New ImmutableArray(Of Boolean)()), node, diagnostics)
				End If
				If (flag) Then
					namedTypeSymbol = tupleTypeSymbol
				Else
					namedTypeSymbol = Nothing
				End If
				Dim namedTypeSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = namedTypeSymbol
				boundTupleLiteral = New Microsoft.CodeAnalysis.VisualBasic.BoundTupleLiteral(node, tupleTypeSymbol, item1, item2, instance.ToImmutableAndFree(), namedTypeSymbol1, item3)
			Else
				If (count = 1) Then
					empty = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(Me.BindRValue(arguments(0).Expression, diagnostics, False))
				Else
					empty = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty
				End If
				boundTupleLiteral = Binder.BadExpression(node, empty, ErrorTypeSymbol.UnknownResultType)
			End If
			Return boundTupleLiteral
		End Function

		Private Function BindTypeArguments(ByVal typeArgumentsOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundTypeArguments
			Dim boundTypeArgument As BoundTypeArguments
			If (typeArgumentsOpt IsNot Nothing) Then
				Dim arguments As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax) = typeArgumentsOpt.Arguments
				Dim typeSymbolArray(arguments.Count - 1 + 1 - 1) As TypeSymbol
				Dim count As Integer = arguments.Count - 1
				Dim num As Integer = 0
				Do
					typeSymbolArray(num) = Me.BindTypeSyntax(arguments(num), diagnostics, False, False, False)
					num = num + 1
				Loop While num <= count
				boundTypeArgument = New BoundTypeArguments(typeArgumentsOpt, Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of TypeSymbol)(typeSymbolArray))
			Else
				boundTypeArgument = Nothing
			End If
			Return boundTypeArgument
		End Function

		Private Function BindTypeOfExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundTypeOf As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindRValue(node.Expression, diagnostics, False)
			Dim type As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = boundExpression.Type
			Dim flag As Boolean = node.Kind() = SyntaxKind.TypeOfIsNotExpression
			Dim symbol As Microsoft.CodeAnalysis.VisualBasic.Symbol = Me.BindTypeOrAliasSyntax(node.Type, diagnostics, False)
			Dim target As NamespaceOrTypeSymbol = TryCast(symbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)
			If (target Is Nothing) Then
				target = DirectCast(symbol, AliasSymbol).Target
			End If
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = DirectCast(target, Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)
			Dim specialType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Boolean, node, diagnostics)
			If (boundExpression.HasErrors OrElse type.IsErrorType() OrElse typeSymbol.IsErrorType()) Then
				boundTypeOf = New Microsoft.CodeAnalysis.VisualBasic.BoundTypeOf(node, boundExpression, flag, typeSymbol, specialType, False)
			Else
				If (type.IsReferenceType OrElse type.IsTypeParameter()) Then
					Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
					Dim conversionKind As Microsoft.CodeAnalysis.VisualBasic.ConversionKind = Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyTryCastConversion(type, typeSymbol, newCompoundUseSiteInfo)
					If (diagnostics.Add(node, newCompoundUseSiteInfo)) Then
						diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
					ElseIf (Not Microsoft.CodeAnalysis.VisualBasic.Conversions.ConversionExists(conversionKind)) Then
						Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_TypeOfExprAlwaysFalse2, New [Object]() { type, typeSymbol })
					End If
				Else
					Binder.ReportDiagnostic(diagnostics, node.Expression, ERRID.ERR_TypeOfRequiresReferenceType1, New [Object]() { type })
				End If
				If (type.IsTypeParameter()) Then
					boundExpression = Me.ApplyImplicitConversion(node, Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Object, node.Expression, diagnostics), boundExpression, diagnostics, False)
				End If
				boundTypeOf = New Microsoft.CodeAnalysis.VisualBasic.BoundTypeOf(node, boundExpression, flag, typeSymbol, specialType, False)
			End If
			Return boundTypeOf
		End Function

		Friend Function BindTypeOrAliasSyntax(ByVal typeSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal suppressUseSiteError As Boolean = False) As Microsoft.CodeAnalysis.VisualBasic.Symbol
			Dim symbol As Microsoft.CodeAnalysis.VisualBasic.Symbol = Binder.TypeBinder.BindTypeOrAliasSyntax(typeSyntax, Me, diagBag, suppressUseSiteError, False, False)
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = TryCast(symbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)
			If (typeSymbol IsNot Nothing) Then
				Binder.ReportUseOfModuleOrVoidType(typeSyntax, typeSymbol, diagBag)
			End If
			Return symbol
		End Function

		Private Sub BindTypeParameterConstraint(ByVal containingSymbol As Symbol, ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax, ByRef constraints As TypeParameterConstraintKind, ByVal constraintsBuilder As ArrayBuilder(Of TypeParameterConstraint), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Select Case syntax.Kind()
				Case SyntaxKind.NewConstraint
					If ((CInt(constraints) And 4) <> 0) Then
						Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_MultipleNewConstraints)
						Return
					End If
					If ((CInt(constraints) And 2) <> 0) Then
						Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_NewAndValueConstraintsCombined)
						Return
					End If
					constraints = CInt(constraints) Or 4
					constraintsBuilder.Add(New TypeParameterConstraint(TypeParameterConstraintKind.Constructor, syntax.GetLocation()))
					Return
				Case SyntaxKind.ClassConstraint
					If ((CInt(constraints) And 1) <> 0) Then
						Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_MultipleReferenceConstraints)
						Return
					End If
					If ((CInt(constraints) And 2) <> 0) Then
						Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_RefAndValueConstraintsCombined)
						Return
					End If
					constraints = CInt(constraints) Or 1
					constraintsBuilder.Add(New TypeParameterConstraint(TypeParameterConstraintKind.ReferenceType, syntax.GetLocation()))
					Return
				Case SyntaxKind.StructureConstraint
					If ((CInt(constraints) And 2) <> 0) Then
						Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_MultipleValueConstraints)
						Return
					End If
					If ((CInt(constraints) And 4) <> 0) Then
						Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_NewAndValueConstraintsCombined)
						Return
					End If
					If ((CInt(constraints) And 1) <> 0) Then
						Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_RefAndValueConstraintsCombined)
						Return
					End If
					constraints = CInt(constraints) Or 2
					constraintsBuilder.Add(New TypeParameterConstraint(TypeParameterConstraintKind.ValueType, syntax.GetLocation()))
					Return
				Case SyntaxKind.TypeConstraint
					Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = TryCast(Me.BindTypeOrAliasSyntax(DirectCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeConstraintSyntax).Type, diagnostics, False).UnwrapAlias(), Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)
					If (typeSymbol Is Nothing) Then
						Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_UnrecognizedType)
						Return
					End If
					constraintsBuilder.Add(New TypeParameterConstraint(typeSymbol, syntax.GetLocation()))
					AccessCheck.VerifyAccessExposureForMemberType(containingSymbol, syntax, typeSymbol, diagnostics, False)
					Return
			End Select
			Throw ExceptionUtilities.UnexpectedValue(syntax.Kind())
		End Sub

		Friend Function BindTypeParameterConstraintClause(ByVal containingSymbol As Symbol, ByVal clause As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterConstraintClauseSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As ImmutableArray(Of TypeParameterConstraint)
			Dim immutableAndFree As ImmutableArray(Of TypeParameterConstraint)
			If (clause IsNot Nothing) Then
				Dim typeParameterConstraintKind As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterConstraintKind = Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterConstraintKind.None
				Dim instance As ArrayBuilder(Of TypeParameterConstraint) = ArrayBuilder(Of TypeParameterConstraint).GetInstance()
				Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = clause.Kind()
				If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeParameterSingleConstraintClause) Then
					Me.BindTypeParameterConstraint(containingSymbol, DirectCast(clause, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSingleConstraintClauseSyntax).Constraint, typeParameterConstraintKind, instance, diagnostics)
				Else
					If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TypeParameterMultipleConstraintClause) Then
						Throw ExceptionUtilities.UnexpectedValue(clause.Kind())
					End If
					Dim enumerator As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax).Enumerator = DirectCast(clause, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterMultipleConstraintClauseSyntax).Constraints.GetEnumerator()
					While enumerator.MoveNext()
						Dim current As Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax = enumerator.Current
						Me.BindTypeParameterConstraint(containingSymbol, current, typeParameterConstraintKind, instance, diagnostics)
					End While
				End If
				immutableAndFree = instance.ToImmutableAndFree()
			Else
				immutableAndFree = ImmutableArray(Of TypeParameterConstraint).Empty
			End If
			Return immutableAndFree
		End Function

		Public Function BindTypeSyntax(ByVal typeSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal suppressUseSiteError As Boolean = False, Optional ByVal inGetTypeContext As Boolean = False, Optional ByVal resolvingBaseType As Boolean = False) As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Binder.TypeBinder.BindTypeSyntax(typeSyntax, Me, diagBag, suppressUseSiteError, resolvingBaseType)
			If (Not inGetTypeContext) Then
				Binder.ReportUseOfModuleOrVoidType(typeSyntax, typeSymbol, diagBag)
			End If
			Return typeSymbol
		End Function

		Private Function BindUnaryOperator(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundUnaryOperator As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim operatorToken As Microsoft.CodeAnalysis.SyntaxToken
			Dim candidate As OverloadResolution.Candidate
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindValue(node.Operand, diagnostics, False)
			Dim unaryOperatorKind As Microsoft.CodeAnalysis.VisualBasic.UnaryOperatorKind = OverloadResolution.MapUnaryOperatorKind(node.Kind())
			If (boundExpression.HasErrors OrElse Not boundExpression.IsNothingLiteral()) Then
				boundExpression = Me.MakeRValue(boundExpression, diagnostics)
			Else
				Dim specialType As NamedTypeSymbol = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Int32, node.Operand, diagnostics)
				boundExpression = Me.ApplyImplicitConversion(node.Operand, specialType, boundExpression, diagnostics, False)
			End If
			If (boundExpression.HasErrors) Then
				diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
			End If
			Dim specialType1 As Microsoft.CodeAnalysis.SpecialType = Microsoft.CodeAnalysis.SpecialType.None
			Dim overloadResolutionResult As OverloadResolution.OverloadResolutionResult = New OverloadResolution.OverloadResolutionResult()
			Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
			Dim unaryOperatorKind1 As Microsoft.CodeAnalysis.VisualBasic.UnaryOperatorKind = OverloadResolution.ResolveUnaryOperator(unaryOperatorKind, boundExpression, Me, specialType1, overloadResolutionResult, newCompoundUseSiteInfo)
			If (diagnostics.Add(node, newCompoundUseSiteInfo)) Then
				diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
			End If
			If (unaryOperatorKind1 = Microsoft.CodeAnalysis.VisualBasic.UnaryOperatorKind.UserDefined) Then
				If (overloadResolutionResult.BestResult.HasValue) Then
					candidate = overloadResolutionResult.BestResult.Value.Candidate
				Else
					candidate = Nothing
				End If
				Dim candidate1 As OverloadResolution.Candidate = candidate
				If (candidate1 IsNot Nothing AndAlso candidate1.IsLifted AndAlso (Not OverloadResolution.IsValidInLiftedSignature(candidate1.Parameters(0).Type) OrElse Not OverloadResolution.IsValidInLiftedSignature(candidate1.ReturnType))) Then
					GoTo Label1
				End If
				boundUnaryOperator = Me.BindUserDefinedUnaryOperator(node, unaryOperatorKind, boundExpression, overloadResolutionResult, diagnostics)
				Return boundUnaryOperator
			End If
		Label2:
			If (unaryOperatorKind1 <> Microsoft.CodeAnalysis.VisualBasic.UnaryOperatorKind.[Error]) Then
				Dim type As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = boundExpression.Type
				Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
				If (specialType1 = Microsoft.CodeAnalysis.SpecialType.None) Then
					typeSymbol = type
				ElseIf (type.GetNullableUnderlyingTypeOrSelf().SpecialType <> specialType1) Then
					typeSymbol = Me.GetSpecialType(specialType1, node.Operand, diagnostics)
					If (type.IsNullableType()) Then
						typeSymbol = DirectCast(type.OriginalDefinition, NamedTypeSymbol).Construct(New Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol() { typeSymbol })
					End If
				Else
					typeSymbol = type
				End If
				If (type.SpecialType = Microsoft.CodeAnalysis.SpecialType.System_Object) Then
					If (Me.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.[On]) Then
						Dim operand As Microsoft.CodeAnalysis.SyntaxNodeOrToken = node.Operand
						operatorToken = node.OperatorToken
						Binder.ReportDiagnostic(diagnostics, operand, ErrorFactory.ErrorInfo(ERRID.ERR_StrictDisallowsObjectOperand1, operatorToken))
					ElseIf (Me.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.Custom) Then
						Dim syntaxNodeOrToken As Microsoft.CodeAnalysis.SyntaxNodeOrToken = node.Operand
						operatorToken = node.OperatorToken
						Binder.ReportDiagnostic(diagnostics, syntaxNodeOrToken, ErrorFactory.ErrorInfo(ERRID.WRN_ObjectMath2, operatorToken))
					End If
				End If
				boundExpression = Me.ApplyImplicitConversion(node.Operand, typeSymbol, boundExpression, diagnostics, False)
				Dim bad As ConstantValue = Nothing
				If (Not boundExpression.HasErrors) Then
					Dim flag As Boolean = False
					bad = OverloadResolution.TryFoldConstantUnaryOperator(unaryOperatorKind1, boundExpression, typeSymbol, flag)
					If (bad IsNot Nothing AndAlso (bad.IsBad OrElse flag)) Then
						Binder.ReportDiagnostic(diagnostics, node, ErrorFactory.ErrorInfo(ERRID.ERR_ExpressionOverflow1, New [Object]() { typeSymbol }))
						If (Not bad.IsBad) Then
							bad = ConstantValue.Bad
						End If
					End If
				End If
				boundUnaryOperator = New Microsoft.CodeAnalysis.VisualBasic.BoundUnaryOperator(node, unaryOperatorKind1, boundExpression, Me.CheckOverflow, bad, typeSymbol, False)
			Else
				Binder.ReportUndefinedOperatorError(node, boundExpression, diagnostics)
				boundUnaryOperator = New Microsoft.CodeAnalysis.VisualBasic.BoundUnaryOperator(node, unaryOperatorKind Or Microsoft.CodeAnalysis.VisualBasic.UnaryOperatorKind.[Error], boundExpression, Me.CheckOverflow, ErrorTypeSymbol.UnknownResultType, True)
			End If
			Return boundUnaryOperator
		Label1:
			unaryOperatorKind1 = Microsoft.CodeAnalysis.VisualBasic.UnaryOperatorKind.[Error]
			GoTo Label2
		End Function

		Friend Function BindUnboundLambda(ByVal source As UnboundLambda, ByVal target As UnboundLambda.TargetSignature) As BoundLambda
			' 
			' Current member / type: Microsoft.CodeAnalysis.VisualBasic.BoundLambda Microsoft.CodeAnalysis.VisualBasic.Binder::BindUnboundLambda(Microsoft.CodeAnalysis.VisualBasic.UnboundLambda,Microsoft.CodeAnalysis.VisualBasic.UnboundLambda/TargetSignature)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: Microsoft.CodeAnalysis.VisualBasic.BoundLambda BindUnboundLambda(Microsoft.CodeAnalysis.VisualBasic.UnboundLambda,Microsoft.CodeAnalysis.VisualBasic.UnboundLambda/TargetSignature)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Function

		Private Function BindUserDefinedNonShortCircuitingBinaryOperator(ByVal node As SyntaxNode, ByVal opKind As BinaryOperatorKind, ByVal left As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal right As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, <InAttribute> ByRef userDefinedOperator As OverloadResolution.OverloadResolutionResult, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundUserDefinedBinaryOperator
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			opKind = opKind Or BinaryOperatorKind.UserDefined
			If (Not userDefinedOperator.BestResult.HasValue) Then
				Dim boundExpressions As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(left, right)
				Dim strs As ImmutableArray(Of String) = New ImmutableArray(Of String)()
				boundExpression = Me.ReportOverloadResolutionFailureAndProduceBoundNode(node, LookupResultKind.Good, boundExpressions, strs, userDefinedOperator, diagnostics, Nothing, Nothing, Nothing, False, Nothing, Nothing, Nothing)
			Else
				Dim value As OverloadResolution.CandidateAnalysisResult = userDefinedOperator.BestResult.Value
				boundExpression = Me.CreateBoundCallOrPropertyAccess(node, node, TypeCharacter.None, (New BoundMethodGroup(node, Nothing, ImmutableArray.Create(Of MethodSymbol)(DirectCast(value.Candidate.UnderlyingSymbol, MethodSymbol)), LookupResultKind.Good, Nothing, QualificationKind.Unqualified, False)).MakeCompilerGenerated(), ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(left, right), value, userDefinedOperator.AsyncLambdaSubToFunctionMismatch, diagnostics, False)
				If (value.Candidate.IsLifted) Then
					opKind = opKind Or BinaryOperatorKind.Lifted
				End If
			End If
			Return New BoundUserDefinedBinaryOperator(node, opKind, boundExpression, Me.CheckOverflow, boundExpression.Type, False)
		End Function

		Private Function BindUserDefinedShortCircuitingOperator(ByVal node As SyntaxNode, ByVal opKind As Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind, ByVal left As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal right As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, <InAttribute> ByRef bitwiseOperator As OverloadResolution.OverloadResolutionResult, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundUserDefinedShortCircuitingOperator
			Dim returnType As TypeSymbol
			Dim boundUserDefinedBinaryOperator As Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedBinaryOperator
			Dim overloadResolutionResult As OverloadResolution.OverloadResolutionResult
			Dim binaryOperatorKind As Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind = If(opKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.[AndAlso], 21, 19) Or 128
			Dim item As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim boundRValuePlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder = Nothing
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim flag As Boolean = False
			If (bitwiseOperator.BestResult.HasValue) Then
				Dim value As OverloadResolution.CandidateAnalysisResult = bitwiseOperator.BestResult.Value
				Dim candidate As OverloadResolution.Candidate = value.Candidate
				returnType = candidate.ReturnType
				If (candidate.IsLifted) Then
					binaryOperatorKind = binaryOperatorKind Or Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.Lifted
				End If
				If (Not returnType.IsSameTypeIgnoringAll(candidate.Parameters(0).Type) OrElse Not returnType.IsSameTypeIgnoringAll(candidate.Parameters(1).Type)) Then
					Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
					Dim syntaxNodeOrToken As Microsoft.CodeAnalysis.SyntaxNodeOrToken = node
					Dim underlyingSymbol() As [Object] = { candidate.UnderlyingSymbol, candidate.UnderlyingSymbol.ContainingType, Nothing }
					underlyingSymbol(2) = SyntaxFacts.GetText(If(opKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.[AndAlso], SyntaxKind.AndAlsoKeyword, SyntaxKind.OrElseKeyword))
					Binder.ReportDiagnostic(bindingDiagnosticBag, syntaxNodeOrToken, ERRID.ERR_UnacceptableLogicalOperator3, underlyingSymbol)
					boundUserDefinedBinaryOperator = Me.BindUserDefinedNonShortCircuitingBinaryOperator(node, binaryOperatorKind, left, right, bitwiseOperator, Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded)
					flag = True
				Else
					boundRValuePlaceholder = (New Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder(left.Syntax, returnType)).MakeCompilerGenerated()
					Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
					overloadResolutionResult = If(opKind <> Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.[AndAlso], OverloadResolution.ResolveIsTrueOperator(boundRValuePlaceholder, Me, newCompoundUseSiteInfo), OverloadResolution.ResolveIsFalseOperator(boundRValuePlaceholder, Me, newCompoundUseSiteInfo))
					If (diagnostics.Add(node, newCompoundUseSiteInfo)) Then
						diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
					End If
					If (overloadResolutionResult.BestResult.HasValue) Then
						Dim candidate1 As OverloadResolution.Candidate = overloadResolutionResult.BestResult.Value.Candidate
						If (returnType.IsSameTypeIgnoringAll(candidate1.Parameters(0).Type)) Then
							Dim valueTuple As ValueTuple(Of ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression), BitVector) = Me.PassArguments(node, value, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(left, right), diagnostics)
							value.ConversionsOpt = New ImmutableArray(Of KeyValuePair(Of ConversionKind, MethodSymbol))()
							boundUserDefinedBinaryOperator = New Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedBinaryOperator(node, binaryOperatorKind, Me.CreateBoundCallOrPropertyAccess(node, node, TypeCharacter.None, (New BoundMethodGroup(node, Nothing, ImmutableArray.Create(Of MethodSymbol)(DirectCast(candidate.UnderlyingSymbol, MethodSymbol)), LookupResultKind.Good, Nothing, QualificationKind.Unqualified, False)).MakeCompilerGenerated(), ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundRValuePlaceholder, valueTuple.Item1(1)), value, bitwiseOperator.AsyncLambdaSubToFunctionMismatch, diagnostics, False), Me.CheckOverflow, returnType, False)
							item = valueTuple.Item1(0)
						Else
							Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_BinaryOperands3, New [Object]() { SyntaxFacts.GetText(If(opKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.[AndAlso], SyntaxKind.AndAlsoKeyword, SyntaxKind.OrElseKeyword)), left.Type, right.Type })
							flag = True
							diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
							boundUserDefinedBinaryOperator = Me.BindUserDefinedNonShortCircuitingBinaryOperator(node, binaryOperatorKind, left, right, bitwiseOperator, diagnostics)
						End If
						Dim boundUserDefinedUnaryOperator As Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedUnaryOperator = Me.BindUserDefinedUnaryOperator(node, If(opKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.[AndAlso], UnaryOperatorKind.IsFalse, UnaryOperatorKind.IsTrue), boundRValuePlaceholder, overloadResolutionResult, diagnostics).MakeCompilerGenerated()
						boundUserDefinedUnaryOperator.UnderlyingExpression.SetWasCompilerGenerated()
						If (flag) Then
							boundRValuePlaceholder = Nothing
						End If
						If (Not candidate1.IsLifted) Then
							boundExpression = boundUserDefinedUnaryOperator
						Else
							boundExpression = Binder.ApplyNullableIsTrueOperator(boundUserDefinedUnaryOperator, candidate1.ReturnType.GetNullableUnderlyingTypeOrSelf())
						End If
					Else
						Dim bindingDiagnosticBag1 As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
						Dim syntaxNodeOrToken1 As Microsoft.CodeAnalysis.SyntaxNodeOrToken = node
						Dim text() As [Object] = { returnType, Nothing, Nothing }
						text(1) = SyntaxFacts.GetText(If(opKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.[AndAlso], SyntaxKind.IsFalseKeyword, SyntaxKind.IsTrueKeyword))
						text(2) = SyntaxFacts.GetText(If(opKind = Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.[AndAlso], SyntaxKind.AndAlsoKeyword, SyntaxKind.OrElseKeyword))
						Binder.ReportDiagnostic(bindingDiagnosticBag1, syntaxNodeOrToken1, ERRID.ERR_ConditionOperatorRequired3, text)
						boundUserDefinedBinaryOperator = Me.BindUserDefinedNonShortCircuitingBinaryOperator(node, binaryOperatorKind, left, right, bitwiseOperator, Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded)
						boundRValuePlaceholder = Nothing
						flag = True
					End If
				End If
			Else
				boundUserDefinedBinaryOperator = Me.BindUserDefinedNonShortCircuitingBinaryOperator(node, binaryOperatorKind, left, right, bitwiseOperator, diagnostics)
				returnType = boundUserDefinedBinaryOperator.Type
				flag = True
			End If
			boundUserDefinedBinaryOperator.UnderlyingExpression.SetWasCompilerGenerated()
			boundUserDefinedBinaryOperator.SetWasCompilerGenerated()
			Return New BoundUserDefinedShortCircuitingOperator(node, item, boundRValuePlaceholder, boundExpression, boundUserDefinedBinaryOperator, returnType, flag)
		End Function

		Private Function BindUserDefinedUnaryOperator(ByVal node As SyntaxNode, ByVal opKind As UnaryOperatorKind, ByVal operand As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, <InAttribute> ByRef userDefinedOperator As OverloadResolution.OverloadResolutionResult, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundUserDefinedUnaryOperator
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			opKind = opKind Or UnaryOperatorKind.UserDefined
			If (Not userDefinedOperator.BestResult.HasValue) Then
				Dim boundExpressions As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(operand)
				Dim strs As ImmutableArray(Of String) = New ImmutableArray(Of String)()
				boundExpression = Me.ReportOverloadResolutionFailureAndProduceBoundNode(node, LookupResultKind.Good, boundExpressions, strs, userDefinedOperator, diagnostics, Nothing, Nothing, Nothing, False, Nothing, Nothing, Nothing)
			Else
				Dim value As OverloadResolution.CandidateAnalysisResult = userDefinedOperator.BestResult.Value
				boundExpression = Me.CreateBoundCallOrPropertyAccess(node, node, TypeCharacter.None, (New BoundMethodGroup(node, Nothing, ImmutableArray.Create(Of MethodSymbol)(DirectCast(value.Candidate.UnderlyingSymbol, MethodSymbol)), LookupResultKind.Good, Nothing, QualificationKind.Unqualified, False)).MakeCompilerGenerated(), ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(operand), value, userDefinedOperator.AsyncLambdaSubToFunctionMismatch, diagnostics, False)
				If (value.Candidate.IsLifted) Then
					opKind = opKind Or UnaryOperatorKind.Lifted
				End If
			End If
			Return New BoundUserDefinedUnaryOperator(node, opKind, boundExpression, boundExpression.Type, False)
		End Function

		Public Function BindUsingBlock(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingBlockSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim parent As SyntaxNode
			Dim binder As Microsoft.CodeAnalysis.VisualBasic.Binder = Me.GetBinder(node)
			Dim boundLocalDeclarationBases As ImmutableArray(Of BoundLocalDeclarationBase) = New ImmutableArray(Of BoundLocalDeclarationBase)()
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			Dim usingStatement As Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax = node.UsingStatement
			Dim variables As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax) = usingStatement.Variables
			Dim count As Integer = variables.Count
			Dim specialType As NamedTypeSymbol = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_IDisposable, node, diagnostics)
			Dim typeSymbols As Dictionary(Of TypeSymbol, ValueTuple(Of BoundRValuePlaceholder, Microsoft.CodeAnalysis.VisualBasic.BoundExpression, Microsoft.CodeAnalysis.VisualBasic.BoundExpression)) = New Dictionary(Of TypeSymbol, ValueTuple(Of BoundRValuePlaceholder, Microsoft.CodeAnalysis.VisualBasic.BoundExpression, Microsoft.CodeAnalysis.VisualBasic.BoundExpression))()
			If (count <= 0) Then
				Dim expression As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = usingStatement.Expression
				boundExpression = Me.BindRValue(expression, diagnostics, False)
				If (Not boundExpression.Type.IsErrorType() AndAlso Not specialType.IsErrorType()) Then
					Me.BuildAndVerifyUsingInfo(expression, boundExpression.Type, typeSymbols, specialType, diagnostics)
				End If
			Else
				boundLocalDeclarationBases = binder.BindVariableDeclarators(variables, diagnostics)
				Dim num As Integer = count - 1
				For i As Integer = 0 To num
					Dim item As BoundLocalDeclarationBase = boundLocalDeclarationBases(i)
					Dim syntax As SyntaxNode = item.Syntax
					If (item.Kind = BoundKind.AsNewLocalDeclarations) Then
						parent = syntax
					Else
						parent = syntax.Parent
						If (parent Is Nothing OrElse DirectCast(parent, Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax).Names.Count > 1) Then
							parent = syntax
						End If
					End If
					If (item.Kind <> BoundKind.LocalDeclaration) Then
						Dim boundAsNewLocalDeclaration As BoundAsNewLocalDeclarations = DirectCast(item, BoundAsNewLocalDeclarations)
						Dim length As Integer = boundAsNewLocalDeclaration.LocalDeclarations.Length - 1
						For j As Integer = 0 To length
							Dim boundLocalDeclaration As Microsoft.CodeAnalysis.VisualBasic.BoundLocalDeclaration = boundAsNewLocalDeclaration.LocalDeclarations(j)
							Me.VerifyUsingVariableDeclarationAndBuildUsingInfo(boundLocalDeclaration.Syntax, boundLocalDeclaration.LocalSymbol, specialType, typeSymbols, diagnostics)
						Next

					Else
						Dim boundLocalDeclaration1 As Microsoft.CodeAnalysis.VisualBasic.BoundLocalDeclaration = DirectCast(item, Microsoft.CodeAnalysis.VisualBasic.BoundLocalDeclaration)
						If (boundLocalDeclaration1.InitializerOpt Is Nothing) Then
							Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagnostics, parent, ErrorFactory.ErrorInfo(ERRID.ERR_UsingResourceVarNeedsInitializer))
						End If
						Me.VerifyUsingVariableDeclarationAndBuildUsingInfo(parent, boundLocalDeclaration1.LocalSymbol, specialType, typeSymbols, diagnostics)
					End If
				Next

			End If
			Dim boundBlock As Microsoft.CodeAnalysis.VisualBasic.BoundBlock = Me.BindBlock(node, node.Statements, diagnostics).MakeCompilerGenerated()
			Dim usingInfo As Microsoft.CodeAnalysis.VisualBasic.UsingInfo = New Microsoft.CodeAnalysis.VisualBasic.UsingInfo(node, typeSymbols)
			Dim usingBlockLocals As ImmutableArray(Of LocalSymbol) = Me.GetUsingBlockLocals(binder)
			Return New BoundUsingStatement(node, boundLocalDeclarationBases, boundExpression, boundBlock, usingInfo, usingBlockLocals, False)
		End Function

		Friend Function BindValue(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal isOperandOfConditionalBranch As Boolean = False) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindExpression(node, False, isOperandOfConditionalBranch, False, diagnostics)
			Return Me.MakeValue(boundExpression, diagnostics)
		End Function

		Friend Overridable Function BindVariableDeclaration(ByVal tree As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal name As Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax, ByVal asClauseOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax, ByVal equalsValueOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal skipAsNewInitializer As Boolean = False) As BoundLocalDeclaration
			Dim visualBasicSyntaxNode As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode
			Dim visualBasicSyntaxNode1 As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode
			Dim localForDeclaration As LocalSymbol = Me.GetLocalForDeclaration(name.Identifier)
			Dim constantExpression As BoundExpression = Nothing
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
			Dim boundExpressions As ImmutableArray(Of BoundExpression) = New ImmutableArray(Of BoundExpression)()
			If (name.ArrayBounds IsNot Nothing) Then
				boundExpressions = Me.BindArrayBounds(name.ArrayBounds, diagnostics, Nothing, False)
			End If
			Dim typeSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Me.ComputeVariableType(localForDeclaration, name, asClauseOpt, equalsValueOpt, constantExpression, typeSymbol, diagnostics)
			Me.VerifyLocalSymbolNameAndSetType(localForDeclaration, typeSymbol1, name, name.Identifier, diagnostics)
			Dim flag As Boolean = If(asClauseOpt Is Nothing, False, asClauseOpt.Kind() = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AsNewClause)
			If (asClauseOpt Is Nothing) Then
				visualBasicSyntaxNode = equalsValueOpt
			Else
				visualBasicSyntaxNode = asClauseOpt.Type()
			End If
			Dim visualBasicSyntaxNode2 As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode = visualBasicSyntaxNode
			Dim typeSymbol2 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
			If (typeSymbol1.IsRestrictedArrayType(typeSymbol2)) Then
				If (Not flag OrElse Not skipAsNewInitializer) Then
					Binder.ReportDiagnostic(diagnostics, visualBasicSyntaxNode2, ERRID.ERR_RestrictedType1, New [Object]() { typeSymbol2 })
				End If
			ElseIf (Not localForDeclaration.IsStatic) Then
				If ((Me.IsInAsyncContext() OrElse Me.IsInIteratorContext()) AndAlso typeSymbol1.IsRestrictedType() AndAlso (Not flag OrElse Not skipAsNewInitializer)) Then
					Binder.ReportDiagnostic(diagnostics, visualBasicSyntaxNode2, ERRID.ERR_CannotLiftRestrictedTypeResumable1, New [Object]() { typeSymbol1 })
				End If
			ElseIf (typeSymbol1.IsRestrictedType()) Then
				If (Not flag OrElse Not skipAsNewInitializer) Then
					Binder.ReportDiagnostic(diagnostics, visualBasicSyntaxNode2, ERRID.ERR_RestrictedType1, New [Object]() { typeSymbol1 })
				End If
			ElseIf (Me.IsInAsyncContext() OrElse Me.IsInIteratorContext()) Then
				Binder.ReportDiagnostic(diagnostics, name, ERRID.ERR_BadStaticInitializerInResumable)
			End If
			If (constantExpression Is Nothing) Then
				If (localForDeclaration.IsConst) Then
					constantExpression = localForDeclaration.GetConstantExpression(Me)
				ElseIf (equalsValueOpt IsNot Nothing) Then
					constantExpression = Me.BindValue(equalsValueOpt.Value, diagnostics, False)
				End If
			End If
			If (constantExpression IsNot Nothing AndAlso Not localForDeclaration.IsConst) Then
				constantExpression = Me.ApplyImplicitConversion(constantExpression.Syntax, typeSymbol1, constantExpression, diagnostics, False)
			End If
			If (flag) Then
				Dim asNewClauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax = DirectCast(asClauseOpt, Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax)
				If (Not localForDeclaration.IsConst) Then
					Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = asNewClauseSyntax.NewExpression.Kind()
					If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ObjectCreationExpression) Then
						If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AnonymousObjectCreationExpression) Then
							Throw ExceptionUtilities.UnexpectedValue(asNewClauseSyntax.NewExpression.Kind())
						End If
					ElseIf (Not skipAsNewInitializer) Then
						Binder.DisallowNewOnTupleType(asNewClauseSyntax.Type(), diagnostics)
						Dim newExpression As Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax = DirectCast(asNewClauseSyntax.NewExpression, Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax)
						Dim boundWithLValueExpressionPlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundWithLValueExpressionPlaceholder = New Microsoft.CodeAnalysis.VisualBasic.BoundWithLValueExpressionPlaceholder(asClauseOpt, localForDeclaration.Type)
						boundWithLValueExpressionPlaceholder.SetWasCompilerGenerated()
						constantExpression = Me.BindObjectCreationExpression(asNewClauseSyntax.Type(), newExpression.ArgumentList, typeSymbol, newExpression, diagnostics, boundWithLValueExpressionPlaceholder)
					End If
					If (typeSymbol1.IsArrayType()) Then
						Binder.ReportDiagnostic(diagnostics, asNewClauseSyntax.NewExpression.NewKeyword, ERRID.ERR_AsNewArray)
						constantExpression = Binder.BadExpression(asNewClauseSyntax, constantExpression, typeSymbol1).MakeCompilerGenerated()
					ElseIf (constantExpression IsNot Nothing AndAlso Not constantExpression.HasErrors AndAlso Not typeSymbol1.IsSameTypeIgnoringAll(constantExpression.Type)) Then
						constantExpression = Binder.BadExpression(asNewClauseSyntax, constantExpression, constantExpression.Type).MakeCompilerGenerated()
					End If
				Else
					Binder.ReportDiagnostic(diagnostics, asNewClauseSyntax.NewExpression.NewKeyword, ERRID.ERR_BadLocalConstFlags1, New [Object]() { asNewClauseSyntax.NewExpression.NewKeyword.ToString() })
				End If
			End If
			Dim boundArrayCreation As Microsoft.CodeAnalysis.VisualBasic.BoundArrayCreation = Nothing
			If (name.ArrayBounds IsNot Nothing) Then
				boundArrayCreation = (New Microsoft.CodeAnalysis.VisualBasic.BoundArrayCreation(name, boundExpressions, Nothing, typeSymbol1, False)).MakeCompilerGenerated()
				If (constantExpression IsNot Nothing AndAlso Not flag) Then
					Binder.ReportDiagnostic(diagnostics, name, ERRID.ERR_InitWithExplicitArraySizes)
				End If
			End If
			If (localForDeclaration.IsConst AndAlso Not typeSymbol1.IsErrorType()) Then
				If (typeSymbol1.IsValidTypeForConstField()) Then
					Dim constantValueDiagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = localForDeclaration.GetConstantValueDiagnostics(Me)
					If (constantValueDiagnostics IsNot Nothing) Then
						diagnostics.AddRange(constantValueDiagnostics, True)
					End If
				Else
					If (asClauseOpt Is Nothing OrElse typeSymbol1.IsArrayType()) Then
						visualBasicSyntaxNode1 = name
					Else
						visualBasicSyntaxNode1 = asClauseOpt.Type()
					End If
					visualBasicSyntaxNode2 = visualBasicSyntaxNode1
					Binder.ReportDiagnostic(diagnostics, visualBasicSyntaxNode2, ERRID.ERR_ConstAsNonConstant)
				End If
			End If
			Return New BoundLocalDeclaration(name, localForDeclaration, constantExpression, boundArrayCreation, flag, False)
		End Function

		Private Function BindVariableDeclarators(ByVal declarators As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As ImmutableArray(Of BoundLocalDeclarationBase)
			Dim equalsValueSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax
			Dim instance As ArrayBuilder(Of BoundLocalDeclarationBase) = ArrayBuilder(Of BoundLocalDeclarationBase).GetInstance()
			Dim enumerator As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax).Enumerator = declarators.GetEnumerator()
			While enumerator.MoveNext()
				Dim current As Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax = enumerator.Current
				Dim asClause As Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax = current.AsClause
				Dim initializer As Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax = current.Initializer
				If (initializer IsNot Nothing AndAlso current.Names.Count > 1) Then
					Binder.ReportDiagnostic(diagnostics, current, ERRID.ERR_InitWithMultipleDeclarators)
				End If
				Dim names As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax) = current.Names
				If (names.Count = 1) Then
					instance.Add(Me.BindVariableDeclaration(current, names(0), asClause, initializer, diagnostics, False))
				ElseIf (asClause Is Nothing OrElse asClause.Kind() <> SyntaxKind.AsNewClause) Then
					Dim count As Integer = names.Count - 1
					For i As Integer = 0 To count
						Dim variableDeclaratorSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax = current
						Dim item As Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax = names(i)
						Dim asClauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax = asClause
						If (i = names.Count - 1) Then
							equalsValueSyntax = initializer
						Else
							equalsValueSyntax = Nothing
						End If
						Dim boundLocalDeclaration As Microsoft.CodeAnalysis.VisualBasic.BoundLocalDeclaration = Me.BindVariableDeclaration(variableDeclaratorSyntax, item, asClauseSyntax, equalsValueSyntax, diagnostics, False)
						instance.Add(boundLocalDeclaration)
					Next

				Else
					Dim num As Integer = names.Count
					Dim boundLocalDeclarations As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundLocalDeclaration) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundLocalDeclaration).GetInstance(num)
					Dim num1 As Integer = num - 1
					Dim num2 As Integer = 0
					Do
						Dim boundLocalDeclaration1 As Microsoft.CodeAnalysis.VisualBasic.BoundLocalDeclaration = Me.BindVariableDeclaration(current, names(num2), asClause, Nothing, diagnostics, num2 > 0)
						boundLocalDeclarations.Add(boundLocalDeclaration1)
						num2 = num2 + 1
					Loop While num2 <= num1
					Dim item1 As Microsoft.CodeAnalysis.VisualBasic.BoundLocalDeclaration = boundLocalDeclarations(0)
					Dim initializerOpt As BoundExpression = item1.InitializerOpt
					boundLocalDeclarations(0) = item1.Update(item1.LocalSymbol, Nothing, item1.IdentifierInitializerOpt, True)
					instance.Add(New BoundAsNewLocalDeclarations(current, boundLocalDeclarations.ToImmutableAndFree(), initializerOpt, False))
				End If
			End While
			Return instance.ToImmutableAndFree()
		End Function

		Private Function BindWhereClause(ByVal source As BoundQueryClauseBase, ByVal where As Microsoft.CodeAnalysis.VisualBasic.Syntax.WhereClauseSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundQueryClause
			Dim whereKeyword As Microsoft.CodeAnalysis.SyntaxToken = where.WhereKeyword
			Return Me.BindFilterQueryOperator(source, where, "Where", whereKeyword.Span, where.Condition, diagnostics)
		End Function

		Private Function BindWhileBlock(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileBlockSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindBooleanExpression(node.WhileStatement.Condition, diagnostics)
			Dim binder As Microsoft.CodeAnalysis.VisualBasic.Binder = Me.GetBinder(node)
			Dim boundBlock As Microsoft.CodeAnalysis.VisualBasic.BoundBlock = binder.BindBlock(node, node.Statements, diagnostics).MakeCompilerGenerated()
			Return New BoundWhileStatement(node, boundExpression, boundBlock, binder.GetContinueLabel(SyntaxKind.ContinueWhileStatement), binder.GetExitLabel(SyntaxKind.ExitWhileStatement), False)
		End Function

		Public Function BindWithBlock(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.WithBlockSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim binder As Microsoft.CodeAnalysis.VisualBasic.Binder = Me.GetBinder(node)
			Return binder.CreateBoundWithBlock(node, binder, diagnostics)
		End Function

		Private Function BindXmlAttribute(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax, ByVal rootInfo As Binder.XmlElementRootInfo, <Out> ByRef xmlName As Binder.XmlName, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundXmlAttribute
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim name As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax = syntax.Name
			If (name.Kind() <> SyntaxKind.XmlEmbeddedExpression) Then
				Dim flag As Boolean = False
				Dim str As String = Nothing
				Dim str1 As String = Nothing
				Dim str2 As String = Nothing
				boundExpression = Me.BindXmlName(DirectCast(name, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax), False, rootInfo, flag, str, str1, str2, diagnostics)
				If (flag) Then
					Binder.AddImportedNamespaceIfNecessary(rootInfo.ImportedNamespaces, str, str2, False)
				End If
				xmlName = New Binder.XmlName(str1, str2)
			Else
				boundExpression = Me.BindXmlEmbeddedExpression(DirectCast(name, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax), diagnostics)
				xmlName = New Binder.XmlName()
			End If
			Dim value As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax = syntax.Value
			Dim flag1 As Boolean = False
			If (value.Kind() <> SyntaxKind.XmlEmbeddedExpression) Then
				Dim xmlString As String = Binder.GetXmlString(DirectCast(value, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax).TextTokens)
				flag1 = If(name.Kind() <> SyntaxKind.XmlName, False, Me.MatchesXmlnsImport(DirectCast(name, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax), xmlString))
				boundExpression1 = Me.CreateStringLiteral(value, xmlString, False, diagnostics, False)
				boundExpression2 = Me.BindObjectCreationExpression(name, Me.GetWellKnownType(WellKnownType.System_Xml_Linq_XAttribute, syntax, diagnostics), ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpression, boundExpression1), diagnostics)
			Else
				boundExpression1 = Me.BindXmlEmbeddedExpression(DirectCast(value, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax), diagnostics)
				Dim xmlMethodOrPropertyGroup As BoundMethodOrPropertyGroup = Me.GetXmlMethodOrPropertyGroup(value, Me.GetInternalXmlHelperType(syntax, diagnostics), "CreateAttribute", Nothing, diagnostics)
				boundExpression2 = Me.BindInvocationExpressionIfGroupNotNothing(value, xmlMethodOrPropertyGroup, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpression, boundExpression1), diagnostics)
			End If
			Return New BoundXmlAttribute(syntax, boundExpression, boundExpression1, flag1, boundExpression2, boundExpression2.Type, False)
		End Function

		Private Function BindXmlAttributeAccess(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			diagnostics = Me.CheckXmlFeaturesAllowed(syntax, diagnostics)
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindXmlMemberAccessReceiver(syntax, diagnostics)
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindXmlName(If(syntax.Name.Kind() = SyntaxKind.XmlName, DirectCast(syntax.Name, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax), DirectCast(syntax.Name, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlBracketedNameSyntax).Name), False, diagnostics)
			Dim type As TypeSymbol = boundExpression.Type
			Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			If (type.SpecialType = SpecialType.System_Object) Then
				Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_NoXmlAxesLateBinding)
			ElseIf (Not type.IsErrorType()) Then
				Dim xmlMethodOrPropertyGroup As BoundMethodOrPropertyGroup = Nothing
				Dim wellKnownType As NamedTypeSymbol = Me.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType.System_Xml_Linq_XElement, syntax, diagnostics)
				Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
				If (type.IsOrDerivedFrom(wellKnownType, newCompoundUseSiteInfo) OrElse type.IsCompatibleWithGenericIEnumerableOfType(wellKnownType, newCompoundUseSiteInfo)) Then
					xmlMethodOrPropertyGroup = Me.GetXmlMethodOrPropertyGroup(syntax, Me.GetInternalXmlHelperType(syntax, diagnostics), "AttributeValue", Nothing, diagnostics)
				End If
				diagnostics.Add(syntax, newCompoundUseSiteInfo)
				If (xmlMethodOrPropertyGroup Is Nothing) Then
					Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_TypeDisallowsAttributes, New [Object]() { type })
				Else
					boundExpression2 = Me.BindInvocationExpressionIfGroupNotNothing(syntax, xmlMethodOrPropertyGroup, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpression, boundExpression1), diagnostics)
					boundExpression2 = Me.MakeValue(boundExpression2, diagnostics)
				End If
			End If
			If (boundExpression2 Is Nothing) Then
				boundExpression2 = Binder.BadExpression(syntax, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpression, boundExpression1), Me.Compilation.GetSpecialType(SpecialType.System_String))
			End If
			Return New BoundXmlMemberAccess(syntax, boundExpression2, boundExpression2.Type, False)
		End Function

		Private Sub BindXmlAttributes(<Out> ByRef allAttributes As Dictionary(Of Binder.XmlName, Microsoft.CodeAnalysis.VisualBasic.BoundXmlAttribute), ByVal attributes As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax), ByVal childNodeBuilder As ArrayBuilder(Of BoundExpression), ByVal rootInfo As Binder.XmlElementRootInfo, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Dim enumerator As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax).Enumerator = attributes.GetEnumerator()
			While enumerator.MoveNext()
				Dim current As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax = enumerator.Current
				If (current.Kind() <> SyntaxKind.XmlAttribute) Then
					childNodeBuilder.Add(Me.BindXmlContent(current, rootInfo, diagnostics))
				Else
					Dim xmlAttributeSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax = DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax)
					Dim xmlName As Binder.XmlName = New Binder.XmlName()
					Dim boundXmlAttribute As Microsoft.CodeAnalysis.VisualBasic.BoundXmlAttribute = Me.BindXmlAttribute(xmlAttributeSyntax, rootInfo, xmlName, diagnostics)
					childNodeBuilder.Add(boundXmlAttribute)
					If (xmlName.LocalName Is Nothing) Then
						Continue While
					End If
					Binder.AddXmlAttributeIfNotDuplicate(xmlAttributeSyntax.Name, xmlName, boundXmlAttribute, allAttributes, diagnostics)
				End If
			End While
		End Sub

		Private Function BindXmlCData(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCDataSectionSyntax, ByVal rootInfoOpt As Binder.XmlElementRootInfo, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			If (rootInfoOpt Is Nothing) Then
				diagnostics = Me.CheckXmlFeaturesAllowed(syntax, diagnostics)
			End If
			Dim boundLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundLiteral = Me.CreateStringLiteral(syntax, Binder.GetXmlString(syntax.TextTokens), True, diagnostics, False)
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindObjectCreationExpression(syntax, Me.GetWellKnownType(WellKnownType.System_Xml_Linq_XCData, syntax, diagnostics), ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundLiteral), diagnostics)
			Return New BoundXmlCData(syntax, boundLiteral, boundExpression, boundExpression.Type, False)
		End Function

		Private Function BindXmlComment(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCommentSyntax, ByVal rootInfoOpt As Binder.XmlElementRootInfo, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			If (rootInfoOpt Is Nothing) Then
				diagnostics = Me.CheckXmlFeaturesAllowed(syntax, diagnostics)
			End If
			Dim boundLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundLiteral = Me.CreateStringLiteral(syntax, Binder.GetXmlString(syntax.TextTokens), True, diagnostics, False)
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindObjectCreationExpression(syntax, Me.GetWellKnownType(WellKnownType.System_Xml_Linq_XComment, syntax, diagnostics), ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundLiteral), diagnostics)
			Return New BoundXmlComment(syntax, boundLiteral, boundExpression, boundExpression.Type, False)
		End Function

		Private Function BindXmlContainerRewriterInfo(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax, ByVal objectCreation As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal childNodes As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression), ByVal rootInfoOpt As Binder.XmlElementRootInfo, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundXmlContainerRewriterInfo
			Dim boundXmlContainerRewriterInfo As Microsoft.CodeAnalysis.VisualBasic.BoundXmlContainerRewriterInfo
			If (childNodes.Length <> 0 OrElse rootInfoOpt IsNot Nothing AndAlso rootInfoOpt.ImportedNamespaces.Count <> 0) Then
				Dim boundRValuePlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder = (New Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder(syntax, objectCreation.Type)).MakeCompilerGenerated()
				Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance()
				Dim xmlMethodOrPropertyGroup As BoundMethodOrPropertyGroup = Me.GetXmlMethodOrPropertyGroup(syntax, Me.GetWellKnownType(WellKnownType.System_Xml_Linq_XContainer, syntax, diagnostics), "Add", boundRValuePlaceholder, diagnostics)
				Dim immutableAndFree As ImmutableArray(Of KeyValuePair(Of String, String)) = New ImmutableArray(Of KeyValuePair(Of String, String))()
				Dim boundRValuePlaceholder1 As Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder = Nothing
				Dim boundRValuePlaceholder2 As Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder = Nothing
				Dim enumerator As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Enumerator = childNodes.GetEnumerator()
				While enumerator.MoveNext()
					Dim current As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = enumerator.Current
					If (current.Kind = BoundKind.XmlAttribute AndAlso DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.BoundXmlAttribute).MatchesImport) Then
						Continue While
					End If
					Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = current
					If (rootInfoOpt IsNot Nothing AndAlso boundExpression.Kind = BoundKind.XmlEmbeddedExpression AndAlso Me.HasImportedXmlNamespaces AndAlso Not boundExpression.Type.IsIntrinsicOrEnumType()) Then
						If (immutableAndFree.IsDefault) Then
							Dim keyValuePairs As ArrayBuilder(Of KeyValuePair(Of String, String)) = ArrayBuilder(Of KeyValuePair(Of String, String)).GetInstance()
							Me.GetInScopeXmlNamespaces(keyValuePairs)
							immutableAndFree = keyValuePairs.ToImmutableAndFree()
						End If
						If (boundRValuePlaceholder1 Is Nothing) Then
							Dim arrayTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol = Me.CreateArrayType(Me.GetSpecialType(SpecialType.System_String, syntax, diagnostics))
							boundRValuePlaceholder1 = (New Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder(syntax, arrayTypeSymbol)).MakeCompilerGenerated()
							Dim arrayTypeSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol = Me.CreateArrayType(Me.GetWellKnownType(WellKnownType.System_Xml_Linq_XNamespace, syntax, diagnostics))
							boundRValuePlaceholder2 = (New Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder(syntax, arrayTypeSymbol1)).MakeCompilerGenerated()
						End If
						boundExpression = rootInfoOpt.BindRemoveNamespaceAttributesInvocation(boundExpression, boundRValuePlaceholder1, boundRValuePlaceholder2, diagnostics)
					End If
					instance.Add(Me.BindInvocationExpressionIfGroupNotNothing(syntax, xmlMethodOrPropertyGroup, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpression), diagnostics))
				End While
				Dim xmlnsAttributesPlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder = Nothing
				Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
				Dim flag As Boolean = If(rootInfoOpt Is Nothing, False, rootInfoOpt.Syntax = syntax)
				If (flag) Then
					Dim importedNamespaces As ArrayBuilder(Of KeyValuePair(Of String, String)) = rootInfoOpt.ImportedNamespaces
					For i As Integer = importedNamespaces.Count - 1 To 0 Step -1
						Dim item As KeyValuePair(Of String, String) = importedNamespaces(i)
						Dim boundXmlAttribute As Microsoft.CodeAnalysis.VisualBasic.BoundXmlAttribute = Me.BindXmlnsAttribute(syntax, item.Key, item.Value, diagnostics)
						instance.Add(Me.BindInvocationExpressionIfGroupNotNothing(syntax, xmlMethodOrPropertyGroup, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundXmlAttribute), diagnostics))
					Next

					xmlnsAttributesPlaceholder = rootInfoOpt.XmlnsAttributesPlaceholder
					If (xmlnsAttributesPlaceholder IsNot Nothing) Then
						boundExpression1 = Me.BindObjectCreationExpression(syntax, xmlnsAttributesPlaceholder.Type, ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty, diagnostics).MakeCompilerGenerated()
						instance.Add(Me.BindInvocationExpressionIfGroupNotNothing(syntax, xmlMethodOrPropertyGroup, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(xmlnsAttributesPlaceholder), diagnostics))
					End If
				End If
				boundXmlContainerRewriterInfo = New Microsoft.CodeAnalysis.VisualBasic.BoundXmlContainerRewriterInfo(flag, boundRValuePlaceholder, objectCreation, xmlnsAttributesPlaceholder, boundExpression1, boundRValuePlaceholder1, boundRValuePlaceholder2, If(flag, rootInfoOpt.ImportedNamespaces.ToImmutable(), New ImmutableArray(Of KeyValuePair(Of String, String))()), immutableAndFree, instance.ToImmutableAndFree())
			Else
				boundXmlContainerRewriterInfo = New Microsoft.CodeAnalysis.VisualBasic.BoundXmlContainerRewriterInfo(objectCreation)
			End If
			Return boundXmlContainerRewriterInfo
		End Function

		Private Sub BindXmlContent(ByVal content As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax), ByVal childNodeBuilder As ArrayBuilder(Of BoundExpression), ByVal rootInfoOpt As Binder.XmlElementRootInfo, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Dim enumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax).Enumerator = content.GetEnumerator()
			While enumerator.MoveNext()
				Dim current As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax = enumerator.Current
				childNodeBuilder.Add(Me.BindXmlContent(current, rootInfoOpt, diagnostics))
			End While
		End Sub

		Private Function BindXmlContent(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax, ByVal rootInfoOpt As Binder.XmlElementRootInfo, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = syntax.Kind()
			Select Case syntaxKind
				Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlElement
					boundExpression = Me.BindXmlElement(DirectCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax), rootInfoOpt, diagnostics)
					Exit Select
				Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlText
					boundExpression = Me.BindXmlText(DirectCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlTextSyntax), diagnostics)
					Exit Select
				Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlElementStartTag
				Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlElementEndTag
					Throw ExceptionUtilities.UnexpectedValue(syntax.Kind())
				Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlEmptyElement
					boundExpression = Me.BindXmlEmptyElement(DirectCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax), rootInfoOpt, diagnostics)
					Exit Select
				Case Else
					Select Case syntaxKind
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlComment
							boundExpression = Me.BindXmlComment(DirectCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCommentSyntax), rootInfoOpt, diagnostics)

						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlProcessingInstruction
							boundExpression = Me.BindXmlProcessingInstruction(DirectCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlProcessingInstructionSyntax), diagnostics)

						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlCDataSection
							boundExpression = Me.BindXmlCData(DirectCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCDataSectionSyntax), rootInfoOpt, diagnostics)

						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlEmbeddedExpression
							boundExpression = Me.BindXmlEmbeddedExpression(DirectCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax), diagnostics)

						Case Else
							Throw ExceptionUtilities.UnexpectedValue(syntax.Kind())
					End Select

			End Select
			Return boundExpression
		End Function

		Private Function BindXmlDeclaration(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundLiteral = Me.BindXmlDeclarationOption(syntax, syntax.Version, diagnostics)
			Dim boundLiteral1 As Microsoft.CodeAnalysis.VisualBasic.BoundLiteral = Me.BindXmlDeclarationOption(syntax, syntax.Encoding, diagnostics)
			Dim boundLiteral2 As Microsoft.CodeAnalysis.VisualBasic.BoundLiteral = Me.BindXmlDeclarationOption(syntax, syntax.Standalone, diagnostics)
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindObjectCreationExpression(syntax, Me.GetWellKnownType(WellKnownType.System_Xml_Linq_XDeclaration, syntax, diagnostics), ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundLiteral, boundLiteral1, boundLiteral2), diagnostics)
			Return New BoundXmlDeclaration(syntax, boundLiteral, boundLiteral1, boundLiteral2, boundExpression, boundExpression.Type, False)
		End Function

		Private Function BindXmlDeclarationOption(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax, ByVal optionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundLiteral
			Dim boundLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundLiteral
			If (optionSyntax IsNot Nothing) Then
				Dim value As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax = optionSyntax.Value
				boundLiteral = Me.CreateStringLiteral(value, Binder.GetXmlString(value.TextTokens), False, diagnostics, False)
			Else
				boundLiteral = Me.CreateStringLiteral(syntax, Nothing, True, diagnostics, False)
			End If
			Return boundLiteral
		End Function

		Private Function BindXmlDescendantAccess(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Return Me.BindXmlElementAccess(syntax, "Descendants", ERRID.ERR_TypeDisallowsDescendants, diagnostics)
		End Function

		Private Function BindXmlDocument(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDocumentSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			diagnostics = Me.CheckXmlFeaturesAllowed(syntax, diagnostics)
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindXmlDeclaration(syntax.Declaration, diagnostics)
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindObjectCreationExpression(syntax, Me.GetWellKnownType(WellKnownType.System_Xml_Linq_XDocument, syntax, diagnostics), ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpression, New BoundLiteral(syntax, ConstantValue.[Nothing], Nothing)), diagnostics)
			Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance()
			Me.BindXmlContent(syntax.PrecedingMisc, instance, Nothing, diagnostics)
			instance.Add(Me.BindXmlContent(syntax.Root, Nothing, diagnostics))
			Me.BindXmlContent(syntax.FollowingMisc, instance, Nothing, diagnostics)
			Dim immutableAndFree As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = instance.ToImmutableAndFree()
			Dim boundXmlContainerRewriterInfo As Microsoft.CodeAnalysis.VisualBasic.BoundXmlContainerRewriterInfo = Me.BindXmlContainerRewriterInfo(syntax, boundExpression1, immutableAndFree, Nothing, diagnostics)
			Return New BoundXmlDocument(syntax, boundExpression, immutableAndFree, boundXmlContainerRewriterInfo, boundExpression1.Type, boundXmlContainerRewriterInfo.HasErrors)
		End Function

		Private Function BindXmlElement(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax, ByVal rootInfoOpt As Binder.XmlElementRootInfo, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim startTag As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementStartTagSyntax = syntax.StartTag
			Return Me.BindXmlElement(syntax, startTag.Name, startTag.Attributes, syntax.Content, rootInfoOpt, diagnostics)
		End Function

		Private Function BindXmlElement(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax, ByVal nameSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax, ByVal attributes As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax), ByVal content As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax), ByVal rootInfoOpt As Binder.XmlElementRootInfo, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim xmlElementBinder As Binder
			If (rootInfoOpt IsNot Nothing) Then
				Dim xmlNames As Dictionary(Of Binder.XmlName, BoundXmlAttribute) = Nothing
				Dim instance As ArrayBuilder(Of BoundXmlAttribute) = ArrayBuilder(Of BoundXmlAttribute).GetInstance()
				Dim xmlNodeSyntaxes As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax).GetInstance()
				Dim strs As Dictionary(Of String, String) = Me.BindXmlnsAttributes(attributes, xmlNames, instance, xmlNodeSyntaxes, rootInfoOpt.ImportedNamespaces, diagnostics)
				If (strs Is Nothing) Then
					xmlElementBinder = Me
				Else
					xmlElementBinder = New Microsoft.CodeAnalysis.VisualBasic.XmlElementBinder(Me, strs)
				End If
				Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = xmlElementBinder.BindXmlElementWithoutAddingNamespaces(syntax, nameSyntax, xmlNames, instance, xmlNodeSyntaxes, content, rootInfoOpt, diagnostics)
				xmlNodeSyntaxes.Free()
				instance.Free()
				boundExpression = boundExpression1
			Else
				diagnostics = Me.CheckXmlFeaturesAllowed(syntax, diagnostics)
				Dim keyValuePairs As ArrayBuilder(Of KeyValuePair(Of String, String)) = ArrayBuilder(Of KeyValuePair(Of String, String)).GetInstance()
				Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = (New XmlRootElementBinder(Me)).BindXmlElement(syntax, nameSyntax, attributes, content, New Binder.XmlElementRootInfo(Me, syntax, keyValuePairs), diagnostics)
				keyValuePairs.Free()
				boundExpression = boundExpression2
			End If
			Return boundExpression
		End Function

		Private Function BindXmlElementAccess(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Return Me.BindXmlElementAccess(syntax, "Elements", ERRID.ERR_TypeDisallowsElements, diagnostics)
		End Function

		Private Function BindXmlElementAccess(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax, ByVal memberName As String, ByVal typeDisallowsError As ERRID, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			diagnostics = Me.CheckXmlFeaturesAllowed(syntax, diagnostics)
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindXmlMemberAccessReceiver(syntax, diagnostics)
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindXmlName(DirectCast(syntax.Name, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlBracketedNameSyntax).Name, True, diagnostics)
			Dim type As TypeSymbol = boundExpression.Type
			Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			If (type.SpecialType = SpecialType.System_Object) Then
				Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_NoXmlAxesLateBinding)
			ElseIf (Not type.IsErrorType()) Then
				Dim xmlMethodOrPropertyGroup As BoundMethodOrPropertyGroup = Nothing
				Dim boundExpressions As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = New ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)()
				Dim wellKnownType As NamedTypeSymbol = Me.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType.System_Xml_Linq_XContainer, syntax, diagnostics)
				Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
				If (type.IsOrDerivedFrom(wellKnownType, newCompoundUseSiteInfo)) Then
					xmlMethodOrPropertyGroup = Me.GetXmlMethodOrPropertyGroup(syntax, wellKnownType, memberName, boundExpression, diagnostics)
					boundExpressions = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpression1)
				ElseIf (type.IsCompatibleWithGenericIEnumerableOfType(wellKnownType, newCompoundUseSiteInfo)) Then
					xmlMethodOrPropertyGroup = Me.GetXmlMethodOrPropertyGroup(syntax, Me.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType.System_Xml_Linq_Extensions, syntax, diagnostics), memberName, Nothing, diagnostics)
					boundExpressions = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpression, boundExpression1)
				End If
				diagnostics.Add(syntax, newCompoundUseSiteInfo)
				If (xmlMethodOrPropertyGroup Is Nothing) Then
					Binder.ReportDiagnostic(diagnostics, syntax, typeDisallowsError, New [Object]() { type })
				Else
					boundExpression2 = Me.BindInvocationExpressionIfGroupNotNothing(syntax, xmlMethodOrPropertyGroup, boundExpressions, diagnostics)
					boundExpression2 = Me.MakeRValue(boundExpression2, diagnostics)
				End If
			End If
			If (boundExpression2 Is Nothing) Then
				boundExpression2 = Binder.BadExpression(syntax, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpression, boundExpression1), ErrorTypeSymbol.UnknownResultType)
			End If
			Return New BoundXmlMemberAccess(syntax, boundExpression2, boundExpression2.Type, False)
		End Function

		Private Function BindXmlElementWithoutAddingNamespaces(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax, ByVal nameSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax, <Out> ByRef allAttributes As Dictionary(Of Binder.XmlName, BoundXmlAttribute), ByVal xmlnsAttributes As ArrayBuilder(Of BoundXmlAttribute), ByVal otherAttributes As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax), ByVal content As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax), ByVal rootInfo As Binder.XmlElementRootInfo, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			If (nameSyntax.Kind() <> SyntaxKind.XmlEmbeddedExpression) Then
				Dim flag As Boolean = False
				Dim str As String = Nothing
				Dim str1 As String = Nothing
				Dim str2 As String = Nothing
				boundExpression = Me.BindXmlName(DirectCast(nameSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax), True, rootInfo, flag, str, str1, str2, diagnostics)
				If (flag) Then
					Binder.AddImportedNamespaceIfNecessary(rootInfo.ImportedNamespaces, str, str2, True)
				End If
			Else
				boundExpression = Me.BindXmlEmbeddedExpression(DirectCast(nameSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax), diagnostics)
			End If
			If (boundExpression.Type.IsObjectType() AndAlso Me.OptionStrict <> Microsoft.CodeAnalysis.VisualBasic.OptionStrict.[On]) Then
				Dim wellKnownType As NamedTypeSymbol = Me.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType.System_Xml_Linq_XName, syntax, diagnostics)
				boundExpression = Me.ApplyDirectCastConversion(syntax, boundExpression, wellKnownType, diagnostics)
			End If
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindObjectCreationExpression(nameSyntax, Me.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType.System_Xml_Linq_XElement, nameSyntax, diagnostics), ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpression), diagnostics)
			Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance()
			Dim enumerator As ArrayBuilder(Of BoundXmlAttribute).Enumerator = xmlnsAttributes.GetEnumerator()
			While enumerator.MoveNext()
				instance.Add(enumerator.Current)
			End While
			Me.BindXmlAttributes(allAttributes, otherAttributes, instance, rootInfo, diagnostics)
			If (syntax.Kind() <> SyntaxKind.XmlEmptyElement) Then
				If (content.Count <= 0) Then
					instance.Add(Me.CreateStringLiteral(syntax, [String].Empty, True, diagnostics, False))
				Else
					Me.BindXmlContent(content, instance, rootInfo, diagnostics)
				End If
			End If
			Dim immutableAndFree As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = instance.ToImmutableAndFree()
			Dim boundXmlContainerRewriterInfo As Microsoft.CodeAnalysis.VisualBasic.BoundXmlContainerRewriterInfo = Me.BindXmlContainerRewriterInfo(syntax, boundExpression1, immutableAndFree, rootInfo, diagnostics)
			Return New BoundXmlElement(syntax, boundExpression, immutableAndFree, boundXmlContainerRewriterInfo, boundExpression1.Type, boundXmlContainerRewriterInfo.HasErrors)
		End Function

		Private Function BindXmlEmbeddedExpression(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = (New XmlEmbeddedExpressionBinder(Me)).BindRValue(syntax.Expression, diagnostics, False)
			Return New BoundXmlEmbeddedExpression(syntax, boundExpression, boundExpression.Type, False)
		End Function

		Private Function BindXmlEmptyElement(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax, ByVal rootInfoOpt As Binder.XmlElementRootInfo, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim name As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax = syntax.Name
			Dim attributes As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax) = syntax.Attributes
			Dim xmlNodeSyntaxes As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax) = New SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax)()
			Return Me.BindXmlElement(syntax, name, attributes, xmlNodeSyntaxes, rootInfoOpt, diagnostics)
		End Function

		Private Function BindXmlMemberAccessReceiver(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			If (syntax.Base IsNot Nothing) Then
				Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindValue(syntax.Base, diagnostics, False)
				boundExpression = Me.AdjustReceiverValue(boundExpression2, syntax, diagnostics)
			Else
				Dim correspondingConditionalAccessExpression As Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax = syntax.GetCorrespondingConditionalAccessExpression()
				boundExpression1 = If(correspondingConditionalAccessExpression Is Nothing, Me.TryBindOmittedLeftForXmlMemberAccess(syntax, diagnostics, Me), Me.GetConditionalAccessReceiver(correspondingConditionalAccessExpression))
				boundExpression = If(boundExpression1 IsNot Nothing, boundExpression1, Binder.ReportDiagnosticAndProduceBadExpression(diagnostics, syntax, ERRID.ERR_BadWithRef))
			End If
			Return boundExpression
		End Function

		Private Function BindXmlName(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax, ByVal forElement As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim flag As Boolean = False
			Dim str As String = Nothing
			Dim str1 As String = Nothing
			Dim str2 As String = Nothing
			Return Me.BindXmlName(syntax, forElement, Nothing, flag, str, str1, str2, diagnostics)
		End Function

		Private Function BindXmlName(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax, ByVal forElement As Boolean, ByVal rootInfoOpt As Binder.XmlElementRootInfo, <Out> ByRef fromImports As Boolean, <Out> ByRef prefix As String, <Out> ByRef localName As String, <Out> ByRef [namespace] As String, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundLiteral
			Dim xmlPrefixSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixSyntax = syntax.Prefix
			fromImports = False
			localName = Binder.GetXmlName(syntax.LocalName)
			[namespace] = Nothing
			If (xmlPrefixSyntax Is Nothing) Then
				prefix = ""
				If (Not forElement) Then
					[namespace] = ""
				Else
					Me.LookupXmlNamespace(prefix, False, [namespace], fromImports)
				End If
				boundLiteral = Me.CreateStringLiteral(syntax, [namespace], True, diagnostics, False)
			Else
				Dim name As Microsoft.CodeAnalysis.SyntaxToken = xmlPrefixSyntax.Name
				prefix = Binder.GetXmlName(name)
				If (Not forElement OrElse EmbeddedOperators.CompareString(prefix, "xmlns", False) <> 0) Then
					If (Not Me.LookupXmlNamespace(prefix, False, [namespace], fromImports)) Then
						boundExpression = Me.ReportXmlNamespacePrefixNotDefined(syntax, xmlPrefixSyntax.Name, prefix, False, diagnostics)
						Return boundExpression
					End If
					boundLiteral = Me.CreateStringLiteral(xmlPrefixSyntax, [namespace], False, diagnostics, False)
				Else
					Binder.ReportDiagnostic(diagnostics, name, ERRID.ERR_IllegalXmlnsPrefix)
					boundExpression = Binder.BadExpression(syntax, Me.Compilation.GetSpecialType(SpecialType.System_String))
					Return boundExpression
				End If
			End If
			Dim boundLiteral1 As Microsoft.CodeAnalysis.VisualBasic.BoundLiteral = Me.CreateStringLiteral(syntax, localName, True, diagnostics, False)
			boundExpression = Me.BindXmlName(syntax, boundLiteral1, boundLiteral, diagnostics)
			Return boundExpression
		End Function

		Private Function BindXmlName(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal localName As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal [namespace] As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim xmlMethodOrPropertyGroup As BoundMethodOrPropertyGroup = Me.GetXmlMethodOrPropertyGroup(syntax, Me.GetWellKnownType(WellKnownType.System_Xml_Linq_XName, syntax, diagnostics), "Get", Nothing, diagnostics)
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindInvocationExpressionIfGroupNotNothing(syntax, xmlMethodOrPropertyGroup, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(localName, [namespace]), diagnostics)
			Return New BoundXmlName(syntax, [namespace], localName, boundExpression, boundExpression.Type, False)
		End Function

		Friend Overridable Function BindXmlNameAttributeValue(ByVal identifier As Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol)) As ImmutableArray(Of Symbol)
			Return Me.ContainingBinder.BindXmlNameAttributeValue(identifier, useSiteInfo)
		End Function

		Private Function BindXmlNamespace(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal [namespace] As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim xmlMethodOrPropertyGroup As BoundMethodOrPropertyGroup = Me.GetXmlMethodOrPropertyGroup(syntax, Me.GetWellKnownType(WellKnownType.System_Xml_Linq_XNamespace, syntax, diagnostics), "Get", Nothing, diagnostics)
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindInvocationExpressionIfGroupNotNothing(syntax, xmlMethodOrPropertyGroup, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)([namespace]), diagnostics)
			Return New BoundXmlNamespace(syntax, [namespace], boundExpression, boundExpression.Type, False)
		End Function

		Private Function BindXmlnsAttribute(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax, ByVal prefix As String, ByVal namespaceName As String, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundXmlAttribute
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindXmlnsName(syntax, prefix, True, diagnostics)
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindXmlNamespace(syntax, Me.CreateStringLiteral(syntax, namespaceName, True, diagnostics, False), diagnostics)
			Return Me.BindXmlnsAttribute(syntax, boundExpression, boundExpression1, False, False, True, False, diagnostics)
		End Function

		Private Function BindXmlnsAttribute(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax, ByVal prefix As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal [namespace] As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal useConstructor As Boolean, ByVal matchesImport As Boolean, ByVal compilerGenerated As Boolean, ByVal hasErrors As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundXmlAttribute
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			If (Not useConstructor) Then
				Dim internalXmlHelperType As NamedTypeSymbol = Me.GetInternalXmlHelperType(syntax, diagnostics)
				Dim xmlMethodOrPropertyGroup As BoundMethodOrPropertyGroup = Me.GetXmlMethodOrPropertyGroup(syntax, internalXmlHelperType, "CreateNamespaceAttribute", Nothing, diagnostics)
				boundExpression = Me.BindInvocationExpressionIfGroupNotNothing(syntax, xmlMethodOrPropertyGroup, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(prefix, [namespace]), diagnostics)
			Else
				boundExpression = Me.BindObjectCreationExpression(syntax, Me.GetWellKnownType(WellKnownType.System_Xml_Linq_XAttribute, syntax, diagnostics), ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(prefix, [namespace]), diagnostics)
			End If
			Dim boundXmlAttribute As Microsoft.CodeAnalysis.VisualBasic.BoundXmlAttribute = New Microsoft.CodeAnalysis.VisualBasic.BoundXmlAttribute(syntax, prefix, [namespace], matchesImport, boundExpression, boundExpression.Type, hasErrors)
			If (compilerGenerated) Then
				boundXmlAttribute.SetWasCompilerGenerated()
			End If
			Return boundXmlAttribute
		End Function

		Private Function BindXmlnsAttributes(ByVal attributes As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax), <Out> ByRef allAttributes As Dictionary(Of Binder.XmlName, Microsoft.CodeAnalysis.VisualBasic.BoundXmlAttribute), ByVal xmlnsAttributes As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundXmlAttribute), ByVal otherAttributes As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax), ByVal importedNamespaces As ArrayBuilder(Of KeyValuePair(Of String, String)), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Dictionary(Of String, String)
			Dim strs As Dictionary(Of String, String) = Nothing
			Dim enumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax).Enumerator = attributes.GetEnumerator()
			While enumerator.MoveNext()
				Dim current As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax = enumerator.Current
				Dim xmlAttributeSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax = TryCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax)
				Dim str As String = Nothing
				Dim str1 As String = Nothing
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
				Dim flag As Boolean = False
				If (xmlAttributeSyntax Is Nothing OrElse Not Me.TryGetXmlnsAttribute(xmlAttributeSyntax, str, str1, boundExpression, flag, False, diagnostics)) Then
					otherAttributes.Add(current)
				Else
					Dim flag1 As Boolean = If(flag, False, Me.MatchesXmlnsImport(str, str1))
					Dim boundXmlAttribute As Microsoft.CodeAnalysis.VisualBasic.BoundXmlAttribute = Me.BindXmlnsAttribute(xmlAttributeSyntax, Me.BindXmlnsName(xmlAttributeSyntax.Name, str, False, diagnostics), boundExpression, True, flag1, False, flag, diagnostics)
					xmlnsAttributes.Add(boundXmlAttribute)
					If (flag) Then
						Continue While
					End If
					If (flag1) Then
						Binder.AddImportedNamespaceIfNecessary(importedNamespaces, str, str1, False)
					End If
					If (Not Binder.AddXmlAttributeIfNotDuplicate(xmlAttributeSyntax.Name, Binder.GetXmlnsXmlName(str), boundXmlAttribute, allAttributes, diagnostics)) Then
						Continue While
					End If
					If (strs Is Nothing) Then
						strs = New Dictionary(Of String, String)()
					End If
					strs.Add(str, str1)
				End If
			End While
			Return strs
		End Function

		Private Function BindXmlnsName(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax, ByVal prefix As String, ByVal compilerGenerated As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim xmlnsXmlName As Binder.XmlName = Binder.GetXmlnsXmlName(prefix)
			Return Me.BindXmlName(syntax, Me.CreateStringLiteral(syntax, xmlnsXmlName.LocalName, compilerGenerated, diagnostics, False), Me.CreateStringLiteral(syntax, xmlnsXmlName.XmlNamespace, compilerGenerated, diagnostics, False), diagnostics)
		End Function

		Private Function BindXmlProcessingInstruction(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlProcessingInstructionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundLiteral = Me.CreateStringLiteral(syntax, Binder.GetXmlName(syntax.Name), True, diagnostics, False)
			Dim boundLiteral1 As Microsoft.CodeAnalysis.VisualBasic.BoundLiteral = Me.CreateStringLiteral(syntax, Binder.GetXmlString(syntax.TextTokens), True, diagnostics, False)
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindObjectCreationExpression(syntax, Me.GetWellKnownType(WellKnownType.System_Xml_Linq_XProcessingInstruction, syntax, diagnostics), ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundLiteral, boundLiteral1), diagnostics)
			Return New BoundXmlProcessingInstruction(syntax, boundLiteral, boundLiteral1, boundExpression, boundExpression.Type, False)
		End Function

		Private Function BindXmlText(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlTextSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundLiteral
			Return Me.CreateStringLiteral(syntax, Binder.GetXmlString(syntax.TextTokens), False, diagnostics, False)
		End Function

		Private Function BindYield(ByVal originalSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.YieldStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Dim boundYieldStatement As BoundStatement
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindValue(originalSyntax.Expression, diagnostics, False)
			If (Not Me.BindingTopLevelScriptCode) Then
				Dim currentYieldType As TypeSymbol = Me.GetCurrentYieldType(originalSyntax, diagnostics)
				If (CObj(currentYieldType) <> CObj(LambdaSymbol.ReturnTypeIsUnknown)) Then
					If (CObj(currentYieldType) = CObj(LambdaSymbol.ReturnTypeIsBeingInferred)) Then
						boundYieldStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundYieldStatement(originalSyntax, boundExpression, False, True)
						Return boundYieldStatement
					End If
					boundExpression = Me.ApplyImplicitConversion(boundExpression.Syntax, currentYieldType, boundExpression, diagnostics, False)
				Else
					boundExpression = Me.MakeRValueAndIgnoreDiagnostics(boundExpression)
				End If
				boundYieldStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundYieldStatement(originalSyntax, boundExpression, False)
			Else
				Binder.ReportDiagnostic(diagnostics, originalSyntax, ERRID.ERR_KeywordNotAllowedInScript, New [Object]() { SyntaxFacts.GetText(SyntaxKind.YieldKeyword) })
				boundExpression = Me.MakeRValueAndIgnoreDiagnostics(boundExpression)
				boundYieldStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundYieldStatement(originalSyntax, boundExpression, True)
			End If
			Return boundYieldStatement
		End Function

		Private Sub BuildAndVerifyUsingInfo(ByVal syntaxNode As Microsoft.CodeAnalysis.SyntaxNode, ByVal resourceType As TypeSymbol, ByVal placeholderInfo As Dictionary(Of TypeSymbol, ValueTuple(Of Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder, Microsoft.CodeAnalysis.VisualBasic.BoundExpression, Microsoft.CodeAnalysis.VisualBasic.BoundExpression)), ByVal iDisposable As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			If (Not placeholderInfo.ContainsKey(resourceType)) Then
				Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
				Dim conversionKind As Microsoft.CodeAnalysis.VisualBasic.ConversionKind = Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyDirectCastConversion(resourceType, iDisposable, newCompoundUseSiteInfo)
				If (diagnostics.Add(syntaxNode, newCompoundUseSiteInfo)) Then
					diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
				End If
				If (Microsoft.CodeAnalysis.VisualBasic.Conversions.IsWideningConversion(conversionKind) OrElse resourceType.IsObjectType() AndAlso Me.OptionStrict <> Microsoft.CodeAnalysis.VisualBasic.OptionStrict.[On]) Then
					Dim boundRValuePlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder = New Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder(syntaxNode, resourceType)
					Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
					Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
					If (Not resourceType.IsValueType) Then
						boundExpression = Me.ApplyImplicitConversion(syntaxNode, iDisposable, boundRValuePlaceholder, diagnostics, False)
						boundExpression1 = Me.BindIsExpression(boundRValuePlaceholder, New BoundLiteral(syntaxNode, ConstantValue.[Nothing], Nothing), syntaxNode, True, diagnostics)
					End If
					placeholderInfo.Add(resourceType, New ValueTuple(Of Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder, Microsoft.CodeAnalysis.VisualBasic.BoundExpression, Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundRValuePlaceholder, boundExpression, boundExpression1))
					Return
				End If
				Binder.ReportDiagnostic(diagnostics, syntaxNode, ErrorFactory.ErrorInfo(ERRID.ERR_UsingRequiresDisposePattern, New [Object]() { resourceType }))
			End If
		End Sub

		Friend Function BuildBoundLambdaParameters(ByVal source As UnboundLambda, ByVal targetSignature As UnboundLambda.TargetSignature, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol)
			Dim empty As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol)
			Dim locations As ImmutableArray(Of Location)
			If (source.Parameters.Length <> 0) Then
				Dim parameters As ImmutableArray(Of ParameterSymbol) = source.Parameters
				Dim boundLambdaParameterSymbol(parameters.Length - 1 + 1 - 1) As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol
				Dim num As Integer = Math.Min(CInt(boundLambdaParameterSymbol.Length), targetSignature.ParameterTypes.Length)
				Dim num1 As Integer = num - 1
				Dim num2 As Integer = 0
				Do
					Dim item As Microsoft.CodeAnalysis.VisualBasic.Symbols.UnboundLambdaParameterSymbol = DirectCast(parameters(num2), Microsoft.CodeAnalysis.VisualBasic.Symbols.UnboundLambdaParameterSymbol)
					Dim type As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = item.Type
					Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = targetSignature.ParameterTypes(num2)
					If (type Is Nothing) Then
						type = typeSymbol
						If (Not item.IsByRef AndAlso source.Flags <> SourceMemberFlags.None AndAlso type.IsRestrictedType()) Then
							Binder.ReportDiagnostic(diagnostics, item.IdentifierSyntax, ERRID.ERR_RestrictedResumableType1, New [Object]() { type })
						End If
					End If
					Dim name As String = item.Name
					Dim ordinal As Integer = item.Ordinal
					Dim isByRef As Boolean = item.IsByRef
					Dim syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax = item.Syntax
					locations = item.Locations
					boundLambdaParameterSymbol(num2) = New Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol(name, ordinal, type, isByRef, syntax, locations(0))
					num2 = num2 + 1
				Loop While num2 <= num1
				If (CInt(boundLambdaParameterSymbol.Length) <> targetSignature.ParameterTypes.Length) Then
					Dim specialType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
					Dim length As Integer = CInt(boundLambdaParameterSymbol.Length) - 1
					For i As Integer = num To length
						Dim unboundLambdaParameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.UnboundLambdaParameterSymbol = DirectCast(parameters(i), Microsoft.CodeAnalysis.VisualBasic.Symbols.UnboundLambdaParameterSymbol)
						Dim type1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = unboundLambdaParameterSymbol.Type
						If (type1 Is Nothing) Then
							If (specialType Is Nothing) Then
								specialType = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Object, unboundLambdaParameterSymbol.IdentifierSyntax, diagnostics)
							End If
							type1 = specialType
							Me.ReportLambdaParameterInferredToBeObject(unboundLambdaParameterSymbol, diagnostics)
						End If
						Dim str As String = unboundLambdaParameterSymbol.Name
						Dim ordinal1 As Integer = unboundLambdaParameterSymbol.Ordinal
						Dim flag As Boolean = unboundLambdaParameterSymbol.IsByRef
						Dim modifiedIdentifierSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax = unboundLambdaParameterSymbol.Syntax
						locations = unboundLambdaParameterSymbol.Locations
						boundLambdaParameterSymbol(i) = New Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol(str, ordinal1, type1, flag, modifiedIdentifierSyntax, locations(0))
					Next

				End If
				empty = Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol)(boundLambdaParameterSymbol)
			Else
				empty = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol).Empty
			End If
			Return empty
		End Function

		Private Function BuildDelegateRelaxationLambda(ByVal syntaxNode As Microsoft.CodeAnalysis.SyntaxNode, ByVal methodGroupSyntax As Microsoft.CodeAnalysis.SyntaxNode, ByVal receiver As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal targetMethod As MethodSymbol, ByVal typeArgumentsOpt As BoundTypeArguments, ByVal qualificationKind As Microsoft.CodeAnalysis.VisualBasic.QualificationKind, ByVal delegateInvoke As MethodSymbol, ByVal delegateRelaxation As ConversionKind, ByVal isZeroArgumentKnownToBeUsed As Boolean, ByVal warnIfResultOfAsyncMethodIsDroppedDueToRelaxation As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, <Out> ByRef relaxationReceiverPlaceholder As BoundRValuePlaceholder) As BoundLambda
			relaxationReceiverPlaceholder = Nothing
			Dim constructedFrom As MethodSymbol = targetMethod.ConstructedFrom
			If (typeArgumentsOpt Is Nothing AndAlso constructedFrom.IsGenericMethod) Then
				typeArgumentsOpt = New BoundTypeArguments(methodGroupSyntax, targetMethod.TypeArguments)
				typeArgumentsOpt.SetWasCompilerGenerated()
			End If
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = receiver
			If (boundExpression IsNot Nothing AndAlso boundExpression.IsValue() AndAlso Not boundExpression.HasErrors AndAlso (Not boundExpression.IsInstanceReference() OrElse Not targetMethod.ReceiverType.IsReferenceType)) Then
				relaxationReceiverPlaceholder = New BoundRValuePlaceholder(boundExpression.Syntax, boundExpression.Type)
				boundExpression = relaxationReceiverPlaceholder
			End If
			Dim boundMethodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup = New Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup(methodGroupSyntax, typeArgumentsOpt, ImmutableArray.Create(Of MethodSymbol)(constructedFrom), LookupResultKind.Good, boundExpression, qualificationKind, False)
			boundMethodGroup.SetWasCompilerGenerated()
			Return Me.BuildDelegateRelaxationLambda(syntaxNode, delegateInvoke, boundMethodGroup, delegateRelaxation, isZeroArgumentKnownToBeUsed, warnIfResultOfAsyncMethodIsDroppedDueToRelaxation, diagnostics)
		End Function

		Private Function BuildDelegateRelaxationLambda(ByVal syntaxNode As Microsoft.CodeAnalysis.SyntaxNode, ByVal delegateInvoke As Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol, ByVal methodGroup As BoundMethodGroup, ByVal delegateRelaxation As ConversionKind, ByVal isZeroArgumentKnownToBeUsed As Boolean, ByVal warnIfResultOfAsyncMethodIsDroppedDueToRelaxation As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundLambda
			Dim flag As Boolean
			Dim returnType As TypeSymbol = delegateInvoke.ReturnType
			Dim parameters As ImmutableArray(Of ParameterSymbol) = delegateInvoke.Parameters
			Dim length As Integer = parameters.Length
			Dim boundLambdaParameterSymbol(length - 1 + 1 - 1) As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol
			Dim location As Microsoft.CodeAnalysis.Location = syntaxNode.GetLocation()
			Dim num As Integer = length - 1
			Dim num1 As Integer = 0
			Do
				Dim item As ParameterSymbol = parameters(num1)
				boundLambdaParameterSymbol(num1) = New Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol(GeneratedNames.MakeDelegateRelaxationParameterName(num1), item.Ordinal, item.Type, item.IsByRef, syntaxNode, location)
				num1 = num1 + 1
			Loop While num1 <= num
			Dim synthesizedLambdaSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaSymbol = New Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaSymbol(SynthesizedLambdaKind.DelegateRelaxationStub, syntaxNode, boundLambdaParameterSymbol.AsImmutable(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol)(), returnType, Me)
			Dim methodSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol = methodGroup.Methods(0)
			If (isZeroArgumentKnownToBeUsed) Then
				flag = True
			Else
				flag = If(length <= 0, False, methodSymbol.ParameterCount = 0)
			End If
			Dim boundExpressionArray(If(flag, 0, length) - 1 + 1 - 1) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			If (Not flag) Then
				Dim length1 As Integer = CInt(boundLambdaParameterSymbol.Length) - 1
				For i As Integer = 0 To length1
					Dim boundLambdaParameterSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol = boundLambdaParameterSymbol(i)
					Dim boundParameter As Microsoft.CodeAnalysis.VisualBasic.BoundParameter = New Microsoft.CodeAnalysis.VisualBasic.BoundParameter(syntaxNode, boundLambdaParameterSymbol1, boundLambdaParameterSymbol1.Type)
					boundParameter.SetWasCompilerGenerated()
					boundExpressionArray(i) = boundParameter
				Next

			End If
			Dim lambdaBodyBinder As Microsoft.CodeAnalysis.VisualBasic.LambdaBodyBinder = New Microsoft.CodeAnalysis.VisualBasic.LambdaBodyBinder(synthesizedLambdaSymbol, Me)
			Dim boundExpressions As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = boundExpressionArray.AsImmutable(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)()
			Dim strs As ImmutableArray(Of String) = New ImmutableArray(Of String)()
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = lambdaBodyBinder.BindInvocationExpression(syntaxNode, syntaxNode, TypeCharacter.None, methodGroup, boundExpressions, strs, diagnostics, Nothing, False, True, False, Nothing, False)
			boundExpression.SetWasCompilerGenerated()
			Dim boundStatements As ImmutableArray(Of BoundStatement) = New ImmutableArray(Of BoundStatement)()
			If (Not synthesizedLambdaSymbol.IsSub) Then
				boundExpression = lambdaBodyBinder.ApplyImplicitConversion(syntaxNode, returnType, boundExpression, diagnostics, False)
				Dim boundReturnStatement As Microsoft.CodeAnalysis.VisualBasic.BoundReturnStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundReturnStatement(syntaxNode, boundExpression, Nothing, Nothing, False)
				boundReturnStatement.SetWasCompilerGenerated()
				boundStatements = ImmutableArray.Create(Of BoundStatement)(boundReturnStatement)
			Else
				Dim boundStatementArray(1) As BoundStatement
				Dim boundExpressionStatement As BoundStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundExpressionStatement(syntaxNode, boundExpression, False)
				boundExpressionStatement.SetWasCompilerGenerated()
				boundStatementArray(0) = boundExpressionStatement
				boundExpressionStatement = New Microsoft.CodeAnalysis.VisualBasic.BoundReturnStatement(syntaxNode, Nothing, Nothing, Nothing, False)
				boundExpressionStatement.SetWasCompilerGenerated()
				boundStatementArray(1) = boundExpressionStatement
				boundStatements = Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of BoundStatement)(boundStatementArray)
				If (warnIfResultOfAsyncMethodIsDroppedDueToRelaxation AndAlso Not methodSymbol.IsSub) Then
					If (methodSymbol.IsAsync) Then
						warnIfResultOfAsyncMethodIsDroppedDueToRelaxation = CObj(methodSymbol.ContainingAssembly) = CObj(Me.Compilation.Assembly)
					Else
						warnIfResultOfAsyncMethodIsDroppedDueToRelaxation = False
						If (methodSymbol.MethodKind = MethodKind.DelegateInvoke AndAlso methodGroup.ReceiverOpt IsNot Nothing AndAlso methodGroup.ReceiverOpt.Kind = BoundKind.Conversion) Then
							Dim receiverOpt As BoundConversion = DirectCast(methodGroup.ReceiverOpt, BoundConversion)
							If (Not receiverOpt.ExplicitCastInCode AndAlso receiverOpt.Operand.Kind = BoundKind.Lambda AndAlso DirectCast(receiverOpt.Operand, Microsoft.CodeAnalysis.VisualBasic.BoundLambda).LambdaSymbol.IsAsync AndAlso receiverOpt.Type.IsDelegateType() AndAlso receiverOpt.Type.IsAnonymousType) Then
								warnIfResultOfAsyncMethodIsDroppedDueToRelaxation = True
							End If
						End If
					End If
					If (warnIfResultOfAsyncMethodIsDroppedDueToRelaxation) Then
						Binder.ReportDiagnostic(diagnostics, syntaxNode, ERRID.WRN_UnobservedAwaitableDelegate)
					End If
				End If
			End If
			Dim statementSyntaxes As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax) = New SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)()
			Dim boundBlock As Microsoft.CodeAnalysis.VisualBasic.BoundBlock = New Microsoft.CodeAnalysis.VisualBasic.BoundBlock(syntaxNode, statementSyntaxes, ImmutableArray(Of LocalSymbol).Empty, boundStatements, False)
			boundBlock.SetWasCompilerGenerated()
			Dim boundLambda As Microsoft.CodeAnalysis.VisualBasic.BoundLambda = New Microsoft.CodeAnalysis.VisualBasic.BoundLambda(syntaxNode, synthesizedLambdaSymbol, boundBlock, ImmutableBindingDiagnostic(Of AssemblySymbol).Empty, Nothing, delegateRelaxation, MethodConversionKind.Identity, False)
			boundLambda.SetWasCompilerGenerated()
			Return boundLambda
		End Function

		Friend Function CanAccessMe(ByVal implicitReference As Boolean, <Out> ByRef errorId As ERRID) As Boolean
			errorId = ERRID.ERR_None
			Return Me.CanAccessMeOrMyClass(implicitReference, errorId)
		End Function

		Private Function CanAccessMeOrMyClass(ByVal implicitReference As Boolean, <Out> ByRef errorId As ERRID) As Boolean
			errorId = ERRID.ERR_None
			Return Me.CheckMeOrMyBaseOrMyClassInSharedOrDisallowedContext(implicitReference, errorId)
		End Function

		Private Function CanAccessMyBase(ByVal implicitReference As Boolean, <Out> ByRef errorId As ERRID) As Boolean
			Dim flag As Boolean
			errorId = ERRID.ERR_None
			If (Not Me.CheckMeOrMyBaseOrMyClassInSharedOrDisallowedContext(implicitReference, errorId)) Then
				flag = False
			ElseIf (Not Me.ContainingType.IsStructureType()) Then
				flag = True
			Else
				errorId = ERRID.ERR_UseOfKeywordFromStructure1
				flag = False
			End If
			Return flag
		End Function

		Private Function CanAccessMyClass(ByVal implicitReference As Boolean, <Out> ByRef errorId As ERRID) As Boolean
			Dim flag As Boolean
			errorId = ERRID.ERR_None
			If (Me.ContainingType Is Nothing OrElse Not Me.ContainingType.IsModuleType()) Then
				flag = Me.CanAccessMeOrMyClass(implicitReference, errorId)
			Else
				errorId = ERRID.ERR_MyClassNotInClass
				flag = False
			End If
			Return flag
		End Function

		Friend Function CanAddLookupSymbolInfo(ByVal sym As Symbol, ByVal options As LookupOptions, ByVal nameSet As LookupSymbolsInfo, ByVal accessThroughType As TypeSymbol) As Boolean
			' 
			' Current member / type: System.Boolean Microsoft.CodeAnalysis.VisualBasic.Binder::CanAddLookupSymbolInfo(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: System.Boolean CanAddLookupSymbolInfo(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Function

		Private Shared Function CanBeImplicitVariableDeclaration(ByVal nameSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax) As Boolean
			Dim flag As Boolean
			If (nameSyntax.Kind() = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IdentifierName) Then
				Dim parent As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode = nameSyntax.Parent
				If (parent IsNot Nothing) Then
					Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = parent.Kind()
					If (syntaxKind <= Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleMemberAccessExpression) Then
						If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CatchStatement) Then
							If (DirectCast(parent, Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax).IdentifierName <> nameSyntax) Then
								GoTo Label1
							End If
							flag = False
							Return flag
						ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleMemberAccessExpression) Then
							If (DirectCast(parent, Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax).Expression <> nameSyntax) Then
								GoTo Label1
							End If
							flag = False
							Return flag
						End If
					ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InvocationExpression) Then
						If (DirectCast(parent, Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax).Expression <> nameSyntax) Then
							GoTo Label1
						End If
						flag = False
						Return flag
					ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ConditionalAccessExpression) Then
						Dim conditionalAccessExpressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax = DirectCast(parent, Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax)
						If (conditionalAccessExpressionSyntax.Expression = nameSyntax) Then
							Dim leafAccess As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = conditionalAccessExpressionSyntax.GetLeafAccess()
							If (leafAccess Is Nothing OrElse leafAccess.Kind() <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleMemberAccessExpression AndAlso leafAccess.Kind() <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InvocationExpression) Then
								GoTo Label1
							End If
							flag = False
							Return flag
						End If
					End If
				End If
			Label1:
				Dim identifier As Microsoft.CodeAnalysis.SyntaxToken = nameSyntax.Identifier
				Dim str As String = SyntaxFacts.MakeHalfWidthIdentifier(identifier.ValueText)
				flag = If(CaseInsensitiveComparison.Equals(str, "Null") OrElse CaseInsensitiveComparison.Equals(str, "Empty") OrElse CaseInsensitiveComparison.Equals(str, "RND"), False, True)
			Else
				flag = False
			End If
			Return flag
		End Function

		Public Overridable Function CheckAccessibility(ByVal sym As Symbol, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol), Optional ByVal accessThroughType As TypeSymbol = Nothing, Optional ByVal basesBeingResolved As Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolved = Nothing) As AccessCheckResult
			Return Me.m_containingBinder.CheckAccessibility(sym, useSiteInfo, accessThroughType, basesBeingResolved)
		End Function

		Private Sub CheckAttributeTypeViability(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
			Dim eRRID As Microsoft.CodeAnalysis.VisualBasic.ERRID
			Dim symbol As Microsoft.CodeAnalysis.VisualBasic.Symbol = lookupResult.SingleSymbol.UnwrapAlias()
			Dim badSymbolDiagnostic As DiagnosticInfo = Nothing
			If (symbol.Kind = SymbolKind.[Namespace]) Then
				eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_UnrecognizedType
			ElseIf (symbol.Kind = SymbolKind.TypeParameter) Then
				eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_AttrCannotBeGenerics
			ElseIf (symbol.Kind = SymbolKind.NamedType) Then
				Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = DirectCast(symbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)
				Dim compoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = If(useSiteInfo.AccumulatesDependencies, New CompoundUseSiteInfo(Of AssemblySymbol)(Me.Compilation.Assembly), CompoundUseSiteInfo(Of AssemblySymbol).DiscardedDependencies)
				If (namedTypeSymbol.IsGenericType) Then
					eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_AttrCannotBeGenerics
				ElseIf (namedTypeSymbol.IsStructureType()) Then
					eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_AttributeMustBeClassNotStruct1
				ElseIf (Me.Compilation.GetWellKnownType(WellKnownType.System_Attribute).IsBaseTypeOf(namedTypeSymbol, compoundUseSiteInfo)) Then
					If (Not namedTypeSymbol.IsMustInherit) Then
						useSiteInfo.MergeAndClear(compoundUseSiteInfo)
						Return
					End If
					eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_AttributeCannotBeAbstract
				Else
					eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_AttributeMustInheritSysAttr
					If (Not compoundUseSiteInfo.Diagnostics.IsNullOrEmpty()) Then
						badSymbolDiagnostic = compoundUseSiteInfo.Diagnostics.First()
					End If
				End If
			Else
				eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_UnrecognizedType
			End If
			If (badSymbolDiagnostic Is Nothing) Then
				badSymbolDiagnostic = New Microsoft.CodeAnalysis.VisualBasic.BadSymbolDiagnostic(symbol, eRRID)
			End If
			lookupResult.Clear()
			lookupResult.SetFrom(SingleLookupResult.NotAnAttributeType(symbol, badSymbolDiagnostic))
		End Sub

		Private Function CheckConversionForConstantExpression(ByVal conv As BoundExpression, ByVal operand As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal context As Binder.ConstantContext) As ConstantValue
			Dim constantValueOpt As ConstantValue
			If (Not conv.HasErrors) Then
				Dim type As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = conv.Type
				Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = operand.Type
				If (Not operand.IsNothingLiteral()) Then
					Dim expressionConstantValueIfAny As ConstantValue = Me.GetExpressionConstantValueIfAny(operand, diagnostics, context)
					If (expressionConstantValueIfAny Is Nothing) Then
						constantValueOpt = Nothing
					ElseIf (type.IsObjectType()) Then
						If (typeSymbol.IsReferenceType AndAlso expressionConstantValueIfAny.IsNothing) Then
							constantValueOpt = expressionConstantValueIfAny
						ElseIf (context <> Binder.ConstantContext.ParameterDefaultValue OrElse Not Binder.IsNothingLiteralAllowedForAType(typeSymbol) AndAlso Not typeSymbol.IsDateTimeType() AndAlso Not typeSymbol.IsDecimalType()) Then
							Binder.ReportDiagnostic(diagnostics, operand.Syntax, ERRID.ERR_RequiredConstConversion2, New [Object]() { typeSymbol, type })
							constantValueOpt = Nothing
						Else
							constantValueOpt = expressionConstantValueIfAny
						End If
					ElseIf (Not expressionConstantValueIfAny.IsNothing) Then
						If (context = Binder.ConstantContext.ParameterDefaultValue AndAlso type.IsNullableType()) Then
							If (Not type.GetNullableUnderlyingType().IsSameTypeIgnoringAll(typeSymbol)) Then
								expressionConstantValueIfAny = Me.ApplyConversion(operand.Syntax, type.GetNullableUnderlyingType(), operand, True, Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded, False, False).ConstantValueOpt
								If (expressionConstantValueIfAny Is Nothing) Then
									GoTo Label1
								End If
								constantValueOpt = expressionConstantValueIfAny
								Return constantValueOpt
							Else
								constantValueOpt = expressionConstantValueIfAny
								Return constantValueOpt
							End If
						End If
					Label1:
						Dim syntax As Microsoft.CodeAnalysis.SyntaxNodeOrToken = operand.Syntax
						Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_RequiredConstConversion2, New [Object]() { typeSymbol, type })
						constantValueOpt = Nothing
					ElseIf (typeSymbol.IsSameTypeIgnoringAll(type)) Then
						constantValueOpt = expressionConstantValueIfAny
					ElseIf (typeSymbol.IsReferenceType AndAlso (type.IsReferenceType OrElse context = Binder.ConstantContext.ParameterDefaultValue)) Then
						constantValueOpt = expressionConstantValueIfAny
					ElseIf (context <> Binder.ConstantContext.ParameterDefaultValue OrElse Not type.IsNullableType()) Then
						Binder.ReportDiagnostic(diagnostics, operand.Syntax, ERRID.ERR_RequiredConstConversion2, New [Object]() { typeSymbol, type })
						constantValueOpt = Nothing
					Else
						constantValueOpt = expressionConstantValueIfAny
					End If
				ElseIf (context <> Binder.ConstantContext.[Default] OrElse Binder.IsNothingLiteralAllowedForAType(type)) Then
					constantValueOpt = operand.ConstantValueOpt
				Else
					Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
					Dim syntaxNodeOrToken As Microsoft.CodeAnalysis.SyntaxNodeOrToken = operand.Syntax
					Dim objArray(1) As [Object]
					Dim specialType As Object = typeSymbol
					If (specialType Is Nothing) Then
						specialType = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Object, operand.Syntax, diagnostics)
					End If
					objArray(0) = specialType
					objArray(1) = type
					Binder.ReportDiagnostic(bindingDiagnosticBag, syntaxNodeOrToken, ERRID.ERR_RequiredConstConversion2, objArray)
					constantValueOpt = Nothing
				End If
			Else
				constantValueOpt = Nothing
			End If
			Return constantValueOpt
		End Function

		Private Shared Function CheckDelegateParameterModifier(ByVal container As Symbol, ByVal token As Microsoft.CodeAnalysis.SyntaxToken, ByVal flag As SourceParameterFlags, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As SourceParameterFlags
			If ((flag And SourceParameterFlags.[ParamArray]) = SourceParameterFlags.[ParamArray]) Then
				Dim location As Microsoft.CodeAnalysis.Location = token.GetLocation()
				diagnostics.Add(ERRID.ERR_ParamArrayIllegal1, location, New [Object]() { Binder.GetDelegateOrEventKeywordText(container) })
				flag = flag And (SourceParameterFlags.[ByVal] Or SourceParameterFlags.[ByRef] Or SourceParameterFlags.[Optional])
			End If
			If ((flag And SourceParameterFlags.[Optional]) = SourceParameterFlags.[Optional]) Then
				Dim location1 As Microsoft.CodeAnalysis.Location = token.GetLocation()
				diagnostics.Add(ERRID.ERR_OptionalIllegal1, location1, New [Object]() { Binder.GetDelegateOrEventKeywordText(container) })
				flag = flag And (SourceParameterFlags.[ByVal] Or SourceParameterFlags.[ByRef] Or SourceParameterFlags.[ParamArray])
			End If
			Return flag
		End Function

		Private Sub CheckMemberTypeAccessibility(ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal node As SyntaxNode, ByVal member As Symbol)
			Dim type As TypeSymbol
			Dim kind As SymbolKind = member.Kind
			If (kind = SymbolKind.Field) Then
				Dim fieldSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol = DirectCast(member, Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol)
				If (Not fieldSymbol.HasDeclaredType) Then
					Return
				End If
				type = fieldSymbol.Type
			ElseIf (kind = SymbolKind.Method) Then
				type = DirectCast(member, MethodSymbol).ReturnType
			Else
				If (kind <> SymbolKind.[Property]) Then
					Throw ExceptionUtilities.UnexpectedValue(member.Kind)
				End If
				type = DirectCast(member, PropertySymbol).Type
			End If
			Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
			Dim basesBeingResolved As Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolved = New Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolved()
			If (Me.CheckAccessibility(type, newCompoundUseSiteInfo, Nothing, basesBeingResolved) <> AccessCheckResult.Accessible) Then
				Binder.ReportDiagnostic(diagnostics, node, New BadSymbolDiagnostic(member, ERRID.ERR_InaccessibleReturnTypeOfMember2, New [Object]() { CustomSymbolDisplayFormatter.WithContainingType(member) }))
			End If
			diagnostics.Add(node, newCompoundUseSiteInfo)
		End Sub

		Private Function CheckMeOrMyBaseOrMyClassInSharedOrDisallowedContext(ByVal implicitReference As Boolean, <Out> ByRef errorId As Microsoft.CodeAnalysis.VisualBasic.ERRID) As Boolean
			Dim flag As Boolean
			Dim eRRID As Microsoft.CodeAnalysis.VisualBasic.ERRID
			errorId = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_None
			Dim containingType As NamedTypeSymbol = Me.ContainingType
			If (containingType IsNot Nothing AndAlso containingType.IsScriptClass) Then
				If (Not implicitReference) Then
					errorId = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_KeywordNotAllowedInScript
					flag = False
				Else
					flag = True
				End If
			ElseIf (Me.IsMeOrMyBaseOrMyClassInSharedContext()) Then
				If (implicitReference) Then
					eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_BadInstanceMemberAccess
				Else
					eRRID = If(containingType Is Nothing OrElse Not containingType.IsModuleType(), Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_UseOfKeywordNotInInstanceMethod1, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_UseOfKeywordFromModule1)
				End If
				errorId = eRRID
				flag = False
			ElseIf (Not Me.IsInsideChainedConstructorCallArguments) Then
				flag = True
			Else
				errorId = If(implicitReference, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_InvalidImplicitMeReference, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_InvalidMeReference)
				flag = False
			End If
			Return flag
		End Function

		Private Sub CheckNamedArgumentsForLateboundInvocation(ByVal argumentNames As ImmutableArray(Of String), ByVal arguments As ImmutableArray(Of BoundExpression), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			If (Not argumentNames.IsDefault AndAlso argumentNames.Length <> 0 AndAlso Me.Compilation.LanguageVersion.AllowNonTrailingNamedArguments()) Then
				Dim flag As Boolean = False
				Dim length As Integer = argumentNames.Length - 1
				For i As Integer = 0 To length
					If (argumentNames(i) IsNot Nothing) Then
						flag = True
					ElseIf (flag) Then
						Binder.ReportDiagnostic(diagnostics, arguments(i).Syntax, ERRID.ERR_NamedArgumentSpecificationBeforeFixedArgumentInLateboundInvocation)
						Return
					End If
				Next

			End If
		End Sub

		Private Shared Function CheckOperatorParameterModifier(ByVal container As Symbol, ByVal token As Microsoft.CodeAnalysis.SyntaxToken, ByVal flag As SourceParameterFlags, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As SourceParameterFlags
			' 
			' Current member / type: Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceParameterFlags Microsoft.CodeAnalysis.VisualBasic.Binder::CheckOperatorParameterModifier(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceParameterFlags,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceParameterFlags CheckOperatorParameterModifier(Microsoft.CodeAnalysis.VisualBasic.Symbol,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceParameterFlags,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Function

		Friend Shared Sub CheckParameterNameNotDuplicate(ByVal params As ArrayBuilder(Of ParameterSymbol), ByVal nParams As Integer, ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax, ByVal parameter As ParameterSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Dim name As String = parameter.Name
			Dim num As Integer = nParams - 1
			For i As Integer = 0 To num
				If (CaseInsensitiveComparison.Equals(params(i).Name, name)) Then
					Binder.ReportDiagnostic(diagnostics, syntax.Identifier, ERRID.ERR_DuplicateParamName1, New [Object]() { name })
					Return
				End If
			Next

		End Sub

		Private Shared Function CheckPropertyParameterModifier(ByVal container As Symbol, ByVal token As Microsoft.CodeAnalysis.SyntaxToken, ByVal flag As SourceParameterFlags, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As SourceParameterFlags
			Dim sourceParameterFlag As SourceParameterFlags
			If (flag <> SourceParameterFlags.[ByRef]) Then
				sourceParameterFlag = flag
			Else
				Dim location As Microsoft.CodeAnalysis.Location = token.GetLocation()
				diagnostics.Add(ERRID.ERR_ByRefIllegal1, location, New [Object]() { container.GetKindText(), token.ToString() })
				sourceParameterFlag = flag And (SourceParameterFlags.[ByVal] Or SourceParameterFlags.[Optional] Or SourceParameterFlags.[ParamArray])
			End If
			Return sourceParameterFlag
		End Function

		Private Sub CheckRangeArgumentLowerBound(ByVal rangeArgument As Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Dim constantValueOpt As ConstantValue = Me.BindValue(rangeArgument.LowerBound, diagnostics, False).ConstantValueOpt
			If (constantValueOpt Is Nothing OrElse Not constantValueOpt.IsIntegral OrElse Not constantValueOpt.IsDefaultValue) Then
				Binder.ReportDiagnostic(diagnostics, rangeArgument.LowerBound, ERRID.ERR_OnlyNullLowerBound)
			End If
		End Sub

		Private Shared Function CheckReservedParameterName(ByVal reservedName As String, ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax, ByVal errorId As ERRID, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
			Dim flag As Boolean
			Dim identifier As Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax = syntax.Identifier
			If (Not CaseInsensitiveComparison.Equals(reservedName, identifier.Identifier.ValueText)) Then
				flag = True
			Else
				diagnostics.Add(errorId, identifier.GetLocation())
				flag = False
			End If
			Return flag
		End Function

		Private Function CheckSharedSymbolAccess(ByVal node As SyntaxNode, ByVal isShared As Boolean, <InAttribute> <Out> ByRef receiver As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal qualKind As QualificationKind, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
			Dim flag As Boolean
			If (isShared) Then
				If (qualKind = QualificationKind.QualifiedViaValue AndAlso receiver IsNot Nothing AndAlso receiver.Kind <> BoundKind.TypeOrValueExpression AndAlso receiver.Kind <> BoundKind.MyBaseReference AndAlso Not receiver.HasErrors AndAlso (node.Parent Is Nothing OrElse node.Parent.Kind() <> SyntaxKind.NamedFieldInitializer)) Then
					Binder.ReportDiagnostic(diagnostics, node, Microsoft.CodeAnalysis.VisualBasic.ERRID.WRN_SharedMemberThroughInstance)
				End If
			ElseIf (qualKind = QualificationKind.QualifiedViaTypeName OrElse qualKind = QualificationKind.Unqualified AndAlso receiver Is Nothing) Then
				If (qualKind = QualificationKind.QualifiedViaTypeName AndAlso receiver IsNot Nothing AndAlso receiver.Kind = BoundKind.TypeExpression) Then
					Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.TryDefaultInstanceProperty(DirectCast(receiver, BoundTypeExpression), diagnostics)
					If (boundExpression Is Nothing) Then
						GoTo Label1
					End If
					receiver = boundExpression
					flag = False
					Return flag
				End If
			Label1:
				If (receiver Is Nothing OrElse receiver.Kind <> BoundKind.TypeExpression OrElse Not Binder.IsReceiverOfNameOfArgument(receiver.Syntax)) Then
					Binder.ReportDiagnostic(diagnostics, node, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_ObjectReferenceNotSupplied)
					flag = True
					Return flag
				Else
					receiver = (New BoundTypeAsValueExpression(receiver.Syntax, DirectCast(receiver, BoundTypeExpression), receiver.Type, False)).MakeCompilerGenerated()
					flag = False
					Return flag
				End If
			Else
				Dim eRRID As Microsoft.CodeAnalysis.VisualBasic.ERRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_None
				If (qualKind <> QualificationKind.Unqualified OrElse Binder.IsNameOfArgument(node) OrElse Me.CanAccessMe(True, eRRID)) Then
					flag = False
					Return flag
				End If
				Binder.ReportDiagnostic(diagnostics, node, eRRID)
				flag = True
				Return flag
			End If
			flag = False
			Return flag
		End Function

		Private Shared Function CheckTupleMemberName(ByVal name As String, ByVal index As Integer, ByVal syntax As SyntaxNodeOrToken, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal uniqueFieldNames As HashSet(Of String)) As Boolean
			Dim flag As Boolean
			Dim num As Integer = TupleTypeSymbol.IsElementNameReserved(name)
			If (num = 0) Then
				Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_TupleReservedElementNameAnyPosition, New [Object]() { name })
				flag = False
			ElseIf (num > 0 AndAlso num <> index + 1) Then
				Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_TupleReservedElementName, New [Object]() { name, num })
				flag = False
			ElseIf (uniqueFieldNames.Add(name)) Then
				flag = True
			Else
				Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_TupleDuplicateElementName)
				flag = False
			End If
			Return flag
		End Function

		Friend Function CheckViability(ByVal sym As Symbol, ByVal arity As Integer, ByVal options As LookupOptions, ByVal accessThroughType As TypeSymbol, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol)) As SingleLookupResult
			' 
			' Current member / type: Microsoft.CodeAnalysis.VisualBasic.SingleLookupResult Microsoft.CodeAnalysis.VisualBasic.Binder::CheckViability(Microsoft.CodeAnalysis.VisualBasic.Symbol,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo`1<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: Microsoft.CodeAnalysis.VisualBasic.SingleLookupResult CheckViability(Microsoft.CodeAnalysis.VisualBasic.Symbol,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Function

		Private Function CheckXmlFeaturesAllowed(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag
			Dim discarded As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag
			If (Not Me.Compilation.GetWellKnownType(WellKnownType.System_Xml_Linq_XObject).IsErrorType()) Then
				discarded = diagnostics
			Else
				Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_XmlFeaturesNotAvailable)
				discarded = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
			End If
			Return discarded
		End Function

		Friend Shared Function ClassifyAddressOfConversion(ByVal source As BoundAddressOfOperator, ByVal destination As TypeSymbol) As ConversionKind
			Return source.GetConversionClassification(destination)
		End Function

		Protected Overridable Sub CollectProbableExtensionMethodsInSingleBinder(ByVal name As String, ByVal methods As ArrayBuilder(Of MethodSymbol), ByVal originalBinder As Binder)
		End Sub

		Private Shared Sub CollectTupleFieldMemberName(ByVal name As String, ByVal elementIndex As Integer, ByVal tupleSize As Integer, ByRef elementNames As ArrayBuilder(Of String))
			If (elementNames IsNot Nothing) Then
				elementNames.Add(name)
				Return
			End If
			If (name IsNot Nothing) Then
				elementNames = ArrayBuilder(Of String).GetInstance(tupleSize)
				Dim num As Integer = elementIndex
				Dim num1 As Integer = 1
				Do
					elementNames.Add(Nothing)
					num1 = num1 + 1
				Loop While num1 <= num
				elementNames.Add(name)
			End If
		End Sub

		Private Function CompleteAggregateClauseBinding(ByVal aggregate As Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax, ByVal operatorsEnumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator, ByVal sourceRangeVariablesPart1 As ImmutableArray(Of RangeVariableSymbol), ByVal sourceRangeVariablesPart2 As ImmutableArray(Of RangeVariableSymbol), ByVal firstSelectExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal firstSelectSelectorBinder As Binder.QueryLambdaBinder, ByVal firstSelectDeclaredRangeVariables As ImmutableArray(Of RangeVariableSymbol), ByVal firstSelectCompoundVariableType As TypeSymbol, ByVal group As BoundQueryClauseBase, ByVal intoBinder As Binder.IntoClauseDisallowGroupReferenceBinder, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundAggregateClause
			Dim boundAggregateClause As Microsoft.CodeAnalysis.VisualBasic.BoundAggregateClause
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim empty As ImmutableArray(Of RangeVariableSymbol)
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim rangeVariableSymbols As ImmutableArray(Of RangeVariableSymbol)
			Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim bitVector As Microsoft.CodeAnalysis.BitVector
			Dim aggregationVariables As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax) = aggregate.AggregationVariables
			If (aggregationVariables.Count > 1) Then
				Dim kind As Boolean = firstSelectExpression.Kind = BoundKind.BadExpression
				If (Not kind AndAlso firstSelectExpression.HasErrors AndAlso firstSelectExpression.Kind = BoundKind.QueryClause) Then
					kind = DirectCast(firstSelectExpression, Microsoft.CodeAnalysis.VisualBasic.BoundQueryClause).UnderlyingExpression.Kind = BoundKind.BadExpression
				End If
				Dim boundQueryClause As Microsoft.CodeAnalysis.VisualBasic.BoundQueryClause = (New Microsoft.CodeAnalysis.VisualBasic.BoundQueryClause(aggregate, firstSelectExpression, Microsoft.CodeAnalysis.ImmutableArrayExtensions.Concat(Of RangeVariableSymbol)(firstSelectSelectorBinder.RangeVariables, firstSelectDeclaredRangeVariables), firstSelectCompoundVariableType, ImmutableArray(Of Binder).Empty, firstSelectExpression.Type, False)).MakeCompilerGenerated()
				Dim boundLambdaParameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol = Me.CreateQueryLambdaParameterSymbol(Binder.GetQueryLambdaParameterName(boundQueryClause.RangeVariables), 0, boundQueryClause.CompoundVariableType, aggregate, boundQueryClause.RangeVariables)
				Dim synthesizedLambdaSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaSymbol = Me.CreateQueryLambdaSymbol(aggregate, SynthesizedLambdaKind.AggregateNonUserCodeQueryLambda, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol)(boundLambdaParameterSymbol))
				Dim item As RangeVariableSymbol = firstSelectDeclaredRangeVariables(0)
				Dim queryLambdaBinder As Binder.QueryLambdaBinder = New Binder.QueryLambdaBinder(synthesizedLambdaSymbol, ImmutableArray(Of RangeVariableSymbol).Empty)
				Dim boundRangeVariable As Microsoft.CodeAnalysis.VisualBasic.BoundRangeVariable = (New Microsoft.CodeAnalysis.VisualBasic.BoundRangeVariable(item.Syntax, item, item.Type)).MakeCompilerGenerated()
				intoBinder = New Binder.IntoClauseDisallowGroupReferenceBinder(queryLambdaBinder, boundRangeVariable, group.RangeVariables, group.CompoundVariableType, Microsoft.CodeAnalysis.ImmutableArrayExtensions.Concat(Of RangeVariableSymbol)(firstSelectSelectorBinder.RangeVariables, group.RangeVariables))
				If (sourceRangeVariablesPart1.Length > 0) Then
					Dim type As AnonymousTypeManager.AnonymousTypePublicSymbol = DirectCast(boundLambdaParameterSymbol.Type, AnonymousTypeManager.AnonymousTypePublicSymbol)
					Dim anonymousTypePropertyPublicSymbol As AnonymousTypeManager.AnonymousTypePropertyPublicSymbol = type.Properties(0)
					Dim boundParameter As Microsoft.CodeAnalysis.VisualBasic.BoundParameter = (New Microsoft.CodeAnalysis.VisualBasic.BoundParameter(boundLambdaParameterSymbol.Syntax, boundLambdaParameterSymbol, False, boundLambdaParameterSymbol.Type)).MakeCompilerGenerated()
					Dim u00210s As ImmutableArray(Of !0) = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty
					bitVector = New Microsoft.CodeAnalysis.BitVector()
					boundExpression = (New BoundPropertyAccess(aggregate, anonymousTypePropertyPublicSymbol, Nothing, PropertyAccessKind.[Get], False, boundParameter, u00210s, bitVector, False)).MakeCompilerGenerated()
					empty = sourceRangeVariablesPart1
					If (sourceRangeVariablesPart2.Length <= 0) Then
						boundExpression1 = Nothing
						rangeVariableSymbols = ImmutableArray(Of RangeVariableSymbol).Empty
					Else
						anonymousTypePropertyPublicSymbol = type.Properties(1)
						Dim boundParameter1 As Microsoft.CodeAnalysis.VisualBasic.BoundParameter = (New Microsoft.CodeAnalysis.VisualBasic.BoundParameter(boundLambdaParameterSymbol.Syntax, boundLambdaParameterSymbol, False, boundLambdaParameterSymbol.Type)).MakeCompilerGenerated()
						Dim empty1 As ImmutableArray(Of !0) = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty
						bitVector = New Microsoft.CodeAnalysis.BitVector()
						boundExpression1 = (New BoundPropertyAccess(aggregate, anonymousTypePropertyPublicSymbol, Nothing, PropertyAccessKind.[Get], False, boundParameter1, empty1, bitVector, False)).MakeCompilerGenerated()
						rangeVariableSymbols = sourceRangeVariablesPart2
					End If
				ElseIf (sourceRangeVariablesPart2.Length <= 0) Then
					boundExpression = Nothing
					empty = ImmutableArray(Of RangeVariableSymbol).Empty
					boundExpression1 = Nothing
					rangeVariableSymbols = ImmutableArray(Of RangeVariableSymbol).Empty
				Else
					Dim item1 As AnonymousTypeManager.AnonymousTypePropertyPublicSymbol = DirectCast(boundLambdaParameterSymbol.Type, AnonymousTypeManager.AnonymousTypePublicSymbol).Properties(0)
					Dim boundParameter2 As Microsoft.CodeAnalysis.VisualBasic.BoundParameter = (New Microsoft.CodeAnalysis.VisualBasic.BoundParameter(boundLambdaParameterSymbol.Syntax, boundLambdaParameterSymbol, False, boundLambdaParameterSymbol.Type)).MakeCompilerGenerated()
					Dim u00210s1 As ImmutableArray(Of !0) = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty
					bitVector = New Microsoft.CodeAnalysis.BitVector()
					boundExpression = (New BoundPropertyAccess(aggregate, item1, Nothing, PropertyAccessKind.[Get], False, boundParameter2, u00210s1, bitVector, False)).MakeCompilerGenerated()
					empty = sourceRangeVariablesPart2
					boundExpression1 = Nothing
					rangeVariableSymbols = ImmutableArray(Of RangeVariableSymbol).Empty
				End If
				Dim rangeVariableSymbols1 As ImmutableArray(Of RangeVariableSymbol) = New ImmutableArray(Of RangeVariableSymbol)()
				Dim boundExpression3 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = intoBinder.BindIntoSelector(aggregate, firstSelectSelectorBinder.RangeVariables, boundExpression, empty, boundExpression1, rangeVariableSymbols, Nothing, aggregationVariables, Binder.MustProduceFlatCompoundVariable(operatorsEnumerator), rangeVariableSymbols1, diagnostics)
				Dim boundQueryLambda As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Binder.CreateBoundQueryLambda(synthesizedLambdaSymbol, boundQueryClause.RangeVariables, boundExpression3, False)
				synthesizedLambdaSymbol.SetQueryLambdaReturnType(boundExpression3.Type)
				boundQueryLambda.SetWasCompilerGenerated()
				If (Not boundQueryClause.Type.IsErrorType()) Then
					Dim discarded As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
					If (kind OrElse Binder.ShouldSuppressDiagnostics(boundQueryLambda)) Then
						discarded = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
					End If
					Dim boundExpressions As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundQueryLambda)
					Dim aggregateKeyword As Microsoft.CodeAnalysis.SyntaxToken = aggregate.AggregateKeyword
					boundExpression2 = Me.BindQueryOperatorCall(aggregate, boundQueryClause, "Select", boundExpressions, aggregateKeyword.Span, discarded)
				Else
					boundExpression2 = Binder.BadExpression(aggregate, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundQueryClause, boundQueryLambda), ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
				End If
				boundAggregateClause = New Microsoft.CodeAnalysis.VisualBasic.BoundAggregateClause(aggregate, Nothing, Nothing, boundExpression2, Microsoft.CodeAnalysis.ImmutableArrayExtensions.Concat(Of RangeVariableSymbol)(firstSelectSelectorBinder.RangeVariables, rangeVariableSymbols1), boundQueryLambda.Expression.Type, ImmutableArray.Create(Of Binder)(firstSelectSelectorBinder, intoBinder), boundExpression2.Type, False)
			Else
				boundAggregateClause = New Microsoft.CodeAnalysis.VisualBasic.BoundAggregateClause(aggregate, Nothing, Nothing, firstSelectExpression, Microsoft.CodeAnalysis.ImmutableArrayExtensions.Concat(Of RangeVariableSymbol)(firstSelectSelectorBinder.RangeVariables, firstSelectDeclaredRangeVariables), firstSelectCompoundVariableType, ImmutableArray.Create(Of Binder)(firstSelectSelectorBinder, intoBinder), firstSelectExpression.Type, False)
			End If
			Return boundAggregateClause
		End Function

		Private Shared Function ComputeArrayLiteralRank(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax) As Integer
			Dim num As Integer = 1
			While True
				Dim initializers As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax) = node.Initializers
				If (initializers.Count = 0) Then
					Exit While
				End If
				node = TryCast(initializers(0), Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax)
				If (node Is Nothing) Then
					Exit While
				End If
				num = num + 1
			End While
			Return num
		End Function

		Private Function ComputeCaseClauseCondition(ByVal caseClause As Microsoft.CodeAnalysis.VisualBasic.BoundCaseClause, <Out> ByRef conditionOpt As BoundExpression, ByVal selectExpression As BoundRValuePlaceholder, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundCaseClause
			Dim boundCaseClause As Microsoft.CodeAnalysis.VisualBasic.BoundCaseClause
			Select Case caseClause.Kind
				Case BoundKind.SimpleCaseClause
					boundCaseClause = Me.ComputeSimpleCaseClauseCondition(DirectCast(caseClause, BoundSimpleCaseClause), conditionOpt, selectExpression, diagnostics)
					Exit Select
				Case BoundKind.RangeCaseClause
					boundCaseClause = Me.ComputeRangeCaseClauseCondition(DirectCast(caseClause, BoundRangeCaseClause), conditionOpt, selectExpression, diagnostics)
					Exit Select
				Case BoundKind.RelationalCaseClause
					boundCaseClause = Me.ComputeRelationalCaseClauseCondition(DirectCast(caseClause, BoundRelationalCaseClause), conditionOpt, selectExpression, diagnostics)
					Exit Select
				Case Else
					Throw ExceptionUtilities.UnexpectedValue(caseClause.Kind)
			End Select
			Return boundCaseClause
		End Function

		Private Function ComputeRangeCaseClauseCondition(ByVal boundClause As BoundRangeCaseClause, <Out> ByRef conditionOpt As BoundExpression, ByVal selectExpression As BoundRValuePlaceholder, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundCaseClause
			Dim syntax As SyntaxNode = boundClause.Syntax
			Dim lowerBoundConditionOpt As BoundExpression = If(boundClause.LowerBoundConditionOpt, Me.BindBinaryOperator(boundClause.Syntax, selectExpression, boundClause.LowerBoundOpt, SyntaxKind.GreaterThanEqualsToken, BinaryOperatorKind.GreaterThanOrEqual, False, diagnostics, True).MakeCompilerGenerated())
			Dim upperBoundConditionOpt As BoundExpression = If(boundClause.UpperBoundConditionOpt, Me.BindBinaryOperator(syntax, selectExpression, boundClause.UpperBoundOpt, SyntaxKind.LessThanEqualsToken, BinaryOperatorKind.LessThanOrEqual, False, diagnostics, True).MakeCompilerGenerated())
			conditionOpt = Me.BindBinaryOperator(syntax, lowerBoundConditionOpt, upperBoundConditionOpt, SyntaxKind.AndAlsoKeyword, BinaryOperatorKind.[AndAlso], False, diagnostics, True).MakeCompilerGenerated()
			Return boundClause.Update(Nothing, Nothing, lowerBoundConditionOpt, upperBoundConditionOpt)
		End Function

		Private Function ComputeRelationalCaseClauseCondition(ByVal boundClause As BoundRelationalCaseClause, <Out> ByRef conditionOpt As BoundExpression, ByVal selectExpression As BoundRValuePlaceholder, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundCaseClause
			Dim syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax = DirectCast(boundClause.Syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax)
			conditionOpt = If(boundClause.ConditionOpt, Me.BindBinaryOperator(syntax, selectExpression, boundClause.ValueOpt, syntax.OperatorToken.Kind(), boundClause.OperatorKind, False, diagnostics, True).MakeCompilerGenerated())
			Return boundClause.Update(boundClause.OperatorKind, Nothing, conditionOpt)
		End Function

		Private Function ComputeSimpleCaseClauseCondition(ByVal boundClause As BoundSimpleCaseClause, <Out> ByRef conditionOpt As BoundExpression, ByVal selectExpression As BoundRValuePlaceholder, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundCaseClause
			conditionOpt = If(boundClause.ConditionOpt, Me.BindBinaryOperator(boundClause.Syntax, selectExpression, boundClause.ValueOpt, SyntaxKind.EqualsToken, BinaryOperatorKind.Equals, False, diagnostics, True).MakeCompilerGenerated())
			Return boundClause.Update(Nothing, conditionOpt)
		End Function

		Friend Function ComputeVariableType(ByVal symbol As LocalSymbol, ByVal modifiedIdentifierOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax, ByVal asClauseOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax, ByVal equalsValueOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax, <Out> ByRef valueExpression As BoundExpression, <Out> ByRef asClauseType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim type As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim flag As Boolean
			valueExpression = Nothing
			Dim getErrorInfoERRStrictDisallowImplicitObject As Func(Of DiagnosticInfo) = Nothing
			If (Not symbol.IsStatic) Then
				If (Not Me.OptionInfer OrElse equalsValueOpt Is Nothing) Then
					If (Me.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.[On]) Then
						getErrorInfoERRStrictDisallowImplicitObject = ErrorFactory.GetErrorInfo_ERR_StrictDisallowImplicitObject
					ElseIf (Me.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.Custom) Then
						getErrorInfoERRStrictDisallowImplicitObject = ErrorFactory.GetErrorInfo_WRN_ObjectAssumedVar1_WRN_MissingAsClauseinVarDecl
					End If
				End If
			ElseIf (Me.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.[On]) Then
				getErrorInfoERRStrictDisallowImplicitObject = ErrorFactory.GetErrorInfo_ERR_StrictDisallowImplicitObject
			ElseIf (Me.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.Custom) Then
				getErrorInfoERRStrictDisallowImplicitObject = ErrorFactory.GetErrorInfo_WRN_ObjectAssumedVar1_WRN_StaticLocalNoInference
			End If
			If (modifiedIdentifierOpt Is Nothing) Then
				Dim identifierToken As Microsoft.CodeAnalysis.SyntaxToken = symbol.IdentifierToken
				type = Me.DecodeIdentifierType(identifierToken, asClauseOpt, getErrorInfoERRStrictDisallowImplicitObject, asClauseType, diagnostics)
				flag = Not Binder.HasDefaultType(identifierToken, asClauseOpt)
			Else
				If (asClauseOpt IsNot Nothing AndAlso asClauseOpt.Kind() = SyntaxKind.AsNewClause) Then
					Dim newExpression As Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax = DirectCast(asClauseOpt, Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax).NewExpression
					If (newExpression.Kind() <> SyntaxKind.AnonymousObjectCreationExpression) Then
						GoTo Label1
					End If
					Dim localInProgressBinder As Microsoft.CodeAnalysis.VisualBasic.LocalInProgressBinder = New Microsoft.CodeAnalysis.VisualBasic.LocalInProgressBinder(Me, symbol)
					valueExpression = localInProgressBinder.BindAnonymousObjectCreationExpression(DirectCast(newExpression, Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax), diagnostics)
					asClauseType = valueExpression.Type
					typeSymbol = asClauseType
					Return typeSymbol
				End If
			Label1:
				Dim modifiedIdentifierSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax = modifiedIdentifierOpt
				type = Me.DecodeModifiedIdentifierType(modifiedIdentifierSyntax, asClauseOpt, equalsValueOpt, getErrorInfoERRStrictDisallowImplicitObject, asClauseType, diagnostics, If(symbol.IsStatic, Binder.ModifiedIdentifierTypeDecoderContext.LocalType Or Binder.ModifiedIdentifierTypeDecoderContext.StaticLocalType, Binder.ModifiedIdentifierTypeDecoderContext.LocalType))
				flag = Not Binder.HasDefaultType(modifiedIdentifierOpt, asClauseOpt)
			End If
			If (Not flag OrElse symbol.IsConst AndAlso type.SpecialType = SpecialType.System_Object) Then
				If (Me.OptionInfer AndAlso Not symbol.IsStatic AndAlso Not symbol.IsConst) Then
					If (equalsValueOpt IsNot Nothing) Then
						Dim value As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = equalsValueOpt.Value
						Dim localInProgressBinder1 As Microsoft.CodeAnalysis.VisualBasic.LocalInProgressBinder = New Microsoft.CodeAnalysis.VisualBasic.LocalInProgressBinder(Me, symbol)
						valueExpression = localInProgressBinder1.BindValue(value, diagnostics, False)
						Dim mostEnclosedParenthesizedExpression As BoundExpression = valueExpression
						If (Not mostEnclosedParenthesizedExpression.IsNothingLiteral()) Then
							mostEnclosedParenthesizedExpression = mostEnclosedParenthesizedExpression.GetMostEnclosedParenthesizedExpression()
						End If
						Dim inferredType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
						Dim boundArrayLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundArrayLiteral = Nothing
						Dim kind As BoundKind = mostEnclosedParenthesizedExpression.Kind
						If (kind = BoundKind.TupleLiteral) Then
							inferredType = DirectCast(mostEnclosedParenthesizedExpression, BoundTupleLiteral).InferredType
						ElseIf (kind = BoundKind.ArrayLiteral) Then
							boundArrayLiteral = DirectCast(mostEnclosedParenthesizedExpression, Microsoft.CodeAnalysis.VisualBasic.BoundArrayLiteral)
							inferredType = boundArrayLiteral.InferredType
						ElseIf (kind <> BoundKind.UnboundLambda) Then
							inferredType = mostEnclosedParenthesizedExpression.Type
						Else
							inferredType = DirectCast(mostEnclosedParenthesizedExpression, UnboundLambda).InferredAnonymousDelegate.Key
						End If
						If (inferredType IsNot Nothing) Then
							Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = If(mostEnclosedParenthesizedExpression.HasErrors, Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded, diagnostics)
							If (modifiedIdentifierOpt Is Nothing) Then
								type = inferredType
							Else
								type = Me.InferVariableType(type, modifiedIdentifierOpt, value, inferredType, mostEnclosedParenthesizedExpression, getErrorInfoERRStrictDisallowImplicitObject, bindingDiagnosticBag)
								If (CObj(type) <> CObj(inferredType) AndAlso boundArrayLiteral IsNot Nothing) Then
									Me.ReportArrayLiteralInferredTypeDiagnostics(boundArrayLiteral, bindingDiagnosticBag)
								End If
							End If
						End If
					End If
				ElseIf (symbol.IsConst) Then
					valueExpression = symbol.GetConstantExpression(Me)
					Dim type1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = valueExpression.Type
					If (type1 IsNot Nothing AndAlso type1.GetEnumUnderlyingTypeOrSelf().IsIntrinsicType()) Then
						type = valueExpression.Type
					End If
				ElseIf (Not symbol.IsStatic AndAlso Me.OptionStrict <> Microsoft.CodeAnalysis.VisualBasic.OptionStrict.[On] AndAlso Not flag AndAlso type.IsObjectType() AndAlso modifiedIdentifierOpt IsNot Nothing AndAlso modifiedIdentifierOpt.Nullable.Node IsNot Nothing AndAlso equalsValueOpt IsNot Nothing) Then
					Binder.ReportDiagnostic(diagnostics, modifiedIdentifierOpt, ERRID.ERR_NullableTypeInferenceNotSupported)
				End If
				typeSymbol = type
			Else
				typeSymbol = type
			End If
			Return typeSymbol
		End Function

		Public Function ConstructAndValidateConstraints(ByVal genericType As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol, ByVal typeArguments As ImmutableArray(Of TypeSymbol), ByVal syntaxWhole As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal syntaxArguments As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol
			Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol
			Dim flag As Boolean
			If (genericType.Arity <> 0) Then
				If (genericType.Arity = typeArguments.Length) Then
					Dim right As Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax = Nothing
					Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = syntaxWhole.Kind()
					If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GenericName) Then
						right = DirectCast(syntaxWhole, Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax)
					ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.QualifiedName) Then
						right = DirectCast(DirectCast(syntaxWhole, Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax).Right, Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax)
					End If
					If (right IsNot Nothing AndAlso DirectCast(syntaxArguments, IEnumerable(Of Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)).AllAreMissingIdentifierName() AndAlso Me.IsUnboundTypeAllowed(right)) Then
						namedTypeSymbol = genericType.AsUnboundGenericType()
						Return namedTypeSymbol
					End If
					flag = True
				Else
					Dim originalDefinition(genericType.Arity - 1 + 1 - 1) As TypeSymbol
					Dim arity As Integer = genericType.Arity - 1
					Dim num As Integer = 0
					Do
						If (num >= typeArguments.Length) Then
							originalDefinition(num) = genericType.TypeParameters(num).OriginalDefinition
						Else
							originalDefinition(num) = typeArguments(num)
						End If
						num = num + 1
					Loop While num <= arity
					typeArguments = Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of TypeSymbol)(originalDefinition)
					flag = False
				End If
				Dim tupleIfCompatible As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = genericType.Construct(typeArguments)
				If (flag AndAlso Me.ShouldCheckConstraints) Then
					tupleIfCompatible.CheckConstraintsForNonTuple(syntaxArguments, diagnostics, Me.GetNewCompoundUseSiteInfo(diagnostics))
				End If
				tupleIfCompatible = DirectCast(TupleTypeSymbol.TransformToTupleIfCompatible(tupleIfCompatible), Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)
				namedTypeSymbol = tupleIfCompatible
			Else
				namedTypeSymbol = genericType
			End If
			Return namedTypeSymbol
		End Function

		Private Function ConstructAnonymousDelegateSymbol(ByVal source As UnboundLambda, ByVal parameters As ImmutableArray(Of BoundLambdaParameterSymbol), ByVal returnType As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As NamedTypeSymbol
			Dim anonymousTypeField(parameters.Length + 1 - 1) As Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField
			Dim length As Integer = parameters.Length - 1
			Dim num As Integer = 0
			Do
				Dim item As UnboundLambdaParameterSymbol = DirectCast(source.Parameters(num), UnboundLambdaParameterSymbol)
				anonymousTypeField(num) = New Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField(parameters(num).Name, parameters(num).Type, item.Syntax.GetLocation(), parameters(num).IsByRef)
				If (parameters(num).Type.IsRestrictedType()) Then
					Binder.ReportDiagnostic(diagnostics, item.TypeSyntax, ERRID.ERR_RestrictedType1, New [Object]() { parameters(num).Type })
				End If
				num = num + 1
			Loop While num <= length
			Dim returnParameterName As String = Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeDescriptor.GetReturnParameterName(source.IsFunctionLambda)
			anonymousTypeField(num) = New Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField(returnParameterName, returnType, source.Syntax.GetLocation(), False)
			Dim anonymousTypeDescriptor As Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeDescriptor = New Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeDescriptor(Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField)(anonymousTypeField), source.Syntax.GetLocation(), True)
			Return Me.Compilation.AnonymousTypeManager.ConstructAnonymousDelegateSymbol(anonymousTypeDescriptor)
		End Function

		Private Sub ConvertNothingLiterals(ByVal operatorKind As Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind, ByRef left As BoundExpression, ByRef right As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Dim type As TypeSymbol
			Dim specialType As TypeSymbol
			Dim specialType1 As Microsoft.CodeAnalysis.SpecialType
			If (left.IsNothingLiteral()) Then
				If (Not right.IsNothingLiteral()) Then
					type = right.Type
					If (type Is Nothing) Then
						Return
					End If
				Else
					Select Case operatorKind
						Case Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.Add
						Case Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.Equals
						Case Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.NotEquals
						Case Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.LessThanOrEqual
						Case Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.GreaterThanOrEqual
						Case Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.LessThan
						Case Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.GreaterThan
						Case Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.Subtract
						Case Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.Multiply
						Case Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.Power
						Case Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.Divide
						Case Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.Modulo
						Case Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.IntegerDivide
						Case Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.LeftShift
						Case Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.RightShift
						Case Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.[Xor]
						Case Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.[Or]
						Case Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.[And]
							specialType1 = Microsoft.CodeAnalysis.SpecialType.System_Int32
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.Concatenate
						Case Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.[Like]
							specialType1 = Microsoft.CodeAnalysis.SpecialType.System_String
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.[OrElse]
						Case Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.[AndAlso]
							specialType1 = Microsoft.CodeAnalysis.SpecialType.System_Boolean
							Exit Select
						Case Else
							Throw ExceptionUtilities.UnexpectedValue(operatorKind)
					End Select
					type = Me.GetSpecialType(specialType1, right.Syntax, diagnostics)
					right = Me.ApplyImplicitConversion(right.Syntax, type, right, diagnostics, False)
				End If
				Dim specialType2 As Microsoft.CodeAnalysis.SpecialType = Microsoft.CodeAnalysis.SpecialType.None
				Dim binaryOperatorKind As Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind = operatorKind
				If (CInt(binaryOperatorKind) - CInt(Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.Concatenate) > CInt(Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.Add)) Then
					If (CInt(binaryOperatorKind) - CInt(Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.LeftShift) <= CInt(Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.Add)) Then
						specialType2 = Microsoft.CodeAnalysis.SpecialType.System_Int32
					End If
				ElseIf (type.GetNullableUnderlyingTypeOrSelf().GetEnumUnderlyingTypeOrSelf().IsIntrinsicType() OrElse type.IsCharSZArray() OrElse type.IsDBNullType()) Then
					specialType2 = Microsoft.CodeAnalysis.SpecialType.System_String
				End If
				If (specialType2 = Microsoft.CodeAnalysis.SpecialType.None OrElse specialType2 = type.SpecialType) Then
					specialType = type
				Else
					specialType = Me.GetSpecialType(specialType2, left.Syntax, diagnostics)
				End If
				left = Me.ApplyImplicitConversion(left.Syntax, specialType, left, diagnostics, False)
				Return
			ElseIf (right.IsNothingLiteral()) Then
				specialType = left.Type
				If (specialType IsNot Nothing) Then
					type = specialType
					If (CInt(operatorKind) - CInt(Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.Concatenate) <= CInt(Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind.Add) AndAlso (specialType.GetNullableUnderlyingTypeOrSelf().GetEnumUnderlyingTypeOrSelf().IsIntrinsicType() OrElse specialType.IsCharSZArray() OrElse specialType.IsDBNullType()) AndAlso specialType.SpecialType <> Microsoft.CodeAnalysis.SpecialType.System_String) Then
						type = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_String, right.Syntax, diagnostics)
					End If
					right = Me.ApplyImplicitConversion(right.Syntax, type, right, diagnostics, False)
				End If
			End If
		End Sub

		Private Function ConvertToQueryableType(ByVal source As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, <Out> ByRef controlVariableType As TypeSymbol) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			controlVariableType = Nothing
			If (Not source.IsValue() OrElse source.Type.IsErrorType()) Then
				boundExpression = source
			Else
				Dim specialType As TypeSymbol = Me.InferControlVariableType(source, diagnostics)
				If (specialType Is Nothing) Then
					Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
					Dim instance As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.GetInstance(diagnostics)
					Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindQueryOperatorCall(source.Syntax, source, "AsQueryable", ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty, source.Syntax.Span, instance)
					If (Not boundExpression2.HasErrors AndAlso boundExpression2.Kind = BoundKind.[Call]) Then
						specialType = Me.InferControlVariableType(boundExpression2, diagnostics)
						If (specialType IsNot Nothing) Then
							controlVariableType = specialType
							boundExpression1 = boundExpression2
							diagnostics.AddRange(instance, False)
						End If
					End If
					If (boundExpression1 Is Nothing) Then
						instance.Clear()
						Dim boundExpression3 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindQueryOperatorCall(source.Syntax, source, "AsEnumerable", ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty, source.Syntax.Span, instance)
						If (Not boundExpression3.HasErrors AndAlso boundExpression3.Kind = BoundKind.[Call]) Then
							specialType = Me.InferControlVariableType(boundExpression3, diagnostics)
							If (specialType IsNot Nothing) Then
								controlVariableType = specialType
								boundExpression1 = boundExpression3
								diagnostics.AddRange(instance, False)
							End If
						End If
					End If
					If (boundExpression1 Is Nothing) Then
						instance.Clear()
						specialType = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Object, source.Syntax, instance)
						Dim boundExpression4 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindQueryOperatorCall(source.Syntax, source, "Cast", New BoundTypeArguments(source.Syntax, ImmutableArray.Create(Of TypeSymbol)(specialType)), ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty, source.Syntax.Span, instance)
						If (Not boundExpression4.HasErrors AndAlso boundExpression4.Kind = BoundKind.[Call]) Then
							controlVariableType = specialType
							boundExpression1 = boundExpression4
							diagnostics.AddRange(instance, False)
						End If
					End If
					instance.Free()
					boundExpression = If(boundExpression1 Is Nothing, source, boundExpression1)
				Else
					controlVariableType = specialType
					boundExpression = source
				End If
			End If
			Return boundExpression
		End Function

		Private Function CreateAnonymousObjectCreationExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal typeDescr As AnonymousTypeDescriptor, ByVal initExpressions As ImmutableArray(Of BoundExpression), Optional ByVal hasErrors As Boolean = False) As BoundExpression
			Dim anonymousTypePublicSymbol As AnonymousTypeManager.AnonymousTypePublicSymbol = Me.Compilation.AnonymousTypeManager.ConstructAnonymousTypeSymbol(typeDescr)
			anonymousTypePublicSymbol.InstanceConstructors.First()
			Return Me.CreateAnonymousObjectCreationExpression(node, anonymousTypePublicSymbol, initExpressions, hasErrors)
		End Function

		Protected Overridable Function CreateAnonymousObjectCreationExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal anonymousType As AnonymousTypeManager.AnonymousTypePublicSymbol, ByVal initExpressions As ImmutableArray(Of BoundExpression), Optional ByVal hasErrors As Boolean = False) As BoundAnonymousTypeCreationExpression
			Return New BoundAnonymousTypeCreationExpression(node, Nothing, ImmutableArray(Of BoundAnonymousTypePropertyAccess).Empty, initExpressions, anonymousType, hasErrors)
		End Function

		Private Function CreateArrayBounds(ByVal node As SyntaxNode, ByVal knownSizes As Binder.DimensionSize(), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As ImmutableArray(Of BoundExpression)
			Dim boundExpressionArray(CInt(knownSizes.Length) - 1 + 1 - 1) As BoundExpression
			Dim specialType As NamedTypeSymbol = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Int32, node, diagnostics)
			Dim length As Integer = CInt(knownSizes.Length) - 1
			Dim num As Integer = 0
			Do
				Dim dimensionSize As Binder.DimensionSize = knownSizes(num)
				Dim boundLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundLiteral = New Microsoft.CodeAnalysis.VisualBasic.BoundLiteral(node, ConstantValue.Create(dimensionSize.Size), specialType)
				boundLiteral.SetWasCompilerGenerated()
				boundExpressionArray(num) = boundLiteral
				num = num + 1
			Loop While num <= length
			Return Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of BoundExpression)(boundExpressionArray)
		End Function

		Public Function CreateArrayOf(ByVal elementType As TypeSymbol, ByVal arrayModifierSyntax As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax), ByVal arrayBoundsOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As ArrayTypeSymbol
			Return DirectCast(Me.ApplyArrayRankSpecifiersAndBoundsToType(elementType, arrayModifierSyntax, arrayBoundsOpt, diagnostics), ArrayTypeSymbol)
		End Function

		Private Function CreateArrayType(ByVal elementType As TypeSymbol) As ArrayTypeSymbol
			Return ArrayTypeSymbol.CreateSZArray(elementType, ImmutableArray(Of CustomModifier).Empty, Me.Compilation)
		End Function

		Private Function CreateBoundCallOrPropertyAccess(ByVal node As SyntaxNode, ByVal target As SyntaxNode, ByVal typeChar As TypeCharacter, ByVal group As BoundMethodOrPropertyGroup, ByVal boundArguments As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression), ByVal bestResult As OverloadResolution.CandidateAnalysisResult, ByVal asyncLambdaSubToFunctionMismatch As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal suppressAbstractCallDiagnostics As Boolean = False) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundPropertyAccess As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim parameters As ImmutableArray(Of ParameterSymbol)
			Dim receiverOpt As Object
			Dim obj As Object
			Dim candidate As OverloadResolution.Candidate = bestResult.Candidate
			Dim underlyingSymbol As Symbol = candidate.UnderlyingSymbol
			Dim returnType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = candidate.ReturnType
			If (group.ResultKind <> LookupResultKind.Inaccessible) Then
				Me.CheckMemberTypeAccessibility(diagnostics, node, underlyingSymbol)
			Else
				Binder.ReportDiagnostic(diagnostics, target, Me.GetInaccessibleErrorInfo(bestResult.Candidate.UnderlyingSymbol))
			End If
			If (bestResult.TypeArgumentInferenceDiagnosticsOpt IsNot Nothing) Then
				diagnostics.AddRange(bestResult.TypeArgumentInferenceDiagnosticsOpt, False)
			End If
			Dim valueTuple As ValueTuple(Of ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression), BitVector) = Me.PassArguments(node, bestResult, boundArguments, diagnostics)
			boundArguments = valueTuple.Item1
			Dim hasErrors As Boolean = False
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = group.ReceiverOpt
			If (group.ResultKind = LookupResultKind.Good) Then
				hasErrors = Me.CheckSharedSymbolAccess(target, underlyingSymbol.IsShared, boundExpression, group.QualificationKind, diagnostics)
			End If
			Me.ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagnostics, underlyingSymbol, node)
			hasErrors = hasErrors Or group.HasErrors
			If (Not returnType.IsErrorType()) Then
				Binder.VerifyTypeCharacterConsistency(node, returnType, typeChar, diagnostics)
			End If
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
			If (boundExpression IsNot Nothing AndAlso Not hasErrors) Then
				boundExpression = Me.AdjustReceiverTypeOrValue(boundExpression, boundExpression.Syntax, underlyingSymbol.IsShared, diagnostics, boundExpression1)
			End If
			If (Not suppressAbstractCallDiagnostics AndAlso boundExpression IsNot Nothing AndAlso (boundExpression.IsMyBaseReference() OrElse boundExpression.IsMyClassReference()) AndAlso underlyingSymbol.IsMustOverride) Then
				Binder.ReportDiagnostic(diagnostics, group.Syntax, If(boundExpression.IsMyBaseReference(), ERRID.ERR_MyBaseAbstractCall1, ERRID.ERR_MyClassAbstractCall1), New [Object]() { underlyingSymbol })
			End If
			If (Not asyncLambdaSubToFunctionMismatch.IsEmpty) Then
				Dim enumerator As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Enumerator = asyncLambdaSubToFunctionMismatch.GetEnumerator()
				While enumerator.MoveNext()
					Dim syntax As SyntaxNode = enumerator.Current.Syntax
					Dim lambdaExpressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaExpressionSyntax = TryCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaExpressionSyntax)
					If (lambdaExpressionSyntax IsNot Nothing) Then
						syntax = lambdaExpressionSyntax.SubOrFunctionHeader
					End If
					Binder.ReportDiagnostic(diagnostics, syntax, ERRID.WRN_AsyncSubCouldBeFunction)
				End While
			End If
			If (underlyingSymbol.Kind <> SymbolKind.Method) Then
				Dim propertySymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol = DirectCast(underlyingSymbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol)
				Dim reducedFromDefinition As Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol = propertySymbol.ReducedFromDefinition
				If (reducedFromDefinition IsNot Nothing) Then
					Dim receiverType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = propertySymbol.ReceiverType
					parameters = reducedFromDefinition.Parameters
					boundExpression = Me.UpdateReceiverForExtensionMethodOrPropertyGroup(boundExpression, receiverType, parameters(0), diagnostics)
				ElseIf (boundExpression IsNot Nothing AndAlso boundExpression.IsPropertyOrXmlPropertyAccess()) Then
					boundExpression = Me.MakeRValue(boundExpression, diagnostics)
				End If
				Dim boundPropertyGroup As Microsoft.CodeAnalysis.VisualBasic.BoundPropertyGroup = DirectCast(group, Microsoft.CodeAnalysis.VisualBasic.BoundPropertyGroup)
				If (boundExpression IsNot Nothing) Then
					receiverOpt = Nothing
				Else
					receiverOpt = If(boundExpression1, boundPropertyGroup.ReceiverOpt)
				End If
				Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = receiverOpt
				boundPropertyGroup = boundPropertyGroup.Update(boundPropertyGroup.Properties, boundPropertyGroup.ResultKind, boundExpression2, boundPropertyGroup.QualificationKind)
				boundPropertyAccess = New Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess(node, propertySymbol, boundPropertyGroup, PropertyAccessKind.Unknown, propertySymbol.IsWritable(boundExpression, Me, False), boundExpression, boundArguments, valueTuple.Item2, hasErrors)
			Else
				Dim methodSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol = DirectCast(underlyingSymbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)
				Dim reducedFrom As Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol = methodSymbol.ReducedFrom
				Dim constantValue As Microsoft.CodeAnalysis.ConstantValue = Nothing
				If (reducedFrom IsNot Nothing) Then
					Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = methodSymbol.ReceiverType
					parameters = reducedFrom.Parameters
					boundExpression = Me.UpdateReceiverForExtensionMethodOrPropertyGroup(boundExpression, typeSymbol, parameters(0), diagnostics)
				Else
					If (boundExpression IsNot Nothing AndAlso boundExpression.IsPropertyOrXmlPropertyAccess()) Then
						boundExpression = Me.MakeRValue(boundExpression, diagnostics)
					End If
					If (methodSymbol.IsUserDefinedOperator() AndAlso Me.ContainingMember = methodSymbol) Then
						Binder.ReportDiagnostic(diagnostics, target, ERRID.WRN_RecursiveOperatorCall, New [Object]() { methodSymbol })
					End If
					constantValue = Me.OptimizeLibraryCall(methodSymbol, boundArguments, node, hasErrors, diagnostics)
				End If
				Dim boundMethodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup = DirectCast(group, Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup)
				If (boundExpression IsNot Nothing) Then
					obj = Nothing
				Else
					obj = If(boundExpression1, boundMethodGroup.ReceiverOpt)
				End If
				Dim boundExpression3 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = obj
				boundMethodGroup = boundMethodGroup.Update(boundMethodGroup.TypeArgumentsOpt, boundMethodGroup.Methods, boundMethodGroup.PendingExtensionMethodsOpt, boundMethodGroup.ResultKind, boundExpression3, boundMethodGroup.QualificationKind)
				boundPropertyAccess = New BoundCall(node, methodSymbol, boundMethodGroup, boundExpression, boundArguments, constantValue, returnType, False, hasErrors, DirectCast(valueTuple.Item2, BitVector))
			End If
			Return boundPropertyAccess
		End Function

		Private Function CreateBoundInvocationExpressionFromMethodOrPropertyGroup(ByVal syntax As SyntaxNode, ByVal methodOrPropertyGroup As BoundMethodOrPropertyGroup, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim empty As ImmutableArray(Of !0) = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty
			Dim strs As ImmutableArray(Of String) = New ImmutableArray(Of String)()
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.BindInvocationExpression(syntax, syntax, TypeCharacter.None, methodOrPropertyGroup, empty, strs, diagnostics, syntax, False, False, False, Nothing, False)
			Return Me.MakeRValue(boundExpression, diagnostics)
		End Function

		Private Function CreateBoundMethodGroup(ByVal node As SyntaxNode, ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal lookupOptionsUsed As LookupOptions, ByVal withDependencies As Boolean, ByVal receiver As BoundExpression, ByVal typeArgumentsOpt As BoundTypeArguments, ByVal qualKind As QualificationKind, Optional ByVal hasError As Boolean = False) As BoundMethodGroup
			Dim extensionMethodGroup As Microsoft.CodeAnalysis.VisualBasic.ExtensionMethodGroup = Nothing
			If (lookupResult.IsGood AndAlso Not lookupResult.Symbols(0).IsReducedExtensionMethod()) Then
				extensionMethodGroup = New Microsoft.CodeAnalysis.VisualBasic.ExtensionMethodGroup(Me, lookupOptionsUsed, withDependencies)
			End If
			Return New BoundMethodGroup(node, typeArgumentsOpt, lookupResult.Symbols.ToDowncastedImmutable(Of MethodSymbol)(), extensionMethodGroup, lookupResult.Kind, receiver, qualKind, hasError)
		End Function

		Private Shared Function CreateBoundQueryLambda(ByVal queryLambdaSymbol As SynthesizedLambdaSymbol, ByVal rangeVariables As ImmutableArray(Of RangeVariableSymbol), ByVal expression As BoundExpression, ByVal exprIsOperandOfConditionalBranch As Boolean) As BoundQueryLambda
			Return New BoundQueryLambda(queryLambdaSymbol.Syntax, queryLambdaSymbol, rangeVariables, expression, exprIsOperandOfConditionalBranch, False)
		End Function

		Protected Overridable Function CreateBoundWithBlock(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.WithBlockSyntax, ByVal boundBlockBinder As Binder, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundStatement
			Return Me.ContainingBinder.CreateBoundWithBlock(node, boundBlockBinder, diagnostics)
		End Function

		Private Function CreateConversionAndReportDiagnostic(ByVal tree As SyntaxNode, ByVal argument As BoundExpression, ByVal convKind As KeyValuePair(Of ConversionKind, MethodSymbol), ByVal isExplicit As Boolean, ByVal targetType As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal copybackConversionParamName As String = Nothing, Optional ByVal explicitSemanticForConcatArgument As Boolean = False) As BoundExpression
			' 
			' Current member / type: Microsoft.CodeAnalysis.VisualBasic.BoundExpression Microsoft.CodeAnalysis.VisualBasic.Binder::CreateConversionAndReportDiagnostic(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Collections.Generic.KeyValuePair`2<Microsoft.CodeAnalysis.VisualBasic.ConversionKind,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol>,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag,System.String,System.Boolean)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: Microsoft.CodeAnalysis.VisualBasic.BoundExpression CreateConversionAndReportDiagnostic(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,System.Collections.Generic.KeyValuePair<Microsoft.CodeAnalysis.VisualBasic.ConversionKind,Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol>,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag,System.String,System.Boolean)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Function

		Private Function CreateConversionForTupleElements(ByVal tree As SyntaxNode, ByVal sourceType As TypeSymbol, ByVal targetType As TypeSymbol, ByVal convKind As ConversionKind, ByVal isExplicit As Boolean) As BoundConvertedTupleElements
			' 
			' Current member / type: Microsoft.CodeAnalysis.VisualBasic.BoundConvertedTupleElements Microsoft.CodeAnalysis.VisualBasic.Binder::CreateConversionForTupleElements(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.ConversionKind,System.Boolean)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: Microsoft.CodeAnalysis.VisualBasic.BoundConvertedTupleElements CreateConversionForTupleElements(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.ConversionKind,System.Boolean)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Function

		Private Function CreateMeReference(ByVal node As Microsoft.CodeAnalysis.SyntaxNode, Optional ByVal isSynthetic As Boolean = False) As Microsoft.CodeAnalysis.VisualBasic.BoundMeReference
			Dim containingMember As Symbol = Me.ContainingMember
			Dim syntaxNode As Microsoft.CodeAnalysis.SyntaxNode = node
			Dim containingType As Object = Me.ContainingType
			If (containingType Is Nothing) Then
				containingType = ErrorTypeSymbol.UnknownResultType
			End If
			Dim boundMeReference As Microsoft.CodeAnalysis.VisualBasic.BoundMeReference = New Microsoft.CodeAnalysis.VisualBasic.BoundMeReference(syntaxNode, containingType)
			If (isSynthetic) Then
				boundMeReference.SetWasCompilerGenerated()
			End If
			Return boundMeReference
		End Function

		Public Function CreateNullableOf(ByVal typeArgument As TypeSymbol, ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal syntaxTypeArgument As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol
			Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = Me.GetSpecialType(SpecialType.System_Nullable_T, syntax, diagBag).Construct(ImmutableArray.Create(Of TypeSymbol)(typeArgument))
			If (Me.ShouldCheckConstraints) Then
				Dim instance As ArrayBuilder(Of TypeParameterDiagnosticInfo) = ArrayBuilder(Of TypeParameterDiagnosticInfo).GetInstance()
				Dim typeParameterDiagnosticInfos As ArrayBuilder(Of TypeParameterDiagnosticInfo) = Nothing
				namedTypeSymbol.CheckConstraints(instance, typeParameterDiagnosticInfos, Me.GetNewCompoundUseSiteInfo(diagBag))
				If (typeParameterDiagnosticInfos IsNot Nothing) Then
					instance.AddRange(typeParameterDiagnosticInfos)
				End If
				Dim enumerator As ArrayBuilder(Of TypeParameterDiagnosticInfo).Enumerator = instance.GetEnumerator()
				While enumerator.MoveNext()
					Dim current As TypeParameterDiagnosticInfo = enumerator.Current
					diagBag.Add(current.UseSiteInfo, syntaxTypeArgument.GetLocation())
				End While
				instance.Free()
			End If
			Return namedTypeSymbol
		End Function

		Private Function CreatePredefinedConversion(ByVal tree As SyntaxNode, ByVal argument As BoundExpression, ByVal convKind As ConversionKind, ByVal isExplicit As Boolean, ByVal targetType As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundConversion
			' 
			' Current member / type: Microsoft.CodeAnalysis.VisualBasic.BoundConversion Microsoft.CodeAnalysis.VisualBasic.Binder::CreatePredefinedConversion(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.ConversionKind,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: Microsoft.CodeAnalysis.VisualBasic.BoundConversion CreatePredefinedConversion(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.ConversionKind,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Function

		Private Function CreateQueryLambdaParameterSymbol(ByVal name As String, ByVal ordinal As Integer, ByVal type As TypeSymbol, ByVal syntaxNode As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal rangeVariables As ImmutableArray(Of RangeVariableSymbol)) As BoundLambdaParameterSymbol
			syntaxNode = Binder.GetQueryLambdaParameterSyntax(syntaxNode, rangeVariables)
			Return New BoundLambdaParameterSymbol(name, ordinal, type, False, syntaxNode, syntaxNode.GetLocation())
		End Function

		Private Shared Function CreateQueryLambdaParameterSymbol(ByVal name As String, ByVal ordinal As Integer, ByVal type As TypeSymbol, ByVal syntaxNode As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode) As BoundLambdaParameterSymbol
			Return New BoundLambdaParameterSymbol(name, ordinal, type, False, syntaxNode, syntaxNode.GetLocation())
		End Function

		Private Function CreateQueryLambdaSymbol(ByVal syntaxNode As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal kind As SynthesizedLambdaKind, ByVal parameters As ImmutableArray(Of BoundLambdaParameterSymbol)) As SynthesizedLambdaSymbol
			Return New SynthesizedLambdaSymbol(kind, syntaxNode, parameters, LambdaSymbol.ReturnTypePendingDelegate, Me)
		End Function

		Private Shared Function CreateSetOfDeclaredNames() As HashSet(Of String)
			Return New HashSet(Of String)(CaseInsensitiveComparison.Comparer)
		End Function

		Private Shared Function CreateSetOfDeclaredNames(ByVal rangeVariables As ImmutableArray(Of RangeVariableSymbol)) As HashSet(Of String)
			Dim strs As HashSet(Of String) = New HashSet(Of String)(CaseInsensitiveComparison.Comparer)
			Dim enumerator As ImmutableArray(Of RangeVariableSymbol).Enumerator = rangeVariables.GetEnumerator()
			While enumerator.MoveNext()
				strs.Add(enumerator.Current.Name)
			End While
			Return strs
		End Function

		Private Function CreateStringLiteral(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal str As String, ByVal compilerGenerated As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal hasErrors As Boolean = False) As Microsoft.CodeAnalysis.VisualBasic.BoundLiteral
			Dim boundLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundLiteral = New Microsoft.CodeAnalysis.VisualBasic.BoundLiteral(syntax, ConstantValue.Create(str), Me.GetSpecialType(SpecialType.System_String, syntax, diagnostics), hasErrors)
			If (compilerGenerated) Then
				boundLiteral.SetWasCompilerGenerated()
			End If
			Return boundLiteral
		End Function

		Private Function CreateUserDefinedConversion(ByVal tree As SyntaxNode, ByVal argument As BoundExpression, ByVal convKind As KeyValuePair(Of Microsoft.CodeAnalysis.VisualBasic.ConversionKind, MethodSymbol), ByVal isExplicit As Boolean, ByVal targetType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, ByVal reportArrayLiteralElementNarrowingConversion As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundConversion
			Dim conversionKind As Microsoft.CodeAnalysis.VisualBasic.ConversionKind
			Dim binder As Microsoft.CodeAnalysis.VisualBasic.Binder
			Dim optionStrictOffBinder As Microsoft.CodeAnalysis.VisualBasic.Binder.OptionStrictOffBinder = New Microsoft.CodeAnalysis.VisualBasic.Binder.OptionStrictOffBinder(Me)
			Dim syntax As SyntaxNode = argument.Syntax
			Dim type As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = argument.Type
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = convKind.Value.Parameters(0).Type
			Dim returnType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = convKind.Value.ReturnType
			Dim num As Byte = 0
			Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
			If (argument.Kind <> BoundKind.ArrayLiteral) Then
				conversionKind = Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyPredefinedConversion(argument, typeSymbol, optionStrictOffBinder, newCompoundUseSiteInfo)
				If (Not Microsoft.CodeAnalysis.VisualBasic.Conversions.IsIdentityConversion(conversionKind)) Then
					argument = optionStrictOffBinder.CreatePredefinedConversion(tree, argument, conversionKind, isExplicit, typeSymbol, diagnostics).MakeCompilerGenerated()
					num = 1
				End If
			Else
				Dim boundArrayLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundArrayLiteral = DirectCast(argument, Microsoft.CodeAnalysis.VisualBasic.BoundArrayLiteral)
				If (reportArrayLiteralElementNarrowingConversion) Then
					binder = Me
				Else
					binder = optionStrictOffBinder
				End If
				Dim binder1 As Microsoft.CodeAnalysis.VisualBasic.Binder = binder
				conversionKind = Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyArrayLiteralConversion(boundArrayLiteral, typeSymbol, binder1, newCompoundUseSiteInfo)
				argument = binder1.ReclassifyArrayLiteralExpression(SyntaxKind.CTypeKeyword, tree, conversionKind, isExplicit, boundArrayLiteral, typeSymbol, diagnostics)
				type = typeSymbol
			End If
			Microsoft.CodeAnalysis.VisualBasic.Binder.ReportUseSite(diagnostics, tree, convKind.Value)
			Me.ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagnostics, convKind.Value, tree)
			If (Me.ContainingMember = convKind.Value) Then
				Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagnostics, syntax, ERRID.WRN_RecursiveOperatorCall, New [Object]() { convKind.Value })
			End If
			Dim value As MethodSymbol = convKind.Value
			Dim boundExpressions As ImmutableArray(Of BoundExpression) = ImmutableArray.Create(Of BoundExpression)(argument)
			Dim bitVector As Microsoft.CodeAnalysis.BitVector = New Microsoft.CodeAnalysis.BitVector()
			argument = (New BoundCall(tree, value, Nothing, Nothing, boundExpressions, Nothing, returnType, True, False, bitVector)).MakeCompilerGenerated()
			conversionKind = Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyPredefinedConversion(argument, targetType, optionStrictOffBinder, newCompoundUseSiteInfo)
			If (Not Microsoft.CodeAnalysis.VisualBasic.Conversions.IsIdentityConversion(conversionKind)) Then
				argument = optionStrictOffBinder.CreatePredefinedConversion(tree, argument, conversionKind, isExplicit, targetType, diagnostics).MakeCompilerGenerated()
				num = num Or 2
			End If
			argument = (New BoundUserDefinedConversion(tree, argument, num, type, False)).MakeCompilerGenerated()
			diagnostics.Add(tree, newCompoundUseSiteInfo)
			Return New BoundConversion(tree, argument, convKind.Key, Me.CheckOverflow, isExplicit, Nothing, targetType, False)
		End Function

		Public Overridable Function DeclareImplicitLocalVariable(ByVal nameSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As LocalSymbol
			Return Me.m_containingBinder.DeclareImplicitLocalVariable(nameSyntax, diagnostics)
		End Function

		Private Shared Sub DeclareLocal(ByRef locals As ArrayBuilder(Of LocalSymbol), ByVal localDecl As BoundLocalDeclarationBase)
			If (locals Is Nothing) Then
				locals = ArrayBuilder(Of LocalSymbol).GetInstance()
			End If
			Dim kind As BoundKind = localDecl.Kind
			If (kind = BoundKind.LocalDeclaration) Then
				locals.Add(DirectCast(localDecl, BoundLocalDeclaration).LocalSymbol)
				Return
			End If
			If (kind <> BoundKind.AsNewLocalDeclarations) Then
				Throw ExceptionUtilities.UnexpectedValue(localDecl.Kind)
			End If
			Dim enumerator As ImmutableArray(Of BoundLocalDeclaration).Enumerator = DirectCast(localDecl, BoundAsNewLocalDeclarations).LocalDeclarations.GetEnumerator()
			While enumerator.MoveNext()
				locals.Add(enumerator.Current.LocalSymbol)
			End While
		End Sub

		Public Function DecodeIdentifierType(ByVal identifier As Microsoft.CodeAnalysis.SyntaxToken, ByVal asClauseOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax, ByVal getRequireTypeDiagnosticInfoFunc As Func(Of DiagnosticInfo), ByRef asClauseType As TypeSymbol, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As TypeSymbol
			If (asClauseOpt Is Nothing) Then
				asClauseType = Nothing
			Else
				asClauseType = Me.BindTypeSyntax(asClauseOpt.Type(), diagBag, False, False, False)
			End If
			Return Me.DecodeIdentifierType(identifier, asClauseType, getRequireTypeDiagnosticInfoFunc, diagBag, Binder.ModifiedIdentifierTypeDecoderContext.None)
		End Function

		Public Function DecodeIdentifierType(ByVal identifier As Microsoft.CodeAnalysis.SyntaxToken, ByVal asClauseOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax, ByVal getRequireTypeDiagnosticInfoFunc As Func(Of DiagnosticInfo), ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
			Return Me.DecodeIdentifierType(identifier, asClauseOpt, getRequireTypeDiagnosticInfoFunc, typeSymbol, diagBag)
		End Function

		Public Function DecodeIdentifierType(ByVal identifier As Microsoft.CodeAnalysis.SyntaxToken, ByVal asClauseType As TypeSymbol, ByVal getRequireTypeDiagnosticInfoFunc As Func(Of DiagnosticInfo), ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal decoderContext As Binder.ModifiedIdentifierTypeDecoderContext = 0) As TypeSymbol
			' 
			' Current member / type: Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol Microsoft.CodeAnalysis.VisualBasic.Binder::DecodeIdentifierType(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Func`1<Microsoft.CodeAnalysis.DiagnosticInfo>,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Binder/ModifiedIdentifierTypeDecoderContext)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol DecodeIdentifierType(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Func<Microsoft.CodeAnalysis.DiagnosticInfo>,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Binder/ModifiedIdentifierTypeDecoderContext)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Function

		Private Sub DecodeLocalModifiersAndReportErrors(ByVal syntax As SyntaxTokenList, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			' 
			' Current member / type: System.Void Microsoft.CodeAnalysis.VisualBasic.Binder::DecodeLocalModifiersAndReportErrors(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: System.Void DecodeLocalModifiersAndReportErrors(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Sub

		Public Function DecodeModifiedIdentifierType(ByVal modifiedIdentifier As Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax, ByVal asClauseOrValueType As TypeSymbol, ByVal asClauseSyntaxOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax, ByVal initializerSyntaxOpt As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal getRequireTypeDiagnosticInfoFunc As Func(Of DiagnosticInfo), ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal decoderContext As Binder.ModifiedIdentifierTypeDecoderContext = 0) As TypeSymbol
			' 
			' Current member / type: Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol Microsoft.CodeAnalysis.VisualBasic.Binder::DecodeModifiedIdentifierType(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,System.Func`1<Microsoft.CodeAnalysis.DiagnosticInfo>,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Binder/ModifiedIdentifierTypeDecoderContext)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol DecodeModifiedIdentifierType(Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode,System.Func<Microsoft.CodeAnalysis.DiagnosticInfo>,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Binder/ModifiedIdentifierTypeDecoderContext)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Function

		Public Function DecodeModifiedIdentifierType(ByVal modifiedIdentifier As Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax, ByVal asClauseOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax, ByVal initializerSyntaxOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax, ByVal getRequireTypeDiagnosticInfoFunc As Func(Of DiagnosticInfo), <Out> ByRef asClauseType As TypeSymbol, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal decoderContext As Binder.ModifiedIdentifierTypeDecoderContext = 0) As TypeSymbol
			If (asClauseOpt Is Nothing) Then
				asClauseType = Nothing
			Else
				asClauseType = Me.BindTypeSyntax(asClauseOpt.Type(), diagBag, False, False, False)
			End If
			Return Me.DecodeModifiedIdentifierType(modifiedIdentifier, asClauseType, asClauseOpt, initializerSyntaxOpt, getRequireTypeDiagnosticInfoFunc, diagBag, decoderContext)
		End Function

		Public Function DecodeModifiedIdentifierType(ByVal modifiedIdentifier As Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax, ByVal asClauseOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax, ByVal initializerSyntaxOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax, ByVal getRequireTypeDiagnosticInfoFunc As Func(Of DiagnosticInfo), ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal decoderContext As Binder.ModifiedIdentifierTypeDecoderContext = 0) As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
			Return Me.DecodeModifiedIdentifierType(modifiedIdentifier, asClauseOpt, initializerSyntaxOpt, getRequireTypeDiagnosticInfoFunc, typeSymbol, diagBag, decoderContext)
		End Function

		Public Function DecodeModifiers(ByVal syntax As SyntaxTokenList, ByVal allowableModifiers As SourceMemberFlags, ByVal errIdBadModifier As ERRID, ByVal defaultAccessibility As Accessibility, ByVal diagBag As DiagnosticBag) As MemberModifiers
			' 
			' Current member / type: Microsoft.CodeAnalysis.VisualBasic.MemberModifiers Microsoft.CodeAnalysis.VisualBasic.Binder::DecodeModifiers(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.SourceMemberFlags,Microsoft.CodeAnalysis.VisualBasic.ERRID,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.DiagnosticBag)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: Microsoft.CodeAnalysis.VisualBasic.MemberModifiers DecodeModifiers(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.SourceMemberFlags,Microsoft.CodeAnalysis.VisualBasic.ERRID,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.DiagnosticBag)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Function

		Public Shared Function DecodeOnOff(ByVal keywordSyntax As Microsoft.CodeAnalysis.SyntaxToken) As Boolean
			Dim flag As Boolean
			If (keywordSyntax.Node IsNot Nothing) Then
				Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = keywordSyntax.Kind()
				If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OnKeyword) Then
					flag = True
				Else
					If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OffKeyword) Then
						Throw ExceptionUtilities.UnexpectedValue(keywordSyntax.Kind())
					End If
					flag = False
				End If
			Else
				flag = True
			End If
			Return flag
		End Function

		Public Function DecodeParameterList(ByVal container As Symbol, ByVal isFromLambda As Boolean, ByVal modifiers As SourceMemberFlags, ByVal syntaxOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol)
			Dim empty As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol)
			Dim typeParameters As ImmutableArray(Of TypeParameterSymbol)
			If (syntaxOpt IsNot Nothing) Then
				Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol).GetInstance(syntaxOpt.Parameters.Count)
				Dim methodSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol = TryCast(container, Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)
				Dim sCheckOperatorParameterModifierCallback As Binder.CheckParameterModifierDelegate = Nothing
				If (methodSymbol IsNot Nothing AndAlso methodSymbol.IsUserDefinedOperator()) Then
					sCheckOperatorParameterModifierCallback = Binder.s_checkOperatorParameterModifierCallback
				End If
				Me.DecodeParameterList(container, isFromLambda, modifiers, syntaxOpt.Parameters, instance, sCheckOperatorParameterModifierCallback, diagBag)
				If (methodSymbol Is Nothing OrElse isFromLambda) Then
					typeParameters = ImmutableArray(Of TypeParameterSymbol).Empty
				Else
					typeParameters = methodSymbol.TypeParameters
				End If
				Dim typeParameterSymbols As ImmutableArray(Of TypeParameterSymbol) = typeParameters
				Dim count As Integer = instance.Count - 1
				Dim num As Integer = 0
				Do
					Dim item As Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax = syntaxOpt.Parameters(num)
					Dim parameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol = instance(num)
					If (methodSymbol IsNot Nothing) Then
						If (Not methodSymbol.IsSub AndAlso Not methodSymbol.IsUserDefinedOperator()) Then
							Binder.CheckReservedParameterName(container.Name, item, ERRID.ERR_ParamNameFunctionNameCollision, diagBag)
						End If
						If (methodSymbol.MethodKind <> MethodKind.DeclareMethod) Then
							Binder.CheckParameterNameNotDuplicate(instance, num, item, parameterSymbol, diagBag)
						End If
					End If
					Dim name As String = parameterSymbol.Name
					Dim enumerator As ImmutableArray(Of TypeParameterSymbol).Enumerator = typeParameterSymbols.GetEnumerator()
					While enumerator.MoveNext()
						If (Not CaseInsensitiveComparison.Equals(enumerator.Current.Name, name)) Then
							Continue While
						End If
						Binder.ReportDiagnostic(diagBag, item.Identifier, ERRID.ERR_NameSameAsMethodTypeParam1, New [Object]() { name })
						Exit While
					End While
					num = num + 1
				Loop While num <= count
				Dim immutable As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol) = instance.ToImmutable()
				instance.Free()
				empty = immutable
			Else
				empty = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol).Empty
			End If
			Return empty
		End Function

		Public Sub DecodeParameterList(ByVal container As Symbol, ByVal isFromLambda As Boolean, ByVal modifiers As SourceMemberFlags, ByVal syntax As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax), ByVal params As ArrayBuilder(Of ParameterSymbol), ByVal checkModifier As Binder.CheckParameterModifierDelegate, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			' 
			' Current member / type: System.Void Microsoft.CodeAnalysis.VisualBasic.Binder::DecodeParameterList(Microsoft.CodeAnalysis.VisualBasic.Symbol,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.SourceMemberFlags,Microsoft.CodeAnalysis.SeparatedSyntaxList`1<Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax>,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1<Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol>,Microsoft.CodeAnalysis.VisualBasic.Binder/CheckParameterModifierDelegate,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: System.Void DecodeParameterList(Microsoft.CodeAnalysis.VisualBasic.Symbol,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.SourceMemberFlags,Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax>,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol>,Microsoft.CodeAnalysis.VisualBasic.Binder/CheckParameterModifierDelegate,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Sub

		Public Function DecodeParameterListOfDelegateDeclaration(ByVal container As Symbol, ByVal syntaxOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As ImmutableArray(Of ParameterSymbol)
			Dim empty As ImmutableArray(Of ParameterSymbol)
			If (syntaxOpt IsNot Nothing) Then
				Dim parameters As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax) = syntaxOpt.Parameters
				Dim instance As ArrayBuilder(Of ParameterSymbol) = ArrayBuilder(Of ParameterSymbol).GetInstance(parameters.Count)
				Me.DecodeParameterList(container, False, SourceMemberFlags.None, parameters, instance, Binder.s_checkDelegateParameterModifierCallback, diagBag)
				Dim immutable As ImmutableArray(Of ParameterSymbol) = instance.ToImmutable()
				instance.Free()
				empty = immutable
			Else
				empty = ImmutableArray(Of ParameterSymbol).Empty
			End If
			Return empty
		End Function

		Private Shared Function DecodeParameterModifiers(ByVal container As Symbol, ByVal modifiers As SyntaxTokenList, ByVal checkModifier As Binder.CheckParameterModifierDelegate, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As SourceParameterFlags
			Dim sourceParameterFlag As SourceParameterFlags = 0
			Dim sourceParameterFlag1 As SourceParameterFlags = 0
			Dim enumerator As SyntaxTokenList.Enumerator = modifiers.GetEnumerator()
			While enumerator.MoveNext()
				Dim current As Microsoft.CodeAnalysis.SyntaxToken = enumerator.Current
				Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = current.Kind()
				If (syntaxKind <= Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ByValKeyword) Then
					If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ByRefKeyword) Then
						sourceParameterFlag = SourceParameterFlags.[ByRef]
					ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ByValKeyword) Then
						sourceParameterFlag = SourceParameterFlags.[ByVal]
					End If
				ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OptionalKeyword) Then
					sourceParameterFlag = SourceParameterFlags.[Optional]
				ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ParamArrayKeyword) Then
					sourceParameterFlag = SourceParameterFlags.[ParamArray]
				End If
				If (checkModifier IsNot Nothing) Then
					sourceParameterFlag = checkModifier(container, current, sourceParameterFlag, diagBag)
				End If
				sourceParameterFlag1 = sourceParameterFlag1 Or sourceParameterFlag
			End While
			Return sourceParameterFlag1
		End Function

		Public Function DecodePropertyParameterList(ByVal container As PropertySymbol, ByVal syntaxOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol)
			Dim empty As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol)
			If (syntaxOpt IsNot Nothing) Then
				Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol).GetInstance(syntaxOpt.Parameters.Count)
				Me.DecodeParameterList(container, False, SourceMemberFlags.None, syntaxOpt.Parameters, instance, Binder.s_checkPropertyParameterModifierCallback, diagBag)
				Dim count As Integer = instance.Count - 1
				Dim num As Integer = 0
				Do
					Dim item As Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax = syntaxOpt.Parameters(num)
					Dim parameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol = instance(num)
					If (Binder.CheckReservedParameterName("Value", item, ERRID.ERR_PropertySetParamCollisionWithValue, diagBag)) Then
						Binder.CheckReservedParameterName(container.Name, item, ERRID.ERR_ParamNameFunctionNameCollision, diagBag)
					End If
					Binder.CheckParameterNameNotDuplicate(instance, num, item, parameterSymbol, diagBag)
					num = num + 1
				Loop While num <= count
				Dim immutable As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol) = instance.ToImmutable()
				instance.Free()
				empty = immutable
			Else
				empty = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol).Empty
			End If
			Return empty
		End Function

		Public Shared Function DecodeTextBinary(ByVal keywordSyntax As Microsoft.CodeAnalysis.SyntaxToken) As Nullable(Of Boolean)
			Dim nullable As Nullable(Of Boolean)
			If (keywordSyntax.Node IsNot Nothing) Then
				Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = keywordSyntax.Kind()
				If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.BinaryKeyword) Then
					nullable = New Nullable(Of Boolean)(False)
				Else
					If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TextKeyword) Then
						Throw ExceptionUtilities.UnexpectedValue(keywordSyntax.Kind())
					End If
					nullable = New Nullable(Of Boolean)(True)
				End If
			Else
				nullable = Nothing
			End If
			Return nullable
		End Function

		Public Shared Function DecodeVariance(ByVal varianceKeywordOpt As Microsoft.CodeAnalysis.SyntaxToken) As Microsoft.CodeAnalysis.VarianceKind
			Dim varianceKind As Microsoft.CodeAnalysis.VarianceKind
			Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = varianceKeywordOpt.Kind()
			If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.None) Then
				varianceKind = Microsoft.CodeAnalysis.VarianceKind.None
			ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InKeyword) Then
				varianceKind = Microsoft.CodeAnalysis.VarianceKind.[In]
			Else
				If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OutKeyword) Then
					Throw ExceptionUtilities.UnexpectedValue(varianceKeywordOpt.Kind())
				End If
				varianceKind = Microsoft.CodeAnalysis.VarianceKind.Out
			End If
			Return varianceKind
		End Function

		Private Shared Function DiagnosticBagHasErrorsOtherThanObsoleteOnes(ByVal bag As DiagnosticBag) As Boolean
			Dim flag As Boolean
			Dim enumerator As IEnumerator(Of Diagnostic) = Nothing
			If (Not bag.IsEmptyWithoutResolution) Then
				Using enumerator
					enumerator = bag.AsEnumerable().GetEnumerator()
					While enumerator.MoveNext()
						Dim current As Diagnostic = enumerator.Current
						If (current.Severity <> DiagnosticSeverity.[Error]) Then
							Continue While
						End If
						Dim code As Integer = current.Code
						If (code = 30668 OrElse code - 30911 <= 1 OrElse code = 31075) Then
							Continue While
						End If
						flag = True
						Return flag
					End While
				End Using
				flag = False
			Else
				flag = False
			End If
			Return flag
		End Function

		Public Overridable Sub DisallowFurtherImplicitVariableDeclaration(ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Me.m_containingBinder.DisallowFurtherImplicitVariableDeclaration(diagnostics)
		End Sub

		Private Shared Sub DisallowNewOnTupleType(ByVal type As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			If (type.Kind() = SyntaxKind.TupleType) Then
				diagnostics.Add(ERRID.ERR_NewWithTupleTypeSyntax, type.Location)
			End If
		End Sub

		Public Shared Sub DisallowTypeCharacter(ByVal identifier As Microsoft.CodeAnalysis.SyntaxToken, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal errid As Microsoft.CodeAnalysis.VisualBasic.ERRID = 30468)
			If (identifier.GetTypeCharacter() <> TypeCharacter.None) Then
				Binder.ReportDiagnostic(diagBag, identifier, errid)
			End If
		End Sub

		Public Shared Function ExpressionRefersToReadonlyVariable(ByVal node As BoundExpression, Optional ByVal digThroughProperty As Boolean = True) As Boolean
			Dim isReadOnly As Boolean
			If (node.Kind <> BoundKind.FieldAccess) Then
				If (node.Kind <> BoundKind.Local) Then
					isReadOnly = False
					Return isReadOnly
				End If
				isReadOnly = DirectCast(node, BoundLocal).LocalSymbol.IsReadOnly
				Return isReadOnly
			Else
				Dim boundFieldAccess As Microsoft.CodeAnalysis.VisualBasic.BoundFieldAccess = DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.BoundFieldAccess)
				If (Not boundFieldAccess.FieldSymbol.IsReadOnly) Then
					Dim receiverOpt As BoundExpression = boundFieldAccess.ReceiverOpt
					If (receiverOpt Is Nothing OrElse Not receiverOpt.IsValue() OrElse Not receiverOpt.Type.IsValueType) Then
						isReadOnly = False
						Return isReadOnly
					End If
					isReadOnly = Binder.ExpressionRefersToReadonlyVariable(receiverOpt, False)
					Return isReadOnly
				Else
					isReadOnly = True
					Return isReadOnly
				End If
			End If
			isReadOnly = False
			Return isReadOnly
		End Function

		Private Shared Function ExtractTupleElementNames(ByVal arguments As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As <TupleElementNames(New String() { "elementNames", "inferredPositions", "hasErrors" })> ValueTuple(Of ImmutableArray(Of String), ImmutableArray(Of Boolean), Boolean)
			Dim name As Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax
			Dim flag As Boolean = False
			Dim strs As HashSet(Of String) = New HashSet(Of String)(CaseInsensitiveComparison.Comparer)
			Dim strs1 As ArrayBuilder(Of String) = Nothing
			Dim strs2 As ArrayBuilder(Of String) = Nothing
			Dim count As Integer = arguments.Count
			Dim num As Integer = count - 1
			Dim num1 As Integer = 0
			Do
				Dim item As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax = arguments(num1)
				Dim valueText As String = Nothing
				Dim str As String = Nothing
				Dim nameColonEquals As Microsoft.CodeAnalysis.VisualBasic.Syntax.NameColonEqualsSyntax = item.NameColonEquals
				If (nameColonEquals IsNot Nothing) Then
					name = nameColonEquals.Name
				Else
					name = Nothing
				End If
				Dim identifierNameSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax = name
				If (identifierNameSyntax Is Nothing) Then
					str = Binder.InferTupleElementName(item.Expression)
				Else
					valueText = identifierNameSyntax.Identifier.ValueText
					If (Not Binder.CheckTupleMemberName(valueText, num1, item.NameColonEquals.Name, diagnostics, strs)) Then
						flag = True
					End If
				End If
				Binder.CollectTupleFieldMemberName(valueText, num1, count, strs1)
				Binder.CollectTupleFieldMemberName(str, num1, count, strs2)
				num1 = num1 + 1
			Loop While num1 <= num
			Binder.RemoveDuplicateInferredTupleNamesAndFreeIfEmptied(strs2, strs)
			Dim valueTuple As ValueTuple(Of ImmutableArray(Of String), ImmutableArray(Of Boolean)) = Binder.MergeTupleElementNames(strs1, strs2)
			If (strs1 IsNot Nothing) Then
				strs1.Free()
			End If
			If (strs2 IsNot Nothing) Then
				strs2.Free()
			End If
			Return New ValueTuple(Of ImmutableArray(Of String), ImmutableArray(Of Boolean), Boolean)(valueTuple.Item1, valueTuple.Item2, flag)
		End Function

		Public Shared Function ExtractTypeCharacter(ByVal node As SyntaxNode) As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter
			Dim typeCharacter As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter = Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter.None
			If (node IsNot Nothing) Then
				Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = node.Kind()
				If (CUShort(syntaxKind) - CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleMemberAccessExpression) <= CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List)) Then
					typeCharacter = Binder.ExtractTypeCharacter(DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax).Name)
				ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IdentifierName) Then
					typeCharacter = DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax).Identifier.GetTypeCharacter()
				ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GenericName) Then
					typeCharacter = DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax).Identifier.GetTypeCharacter()
				End If
			End If
			Return typeCharacter
		End Function

		Public Shared Function FindFirstKeyword(ByVal syntax As SyntaxTokenList, ByVal ParamArray keywordKinds As SyntaxKind()) As Microsoft.CodeAnalysis.SyntaxToken
			Dim syntaxToken As Microsoft.CodeAnalysis.SyntaxToken
			Dim enumerator As SyntaxTokenList.Enumerator = syntax.GetEnumerator()
			While True
				If (enumerator.MoveNext()) Then
					Dim current As Microsoft.CodeAnalysis.SyntaxToken = enumerator.Current
					If (Array.IndexOf(Of SyntaxKind)(keywordKinds, current.Kind()) >= 0) Then
						syntaxToken = current
						Exit While
					End If
				Else
					syntaxToken = New Microsoft.CodeAnalysis.SyntaxToken()
					Exit While
				End If
			End While
			Return syntaxToken
		End Function

		Private Function ForceLiftToEmptyString(ByVal left As BoundExpression, ByVal stringType As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim boundLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundLiteral = (New Microsoft.CodeAnalysis.VisualBasic.BoundLiteral(left.Syntax, ConstantValue.[Nothing], stringType)).MakeCompilerGenerated()
			Return Me.AnalyzeConversionAndCreateBinaryConditionalExpression(left.Syntax, left, boundLiteral, Nothing, stringType, False, diagnostics, True).MakeCompilerGenerated()
		End Function

		Private Shared Function GenerateBadExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax, ByVal target As BoundExpression, ByVal boundArguments As ImmutableArray(Of BoundExpression)) As BoundExpression
			Dim instance As ArrayBuilder(Of BoundExpression) = ArrayBuilder(Of BoundExpression).GetInstance()
			instance.Add(target)
			instance.AddRange(boundArguments)
			Return Binder.BadExpression(node, instance.ToImmutableAndFree(), ErrorTypeSymbol.UnknownResultType)
		End Function

		Private Function GenerateDiagnosticsForDominantTypeInferenceInIfExpression(ByVal dominantType As TypeSymbol, ByVal numCandidates As Integer, ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
			Dim flag As Boolean = False
			If (dominantType Is Nothing) Then
				Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_IfNoType)
				flag = True
			ElseIf (numCandidates <> 0) Then
				If (numCandidates > 1) Then
					If (Me.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.[On]) Then
						Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_IfTooManyTypesObjectDisallowed)
						flag = True
					ElseIf (Me.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.Custom) Then
						Binder.ReportDiagnostic(diagnostics, node, ErrorFactory.ErrorInfo(ERRID.WRN_ObjectAssumed1, New [Object]() { ErrorFactory.ErrorInfo(ERRID.WRN_IfTooManyTypesObjectAssumed) }))
					End If
				End If
			ElseIf (Me.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.[On]) Then
				Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_IfNoTypeObjectDisallowed)
				flag = True
			ElseIf (Me.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.Custom) Then
				Binder.ReportDiagnostic(diagnostics, node, ErrorFactory.ErrorInfo(ERRID.WRN_ObjectAssumed1, New [Object]() { ErrorFactory.ErrorInfo(ERRID.WRN_IfNoTypeObjectAssumed) }))
			End If
			Return flag
		End Function

		Private Shared Sub GetAbsorbingJoinSelectorLambdaKindAndSyntax(ByVal clauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax, ByVal absorbNextOperator As Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax, <Out> ByRef lambdaKind As SynthesizedLambdaKind, <Out> ByRef lambdaSyntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)
			If (absorbNextOperator Is Nothing) Then
				Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = clauseSyntax.Kind()
				If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FromClause) Then
					lambdaKind = SynthesizedLambdaKind.FromNonUserCodeQueryLambda
				ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AggregateClause) Then
					lambdaKind = SynthesizedLambdaKind.FromNonUserCodeQueryLambda
				Else
					If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleJoinClause) Then
						Throw ExceptionUtilities.UnexpectedValue(clauseSyntax.Kind())
					End If
					lambdaKind = SynthesizedLambdaKind.JoinNonUserCodeQueryLambda
				End If
				lambdaSyntax = clauseSyntax
				Return
			End If
			Dim syntaxKind1 As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = absorbNextOperator.Kind()
			If (syntaxKind1 = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LetClause) Then
				Dim expressionRangeVariableSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax = DirectCast(absorbNextOperator, Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax).Variables.First()
				lambdaSyntax = LambdaUtilities.GetLetVariableLambdaBody(expressionRangeVariableSyntax)
				lambdaKind = SynthesizedLambdaKind.LetVariableQueryLambda
				Return
			End If
			If (syntaxKind1 = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AggregateClause) Then
				Dim collectionRangeVariableSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax = DirectCast(absorbNextOperator, Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax).Variables.First()
				lambdaSyntax = LambdaUtilities.GetFromOrAggregateVariableLambdaBody(collectionRangeVariableSyntax)
				lambdaKind = SynthesizedLambdaKind.AggregateQueryLambda
				Return
			End If
			If (syntaxKind1 <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SelectClause) Then
				Throw ExceptionUtilities.UnexpectedValue(absorbNextOperator.Kind())
			End If
			lambdaSyntax = LambdaUtilities.GetSelectLambdaBody(DirectCast(absorbNextOperator, Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax))
			lambdaKind = SynthesizedLambdaKind.SelectQueryLambda
		End Sub

		Friend Function GetAccessibleConstructors(ByVal type As NamedTypeSymbol, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol)) As ImmutableArray(Of MethodSymbol)
			Dim immutableAndFree As ImmutableArray(Of MethodSymbol)
			Dim instanceConstructors As ImmutableArray(Of MethodSymbol) = type.InstanceConstructors
			If (Not instanceConstructors.IsEmpty) Then
				Dim instance As ArrayBuilder(Of MethodSymbol) = ArrayBuilder(Of MethodSymbol).GetInstance()
				Dim enumerator As ImmutableArray(Of MethodSymbol).Enumerator = instanceConstructors.GetEnumerator()
				While enumerator.MoveNext()
					Dim current As MethodSymbol = enumerator.Current
					If (Not Me.IsAccessible(current, useSiteInfo, Nothing, New BasesBeingResolved())) Then
						Continue While
					End If
					instance.Add(current)
				End While
				immutableAndFree = instance.ToImmutableAndFree()
			Else
				immutableAndFree = instanceConstructors
			End If
			Return immutableAndFree
		End Function

		Friend Shared Function GetAccessorName(ByVal name As String, ByVal kind As MethodKind, ByVal isWinMd As Boolean) As String
			Dim str As String
			Select Case kind
				Case MethodKind.EventAdd
					str = "add_"
					Exit Select
				Case MethodKind.EventRaise
					str = "raise_"
					Exit Select
				Case MethodKind.EventRemove
					str = "remove_"
					Exit Select
				Case MethodKind.ExplicitInterfaceImplementation
				Case MethodKind.UserDefinedOperator
				Case MethodKind.Ordinary
					Throw ExceptionUtilities.UnexpectedValue(kind)
				Case MethodKind.PropertyGet
					str = "get_"
					Exit Select
				Case MethodKind.PropertySet
					If (Not isWinMd) Then
						str = "set_"
						Exit Select
					Else
						str = "put_"
						Exit Select
					End If
				Case Else
					Throw ExceptionUtilities.UnexpectedValue(kind)
			End Select
			Return [String].Concat(str, name)
		End Function

		Private Function GetAccessThroughType(ByVal receiverOpt As BoundExpression) As TypeSymbol
			Dim containingType As TypeSymbol
			If (receiverOpt Is Nothing OrElse receiverOpt.Kind = BoundKind.MyBaseReference) Then
				containingType = Me.ContainingType
			Else
				containingType = receiverOpt.Type
			End If
			Return containingType
		End Function

		Friend Function GetArgumentForParameterDefaultValue(ByVal param As ParameterSymbol, ByVal syntax As SyntaxNode, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal callerInfoOpt As SyntaxNode) As BoundExpression
			' 
			' Current member / type: Microsoft.CodeAnalysis.VisualBasic.BoundExpression Microsoft.CodeAnalysis.VisualBasic.Binder::GetArgumentForParameterDefaultValue(Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag,Microsoft.CodeAnalysis.SyntaxNode)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: Microsoft.CodeAnalysis.VisualBasic.BoundExpression GetArgumentForParameterDefaultValue(Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag,Microsoft.CodeAnalysis.SyntaxNode)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Function

		Friend Function GetAttribute(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax, ByVal boundAttributeType As NamedTypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As SourceAttributeData
			Dim boundAttribute As Microsoft.CodeAnalysis.VisualBasic.BoundAttribute = Me.BindAttribute(node, boundAttributeType, diagnostics)
			Dim attributeExpressionVisitor As Binder.AttributeExpressionVisitor = New Binder.AttributeExpressionVisitor(Me, boundAttribute.HasErrors)
			Dim typedConstants As ImmutableArray(Of TypedConstant) = attributeExpressionVisitor.VisitPositionalArguments(boundAttribute.ConstructorArguments, diagnostics)
			Dim keyValuePairs As ImmutableArray(Of KeyValuePair(Of String, TypedConstant)) = attributeExpressionVisitor.VisitNamedArguments(boundAttribute.NamedArguments, diagnostics)
			Dim flag As Boolean = If(attributeExpressionVisitor.HasErrors, False, Me.IsAttributeConditionallyOmitted(boundAttributeType, node, boundAttribute.SyntaxTree))
			Return New SourceAttributeData(node.GetReference(), DirectCast(boundAttribute.Type, NamedTypeSymbol), boundAttribute.Constructor, typedConstants, keyValuePairs, flag, attributeExpressionVisitor.HasErrors)
		End Function

		Friend Shared Sub GetAttributes(ByVal binders As ImmutableArray(Of Binder), ByVal attributesToBind As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax), ByVal boundAttributeTypes As ImmutableArray(Of NamedTypeSymbol), ByVal attributeBuilder As VisualBasicAttributeData(), ByVal ownerSymbol As Symbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Dim length As Integer = attributesToBind.Length - 1
			For i As Integer = 0 To length
				If (attributeBuilder(i) Is Nothing) Then
					Dim item As Binder = binders(i)
					item = New LocationSpecificBinder(Microsoft.CodeAnalysis.VisualBasic.BindingLocation.Attribute, ownerSymbol, item)
					attributeBuilder(i) = item.GetAttribute(attributesToBind(i), boundAttributeTypes(i), diagnostics)
				End If
			Next

		End Sub

		Private Function GetAwaitInNonAsyncError() As Microsoft.CodeAnalysis.DiagnosticInfo
			Dim diagnosticInfo As Microsoft.CodeAnalysis.DiagnosticInfo
			If (Me.IsInLambda) Then
				diagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_BadAwaitInNonAsyncLambda)
			ElseIf (Me.ContainingMember.Kind <> SymbolKind.Method) Then
				diagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_BadAwaitNotInAsyncMethodOrLambda)
			Else
				Dim containingMember As MethodSymbol = DirectCast(Me.ContainingMember, MethodSymbol)
				diagnosticInfo = If(Not containingMember.IsSub, ErrorFactory.ErrorInfo(ERRID.ERR_BadAwaitInNonAsyncMethod, New [Object]() { containingMember.ReturnType }), ErrorFactory.ErrorInfo(ERRID.ERR_BadAwaitInNonAsyncVoidMethod))
			End If
			Return diagnosticInfo
		End Function

		Private Shared Function GetBestAttributeFieldOrProperty(ByVal result As LookupResult) As Microsoft.CodeAnalysis.VisualBasic.Symbol
			Dim singleSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbol
			If (Not result.HasSingleSymbol) Then
				Dim symbol As Microsoft.CodeAnalysis.VisualBasic.Symbol = Nothing
				Dim symbols As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbol) = result.Symbols
				Dim enumerator As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbol).Enumerator = symbols.GetEnumerator()
				While enumerator.MoveNext()
					Dim current As Microsoft.CodeAnalysis.VisualBasic.Symbol = enumerator.Current
					Dim kind As SymbolKind = current.Kind
					If (kind = SymbolKind.Field) Then
						singleSymbol = current
						Return singleSymbol
					ElseIf (kind = SymbolKind.[Property]) Then
						symbol = current
						Dim propertySymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol = DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol)
						Dim mostDerivedSetMethod As MethodSymbol = propertySymbol.GetMostDerivedSetMethod()
						If (mostDerivedSetMethod Is Nothing OrElse mostDerivedSetMethod.ParameterCount <> 1) Then
							Continue While
						End If
						singleSymbol = propertySymbol
						Return singleSymbol
					End If
				End While
				singleSymbol = If(symbol IsNot Nothing, symbol, symbols(0))
			Else
				singleSymbol = result.SingleSymbol
			End If
			Return singleSymbol
		End Function

		Public Overridable Function GetBinder(ByVal node As SyntaxNode) As Binder
			Return Me.m_containingBinder.GetBinder(node)
		End Function

		Public Overridable Function GetBinder(ByVal stmtList As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)) As Binder
			Return Me.m_containingBinder.GetBinder(stmtList)
		End Function

		Private Shared Function GetCallerLocation(ByVal syntax As SyntaxNode) As TextSpan
			Dim span As TextSpan
			Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = syntax.Kind()
			If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleMemberAccessExpression) Then
				span = DirectCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax).Name.Span
			Else
				span = If(syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DictionaryAccessExpression, DirectCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax).OperatorToken.Span, syntax.Span)
			End If
			Return span
		End Function

		Private Function GetCommonExpressionTypeForErrorRecovery(ByVal symbolReference As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal symbols As ImmutableArray(Of Symbol), ByVal constantFieldsInProgress As Microsoft.CodeAnalysis.VisualBasic.ConstantFieldsInProgress) As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim extendedErrorTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
			Dim name As String = Nothing
			Dim flag As Boolean = False
			Dim flag1 As Boolean = False
			Dim discarded As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
			Dim length As Integer = symbols.Length - 1
			Dim num As Integer = 0
			Do
				Dim expressionType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Me.GetExpressionType(symbolReference, symbols(num), constantFieldsInProgress, discarded)
				If (expressionType IsNot Nothing) Then
					If (typeSymbol Is Nothing) Then
						typeSymbol = expressionType
					ElseIf (Not flag AndAlso Not typeSymbol.Equals(expressionType)) Then
						flag = True
					End If
					If (name Is Nothing) Then
						name = expressionType.Name
					ElseIf (Not flag1 AndAlso Not CaseInsensitiveComparison.Equals(name, expressionType.Name)) Then
						flag1 = True
					End If
				End If
				num = num + 1
			Loop While num <= length
			If (Not flag) Then
				extendedErrorTypeSymbol = typeSymbol
			ElseIf (Not flag1) Then
				extendedErrorTypeSymbol = New Microsoft.CodeAnalysis.VisualBasic.Symbols.ExtendedErrorTypeSymbol(Nothing, name, False, Nothing)
			Else
				extendedErrorTypeSymbol = ErrorTypeSymbol.UnknownResultType
			End If
			Return extendedErrorTypeSymbol
		End Function

		Protected Function GetConditionalAccessReceiver(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.TryGetConditionalAccessReceiver(node)
			If (boundExpression1 IsNot Nothing) Then
				boundExpression = boundExpression1
			Else
				Dim boundRValuePlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder = Nothing
				Me.BindConditionalAccessReceiver(node, Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded, boundRValuePlaceholder)
				boundExpression = boundRValuePlaceholder
			End If
			Return boundExpression
		End Function

		Private Shared Function GetContainingTypeBlock(ByVal modifierToken As Microsoft.CodeAnalysis.SyntaxToken) As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax
			Dim parent As SyntaxNode = modifierToken.Parent
			If (TypeOf parent.Parent Is Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax OrElse TypeOf parent.Parent Is Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax) Then
				parent = parent.Parent
			End If
			Return TryCast(parent.Parent, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax)
		End Function

		Public Overridable Function GetContinueLabel(ByVal continueSyntaxKind As SyntaxKind) As LabelSymbol
			Return Me.m_containingBinder.GetContinueLabel(continueSyntaxKind)
		End Function

		Private Function GetCurrentReturnType(<Out> ByRef isAsync As Boolean, <Out> ByRef isIterator As Boolean, <Out> ByRef methodReturnType As TypeSymbol) As TypeSymbol
			Dim item As TypeSymbol
			isAsync = False
			isIterator = False
			Dim containingMember As MethodSymbol = TryCast(Me.ContainingMember, MethodSymbol)
			If (containingMember Is Nothing) Then
				methodReturnType = ErrorTypeSymbol.UnknownResultType
				item = methodReturnType
			Else
				methodReturnType = containingMember.ReturnType
				isAsync = containingMember.IsAsync
				isIterator = If(isAsync, False, containingMember.IsIterator)
				If (Not containingMember.IsSub) Then
					If (isAsync AndAlso containingMember.ReturnType.OriginalDefinition.Equals(Me.Compilation.GetWellKnownType(WellKnownType.System_Threading_Tasks_Task_T))) Then
						item = DirectCast(containingMember.ReturnType, NamedTypeSymbol).TypeArgumentsNoUseSiteDiagnostics(0)
						Return item
					ElseIf (Not isAsync OrElse Not containingMember.ReturnType.Equals(Me.Compilation.GetWellKnownType(WellKnownType.System_Threading_Tasks_Task))) Then
						If (Not isIterator) Then
							GoTo Label1
						End If
						item = Me.Compilation.GetSpecialType(SpecialType.System_Void)
						Return item
					Else
						item = Me.Compilation.GetSpecialType(SpecialType.System_Void)
						Return item
					End If
				End If
			Label1:
				item = methodReturnType
			End If
			Return item
		End Function

		Private Function GetCurrentYieldType(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.YieldStatementSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As TypeSymbol
			Dim item As TypeSymbol
			Dim containingMember As MethodSymbol = TryCast(Me.ContainingMember, MethodSymbol)
			If (containingMember IsNot Nothing) Then
				Dim returnType As TypeSymbol = containingMember.ReturnType
				If (Not containingMember.IsIterator) Then
					Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_BadYieldInNonIteratorMethod)
				End If
				If (Not containingMember.IsSub) Then
					Dim originalDefinition As NamedTypeSymbol = TryCast(returnType.OriginalDefinition, NamedTypeSymbol)
					Dim specialType As Microsoft.CodeAnalysis.SpecialType = If(originalDefinition IsNot Nothing, originalDefinition.SpecialType, Microsoft.CodeAnalysis.SpecialType.None)
					If (specialType = Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_IEnumerable_T OrElse specialType = Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_IEnumerator_T) Then
						item = DirectCast(returnType, NamedTypeSymbol).TypeArgumentsNoUseSiteDiagnostics(0)
						Return item
					Else
						If (specialType <> Microsoft.CodeAnalysis.SpecialType.System_Collections_IEnumerable AndAlso specialType <> Microsoft.CodeAnalysis.SpecialType.System_Collections_IEnumerator) Then
							If (CObj(returnType) <> CObj(LambdaSymbol.ReturnTypeIsUnknown) AndAlso CObj(returnType) <> CObj(LambdaSymbol.ReturnTypeIsBeingInferred)) Then
								item = ErrorTypeSymbol.UnknownResultType
								Return item
							End If
							item = returnType
							Return item
						End If
						item = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Object, node, diagnostics)
						Return item
					End If
				End If
				If (CObj(returnType) <> CObj(LambdaSymbol.ReturnTypeIsUnknown) AndAlso CObj(returnType) <> CObj(LambdaSymbol.ReturnTypeIsBeingInferred)) Then
					item = ErrorTypeSymbol.UnknownResultType
					Return item
				End If
				item = returnType
				Return item
			End If
			item = ErrorTypeSymbol.UnknownResultType
			Return item
		End Function

		Private Shared Function GetDelegateMethodConversionBasedOnArguments(ByVal bestResult As OverloadResolution.CandidateAnalysisResult, ByVal delegateInvoke As MethodSymbol, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol)) As Microsoft.CodeAnalysis.VisualBasic.MethodConversionKind
			Dim parameters As ImmutableArray(Of ParameterSymbol)
			Dim methodConversionKind As Microsoft.CodeAnalysis.VisualBasic.MethodConversionKind = Microsoft.CodeAnalysis.VisualBasic.MethodConversionKind.Identity
			Dim candidate As OverloadResolution.Candidate = bestResult.Candidate
			Dim parameterCount As Integer = candidate.ParameterCount
			Dim num As Integer = parameterCount - 1
			Dim parameterCount1 As Integer = delegateInvoke.ParameterCount
			Dim num1 As Integer = Math.Min(parameterCount, parameterCount1) - 1
			If (bestResult.IsExpandedParamArrayForm) Then
				methodConversionKind = methodConversionKind Or Microsoft.CodeAnalysis.VisualBasic.MethodConversionKind.ExcessOptionalArgumentsOnTarget
			ElseIf (parameterCount > parameterCount1) Then
				methodConversionKind = methodConversionKind Or Microsoft.CodeAnalysis.VisualBasic.MethodConversionKind.ExcessOptionalArgumentsOnTarget
			ElseIf (num1 >= 0 AndAlso candidate.Parameters(num1).IsParamArray AndAlso delegateInvoke.Parameters(num1).IsByRef AndAlso candidate.Parameters(num1).IsByRef AndAlso Not bestResult.ConversionsOpt.IsDefaultOrEmpty AndAlso Not Microsoft.CodeAnalysis.VisualBasic.Conversions.IsIdentityConversion(bestResult.ConversionsOpt(num1).Key)) Then
				Dim type As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = candidate.Parameters(num1).Type
				parameters = delegateInvoke.Parameters
				Dim keyValuePair As KeyValuePair(Of ConversionKind, MethodSymbol) = Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyConversion(type, parameters(num1).Type, useSiteInfo)
				Dim key As ConversionKind = keyValuePair.Key
				parameters = delegateInvoke.Parameters
				methodConversionKind = methodConversionKind Or Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyMethodConversionBasedOnArgumentConversion(key, parameters(num1).Type)
			End If
			Dim num2 As Integer = num1
			Dim num3 As Integer = 0
			While num3 <= num2
				If (delegateInvoke.Parameters(num3).IsByRef = candidate.Parameters(num3).IsByRef) Then
					num3 = num3 + 1
				Else
					methodConversionKind = methodConversionKind Or Microsoft.CodeAnalysis.VisualBasic.MethodConversionKind.Error_ByRefByValMismatch
					Exit While
				End If
			End While
			If (bestResult.IsExpandedParamArrayForm AndAlso (methodConversionKind And Microsoft.CodeAnalysis.VisualBasic.MethodConversionKind.Error_ByRefByValMismatch) <> Microsoft.CodeAnalysis.VisualBasic.MethodConversionKind.Error_ByRefByValMismatch) Then
				Dim isByRef As Boolean = candidate.Parameters(num).IsByRef
				Dim num4 As Integer = parameterCount1 - 1
				Dim num5 As Integer = num1 + 1
				While num5 <= num4
					If (delegateInvoke.Parameters(num5).IsByRef = isByRef) Then
						num5 = num5 + 1
					Else
						methodConversionKind = methodConversionKind Or Microsoft.CodeAnalysis.VisualBasic.MethodConversionKind.Error_ByRefByValMismatch
						Exit While
					End If
				End While
			End If
			If (Not bestResult.ConversionsOpt.IsDefaultOrEmpty) Then
				Dim length As Integer = bestResult.ConversionsOpt.Length - 1
				For i As Integer = 0 To length
					Dim item As KeyValuePair(Of ConversionKind, MethodSymbol) = bestResult.ConversionsOpt(i)
					parameters = delegateInvoke.Parameters
					Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = parameters(i).Type
					methodConversionKind = methodConversionKind Or Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyMethodConversionBasedOnArgumentConversion(item.Key, typeSymbol)
				Next

			End If
			If (Not bestResult.ConversionsBackOpt.IsDefaultOrEmpty) Then
				Dim length1 As Integer = bestResult.ConversionsBackOpt.Length - 1
				For j As Integer = 0 To length1
					Dim item1 As KeyValuePair(Of ConversionKind, MethodSymbol) = bestResult.ConversionsBackOpt(j)
					If (Not Microsoft.CodeAnalysis.VisualBasic.Conversions.IsIdentityConversion(item1.Key)) Then
						Dim type1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = candidate.Parameters(j).Type
						methodConversionKind = methodConversionKind Or Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyMethodConversionBasedOnArgumentConversion(item1.Key, type1)
					End If
				Next

			End If
			Return methodConversionKind
		End Function

		Private Shared Function GetDelegateOrEventKeywordText(ByVal sym As Symbol) As String
			Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind
			If (sym.Kind <> SymbolKind.[Event]) Then
				syntaxKind = If(Not TypeOf sym.ContainingType Is SynthesizedEventDelegateSymbol, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DelegateKeyword, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EventKeyword)
			Else
				syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EventKeyword
			End If
			Return SyntaxFacts.GetText(syntaxKind)
		End Function

		Public Shared Function GetErrorSymbol(ByVal name As String, ByVal errorInfo As DiagnosticInfo, ByVal candidateSymbols As ImmutableArray(Of Symbol), ByVal resultKind As LookupResultKind, Optional ByVal reportErrorWhenReferenced As Boolean = False) As ErrorTypeSymbol
			Return New ExtendedErrorTypeSymbol(errorInfo, name, 0, candidateSymbols, resultKind, reportErrorWhenReferenced)
		End Function

		Public Shared Function GetErrorSymbol(ByVal name As String, ByVal errorInfo As DiagnosticInfo, Optional ByVal reportErrorWhenReferenced As Boolean = False) As ErrorTypeSymbol
			Return Binder.GetErrorSymbol(name, errorInfo, ImmutableArray(Of Symbol).Empty, LookupResultKind.Empty, reportErrorWhenReferenced)
		End Function

		Public Overridable Function GetExitLabel(ByVal exitSyntaxKind As SyntaxKind) As LabelSymbol
			Return Me.m_containingBinder.GetExitLabel(exitSyntaxKind)
		End Function

		Public Function GetExpressionConstantValueIfAny(ByVal boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal context As Binder.ConstantContext) As Microsoft.CodeAnalysis.ConstantValue
			Dim constantValue As Microsoft.CodeAnalysis.ConstantValue
			Dim constantValue1 As Microsoft.CodeAnalysis.ConstantValue
			Dim constantValue2 As Microsoft.CodeAnalysis.ConstantValue
			Dim constantValue3 As Microsoft.CodeAnalysis.ConstantValue
			Dim constantValueOpt As Microsoft.CodeAnalysis.ConstantValue
			Dim constantValue4 As Microsoft.CodeAnalysis.ConstantValue
			Dim flag As Boolean = False
			While True
				If (boundExpression.Kind = BoundKind.Local) Then
					Dim localSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol = DirectCast(boundExpression, BoundLocal).LocalSymbol
					If (localSymbol.IsConst) Then
						If (flag) Then
							constantValue4 = Nothing
						Else
							constantValue4 = localSymbol.GetConstantValue(Me)
						End If
						constantValue = constantValue4
						Exit While
					Else
						Binder.ReportDiagnostic(diagnostics, boundExpression.Syntax, ERRID.ERR_RequiredConstExpr)
						constantValue = Nothing
						Exit While
					End If
				ElseIf (boundExpression.ConstantValueOpt Is Nothing) Then
					Dim kind As BoundKind = boundExpression.Kind
					If (kind <= BoundKind.UnaryOperator) Then
						If (kind = BoundKind.BadExpression) Then
							constantValue = Nothing
							Exit While
						ElseIf (kind = BoundKind.Parenthesized) Then
							boundExpression = DirectCast(boundExpression, BoundParenthesized).Expression
						ElseIf (kind = BoundKind.UnaryOperator) Then
							boundExpression = DirectCast(boundExpression, BoundUnaryOperator).Operand
						Else
							Binder.ReportDiagnostic(diagnostics, boundExpression.Syntax, ERRID.ERR_RequiredConstExpr)
							constantValue = Nothing
							Return constantValue
						End If
					ElseIf (kind <= BoundKind.Conversion) Then
						If (kind = BoundKind.BinaryOperator) Then
							Dim boundBinaryOperator As Microsoft.CodeAnalysis.VisualBasic.BoundBinaryOperator = DirectCast(boundExpression, Microsoft.CodeAnalysis.VisualBasic.BoundBinaryOperator)
							Me.GetExpressionConstantValueIfAny(boundBinaryOperator.Right, diagnostics, context)
							flag = True
							boundExpression = boundBinaryOperator.Left
						ElseIf (kind = BoundKind.Conversion) Then
							Dim boundConversion As Microsoft.CodeAnalysis.VisualBasic.BoundConversion = DirectCast(boundExpression, Microsoft.CodeAnalysis.VisualBasic.BoundConversion)
							Dim constantValue5 As Microsoft.CodeAnalysis.ConstantValue = Me.CheckConversionForConstantExpression(boundConversion, boundConversion.Operand, diagnostics, context)
							If (flag) Then
								constantValue3 = Nothing
							Else
								constantValue3 = constantValue5
							End If
							constantValue = constantValue3
							Exit While
						Else
							Binder.ReportDiagnostic(diagnostics, boundExpression.Syntax, ERRID.ERR_RequiredConstExpr)
							constantValue = Nothing
							Return constantValue
						End If
					ElseIf (kind = BoundKind.[DirectCast]) Then
						Dim boundDirectCast As Microsoft.CodeAnalysis.VisualBasic.BoundDirectCast = DirectCast(boundExpression, Microsoft.CodeAnalysis.VisualBasic.BoundDirectCast)
						Dim constantValue6 As Microsoft.CodeAnalysis.ConstantValue = Me.CheckConversionForConstantExpression(boundDirectCast, boundDirectCast.Operand, diagnostics, context)
						If (flag) Then
							constantValue1 = Nothing
						Else
							constantValue1 = constantValue6
						End If
						constantValue = constantValue1
						Exit While
					ElseIf (kind = BoundKind.[TryCast]) Then
						Dim boundTryCast As Microsoft.CodeAnalysis.VisualBasic.BoundTryCast = DirectCast(boundExpression, Microsoft.CodeAnalysis.VisualBasic.BoundTryCast)
						Dim constantValue7 As Microsoft.CodeAnalysis.ConstantValue = Me.CheckConversionForConstantExpression(boundTryCast, boundTryCast.Operand, diagnostics, context)
						If (flag) Then
							constantValue2 = Nothing
						Else
							constantValue2 = constantValue7
						End If
						constantValue = constantValue2
						Exit While
					Else
						Binder.ReportDiagnostic(diagnostics, boundExpression.Syntax, ERRID.ERR_RequiredConstExpr)
						constantValue = Nothing
						Return constantValue
					End If
				Else
					If (flag) Then
						constantValueOpt = Nothing
					Else
						constantValueOpt = boundExpression.ConstantValueOpt
					End If
					constantValue = constantValueOpt
					Exit While
				End If
			End While
			Return constantValue
		End Function

		Private Function GetExpressionType(ByVal symbolReference As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal s As Symbol, ByVal constantFieldsInProgress As Microsoft.CodeAnalysis.VisualBasic.ConstantFieldsInProgress, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim inferredType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Select Case s.Kind
				Case SymbolKind.Field
					inferredType = DirectCast(s, FieldSymbol).GetInferredType(constantFieldsInProgress)
					Exit Select
				Case SymbolKind.Label
				Case SymbolKind.NetModule
				Case SymbolKind.NamedType
				Case SymbolKind.[Namespace]
				Case SymbolKind.PointerType
				Label0:
					Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = TryCast(s, Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)
					If (typeSymbol Is Nothing) Then
						inferredType = Nothing
						Exit Select
					Else
						inferredType = typeSymbol
						Exit Select
					End If
				Case SymbolKind.Local
					inferredType = Me.GetLocalSymbolType(DirectCast(s, LocalSymbol), symbolReference, diagnostics)
					Exit Select
				Case SymbolKind.Method
					inferredType = DirectCast(s, MethodSymbol).ReturnType
					Exit Select
				Case SymbolKind.Parameter
					inferredType = DirectCast(s, ParameterSymbol).Type
					Exit Select
				Case SymbolKind.[Property]
					inferredType = DirectCast(s, PropertySymbol).Type
					Exit Select
				Case SymbolKind.RangeVariable
					inferredType = DirectCast(s, RangeVariableSymbol).Type
					Exit Select
				Case Else
					GoTo Label0
			End Select
			Return inferredType
		End Function

		Private Shared Function GetGroupByOperatorNameSpan(ByVal groupBy As Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax) As TextSpan
			Dim span As TextSpan
			Dim groupKeyword As Microsoft.CodeAnalysis.SyntaxToken
			If (groupBy.Items.Count <> 0) Then
				groupKeyword = groupBy.GroupKeyword
				span = groupKeyword.Span
			Else
				Dim syntaxToken As Microsoft.CodeAnalysis.SyntaxToken = groupBy.GroupKeyword
				groupKeyword = groupBy.ByKeyword
				span = Binder.GetQueryOperatorNameSpan(syntaxToken, groupKeyword)
			End If
			Return span
		End Function

		Friend Function GetInaccessibleErrorInfo(ByVal sym As Symbol) As Microsoft.CodeAnalysis.DiagnosticInfo
			Dim diagnosticInfo As Microsoft.CodeAnalysis.DiagnosticInfo
			Dim target As Symbol = sym
			Dim aliasSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol = TryCast(sym, Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol)
			If (aliasSymbol IsNot Nothing) Then
				target = aliasSymbol.Target
			ElseIf (sym.Kind = SymbolKind.Method) Then
				sym = DirectCast(sym, MethodSymbol).ConstructedFrom
			End If
			diagnosticInfo = If(target.Kind <> SymbolKind.Method OrElse target.ContainingSymbol Is Nothing, New BadSymbolDiagnostic(sym, ERRID.ERR_InaccessibleSymbol2, New [Object]() { CustomSymbolDisplayFormatter.QualifiedName(sym), AccessCheck.GetAccessibilityForErrorMessage(sym, sym.ContainingAssembly) }), New BadSymbolDiagnostic(sym, ERRID.ERR_InaccessibleMember3, New [Object]() { sym.ContainingSymbol.Name, sym, AccessCheck.GetAccessibilityForErrorMessage(sym, Me.Compilation.Assembly) }))
			Return diagnosticInfo
		End Function

		Friend Overridable Sub GetInScopeXmlNamespaces(ByVal builder As ArrayBuilder(Of KeyValuePair(Of String, String)))
			Me.m_containingBinder.GetInScopeXmlNamespaces(builder)
		End Sub

		Private Function GetInternalXmlHelperType(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As NamedTypeSymbol
			Dim internalXmlHelperType As NamedTypeSymbol = Me.GetInternalXmlHelperType()
			Dim useSiteInfoForWellKnownType As UseSiteInfo(Of AssemblySymbol) = Binder.GetUseSiteInfoForWellKnownType(internalXmlHelperType)
			Binder.ReportUseSite(diagBag, syntax, useSiteInfoForWellKnownType)
			Return internalXmlHelperType
		End Function

		Private Function GetInternalXmlHelperType() As NamedTypeSymbol
			Dim str As String = "My.InternalXmlHelper"
			Dim rootNamespace As String = Me.Compilation.Options.RootNamespace
			If (Not [String].IsNullOrEmpty(rootNamespace)) Then
				str = [String].Format("{0}.{1}", CObj(rootNamespace), str)
			End If
			Dim metadataTypeName As Microsoft.CodeAnalysis.MetadataTypeName = Microsoft.CodeAnalysis.MetadataTypeName.FromFullName(str, True, -1)
			Return Me.ContainingModule.LookupTopLevelMetadataType(metadataTypeName)
		End Function

		Private Function GetInternalXmlHelperValueExtensionProperty() As Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol
			Dim propertySymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol
			Dim members As ImmutableArray(Of Symbol) = Me.GetInternalXmlHelperType().GetMembers("Value")
			Dim enumerator As ImmutableArray(Of Symbol).Enumerator = members.GetEnumerator()
			While True
				If (enumerator.MoveNext()) Then
					Dim current As Symbol = enumerator.Current
					If (current.IsShared AndAlso current.Kind = SymbolKind.[Property]) Then
						Dim propertySymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol = DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol)
						If (propertySymbol1.Type.SpecialType = SpecialType.System_String AndAlso propertySymbol1.RefCustomModifiers.Length <= 0 AndAlso propertySymbol1.TypeCustomModifiers.Length <= 0 AndAlso propertySymbol1.ParameterCount = 1) Then
							Dim item As ParameterSymbol = propertySymbol1.Parameters(0)
							If (item.CustomModifiers.Length <= 0 AndAlso item.RefCustomModifiers.Length <= 0) Then
								Dim type As TypeSymbol = item.Type
								If (type.OriginalDefinition.SpecialType = SpecialType.System_Collections_Generic_IEnumerable_T AndAlso TypeSymbol.Equals(DirectCast(type, NamedTypeSymbol).TypeArgumentsNoUseSiteDiagnostics(0), Me.Compilation.GetWellKnownType(WellKnownType.System_Xml_Linq_XElement), TypeCompareKind.ConsiderEverything)) Then
									propertySymbol = propertySymbol1
									Exit While
								End If
							End If
						End If
					End If
				Else
					propertySymbol = Nothing
					Exit While
				End If
			End While
			Return propertySymbol
		End Function

		Private Function GetLocalForDeclaration(ByVal identifier As Microsoft.CodeAnalysis.SyntaxToken) As LocalSymbol
			Dim blockBaseBinder As Microsoft.CodeAnalysis.VisualBasic.BlockBaseBinder
			Dim containingBinder As Binder = Me
			While True
				blockBaseBinder = TryCast(containingBinder, Microsoft.CodeAnalysis.VisualBasic.BlockBaseBinder)
				If (blockBaseBinder IsNot Nothing) Then
					Exit While
				End If
				containingBinder = containingBinder.ContainingBinder
			End While
			Dim enumerator As ImmutableArray(Of LocalSymbol).Enumerator = blockBaseBinder.Locals.GetEnumerator()
			While enumerator.MoveNext()
				Dim current As LocalSymbol = enumerator.Current
				If (current.IdentifierToken <> identifier) Then
					Continue While
				End If
				Return current
			End While
			Throw ExceptionUtilities.Unreachable
		End Function

		Public Overridable Function GetLocalForFunctionValue() As LocalSymbol
			Return Me.m_containingBinder.GetLocalForFunctionValue()
		End Function

		Private Function GetLocalSymbolType(ByVal localSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol, ByVal node As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, Optional ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Nothing) As TypeSymbol
			Dim type As TypeSymbol
			Dim useBeforeDeclarationResultType As TypeSymbol = Nothing
			If (node IsNot Nothing AndAlso node.SpanStart < localSymbol.IdentifierToken.SpanStart) Then
				Dim identifierLocation As Microsoft.CodeAnalysis.Location = localSymbol.IdentifierLocation
				Dim location As Microsoft.CodeAnalysis.Location = node.GetLocation()
				If (Not localSymbol.IsImplicitlyDeclared AndAlso identifierLocation.IsInSource AndAlso location IsNot Nothing AndAlso location.IsInSource AndAlso identifierLocation.SourceTree = location.SourceTree) Then
					useBeforeDeclarationResultType = Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol.UseBeforeDeclarationResultType
					If (diagnostics IsNot Nothing) Then
						Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_UseOfLocalBeforeDeclaration1, New [Object]() { localSymbol })
					End If
				End If
			ElseIf (Me.IsBindingImplicitlyTypedLocal(localSymbol)) Then
				If (localSymbol.IsConst AndAlso localSymbol.ConstHasType) Then
					type = localSymbol.Type
					Return type
				End If
				If (diagnostics IsNot Nothing) Then
					If (Not localSymbol.IsConst) Then
						Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_CircularInference1, New [Object]() { localSymbol })
					Else
						Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_CircularEvaluation1, New [Object]() { localSymbol })
					End If
				End If
				useBeforeDeclarationResultType = ErrorTypeSymbol.UnknownResultType
			End If
			If (useBeforeDeclarationResultType Is Nothing) Then
				useBeforeDeclarationResultType = localSymbol.Type
			End If
			type = useBeforeDeclarationResultType
			Return type
		End Function

		Public Function GetLocation(ByVal span As TextSpan) As Location
			Return Me.SyntaxTree.GetLocation(span)
		End Function

		Public Shared Function GetLocationForOverloadResolutionDiagnostic(ByVal node As SyntaxNode, Optional ByVal groupOpt As BoundMethodOrPropertyGroup = Nothing) As Microsoft.CodeAnalysis.Location
			Dim location As Microsoft.CodeAnalysis.Location
			Dim syntax As SyntaxNode
			If (groupOpt Is Nothing) Then
				If (node.IsKind(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.InvocationExpression)) Then
					GoTo Label1
				End If
				location = node.GetLocation()
				Return location
			ElseIf (node.SyntaxTree <> groupOpt.Syntax.SyntaxTree OrElse Not node.Span.Contains(groupOpt.Syntax.Span)) Then
				location = node.GetLocation()
				Return location
			Else
				syntax = groupOpt.Syntax
				If (syntax <> node OrElse groupOpt.ReceiverOpt IsNot Nothing AndAlso groupOpt.ReceiverOpt.Syntax <> syntax) Then
					GoTo Label2
				End If
				location = syntax.GetLocation()
				Return location
			End If
		Label2:
			Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = syntax.Kind()
			If (syntaxKind <= Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleMemberAccessExpression) Then
				If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.HandlesClauseItem) Then
					location = DirectCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax).EventMember.GetLocation()
				Else
					If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleMemberAccessExpression) Then
						location = syntax.GetLocation()
						Return location
					End If
					location = If(syntax.Parent Is Nothing OrElse Not syntax.Parent.IsKind(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AddressOfExpression), DirectCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax).Name.GetLocation(), syntax.GetLocation())
				End If
			ElseIf (CUShort(syntaxKind) - CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlElementAccessExpression) <= CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement)) Then
				location = DirectCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax).Name.GetLocation()
			Else
				If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.QualifiedName) Then
					location = syntax.GetLocation()
					Return location
				End If
				location = DirectCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax).Right.GetLocation()
			End If
			Return location
		Label1:
			Dim expression As SyntaxNode = DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax).Expression
			If (expression Is Nothing) Then
				expression = node
			End If
			syntax = expression
			GoTo Label2
		End Function

		Private Function GetMemberIfMatchesRequirements(ByVal name As String, ByVal container As TypeSymbol, ByVal symbolChecker As Func(Of Symbol, Boolean), ByVal result As LookupResult, ByVal syntax As SyntaxNode, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
			Dim flag As Boolean
			result.Clear()
			Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
			Me.LookupMember(result, container, name, 0, LookupOptions.AllMethodsOfAnyArity, newCompoundUseSiteInfo)
			diagnostics.Add(syntax, newCompoundUseSiteInfo)
			newCompoundUseSiteInfo = New CompoundUseSiteInfo(Of AssemblySymbol)(newCompoundUseSiteInfo)
			If (result.IsGood) Then
				Dim enumerator As ArrayBuilder(Of Symbol).Enumerator = result.Symbols.GetEnumerator()
				While enumerator.MoveNext()
					If (Not symbolChecker(enumerator.Current)) Then
						Continue While
					End If
					flag = True
					Return flag
				End While
				If (result.Symbols(0).Kind = SymbolKind.Method AndAlso Not DirectCast(result.Symbols(0), MethodSymbol).IsReducedExtensionMethod) Then
					result.Clear()
					Me.LookupExtensionMethods(result, container, name, 0, LookupOptions.AllMethodsOfAnyArity, newCompoundUseSiteInfo)
					diagnostics.Add(syntax, newCompoundUseSiteInfo)
					If (result.IsGood) Then
						Dim enumerator1 As ArrayBuilder(Of Symbol).Enumerator = result.Symbols.GetEnumerator()
						While enumerator1.MoveNext()
							If (Not symbolChecker(enumerator1.Current)) Then
								Continue While
							End If
							flag = True
							Return flag
						End While
					End If
				End If
			ElseIf (result.IsAmbiguous) Then
				diagnostics.Clear()
				diagnostics.Add(New VBDiagnostic(result.Diagnostic, syntax.GetLocation(), False))
			End If
			result.Clear()
			flag = False
			Return flag
		End Function

		Private Shared Function GetNamedArgumentIdentifier(ByVal argumentExpression As SyntaxNode) As Microsoft.CodeAnalysis.SyntaxToken
			Dim syntaxToken As Microsoft.CodeAnalysis.SyntaxToken
			Dim parent As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax = TryCast(argumentExpression.Parent, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax)
			syntaxToken = If(parent Is Nothing OrElse Not parent.IsNamed, argumentExpression.GetFirstToken(False, False, False, False), parent.NameColonEquals.Name.Identifier)
			Return syntaxToken
		End Function

		Public Function GetNewCompoundUseSiteInfo(ByVal futureDestination As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As CompoundUseSiteInfo(Of AssemblySymbol)
			Return New CompoundUseSiteInfo(Of AssemblySymbol)(futureDestination, Me.Compilation.Assembly)
		End Function

		Private Shared Function GetNullableTypeForBinaryOperator(ByVal leftType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, ByVal rightType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, ByVal ofType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol) As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim typeSymbolArray As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol()
			Dim originalDefinition As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol
			Dim typeSymbolArray1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol()
			Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol
			Dim flag As Boolean = leftType.IsNullableType()
			Dim flag1 As Boolean = rightType.IsNullableType()
			Dim specialType As Microsoft.CodeAnalysis.SpecialType = ofType.SpecialType
			If (specialType <> Microsoft.CodeAnalysis.SpecialType.None) Then
				If (Not flag OrElse leftType.GetNullableUnderlyingType().SpecialType <> specialType) Then
					If (Not flag1 OrElse rightType.GetNullableUnderlyingType().SpecialType <> specialType) Then
						If (Not flag) Then
							originalDefinition = DirectCast(rightType.OriginalDefinition, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)
							typeSymbolArray = New Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol() { ofType }
							typeSymbol = originalDefinition.Construct(typeSymbolArray)
						Else
							namedTypeSymbol = DirectCast(leftType.OriginalDefinition, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)
							typeSymbolArray1 = New Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol() { ofType }
							typeSymbol = namedTypeSymbol.Construct(typeSymbolArray1)
						End If
						Return typeSymbol
					End If
					typeSymbol = rightType
					Return typeSymbol
				Else
					typeSymbol = leftType
					Return typeSymbol
				End If
			End If
			If (Not flag) Then
				originalDefinition = DirectCast(rightType.OriginalDefinition, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)
				typeSymbolArray = New Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol() { ofType }
				typeSymbol = originalDefinition.Construct(typeSymbolArray)
			Else
				namedTypeSymbol = DirectCast(leftType.OriginalDefinition, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)
				typeSymbolArray1 = New Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol() { ofType }
				typeSymbol = namedTypeSymbol.Construct(typeSymbolArray1)
			End If
			Return typeSymbol
		End Function

		Private Shared Function GetQueryLambdaParameterName(ByVal rangeVariables As ImmutableArray(Of RangeVariableSymbol)) As String
			Dim str As String
			Dim length As Integer = rangeVariables.Length
			If (length = 0) Then
				str = "$VB$ItAnonymous"
			Else
				str = If(length = 1, rangeVariables(0).Name, "$VB$It")
			End If
			Return str
		End Function

		Private Shared Function GetQueryLambdaParameterNameLeft(ByVal rangeVariables As ImmutableArray(Of RangeVariableSymbol)) As String
			Dim str As String
			Dim length As Integer = rangeVariables.Length
			If (length = 0) Then
				str = "$VB$ItAnonymous"
			Else
				str = If(length = 1, rangeVariables(0).Name, "$VB$It1")
			End If
			Return str
		End Function

		Private Shared Function GetQueryLambdaParameterNameRight(ByVal rangeVariables As ImmutableArray(Of RangeVariableSymbol)) As String
			Dim str As String
			Dim length As Integer = rangeVariables.Length
			If (length = 0) Then
				Throw ExceptionUtilities.UnexpectedValue(rangeVariables.Length)
			End If
			str = If(length = 1, rangeVariables(0).Name, "$VB$It2")
			Return str
		End Function

		Private Shared Function GetQueryLambdaParameterSyntax(ByVal syntaxNode As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal rangeVariables As ImmutableArray(Of RangeVariableSymbol)) As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode
			Dim visualBasicSyntaxNode As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode
			visualBasicSyntaxNode = If(rangeVariables.Length <> 1, syntaxNode, rangeVariables(0).Syntax)
			Return visualBasicSyntaxNode
		End Function

		Private Shared Function GetQueryOperatorNameSpan(ByRef left As Microsoft.CodeAnalysis.SyntaxToken, ByRef right As Microsoft.CodeAnalysis.SyntaxToken) As Microsoft.CodeAnalysis.Text.TextSpan
			Dim span As Microsoft.CodeAnalysis.Text.TextSpan = left.Span
			If (right.ValueText.Length > 0) Then
				Dim start As Integer = span.Start
				Dim textSpan As Microsoft.CodeAnalysis.Text.TextSpan = right.Span
				span = Microsoft.CodeAnalysis.Text.TextSpan.FromBounds(start, textSpan.[End])
			End If
			Return span
		End Function

		Public Overridable Function GetReturnLabel() As LabelSymbol
			Return Me.m_containingBinder.GetReturnLabel()
		End Function

		Private Shared Function GetSetOfTheBestCandidates(ByRef results As OverloadResolution.OverloadResolutionResult, ByVal bestCandidates As ArrayBuilder(Of OverloadResolution.CandidateAnalysisResult), ByRef bestSymbols As ImmutableArray(Of Symbol)) As TypeSymbol
			Dim numArray(14) As Int32
			numArray(0) = 1
			numArray(7) = 2
			numArray(8) = 2
			numArray(6) = 3
			numArray(5) = 4
			numArray(4) = 5
			numArray(3) = 6
			numArray(2) = 7
			numArray(1) = 8
			Dim enumerator As ImmutableArray(Of OverloadResolution.CandidateAnalysisResult).Enumerator = results.Candidates.GetEnumerator()
			While enumerator.MoveNext()
				Dim current As OverloadResolution.CandidateAnalysisResult = enumerator.Current
				Dim num As Integer = numArray(CInt(current.State))
				If (num = 0) Then
					Continue While
				End If
				If (bestCandidates.Count <> 0) Then
					Dim num1 As Integer = numArray(CInt(bestCandidates(0).State))
					If (num <> num1) Then
						If (num >= num1) Then
							Continue While
						End If
						bestCandidates.Clear()
						bestCandidates.Add(current)
					Else
						bestCandidates.Add(current)
					End If
				Else
					bestCandidates.Add(current)
				End If
			End While
			Dim instance As ArrayBuilder(Of Symbol) = ArrayBuilder(Of Symbol).GetInstance(bestCandidates.Count)
			Dim unknownResultType As TypeSymbol = Nothing
			If (bestCandidates.Count <> 1) Then
				Dim count As Integer = bestCandidates.Count - 1
				For i As Integer = 0 To count
					If (i = 0 OrElse Not instance(instance.Count - 1).Equals(bestCandidates(i).Candidate.UnderlyingSymbol)) Then
						instance.Add(bestCandidates(i).Candidate.UnderlyingSymbol)
						Dim returnType As TypeSymbol = bestCandidates(i).Candidate.ReturnType
						If (unknownResultType Is Nothing) Then
							unknownResultType = returnType
						ElseIf (unknownResultType <> ErrorTypeSymbol.UnknownResultType AndAlso Not unknownResultType.IsSameTypeIgnoringAll(returnType)) Then
							unknownResultType = ErrorTypeSymbol.UnknownResultType
						End If
					End If
				Next

			Else
				Dim underlyingSymbol As Symbol = bestCandidates(0).Candidate.UnderlyingSymbol
				instance.Add(underlyingSymbol)
				unknownResultType = bestCandidates(0).Candidate.ReturnType
				If (underlyingSymbol.Kind = SymbolKind.Method) Then
					Dim methodSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol = DirectCast(underlyingSymbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)
					If (methodSymbol.IsGenericMethod AndAlso unknownResultType.ReferencesMethodsTypeParameter(methodSymbol)) Then
						Dim state As Integer = CInt(bestCandidates(0).State)
						If (state - 1 <= 1 OrElse state - 4 <= 2) Then
							unknownResultType = Nothing
						End If
					End If
				End If
			End If
			bestSymbols = instance.ToImmutableAndFree()
			Dim obj As Object = unknownResultType
			If (obj Is Nothing) Then
				obj = ErrorTypeSymbol.UnknownResultType
			End If
			Return obj
		End Function

		Public Function GetSpecialType(ByVal typeId As SpecialType, ByVal node As SyntaxNodeOrToken, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As NamedTypeSymbol
			Dim flag As Boolean = False
			Return Binder.GetSpecialType(Me.Compilation, typeId, node, diagBag, flag, False)
		End Function

		Public Shared Function GetSpecialType(ByVal compilation As VisualBasicCompilation, ByVal typeId As SpecialType, ByVal node As SyntaxNodeOrToken, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As NamedTypeSymbol
			Dim flag As Boolean = False
			Return Binder.GetSpecialType(compilation, typeId, node, diagBag, flag, False)
		End Function

		Public Function GetSpecialType(ByVal typeId As SpecialType, ByVal node As SyntaxNodeOrToken, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByRef reportedAnError As Boolean, ByVal suppressUseSiteError As Boolean) As NamedTypeSymbol
			Return Binder.GetSpecialType(Me.Compilation, typeId, node, diagBag, reportedAnError, suppressUseSiteError)
		End Function

		Public Shared Function GetSpecialType(ByVal compilation As VisualBasicCompilation, ByVal typeId As Microsoft.CodeAnalysis.SpecialType, ByVal node As SyntaxNodeOrToken, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByRef reportedAnError As Boolean, ByVal suppressUseSiteError As Boolean) As NamedTypeSymbol
			Dim specialType As NamedTypeSymbol = compilation.GetSpecialType(typeId)
			If (diagBag IsNot Nothing AndAlso Binder.ReportUseSite(diagBag, node, Binder.GetUseSiteInfoForSpecialType(specialType, suppressUseSiteError))) Then
				reportedAnError = True
			End If
			Return specialType
		End Function

		Private Function GetSpecialTypeForBinaryOperator(ByVal node As SyntaxNode, ByVal leftType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, ByVal rightType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, ByVal specialType As Microsoft.CodeAnalysis.SpecialType, ByVal makeNullable As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim nullableUnderlyingTypeOrSelf As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = leftType.GetNullableUnderlyingTypeOrSelf()
			Dim specialType1 As Microsoft.CodeAnalysis.SpecialType = nullableUnderlyingTypeOrSelf.SpecialType
			Dim nullableUnderlyingTypeOrSelf1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = rightType.GetNullableUnderlyingTypeOrSelf()
			Dim specialType2 As Microsoft.CodeAnalysis.SpecialType = nullableUnderlyingTypeOrSelf1.SpecialType
			If (specialType1 = specialType) Then
				If (Not makeNullable) Then
					typeSymbol = nullableUnderlyingTypeOrSelf
				ElseIf (leftType.IsNullableType()) Then
					typeSymbol = leftType
				ElseIf (specialType2 <> specialType) Then
					typeSymbol = DirectCast(rightType.OriginalDefinition, NamedTypeSymbol).Construct(New Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol() { leftType })
				Else
					typeSymbol = rightType
				End If
			ElseIf (specialType2 <> specialType) Then
				typeSymbol = Me.GetSpecialType(specialType, node, diagnostics)
				If (makeNullable) Then
					typeSymbol = If(Not leftType.IsNullableType(), DirectCast(rightType.OriginalDefinition, NamedTypeSymbol).Construct(New Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol() { typeSymbol }), DirectCast(leftType.OriginalDefinition, NamedTypeSymbol).Construct(New Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol() { typeSymbol }))
				End If
			ElseIf (Not makeNullable) Then
				typeSymbol = nullableUnderlyingTypeOrSelf1
			ElseIf (Not rightType.IsNullableType()) Then
				typeSymbol = DirectCast(leftType.OriginalDefinition, NamedTypeSymbol).Construct(New Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol() { nullableUnderlyingTypeOrSelf1 })
			Else
				typeSymbol = rightType
			End If
			Return typeSymbol
		End Function

		Public Shared Function GetSpecialTypeForTypeCharacter(ByVal typeChar As TypeCharacter, ByRef typeCharacterString As String) As Microsoft.CodeAnalysis.SpecialType
			Dim specialType As Microsoft.CodeAnalysis.SpecialType = Microsoft.CodeAnalysis.SpecialType.None
			Select Case typeChar
				Case TypeCharacter.None
					typeCharacterString = Nothing
					Exit Select
				Case TypeCharacter.[Integer]
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Int32
					typeCharacterString = "%"
					Exit Select
				Case TypeCharacter.[Long]
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Int64
					typeCharacterString = "&"
					Exit Select
				Case TypeCharacter.[Decimal]
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Decimal
					typeCharacterString = "@"
					Exit Select
				Case TypeCharacter.[Single]
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Single
					typeCharacterString = "!"
					Exit Select
				Case TypeCharacter.[Double]
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Double
					typeCharacterString = "#"
					Exit Select
				Case TypeCharacter.[String]
					specialType = Microsoft.CodeAnalysis.SpecialType.System_String
					typeCharacterString = "$"
					Exit Select
				Case TypeCharacter.ShortLiteral
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Int16
					typeCharacterString = "S"
					Exit Select
				Case TypeCharacter.UShortLiteral
					specialType = Microsoft.CodeAnalysis.SpecialType.System_UInt16
					typeCharacterString = "US"
					Exit Select
				Case TypeCharacter.IntegerLiteral
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Int32
					typeCharacterString = "I"
					Exit Select
				Case TypeCharacter.UIntegerLiteral
					specialType = Microsoft.CodeAnalysis.SpecialType.System_UInt32
					typeCharacterString = "UI"
					Exit Select
				Case TypeCharacter.LongLiteral
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Int64
					typeCharacterString = "L"
					Exit Select
				Case TypeCharacter.ULongLiteral
					specialType = Microsoft.CodeAnalysis.SpecialType.System_UInt64
					typeCharacterString = "UL"
					Exit Select
				Case TypeCharacter.SingleLiteral
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Single
					typeCharacterString = "F"
					Exit Select
				Case TypeCharacter.DoubleLiteral
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Double
					typeCharacterString = "R"
					Exit Select
				Case TypeCharacter.DecimalLiteral
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Decimal
					typeCharacterString = "D"
					Exit Select
				Case Else
					Throw ExceptionUtilities.UnexpectedValue(typeChar)
			End Select
			Return specialType
		End Function

		Friend Function GetSpecialTypeMember(ByVal member As SpecialMember, ByVal syntax As SyntaxNode, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Symbol
			Return Binder.GetSpecialTypeMember(Me.ContainingMember.ContainingAssembly, member, syntax, diagnostics)
		End Function

		Friend Shared Function GetSpecialTypeMember(ByVal assembly As AssemblySymbol, ByVal member As SpecialMember, ByVal syntax As SyntaxNode, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Symbol
			Dim useSiteInfo As UseSiteInfo(Of AssemblySymbol) = New UseSiteInfo(Of AssemblySymbol)()
			Dim specialTypeMember As Symbol = Binder.GetSpecialTypeMember(assembly, member, useSiteInfo)
			Binder.ReportUseSite(diagnostics, syntax, useSiteInfo)
			Return specialTypeMember
		End Function

		Friend Shared Function GetSpecialTypeMember(ByVal assembly As AssemblySymbol, ByVal member As SpecialMember, <Out> ByRef useSiteInfo As UseSiteInfo(Of AssemblySymbol)) As Symbol
			Dim specialTypeMember As Symbol = assembly.GetSpecialTypeMember(member)
			If (specialTypeMember IsNot Nothing) Then
				useSiteInfo = Binder.GetUseSiteInfoForMemberAndContainingType(specialTypeMember)
			Else
				Dim descriptor As MemberDescriptor = SpecialMembers.GetDescriptor(member)
				useSiteInfo = New UseSiteInfo(Of AssemblySymbol)(ErrorFactory.ErrorInfo(ERRID.ERR_MissingRuntimeHelper, New [Object]() { [String].Concat(descriptor.DeclaringTypeMetadataName, ".", descriptor.Name) }))
			End If
			Return specialTypeMember
		End Function

		Public Overridable Function GetSyntaxReference(ByVal node As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode) As SyntaxReference
			Return Me.m_containingBinder.GetSyntaxReference(node)
		End Function

		Private Function GetTupleFieldType(ByVal expression As BoundExpression, ByVal errorSyntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByRef hasNaturalType As Boolean) As TypeSymbol
			Dim type As TypeSymbol = expression.Type
			If (type Is Nothing) Then
				hasNaturalType = False
				If (Not expression.IsNothingLiteral()) Then
					expression = expression.GetMostEnclosedParenthesizedExpression()
				End If
				Dim kind As BoundKind = expression.Kind
				If (kind = BoundKind.TupleLiteral) Then
					type = DirectCast(expression, BoundTupleLiteral).InferredType
				ElseIf (kind = BoundKind.ArrayLiteral) Then
					type = DirectCast(expression, BoundArrayLiteral).InferredType
				ElseIf (kind = BoundKind.UnboundLambda) Then
					type = DirectCast(expression, UnboundLambda).InferredAnonymousDelegate.Key
				ElseIf (expression.IsNothingLiteral()) Then
					type = Me.GetSpecialType(SpecialType.System_Object, expression.Syntax, diagnostics)
				End If
			End If
			Return type
		End Function

		Private Shared Function GetTypeNotExpressionErrorId(ByVal type As TypeSymbol) As Microsoft.CodeAnalysis.VisualBasic.ERRID
			Dim eRRID As Microsoft.CodeAnalysis.VisualBasic.ERRID
			Dim typeKind As Microsoft.CodeAnalysis.TypeKind = type.TypeKind
			If (typeKind <= Microsoft.CodeAnalysis.TypeKind.[Enum]) Then
				If (typeKind = Microsoft.CodeAnalysis.TypeKind.[Class]) Then
					eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_ClassNotExpression1
				Else
					If (typeKind <> Microsoft.CodeAnalysis.TypeKind.[Enum]) Then
						eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_TypeNotExpression1
						Return eRRID
					End If
					eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_EnumNotExpression1
				End If
			ElseIf (typeKind = Microsoft.CodeAnalysis.TypeKind.[Interface]) Then
				eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_InterfaceNotExpression1
			Else
				If (typeKind <> Microsoft.CodeAnalysis.TypeKind.Struct) Then
					eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_TypeNotExpression1
					Return eRRID
				End If
				eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_StructureNotExpression1
			End If
			Return eRRID
		End Function

		Friend Shared Function GetUseSiteInfoForMemberAndContainingType(ByVal member As Symbol) As UseSiteInfo(Of AssemblySymbol)
			Dim useSiteInfo As UseSiteInfo(Of AssemblySymbol) = member.GetUseSiteInfo()
			If (useSiteInfo.DiagnosticInfo Is Nothing) Then
				Symbol.MergeUseSiteInfo(useSiteInfo, member.ContainingType.GetUseSiteInfo(), 0)
			End If
			Return useSiteInfo
		End Function

		Friend Shared Function GetUseSiteInfoForSpecialType(ByVal type As TypeSymbol, Optional ByVal suppressUseSiteInfo As Boolean = False) As UseSiteInfo(Of AssemblySymbol)
			Dim useSiteInfo As UseSiteInfo(Of AssemblySymbol) = New UseSiteInfo(Of AssemblySymbol)()
			If (type.TypeKind = Microsoft.CodeAnalysis.TypeKind.[Error] AndAlso TypeOf type Is MissingMetadataTypeSymbol.TopLevel) Then
				Dim topLevel As MissingMetadataTypeSymbol.TopLevel = DirectCast(type, MissingMetadataTypeSymbol.TopLevel)
				useSiteInfo = New UseSiteInfo(Of AssemblySymbol)(ErrorFactory.ErrorInfo(ERRID.ERR_UndefinedType1, New [Object]() { MetadataHelpers.BuildQualifiedName(topLevel.NamespaceName, topLevel.Name) }))
			ElseIf (Not suppressUseSiteInfo) Then
				useSiteInfo = type.GetUseSiteInfo()
			End If
			Return useSiteInfo
		End Function

		Friend Shared Function GetUseSiteInfoForWellKnownType(ByVal type As TypeSymbol) As UseSiteInfo(Of AssemblySymbol)
			Return type.GetUseSiteInfo()
		End Function

		Friend Shared Function GetUseSiteInfoForWellKnownTypeMember(ByVal memberSymbol As Symbol, ByVal member As WellKnownMember, ByVal embedVBRuntimeUsed As Boolean) As UseSiteInfo(Of AssemblySymbol)
			Dim useSiteInfoForMemberAndContainingType As UseSiteInfo(Of AssemblySymbol)
			If (memberSymbol IsNot Nothing) Then
				useSiteInfoForMemberAndContainingType = Binder.GetUseSiteInfoForMemberAndContainingType(memberSymbol)
			Else
				Dim descriptor As MemberDescriptor = WellKnownMembers.GetDescriptor(member)
				useSiteInfoForMemberAndContainingType = New UseSiteInfo(Of AssemblySymbol)(MissingRuntimeMemberDiagnosticHelper.GetDiagnosticForMissingRuntimeHelper(descriptor.DeclaringTypeMetadataName, descriptor.Name, embedVBRuntimeUsed))
			End If
			Return useSiteInfoForMemberAndContainingType
		End Function

		Private Function GetUsingBlockLocals(ByVal currentBinder As Binder) As ImmutableArray(Of LocalSymbol)
			Dim empty As ImmutableArray(Of LocalSymbol)
			While True
				Dim usingBlockBinder As Microsoft.CodeAnalysis.VisualBasic.UsingBlockBinder = TryCast(currentBinder, Microsoft.CodeAnalysis.VisualBasic.UsingBlockBinder)
				If (usingBlockBinder Is Nothing) Then
					currentBinder = currentBinder.ContainingBinder
					If (currentBinder Is Nothing) Then
						empty = ImmutableArray(Of LocalSymbol).Empty
						Exit While
					End If
				Else
					empty = usingBlockBinder.Locals
					Exit While
				End If
			End While
			Return empty
		End Function

		Friend Function GetWellKnownType(ByVal type As WellKnownType, ByVal syntax As SyntaxNode, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As NamedTypeSymbol
			Return Binder.GetWellKnownType(Me.Compilation, type, syntax, diagBag)
		End Function

		Friend Shared Function GetWellKnownType(ByVal compilation As VisualBasicCompilation, ByVal type As Microsoft.CodeAnalysis.WellKnownType, ByVal syntax As SyntaxNode, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As NamedTypeSymbol
			Dim wellKnownType As NamedTypeSymbol = compilation.GetWellKnownType(type)
			Dim useSiteInfoForWellKnownType As UseSiteInfo(Of AssemblySymbol) = Binder.GetUseSiteInfoForWellKnownType(wellKnownType)
			Binder.ReportUseSite(diagBag, syntax, useSiteInfoForWellKnownType)
			Return wellKnownType
		End Function

		Friend Function GetWellKnownTypeMember(ByVal member As WellKnownMember, ByVal syntax As SyntaxNode, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Symbol
			Return Binder.GetWellKnownTypeMember(Me.Compilation, member, syntax, diagBag)
		End Function

		Friend Shared Function GetWellKnownTypeMember(ByVal compilation As VisualBasicCompilation, ByVal member As WellKnownMember, ByVal syntax As SyntaxNode, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Symbol
			Dim useSiteInfo As UseSiteInfo(Of AssemblySymbol) = New UseSiteInfo(Of AssemblySymbol)()
			Dim wellKnownTypeMember As Symbol = Binder.GetWellKnownTypeMember(compilation, member, useSiteInfo)
			Binder.ReportUseSite(diagBag, syntax, useSiteInfo)
			Return wellKnownTypeMember
		End Function

		Friend Shared Function GetWellKnownTypeMember(ByVal compilation As VisualBasicCompilation, ByVal member As WellKnownMember, <Out> ByRef useSiteInfo As UseSiteInfo(Of AssemblySymbol)) As Symbol
			Dim wellKnownTypeMember As Symbol = compilation.GetWellKnownTypeMember(member)
			useSiteInfo = Binder.GetUseSiteInfoForWellKnownTypeMember(wellKnownTypeMember, member, compilation.Options.EmbedVbCoreRuntime)
			Return wellKnownTypeMember
		End Function

		Friend Overridable Function GetWithStatementPlaceholderSubstitute(ByVal placeholder As BoundValuePlaceholderBase) As BoundExpression
			Return Me.m_containingBinder.GetWithStatementPlaceholderSubstitute(placeholder)
		End Function

		Private Function GetXmlMethodOrPropertyGroup(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal type As NamedTypeSymbol, ByVal memberName As String, ByVal receiverOpt As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundMethodOrPropertyGroup
			Dim boundMethodOrPropertyGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodOrPropertyGroup
			If (Not type.IsErrorType()) Then
				Dim boundMethodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodOrPropertyGroup = Nothing
				Dim instance As LookupResult = LookupResult.GetInstance()
				Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
				Me.LookupMember(instance, type, memberName, 0, LookupOptions.NoBaseClassLookup Or LookupOptions.AllMethodsOfAnyArity Or LookupOptions.IgnoreExtensionMethods, newCompoundUseSiteInfo)
				diagnostics.Add(syntax, newCompoundUseSiteInfo)
				If (instance.IsGood) Then
					Dim item As Symbol = instance.Symbols(0)
					Dim kind As SymbolKind = instance.Symbols(0).Kind
					If (kind = SymbolKind.Method) Then
						boundMethodGroup = New Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup(syntax, Nothing, instance.Symbols.ToDowncastedImmutable(Of MethodSymbol)(), instance.Kind, receiverOpt, QualificationKind.QualifiedViaValue, False)
					ElseIf (kind = SymbolKind.[Property]) Then
						boundMethodGroup = New BoundPropertyGroup(syntax, instance.Symbols.ToDowncastedImmutable(Of PropertySymbol)(), instance.Kind, receiverOpt, QualificationKind.QualifiedViaValue, False)
					End If
				End If
				If (boundMethodGroup Is Nothing) Then
					Binder.ReportDiagnostic(diagnostics, syntax, If(instance.HasDiagnostic, instance.Diagnostic, ErrorFactory.ErrorInfo(ERRID.ERR_NameNotMember2, New [Object]() { memberName, type })))
				End If
				instance.Free()
				boundMethodOrPropertyGroup = boundMethodGroup
			Else
				boundMethodOrPropertyGroup = Nothing
			End If
			Return boundMethodOrPropertyGroup
		End Function

		Private Shared Function GetXmlName(ByVal token As Microsoft.CodeAnalysis.SyntaxToken) As String
			If (token.Kind() <> SyntaxKind.XmlNameToken) Then
				Throw ExceptionUtilities.UnexpectedValue(token.Kind())
			End If
			Return token.ValueText
		End Function

		Private Shared Function GetXmlnsXmlName(ByVal prefix As String) As Binder.XmlName
			Dim str As String = If([String].IsNullOrEmpty(prefix), "xmlns", prefix)
			Return New Binder.XmlName(str, If([String].IsNullOrEmpty(prefix), "", "http://www.w3.org/2000/xmlns/"))
		End Function

		Friend Shared Function GetXmlString(ByVal tokens As SyntaxTokenList) As String
			Dim empty As String
			Dim count As Integer = tokens.Count
			If (count = 0) Then
				empty = [String].Empty
			ElseIf (count <> 1) Then
				Dim instance As PooledStringBuilder = PooledStringBuilder.GetInstance()
				Dim builder As StringBuilder = instance.Builder
				Dim enumerator As SyntaxTokenList.Enumerator = tokens.GetEnumerator()
				While enumerator.MoveNext()
					Dim current As Microsoft.CodeAnalysis.SyntaxToken = enumerator.Current
					builder.Append(Binder.GetXmlString(current))
				End While
				Dim str As String = builder.ToString()
				instance.Free()
				empty = str
			Else
				empty = Binder.GetXmlString(tokens(0))
			End If
			Return empty
		End Function

		Private Shared Function GetXmlString(ByVal token As Microsoft.CodeAnalysis.SyntaxToken) As String
			If (CUShort(token.Kind()) - CUShort(SyntaxKind.XmlTextLiteralToken) > CUShort(SyntaxKind.List)) Then
				Throw ExceptionUtilities.UnexpectedValue(token.Kind())
			End If
			Return token.ValueText
		End Function

		Private Shared Function HasDefaultType(ByVal identifierSyntax As Microsoft.CodeAnalysis.SyntaxToken, ByVal asClauseOptSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax) As Boolean
			If (identifierSyntax.GetTypeCharacter() <> TypeCharacter.None) Then
				Return False
			End If
			Return asClauseOptSyntax Is Nothing
		End Function

		Private Shared Function HasDefaultType(ByVal identifierSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax, ByVal asClauseOptSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax) As Boolean
			Return Binder.HasDefaultType(identifierSyntax.Identifier, asClauseOptSyntax)
		End Function

		Friend Function InferAnonymousDelegateForLambda(ByVal source As UnboundLambda) As KeyValuePair(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol, ImmutableBindingDiagnostic(Of AssemblySymbol))
			Dim instance As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.GetInstance(True, source.WithDependencies)
			Dim targetSignature As UnboundLambda.TargetSignature = New UnboundLambda.TargetSignature(ImmutableArray(Of ParameterSymbol).Empty, Me.Compilation.GetSpecialType(SpecialType.System_Void), False)
			Dim boundLambdaParameterSymbols As ImmutableArray(Of BoundLambdaParameterSymbol) = Me.BuildBoundLambdaParameters(source, targetSignature, instance)
			Dim keyValuePair As KeyValuePair(Of TypeSymbol, ImmutableBindingDiagnostic(Of AssemblySymbol)) = source.InferReturnType(New UnboundLambda.TargetSignature(StaticCast(Of ParameterSymbol).From(Of BoundLambdaParameterSymbol)(boundLambdaParameterSymbols), targetSignature.ReturnType, targetSignature.ReturnsByRef))
			Dim key As TypeSymbol = keyValuePair.Key
			instance.AddRange(keyValuePair.Value, False)
			Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = Me.ConstructAnonymousDelegateSymbol(source, boundLambdaParameterSymbols, key, instance)
			Return New KeyValuePair(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol, ImmutableBindingDiagnostic(Of AssemblySymbol))(namedTypeSymbol, instance.ToReadOnlyAndFree())
		End Function

		Private Function InferControlVariableType(ByVal source As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
			Dim instance As LookupResult = LookupResult.GetInstance()
			Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
			Me.LookupMember(instance, source.Type, "Select", 0, LookupOptions.MustBeInstance Or LookupOptions.AllMethodsOfAnyArity Or LookupOptions.MethodsOnly, newCompoundUseSiteInfo)
			If (instance.IsGood) Then
				Dim flag As Boolean = False
				typeSymbol = Me.InferControlVariableType(instance.Symbols, flag)
				If (typeSymbol Is Nothing AndAlso Not flag AndAlso Not instance.Symbols(0).IsReducedExtensionMethod()) Then
					instance.Clear()
					Me.LookupExtensionMethods(instance, source.Type, "Select", 0, LookupOptions.MustBeInstance Or LookupOptions.AllMethodsOfAnyArity Or LookupOptions.MethodsOnly, newCompoundUseSiteInfo)
					If (instance.IsGood) Then
						typeSymbol = Me.InferControlVariableType(instance.Symbols, flag)
					End If
				End If
			End If
			diagnostics.Add(source, newCompoundUseSiteInfo)
			instance.Free()
			Return typeSymbol
		End Function

		Private Function InferControlVariableType(ByVal methods As ArrayBuilder(Of Symbol), <Out> ByRef failedDueToAnAmbiguity As Boolean) As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim typeSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
			failedDueToAnAmbiguity = False
			Dim enumerator As ArrayBuilder(Of Symbol).Enumerator = methods.GetEnumerator()
			While True
				If (enumerator.MoveNext()) Then
					Dim current As MethodSymbol = DirectCast(enumerator.Current, MethodSymbol)
					Dim typeSymbol2 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Me.InferControlVariableType(current)
					If (typeSymbol2 IsNot Nothing) Then
						If (typeSymbol2.ReferencesMethodsTypeParameter(current)) Then
							failedDueToAnAmbiguity = True
							typeSymbol = Nothing
							Exit While
						ElseIf (typeSymbol1 Is Nothing) Then
							typeSymbol1 = typeSymbol2
						ElseIf (Not typeSymbol1.IsSameTypeIgnoringAll(typeSymbol2)) Then
							failedDueToAnAmbiguity = True
							typeSymbol = Nothing
							Exit While
						End If
					End If
				Else
					typeSymbol = typeSymbol1
					Exit While
				End If
			End While
			Return typeSymbol
		End Function

		Private Function InferControlVariableType(ByVal method As MethodSymbol) As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim typeSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			If (method.IsSub) Then
				typeSymbol = Nothing
			ElseIf (method.ParameterCount = 1) Then
				Dim item As Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol = method.Parameters(0)
				If (Not item.IsByRef) Then
					Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = item.Type.DelegateOrExpressionDelegate(Me)
					If (namedTypeSymbol IsNot Nothing) Then
						Dim delegateInvokeMethod As MethodSymbol = namedTypeSymbol.DelegateInvokeMethod
						If (delegateInvokeMethod Is Nothing OrElse delegateInvokeMethod.IsSub OrElse delegateInvokeMethod.ParameterCount <> 1) Then
							typeSymbol = Nothing
						Else
							Dim parameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol = delegateInvokeMethod.Parameters(0)
							If (parameterSymbol.IsOptional OrElse parameterSymbol.IsByRef OrElse parameterSymbol.IsParamArray) Then
								typeSymbol = Nothing
							Else
								Dim type As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = parameterSymbol.Type
								If (type.IsErrorType()) Then
									typeSymbol1 = Nothing
								Else
									typeSymbol1 = type
								End If
								typeSymbol = typeSymbol1
							End If
						End If
					Else
						typeSymbol = Nothing
					End If
				Else
					typeSymbol = Nothing
				End If
			Else
				typeSymbol = Nothing
			End If
			Return typeSymbol
		End Function

		Friend Function InferDominantTypeOfExpressions(ByVal syntax As SyntaxNode, ByVal Expressions As ArrayBuilder(Of BoundExpression), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByRef numCandidates As Integer, Optional ByRef errorReasons As InferenceErrorReasons = 0) As TypeSymbol
			' 
			' Current member / type: Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol Microsoft.CodeAnalysis.VisualBasic.Binder::InferDominantTypeOfExpressions(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1<Microsoft.CodeAnalysis.VisualBasic.BoundExpression>,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag,System.Int32&,Microsoft.CodeAnalysis.VisualBasic.InferenceErrorReasons&)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol InferDominantTypeOfExpressions(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder<Microsoft.CodeAnalysis.VisualBasic.BoundExpression>,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag,System.Int32&,Microsoft.CodeAnalysis.VisualBasic.InferenceErrorReasons&)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Function

		Friend Function InferForEachVariableType(ByVal symbol As LocalSymbol, ByVal collectionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax, <Out> ByRef collectionExpression As BoundExpression, <Out> ByRef currentType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, <Out> ByRef elementType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, <Out> ByRef isEnumerable As Boolean, <Out> ByRef boundGetEnumeratorCall As BoundExpression, <Out> ByRef boundEnumeratorPlaceholder As BoundLValuePlaceholder, <Out> ByRef boundMoveNextCall As BoundExpression, <Out> ByRef boundCurrentAccess As BoundExpression, <Out> ByRef collectionPlaceholder As BoundRValuePlaceholder, <Out> ByRef needToDispose As Boolean, <Out> ByRef isOrInheritsFromOrImplementsIDisposable As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			collectionExpression = Nothing
			currentType = Nothing
			elementType = Nothing
			isEnumerable = False
			boundGetEnumeratorCall = Nothing
			boundEnumeratorPlaceholder = Nothing
			boundMoveNextCall = Nothing
			boundCurrentAccess = Nothing
			collectionPlaceholder = Nothing
			needToDispose = False
			isOrInheritsFromOrImplementsIDisposable = False
			Dim identifierToken As Microsoft.CodeAnalysis.SyntaxToken = symbol.IdentifierToken
			Dim typeSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
			Dim typeSymbol2 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Me.DecodeIdentifierType(identifierToken, DirectCast(Nothing, Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax), Nothing, typeSymbol1, diagnostics)
			If (Binder.HasDefaultType(identifierToken, Nothing)) Then
				Dim localInProgressBinder As Microsoft.CodeAnalysis.VisualBasic.LocalInProgressBinder = New Microsoft.CodeAnalysis.VisualBasic.LocalInProgressBinder(Me, symbol)
				collectionExpression = localInProgressBinder.BindValue(collectionSyntax, diagnostics, False)
				If (Not collectionExpression.IsLValue AndAlso Not collectionExpression.IsNothingLiteral()) Then
					collectionExpression = Me.MakeRValue(collectionExpression, diagnostics)
				End If
				collectionExpression = Me.InterpretForEachStatementCollection(collectionExpression, currentType, elementType, isEnumerable, boundGetEnumeratorCall, boundEnumeratorPlaceholder, boundMoveNextCall, boundCurrentAccess, collectionPlaceholder, needToDispose, isOrInheritsFromOrImplementsIDisposable, diagnostics)
				typeSymbol = If(elementType Is Nothing, typeSymbol2, elementType)
			Else
				typeSymbol = typeSymbol2
			End If
			Return typeSymbol
		End Function

		Friend Function InferForFromToVariableType(ByVal symbol As LocalSymbol, ByVal fromValueSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax, ByVal toValueSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax, ByVal stepClauseSyntaxOpt As Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax, <Out> ByRef fromValueExpression As BoundExpression, <Out> ByRef toValueExpression As BoundExpression, <Out> ByRef stepValueExpression As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As TypeSymbol
			' 
			' Current member / type: Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol Microsoft.CodeAnalysis.VisualBasic.Binder::InferForFromToVariableType(Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.BoundExpression&,Microsoft.CodeAnalysis.VisualBasic.BoundExpression&,Microsoft.CodeAnalysis.VisualBasic.BoundExpression&,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol InferForFromToVariableType(Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax,Microsoft.CodeAnalysis.VisualBasic.BoundExpression&,Microsoft.CodeAnalysis.VisualBasic.BoundExpression&,Microsoft.CodeAnalysis.VisualBasic.BoundExpression&,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Function

		Friend Function InferFunctionLambdaReturnType(ByVal source As UnboundLambda, ByVal targetParameters As UnboundLambda.TargetSignature) As KeyValuePair(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, ImmutableBindingDiagnostic(Of AssemblySymbol))
			Dim keyValuePair As KeyValuePair(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, ImmutableBindingDiagnostic(Of AssemblySymbol))
			Dim wellKnownType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			If (source.Flags <> (SourceMemberFlags.Async Or SourceMemberFlags.Iterator)) Then
				Dim instance As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.GetInstance(True, source.WithDependencies)
				Dim boundLambdaParameterSymbols As ImmutableArray(Of BoundLambdaParameterSymbol) = Me.BuildBoundLambdaParameters(source, targetParameters, instance)
				Dim sourceLambdaSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceLambdaSymbol = New Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceLambdaSymbol(source.Syntax, source, boundLambdaParameterSymbols, LambdaSymbol.ReturnTypeIsBeingInferred, Me)
				Dim lambdaBodyBinder As Microsoft.CodeAnalysis.VisualBasic.LambdaBodyBinder = Nothing
				Dim boundBlock As Microsoft.CodeAnalysis.VisualBasic.BoundBlock = Me.BindLambdaBody(sourceLambdaSymbol, instance, lambdaBodyBinder)
				If (boundBlock.HasErrors OrElse instance.HasAnyErrors()) Then
					keyValuePair = New KeyValuePair(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, ImmutableBindingDiagnostic(Of AssemblySymbol))(LambdaSymbol.ReturnTypeIsUnknown, instance.ToReadOnlyAndFree())
				Else
					instance.Clear()
					Dim boundExpressions As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance()
					Binder.LambdaReturnStatementsVisitor.CollectReturnExpressions(boundBlock, boundExpressions, source.Flags = SourceMemberFlags.Iterator)
					If (boundExpressions.Count = 0 AndAlso source.Flags = SourceMemberFlags.Async) Then
						wellKnownType = Me.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType.System_Threading_Tasks_Task, source.Syntax, instance)
					ElseIf (boundExpressions.Count <> 0 OrElse source.Flags <> SourceMemberFlags.Iterator) Then
						If (Not source.IsSingleLine) Then
							Dim num As Integer = 0
							Dim inferenceErrorReason As InferenceErrorReasons = InferenceErrorReasons.Other
							wellKnownType = Me.InferDominantTypeOfExpressions(source.Syntax, boundExpressions, instance, num, inferenceErrorReason)
							Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
							If (wellKnownType Is Nothing) Then
								Binder.ReportDiagnostic(instance, Binder.LambdaHeaderErrorNode(source), ERRID.ERR_LambdaNoType)
								wellKnownType = LambdaSymbol.ReturnTypeIsUnknown
							ElseIf (wellKnownType.IsRestrictedTypeOrArrayType(typeSymbol)) Then
								Binder.ReportDiagnostic(instance, Binder.LambdaHeaderErrorNode(source), ERRID.ERR_RestrictedType1, New [Object]() { typeSymbol })
							ElseIf (num <> 1) Then
								If (Me.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.[On]) Then
									If (num <> 0) Then
										Binder.ReportDiagnostic(instance, Binder.LambdaHeaderErrorNode(source), ERRID.ERR_LambdaTooManyTypesObjectDisallowed)
									Else
										Binder.ReportDiagnostic(instance, Binder.LambdaHeaderErrorNode(source), ERRID.ERR_LambdaNoTypeObjectDisallowed)
									End If
								ElseIf (Me.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.Custom) Then
									If (num <> 0) Then
										Binder.ReportDiagnostic(instance, Binder.LambdaHeaderErrorNode(source), ERRID.WRN_ObjectAssumed1, New [Object]() { ErrorFactory.ErrorInfo(ERRID.WRN_LambdaTooManyTypesObjectAssumed) })
									Else
										Binder.ReportDiagnostic(instance, Binder.LambdaHeaderErrorNode(source), ERRID.WRN_ObjectAssumed1, New [Object]() { ErrorFactory.ErrorInfo(ERRID.WRN_LambdaNoTypeObjectAssumed) })
									End If
								End If
							End If
						Else
							Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
							If (boundExpressions.Count > 0) Then
								boundExpression = Me.MakeRValue(boundExpressions(0), instance)
							End If
							If (boundExpression Is Nothing OrElse boundExpression.HasErrors OrElse instance.HasAnyErrors()) Then
								wellKnownType = Me.GetSpecialType(SpecialType.System_Object, source.Syntax, instance)
							Else
								wellKnownType = boundExpression.Type
							End If
							instance.Clear()
							Dim typeSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
							If (wellKnownType.IsRestrictedTypeOrArrayType(typeSymbol1)) Then
								Binder.ReportDiagnostic(instance, Binder.LambdaHeaderErrorNode(source), ERRID.ERR_RestrictedType1, New [Object]() { typeSymbol1 })
							End If
						End If
						If (source.Flags = SourceMemberFlags.Async) Then
							wellKnownType = Me.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType.System_Threading_Tasks_Task_T, source.Syntax, instance).Construct(New Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol() { wellKnownType })
						ElseIf (source.Flags = SourceMemberFlags.Iterator) Then
							wellKnownType = Me.GetSpecialType(SpecialType.System_Collections_Generic_IEnumerable_T, source.Syntax, instance).Construct(New Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol() { wellKnownType })
						End If
					Else
						wellKnownType = Me.GetSpecialType(SpecialType.System_Collections_Generic_IEnumerable_T, source.Syntax, instance).Construct(New Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol() { Me.GetSpecialType(SpecialType.System_Object, source.Syntax, instance) })
					End If
					boundExpressions.Free()
					keyValuePair = New KeyValuePair(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, ImmutableBindingDiagnostic(Of AssemblySymbol))(wellKnownType, instance.ToReadOnlyAndFree())
				End If
			Else
				keyValuePair = New KeyValuePair(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, ImmutableBindingDiagnostic(Of AssemblySymbol))(LambdaSymbol.ReturnTypeIsUnknown, ImmutableBindingDiagnostic(Of AssemblySymbol).Empty)
			End If
			Return keyValuePair
		End Function

		Private Function InferGroupType(ByVal source As BoundQueryClauseBase, ByVal groupBy As Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax, ByVal itemsLambda As BoundQueryLambda, ByVal keysLambda As BoundQueryLambda, ByVal keysRangeVariables As ImmutableArray(Of RangeVariableSymbol), <Out> ByRef methodGroup As BoundMethodGroup, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As TypeSymbol
			Dim boundExpressionArray As BoundExpression()
			Dim unknownResultType As TypeSymbol = ErrorTypeSymbol.UnknownResultType
			If (Not source.Type.IsErrorType()) Then
				methodGroup = Me.LookupQueryOperator(groupBy, source, "GroupBy", Nothing, diagnostics)
				If (methodGroup Is Nothing) Then
					Binder.ReportDiagnostic(diagnostics, Location.Create(groupBy.SyntaxTree, Binder.GetGroupByOperatorNameSpan(groupBy)), ERRID.ERR_QueryOperatorNotFound, New [Object]() { "GroupBy" })
				ElseIf (Not Binder.ShouldSuppressDiagnostics(keysLambda) AndAlso (itemsLambda Is Nothing OrElse Not Binder.ShouldSuppressDiagnostics(itemsLambda))) Then
					Dim groupTypeInferenceLambda As Microsoft.CodeAnalysis.VisualBasic.GroupTypeInferenceLambda = New Microsoft.CodeAnalysis.VisualBasic.GroupTypeInferenceLambda(groupBy, Me, Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of ParameterSymbol)(New ParameterSymbol() { Me.CreateQueryLambdaParameterSymbol("$VB$It1", 0, keysLambda.Expression.Type, groupBy, keysRangeVariables), Binder.CreateQueryLambdaParameterSymbol("$VB$It2", 1, Nothing, groupBy) }), Me.Compilation)
					boundExpressionArray = If(itemsLambda IsNot Nothing, New BoundExpression() { keysLambda, itemsLambda, groupTypeInferenceLambda }, New BoundExpression() { keysLambda, groupTypeInferenceLambda })
					Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
					Dim overloadResolutionResult As OverloadResolution.OverloadResolutionResult = OverloadResolution.QueryOperatorInvocationOverloadResolution(methodGroup, Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of BoundExpression)(boundExpressionArray), Me, newCompoundUseSiteInfo, False)
					diagnostics.Add(groupBy, newCompoundUseSiteInfo)
					If (overloadResolutionResult.BestResult.HasValue) Then
						Dim parameters As ImmutableArray(Of ParameterSymbol) = DirectCast(overloadResolutionResult.BestResult.Value.Candidate.UnderlyingSymbol, MethodSymbol).Parameters
						parameters = parameters(CInt(boundExpressionArray.Length) - 1).Type.DelegateOrExpressionDelegate(Me).DelegateInvokeMethod.Parameters
						unknownResultType = parameters(1).Type
					ElseIf (Not source.HasErrors) Then
						Binder.ReportDiagnostic(diagnostics, Location.Create(groupBy.SyntaxTree, Binder.GetGroupByOperatorNameSpan(groupBy)), ERRID.ERR_QueryOperatorNotFound, New [Object]() { "GroupBy" })
					End If
				End If
			End If
			Return unknownResultType
		End Function

		Private Function InferGroupType(ByVal outer As BoundQueryClauseBase, ByVal inner As BoundQueryClauseBase, ByVal groupJoin As Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax, ByVal outerKeyLambda As BoundQueryLambda, ByVal innerKeyLambda As BoundQueryLambda, <Out> ByRef methodGroup As BoundMethodGroup, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As TypeSymbol
			Dim groupKeyword As Microsoft.CodeAnalysis.SyntaxToken
			Dim joinKeyword As Microsoft.CodeAnalysis.SyntaxToken
			Dim unknownResultType As TypeSymbol = ErrorTypeSymbol.UnknownResultType
			If (Not outer.Type.IsErrorType()) Then
				methodGroup = Me.LookupQueryOperator(groupJoin, outer, "GroupJoin", Nothing, diagnostics)
				If (methodGroup Is Nothing) Then
					Dim syntaxTree As Microsoft.CodeAnalysis.SyntaxTree = groupJoin.SyntaxTree
					groupKeyword = groupJoin.GroupKeyword
					joinKeyword = groupJoin.JoinKeyword
					Binder.ReportDiagnostic(diagnostics, Location.Create(syntaxTree, Binder.GetQueryOperatorNameSpan(groupKeyword, joinKeyword)), ERRID.ERR_QueryOperatorNotFound, New [Object]() { "GroupJoin" })
				ElseIf (Not Binder.ShouldSuppressDiagnostics(innerKeyLambda) AndAlso Not Binder.ShouldSuppressDiagnostics(outerKeyLambda) AndAlso Not inner.HasErrors AndAlso Not inner.Type.IsErrorType()) Then
					Dim groupTypeInferenceLambda As Microsoft.CodeAnalysis.VisualBasic.GroupTypeInferenceLambda = New Microsoft.CodeAnalysis.VisualBasic.GroupTypeInferenceLambda(groupJoin, Me, Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of ParameterSymbol)(New ParameterSymbol() { Me.CreateQueryLambdaParameterSymbol("$VB$It1", 0, outer.CompoundVariableType, groupJoin, outer.RangeVariables), Binder.CreateQueryLambdaParameterSymbol("$VB$It2", 1, Nothing, groupJoin) }), Me.Compilation)
					Dim boundExpressionArray() As BoundExpression = { inner, outerKeyLambda, innerKeyLambda, groupTypeInferenceLambda }
					Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
					Dim overloadResolutionResult As OverloadResolution.OverloadResolutionResult = OverloadResolution.QueryOperatorInvocationOverloadResolution(methodGroup, Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of BoundExpression)(boundExpressionArray), Me, newCompoundUseSiteInfo, False)
					diagnostics.Add(groupJoin, newCompoundUseSiteInfo)
					If (overloadResolutionResult.BestResult.HasValue) Then
						Dim parameters As ImmutableArray(Of ParameterSymbol) = DirectCast(overloadResolutionResult.BestResult.Value.Candidate.UnderlyingSymbol, MethodSymbol).Parameters
						parameters = parameters(CInt(boundExpressionArray.Length) - 1).Type.DelegateOrExpressionDelegate(Me).DelegateInvokeMethod.Parameters
						unknownResultType = parameters(1).Type
					ElseIf (Not outer.HasErrors) Then
						Dim syntaxTree1 As Microsoft.CodeAnalysis.SyntaxTree = groupJoin.SyntaxTree
						joinKeyword = groupJoin.GroupKeyword
						groupKeyword = groupJoin.JoinKeyword
						Binder.ReportDiagnostic(diagnostics, Location.Create(syntaxTree1, Binder.GetQueryOperatorNameSpan(joinKeyword, groupKeyword)), ERRID.ERR_QueryOperatorNotFound, New [Object]() { "GroupJoin" })
					End If
				End If
			End If
			Return unknownResultType
		End Function

		Private Shared Function InferTupleElementName(ByVal element As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax) As String
			Dim str As String
			Dim xmlNameSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax = Nothing
			Dim syntaxToken As Microsoft.CodeAnalysis.SyntaxToken = element.ExtractAnonymousTypeMemberName(xmlNameSyntax)
			If (syntaxToken.Kind() = SyntaxKind.IdentifierToken) Then
				Dim valueText As String = syntaxToken.ValueText
				If (TupleTypeSymbol.IsElementNameReserved(valueText) <> -1) Then
					str = Nothing
					Return str
				End If
				str = valueText
				Return str
			End If
			str = Nothing
			Return str
		End Function

		Private Function InferVariableType(ByVal defaultType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, ByVal name As Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax, ByVal valueSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax, ByVal valueType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, ByVal valueExpression As BoundExpression, ByVal getRequireTypeDiagnosticInfoFunc As Func(Of DiagnosticInfo), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
			Dim flag As Boolean = Binder.IsArrayType(name)
			Dim nullable As Microsoft.CodeAnalysis.SyntaxToken = name.Nullable
			Dim node As Boolean = nullable.Node IsNot Nothing
			Dim identifier As Microsoft.CodeAnalysis.SyntaxToken = name.Identifier
			If (node AndAlso valueType.IsArrayType() AndAlso Not flag) Then
				Dim syntaxNodeOrToken As Microsoft.CodeAnalysis.SyntaxNodeOrToken = identifier
				Dim str(0) As [Object]
				nullable = name.Identifier
				str(0) = nullable.ToString()
				Binder.ReportDiagnostic(diagnostics, syntaxNodeOrToken, ERRID.ERR_CannotInferNullableForVariable1, str)
			ElseIf (flag AndAlso Not valueType.IsArrayType()) Then
				Binder.ReportDiagnostic(diagnostics, identifier, ERRID.ERR_InferringNonArrayType1, New [Object]() { valueType })
			ElseIf (flag) Then
				If (node) Then
					Dim elementType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = DirectCast(valueType, Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol).ElementType
					While elementType.IsArrayType()
						elementType = DirectCast(elementType, Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol).ElementType
					End While
					If (elementType.IsNullableType()) Then
						GoTo Label1
					End If
					Binder.ReportDiagnostic(diagnostics, identifier, ERRID.ERR_CannotInferNullableForVariable1, New [Object]() { identifier.ToString() })
					typeSymbol = defaultType
					Return typeSymbol
				End If
			Label1:
				If (DirectCast(defaultType, Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol).Rank <> DirectCast(valueType, Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol).Rank) Then
					GoTo Label2
				End If
				Dim elementType1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = defaultType
				Dim typeSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = valueType
				While True
					If (Not elementType1.IsArrayType() OrElse Not typeSymbol1.IsArrayType()) Then
						If (Not typeSymbol1.IsArrayType() AndAlso elementType1.IsArrayType()) Then
							Exit While
						End If
						typeSymbol = valueType
						Return typeSymbol
					Else
						Dim arrayTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol = DirectCast(elementType1, Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol)
						Dim arrayTypeSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol = DirectCast(typeSymbol1, Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol)
						If (arrayTypeSymbol.Rank <> arrayTypeSymbol1.Rank) Then
							Exit While
						End If
						elementType1 = arrayTypeSymbol.ElementType
						typeSymbol1 = arrayTypeSymbol1.ElementType
					End If
				End While
				typeSymbol = Me.DecodeModifiedIdentifierType(name, typeSymbol1, Nothing, valueSyntax, getRequireTypeDiagnosticInfoFunc, diagnostics, Binder.ModifiedIdentifierTypeDecoderContext.None)
				Return typeSymbol
			ElseIf (Not node) Then
				typeSymbol = valueType
				Return typeSymbol
			Else
				If (Not valueType.IsValueType) Then
					Binder.ReportDiagnostic(diagnostics, identifier, ERRID.ERR_CannotInferNullableForVariable1, New [Object]() { identifier.ToString() })
					typeSymbol = defaultType
					Return typeSymbol
				End If
				If (Not valueType.IsNullableType()) Then
					typeSymbol = Me.DecodeModifiedIdentifierType(name, valueType, Nothing, valueSyntax, getRequireTypeDiagnosticInfoFunc, diagnostics, Binder.ModifiedIdentifierTypeDecoderContext.None)
					Return typeSymbol
				Else
					typeSymbol = valueType
					Return typeSymbol
				End If
			End If
			typeSymbol = defaultType
			Return typeSymbol
		Label2:
			Dim boundArrayLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundArrayLiteral = TryCast(valueExpression, Microsoft.CodeAnalysis.VisualBasic.BoundArrayLiteral)
			If (boundArrayLiteral Is Nothing OrElse Not boundArrayLiteral.IsEmptyArrayLiteral) Then
				Dim syntaxNodeOrToken1 As Microsoft.CodeAnalysis.SyntaxNodeOrToken = name
				Dim objArray(0) As [Object]
				nullable = name.Identifier
				objArray(0) = nullable.ToString()
				Binder.ReportDiagnostic(diagnostics, syntaxNodeOrToken1, ERRID.ERR_TypeInferenceArrayRankMismatch1, objArray)
				typeSymbol = defaultType
				Return typeSymbol
			Else
				typeSymbol = defaultType
				Return typeSymbol
			End If
		End Function

		Friend Shared Function InterpretDelegateBinding(ByVal addressOfExpression As BoundAddressOfOperator, ByVal targetType As TypeSymbol, ByVal isForHandles As Boolean) As Microsoft.CodeAnalysis.VisualBasic.Binder.DelegateResolutionResult
			Dim instance As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.GetInstance(True, addressOfExpression.WithDependencies)
			Dim key As MethodSymbol = Nothing
			Dim syntax As Microsoft.CodeAnalysis.SyntaxNode = addressOfExpression.Syntax
			Dim value As MethodConversionKind = MethodConversionKind.Identity
			If (targetType.SpecialType = SpecialType.System_Delegate OrElse targetType.SpecialType = SpecialType.System_MulticastDelegate) Then
				Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(instance, syntax, ERRID.ERR_AddressOfNotCreatableDelegate1, New [Object]() { targetType })
				value = value Or MethodConversionKind.Error_Unspecified
			ElseIf (targetType.TypeKind = Microsoft.CodeAnalysis.TypeKind.[Delegate]) Then
				Dim delegateInvokeMethod As MethodSymbol = DirectCast(targetType, NamedTypeSymbol).DelegateInvokeMethod
				If (delegateInvokeMethod Is Nothing) Then
					Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(instance, syntax, ERRID.ERR_UnsupportedMethod1, New [Object]() { targetType })
					value = value Or MethodConversionKind.Error_Unspecified
				ElseIf (Not Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDelegateInvokeUseSite(instance, syntax, targetType, delegateInvokeMethod)) Then
					Dim keyValuePair As KeyValuePair(Of MethodSymbol, MethodConversionKind) = Microsoft.CodeAnalysis.VisualBasic.Binder.ResolveMethodForDelegateInvokeFullAndRelaxed(addressOfExpression, delegateInvokeMethod, False, instance)
					key = keyValuePair.Key
					value = keyValuePair.Value
				Else
					value = value Or MethodConversionKind.Error_Unspecified
				End If
			Else
				If (targetType.TypeKind <> Microsoft.CodeAnalysis.TypeKind.[Error]) Then
					Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(instance, syntax, ERRID.ERR_AddressOfNotDelegate1, New [Object]() { targetType })
				End If
				value = value Or MethodConversionKind.Error_Unspecified
			End If
			If (key IsNot Nothing) Then
				Dim binder As Microsoft.CodeAnalysis.VisualBasic.Binder = addressOfExpression.Binder
				Dim syntaxNode As Microsoft.CodeAnalysis.SyntaxNode = addressOfExpression.Syntax
				Dim isShared As Boolean = key.IsShared
				Dim receiverOpt As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = addressOfExpression.MethodGroup.ReceiverOpt
				If (binder.CheckSharedSymbolAccess(syntaxNode, isShared, receiverOpt, addressOfExpression.MethodGroup.QualificationKind, instance)) Then
					value = value Or MethodConversionKind.Error_Unspecified
				End If
			End If
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = addressOfExpression.MethodGroup.ReceiverOpt
			If (key IsNot Nothing) Then
				If (key.IsMustOverride AndAlso boundExpression IsNot Nothing AndAlso (boundExpression.IsMyBaseReference() OrElse boundExpression.IsMyClassReference())) Then
					Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(instance, addressOfExpression.MethodGroup.Syntax, If(boundExpression.IsMyBaseReference(), ERRID.ERR_MyBaseAbstractCall1, ERRID.ERR_MyClassAbstractCall1), New [Object]() { key })
					value = value Or MethodConversionKind.Error_Unspecified
				End If
				If (Not key.IsShared AndAlso key.ContainingType.IsNullableType() AndAlso Not key.IsOverrides) Then
					Dim operand As Microsoft.CodeAnalysis.SyntaxNode = addressOfExpression.Syntax
					Dim unaryExpressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax = DirectCast(addressOfExpression.Syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax)
					If (unaryExpressionSyntax IsNot Nothing) Then
						operand = unaryExpressionSyntax.Operand
					End If
					Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(instance, operand, ERRID.ERR_AddressOfNullableMethod, New [Object]() { key.ContainingType, SyntaxFacts.GetText(SyntaxKind.AddressOfKeyword) })
					value = value Or MethodConversionKind.Error_Unspecified
				End If
				addressOfExpression.Binder.ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(instance, key, addressOfExpression.MethodGroup.Syntax)
			End If
			Dim conversionKind As Microsoft.CodeAnalysis.VisualBasic.ConversionKind = Microsoft.CodeAnalysis.VisualBasic.Conversions.DetermineDelegateRelaxationLevel(value)
			If ((conversionKind And Microsoft.CodeAnalysis.VisualBasic.ConversionKind.DelegateRelaxationLevelInvalid) <> Microsoft.CodeAnalysis.VisualBasic.ConversionKind.DelegateRelaxationLevelInvalid) Then
				conversionKind = If(Not Microsoft.CodeAnalysis.VisualBasic.Conversions.IsNarrowingMethodConversion(value, Not isForHandles), conversionKind Or Microsoft.CodeAnalysis.VisualBasic.ConversionKind.[Widening], conversionKind Or Microsoft.CodeAnalysis.VisualBasic.ConversionKind.[Narrowing])
			End If
			Return New Microsoft.CodeAnalysis.VisualBasic.Binder.DelegateResolutionResult(conversionKind, key, value, instance.ToReadOnlyAndFree())
		End Function

		Private Function InterpretForEachStatementCollection(ByVal collection As BoundExpression, <Out> ByRef currentType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, <Out> ByRef elementType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, <Out> ByRef isEnumerable As Boolean, <Out> ByRef boundGetEnumeratorCall As BoundExpression, <Out> ByRef boundEnumeratorPlaceholder As BoundLValuePlaceholder, <Out> ByRef boundMoveNextCall As BoundExpression, <Out> ByRef boundCurrentAccess As BoundExpression, <Out> ByRef collectionPlaceholder As BoundRValuePlaceholder, <Out> ByRef needToDispose As Boolean, <Out> ByRef isOrInheritsFromOrImplementsIDisposable As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim boundBadExpression As BoundExpression
			Dim syntax As SyntaxNode
			Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol
			Dim specialType As Microsoft.CodeAnalysis.SpecialType
			Dim instance As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag
			Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol)
			Dim specialType1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol
			Dim specialTypeMember As Microsoft.CodeAnalysis.VisualBasic.Symbol
			Dim symbol As Microsoft.CodeAnalysis.VisualBasic.Symbol
			Dim useSiteInfo As UseSiteInfo(Of AssemblySymbol)
			Dim useSiteInfo1 As UseSiteInfo(Of AssemblySymbol)
			Dim useSiteInfo2 As UseSiteInfo(Of AssemblySymbol)
			Dim useSiteInfo3 As UseSiteInfo(Of AssemblySymbol)
			currentType = Nothing
			elementType = Nothing
			isEnumerable = False
			needToDispose = False
			isOrInheritsFromOrImplementsIDisposable = False
			boundGetEnumeratorCall = Nothing
			boundEnumeratorPlaceholder = Nothing
			boundMoveNextCall = Nothing
			boundCurrentAccess = Nothing
			collectionPlaceholder = Nothing
			If (Not collection.HasErrors) Then
				Dim type As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = collection.Type
				syntax = collection.Syntax
				namedTypeSymbol = Nothing
				specialType = Microsoft.CodeAnalysis.SpecialType.None
				Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.GetInstance(True, diagnostics.AccumulatesDependencies)
				If (Not Me.MatchesForEachCollectionDesignPattern(type, collection, currentType, boundGetEnumeratorCall, boundEnumeratorPlaceholder, boundMoveNextCall, boundCurrentAccess, collectionPlaceholder, bindingDiagnosticBag)) Then
					instance = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.GetInstance(diagnostics)
					Dim namedTypeSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_IEnumerable_T, syntax, instance)
					Dim namedTypeSymbols As HashSet(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol) = New HashSet(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)(EqualsIgnoringComparer.InstanceIgnoringTupleNames)
					newCompoundUseSiteInfo = Me.GetNewCompoundUseSiteInfo(diagnostics)
					If (collection.IsNothingLiteral() OrElse type.IsArrayType() OrElse Not Binder.IsOrInheritsFromOrImplementsInterface(type, namedTypeSymbol1, newCompoundUseSiteInfo, namedTypeSymbols)) Then
						instance.Clear()
						specialType1 = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Collections_IEnumerable, syntax, instance)
						If ((collection.IsNothingLiteral() OrElse type.IsObjectType()) AndAlso Me.OptionStrict <> Microsoft.CodeAnalysis.VisualBasic.OptionStrict.[On] OrElse Not collection.IsNothingLiteral() AndAlso Not type.IsArrayType() AndAlso Binder.IsOrInheritsFromOrImplementsInterface(type, specialType1, newCompoundUseSiteInfo, namedTypeSymbols)) Then
							GoTo Label1
						End If
						diagnostics.Add(syntax, newCompoundUseSiteInfo)
						If (collection.IsNothingLiteral()) Then
							collection = Me.MakeRValue(collection, diagnostics)
							type = collection.Type
						End If
						If (Not bindingDiagnosticBag.HasAnyErrors()) Then
							Binder.ReportDiagnostic(diagnostics, syntax, ErrorFactory.ErrorInfo(ERRID.ERR_ForEachCollectionDesignPattern1, New [Object]() { type }))
						Else
							diagnostics.AddRange(bindingDiagnosticBag, False)
						End If
						bindingDiagnosticBag.Free()
						instance.Free()
						boundBadExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression(syntax, LookupResultKind.Empty, ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbol).Empty, ImmutableArray.Create(Of BoundExpression)(collection), type, True)
						Return boundBadExpression
					Else
						diagnostics.Add(syntax, newCompoundUseSiteInfo)
						isEnumerable = True
						namedTypeSymbol = namedTypeSymbols.ElementAtOrDefault(0)
						diagnostics.AddRange(instance, False)
						instance.Free()
						If (namedTypeSymbols.Count > 1) Then
							Binder.ReportDiagnostic(diagnostics, syntax, ErrorFactory.ErrorInfo(ERRID.ERR_ForEachAmbiguousIEnumerable1, New [Object]() { type }))
							bindingDiagnosticBag.Free()
							boundBadExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression(syntax, LookupResultKind.Empty, ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbol).Empty, ImmutableArray.Create(Of BoundExpression)(collection), type, True)
							Return boundBadExpression
						End If
						specialType = Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_IEnumerable_T
					End If
				Else
					diagnostics.AddRange(bindingDiagnosticBag, False)
					elementType = currentType
					isEnumerable = True
				End If
			Label3:
				bindingDiagnosticBag.Free()
				If (namedTypeSymbol IsNot Nothing) Then
					collection = Me.ApplyImplicitConversion(syntax, namedTypeSymbol, collection, diagnostics, False)
				End If
				If (isEnumerable) Then
					If (specialType <> Microsoft.CodeAnalysis.SpecialType.None) Then
						If (specialType <> Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_IEnumerable_T) Then
							specialTypeMember = Me.GetSpecialTypeMember(SpecialMember.System_Collections_IEnumerable__GetEnumerator, syntax, diagnostics)
						Else
							symbol = Me.GetSpecialTypeMember(SpecialMember.System_Collections_Generic_IEnumerable_T__GetEnumerator, syntax, diagnostics)
							If (symbol Is Nothing OrElse symbol.GetUseSiteInfo().DiagnosticInfo IsNot Nothing OrElse namedTypeSymbol.IsErrorType()) Then
								specialTypeMember = Nothing
							Else
								specialTypeMember = DirectCast(namedTypeSymbol, SubstitutedNamedType).GetMemberForDefinition(symbol)
							End If
						End If
						If (specialTypeMember IsNot Nothing) Then
							useSiteInfo1 = specialTypeMember.GetUseSiteInfo()
						Else
							useSiteInfo = New UseSiteInfo(Of AssemblySymbol)()
							useSiteInfo1 = useSiteInfo
						End If
						Dim useSiteInfo4 As UseSiteInfo(Of AssemblySymbol) = useSiteInfo1
						If (specialTypeMember IsNot Nothing AndAlso useSiteInfo4.DiagnosticInfo Is Nothing) Then
							diagnostics.AddDependencies(useSiteInfo4)
							collectionPlaceholder = New BoundRValuePlaceholder(syntax, If(type Is Nothing OrElse Not type.IsStringType(), collection.Type, type))
							Dim boundMethodGroup As BoundMethodOrPropertyGroup = New Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup(syntax, Nothing, ImmutableArray.Create(Of MethodSymbol)(DirectCast(specialTypeMember, MethodSymbol)), LookupResultKind.Good, collectionPlaceholder, QualificationKind.QualifiedViaValue, False)
							boundGetEnumeratorCall = Me.CreateBoundInvocationExpressionFromMethodOrPropertyGroup(syntax, boundMethodGroup, diagnostics)
							Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = boundGetEnumeratorCall.Type
							boundEnumeratorPlaceholder = New BoundLValuePlaceholder(syntax, typeSymbol)
							specialTypeMember = Me.GetSpecialTypeMember(SpecialMember.System_Collections_IEnumerator__MoveNext, syntax, diagnostics)
							If (specialTypeMember IsNot Nothing) Then
								useSiteInfo2 = specialTypeMember.GetUseSiteInfo()
							Else
								useSiteInfo = New UseSiteInfo(Of AssemblySymbol)()
								useSiteInfo2 = useSiteInfo
							End If
							useSiteInfo4 = useSiteInfo2
							If (specialTypeMember IsNot Nothing AndAlso useSiteInfo4.DiagnosticInfo Is Nothing) Then
								diagnostics.AddDependencies(useSiteInfo4)
								boundMethodGroup = New Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup(syntax, Nothing, ImmutableArray.Create(Of MethodSymbol)(DirectCast(specialTypeMember, MethodSymbol)), LookupResultKind.Good, boundEnumeratorPlaceholder, QualificationKind.QualifiedViaValue, False)
								boundMoveNextCall = Me.CreateBoundInvocationExpressionFromMethodOrPropertyGroup(syntax, boundMethodGroup, diagnostics)
							End If
							If (specialType <> Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_IEnumerable_T) Then
								specialTypeMember = Me.GetSpecialTypeMember(SpecialMember.System_Collections_IEnumerator__Current, syntax, diagnostics)
							Else
								symbol = Me.GetSpecialTypeMember(SpecialMember.System_Collections_Generic_IEnumerator_T__Current, syntax, diagnostics)
								If (symbol Is Nothing OrElse symbol.GetUseSiteInfo().DiagnosticInfo IsNot Nothing OrElse typeSymbol.IsErrorType()) Then
									specialTypeMember = Nothing
								Else
									specialTypeMember = DirectCast(typeSymbol, SubstitutedNamedType).GetMemberForDefinition(symbol)
								End If
							End If
							If (specialTypeMember IsNot Nothing) Then
								useSiteInfo3 = specialTypeMember.GetUseSiteInfo()
							Else
								useSiteInfo = New UseSiteInfo(Of AssemblySymbol)()
								useSiteInfo3 = useSiteInfo
							End If
							useSiteInfo4 = useSiteInfo3
							If (specialTypeMember IsNot Nothing AndAlso useSiteInfo4.DiagnosticInfo Is Nothing) Then
								diagnostics.AddDependencies(useSiteInfo4)
								boundMethodGroup = New BoundPropertyGroup(syntax, ImmutableArray.Create(Of PropertySymbol)(DirectCast(specialTypeMember, PropertySymbol)), LookupResultKind.Good, boundEnumeratorPlaceholder, QualificationKind.QualifiedViaValue, False)
								boundCurrentAccess = Me.CreateBoundInvocationExpressionFromMethodOrPropertyGroup(syntax, boundMethodGroup, diagnostics)
								currentType = boundCurrentAccess.Type
								elementType = currentType
							End If
						End If
					End If
					If (type IsNot Nothing) Then
						If (type.IsArrayType()) Then
							Dim arrayTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol = DirectCast(type, Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol)
							elementType = arrayTypeSymbol.ElementType
							If (arrayTypeSymbol.IsSZArray) Then
								currentType = elementType
							End If
						ElseIf (type.IsStringType()) Then
							elementType = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Char, syntax, diagnostics)
							currentType = elementType
						End If
					End If
					Dim specialType2 As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_IDisposable, syntax, diagnostics)
					If (specialType2 IsNot Nothing AndAlso Not specialType2.IsErrorType() AndAlso Not boundGetEnumeratorCall.HasErrors AndAlso Not boundGetEnumeratorCall.Type.IsErrorType()) Then
						Dim type1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = boundGetEnumeratorCall.Type
						Dim compoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
						Dim conversionKind As Microsoft.CodeAnalysis.VisualBasic.ConversionKind = Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyDirectCastConversion(type1, specialType2, compoundUseSiteInfo)
						diagnostics.Add(syntax, compoundUseSiteInfo)
						isOrInheritsFromOrImplementsIDisposable = Microsoft.CodeAnalysis.VisualBasic.Conversions.IsWideningConversion(conversionKind)
						If ((isOrInheritsFromOrImplementsIDisposable OrElse type1.SpecialType = Microsoft.CodeAnalysis.SpecialType.System_Collections_IEnumerator) AndAlso (type Is Nothing OrElse Not type.IsArrayType())) Then
							needToDispose = True
						End If
					End If
				End If
				boundBadExpression = collection
			Else
				boundBadExpression = collection
			End If
			Return boundBadExpression
		Label1:
			diagnostics.Add(syntax, newCompoundUseSiteInfo)
			isEnumerable = True
			namedTypeSymbol = specialType1
			specialType = Microsoft.CodeAnalysis.SpecialType.System_Collections_IEnumerable
			diagnostics.AddRange(instance, False)
			instance.Free()
			GoTo Label3
		End Function

		Public Function IsAccessible(ByVal sym As Symbol, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol), Optional ByVal accessThroughType As TypeSymbol = Nothing, Optional ByVal basesBeingResolved As Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolved = Nothing) As Boolean
			Return Me.CheckAccessibility(sym, useSiteInfo, accessThroughType, basesBeingResolved) = AccessCheckResult.Accessible
		End Function

		Public Shared Function IsArrayType(ByVal identifierSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax) As Boolean
			If (identifierSyntax.ArrayBounds IsNot Nothing) Then
				Return True
			End If
			Return identifierSyntax.ArrayRankSpecifiers.Count > 0
		End Function

		Protected Function IsAttributeConditionallyOmitted(ByVal attributeType As NamedTypeSymbol, ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax, ByVal syntaxTree As Microsoft.CodeAnalysis.SyntaxTree) As Boolean
			Dim flag As Boolean
			If (Me.IsEarlyAttributeBinder) Then
				flag = False
			ElseIf (Not attributeType.IsConditional) Then
				flag = False
			Else
				flag = If(Not syntaxTree.IsAnyPreprocessorSymbolDefined(DirectCast(attributeType.GetAppliedConditionalSymbols(), IEnumerable(Of String)), node), True, False)
			End If
			Return flag
		End Function

		Private Function IsBindingImplicitlyTypedLocal(ByVal symbol As LocalSymbol) As Boolean
			Dim flag As Boolean
			Dim enumerator As ConsList(Of LocalSymbol).Enumerator = New ConsList(Of LocalSymbol).Enumerator()
			Try
				enumerator = Me.ImplicitlyTypedLocalsBeingBound.GetEnumerator()
				While enumerator.MoveNext()
					If (enumerator.Current <> symbol) Then
						Continue While
					End If
					flag = True
					Return flag
				End While
			Finally
				DirectCast(enumerator, IDisposable).Dispose()
			End Try
			flag = False
			Return flag
		End Function

		Private Shared Function IsCallStatementContext(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax) As Boolean
			Dim parent As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode = node.Parent
			If (parent IsNot Nothing AndAlso parent.Kind() = SyntaxKind.ConditionalAccessExpression) Then
				Dim conditionalAccessExpressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax = DirectCast(parent, Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax)
				If (conditionalAccessExpressionSyntax.WhenNotNull = node) Then
					parent = conditionalAccessExpressionSyntax.Parent
				End If
			End If
			If (parent Is Nothing) Then
				Return False
			End If
			If (parent.Kind() = SyntaxKind.CallStatement) Then
				Return True
			End If
			Return parent.Kind() = SyntaxKind.ExpressionStatement
		End Function

		Private Shared Function IsConstantAllowingCompileTimeFolding(ByVal candidate As BoundExpression) As Boolean
			If (Not candidate.IsConstant OrElse candidate.ConstantValueOpt.IsBad) Then
				Return False
			End If
			If (candidate.IsNothingLiteral()) Then
				Return True
			End If
			If (candidate.Type Is Nothing) Then
				Return False
			End If
			Return candidate.Type.AllowsCompileTimeOperations()
		End Function

		Private Function IsConstructorCallAllowed(ByVal invocationExpression As Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax, ByVal boundMemberGroup As BoundMethodOrPropertyGroup) As Boolean
			Dim flag As Boolean
			If (Me.ContainingMember.Kind = SymbolKind.Method AndAlso DirectCast(Me.ContainingMember, MethodSymbol).MethodKind = MethodKind.Constructor) Then
				Dim parent As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode = invocationExpression.Parent
				If (parent Is Nothing OrElse parent.Kind() <> SyntaxKind.CallStatement AndAlso parent.Kind() <> SyntaxKind.ExpressionStatement) Then
					flag = False
					Return flag
				Else
					Dim visualBasicSyntaxNode As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode = parent.Parent
					If (visualBasicSyntaxNode Is Nothing OrElse visualBasicSyntaxNode.Kind() <> SyntaxKind.ConstructorBlock) Then
						flag = False
						Return flag
					ElseIf (DirectCast(visualBasicSyntaxNode, Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstructorBlockSyntax).Statements(0) = parent) Then
						Dim receiverOpt As BoundExpression = boundMemberGroup.ReceiverOpt
						If (receiverOpt Is Nothing OrElse receiverOpt.Kind <> BoundKind.MeReference AndAlso receiverOpt.Kind <> BoundKind.MyBaseReference AndAlso receiverOpt.Kind <> BoundKind.MyClassReference) Then
							flag = False
							Return flag
						End If
						flag = True
						Return flag
					End If
				End If
			End If
			flag = False
			Return flag
		End Function

		Private Shared Function IsGroupOfConstructors(ByVal group As BoundMethodOrPropertyGroup) As Boolean
			Dim methodKind As Boolean
			If (group.Kind <> BoundKind.MethodGroup) Then
				methodKind = False
			Else
				Dim methods As ImmutableArray(Of MethodSymbol) = DirectCast(group, BoundMethodGroup).Methods
				methodKind = methods(0).MethodKind = Microsoft.CodeAnalysis.MethodKind.Constructor
			End If
			Return methodKind
		End Function

		Private Function IsIEnumerableOfXElement(ByVal type As TypeSymbol, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol)) As Boolean
			Return type.IsOrImplementsIEnumerableOfXElement(Me.Compilation, useSiteInfo)
		End Function

		Public Function IsInAsyncContext() As Boolean
			If (Me.ContainingMember.Kind <> SymbolKind.Method) Then
				Return False
			End If
			Return DirectCast(Me.ContainingMember, MethodSymbol).IsAsync
		End Function

		Public Function IsInIteratorContext() As Boolean
			If (Me.ContainingMember.Kind <> SymbolKind.Method) Then
				Return False
			End If
			Return DirectCast(Me.ContainingMember, MethodSymbol).IsIterator
		End Function

		Private Shared Function IsInvalidSelectCaseRange(ByVal lbConstantValue As ConstantValue, ByVal ubConstantValue As ConstantValue) As Boolean
			Dim uInt64Value As Boolean
			Select Case lbConstantValue.SpecialType
				Case SpecialType.System_Boolean
				Case SpecialType.System_Byte
				Case SpecialType.System_UInt16
				Case SpecialType.System_UInt32
				Case SpecialType.System_UInt64
					uInt64Value = lbConstantValue.UInt64Value > ubConstantValue.UInt64Value
					Exit Select
				Case SpecialType.System_Char
				Case SpecialType.System_SByte
				Case SpecialType.System_Int16
				Case SpecialType.System_Int32
				Case SpecialType.System_Int64
					uInt64Value = lbConstantValue.Int64Value > ubConstantValue.Int64Value
					Exit Select
				Case SpecialType.System_Decimal
					uInt64Value = [Decimal].Compare(lbConstantValue.DecimalValue, ubConstantValue.DecimalValue) > 0
					Exit Select
				Case SpecialType.System_Single
				Case SpecialType.System_Double
					uInt64Value = lbConstantValue.DoubleValue > ubConstantValue.DoubleValue
					Exit Select
				Case Else
					uInt64Value = False
					Exit Select
			End Select
			Return uInt64Value
		End Function

		Private Shared Function IsKnownToBeNullableNothing(ByVal expr As BoundExpression) As Boolean
			Dim flag As Boolean
			Dim operand As BoundExpression = expr
			While True
				If (operand.Kind <> BoundKind.Conversion AndAlso operand.Kind <> BoundKind.[DirectCast]) Then
					flag = operand.IsNothingLiteral()
					Exit While
				ElseIf (Not operand.HasErrors) Then
					Dim type As TypeSymbol = Nothing
					Dim kind As BoundKind = operand.Kind
					If (kind = BoundKind.Conversion) Then
						Dim boundConversion As Microsoft.CodeAnalysis.VisualBasic.BoundConversion = DirectCast(operand, Microsoft.CodeAnalysis.VisualBasic.BoundConversion)
						type = boundConversion.Type
						operand = boundConversion.Operand
					ElseIf (kind = BoundKind.[DirectCast]) Then
						Dim boundDirectCast As Microsoft.CodeAnalysis.VisualBasic.BoundDirectCast = DirectCast(operand, Microsoft.CodeAnalysis.VisualBasic.BoundDirectCast)
						type = boundDirectCast.Type
						operand = boundDirectCast.Operand
					End If
					If (type Is Nothing OrElse Not type.IsNullableType() AndAlso Not type.IsObjectType()) Then
						flag = False
						Exit While
					End If
				Else
					flag = False
					Exit While
				End If
			End While
			Return flag
		End Function

		Friend Function IsLValueFieldAccess(ByVal field As FieldSymbol, ByVal receiver As BoundExpression) As Boolean
			Dim flag As Boolean
			Dim flag1 As Boolean
			If (Not field.IsConst) Then
				If (Not field.IsShared AndAlso receiver IsNot Nothing AndAlso receiver.IsValue()) Then
					Dim type As TypeSymbol = receiver.Type
					If (type.IsTypeParameter() OrElse Not type.IsValueType OrElse receiver.IsLValue OrElse receiver.IsMeReference() OrElse receiver.IsMyClassReference()) Then
						GoTo Label1
					End If
					flag = False
					Return flag
				End If
			Label1:
				If (field.IsReadOnly) Then
					Dim methodKind As Microsoft.CodeAnalysis.MethodKind = Me.KindOfContainingMethodAtRunTime()
					If (methodKind = Microsoft.CodeAnalysis.MethodKind.Constructor) Then
						If (Not field.IsShared AndAlso receiver IsNot Nothing AndAlso receiver.IsInstanceReference()) Then
							GoTo Label2
						End If
						flag = False
						Return flag
					ElseIf (methodKind <> Microsoft.CodeAnalysis.MethodKind.StaticConstructor) Then
						flag = False
						Return flag
					Else
						If (field.IsShared) Then
							GoTo Label2
						End If
						flag = False
						Return flag
					End If
				Label2:
					flag1 = If(Me.Compilation.FeatureStrictEnabled, CObj(Me.ContainingMember.ContainingSymbol) = CObj(field.ContainingSymbol), CObj(Me.ContainingMember.ContainingSymbol.OriginalDefinition) = CObj(field.ContainingSymbol.OriginalDefinition))
					flag = flag1
				Else
					flag = True
				End If
			Else
				flag = False
			End If
			Return flag
		End Function

		Private Function IsMeOrMyBaseOrMyClassInSharedContext() As Boolean
			Dim flag As Boolean
			If (Me.BindingLocation <> Microsoft.CodeAnalysis.VisualBasic.BindingLocation.Attribute) Then
				Dim containingMember As Symbol = Me.ContainingMember
				If (containingMember IsNot Nothing) Then
					Dim kind As SymbolKind = containingMember.Kind
					If (kind = SymbolKind.Field) Then
						flag = If(containingMember.IsShared OrElse Me.ContainingType.IsModuleType(), True, DirectCast(containingMember, FieldSymbol).IsConst)
						Return flag
					Else
						If (kind <> SymbolKind.Method AndAlso kind <> SymbolKind.[Property]) Then
							GoTo Label1
						End If
						flag = If(containingMember.IsShared, True, Me.ContainingType.IsModuleType())
						Return flag
					End If
				End If
			Label1:
				flag = True
			Else
				flag = True
			End If
			Return flag
		End Function

		Private Shared Function IsNameOfArgument(ByVal syntax As SyntaxNode) As Boolean
			If (syntax.Parent Is Nothing OrElse syntax.Parent.Kind() <> SyntaxKind.NameOfExpression) Then
				Return False
			End If
			Return DirectCast(syntax.Parent, Microsoft.CodeAnalysis.VisualBasic.Syntax.NameOfExpressionSyntax).Argument = syntax
		End Function

		Private Shared Function IsNamespaceGroupIncludesButNotEquivalentTo(ByVal namespaceGroup As NamespaceSymbol, ByVal other As NamespaceSymbol) As Boolean
			Dim flag As Boolean
			If (CInt(other.NamespaceKind) = 0) Then
				Dim constituentNamespaces As ImmutableArray(Of NamespaceSymbol) = namespaceGroup.ConstituentNamespaces
				Dim namespaceSymbols As ImmutableArray(Of NamespaceSymbol) = other.ConstituentNamespaces
				If (constituentNamespaces.Length <= namespaceSymbols.Length) Then
					flag = False
				Else
					flag = True
					Dim namespaceSymbols1 As SmallDictionary(Of NamespaceSymbol, Boolean) = New SmallDictionary(Of NamespaceSymbol, Boolean)()
					Dim enumerator As ImmutableArray(Of NamespaceSymbol).Enumerator = constituentNamespaces.GetEnumerator()
					While enumerator.MoveNext()
						namespaceSymbols1(enumerator.Current) = False
					End While
					Dim enumerator1 As ImmutableArray(Of NamespaceSymbol).Enumerator = namespaceSymbols.GetEnumerator()
					While enumerator1.MoveNext()
						Dim current As NamespaceSymbol = enumerator1.Current
						Dim flag1 As Boolean = False
						If (namespaceSymbols1.TryGetValue(current, flag1)) Then
							Continue While
						End If
						flag = False
						Return flag
					End While
				End If
			Else
				flag = namespaceGroup.ConstituentNamespaces.Contains(other)
			End If
			Return flag
		End Function

		Private Shared Function IsNothingLiteralAllowedForAType(ByVal type As TypeSymbol) As Boolean
			Dim flag As Boolean
			If (type.IsReferenceType) Then
				flag = True
			ElseIf (Not type.IsEnumType()) Then
				Dim specialType As Microsoft.CodeAnalysis.SpecialType = type.SpecialType
				flag = If(CSByte(specialType) - CSByte(Microsoft.CodeAnalysis.SpecialType.System_Boolean) <= CSByte(Microsoft.CodeAnalysis.SpecialType.System_SByte) OrElse CSByte(specialType) - CSByte(Microsoft.CodeAnalysis.SpecialType.System_Single) <= CSByte(Microsoft.CodeAnalysis.SpecialType.System_Object), True, False)
			Else
				flag = True
			End If
			Return flag
		End Function

		Private Function IsOrInheritsFromOrImplementsInterface(ByVal derivedType As TypeSymbol, ByVal interfaceType As Microsoft.CodeAnalysis.WellKnownType, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol)) As Boolean
			Dim wellKnownType As NamedTypeSymbol = Me.Compilation.GetWellKnownType(interfaceType)
			If (wellKnownType.IsErrorType() OrElse Not wellKnownType.IsInterfaceType()) Then
				Return False
			End If
			Return Binder.IsOrInheritsFromOrImplementsInterface(derivedType, wellKnownType, useSiteInfo, Nothing)
		End Function

		Friend Shared Function IsOrInheritsFromOrImplementsInterface(ByVal derivedType As TypeSymbol, ByVal interfaceType As NamedTypeSymbol, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol), Optional ByVal matchingInterfaces As HashSet(Of NamedTypeSymbol) = Nothing) As Boolean
			Dim flag As Boolean
			Dim flag1 As Boolean
			If (Not derivedType.IsTypeParameter()) Then
				If (TypeSymbol.Equals(derivedType.OriginalDefinition, interfaceType, TypeCompareKind.ConsiderEverything)) Then
					If (matchingInterfaces Is Nothing) Then
						flag = True
						Return flag
					End If
					Binder.RecordMatchForIsOrInheritsFromOrImplementsInterface(matchingInterfaces, DirectCast(derivedType, NamedTypeSymbol))
				End If
				Dim enumerator As ImmutableArray(Of NamedTypeSymbol).Enumerator = derivedType.AllInterfacesWithDefinitionUseSiteDiagnostics(useSiteInfo).GetEnumerator()
				While enumerator.MoveNext()
					Dim current As NamedTypeSymbol = enumerator.Current
					If (Not TypeSymbol.Equals(current.OriginalDefinition, interfaceType, TypeCompareKind.ConsiderEverything)) Then
						Continue While
					End If
					If (matchingInterfaces IsNot Nothing) Then
						Binder.RecordMatchForIsOrInheritsFromOrImplementsInterface(matchingInterfaces, current)
					Else
						flag = True
						Return flag
					End If
				End While
				flag1 = If(matchingInterfaces Is Nothing, False, matchingInterfaces.Count > 0)
				flag = flag1
				Return flag
			Else
				Dim typeParameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol = DirectCast(derivedType, Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol)
				If (Not typeParameterSymbol.HasValueTypeConstraint OrElse Not Binder.IsOrInheritsFromOrImplementsInterface(interfaceType.ContainingAssembly.GetSpecialType(SpecialType.System_ValueType), interfaceType, useSiteInfo, matchingInterfaces) OrElse matchingInterfaces IsNot Nothing) Then
					Dim enumerator1 As ImmutableArray(Of TypeSymbol).Enumerator = typeParameterSymbol.ConstraintTypesWithDefinitionUseSiteDiagnostics(useSiteInfo).GetEnumerator()
					While enumerator1.MoveNext()
						If (Not Binder.IsOrInheritsFromOrImplementsInterface(enumerator1.Current, interfaceType, useSiteInfo, matchingInterfaces) OrElse matchingInterfaces IsNot Nothing) Then
							Continue While
						End If
						flag = True
						Return flag
					End While
					flag1 = If(matchingInterfaces Is Nothing, False, matchingInterfaces.Count > 0)
					flag = flag1
					Return flag
				Else
					flag = True
				End If
			End If
			Return flag
		End Function

		Private Shared Function IsReceiverOfNameOfArgument(ByVal syntax As SyntaxNode) As Boolean
			Dim parent As SyntaxNode = syntax.Parent
			If (parent Is Nothing OrElse parent.Kind() <> SyntaxKind.SimpleMemberAccessExpression OrElse DirectCast(parent, Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax).Expression <> syntax) Then
				Return False
			End If
			Return Binder.IsNameOfArgument(parent)
		End Function

		Public Shared Function IsTopMostEnclosingLambdaAQueryLambda(ByVal containingMember As Symbol, ByVal stopAtContainer As Symbol) As Boolean
			Dim isQueryLambdaMethod As Boolean = False
			Dim containingSymbol As Symbol = containingMember
			While containingSymbol IsNot Nothing AndAlso CObj(containingSymbol) <> CObj(stopAtContainer) AndAlso containingSymbol.IsLambdaMethod
				isQueryLambdaMethod = containingSymbol.IsQueryLambdaMethod
				containingSymbol = containingSymbol.ContainingSymbol
			End While
			Return isQueryLambdaMethod
		End Function

		Public Overridable Function IsUnboundTypeAllowed(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax) As Boolean
			Return Me.m_containingBinder.IsUnboundTypeAllowed(syntax)
		End Function

		Friend Shared Function IsValidAssignmentTarget(ByVal expression As BoundExpression) As Boolean
			Dim isLValue As Boolean
			Dim flag As Boolean
			Dim kind As BoundKind = expression.Kind
			Select Case kind
				Case BoundKind.[Call]
					isLValue = DirectCast(expression, BoundCall).IsLValue
					Exit Select
				Case BoundKind.Attribute
				Label0:
					isLValue = expression.IsLValue
					Exit Select
				Case BoundKind.LateMemberAccess
					Dim boundLateMemberAccess As Microsoft.CodeAnalysis.VisualBasic.BoundLateMemberAccess = DirectCast(expression, Microsoft.CodeAnalysis.VisualBasic.BoundLateMemberAccess)
					isLValue = If(boundLateMemberAccess.AccessKind = LateBoundAccessKind.[Get], False, boundLateMemberAccess.AccessKind <> LateBoundAccessKind.[Call])
					Exit Select
				Case BoundKind.LateInvocation
					Dim boundLateInvocation As Microsoft.CodeAnalysis.VisualBasic.BoundLateInvocation = DirectCast(expression, Microsoft.CodeAnalysis.VisualBasic.BoundLateInvocation)
					isLValue = If(boundLateInvocation.AccessKind = LateBoundAccessKind.[Get], False, boundLateInvocation.AccessKind <> LateBoundAccessKind.[Call])
					Exit Select
				Case Else
					If (kind = BoundKind.PropertyAccess) Then
						Dim boundPropertyAccess As Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess = DirectCast(expression, Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess)
						Dim propertySymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol = boundPropertyAccess.PropertySymbol
						Dim receiverOpt As BoundExpression = boundPropertyAccess.ReceiverOpt
						If (boundPropertyAccess.AccessKind = PropertyAccessKind.[Get]) Then
							flag = False
						Else
							flag = If(propertySymbol.IsShared OrElse receiverOpt Is Nothing OrElse receiverOpt.IsLValue OrElse receiverOpt.IsMeReference() OrElse receiverOpt.IsMyClassReference(), True, Not receiverOpt.Type.IsValueType)
						End If
						isLValue = flag
						Exit Select
					ElseIf (kind = BoundKind.XmlMemberAccess) Then
						isLValue = Binder.IsValidAssignmentTarget(DirectCast(expression, BoundXmlMemberAccess).MemberAccess)
						Exit Select
					Else
						GoTo Label0
					End If
			End Select
			Return isLValue
		End Function

		Private Shared Function IsValidBranchTarget(ByVal block As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal labelSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax) As Boolean
			Dim flag As Boolean
			Dim parent As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode = labelSyntax.Parent
			While True
				If (parent Is Nothing) Then
					flag = False
					Exit While
				ElseIf (parent <> block) Then
					parent = parent.Parent
				Else
					flag = True
					Exit While
				End If
			End While
			Return flag
		End Function

		Private Function IsValidForControlVariableType(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax, ByVal targetType As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
			Dim flag As Boolean
			If (targetType.IsNullableType()) Then
				targetType = targetType.GetNullableUnderlyingType().GetEnumUnderlyingTypeOrSelf()
			End If
			If (targetType.IsNumericType()) Then
				flag = True
			ElseIf (Not targetType.IsObjectType()) Then
				Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
				If (targetType.IsIntrinsicOrEnumType() OrElse Not targetType.CanContainUserDefinedOperators(newCompoundUseSiteInfo)) Then
					diagnostics.Add(DirectCast(node.ForOrForEachStatement, Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax).ControlVariable, newCompoundUseSiteInfo)
					Binder.ReportDiagnostic(diagnostics, DirectCast(node.ForOrForEachStatement, Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax).ControlVariable, ERRID.ERR_ForLoopType1, New [Object]() { targetType })
					flag = False
				Else
					diagnostics.Add(DirectCast(node.ForOrForEachStatement, Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax).ControlVariable, newCompoundUseSiteInfo)
					flag = True
				End If
			Else
				flag = True
			End If
			Return flag
		End Function

		Private Function IsValidLabelForGoto(ByVal label As LabelSymbol, ByVal labelSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
			Dim flag As Boolean = False
			Dim parent As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode = DirectCast(label.LabelName.Parent, Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)
			Dim eRRID As Microsoft.CodeAnalysis.VisualBasic.ERRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_None
			While parent IsNot Nothing
				Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = parent.Kind()
				If (syntaxKind > Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TryBlock) Then
					If (CUShort(syntaxKind) - CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CatchBlock) <= CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List)) Then
						GoTo Label0
					End If
					If (CUShort(syntaxKind) - CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ForBlock) <= CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List)) Then
						eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_GotoIntoFor
					ElseIf (CUShort(syntaxKind) - CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MultiLineFunctionLambdaExpression) <= CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List)) Then
						Exit While
					End If
				Else
					If (CUShort(syntaxKind) - CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SubBlock) <= CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List)) Then
						Exit While
					End If
					Select Case syntaxKind
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UsingBlock
							eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_GotoIntoUsing
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SyncLockBlock
							eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_GotoIntoSyncLock
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithBlock
							eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_GotoIntoWith
							Exit Select
						Case Else
							If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TryBlock) Then
								GoTo Label0
							End If
							Exit Select
					End Select
				End If
			Label1:
				If (eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_None) Then
					parent = parent.Parent
				Else
					If (Binder.IsValidBranchTarget(parent, labelSyntax)) Then
						Exit While
					End If
					Binder.ReportDiagnostic(diagnostics, labelSyntax, ErrorFactory.ErrorInfo(eRRID, New [Object]() { label.Name }))
					flag = True
					Exit While
				End If
			End While
			Return Not flag
		Label0:
			eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_GotoIntoTryHandler
			GoTo Label1
		End Function

		Private Function IsValidTypeForAttributeArgument(ByVal type As TypeSymbol) As Boolean
			Return type.IsValidTypeForAttributeArgument(Me.Compilation)
		End Function

		Private Function IsWellKnownTypeMember(ByVal memberId As WellKnownMember, ByVal method As MethodSymbol) As Boolean
			Return Me.Compilation.GetWellKnownTypeMember(memberId) = method
		End Function

		Private Shared Function JoinShouldAbsorbNextOperator(ByRef operatorsEnumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator) As Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax
			Dim queryClauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax
			Dim enumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator = operatorsEnumerator
			If (enumerator.MoveNext()) Then
				Dim current As Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax = enumerator.Current
				Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = current.Kind()
				If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LetClause) Then
					If (DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax).Variables.Count <= 0) Then
						queryClauseSyntax = Nothing
						Return queryClauseSyntax
					End If
					operatorsEnumerator = enumerator
					queryClauseSyntax = current
					Return queryClauseSyntax
				ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AggregateClause) Then
					operatorsEnumerator = enumerator
					queryClauseSyntax = current
					Return queryClauseSyntax
				Else
					If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SelectClause) Then
						queryClauseSyntax = Nothing
						Return queryClauseSyntax
					End If
					operatorsEnumerator = enumerator
					queryClauseSyntax = current
					Return queryClauseSyntax
				End If
			End If
			queryClauseSyntax = Nothing
			Return queryClauseSyntax
		End Function

		Private Function KindOfContainingMethodAtRunTime() As Microsoft.CodeAnalysis.MethodKind
			Dim methodKind As Microsoft.CodeAnalysis.MethodKind
			Dim containingMember As Symbol = Me.ContainingMember
			If (containingMember IsNot Nothing) Then
				Select Case containingMember.Kind
					Case SymbolKind.Field
					Case SymbolKind.[Property]
						If (Not containingMember.IsShared) Then
							methodKind = Microsoft.CodeAnalysis.MethodKind.Constructor
							Return methodKind
						Else
							methodKind = Microsoft.CodeAnalysis.MethodKind.StaticConstructor
							Return methodKind
						End If
					Case SymbolKind.Label
					Case SymbolKind.Local
					Case SymbolKind.NetModule
					Case SymbolKind.PointerType
						Throw ExceptionUtilities.UnexpectedValue(containingMember.Kind)
					Case SymbolKind.Method
						methodKind = DirectCast(containingMember, MethodSymbol).MethodKind
						Return methodKind
					Case SymbolKind.NamedType
					Case SymbolKind.[Namespace]
					Case SymbolKind.Parameter
						Exit Select
					Case Else
						Throw ExceptionUtilities.UnexpectedValue(containingMember.Kind)
				End Select
			End If
			methodKind = Microsoft.CodeAnalysis.MethodKind.Ordinary
			Return methodKind
		End Function

		Private Shared Function LambdaHeaderErrorNode(ByVal source As UnboundLambda) As SyntaxNode
			Dim syntax As SyntaxNode
			Dim lambdaExpressionSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaExpressionSyntax = TryCast(source.Syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaExpressionSyntax)
			If (lambdaExpressionSyntax Is Nothing) Then
				syntax = source.Syntax
			Else
				syntax = lambdaExpressionSyntax.SubOrFunctionHeader
			End If
			Return syntax
		End Function

		Public Overridable Sub Lookup(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
			' 
			' Current member / type: System.Void Microsoft.CodeAnalysis.VisualBasic.Binder::Lookup(Microsoft.CodeAnalysis.VisualBasic.LookupResult,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.CompoundUseSiteInfo`1<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: System.Void Lookup(Microsoft.CodeAnalysis.VisualBasic.LookupResult,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.CompoundUseSiteInfo<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Sub

		Private Sub Lookup(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal container As NamespaceOrTypeSymbol, ByVal name As String, ByVal options As LookupOptions, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
			If (container Is Nothing) Then
				Me.Lookup(lookupResult, name, 0, options, useSiteInfo)
				Return
			End If
			Me.LookupMember(lookupResult, container, name, 0, options, useSiteInfo)
		End Sub

		Friend Sub LookupAttributeType(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal container As NamespaceOrTypeSymbol, ByVal name As String, ByVal options As LookupOptions, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
			options = options Or LookupOptions.IgnoreExtensionMethods
			Me.Lookup(lookupResult, container, [String].Concat(name, "Attribute"), options, useSiteInfo)
			If (lookupResult.IsClear OrElse lookupResult.IsWrongArity) Then
				lookupResult.Clear()
				Me.Lookup(lookupResult, container, name, options, useSiteInfo)
			End If
			If (lookupResult.IsGood) Then
				Me.CheckAttributeTypeViability(lookupResult, useSiteInfo)
			End If
		End Sub

		Friend Sub LookupExtensionMethods(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal container As TypeSymbol, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
			options = Me.BinderSpecificLookupOptions(options)
			Binder.MemberLookup.LookupForExtensionMethods(lookupResult, container, name, arity, options, Me, useSiteInfo)
		End Sub

		Friend Overridable Sub LookupInSingleBinder(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, ByVal originalBinder As Binder, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
			lookupResult.Clear()
		End Sub

		Friend Overridable Function LookupLabelByNameToken(ByVal labelName As Microsoft.CodeAnalysis.SyntaxToken) As LabelSymbol
			Return Me.ContainingBinder.LookupLabelByNameToken(labelName)
		End Function

		Friend Sub LookupMember(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal container As NamespaceOrTypeSymbol, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
			options = Me.BinderSpecificLookupOptions(options)
			Binder.MemberLookup.Lookup(lookupResult, container, name, arity, options, Me, useSiteInfo)
		End Sub

		Friend Sub LookupMember(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal container As TypeSymbol, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
			options = Me.BinderSpecificLookupOptions(options)
			Dim instance As Microsoft.CodeAnalysis.VisualBasic.LookupResult = Microsoft.CodeAnalysis.VisualBasic.LookupResult.GetInstance()
			Binder.MemberLookup.Lookup(lookupResult, container, name, arity, options, Me, instance, useSiteInfo)
			instance.Free()
		End Sub

		Friend Sub LookupMember(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal container As NamespaceSymbol, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
			options = Me.BinderSpecificLookupOptions(options)
			Binder.MemberLookup.Lookup(lookupResult, container, name, arity, options, Me, useSiteInfo)
		End Sub

		Friend Sub LookupMemberImmediate(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal container As NamespaceSymbol, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
			options = Me.BinderSpecificLookupOptions(options)
			Binder.MemberLookup.LookupImmediate(lookupResult, container, name, arity, options, Me, useSiteInfo)
		End Sub

		Friend Sub LookupMemberInModules(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal container As NamespaceSymbol, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
			options = Me.BinderSpecificLookupOptions(options)
			Binder.MemberLookup.LookupInModules(lookupResult, container, name, arity, options, Me, useSiteInfo)
		End Sub

		Private Function LookupQueryOperator(ByVal node As SyntaxNode, ByVal source As BoundExpression, ByVal operatorName As String, ByVal typeArgumentsOpt As BoundTypeArguments, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup
			Dim instance As LookupResult = LookupResult.GetInstance()
			Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
			Me.LookupMember(instance, source.Type, operatorName, 0, LookupOptions.MustBeInstance Or LookupOptions.AllMethodsOfAnyArity Or LookupOptions.MethodsOnly, newCompoundUseSiteInfo)
			Dim boundMethodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup = Nothing
			If (Not instance.IsClear AndAlso (instance.Kind = LookupResultKind.Good OrElse instance.Kind = LookupResultKind.Inaccessible)) Then
				boundMethodGroup = Me.CreateBoundMethodGroup(node, instance, LookupOptions.MustBeInstance Or LookupOptions.AllMethodsOfAnyArity Or LookupOptions.MethodsOnly, diagnostics.AccumulatesDependencies, source, typeArgumentsOpt, QualificationKind.QualifiedViaValue, False).MakeCompilerGenerated()
			End If
			diagnostics.Add(node, newCompoundUseSiteInfo)
			instance.Free()
			Return boundMethodGroup
		End Function

		Friend Overridable Function LookupXmlNamespace(ByVal prefix As String, ByVal ignoreXmlNodes As Boolean, <Out> ByRef [namespace] As String, <Out> ByRef fromImports As Boolean) As Boolean
			Return Me.m_containingBinder.LookupXmlNamespace(prefix, ignoreXmlNodes, [namespace], fromImports)
		End Function

		Private Function MakeArgsRValues(ByVal invocation As BoundLateInvocation, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundLateInvocation
			Dim argumentsOpt As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = invocation.ArgumentsOpt
			If (Not argumentsOpt.IsEmpty) Then
				Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = Nothing
				Dim length As Integer = argumentsOpt.Length - 1
				Dim num As Integer = 0
				Do
					Dim item As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = argumentsOpt(num)
					Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.MakeRValue(item, diagnostics)
					If (instance Is Nothing AndAlso item <> boundExpression) Then
						instance = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance()
						instance.AddRange(argumentsOpt, num)
					End If
					If (instance IsNot Nothing) Then
						instance.Add(boundExpression)
					End If
					num = num + 1
				Loop While num <= length
				If (instance IsNot Nothing) Then
					invocation = invocation.Update(invocation.Member, instance.ToImmutableAndFree(), invocation.ArgumentNamesOpt, invocation.AccessKind, invocation.MethodOrPropertyGroupOpt, invocation.Type)
				End If
			End If
			Return invocation
		End Function

		Friend Function MakeRValue(ByVal expr As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			If (expr.Kind = BoundKind.Parenthesized AndAlso Not expr.IsNothingLiteral()) Then
				Dim boundParenthesized As Microsoft.CodeAnalysis.VisualBasic.BoundParenthesized = DirectCast(expr, Microsoft.CodeAnalysis.VisualBasic.BoundParenthesized)
				Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.MakeRValue(boundParenthesized.Expression, diagnostics)
				boundExpression = boundParenthesized.Update(boundExpression1, boundExpression1.Type)
			ElseIf (expr.Kind <> BoundKind.XmlMemberAccess) Then
				expr = Me.MakeValue(expr, diagnostics)
				If (expr.HasErrors) Then
					boundExpression = expr.MakeRValue()
				ElseIf (expr.Type IsNot Nothing) Then
					If (expr.IsLValue) Then
						expr = expr.MakeRValue()
					ElseIf (expr.Kind = BoundKind.PropertyAccess) Then
						Dim boundPropertyAccess As Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess = DirectCast(expr, Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess)
						Dim mostDerivedGetMethod As MethodSymbol = boundPropertyAccess.PropertySymbol.GetMostDerivedGetMethod()
						Binder.ReportUseSite(diagnostics, expr.Syntax, mostDerivedGetMethod)
						Me.ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagnostics, mostDerivedGetMethod, expr.Syntax)
						Dim accessKind As PropertyAccessKind = boundPropertyAccess.AccessKind
						If (accessKind = PropertyAccessKind.Unknown) Then
							Me.WarnOnRecursiveAccess(boundPropertyAccess, PropertyAccessKind.[Get], diagnostics)
							expr = boundPropertyAccess.SetAccessKind(PropertyAccessKind.[Get])
						ElseIf (accessKind <> PropertyAccessKind.[Get]) Then
							Throw ExceptionUtilities.UnexpectedValue(boundPropertyAccess.AccessKind)
						End If
					ElseIf (expr.IsLateBound()) Then
						Dim lateBoundAccessKind As Microsoft.CodeAnalysis.VisualBasic.LateBoundAccessKind = expr.GetLateBoundAccessKind()
						If (lateBoundAccessKind = Microsoft.CodeAnalysis.VisualBasic.LateBoundAccessKind.Unknown) Then
							expr = expr.SetLateBoundAccessKind(Microsoft.CodeAnalysis.VisualBasic.LateBoundAccessKind.[Get])
						ElseIf (lateBoundAccessKind <> Microsoft.CodeAnalysis.VisualBasic.LateBoundAccessKind.[Get]) Then
							Throw ExceptionUtilities.UnexpectedValue(expr.GetLateBoundAccessKind())
						End If
					End If
					boundExpression = expr
				Else
					boundExpression = Me.ReclassifyExpression(expr, diagnostics)
				End If
			Else
				Dim boundXmlMemberAccess As Microsoft.CodeAnalysis.VisualBasic.BoundXmlMemberAccess = DirectCast(expr, Microsoft.CodeAnalysis.VisualBasic.BoundXmlMemberAccess)
				Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.MakeRValue(boundXmlMemberAccess.MemberAccess, diagnostics)
				boundExpression = boundXmlMemberAccess.Update(boundExpression2)
			End If
			Return boundExpression
		End Function

		Private Function MakeRValueAndIgnoreDiagnostics(ByVal expr As BoundExpression) As BoundExpression
			expr = Me.MakeRValue(expr, Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded)
			Return expr
		End Function

		Private Function MakeValue(ByVal expr As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			' 
			' Current member / type: Microsoft.CodeAnalysis.VisualBasic.BoundExpression Microsoft.CodeAnalysis.VisualBasic.Binder::MakeValue(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: Microsoft.CodeAnalysis.VisualBasic.BoundExpression MakeValue(Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Function

		Private Function MakeVarianceConversionSuggestion(ByVal convKind As ConversionKind, ByVal location As SyntaxNode, ByVal sourceType As TypeSymbol, ByVal targetType As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal justWarn As Boolean) As Boolean
			Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
			Dim flag As Boolean = Me.MakeVarianceConversionSuggestion(convKind, location, sourceType, targetType, diagnostics, newCompoundUseSiteInfo, justWarn)
			diagnostics.AddDependencies(newCompoundUseSiteInfo)
			Return flag
		End Function

		Private Function MakeVarianceConversionSuggestion(ByVal convKind As ConversionKind, ByVal location As SyntaxNode, ByVal sourceType As TypeSymbol, ByVal targetType As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol), ByVal justWarn As Boolean) As Boolean
			' 
			' Current member / type: System.Boolean Microsoft.CodeAnalysis.VisualBasic.Binder::MakeVarianceConversionSuggestion(Microsoft.CodeAnalysis.VisualBasic.ConversionKind,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag,Microsoft.CodeAnalysis.CompoundUseSiteInfo`1<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&,System.Boolean)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: System.Boolean MakeVarianceConversionSuggestion(Microsoft.CodeAnalysis.VisualBasic.ConversionKind,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag,Microsoft.CodeAnalysis.CompoundUseSiteInfo<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&,System.Boolean)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Function

		Friend Shared Function MapKeywordToFlag(ByVal syntax As Microsoft.CodeAnalysis.SyntaxToken) As SourceMemberFlags
			Dim sourceMemberFlag As SourceMemberFlags
			Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = syntax.Kind()
			If (syntaxKind <= Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotInheritableKeyword) Then
				If (syntaxKind <= Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FriendKeyword) Then
					If (syntaxKind <= Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DefaultKeyword) Then
						If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ConstKeyword) Then
							sourceMemberFlag = SourceMemberFlags.[Const]
						Else
							If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DefaultKeyword) Then
								sourceMemberFlag = SourceMemberFlags.None
								Return sourceMemberFlag
							End If
							sourceMemberFlag = SourceMemberFlags.[Default]
						End If
					ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DimKeyword) Then
						sourceMemberFlag = SourceMemberFlags.[Dim]
					Else
						If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FriendKeyword) Then
							sourceMemberFlag = SourceMemberFlags.None
							Return sourceMemberFlag
						End If
						sourceMemberFlag = SourceMemberFlags.[Friend]
					End If
				ElseIf (syntaxKind <= Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MustOverrideKeyword) Then
					If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MustInheritKeyword) Then
						sourceMemberFlag = SourceMemberFlags.[MustInherit]
					Else
						If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.MustOverrideKeyword) Then
							sourceMemberFlag = SourceMemberFlags.None
							Return sourceMemberFlag
						End If
						sourceMemberFlag = SourceMemberFlags.[MustOverride]
					End If
				ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NarrowingKeyword) Then
					sourceMemberFlag = SourceMemberFlags.[Narrowing]
				Else
					If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotInheritableKeyword) Then
						sourceMemberFlag = SourceMemberFlags.None
						Return sourceMemberFlag
					End If
					sourceMemberFlag = SourceMemberFlags.[NotInheritable]
				End If
			ElseIf (syntaxKind <= Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WideningKeyword) Then
				If (syntaxKind > Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ReadOnlyKeyword) Then
					Select Case syntaxKind
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ShadowsKeyword
							sourceMemberFlag = SourceMemberFlags.[Shadows]
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SharedKeyword
							sourceMemberFlag = SourceMemberFlags.[Shared]
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ShortKeyword
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleKeyword
							sourceMemberFlag = SourceMemberFlags.None
							Return sourceMemberFlag
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.StaticKeyword
							sourceMemberFlag = SourceMemberFlags.[Static]
							Exit Select
						Case Else
							If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WideningKeyword) Then
								sourceMemberFlag = SourceMemberFlags.[Widening]
								Exit Select
							Else
								sourceMemberFlag = SourceMemberFlags.None
								Return sourceMemberFlag
							End If
					End Select
				ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotOverridableKeyword) Then
					sourceMemberFlag = SourceMemberFlags.[NotOverridable]
				Else
					Select Case syntaxKind
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OverloadsKeyword
							sourceMemberFlag = SourceMemberFlags.[Overloads]
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OverridableKeyword
							sourceMemberFlag = SourceMemberFlags.[Overridable]
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OverridesKeyword
							sourceMemberFlag = SourceMemberFlags.[Overrides]
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ParamArrayKeyword
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PropertyKeyword
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndIfStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndUsingStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndWithStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndGetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSetStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndPropertyStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndOperatorStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndAddHandlerStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndRemoveHandlerStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotKeyword Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NothingKeyword Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotInheritableKeyword Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotOverridableKeyword Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ObjectKeyword Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OfKeyword Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OverridesKeyword Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ParamArrayKeyword Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PartialKeyword Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PrivateKeyword Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PropertyKeyword Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ProtectedKeyword Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PublicKeyword
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndSelectStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndFunctionStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EndRaiseEventStatement Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NotKeyword Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OnKeyword Or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.OverridesKeyword
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.RaiseEventKeyword
							sourceMemberFlag = SourceMemberFlags.None
							Return sourceMemberFlag
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PartialKeyword
							sourceMemberFlag = SourceMemberFlags.[Partial]
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PrivateKeyword
							sourceMemberFlag = SourceMemberFlags.[Private]
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ProtectedKeyword
							sourceMemberFlag = SourceMemberFlags.[Protected]
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PublicKeyword
							sourceMemberFlag = SourceMemberFlags.[Public]
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ReadOnlyKeyword
							sourceMemberFlag = SourceMemberFlags.[ReadOnly]
							Exit Select
						Case Else
							sourceMemberFlag = SourceMemberFlags.None
							Return sourceMemberFlag
					End Select
				End If
			ElseIf (syntaxKind <= Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WriteOnlyKeyword) Then
				If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WithEventsKeyword) Then
					sourceMemberFlag = SourceMemberFlags.[WithEvents]
				Else
					If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.WriteOnlyKeyword) Then
						sourceMemberFlag = SourceMemberFlags.None
						Return sourceMemberFlag
					End If
					sourceMemberFlag = SourceMemberFlags.[WriteOnly]
				End If
			ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AsyncKeyword) Then
				sourceMemberFlag = SourceMemberFlags.Async
			Else
				If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IteratorKeyword) Then
					sourceMemberFlag = SourceMemberFlags.None
					Return sourceMemberFlag
				End If
				sourceMemberFlag = SourceMemberFlags.Iterator
			End If
			Return sourceMemberFlag
		End Function

		Private Sub MarkEmbeddedTypeReferencedFromGetTypeExpression(ByVal expression As BoundGetType)
			Dim type As TypeSymbol = expression.SourceType.Type
			If (type.IsEmbedded) Then
				Me.Compilation.EmbeddedSymbolManager.MarkSymbolAsReferenced(type)
			End If
		End Sub

		Private Sub MarkEmbeddedTypeReferenceIfNeeded(ByVal expression As BoundExpression)
			If (Me.Compilation.EmbeddedSymbolManager.Embedded <> EmbeddedSymbolKind.None AndAlso Not expression.HasErrors AndAlso expression.Syntax.SyntaxTree IsNot Nothing AndAlso Me.Compilation.ContainsSyntaxTree(expression.Syntax.SyntaxTree)) Then
				If (expression.Kind = BoundKind.[GetType]) Then
					Me.MarkEmbeddedTypeReferencedFromGetTypeExpression(DirectCast(expression, BoundGetType))
					Return
				End If
				If (expression.Kind = BoundKind.ArrayCreation) Then
					Dim initializerOpt As BoundArrayInitialization = DirectCast(expression, BoundArrayCreation).InitializerOpt
					If (initializerOpt IsNot Nothing) Then
						Dim enumerator As ImmutableArray(Of BoundExpression).Enumerator = initializerOpt.Initializers.GetEnumerator()
						While enumerator.MoveNext()
							Me.MarkEmbeddedTypeReferenceIfNeeded(enumerator.Current)
						End While
					End If
				End If
			End If
		End Sub

		Private Function MatchesForEachCollectionDesignPattern(ByVal collectionType As TypeSymbol, ByVal collection As BoundExpression, <Out> ByRef currentType As TypeSymbol, <Out> ByRef boundGetEnumeratorCall As BoundExpression, <Out> ByRef boundEnumeratorPlaceholder As BoundLValuePlaceholder, <Out> ByRef boundMoveNextCall As BoundExpression, <Out> ByRef boundCurrentAccess As BoundExpression, <Out> ByRef collectionPlaceholder As BoundRValuePlaceholder, ByVal temporaryDiagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
			Dim flag As Boolean
			currentType = Nothing
			boundGetEnumeratorCall = Nothing
			boundEnumeratorPlaceholder = Nothing
			boundMoveNextCall = Nothing
			boundCurrentAccess = Nothing
			Dim syntax As SyntaxNode = collection.Syntax
			If (collection.IsNothingLiteral() OrElse collectionType.Kind <> SymbolKind.ArrayType AndAlso collectionType.Kind <> SymbolKind.NamedType AndAlso collectionType.Kind <> SymbolKind.TypeParameter) Then
				flag = False
			Else
				Dim lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult = New Microsoft.CodeAnalysis.VisualBasic.LookupResult()
				If (Me.GetMemberIfMatchesRequirements("GetEnumerator", collectionType, Binder.s_isFunctionWithoutArguments, lookupResult, syntax, temporaryDiagnostics)) Then
					collectionPlaceholder = New BoundRValuePlaceholder(syntax, collection.Type)
					Dim boundPropertyGroup As BoundMethodOrPropertyGroup = Me.CreateBoundMethodGroup(syntax, lookupResult, LookupOptions.AllMethodsOfAnyArity, temporaryDiagnostics.AccumulatesDependencies, collectionPlaceholder, Nothing, QualificationKind.QualifiedViaValue, False)
					boundGetEnumeratorCall = Me.CreateBoundInvocationExpressionFromMethodOrPropertyGroup(syntax, boundPropertyGroup, temporaryDiagnostics)
					If (Not boundGetEnumeratorCall.HasErrors) Then
						Dim type As TypeSymbol = boundGetEnumeratorCall.Type
						boundEnumeratorPlaceholder = New BoundLValuePlaceholder(syntax, type)
						If (Me.GetMemberIfMatchesRequirements("MoveNext", type, Binder.s_isFunctionWithoutArguments, lookupResult, syntax, temporaryDiagnostics)) Then
							boundPropertyGroup = Me.CreateBoundMethodGroup(syntax, lookupResult, LookupOptions.AllMethodsOfAnyArity, temporaryDiagnostics.AccumulatesDependencies, boundEnumeratorPlaceholder, Nothing, QualificationKind.QualifiedViaValue, False)
							boundMoveNextCall = Me.CreateBoundInvocationExpressionFromMethodOrPropertyGroup(syntax, boundPropertyGroup, temporaryDiagnostics)
							If (boundMoveNextCall.HasErrors OrElse boundMoveNextCall.Kind <> BoundKind.[Call] OrElse DirectCast(boundMoveNextCall, BoundCall).Method.OriginalDefinition.ReturnType.SpecialType <> SpecialType.System_Boolean) Then
								temporaryDiagnostics.Clear()
								flag = False
							ElseIf (Me.GetMemberIfMatchesRequirements("Current", type, Binder.s_isReadablePropertyWithoutArguments, lookupResult, syntax, temporaryDiagnostics)) Then
								boundPropertyGroup = New Microsoft.CodeAnalysis.VisualBasic.BoundPropertyGroup(syntax, lookupResult.Symbols.ToDowncastedImmutable(Of PropertySymbol)(), lookupResult.Kind, boundEnumeratorPlaceholder, QualificationKind.QualifiedViaValue, False)
								boundCurrentAccess = Me.CreateBoundInvocationExpressionFromMethodOrPropertyGroup(syntax, boundPropertyGroup, temporaryDiagnostics)
								If (Not boundCurrentAccess.HasErrors) Then
									currentType = boundCurrentAccess.Type
									flag = True
								Else
									flag = False
								End If
							Else
								flag = False
							End If
						Else
							flag = False
						End If
					Else
						temporaryDiagnostics.Clear()
						flag = False
					End If
				Else
					flag = False
				End If
			End If
			Return flag
		End Function

		Private Function MatchesXmlnsImport(ByVal prefix As String, ByVal [namespace] As String) As Boolean
			Dim flag As Boolean = False
			Dim str As String = Nothing
			If (Not Me.LookupXmlNamespace(prefix, False, str, flag) OrElse Not flag) Then
				Return False
			End If
			Return EmbeddedOperators.CompareString([namespace], str, False) = 0
		End Function

		Private Function MatchesXmlnsImport(ByVal name As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax, ByVal value As String) As Boolean
			Dim flag As Boolean
			Dim str As String = Nothing
			Me.TryGetXmlnsPrefix(name, str, Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded)
			flag = If(str IsNot Nothing, Me.ContainingBinder.MatchesXmlnsImport(str, value), False)
			Return flag
		End Function

		Private Shared Function MergeBoundChildNodesWithObjectInitializerForBadNode(ByVal boundArguments As ImmutableArray(Of BoundExpression), ByVal objectInitializerExpression As BoundObjectInitializerExpressionBase) As ImmutableArray(Of BoundExpression)
			Dim boundExpressions As ImmutableArray(Of BoundExpression) = boundArguments
			If (objectInitializerExpression IsNot Nothing) Then
				boundExpressions = boundExpressions.Add(objectInitializerExpression)
			End If
			Return boundExpressions
		End Function

		Private Shared Function MergeTupleElementNames(ByVal elementNames As ArrayBuilder(Of String), ByVal inferredElementNames As ArrayBuilder(Of String)) As <TupleElementNames(New String() { "names", "inferred" })> ValueTuple(Of ImmutableArray(Of String), ImmutableArray(Of Boolean))
			Dim valueTuple As ValueTuple(Of ImmutableArray(Of String), ImmutableArray(Of Boolean))
			Dim flags As ImmutableArray(Of Boolean)
			Dim func As Func(Of String, Boolean)
			If (elementNames Is Nothing) Then
				If (inferredElementNames IsNot Nothing) Then
					Dim immutable As ImmutableArray(Of String) = inferredElementNames.ToImmutable()
					Dim strs As ImmutableArray(Of String) = immutable
					Dim strs1 As ImmutableArray(Of String) = immutable
					If (Binder._Closure$__.$I237-0 Is Nothing) Then
						func = Function(n As String) CObj(n) <> CObj(Nothing)
						Binder._Closure$__.$I237-0 = func
					Else
						func = Binder._Closure$__.$I237-0
					End If
					valueTuple = New ValueTuple(Of ImmutableArray(Of String), ImmutableArray(Of Boolean))(strs, Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray(Of String, Boolean)(strs1, func))
				Else
					Dim strs2 As ImmutableArray(Of String) = New ImmutableArray(Of String)()
					flags = New ImmutableArray(Of Boolean)()
					valueTuple = New ValueTuple(Of ImmutableArray(Of String), ImmutableArray(Of Boolean))(strs2, flags)
				End If
			ElseIf (inferredElementNames IsNot Nothing) Then
				Dim instance As ArrayBuilder(Of Boolean) = ArrayBuilder(Of Boolean).GetInstance(elementNames.Count)
				Dim count As Integer = elementNames.Count - 1
				Dim num As Integer = 0
				Do
					Dim item As String = inferredElementNames(num)
					If (elementNames(num) IsNot Nothing OrElse item Is Nothing) Then
						instance.Add(False)
					Else
						elementNames(num) = item
						instance.Add(True)
					End If
					num = num + 1
				Loop While num <= count
				valueTuple = New ValueTuple(Of ImmutableArray(Of String), ImmutableArray(Of Boolean))(elementNames.ToImmutable(), instance.ToImmutableAndFree())
			Else
				Dim immutable1 As ImmutableArray(Of String) = elementNames.ToImmutable()
				flags = New ImmutableArray(Of Boolean)()
				valueTuple = New ValueTuple(Of ImmutableArray(Of String), ImmutableArray(Of Boolean))(immutable1, flags)
			End If
			Return valueTuple
		End Function

		Private Shared Function MustProduceFlatCompoundVariable(ByVal operatorsEnumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator) As Boolean
			Dim count As Boolean
			Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind
			Do
			Label1:
				If (operatorsEnumerator.MoveNext()) Then
					syntaxKind = operatorsEnumerator.Current.Kind()
					If (syntaxKind > Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GroupByClause) Then
						Continue Do
					End If
					If (CUShort(syntaxKind) - CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FromClause) <= CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.EmptyStatement)) Then
						Exit Do
					End If
					If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GroupByClause) Then
						count = DirectCast(operatorsEnumerator.Current, Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax).Items.Count = 0
						Return count
					Else
						GoTo Label1
					End If
				Else
					count = True
					Return count
				End If
			Loop While CUShort(syntaxKind) - CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleJoinClause) > CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List) AndAlso syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SelectClause
			count = False
			Return count
		End Function

		Private Shared Function MustProduceFlatCompoundVariable(ByVal groupOrInnerJoin As Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax, ByVal operatorsEnumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator) As Boolean
			Dim flag As Boolean
			Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = groupOrInnerJoin.Parent.Kind()
			If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleJoinClause) Then
				flag = False
			ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GroupJoinClause) Then
				Dim additionalJoins As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax) = DirectCast(groupOrInnerJoin.Parent, Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax).AdditionalJoins
				flag = groupOrInnerJoin = additionalJoins.LastOrDefault()
			Else
				flag = Binder.MustProduceFlatCompoundVariable(operatorsEnumerator)
			End If
			Return flag
		End Function

		Private Function OptimizeLibraryCall(ByVal method As MethodSymbol, ByVal arguments As ImmutableArray(Of BoundExpression), ByVal syntax As SyntaxNode, ByRef hasErrors As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.ConstantValue
			Dim constantValue As Microsoft.CodeAnalysis.ConstantValue
			Dim empty As String
			Dim str As String
			If (arguments.Length <> 1 OrElse Not arguments(0).IsConstant OrElse arguments(0).ConstantValueOpt.IsBad) Then
				constantValue = Nothing
				Return constantValue
			ElseIf (CObj(Me.Compilation.GetWellKnownType(WellKnownType.Microsoft_VisualBasic_Strings)) <> CObj(method.ContainingType)) Then
				constantValue = Nothing
			ElseIf (Me.IsWellKnownTypeMember(WellKnownMember.Microsoft_VisualBasic_Strings__AscWCharInt32, method) OrElse Me.IsWellKnownTypeMember(WellKnownMember.Microsoft_VisualBasic_Strings__AscWStringInt32, method)) Then
				Dim constantValueOpt As Microsoft.CodeAnalysis.ConstantValue = arguments(0).ConstantValueOpt
				If (Not constantValueOpt.IsNull) Then
					empty = If(Not constantValueOpt.IsChar, constantValueOpt.StringValue, Microsoft.VisualBasic.CompilerServices.Conversions.ToString(constantValueOpt.CharValue))
				Else
					empty = [String].Empty
				End If
				If (Not empty.IsEmpty()) Then
					constantValue = Microsoft.CodeAnalysis.ConstantValue.Create(Strings.AscW(empty))
				Else
					Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_CannotConvertValue2, New [Object]() { empty, method.ReturnType })
					hasErrors = True
					constantValue = Nothing
				End If
			ElseIf (Me.IsWellKnownTypeMember(WellKnownMember.Microsoft_VisualBasic_Strings__ChrWInt32Char, method)) Then
				Dim int32Value As Integer = arguments(0).ConstantValueOpt.Int32Value
				If (int32Value < -32768 OrElse int32Value > 65535) Then
					Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_CannotConvertValue2, New [Object]() { int32Value, method.ReturnType })
					hasErrors = True
					constantValue = Nothing
				Else
					constantValue = Microsoft.CodeAnalysis.ConstantValue.Create(Strings.ChrW(int32Value))
				End If
			ElseIf (Me.IsWellKnownTypeMember(WellKnownMember.Microsoft_VisualBasic_Strings__AscCharInt32, method) OrElse Me.IsWellKnownTypeMember(WellKnownMember.Microsoft_VisualBasic_Strings__AscStringInt32, method)) Then
				Dim constantValueOpt1 As Microsoft.CodeAnalysis.ConstantValue = arguments(0).ConstantValueOpt
				If (Not constantValueOpt1.IsNull) Then
					str = If(Not constantValueOpt1.IsChar, constantValueOpt1.StringValue, Microsoft.VisualBasic.CompilerServices.Conversions.ToString(constantValueOpt1.CharValue))
				Else
					str = [String].Empty
				End If
				If (Not str.IsEmpty()) Then
					Dim num As Integer = Strings.AscW(str)
					If (num >= 128) Then
						constantValue = Nothing
					Else
						constantValue = Microsoft.CodeAnalysis.ConstantValue.Create(num)
					End If
				Else
					Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_CannotConvertValue2, New [Object]() { str, method.ReturnType })
					hasErrors = True
					constantValue = Nothing
				End If
			ElseIf (Me.IsWellKnownTypeMember(WellKnownMember.Microsoft_VisualBasic_Strings__ChrInt32Char, method)) Then
				Dim int32Value1 As Integer = arguments(0).ConstantValueOpt.Int32Value
				If (int32Value1 < 0 OrElse int32Value1 >= 128) Then
					If (int32Value1 >= -32768 AndAlso int32Value1 <= 65535) Then
						constantValue = Nothing
						Return constantValue
					End If
					Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_CannotConvertValue2, New [Object]() { int32Value1, method.ReturnType })
					hasErrors = True
					constantValue = Nothing
				Else
					constantValue = Microsoft.CodeAnalysis.ConstantValue.Create(Strings.ChrW(int32Value1))
				End If
			Else
				constantValue = Nothing
				Return constantValue
			End If
			Return constantValue
		End Function

		Private Function OptimizeSelectStatement(ByVal selectExpression As BoundRValuePlaceholder, ByVal caseBlockBuilder As ArrayBuilder(Of BoundCaseBlock), ByRef generateSwitchTable As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As ImmutableArray(Of BoundCaseBlock)
			Dim boundCaseClauses As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundCaseClause)
			generateSwitchTable = Me.RecommendSwitchTable(selectExpression, caseBlockBuilder, diagnostics)
			If (Not generateSwitchTable AndAlso caseBlockBuilder.Any()) Then
				Dim specialType As NamedTypeSymbol = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Boolean, selectExpression.Syntax, diagnostics)
				Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundCaseClause) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundCaseClause).GetInstance()
				Dim count As Integer = caseBlockBuilder.Count - 1
				Dim num As Integer = 0
				Do
					Dim item As BoundCaseBlock = caseBlockBuilder(num)
					If (item.Syntax.Kind() <> SyntaxKind.CaseElseBlock AndAlso Not item.CaseStatement.Syntax.IsMissing) Then
						Dim caseStatement As BoundCaseStatement = item.CaseStatement
						Dim syntax As SyntaxNode = caseStatement.Syntax
						Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
						Dim flag As Boolean = False
						Dim enumerator As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundCaseClause).Enumerator = caseStatement.CaseClauses.GetEnumerator()
						While enumerator.MoveNext()
							Dim current As Microsoft.CodeAnalysis.VisualBasic.BoundCaseClause = enumerator.Current
							Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
							Dim boundCaseClause As Microsoft.CodeAnalysis.VisualBasic.BoundCaseClause = Me.ComputeCaseClauseCondition(current, boundExpression1, selectExpression, diagnostics)
							instance.Add(boundCaseClause)
							flag = If(flag, True, Not boundCaseClause.Equals(current))
							boundExpression = If(boundExpression IsNot Nothing, Me.BindBinaryOperator(syntax, boundExpression, boundExpression1, SyntaxKind.OrElseKeyword, BinaryOperatorKind.[OrElse], False, diagnostics, True).MakeCompilerGenerated(), boundExpression1)
						End While
						boundCaseClauses = If(Not flag, caseStatement.CaseClauses, instance.ToImmutable())
						instance.Clear()
						boundExpression = Me.ApplyImplicitConversion(boundExpression.Syntax, specialType, boundExpression, diagnostics, True)
						caseStatement = caseStatement.Update(boundCaseClauses, boundExpression)
						caseBlockBuilder(num) = item.Update(caseStatement, item.Body)
					End If
					num = num + 1
				Loop While num <= count
				instance.Free()
			End If
			Return caseBlockBuilder.ToImmutableAndFree()
		End Function

		Private Function PassArgument(ByVal argument As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal conversionTo As KeyValuePair(Of ConversionKind, MethodSymbol), ByVal forceByValueSemantics As Boolean, ByVal conversionFrom As KeyValuePair(Of ConversionKind, MethodSymbol), ByVal targetType As TypeSymbol, ByVal param As ParameterSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			boundExpression = If(Not param.IsByRef OrElse forceByValueSemantics OrElse Not param.IsExplicitByRef AndAlso (argument.Type Is Nothing OrElse Not argument.Type.IsStringType()), Me.PassArgumentByVal(argument, conversionTo, targetType, diagnostics), Me.PassArgumentByRef(param.IsOut, argument, conversionTo, conversionFrom, targetType, param.Name, diagnostics))
			Return boundExpression
		End Function

		Private Function PassArgumentByRef(ByVal isOutParameter As Boolean, ByVal argument As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal conversionTo As KeyValuePair(Of ConversionKind, MethodSymbol), ByVal conversionFrom As KeyValuePair(Of ConversionKind, MethodSymbol), ByVal targetType As TypeSymbol, ByVal parameterName As String, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim isInitOnly As Boolean
			Dim isLValue As Boolean = argument.IsLValue
			If (isLValue AndAlso argument.Kind = BoundKind.PropertyAccess) Then
				argument = argument.SetAccessKind(PropertyAccessKind.[Get])
			End If
			If (isLValue AndAlso Microsoft.CodeAnalysis.VisualBasic.Conversions.IsIdentityConversion(conversionTo.Key)) Then
				boundExpression = argument
			ElseIf (isLValue OrElse argument.IsSupportingAssignment()) Then
				Dim boundByRefArgumentPlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundByRefArgumentPlaceholder = (New Microsoft.CodeAnalysis.VisualBasic.BoundByRefArgumentPlaceholder(argument.Syntax, isOutParameter, argument.Type, argument.HasErrors)).MakeCompilerGenerated()
				Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.CreateConversionAndReportDiagnostic(argument.Syntax, boundByRefArgumentPlaceholder, conversionTo, False, targetType, diagnostics, Nothing, False)
				Dim boundRValuePlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder = (New Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder(argument.Syntax, targetType)).MakeCompilerGenerated()
				Dim typeOfAssignmentTarget As TypeSymbol = argument.GetTypeOfAssignmentTarget()
				Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.CreateConversionAndReportDiagnostic(argument.Syntax, boundRValuePlaceholder, conversionFrom, False, typeOfAssignmentTarget, diagnostics, parameterName, False).MakeCompilerGenerated()
				If (argument.Kind = BoundKind.LateInvocation) Then
					argument = Me.MakeArgsRValues(DirectCast(argument, BoundLateInvocation), diagnostics)
				End If
				Dim boundAssignmentOperator As Microsoft.CodeAnalysis.VisualBasic.BoundAssignmentOperator = Me.BindAssignment(argument.Syntax, argument, boundExpression2, diagnostics)
				If (Not isLValue) Then
					If (Not argument.IsLateBound()) Then
						Me.WarnOnRecursiveAccess(argument, PropertyAccessKind.[Get], diagnostics)
						argument = argument.SetAccessKind(PropertyAccessKind.[Get] Or PropertyAccessKind.[Set])
					Else
						argument = argument.SetLateBoundAccessKind(LateBoundAccessKind.[Get] Or LateBoundAccessKind.[Set])
					End If
				End If
				boundExpression = (New BoundByRefArgumentWithCopyBack(argument.Syntax, argument, boundExpression1, boundByRefArgumentPlaceholder, boundExpression2, boundRValuePlaceholder, targetType, boundAssignmentOperator.HasErrors)).MakeCompilerGenerated()
			Else
				Dim boundPropertyAccess As Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess = TryCast(argument, Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess)
				If (boundPropertyAccess IsNot Nothing AndAlso boundPropertyAccess.AccessKind <> PropertyAccessKind.[Get]) Then
					Dim setMethod As MethodSymbol = boundPropertyAccess.PropertySymbol.SetMethod
					If (setMethod IsNot Nothing) Then
						isInitOnly = setMethod.IsInitOnly
					Else
						isInitOnly = False
					End If
					If (isInitOnly) Then
						Parser.CheckFeatureAvailability(diagnostics, argument.Syntax.Location, DirectCast(argument.Syntax.SyntaxTree.Options, VisualBasicParseOptions).LanguageVersion, Feature.InitOnlySettersUsage)
					End If
				End If
				boundExpression = Me.PassArgumentByVal(argument, conversionTo, targetType, diagnostics)
			End If
			Return boundExpression
		End Function

		Friend Function PassArgumentByVal(ByVal argument As BoundExpression, ByVal conversion As KeyValuePair(Of ConversionKind, MethodSymbol), ByVal targetType As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			argument = Me.CreateConversionAndReportDiagnostic(argument.Syntax, argument, conversion, False, targetType, diagnostics, Nothing, False)
			Return argument
		End Function

		Private Function PassArguments(ByVal node As SyntaxNode, ByRef candidate As OverloadResolution.CandidateAnalysisResult, ByVal arguments As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As <TupleElementNames(New String() { "Arguments", "DefaultArguments" })> ValueTuple(Of ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression), BitVector)
			Dim item As Integer
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			If (arguments.IsDefault) Then
				arguments = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty
			End If
			Dim parameterCount As Integer = candidate.Candidate.ParameterCount
			Dim instance As ArrayBuilder(Of Integer) = ArrayBuilder(Of Integer).GetInstance(parameterCount, -1)
			Dim boundExpressions As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance(parameterCount)
			Dim null As BitVector = BitVector.Null
			Dim nums As ArrayBuilder(Of Integer) = Nothing
			If (candidate.IsExpandedParamArrayForm) Then
				nums = ArrayBuilder(Of Integer).GetInstance()
			End If
			If (Not candidate.ArgsToParamsOpt.IsDefaultOrEmpty) Then
				Dim argsToParamsOpt As ImmutableArray(Of Integer) = candidate.ArgsToParamsOpt
				Dim length As Integer = argsToParamsOpt.Length - 1
				For i As Integer = 0 To length
					item = argsToParamsOpt(i)
					If (arguments(i).Kind <> BoundKind.OmittedArgument) Then
						If (Not candidate.IsExpandedParamArrayForm OrElse item <> candidate.Candidate.ParameterCount - 1) Then
							instance(item) = i
						Else
							nums.Add(i)
						End If
					End If
				Next

			Else
				Dim num As Integer = parameterCount
				If (candidate.IsExpandedParamArrayForm) Then
					num = num - 1
				End If
				Dim num1 As Integer = Math.Min(num, arguments.Length) - 1
				Dim num2 As Integer = 0
				Do
					If (arguments(num2).Kind <> BoundKind.OmittedArgument) Then
						instance(num2) = num2
					End If
					num2 = num2 + 1
				Loop While num2 <= num1
				If (candidate.IsExpandedParamArrayForm) Then
					Dim length1 As Integer = arguments.Length - 1
					For j As Integer = num To length1
						nums.Add(j)
					Next

				End If
			End If
			Dim kind As Boolean = candidate.Candidate.UnderlyingSymbol.Kind = SymbolKind.[Property]
			Dim num3 As Integer = parameterCount - 1
			item = 0
			Do
				Dim parameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol = candidate.Candidate.Parameters(item)
				Dim type As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = parameterSymbol.Type
				Dim defaultValue As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
				Dim identity As KeyValuePair(Of ConversionKind, MethodSymbol) = Microsoft.CodeAnalysis.VisualBasic.Conversions.Identity
				Dim keyValuePair As KeyValuePair(Of ConversionKind, MethodSymbol) = Microsoft.CodeAnalysis.VisualBasic.Conversions.Identity
				If (Not candidate.IsExpandedParamArrayForm OrElse item <> candidate.Candidate.ParameterCount - 1) Then
					Dim item1 As Integer = instance(item)
					If (item1 = -1) Then
						boundExpression = Nothing
					Else
						boundExpression = arguments(item1)
					End If
					defaultValue = boundExpression
					If (defaultValue IsNot Nothing AndAlso item = candidate.Candidate.ParameterCount - 1 AndAlso parameterSymbol.IsParamArray) Then
						defaultValue = Me.ApplyImplicitConversion(defaultValue.Syntax, type, defaultValue, diagnostics, False)
					ElseIf (item1 > -1) Then
						If (Not candidate.ConversionsOpt.IsDefaultOrEmpty) Then
							identity = candidate.ConversionsOpt(item1)
						End If
						If (Not candidate.ConversionsBackOpt.IsDefaultOrEmpty) Then
							keyValuePair = candidate.ConversionsBackOpt(item1)
						End If
					End If
				Else
					Dim elementType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = DirectCast(type, ArrayTypeSymbol).ElementType
					Dim instance1 As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance(nums.Count)
					Dim count As Integer = nums.Count - 1
					Dim num4 As Integer = 0
					Do
						instance1.Add(Me.PassArgumentByVal(arguments(nums(num4)), If(candidate.ConversionsOpt.IsDefaultOrEmpty, Microsoft.CodeAnalysis.VisualBasic.Conversions.Identity, candidate.ConversionsOpt(nums(num4))), elementType, diagnostics))
						num4 = num4 + 1
					Loop While num4 <= count
					defaultValue = (New BoundArrayCreation(node, True, Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(New Microsoft.CodeAnalysis.VisualBasic.BoundExpression() { (New BoundLiteral(node, ConstantValue.Create(instance1.Count), Me.GetSpecialType(SpecialType.System_Int32, node, diagnostics))).MakeCompilerGenerated() }), (New BoundArrayInitialization(node, instance1.ToImmutableAndFree(), type, False)).MakeCompilerGenerated(), Nothing, ConversionKind.DelegateRelaxationLevelNone, type, False)).MakeCompilerGenerated()
				End If
				Dim flag As Boolean = False
				If (defaultValue Is Nothing) Then
					If (null.IsNull) Then
						null = BitVector.Create(parameterCount)
					End If
					Dim optionalArgument As OverloadResolution.OptionalArgument = candidate.OptionalArguments(item)
					defaultValue = optionalArgument.DefaultValue
					diagnostics.AddDependencies(optionalArgument.Dependencies)
					flag = True
					null(item) = True
					identity = optionalArgument.Conversion
					Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = defaultValue.Type
					If (typeSymbol IsNot Nothing) Then
						Dim useSiteInfo As UseSiteInfo(Of AssemblySymbol) = typeSymbol.GetUseSiteInfo()
						Binder.ReportUseSite(diagnostics, defaultValue.Syntax, useSiteInfo)
					End If
				End If
				Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.PassArgument(defaultValue, identity, kind, keyValuePair, type, parameterSymbol, diagnostics)
				If (flag AndAlso boundExpression1 <> defaultValue) Then
					boundExpression1.SetWasCompilerGenerated()
				End If
				boundExpressions.Add(boundExpression1)
				item = item + 1
			Loop While item <= num3
			If (nums IsNot Nothing) Then
				nums.Free()
			End If
			instance.Free()
			Return New ValueTuple(Of ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression), BitVector)(boundExpressions.ToImmutableAndFree(), null)
		End Function

		Friend Function ReclassifyAddressOf(ByVal addressOfExpression As BoundAddressOfOperator, ByRef delegateResolutionResult As Binder.DelegateResolutionResult, ByVal targetType As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal isForHandles As Boolean, ByVal warnIfResultOfAsyncMethodIsDroppedDueToRelaxation As Boolean) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundDelegateCreationExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim receiverOpt As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			If (Not addressOfExpression.HasErrors) Then
				Dim boundLambda As Microsoft.CodeAnalysis.VisualBasic.BoundLambda = Nothing
				Dim boundRValuePlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder = Nothing
				Dim syntax As SyntaxNode = addressOfExpression.Syntax
				Dim target As Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol = delegateResolutionResult.Target
				Dim reducedFrom As Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol = target.ReducedFrom
				Dim methodGroup As BoundMethodGroup = addressOfExpression.MethodGroup
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = methodGroup.ReceiverOpt
				Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
				If (boundExpression IsNot Nothing AndAlso Not addressOfExpression.HasErrors AndAlso Not Microsoft.CodeAnalysis.ImmutableArrayExtensions.HasAnyErrors(Of Diagnostic)(delegateResolutionResult.Diagnostics.Diagnostics)) Then
					boundExpression = Me.AdjustReceiverTypeOrValue(boundExpression, boundExpression.Syntax, target.IsShared, diagnostics, boundExpression1)
				End If
				If (Me.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.[On] AndAlso Microsoft.CodeAnalysis.VisualBasic.Conversions.IsNarrowingConversion(delegateResolutionResult.DelegateConversions)) Then
					Dim operand As SyntaxNode = addressOfExpression.Syntax
					If (operand.Kind() = SyntaxKind.AddressOfExpression) Then
						operand = DirectCast(operand, Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax).Operand
					End If
					Binder.ReportDelegateBindingMismatchStrictOff(operand, DirectCast(targetType, NamedTypeSymbol), target, diagnostics)
				ElseIf (Microsoft.CodeAnalysis.VisualBasic.Conversions.IsStubRequiredForMethodConversion(delegateResolutionResult.MethodConversions) OrElse reducedFrom IsNot Nothing AndAlso (reducedFrom.Parameters(0).IsByRef OrElse target.ReceiverType.IsTypeParameter() OrElse target.ReceiverType.IsValueType)) Then
					boundLambda = Me.BuildDelegateRelaxationLambda(syntax, methodGroup.Syntax, boundExpression, target, methodGroup.TypeArgumentsOpt, methodGroup.QualificationKind, DirectCast(targetType, NamedTypeSymbol).DelegateInvokeMethod, delegateResolutionResult.DelegateConversions And ConversionKind.DelegateRelaxationLevelMask, (delegateResolutionResult.MethodConversions And MethodConversionKind.AllArgumentsIgnored) <> MethodConversionKind.Identity, warnIfResultOfAsyncMethodIsDroppedDueToRelaxation, diagnostics, boundRValuePlaceholder)
				End If
				Dim methodSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol = delegateResolutionResult.Target
				If (Not isForHandles AndAlso methodSymbol.IsPartialWithoutImplementation()) Then
					Binder.ReportDiagnostic(diagnostics, addressOfExpression.MethodGroup.Syntax, ERRID.ERR_NoPartialMethodInAddressOf1, New [Object]() { methodSymbol })
				End If
				If (boundExpression Is Nothing) Then
					receiverOpt = If(boundExpression1, methodGroup.ReceiverOpt)
				Else
					If (boundExpression.IsPropertyOrXmlPropertyAccess()) Then
						boundExpression = Me.MakeRValue(boundExpression, diagnostics)
					End If
					receiverOpt = Nothing
				End If
				methodGroup = methodGroup.Update(methodGroup.TypeArgumentsOpt, methodGroup.Methods, methodGroup.PendingExtensionMethodsOpt, methodGroup.ResultKind, receiverOpt, methodGroup.QualificationKind)
				boundDelegateCreationExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundDelegateCreationExpression(syntax, boundExpression, methodSymbol, boundLambda, boundRValuePlaceholder, methodGroup, targetType, False)
			Else
				boundDelegateCreationExpression = addressOfExpression
			End If
			Return boundDelegateCreationExpression
		End Function

		Private Function ReclassifyArrayInitialization(ByVal arrayInitialization As BoundArrayInitialization, ByVal elementType As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundArrayInitialization
			Dim instance As ArrayBuilder(Of BoundExpression) = ArrayBuilder(Of BoundExpression).GetInstance()
			Dim enumerator As ImmutableArray(Of BoundExpression).Enumerator = arrayInitialization.Initializers.GetEnumerator()
			While enumerator.MoveNext()
				Dim current As BoundExpression = enumerator.Current
				If (current.Kind <> BoundKind.ArrayInitialization) Then
					current = Me.ApplyImplicitConversion(current.Syntax, elementType, current, diagnostics, False)
				Else
					current = Me.ReclassifyArrayInitialization(DirectCast(current, BoundArrayInitialization), elementType, diagnostics)
				End If
				instance.Add(current)
			End While
			arrayInitialization = New BoundArrayInitialization(arrayInitialization.Syntax, instance.ToImmutableAndFree(), Nothing, False)
			Return arrayInitialization
		End Function

		Private Function ReclassifyArrayLiteralExpression(ByVal conversionSemantics As SyntaxKind, ByVal tree As SyntaxNode, ByVal conv As ConversionKind, ByVal isExplicit As Boolean, ByVal arrayLiteral As BoundArrayLiteral, ByVal destination As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			' 
			' Current member / type: Microsoft.CodeAnalysis.VisualBasic.BoundExpression Microsoft.CodeAnalysis.VisualBasic.Binder::ReclassifyArrayLiteralExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.ConversionKind,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.BoundArrayLiteral,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: Microsoft.CodeAnalysis.VisualBasic.BoundExpression ReclassifyArrayLiteralExpression(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.ConversionKind,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.BoundArrayLiteral,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Function

		Private Function ReclassifyArrayLiteralExpression(ByVal arrayLiteral As BoundArrayLiteral, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Return Me.ApplyImplicitConversion(arrayLiteral.Syntax, arrayLiteral.InferredType, arrayLiteral, diagnostics, False)
		End Function

		Friend Function ReclassifyAsValue(ByVal expr As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundBadVariable As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			If (expr.Kind = BoundKind.ConditionalAccess AndAlso expr.Type Is Nothing) Then
				Dim boundConditionalAccess As Microsoft.CodeAnalysis.VisualBasic.BoundConditionalAccess = DirectCast(expr, Microsoft.CodeAnalysis.VisualBasic.BoundConditionalAccess)
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.MakeRValue(boundConditionalAccess.AccessExpression, diagnostics)
				Dim type As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = boundExpression.Type
				If (Not type.IsErrorType()) Then
					If (type.IsValueType AndAlso Not type.IsRestrictedType()) Then
						If (Not type.IsNullableType()) Then
							type = Me.GetSpecialType(SpecialType.System_Nullable_T, expr.Syntax, diagnostics).Construct(New Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol() { type })
						End If
					ElseIf (Not type.IsReferenceType) Then
						Binder.ReportDiagnostic(diagnostics, boundExpression.Syntax, ERRID.ERR_CannotBeMadeNullable1, New [Object]() { type })
						type = ErrorTypeSymbol.UnknownResultType
					End If
				End If
				boundBadVariable = boundConditionalAccess.Update(boundConditionalAccess.Receiver, boundConditionalAccess.Placeholder, boundExpression, type)
			ElseIf (Not expr.HasErrors) Then
				Dim kind As BoundKind = expr.Kind
				If (kind <= BoundKind.NamespaceExpression) Then
					If (kind = BoundKind.Parenthesized) Then
						If (expr.IsNothingLiteral()) Then
							GoTo Label3
						End If
						boundBadVariable = Me.MakeRValue(expr, diagnostics)
						Return boundBadVariable
					ElseIf (kind = BoundKind.TypeExpression) Then
						Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.TryDefaultInstanceProperty(DirectCast(expr, BoundTypeExpression), diagnostics)
						If (boundExpression1 Is Nothing) Then
							Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = expr.Type
							Binder.ReportDiagnostic(diagnostics, expr.Syntax, Binder.GetTypeNotExpressionErrorId(typeSymbol), New [Object]() { typeSymbol })
							boundBadVariable = New Microsoft.CodeAnalysis.VisualBasic.BoundBadVariable(expr.Syntax, expr, ErrorTypeSymbol.UnknownResultType, True)
							Return boundBadVariable
						End If
						expr = boundExpression1
					Else
						If (kind <> BoundKind.NamespaceExpression) Then
							GoTo Label3
						End If
						Binder.ReportDiagnostic(diagnostics, expr.Syntax, ERRID.ERR_NamespaceNotExpression1, New [Object]() { DirectCast(expr, BoundNamespaceExpression).NamespaceSymbol })
						boundBadVariable = New Microsoft.CodeAnalysis.VisualBasic.BoundBadVariable(expr.Syntax, expr, ErrorTypeSymbol.UnknownResultType, True)
						Return boundBadVariable
					End If
				ElseIf (CByte(kind) - CByte(BoundKind.MethodGroup) <= CByte(BoundKind.OmittedArgument)) Then
					Dim boundMethodOrPropertyGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodOrPropertyGroup = DirectCast(expr, Microsoft.CodeAnalysis.VisualBasic.BoundMethodOrPropertyGroup)
					If (Binder.IsGroupOfConstructors(boundMethodOrPropertyGroup)) Then
						Binder.ReportDiagnostic(diagnostics, boundMethodOrPropertyGroup.Syntax, ERRID.ERR_InvalidConstructorCall)
						boundBadVariable = New Microsoft.CodeAnalysis.VisualBasic.BoundBadVariable(expr.Syntax, expr, ErrorTypeSymbol.UnknownResultType, True)
						Return boundBadVariable
					End If
					Dim syntax As Microsoft.CodeAnalysis.SyntaxNode = expr.Syntax
					Dim syntaxNode As Microsoft.CodeAnalysis.SyntaxNode = expr.Syntax
					Dim typeCharacter As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter = Binder.ExtractTypeCharacter(expr.Syntax)
					Dim sNoArguments As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = Binder.s_noArguments
					Dim strs As ImmutableArray(Of String) = New ImmutableArray(Of String)()
					expr = Me.BindInvocationExpression(syntax, syntaxNode, typeCharacter, boundMethodOrPropertyGroup, sNoArguments, strs, diagnostics, expr.Syntax, False, False, False, Nothing, False)
				ElseIf (kind = BoundKind.EventAccess) Then
					Binder.ReportDiagnostic(diagnostics, expr.Syntax, ERRID.ERR_CannotCallEvent1, New [Object]() { DirectCast(expr, BoundEventAccess).EventSymbol })
					boundBadVariable = New Microsoft.CodeAnalysis.VisualBasic.BoundBadVariable(expr.Syntax, expr, ErrorTypeSymbol.UnknownResultType, True)
					Return boundBadVariable
				Else
					If (kind <> BoundKind.Label) Then
						GoTo Label3
					End If
					Binder.ReportDiagnostic(diagnostics, expr.Syntax, ERRID.ERR_VoidValue, New [Object]() { DirectCast(expr, BoundLabel).Label.Name })
					boundBadVariable = New Microsoft.CodeAnalysis.VisualBasic.BoundBadVariable(expr.Syntax, expr, ErrorTypeSymbol.UnknownResultType, True)
					Return boundBadVariable
				End If
			Label3:
				boundBadVariable = expr
			Else
				boundBadVariable = expr
			End If
			Return boundBadVariable
		End Function

		Private Function ReclassifyEmptyArrayInitialization(ByVal arrayLiteral As BoundArrayLiteral, ByVal rank As Integer) As Microsoft.CodeAnalysis.VisualBasic.BoundArrayInitialization
			Dim boundArrayInitialization As Microsoft.CodeAnalysis.VisualBasic.BoundArrayInitialization
			Dim initializer As Microsoft.CodeAnalysis.VisualBasic.BoundArrayInitialization = arrayLiteral.Initializer
			If (rank <> 1) Then
				Dim empty As ImmutableArray(Of BoundExpression) = ImmutableArray(Of BoundExpression).Empty
				Dim num As Integer = rank - 1
				Dim num1 As Integer = 1
				Do
					initializer = (New Microsoft.CodeAnalysis.VisualBasic.BoundArrayInitialization(initializer.Syntax, empty, Nothing, False)).MakeCompilerGenerated()
					empty = ImmutableArray.Create(Of BoundExpression)(initializer)
					num1 = num1 + 1
				Loop While num1 <= num
				boundArrayInitialization = New Microsoft.CodeAnalysis.VisualBasic.BoundArrayInitialization(initializer.Syntax, empty, Nothing, False)
			Else
				boundArrayInitialization = initializer
			End If
			Return boundArrayInitialization
		End Function

		Private Function ReclassifyExpression(ByRef argument As BoundExpression, ByVal conversionSemantics As SyntaxKind, ByVal tree As SyntaxNode, ByVal convKind As ConversionKind, ByVal isExplicit As Boolean, ByVal targetType As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
			Dim kind As Boolean
			Dim optionStrictOffBinder As Binder
			Dim boundKind As Microsoft.CodeAnalysis.VisualBasic.BoundKind = argument.Kind
			If (boundKind > Microsoft.CodeAnalysis.VisualBasic.BoundKind.TupleLiteral) Then
				If (boundKind <= Microsoft.CodeAnalysis.VisualBasic.BoundKind.UnboundLambda) Then
					If (boundKind = Microsoft.CodeAnalysis.VisualBasic.BoundKind.ArrayLiteral) Then
						argument = Me.ReclassifyArrayLiteralExpression(conversionSemantics, tree, convKind, isExplicit, DirectCast(argument, BoundArrayLiteral), targetType, diagnostics)
						kind = True
						Return kind
					Else
						If (boundKind <> Microsoft.CodeAnalysis.VisualBasic.BoundKind.UnboundLambda) Then
							kind = False
							Return kind
						End If
						argument = Me.ReclassifyUnboundLambdaExpression(DirectCast(argument, UnboundLambda), conversionSemantics, tree, convKind, isExplicit, targetType, diagnostics)
						kind = True
						Return kind
					End If
				ElseIf (boundKind = Microsoft.CodeAnalysis.VisualBasic.BoundKind.QueryLambda) Then
					argument = Me.ReclassifyQueryLambdaExpression(DirectCast(argument, BoundQueryLambda), conversionSemantics, tree, convKind, isExplicit, targetType, diagnostics)
					kind = True
					Return kind
				Else
					If (boundKind <> Microsoft.CodeAnalysis.VisualBasic.BoundKind.InterpolatedStringExpression) Then
						kind = False
						Return kind
					End If
					argument = Me.ReclassifyInterpolatedStringExpression(conversionSemantics, tree, convKind, isExplicit, DirectCast(argument, BoundInterpolatedStringExpression), targetType, diagnostics)
					kind = argument.Kind = Microsoft.CodeAnalysis.VisualBasic.BoundKind.Conversion
					Return kind
				End If
			ElseIf (boundKind > Microsoft.CodeAnalysis.VisualBasic.BoundKind.AddressOfOperator) Then
				If (boundKind = Microsoft.CodeAnalysis.VisualBasic.BoundKind.LateAddressOfOperator) Then
					Dim boundLateAddressOfOperator As Microsoft.CodeAnalysis.VisualBasic.BoundLateAddressOfOperator = DirectCast(argument, Microsoft.CodeAnalysis.VisualBasic.BoundLateAddressOfOperator)
					If (targetType.TypeKind <> Microsoft.CodeAnalysis.TypeKind.[Delegate] AndAlso targetType.TypeKind <> Microsoft.CodeAnalysis.TypeKind.[Error]) Then
						Binder.ReportDiagnostic(diagnostics, boundLateAddressOfOperator.Syntax, ERRID.ERR_AddressOfNotDelegate1, New [Object]() { targetType })
					End If
					argument = boundLateAddressOfOperator.Update(boundLateAddressOfOperator.Binder, boundLateAddressOfOperator.MemberAccess, targetType)
					kind = True
					Return kind
				Else
					If (boundKind <> Microsoft.CodeAnalysis.VisualBasic.BoundKind.TupleLiteral) Then
						kind = False
						Return kind
					End If
					Dim boundTupleLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundTupleLiteral = DirectCast(argument, Microsoft.CodeAnalysis.VisualBasic.BoundTupleLiteral)
					argument = Me.ReclassifyTupleLiteral(convKind, tree, isExplicit, boundTupleLiteral, targetType, diagnostics)
					kind = argument <> boundTupleLiteral
					Return kind
				End If
			ElseIf (boundKind <> Microsoft.CodeAnalysis.VisualBasic.BoundKind.Parenthesized) Then
				If (boundKind = Microsoft.CodeAnalysis.VisualBasic.BoundKind.AddressOfOperator) Then
					Dim delegateResolutionResult As Binder.DelegateResolutionResult = New Binder.DelegateResolutionResult()
					Dim boundAddressOfOperator As Microsoft.CodeAnalysis.VisualBasic.BoundAddressOfOperator = DirectCast(argument, Microsoft.CodeAnalysis.VisualBasic.BoundAddressOfOperator)
					If (Not boundAddressOfOperator.GetDelegateResolutionResult(targetType, delegateResolutionResult)) Then
						kind = False
						Return kind
					End If
					diagnostics.AddRange(delegateResolutionResult.Diagnostics, False)
					Dim hasErrors As Boolean = True
					If (Microsoft.CodeAnalysis.VisualBasic.Conversions.ConversionExists(delegateResolutionResult.DelegateConversions)) Then
						If (Not isExplicit OrElse Me.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.Off) Then
							optionStrictOffBinder = Me
						Else
							optionStrictOffBinder = New Binder.OptionStrictOffBinder(Me)
						End If
						argument = optionStrictOffBinder.ReclassifyAddressOf(boundAddressOfOperator, delegateResolutionResult, targetType, diagnostics, False, If(isExplicit, False, tree.Kind() <> SyntaxKind.ObjectCreationExpression))
						hasErrors = argument.HasErrors
					End If
					If (argument.Kind <> Microsoft.CodeAnalysis.VisualBasic.BoundKind.DelegateCreationExpression) Then
						If (conversionSemantics = SyntaxKind.CTypeKeyword) Then
							argument = New BoundConversion(tree, argument, convKind, False, isExplicit, targetType, hasErrors)
						ElseIf (conversionSemantics <> SyntaxKind.DirectCastKeyword) Then
							If (conversionSemantics <> SyntaxKind.TryCastKeyword) Then
								Throw ExceptionUtilities.UnexpectedValue(conversionSemantics)
							End If
							argument = New BoundTryCast(tree, argument, convKind, targetType, hasErrors)
						Else
							argument = New BoundDirectCast(tree, argument, convKind, targetType, hasErrors)
						End If
					End If
					kind = True
					Return kind
				End If
			ElseIf (argument.Type Is Nothing AndAlso Not argument.IsNothingLiteral()) Then
				Dim boundParenthesized As Microsoft.CodeAnalysis.VisualBasic.BoundParenthesized = DirectCast(argument, Microsoft.CodeAnalysis.VisualBasic.BoundParenthesized)
				Dim expression As BoundExpression = boundParenthesized.Expression
				If (Not Me.ReclassifyExpression(expression, conversionSemantics, expression.Syntax, convKind, isExplicit, targetType, diagnostics)) Then
					kind = False
					Return kind
				End If
				argument = boundParenthesized.Update(expression, expression.Type)
				kind = True
				Return kind
			End If
			kind = False
			Return kind
		End Function

		Friend Function ReclassifyExpression(ByVal expr As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundConversion As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim kind As BoundKind
			Dim methods As ImmutableArray(Of MethodSymbol)
			If (Not expr.IsNothingLiteral()) Then
				kind = expr.Kind
				If (kind <= BoundKind.AddressOfOperator) Then
					If (kind <> BoundKind.Parenthesized) Then
						GoTo Label3
					End If
					Dim boundParenthesized As Microsoft.CodeAnalysis.VisualBasic.BoundParenthesized = DirectCast(expr, Microsoft.CodeAnalysis.VisualBasic.BoundParenthesized)
					Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.ReclassifyExpression(boundParenthesized.Expression, diagnostics)
					boundConversion = boundParenthesized.Update(boundExpression, boundExpression.Type)
					Return boundConversion
				ElseIf (kind = BoundKind.TupleLiteral) Then
					Dim boundTupleLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundTupleLiteral = DirectCast(expr, Microsoft.CodeAnalysis.VisualBasic.BoundTupleLiteral)
					If (boundTupleLiteral.InferredType Is Nothing) Then
						GoTo Label1
					End If
					boundConversion = Me.ReclassifyTupleLiteralExpression(boundTupleLiteral, diagnostics)
					Return boundConversion
				ElseIf (kind = BoundKind.ArrayLiteral) Then
					boundConversion = Me.ReclassifyArrayLiteralExpression(DirectCast(expr, BoundArrayLiteral), diagnostics)
					Return boundConversion
				Else
					If (kind <> BoundKind.UnboundLambda) Then
						GoTo Label1
					End If
					boundConversion = Me.ReclassifyUnboundLambdaExpression(DirectCast(expr, UnboundLambda), diagnostics)
					Return boundConversion
				End If
			Label1:
				Binder.ReportDiagnostic(diagnostics, expr.Syntax, ERRID.ERR_VoidValue)
				boundConversion = Binder.BadExpression(expr.Syntax, expr, ErrorTypeSymbol.UnknownResultType)
			Else
				boundConversion = New Microsoft.CodeAnalysis.VisualBasic.BoundConversion(expr.Syntax, expr, ConversionKind.WideningNothingLiteral, False, False, expr.ConstantValueOpt, Me.GetSpecialType(SpecialType.System_Object, expr.Syntax, diagnostics), False)
			End If
			Return boundConversion
		Label3:
			If (kind = BoundKind.AddressOfOperator) Then
				Dim boundAddressOfOperator As Microsoft.CodeAnalysis.VisualBasic.BoundAddressOfOperator = DirectCast(expr, Microsoft.CodeAnalysis.VisualBasic.BoundAddressOfOperator)
				If (boundAddressOfOperator.MethodGroup.ResultKind <> LookupResultKind.Inaccessible) Then
					GoTo Label1
				ElseIf (boundAddressOfOperator.MethodGroup.Methods.Length <> 1) Then
					Dim syntax As Microsoft.CodeAnalysis.SyntaxNodeOrToken = boundAddressOfOperator.MethodGroup.Syntax
					Dim name(0) As [Object]
					methods = boundAddressOfOperator.MethodGroup.Methods
					name(0) = methods(0).Name
					Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_NoViableOverloadCandidates1, name)
					GoTo Label1
				Else
					Dim syntaxNodeOrToken As Microsoft.CodeAnalysis.SyntaxNodeOrToken = boundAddressOfOperator.MethodGroup.Syntax
					methods = boundAddressOfOperator.MethodGroup.Methods
					Binder.ReportDiagnostic(diagnostics, syntaxNodeOrToken, Me.GetInaccessibleErrorInfo(methods(0)))
					GoTo Label1
				End If
			Else
				GoTo Label1
			End If
		End Function

		Private Function ReclassifyInterpolatedStringExpression(ByVal conversionSemantics As SyntaxKind, ByVal tree As SyntaxNode, ByVal convKind As ConversionKind, ByVal isExplicit As Boolean, ByVal node As BoundInterpolatedStringExpression, ByVal targetType As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim boundConversion As BoundExpression
			If ((convKind And ConversionKind.InterpolatedString) <> ConversionKind.InterpolatedString) Then
				boundConversion = node
			Else
				boundConversion = New Microsoft.CodeAnalysis.VisualBasic.BoundConversion(tree, node, ConversionKind.InterpolatedString, False, isExplicit, targetType, False)
			End If
			Return boundConversion
		End Function

		Friend Function ReclassifyInvocationExpressionAsStatement(ByVal boundInvocation As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim kind As BoundKind = boundInvocation.Kind
			If (kind <= BoundKind.LateInvocation) Then
				If (kind = BoundKind.LateMemberAccess) Then
					boundInvocation = DirectCast(boundInvocation, BoundLateMemberAccess).SetAccessKind(LateBoundAccessKind.[Call])
				ElseIf (kind = BoundKind.LateInvocation) Then
					Dim boundLateInvocation As Microsoft.CodeAnalysis.VisualBasic.BoundLateInvocation = DirectCast(boundInvocation, Microsoft.CodeAnalysis.VisualBasic.BoundLateInvocation).SetAccessKind(LateBoundAccessKind.[Call])
					boundInvocation = boundLateInvocation
					If (Not boundLateInvocation.HasErrors AndAlso TypeOf boundLateInvocation.MethodOrPropertyGroupOpt Is BoundPropertyGroup) Then
						Binder.ReportDiagnostic(diagnostics, boundInvocation.Syntax, ERRID.ERR_PropertyAccessIgnored)
					End If
				End If
			ElseIf (kind = BoundKind.PropertyAccess) Then
				boundInvocation = Me.MakeRValue(boundInvocation, diagnostics)
				If (Not boundInvocation.HasErrors) Then
					Binder.ReportDiagnostic(diagnostics, boundInvocation.Syntax, ERRID.ERR_PropertyAccessIgnored)
				End If
			ElseIf (kind = BoundKind.ConditionalAccess) Then
				Dim boundConditionalAccess As Microsoft.CodeAnalysis.VisualBasic.BoundConditionalAccess = DirectCast(boundInvocation, Microsoft.CodeAnalysis.VisualBasic.BoundConditionalAccess)
				boundInvocation = boundConditionalAccess.Update(boundConditionalAccess.Receiver, boundConditionalAccess.Placeholder, Me.ReclassifyInvocationExpressionAsStatement(boundConditionalAccess.AccessExpression, diagnostics), Me.GetSpecialType(SpecialType.System_Void, boundConditionalAccess.Syntax, diagnostics))
			End If
			Return boundInvocation
		End Function

		Private Function ReclassifyQueryLambdaExpression(ByVal lambda As BoundQueryLambda, ByVal conversionSemantics As SyntaxKind, ByVal tree As Microsoft.CodeAnalysis.SyntaxNode, ByVal convKind As ConversionKind, ByVal isExplicit As Boolean, ByVal targetType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim syntaxNode As Microsoft.CodeAnalysis.SyntaxNode
			Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = targetType.DelegateOrExpressionDelegate(Me)
			If (Not Microsoft.CodeAnalysis.VisualBasic.Conversions.NoConversion(convKind)) Then
				Dim delegateInvokeMethod As Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol = namedTypeSymbol.DelegateInvokeMethod
				Dim enumerator As ImmutableArray(Of ParameterSymbol).Enumerator = delegateInvokeMethod.Parameters.GetEnumerator()
				While enumerator.MoveNext()
					Dim current As ParameterSymbol = enumerator.Current
					If (Not current.IsByRef AndAlso Not current.OriginalDefinition.Type.IsTypeParameter()) Then
						Continue While
					End If
					Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
					If (Not current.Type.IsRestrictedTypeOrArrayType(typeSymbol)) Then
						Continue While
					End If
					Dim locations As ImmutableArray(Of Location) = lambda.LambdaSymbol.Parameters(current.Ordinal).Locations
					Binder.ReportDiagnostic(diagnostics, locations(0), ERRID.ERR_RestrictedType1, New [Object]() { typeSymbol })
				End While
				Dim returnType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = delegateInvokeMethod.ReturnType
				If (delegateInvokeMethod.OriginalDefinition.ReturnType.IsTypeParameter()) Then
					Dim typeSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
					If (returnType.IsRestrictedTypeOrArrayType(typeSymbol1)) Then
						syntaxNode = If(lambda.Expression.Kind <> BoundKind.RangeVariableAssignment, lambda.Expression.Syntax, DirectCast(lambda.Expression, BoundRangeVariableAssignment).Value.Syntax)
						Binder.ReportDiagnostic(diagnostics, syntaxNode, ERRID.ERR_RestrictedType1, New [Object]() { typeSymbol1 })
					End If
				End If
				If (CObj(lambda.LambdaSymbol.ReturnType) <> CObj(LambdaSymbol.ReturnTypePendingDelegate)) Then
					lambda = lambda.Update(lambda.LambdaSymbol, lambda.RangeVariables, lambda.Expression, False)
				Else
					lambda = lambda.Update(lambda.LambdaSymbol, lambda.RangeVariables, Me.ApplyImplicitConversion(lambda.Expression.Syntax, returnType, lambda.Expression, diagnostics, If(returnType.IsBooleanType(), lambda.ExprIsOperandOfConditionalBranch, False)), False)
				End If
				If (conversionSemantics = SyntaxKind.CTypeKeyword) Then
					boundExpression = (New BoundConversion(tree, lambda, convKind, False, isExplicit, targetType, False)).MakeCompilerGenerated()
				ElseIf (conversionSemantics <> SyntaxKind.DirectCastKeyword) Then
					If (conversionSemantics <> SyntaxKind.TryCastKeyword) Then
						Throw ExceptionUtilities.UnexpectedValue(conversionSemantics)
					End If
					boundExpression = (New BoundTryCast(tree, lambda, convKind, targetType, False)).MakeCompilerGenerated()
				Else
					boundExpression = (New BoundDirectCast(tree, lambda, convKind, targetType, False)).MakeCompilerGenerated()
				End If
			Else
				If (targetType.IsStrictSupertypeOfConcreteDelegate() AndAlso Not targetType.IsObjectType()) Then
					Binder.ReportDiagnostic(diagnostics, lambda.Syntax, ERRID.ERR_LambdaNotCreatableDelegate1, New [Object]() { targetType })
				ElseIf (namedTypeSymbol IsNot Nothing) Then
					Dim methodSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol = namedTypeSymbol.DelegateInvokeMethod
					If (methodSymbol Is Nothing) Then
						Binder.ReportDiagnostic(diagnostics, lambda.Syntax, ERRID.ERR_LambdaNotDelegate1, New [Object]() { namedTypeSymbol })
					ElseIf (Not Binder.ReportDelegateInvokeUseSite(diagnostics, lambda.Syntax, namedTypeSymbol, methodSymbol)) Then
						If (CObj(lambda.LambdaSymbol.ReturnType) <> CObj(LambdaSymbol.ReturnTypePendingDelegate) OrElse methodSymbol.IsSub OrElse Not Microsoft.CodeAnalysis.VisualBasic.Conversions.FailedDueToQueryLambdaBodyMismatch(convKind)) Then
							Binder.ReportDiagnostic(diagnostics, lambda.Syntax, ERRID.ERR_LambdaBindingMismatch1, New [Object]() { namedTypeSymbol })
						Else
							lambda = lambda.Update(lambda.LambdaSymbol, lambda.RangeVariables, Me.ApplyImplicitConversion(lambda.Expression.Syntax, methodSymbol.ReturnType, lambda.Expression, diagnostics, If(methodSymbol.ReturnType.IsBooleanType(), lambda.ExprIsOperandOfConditionalBranch, False)), False)
						End If
					End If
				Else
					Binder.ReportDiagnostic(diagnostics, lambda.Syntax, ERRID.ERR_LambdaNotDelegate1, New [Object]() { targetType })
				End If
				If (conversionSemantics = SyntaxKind.CTypeKeyword) Then
					boundExpression = (New BoundConversion(tree, lambda, convKind, False, isExplicit, targetType, True)).MakeCompilerGenerated()
				ElseIf (conversionSemantics <> SyntaxKind.DirectCastKeyword) Then
					If (conversionSemantics <> SyntaxKind.TryCastKeyword) Then
						Throw ExceptionUtilities.UnexpectedValue(conversionSemantics)
					End If
					boundExpression = (New BoundTryCast(tree, lambda, convKind, targetType, True)).MakeCompilerGenerated()
				Else
					boundExpression = (New BoundDirectCast(tree, lambda, convKind, targetType, True)).MakeCompilerGenerated()
				End If
			End If
			Return boundExpression
		End Function

		Private Function ReclassifyTupleLiteral(ByVal convKind As ConversionKind, ByVal tree As SyntaxNode, ByVal isExplicit As Boolean, ByVal sourceTuple As BoundTupleLiteral, ByVal destination As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim nullableUnderlyingType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = destination
			If ((convKind And ConversionKind.Nullable) <> ConversionKind.DelegateRelaxationLevelNone) Then
				nullableUnderlyingType = destination.GetNullableUnderlyingType()
			End If
			Dim arguments As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = sourceTuple.Arguments
			If (nullableUnderlyingType.IsTupleOrCompatibleWithTupleOfCardinality(arguments.Length)) Then
				If (nullableUnderlyingType.IsTupleType) Then
					Dim tupleTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TupleTypeSymbol = DirectCast(nullableUnderlyingType, Microsoft.CodeAnalysis.VisualBasic.Symbols.TupleTypeSymbol)
					Microsoft.CodeAnalysis.VisualBasic.Symbols.TupleTypeSymbol.ReportNamesMismatchesIfAny(nullableUnderlyingType, sourceTuple, diagnostics)
					nullableUnderlyingType = tupleTypeSymbol.WithElementNames(sourceTuple.ArgumentNamesOpt)
				End If
				Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).GetInstance(arguments.Length)
				Dim elementTypesOfTupleOrCompatible As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol) = nullableUnderlyingType.GetElementTypesOfTupleOrCompatible()
				Dim length As Integer = arguments.Length - 1
				Dim num As Integer = 0
				Do
					Dim item As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = arguments(num)
					Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = elementTypesOfTupleOrCompatible(num)
					instance.Add(Me.ApplyConversion(item.Syntax, typeSymbol, item, isExplicit, diagnostics, False, False))
					num = num + 1
				Loop While num <= length
				Dim boundConvertedTupleLiteral As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundConvertedTupleLiteral(sourceTuple.Syntax, sourceTuple.Type, instance.ToImmutableAndFree(), nullableUnderlyingType, False)
				If (Not Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol.Equals(sourceTuple.Type, destination, TypeCompareKind.ConsiderEverything) AndAlso convKind <> ConversionKind.DelegateRelaxationLevelNone) Then
					boundConvertedTupleLiteral = New BoundConversion(sourceTuple.Syntax, boundConvertedTupleLiteral, convKind, False, isExplicit, destination, False)
				End If
				If (isExplicit) Then
					boundConvertedTupleLiteral = New BoundConversion(tree, boundConvertedTupleLiteral, ConversionKind.Identity, False, isExplicit, destination, False)
				End If
				boundExpression = boundConvertedTupleLiteral
			Else
				boundExpression = sourceTuple
			End If
			Return boundExpression
		End Function

		Private Function ReclassifyTupleLiteralExpression(ByVal tupleLiteral As BoundTupleLiteral, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Return Me.ApplyImplicitConversion(tupleLiteral.Syntax, tupleLiteral.InferredType, tupleLiteral, diagnostics, False)
		End Function

		Private Function ReclassifyUnboundLambdaExpression(ByVal unboundLambda As Microsoft.CodeAnalysis.VisualBasic.UnboundLambda, ByVal conversionSemantics As SyntaxKind, ByVal tree As Microsoft.CodeAnalysis.SyntaxNode, ByVal convKind As Microsoft.CodeAnalysis.VisualBasic.ConversionKind, ByVal isExplicit As Boolean, ByVal targetType As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundConversion As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim delegateInvokeMethod As MethodSymbol
			Dim eRRID As Microsoft.CodeAnalysis.VisualBasic.ERRID
			Dim optionStrictOffBinder As Binder
			Dim boundExtendedConversionInfo As Microsoft.CodeAnalysis.VisualBasic.BoundExtendedConversionInfo
			Dim obj As [Object]
			Dim obj1 As [Object]
			Dim eRRID1 As Microsoft.CodeAnalysis.VisualBasic.ERRID
			If (Not targetType.IsStrictSupertypeOfConcreteDelegate()) Then
				Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = targetType.DelegateOrExpressionDelegate(Me)
				If (namedTypeSymbol IsNot Nothing) Then
					delegateInvokeMethod = namedTypeSymbol.DelegateInvokeMethod
					If (delegateInvokeMethod Is Nothing) Then
						Binder.ReportDiagnostic(diagnostics, unboundLambda.Syntax, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_LambdaNotDelegate1, New [Object]() { namedTypeSymbol })
						delegateInvokeMethod = Nothing
					ElseIf (Binder.ReportDelegateInvokeUseSite(diagnostics, unboundLambda.Syntax, namedTypeSymbol, delegateInvokeMethod)) Then
						delegateInvokeMethod = Nothing
					ElseIf (unboundLambda.IsInferredDelegateForThisLambda(delegateInvokeMethod.ContainingType)) Then
						Dim value As ImmutableBindingDiagnostic(Of AssemblySymbol) = unboundLambda.InferredAnonymousDelegate.Value
						diagnostics.AddRange(value, False)
						If (Not value.Diagnostics.IsDefaultOrEmpty AndAlso Microsoft.CodeAnalysis.ImmutableArrayExtensions.HasAnyErrors(Of Diagnostic)(value.Diagnostics)) Then
							delegateInvokeMethod = Nothing
						End If
					End If
				Else
					Binder.ReportDiagnostic(diagnostics, unboundLambda.Syntax, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_LambdaNotDelegate1, New [Object]() { targetType })
					delegateInvokeMethod = Nothing
				End If
				Dim boundLambda As Microsoft.CodeAnalysis.VisualBasic.BoundLambda = Nothing
				If (delegateInvokeMethod IsNot Nothing) Then
					boundLambda = unboundLambda.GetBoundLambda(New Microsoft.CodeAnalysis.VisualBasic.UnboundLambda.TargetSignature(delegateInvokeMethod))
					If (boundLambda Is Nothing) Then
						Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
						Dim syntax As Microsoft.CodeAnalysis.SyntaxNodeOrToken = unboundLambda.Syntax
						eRRID1 = If(unboundLambda.IsFunctionLambda, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_LambdaBindingMismatch1, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_LambdaBindingMismatch2)
						Dim objArray(0) As [Object]
						If (namedTypeSymbol.TypeKind <> Microsoft.CodeAnalysis.TypeKind.[Delegate] OrElse Not namedTypeSymbol.IsFromCompilation(Me.Compilation)) Then
							obj1 = namedTypeSymbol
						Else
							obj1 = CustomSymbolDisplayFormatter.DelegateSignature(namedTypeSymbol)
						End If
						objArray(0) = obj1
						Binder.ReportDiagnostic(bindingDiagnosticBag, syntax, eRRID1, objArray)
					End If
				End If
				If (boundLambda IsNot Nothing) Then
					Dim immutableBindingDiagnostic As ImmutableBindingDiagnostic(Of AssemblySymbol) = boundLambda.Diagnostics
					Dim flag As Boolean = Microsoft.CodeAnalysis.ImmutableArrayExtensions.HasAnyErrors(Of Diagnostic)(immutableBindingDiagnostic.Diagnostics)
					diagnostics.AddRange(immutableBindingDiagnostic, False)
					Dim boundLambda1 As Microsoft.CodeAnalysis.VisualBasic.BoundLambda = Nothing
					If ((convKind And Microsoft.CodeAnalysis.VisualBasic.ConversionKind.DelegateRelaxationLevelMask) = Microsoft.CodeAnalysis.VisualBasic.ConversionKind.DelegateRelaxationLevelInvalid AndAlso Not flag AndAlso Not boundLambda.HasErrors) Then
						If (unboundLambda.ReturnType IsNot Nothing OrElse unboundLambda.Flags <> (SourceMemberFlags.Async Or SourceMemberFlags.Iterator)) Then
							eRRID = If(Not unboundLambda.IsFunctionLambda, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_LambdaBindingMismatch2, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_LambdaBindingMismatch1)
							Dim bindingDiagnosticBag1 As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
							Dim syntaxNodeOrToken As Microsoft.CodeAnalysis.SyntaxNodeOrToken = unboundLambda.Syntax
							Dim eRRID2 As Microsoft.CodeAnalysis.VisualBasic.ERRID = eRRID
							Dim objArray1(0) As [Object]
							If (namedTypeSymbol.TypeKind <> Microsoft.CodeAnalysis.TypeKind.[Delegate] OrElse Not namedTypeSymbol.IsFromCompilation(Me.Compilation)) Then
								obj = namedTypeSymbol
							Else
								obj = CustomSymbolDisplayFormatter.DelegateSignature(namedTypeSymbol)
							End If
							objArray1(0) = obj
							Binder.ReportDiagnostic(bindingDiagnosticBag1, syntaxNodeOrToken, eRRID2, objArray1)
						End If
					ElseIf (Microsoft.CodeAnalysis.VisualBasic.Conversions.IsStubRequiredForMethodConversion(boundLambda.MethodConversionKind)) Then
						Dim lambdaSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.LambdaSymbol = boundLambda.LambdaSymbol
						Dim parameters As ImmutableArray(Of ParameterSymbol) = lambdaSymbol.Parameters
						Dim namedTypeSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = Me.ConstructAnonymousDelegateSymbol(unboundLambda, parameters.[As](Of BoundLambdaParameterSymbol)(), lambdaSymbol.ReturnType, diagnostics)
						Dim boundConversion1 As Microsoft.CodeAnalysis.VisualBasic.BoundConversion = New Microsoft.CodeAnalysis.VisualBasic.BoundConversion(tree, boundLambda, Microsoft.CodeAnalysis.VisualBasic.ConversionKind.[Widening] Or Microsoft.CodeAnalysis.VisualBasic.ConversionKind.Lambda, False, False, namedTypeSymbol1, False)
						boundConversion1.SetWasCompilerGenerated()
						Dim boundMethodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup = New Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup(unboundLambda.Syntax, Nothing, ImmutableArray.Create(Of MethodSymbol)(namedTypeSymbol1.DelegateInvokeMethod), LookupResultKind.Good, boundConversion1, QualificationKind.QualifiedViaValue, False)
						boundMethodGroup.SetWasCompilerGenerated()
						If (Not isExplicit OrElse Me.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.Off) Then
							optionStrictOffBinder = Me
						Else
							optionStrictOffBinder = New Binder.OptionStrictOffBinder(Me)
						End If
						boundLambda1 = optionStrictOffBinder.BuildDelegateRelaxationLambda(unboundLambda.Syntax, delegateInvokeMethod, boundMethodGroup, boundLambda.DelegateRelaxation, False, If(isExplicit, False, tree.Kind() <> SyntaxKind.ObjectCreationExpression), diagnostics)
					End If
					If (conversionSemantics = SyntaxKind.CTypeKeyword) Then
						Dim syntaxNode As Microsoft.CodeAnalysis.SyntaxNode = tree
						Dim boundLambda2 As Microsoft.CodeAnalysis.VisualBasic.BoundLambda = boundLambda
						Dim conversionKind As Microsoft.CodeAnalysis.VisualBasic.ConversionKind = convKind
						Dim flag1 As Boolean = isExplicit
						If (boundLambda1 Is Nothing) Then
							boundExtendedConversionInfo = Nothing
						Else
							boundExtendedConversionInfo = (New BoundRelaxationLambda(tree, boundLambda1, Nothing, False)).MakeCompilerGenerated()
						End If
						boundConversion = New Microsoft.CodeAnalysis.VisualBasic.BoundConversion(syntaxNode, boundLambda2, conversionKind, False, flag1, Nothing, boundExtendedConversionInfo, targetType, False)
					ElseIf (conversionSemantics <> SyntaxKind.DirectCastKeyword) Then
						If (conversionSemantics <> SyntaxKind.TryCastKeyword) Then
							Throw ExceptionUtilities.UnexpectedValue(conversionSemantics)
						End If
						boundConversion = New BoundTryCast(tree, boundLambda, convKind, boundLambda1, targetType, False)
					Else
						boundConversion = New BoundDirectCast(tree, boundLambda, convKind, boundLambda1, targetType, False)
					End If
				Else
					Dim boundLambda3 As Microsoft.CodeAnalysis.VisualBasic.BoundLambda = unboundLambda.BindForErrorRecovery()
					If (conversionSemantics = SyntaxKind.CTypeKeyword) Then
						boundConversion = New Microsoft.CodeAnalysis.VisualBasic.BoundConversion(tree, boundLambda3, convKind, False, isExplicit, targetType, True)
					ElseIf (conversionSemantics <> SyntaxKind.DirectCastKeyword) Then
						If (conversionSemantics <> SyntaxKind.TryCastKeyword) Then
							Throw ExceptionUtilities.UnexpectedValue(conversionSemantics)
						End If
						boundConversion = New BoundTryCast(tree, boundLambda3, convKind, targetType, True)
					Else
						boundConversion = New BoundDirectCast(tree, boundLambda3, convKind, targetType, True)
					End If
				End If
			Else
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.ReclassifyUnboundLambdaExpression(unboundLambda, diagnostics)
				If (conversionSemantics = SyntaxKind.CTypeKeyword) Then
					boundConversion = Me.ApplyConversion(tree, targetType, boundExpression, isExplicit, diagnostics, False, False)
				ElseIf (conversionSemantics <> SyntaxKind.DirectCastKeyword) Then
					If (conversionSemantics <> SyntaxKind.TryCastKeyword) Then
						Throw ExceptionUtilities.UnexpectedValue(conversionSemantics)
					End If
					boundConversion = Me.ApplyTryCastConversion(tree, boundExpression, targetType, diagnostics)
				Else
					boundConversion = Me.ApplyDirectCastConversion(tree, boundExpression, targetType, diagnostics)
				End If
			End If
			Return boundConversion
		End Function

		Private Function ReclassifyUnboundLambdaExpression(ByVal lambda As UnboundLambda, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Dim syntax As SyntaxNode = lambda.Syntax
			Dim inferredAnonymousDelegate As KeyValuePair(Of NamedTypeSymbol, ImmutableBindingDiagnostic(Of AssemblySymbol)) = lambda.InferredAnonymousDelegate
			Return Me.ApplyImplicitConversion(syntax, inferredAnonymousDelegate.Key, lambda, diagnostics, False)
		End Function

		Private Function RecommendSwitchTable(ByVal selectExpr As BoundRValuePlaceholder, ByVal caseBlocks As ArrayBuilder(Of BoundCaseBlock), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
			Dim flag As Boolean
			If (Not caseBlocks.Any() OrElse Not selectExpr.Type.IsValidTypeForSwitchTable()) Then
				flag = False
			ElseIf (Not selectExpr.Type.IsStringType() OrElse Not Me.OptionCompareText) Then
				Dim flag1 As Boolean = True
				Dim enumerator As ArrayBuilder(Of BoundCaseBlock).Enumerator = caseBlocks.GetEnumerator()
				While enumerator.MoveNext()
					Dim enumerator1 As ImmutableArray(Of BoundCaseClause).Enumerator = enumerator.Current.CaseStatement.CaseClauses.GetEnumerator()
					While enumerator1.MoveNext()
						Dim current As BoundCaseClause = enumerator1.Current
						Dim kind As BoundKind = current.Kind
						If (kind = BoundKind.RangeCaseClause) Then
							Dim boundRangeCaseClause As Microsoft.CodeAnalysis.VisualBasic.BoundRangeCaseClause = DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.BoundRangeCaseClause)
							Dim lowerBoundOpt As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = boundRangeCaseClause.LowerBoundOpt
							Dim upperBoundOpt As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = boundRangeCaseClause.UpperBoundOpt
							If (lowerBoundOpt Is Nothing OrElse upperBoundOpt Is Nothing OrElse lowerBoundOpt.ConstantValueOpt Is Nothing OrElse upperBoundOpt.ConstantValueOpt Is Nothing OrElse Not SwitchConstantValueHelper.IsValidSwitchCaseLabelConstant(lowerBoundOpt.ConstantValueOpt) OrElse Not SwitchConstantValueHelper.IsValidSwitchCaseLabelConstant(upperBoundOpt.ConstantValueOpt)) Then
								flag = False
								Return flag
							Else
								flag1 = False
							End If
						ElseIf (kind <> BoundKind.RelationalCaseClause) Then
							Dim valueOpt As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = DirectCast(current, BoundSimpleCaseClause).ValueOpt
							If (valueOpt IsNot Nothing AndAlso valueOpt.ConstantValueOpt IsNot Nothing AndAlso SwitchConstantValueHelper.IsValidSwitchCaseLabelConstant(valueOpt.ConstantValueOpt)) Then
								Continue While
							End If
							flag = False
							Return flag
						Else
							Dim boundRelationalCaseClause As Microsoft.CodeAnalysis.VisualBasic.BoundRelationalCaseClause = DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.BoundRelationalCaseClause)
							Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = boundRelationalCaseClause.ValueOpt
							If (boundExpression IsNot Nothing AndAlso boundRelationalCaseClause.OperatorKind = BinaryOperatorKind.Equals AndAlso boundExpression.ConstantValueOpt IsNot Nothing AndAlso SwitchConstantValueHelper.IsValidSwitchCaseLabelConstant(boundExpression.ConstantValueOpt)) Then
								Continue While
							End If
							flag = False
							Return flag
						End If
					End While
				End While
				flag = If(Me.ReportInvalidSelectCaseRange(caseBlocks, diagnostics), False, flag1)
			Else
				flag = False
			End If
			Return flag
		End Function

		Private Shared Sub RecordMatchForIsOrInheritsFromOrImplementsInterface(ByVal matchingInterfaces As HashSet(Of NamedTypeSymbol), ByVal interfaceOfDerived As NamedTypeSymbol)
			If (Not matchingInterfaces.Add(interfaceOfDerived) AndAlso matchingInterfaces.Comparer = EqualsIgnoringComparer.InstanceIgnoringTupleNames AndAlso Not interfaceOfDerived.IsDefinition) Then
				matchingInterfaces.Remove(interfaceOfDerived)
				matchingInterfaces.Add(interfaceOfDerived)
			End If
		End Sub

		Private Shared Function RedefinesReservedXmlNamespace(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal prefix As String, ByVal reservedPrefix As String, ByVal [namespace] As String, ByVal reservedNamespace As String, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
			Dim flag As Boolean
			If (EmbeddedOperators.CompareString([namespace], reservedNamespace, False) <> 0 OrElse EmbeddedOperators.CompareString(prefix, reservedPrefix, False) = 0) Then
				flag = False
			Else
				Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_ReservedXmlNamespace, New [Object]() { prefix, reservedPrefix })
				flag = True
			End If
			Return flag
		End Function

		Private Shared Sub RemoveDuplicateInferredTupleNamesAndFreeIfEmptied(ByRef inferredElementNames As ArrayBuilder(Of String), ByVal uniqueFieldNames As HashSet(Of String))
			Dim func As Func(Of String, Boolean)
			If (inferredElementNames IsNot Nothing) Then
				Dim strs As HashSet(Of String) = New HashSet(Of String)(CaseInsensitiveComparison.Comparer)
				Dim enumerator As ArrayBuilder(Of String).Enumerator = inferredElementNames.GetEnumerator()
				While enumerator.MoveNext()
					Dim current As String = enumerator.Current
					If (current Is Nothing OrElse uniqueFieldNames.Add(current)) Then
						Continue While
					End If
					strs.Add(current)
				End While
				Dim count As Integer = inferredElementNames.Count - 1
				Dim num As Integer = 0
				Do
					Dim item As String = inferredElementNames(num)
					If (item IsNot Nothing AndAlso strs.Contains(item)) Then
						inferredElementNames(num) = Nothing
					End If
					num = num + 1
				Loop While num <= count
				Dim strs1 As ArrayBuilder(Of String) = inferredElementNames
				If (Binder._Closure$__.$I238-0 Is Nothing) Then
					func = Function(n As String) n Is Nothing
					Binder._Closure$__.$I238-0 = func
				Else
					func = Binder._Closure$__.$I238-0
				End If
				If (strs1.All(func)) Then
					inferredElementNames.Free()
					inferredElementNames = Nothing
				End If
			End If
		End Sub

		Public Function Report_ERRID_ReadOnlyInClosure(ByVal argument As BoundExpression) As Boolean
			Dim isLValue As Boolean
			Dim receiverOpt As BoundExpression
			Dim associatedField As FieldSymbol
			If (Not argument.HasErrors) Then
				Dim containingMember As Symbol = Me.ContainingMember
				If (containingMember IsNot Nothing) Then
					If (argument.Kind <> BoundKind.PropertyAccess) Then
						If (argument.Kind = BoundKind.FieldAccess) Then
							GoTo Label1
						End If
						isLValue = False
						Return isLValue
					Else
						Dim boundPropertyAccess As Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess = DirectCast(argument, Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess)
						Dim propertySymbol As SourcePropertySymbol = TryCast(boundPropertyAccess.PropertySymbol, SourcePropertySymbol)
						If (propertySymbol Is Nothing OrElse Not propertySymbol.IsReadOnly) Then
							isLValue = False
							Return isLValue
						Else
							associatedField = propertySymbol.AssociatedField
							receiverOpt = boundPropertyAccess.ReceiverOpt
							If (associatedField IsNot Nothing) Then
								GoTo Label2
							End If
							isLValue = False
							Return isLValue
						End If
					End If
				Label2:
					Dim binder As Microsoft.CodeAnalysis.VisualBasic.Binder = Nothing
					If (containingMember.IsLambdaMethod) Then
						Dim containingBinder As Microsoft.CodeAnalysis.VisualBasic.Binder = Nothing
						Do
							containingBinder = DirectCast(containingMember, LambdaSymbol).ContainingBinder
							containingMember = containingMember.ContainingSymbol
						Loop While containingMember IsNot Nothing AndAlso containingMember.IsLambdaMethod
						Dim methodKind As Microsoft.CodeAnalysis.MethodKind = containingBinder.KindOfContainingMethodAtRunTime()
						If (methodKind = Microsoft.CodeAnalysis.MethodKind.Constructor OrElse methodKind = Microsoft.CodeAnalysis.MethodKind.StaticConstructor) Then
							binder = containingBinder
						End If
					End If
					If (binder Is Nothing) Then
						isLValue = False
					ElseIf (receiverOpt Is Nothing OrElse receiverOpt.Kind <> BoundKind.FieldAccess) Then
						isLValue = binder.IsLValueFieldAccess(associatedField, receiverOpt)
					Else
						Dim instance As ArrayBuilder(Of FieldSymbol) = ArrayBuilder(Of FieldSymbol).GetInstance()
						instance.Add(associatedField)
						Do
							Dim boundFieldAccess As Microsoft.CodeAnalysis.VisualBasic.BoundFieldAccess = DirectCast(receiverOpt, Microsoft.CodeAnalysis.VisualBasic.BoundFieldAccess)
							instance.Add(boundFieldAccess.FieldSymbol)
							receiverOpt = boundFieldAccess.ReceiverOpt
						Loop While receiverOpt IsNot Nothing AndAlso receiverOpt.Kind = BoundKind.FieldAccess
						For i As Integer = instance.Count - 1 To 0 Step -1
							Dim item As FieldSymbol = instance(i)
							receiverOpt = New Microsoft.CodeAnalysis.VisualBasic.BoundFieldAccess(argument.Syntax, receiverOpt, item, binder.IsLValueFieldAccess(item, receiverOpt), item.Type, False)
						Next

						instance.Free()
						isLValue = receiverOpt.IsLValue
					End If
				Else
					isLValue = False
				End If
			Else
				isLValue = False
			End If
			Return isLValue
		Label1:
			Dim boundFieldAccess1 As Microsoft.CodeAnalysis.VisualBasic.BoundFieldAccess = DirectCast(argument, Microsoft.CodeAnalysis.VisualBasic.BoundFieldAccess)
			receiverOpt = boundFieldAccess1.ReceiverOpt
			associatedField = boundFieldAccess1.FieldSymbol
			receiverOpt = boundFieldAccess1.ReceiverOpt
			GoTo Label2
		End Function

		Private Sub ReportArrayLiteralDiagnostics(ByVal arrayLiteral As BoundArrayLiteral, ByVal targetArrayType As ArrayTypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			If (CObj(targetArrayType) = CObj(arrayLiteral.InferredType)) Then
				Me.ReportArrayLiteralInferredTypeDiagnostics(arrayLiteral, diagnostics)
			End If
		End Sub

		Private Sub ReportArrayLiteralInferredTypeDiagnostics(ByVal arrayLiteral As BoundArrayLiteral, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Dim elementType As TypeSymbol = arrayLiteral.InferredType.ElementType
			If (elementType.IsRestrictedType()) Then
				Binder.ReportDiagnostic(diagnostics, arrayLiteral.Syntax, ERRID.ERR_RestrictedType1, New [Object]() { elementType })
				Return
			End If
			If (Not arrayLiteral.HasDominantType) Then
				Binder.ReportDiagnostic(diagnostics, arrayLiteral.Syntax, ERRID.ERR_ArrayInitNoType)
				Return
			End If
			Dim optionStrict As Microsoft.CodeAnalysis.VisualBasic.OptionStrict = Me.OptionStrict
			If (optionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.Custom) Then
				If (arrayLiteral.NumberOfCandidates = 0) Then
					Binder.ReportDiagnostic(diagnostics, arrayLiteral.Syntax, ErrorFactory.ErrorInfo(ERRID.WRN_ObjectAssumed1, New [Object]() { ErrorFactory.ErrorInfo(ERRID.WRN_ArrayInitNoTypeObjectAssumed) }))
					Return
				End If
				If (arrayLiteral.NumberOfCandidates > 1) Then
					Binder.ReportDiagnostic(diagnostics, arrayLiteral.Syntax, ErrorFactory.ErrorInfo(ERRID.WRN_ObjectAssumed1, New [Object]() { ErrorFactory.ErrorInfo(ERRID.WRN_ArrayInitTooManyTypesObjectAssumed) }))
				End If
			ElseIf (optionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.[On]) Then
				If (arrayLiteral.NumberOfCandidates = 0) Then
					Binder.ReportDiagnostic(diagnostics, arrayLiteral.Syntax, ERRID.ERR_ArrayInitNoTypeObjectDisallowed)
					Return
				End If
				If (arrayLiteral.NumberOfCandidates > 1) Then
					Binder.ReportDiagnostic(diagnostics, arrayLiteral.Syntax, ERRID.ERR_ArrayInitTooManyTypesObjectDisallowed)
					Return
				End If
			End If
		End Sub

		Private Shared Sub ReportAssignmentToRValue(ByVal expr As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Dim eRRID As Microsoft.CodeAnalysis.VisualBasic.ERRID
			If (Not expr.IsConstant) Then
				eRRID = If(Not Binder.ExpressionRefersToReadonlyVariable(expr, True), Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_LValueRequired, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_ReadOnlyAssignment)
			Else
				eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_CantAssignToConst
			End If
			Binder.ReportDiagnostic(diagnostics, expr.Syntax, eRRID)
		End Sub

		Private Shared Sub ReportBinaryOperatorOnObject(ByVal operatorTokenKind As SyntaxKind, ByVal operand As BoundExpression, ByVal preliminaryOperatorKind As BinaryOperatorKind, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Binder.ReportDiagnostic(diagnostics, operand.Syntax, ErrorFactory.ErrorInfo(If(preliminaryOperatorKind = BinaryOperatorKind.Equals OrElse preliminaryOperatorKind = BinaryOperatorKind.NotEquals, ERRID.ERR_StrictDisallowsObjectComparison1, ERRID.ERR_StrictDisallowsObjectOperand1), operatorTokenKind))
		End Sub

		Private Sub ReportByRefConversionErrors(ByVal candidate As OverloadResolution.Candidate, ByVal param As ParameterSymbol, ByVal argument As BoundExpression, ByVal targetType As TypeSymbol, ByVal reportNarrowingConversions As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal diagnosticNode As SyntaxNode = Nothing, Optional ByVal delegateSymbol As Symbol = Nothing)
			If (Not targetType.IsErrorType() AndAlso Not argument.HasErrors) Then
				If (Not argument.IsSupportingAssignment()) Then
					If (Me.Report_ERRID_ReadOnlyInClosure(argument)) Then
						Binder.ReportDiagnostic(diagnostics, argument.Syntax, ERRID.ERR_ReadOnlyInClosure)
					End If
					Me.ReportByValConversionErrors(param, argument, targetType, reportNarrowingConversions, diagnostics, diagnosticNode, delegateSymbol)
				ElseIf ((Not argument.IsLValue OrElse Not targetType.IsSameTypeIgnoringAll(argument.Type)) AndAlso Not Me.ReportByValConversionErrors(param, argument, targetType, reportNarrowingConversions, diagnostics, diagnosticNode, delegateSymbol)) Then
					Dim boundRValuePlaceholder As Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder = New Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder(argument.Syntax, targetType)
					Dim typeOfAssignmentTarget As TypeSymbol = argument.GetTypeOfAssignmentTarget()
					Dim discarded As CompoundUseSiteInfo(Of AssemblySymbol) = CompoundUseSiteInfo(Of AssemblySymbol).Discarded
					Dim keyValuePair As KeyValuePair(Of ConversionKind, MethodSymbol) = Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyConversion(boundRValuePlaceholder, typeOfAssignmentTarget, Me, discarded)
					If (Microsoft.CodeAnalysis.VisualBasic.Conversions.NoConversion(keyValuePair.Key)) Then
						Me.CreateConversionAndReportDiagnostic(argument.Syntax, boundRValuePlaceholder, keyValuePair, False, typeOfAssignmentTarget, diagnostics, param.Name, False)
						Return
					End If
					If (Microsoft.CodeAnalysis.VisualBasic.Conversions.IsNarrowingConversion(keyValuePair.Key)) Then
						If (Me.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.[On]) Then
							Me.CreateConversionAndReportDiagnostic(argument.Syntax, boundRValuePlaceholder, keyValuePair, False, typeOfAssignmentTarget, diagnostics, param.Name, False)
							Return
						End If
						If (reportNarrowingConversions) Then
							Binder.ReportDiagnostic(diagnostics, argument.Syntax, ERRID.ERR_ArgumentCopyBackNarrowing3, New [Object]() { CustomSymbolDisplayFormatter.ShortErrorName(param), targetType, typeOfAssignmentTarget })
							Return
						End If
					End If
				End If
			End If
		End Sub

		Private Function ReportByValConversionErrors(ByVal param As ParameterSymbol, ByVal argument As BoundExpression, ByVal targetType As TypeSymbol, ByVal reportNarrowingConversions As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal diagnosticNode As SyntaxNode = Nothing, Optional ByVal delegateSymbol As Symbol = Nothing) As Boolean
			' 
			' Current member / type: System.Boolean Microsoft.CodeAnalysis.VisualBasic.Binder::ReportByValConversionErrors(Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbol)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: System.Boolean ReportByValConversionErrors(Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol,Microsoft.CodeAnalysis.VisualBasic.BoundExpression,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbol)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Function

		Private Shared Function ReportCommonErrorsFromLambdas(ByVal diagnosticPerSymbol As ArrayBuilder(Of KeyValuePair(Of Symbol, ImmutableBindingDiagnostic(Of AssemblySymbol))), ByVal arguments As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
			Dim flag As Boolean = False
			Dim enumerator As ImmutableArray(Of Diagnostic).Enumerator = diagnosticPerSymbol(0).Value.Diagnostics.GetEnumerator()
		Label0:
			While enumerator.MoveNext()
				Dim current As Diagnostic = enumerator.Current
				If (current.Severity <> DiagnosticSeverity.[Error]) Then
					Continue While
				End If
				Dim enumerator1 As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Enumerator = arguments.GetEnumerator()
				While enumerator1.MoveNext()
					Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = enumerator1.Current
					If (boundExpression.Syntax.SyntaxTree <> current.Location.SourceTree OrElse boundExpression.Kind <> BoundKind.UnboundLambda OrElse Not boundExpression.Syntax.Span.Contains(current.Location.SourceSpan)) Then
						Continue While
					End If
					Dim flag1 As Boolean = True
					Dim count As Integer = diagnosticPerSymbol.Count - 1
					Dim num As Integer = 1
					While num <= count
						If (diagnosticPerSymbol(num).Value.Diagnostics.Contains(current)) Then
							num = num + 1
						Else
							flag1 = False
							Exit While
						End If
					End While
					If (Not flag1) Then
						GoTo Label0
					End If
					flag = True
					diagnostics.Add(current)
					GoTo Label0
				End While
			End While
			Return flag
		End Function

		Private Shared Sub ReportDefaultMemberNotProperty(ByVal expr As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Binder.ReportDiagnostic(diagnostics, expr.Syntax, ERRID.ERR_DefaultMemberNotProperty1, New [Object]() { expr.Type })
		End Sub

		Private Shared Sub ReportDelegateBindingIncompatible(ByVal syntax As SyntaxNode, ByVal delegateType As NamedTypeSymbol, ByVal targetMethodSymbol As MethodSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			If (targetMethodSymbol.ReducedFrom Is Nothing) Then
				Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_DelegateBindingIncompatible2, New [Object]() { targetMethodSymbol, CustomSymbolDisplayFormatter.DelegateSignature(delegateType) })
				Return
			End If
			Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_DelegateBindingIncompatible3, New [Object]() { targetMethodSymbol, CustomSymbolDisplayFormatter.DelegateSignature(delegateType), targetMethodSymbol.ContainingType })
		End Sub

		Private Shared Sub ReportDelegateBindingMismatchStrictOff(ByVal syntax As SyntaxNode, ByVal delegateType As NamedTypeSymbol, ByVal targetMethodSymbol As MethodSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			If (targetMethodSymbol.ReducedFrom Is Nothing) Then
				Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_DelegateBindingMismatchStrictOff2, New [Object]() { targetMethodSymbol, CustomSymbolDisplayFormatter.DelegateSignature(delegateType) })
				Return
			End If
			Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_DelegateBindingMismatchStrictOff3, New [Object]() { targetMethodSymbol, CustomSymbolDisplayFormatter.DelegateSignature(delegateType), targetMethodSymbol.ContainingType })
		End Sub

		Friend Shared Function ReportDelegateInvokeUseSite(ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal syntax As SyntaxNode, ByVal delegateType As TypeSymbol, ByVal invoke As MethodSymbol) As Boolean
			Dim code As Boolean
			Dim useSiteInfo As UseSiteInfo(Of AssemblySymbol) = invoke.GetUseSiteInfo()
			Dim diagnosticInfo As Microsoft.CodeAnalysis.DiagnosticInfo = useSiteInfo.DiagnosticInfo
			If (diagnosticInfo IsNot Nothing) Then
				code = diagnosticInfo.Code = 30657
			Else
				code = False
			End If
			If (code) Then
				useSiteInfo = New UseSiteInfo(Of AssemblySymbol)(ErrorFactory.ErrorInfo(ERRID.ERR_UnsupportedMethod1, New [Object]() { delegateType }))
			End If
			Return diagBag.Add(useSiteInfo, syntax)
		End Function

		Public Shared Sub ReportDiagnostic(ByVal diagBag As DiagnosticBag, ByVal syntax As SyntaxNodeOrToken, ByVal id As ERRID)
			Binder.ReportDiagnostic(diagBag, syntax, ErrorFactory.ErrorInfo(id))
		End Sub

		Public Shared Sub ReportDiagnostic(ByVal diagBag As DiagnosticBag, ByVal syntax As SyntaxNodeOrToken, ByVal id As ERRID, ByVal ParamArray args As Object())
			Binder.ReportDiagnostic(diagBag, syntax, ErrorFactory.ErrorInfo(id, args))
		End Sub

		Public Shared Sub ReportDiagnostic(ByVal diagBag As DiagnosticBag, ByVal syntax As SyntaxNodeOrToken, ByVal info As DiagnosticInfo)
			Dim vBDiagnostic As Microsoft.CodeAnalysis.VisualBasic.VBDiagnostic = New Microsoft.CodeAnalysis.VisualBasic.VBDiagnostic(info, syntax.GetLocation(), False)
			Binder.ReportDiagnostic(diagBag, vBDiagnostic)
		End Sub

		Public Shared Sub ReportDiagnostic(ByVal diagBag As DiagnosticBag, ByVal location As Microsoft.CodeAnalysis.Location, ByVal id As ERRID)
			Binder.ReportDiagnostic(diagBag, location, ErrorFactory.ErrorInfo(id))
		End Sub

		Public Shared Sub ReportDiagnostic(ByVal diagBag As DiagnosticBag, ByVal location As Microsoft.CodeAnalysis.Location, ByVal id As ERRID, ByVal ParamArray args As Object())
			Binder.ReportDiagnostic(diagBag, location, ErrorFactory.ErrorInfo(id, args))
		End Sub

		Public Shared Sub ReportDiagnostic(ByVal diagBag As DiagnosticBag, ByVal location As Microsoft.CodeAnalysis.Location, ByVal info As DiagnosticInfo)
			Binder.ReportDiagnostic(diagBag, New VBDiagnostic(info, location, False))
		End Sub

		Public Shared Sub ReportDiagnostic(ByVal diagBag As DiagnosticBag, ByVal diag As Diagnostic)
			diagBag.Add(diag)
		End Sub

		Public Shared Sub ReportDiagnostic(ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal syntax As SyntaxNodeOrToken, ByVal id As ERRID)
			Binder.ReportDiagnostic(diagBag, syntax, ErrorFactory.ErrorInfo(id))
		End Sub

		Public Shared Sub ReportDiagnostic(ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal syntax As SyntaxNodeOrToken, ByVal id As ERRID, ByVal ParamArray args As Object())
			Binder.ReportDiagnostic(diagBag, syntax, ErrorFactory.ErrorInfo(id, args))
		End Sub

		Public Shared Sub ReportDiagnostic(ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal syntax As SyntaxNodeOrToken, ByVal info As DiagnosticInfo)
			Dim vBDiagnostic As Microsoft.CodeAnalysis.VisualBasic.VBDiagnostic = New Microsoft.CodeAnalysis.VisualBasic.VBDiagnostic(info, syntax.GetLocation(), False)
			Binder.ReportDiagnostic(diagBag, vBDiagnostic)
		End Sub

		Public Shared Sub ReportDiagnostic(ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal location As Microsoft.CodeAnalysis.Location, ByVal id As ERRID)
			Binder.ReportDiagnostic(diagBag, location, ErrorFactory.ErrorInfo(id))
		End Sub

		Public Shared Sub ReportDiagnostic(ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal location As Microsoft.CodeAnalysis.Location, ByVal id As ERRID, ByVal ParamArray args As Object())
			Binder.ReportDiagnostic(diagBag, location, ErrorFactory.ErrorInfo(id, args))
		End Sub

		Public Shared Sub ReportDiagnostic(ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal location As Microsoft.CodeAnalysis.Location, ByVal info As DiagnosticInfo)
			Binder.ReportDiagnostic(diagBag, New VBDiagnostic(info, location, False))
		End Sub

		Public Shared Sub ReportDiagnostic(ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal diag As Diagnostic)
			diagBag.Add(diag)
		End Sub

		Public Shared Function ReportDiagnosticAndProduceBadExpression(ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal id As ERRID) As BoundExpression
			Return Binder.ReportDiagnosticAndProduceBadExpression(diagBag, syntax, ErrorFactory.ErrorInfo(id), New BoundExpression(-1) {})
		End Function

		Public Shared Function ReportDiagnosticAndProduceBadExpression(ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal id As ERRID, ByVal ParamArray args As Object()) As BoundExpression
			Return Binder.ReportDiagnosticAndProduceBadExpression(diagBag, syntax, ErrorFactory.ErrorInfo(id, args), New BoundExpression(-1) {})
		End Function

		Public Shared Function ReportDiagnosticAndProduceBadExpression(ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal info As DiagnosticInfo, ByVal ParamArray nodes As BoundExpression()) As BoundExpression
			Dim empty As ImmutableArray(Of BoundExpression)
			Dim visualBasicSyntaxNode As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode = syntax
			If (nodes.IsEmpty(Of BoundExpression)()) Then
				empty = ImmutableArray(Of BoundExpression).Empty
			Else
				empty = ImmutableArray.Create(Of BoundExpression)(nodes)
			End If
			Return Binder.BadExpression(visualBasicSyntaxNode, empty, Binder.ReportDiagnosticAndProduceErrorTypeSymbol(diagBag, syntax, info))
		End Function

		Public Shared Function ReportDiagnosticAndProduceErrorTypeSymbol(ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal id As ERRID, ByVal ParamArray args As Object()) As ErrorTypeSymbol
			Return Binder.ReportDiagnosticAndProduceErrorTypeSymbol(diagBag, syntax, ErrorFactory.ErrorInfo(id, args))
		End Function

		Public Shared Function ReportDiagnosticAndProduceErrorTypeSymbol(ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal info As DiagnosticInfo) As ErrorTypeSymbol
			Binder.ReportDiagnostic(diagBag, syntax, info)
			Return ErrorTypeSymbol.UnknownResultType
		End Function

		Friend Shared Sub ReportDiagnosticsIfObsolete(ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal context As Microsoft.CodeAnalysis.VisualBasic.Symbol, ByVal symbol As Microsoft.CodeAnalysis.VisualBasic.Symbol, ByVal node As SyntaxNode)
			Dim obsoleteDiagnosticKind As Microsoft.CodeAnalysis.VisualBasic.Symbols.ObsoleteDiagnosticKind = ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(context, symbol, False)
			Dim lazyObsoleteDiagnosticInfo As DiagnosticInfo = Nothing
			If (obsoleteDiagnosticKind = Microsoft.CodeAnalysis.VisualBasic.Symbols.ObsoleteDiagnosticKind.Diagnostic) Then
				lazyObsoleteDiagnosticInfo = ObsoleteAttributeHelpers.CreateObsoleteDiagnostic(symbol)
			ElseIf (CInt(obsoleteDiagnosticKind) - CInt(Microsoft.CodeAnalysis.VisualBasic.Symbols.ObsoleteDiagnosticKind.Lazy) <= CInt(Microsoft.CodeAnalysis.VisualBasic.Symbols.ObsoleteDiagnosticKind.Suppressed)) Then
				lazyObsoleteDiagnosticInfo = New Microsoft.CodeAnalysis.VisualBasic.LazyObsoleteDiagnosticInfo(symbol, context)
			End If
			If (lazyObsoleteDiagnosticInfo IsNot Nothing) Then
				diagnostics.Add(lazyObsoleteDiagnosticInfo, node.GetLocation())
			End If
		End Sub

		Friend Sub ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal symbol As Microsoft.CodeAnalysis.VisualBasic.Symbol, ByVal node As SyntaxNode)
			Dim isInterface As Boolean
			If (Not Me.SuppressObsoleteDiagnostics) Then
				Binder.ReportDiagnosticsIfObsolete(diagnostics, Me.ContainingMember, symbol, node)
			End If
			If (symbol.Kind <> SymbolKind.[Property] AndAlso CObj(Me.Compilation.SourceModule) <> CObj(symbol.ContainingModule)) Then
				Dim containingType As NamedTypeSymbol = symbol.ContainingType
				If (containingType IsNot Nothing) Then
					isInterface = containingType.IsInterface
				Else
					isInterface = False
				End If
				If (isInterface AndAlso Not Me.Compilation.Assembly.RuntimeSupportsDefaultInterfaceImplementation) Then
					If (Not symbol.IsShared AndAlso Not TypeOf symbol Is TypeSymbol AndAlso Not symbol.RequiresImplementation()) Then
						Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation)
						Return
					End If
					Dim declaredAccessibility As Accessibility = symbol.DeclaredAccessibility
					If (CInt(declaredAccessibility) - CInt(Accessibility.ProtectedAndInternal) <= CInt(Accessibility.[Private]) OrElse declaredAccessibility = Accessibility.ProtectedOrInternal) Then
						Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember)
					End If
				End If
			End If
		End Sub

		Private Function ReportInvalidSelectCaseRange(ByVal caseBlocks As ArrayBuilder(Of BoundCaseBlock), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
			Dim flag As Boolean
			Dim enumerator As ArrayBuilder(Of BoundCaseBlock).Enumerator = caseBlocks.GetEnumerator()
			While True
				If (enumerator.MoveNext()) Then
					Dim enumerator1 As ImmutableArray(Of BoundCaseClause).Enumerator = enumerator.Current.CaseStatement.CaseClauses.GetEnumerator()
					While enumerator1.MoveNext()
						Dim current As BoundCaseClause = enumerator1.Current
						If (current.Kind <> BoundKind.RangeCaseClause) Then
							Continue While
						End If
						Dim boundRangeCaseClause As Microsoft.CodeAnalysis.VisualBasic.BoundRangeCaseClause = DirectCast(current, Microsoft.CodeAnalysis.VisualBasic.BoundRangeCaseClause)
						Dim lowerBoundOpt As BoundExpression = boundRangeCaseClause.LowerBoundOpt
						Dim upperBoundOpt As BoundExpression = boundRangeCaseClause.UpperBoundOpt
						If (Not Binder.IsInvalidSelectCaseRange(lowerBoundOpt.ConstantValueOpt, upperBoundOpt.ConstantValueOpt)) Then
							Continue While
						End If
						Binder.ReportDiagnostic(diagnostics, boundRangeCaseClause.Syntax, ERRID.WRN_SelectCaseInvalidRange)
						flag = True
						Return flag
					End While
				Else
					flag = False
					Exit While
				End If
			End While
			Return flag
		End Function

		Public Sub ReportLambdaParameterInferredToBeObject(ByVal unboundParam As UnboundLambdaParameterSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			If (Me.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.[On]) Then
				Binder.ReportDiagnostic(diagnostics, unboundParam.IdentifierSyntax, ERRID.ERR_StrictDisallowImplicitObjectLambda)
				Return
			End If
			If (Me.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.Custom) Then
				Binder.ReportDiagnostic(diagnostics, unboundParam.IdentifierSyntax, ERRID.WRN_ObjectAssumedVar1, New [Object]() { ErrorFactory.ErrorInfo(ERRID.WRN_MissingAsClauseinVarDecl) })
			End If
		End Sub

		Public Sub ReportModifierError(ByVal modifiers As SyntaxTokenList, ByVal errid As Microsoft.CodeAnalysis.VisualBasic.ERRID, ByVal diagBag As DiagnosticBag, ByVal ParamArray keywordKinds As SyntaxKind())
			Dim syntaxToken As Microsoft.CodeAnalysis.SyntaxToken = Binder.FindFirstKeyword(modifiers, keywordKinds)
			If (syntaxToken.Kind() = SyntaxKind.ProtectedKeyword) Then
				Dim syntaxToken1 As Microsoft.CodeAnalysis.SyntaxToken = Binder.FindFirstKeyword(modifiers, Binder.s_friendKeyword)
				If (syntaxToken1.Kind() <> SyntaxKind.None) Then
					Dim num As Integer = Math.Min(syntaxToken.SpanStart, syntaxToken1.SpanStart)
					Dim span As TextSpan = syntaxToken.Span
					Dim [end] As Integer = span.[End]
					span = syntaxToken1.Span
					Dim num1 As Integer = Math.Max([end], span.[End])
					Dim location As Microsoft.CodeAnalysis.Location = Me.SyntaxTree.GetLocation(New TextSpan(num, num1 - num))
					Binder.ReportDiagnostic(diagBag, location, errid, New [Object]() { [String].Concat(syntaxToken.ToString(), " ", syntaxToken1.ToString()) })
					Return
				End If
			End If
			Binder.ReportDiagnostic(diagBag, syntaxToken, errid, New [Object]() { syntaxToken.ToString() })
		End Sub

		Private Sub ReportMutableStructureConstraintsInUsing(ByVal type As TypeSymbol, ByVal symbolName As String, ByVal syntaxNode As Microsoft.CodeAnalysis.SyntaxNode, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			If (Not type.IsReferenceType) Then
				If (type.IsTypeParameter()) Then
					If (Not type.IsValueType) Then
						Binder.ReportDiagnostic(diagnostics, syntaxNode, ErrorFactory.ErrorInfo(ERRID.WRN_MutableGenericStructureInUsing, New [Object]() { symbolName }))
						Return
					End If
					Dim typeParameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol = DirectCast(type, Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol)
					Dim flag As Boolean = False
					Dim enumerator As ImmutableArray(Of TypeSymbol).Enumerator = DirectCast(type, Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol).ConstraintTypesNoUseSiteDiagnostics.GetEnumerator()
					While enumerator.MoveNext()
						Dim current As TypeSymbol = enumerator.Current
						If (Not current.IsValueType) Then
							Continue While
						End If
						flag = True
						If (Not Binder.ShouldReportMutableStructureInUsing(current)) Then
							Continue While
						End If
						Binder.ReportDiagnostic(diagnostics, syntaxNode, ErrorFactory.ErrorInfo(ERRID.WRN_MutableStructureInUsing, New [Object]() { symbolName }))
						Return
					End While
					If (Not flag) Then
						Binder.ReportDiagnostic(diagnostics, syntaxNode, ErrorFactory.ErrorInfo(ERRID.WRN_MutableStructureInUsing, New [Object]() { symbolName }))
						Return
					End If
				ElseIf (Binder.ShouldReportMutableStructureInUsing(type)) Then
					Binder.ReportDiagnostic(diagnostics, syntaxNode, ErrorFactory.ErrorInfo(ERRID.WRN_MutableStructureInUsing, New [Object]() { symbolName }))
				End If
			End If
		End Sub

		Private Shared Sub ReportNameConfictsBetweenStaticLocals(ByVal methodBlockBinder As Binder, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Dim methodBodyBinder As Microsoft.CodeAnalysis.VisualBasic.MethodBodyBinder
			Dim enumerator As IEnumerator(Of BlockBaseBinder) = Nothing
			Dim enumerator1 As Dictionary(Of String, ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol)).Enumerator = New Dictionary(Of String, ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol)).Enumerator()
			Dim containingBinder As Binder = methodBlockBinder
			Do
				methodBodyBinder = TryCast(containingBinder, Microsoft.CodeAnalysis.VisualBasic.MethodBodyBinder)
				If (methodBodyBinder IsNot Nothing) Then
					Exit Do
				End If
				containingBinder = containingBinder.ContainingBinder
			Loop While containingBinder IsNot Nothing
			If (methodBodyBinder IsNot Nothing) Then
				Using strs As Dictionary(Of String, ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol)) = Nothing
					enumerator = methodBodyBinder.StmtListToBinderMap.Values.GetEnumerator()
					While enumerator.MoveNext()
						Dim enumerator2 As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol).Enumerator = enumerator.Current.Locals.GetEnumerator()
						While enumerator2.MoveNext()
							Dim current As Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol = enumerator2.Current
							If (Not current.IsStatic) Then
								Continue While
							End If
							Dim localSymbols As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol) = Nothing
							If (strs Is Nothing) Then
								strs = New Dictionary(Of String, ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol))(CaseInsensitiveComparison.Comparer)
								localSymbols = New ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol)()
								strs.Add(current.Name, localSymbols)
							ElseIf (Not strs.TryGetValue(current.Name, localSymbols)) Then
								localSymbols = New ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol)()
								strs.Add(current.Name, localSymbols)
							End If
							localSymbols.Add(current)
						End While
					End While
				End Using
				If (strs IsNot Nothing) Then
					Try
						enumerator1 = strs.GetEnumerator()
						While enumerator1.MoveNext()
							Dim value As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol) = enumerator1.Current.Value
							If (value.Count <= 1) Then
								Continue While
							End If
							Dim item As Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol = value(0)
							Dim count As Integer = value.Count - 1
							Dim num As Integer = 1
							Do
								If (item.IdentifierToken.Position > value(num).IdentifierToken.Position) Then
									item = value(num)
								End If
								num = num + 1
							Loop While num <= count
							Dim enumerator3 As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol).Enumerator = value.GetEnumerator()
							While enumerator3.MoveNext()
								Dim localSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol = enumerator3.Current
								If (CObj(item) = CObj(localSymbol)) Then
									Continue While
								End If
								Binder.ReportDiagnostic(diagnostics, localSymbol.IdentifierToken, ERRID.ERR_DuplicateLocalStatic1, New [Object]() { localSymbol.Name })
							End While
						End While
					Finally
						DirectCast(enumerator1, IDisposable).Dispose()
					End Try
				End If
			End If
		End Sub

		Private Sub ReportNoConversionError(ByVal location As SyntaxNode, ByVal sourceType As TypeSymbol, ByVal targetType As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal copybackConversionParamName As String = Nothing)
			' 
			' Current member / type: System.Void Microsoft.CodeAnalysis.VisualBasic.Binder::ReportNoConversionError(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag,System.String)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: System.Void ReportNoConversionError(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag,System.String)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Sub

		Private Shared Sub ReportNoDefaultProperty(ByVal expr As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Dim type As TypeSymbol = expr.Type
			Dim syntax As SyntaxNode = expr.Syntax
			Dim typeKind As Microsoft.CodeAnalysis.TypeKind = type.TypeKind
			If (typeKind = Microsoft.CodeAnalysis.TypeKind.[Class]) Then
				Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_NoDefaultNotExtend1, New [Object]() { type })
				Return
			End If
			If (typeKind <> Microsoft.CodeAnalysis.TypeKind.[Error]) Then
				If (typeKind = Microsoft.CodeAnalysis.TypeKind.Struct) Then
					Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_StructureNoDefault1, New [Object]() { type })
					Return
				End If
				Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_InterfaceNoDefault1, New [Object]() { type })
			End If
		End Sub

		Private Function ReportOverloadResolutionFailureAndProduceBoundNode(ByVal node As SyntaxNode, ByVal group As BoundMethodOrPropertyGroup, ByVal boundArguments As ImmutableArray(Of BoundExpression), ByVal argumentNames As ImmutableArray(Of String), <InAttribute> ByRef results As OverloadResolution.OverloadResolutionResult, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal callerInfoOpt As SyntaxNode, Optional ByVal overrideCommonReturnType As TypeSymbol = Nothing, Optional ByVal queryMode As Boolean = False, Optional ByVal boundTypeExpression As Microsoft.CodeAnalysis.VisualBasic.BoundTypeExpression = Nothing, Optional ByVal representCandidateInDiagnosticsOpt As Symbol = Nothing, Optional ByVal diagnosticLocationOpt As Location = Nothing) As BoundExpression
			Return Me.ReportOverloadResolutionFailureAndProduceBoundNode(node, group.ResultKind, boundArguments, argumentNames, results, diagnostics, callerInfoOpt, group, overrideCommonReturnType, queryMode, boundTypeExpression, representCandidateInDiagnosticsOpt, diagnosticLocationOpt)
		End Function

		Private Function ReportOverloadResolutionFailureAndProduceBoundNode(ByVal node As SyntaxNode, ByVal lookupResult As LookupResultKind, ByVal boundArguments As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression), ByVal argumentNames As ImmutableArray(Of String), <InAttribute> ByRef results As OverloadResolution.OverloadResolutionResult, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal callerInfoOpt As SyntaxNode, Optional ByVal groupOpt As BoundMethodOrPropertyGroup = Nothing, Optional ByVal overrideCommonReturnType As TypeSymbol = Nothing, Optional ByVal queryMode As Boolean = False, Optional ByVal boundTypeExpression As Microsoft.CodeAnalysis.VisualBasic.BoundTypeExpression = Nothing, Optional ByVal representCandidateInDiagnosticsOpt As Symbol = Nothing, Optional ByVal diagnosticLocationOpt As Location = Nothing) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim instance As ArrayBuilder(Of OverloadResolution.CandidateAnalysisResult) = ArrayBuilder(Of OverloadResolution.CandidateAnalysisResult).GetInstance()
			Dim empty As ImmutableArray(Of Symbol) = ImmutableArray(Of Symbol).Empty
			Dim setOfTheBestCandidates As TypeSymbol = Binder.GetSetOfTheBestCandidates(results, instance, empty)
			If (overrideCommonReturnType IsNot Nothing) Then
				setOfTheBestCandidates = overrideCommonReturnType
			End If
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.ReportOverloadResolutionFailureAndProduceBoundNode(node, lookupResult, instance, empty, setOfTheBestCandidates, boundArguments, argumentNames, diagnostics, callerInfoOpt, groupOpt, Nothing, queryMode, boundTypeExpression, representCandidateInDiagnosticsOpt, diagnosticLocationOpt)
			instance.Free()
			Return boundExpression
		End Function

		Private Function ReportOverloadResolutionFailureAndProduceBoundNode(ByVal node As SyntaxNode, ByVal group As BoundMethodOrPropertyGroup, ByVal bestCandidates As ArrayBuilder(Of OverloadResolution.CandidateAnalysisResult), ByVal bestSymbols As ImmutableArray(Of Symbol), ByVal commonReturnType As TypeSymbol, ByVal boundArguments As ImmutableArray(Of BoundExpression), ByVal argumentNames As ImmutableArray(Of String), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal callerInfoOpt As SyntaxNode, Optional ByVal delegateSymbol As Symbol = Nothing, Optional ByVal queryMode As Boolean = False, Optional ByVal boundTypeExpression As Microsoft.CodeAnalysis.VisualBasic.BoundTypeExpression = Nothing, Optional ByVal representCandidateInDiagnosticsOpt As Symbol = Nothing) As BoundExpression
			Return Me.ReportOverloadResolutionFailureAndProduceBoundNode(node, group.ResultKind, bestCandidates, bestSymbols, commonReturnType, boundArguments, argumentNames, diagnostics, callerInfoOpt, group, delegateSymbol, queryMode, boundTypeExpression, representCandidateInDiagnosticsOpt, Nothing)
		End Function

		Private Function ReportOverloadResolutionFailureAndProduceBoundNode(ByVal node As SyntaxNode, ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResultKind, ByVal bestCandidates As ArrayBuilder(Of OverloadResolution.CandidateAnalysisResult), ByVal bestSymbols As ImmutableArray(Of Symbol), ByVal commonReturnType As TypeSymbol, ByVal boundArguments As ImmutableArray(Of BoundExpression), ByVal argumentNames As ImmutableArray(Of String), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal callerInfoOpt As SyntaxNode, Optional ByVal groupOpt As BoundMethodOrPropertyGroup = Nothing, Optional ByVal delegateSymbol As Symbol = Nothing, Optional ByVal queryMode As Boolean = False, Optional ByVal boundTypeExpression As Microsoft.CodeAnalysis.VisualBasic.BoundTypeExpression = Nothing, Optional ByVal representCandidateInDiagnosticsOpt As Symbol = Nothing, Optional ByVal diagnosticLocationOpt As Location = Nothing) As BoundExpression
			Dim immutableAndFree As ImmutableArray(Of BoundExpression)
			Dim arguments As ImmutableArray(Of TypeSymbol)
			Dim state As OverloadResolution.CandidateAnalysisResultState = OverloadResolution.CandidateAnalysisResultState.Count
			If (bestCandidates.Count > 0) Then
				state = bestCandidates(0).State
			End If
			If (boundArguments.IsDefault) Then
				boundArguments = ImmutableArray(Of BoundExpression).Empty
			End If
			Dim item As OverloadResolution.CandidateAnalysisResult = New OverloadResolution.CandidateAnalysisResult()
			Dim candidate As OverloadResolution.Candidate = Nothing
			Dim flag As Boolean = False
			Dim isExpandedParamArrayForm As Boolean = False
			If (bestSymbols.Length = 1 AndAlso bestCandidates.Count < 3) Then
				item = bestCandidates(0)
				candidate = item.Candidate
				isExpandedParamArrayForm = item.IsExpandedParamArrayForm
				flag = Not isExpandedParamArrayForm
				If (bestCandidates.Count > 1) Then
					If (Not bestCandidates(1).IsExpandedParamArrayForm) Then
						flag = True
					Else
						isExpandedParamArrayForm = True
					End If
				End If
			End If
			If (lookupResult = Microsoft.CodeAnalysis.VisualBasic.LookupResultKind.Inaccessible) Then
				If (candidate IsNot Nothing) Then
					GoTo Label1
				End If
				If (Not queryMode) Then
					Binder.ReportDiagnostic(diagnostics, If(groupOpt IsNot Nothing, groupOpt.Syntax, node), ERRID.ERR_NoViableOverloadCandidates1, New [Object]() { bestSymbols(0).Name })
					GoTo Label0
				Else
					GoTo Label0
				End If
			End If
		Label3:
			If (diagnosticLocationOpt Is Nothing) Then
				diagnosticLocationOpt = Binder.GetLocationForOverloadResolutionDiagnostic(node, groupOpt)
			End If
			Select Case state
				Case OverloadResolution.CandidateAnalysisResultState.Applicable
					If (Not bestCandidates(0).RequiresNarrowingConversion) Then
						Binder.ReportUnspecificProcedures(diagnosticLocationOpt, bestSymbols, diagnostics, CObj(delegateSymbol) <> CObj(Nothing))
						Exit Select
					Else
						Me.ReportOverloadResolutionFailureForASetOfCandidates(node, diagnosticLocationOpt, lookupResult, If(delegateSymbol Is Nothing, ERRID.ERR_NoNonNarrowingOverloadCandidates2, ERRID.ERR_DelegateBindingFailure3), bestCandidates, boundArguments, argumentNames, diagnostics, delegateSymbol, queryMode, callerInfoOpt)
						Exit Select
					End If
				Case OverloadResolution.CandidateAnalysisResultState.HasUnsupportedMetadata
				Case OverloadResolution.CandidateAnalysisResultState.HasUseSiteError
					If (candidate Is Nothing) Then
						Me.ReportOverloadResolutionFailureForASetOfCandidates(node, diagnosticLocationOpt, lookupResult, ERRID.ERR_BadOverloadCandidates2, bestCandidates, boundArguments, argumentNames, diagnostics, delegateSymbol, queryMode, callerInfoOpt)
						Exit Select
					Else
						Me.ReportOverloadResolutionFailureForASingleCandidate(node, diagnosticLocationOpt, lookupResult, item, boundArguments, argumentNames, flag, isExpandedParamArrayForm, True, False, diagnostics, delegateSymbol, queryMode, callerInfoOpt, representCandidateInDiagnosticsOpt)
						Exit Select
					End If
				Case OverloadResolution.CandidateAnalysisResultState.Ambiguous
					Dim originalDefinition As Symbol = bestSymbols(0).OriginalDefinition
					Dim containingSymbol As Symbol = originalDefinition.ContainingSymbol
					Binder.ReportDiagnostic(diagnostics, diagnosticLocationOpt, ERRID.ERR_MetadataMembersAmbiguous3, New [Object]() { originalDefinition.Name, containingSymbol.GetKindText(), containingSymbol })
					Exit Select
				Case OverloadResolution.CandidateAnalysisResultState.BadGenericArity
					Dim boundMethodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup = DirectCast(groupOpt, Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup)
					If (candidate Is Nothing) Then
						Binder.ReportDiagnostic(diagnostics, diagnosticLocationOpt, ERRID.ERR_NoTypeArgumentCountOverloadCand1, New [Object]() { CustomSymbolDisplayFormatter.ShortErrorName(bestSymbols(0)) })
						Exit Select
					Else
						If (boundMethodGroup.TypeArgumentsOpt IsNot Nothing) Then
							arguments = boundMethodGroup.TypeArgumentsOpt.Arguments
						Else
							arguments = ImmutableArray(Of TypeSymbol).Empty
						End If
						Dim empty As ImmutableArray(Of TypeSymbol) = arguments
						If (empty.IsDefault) Then
							empty = ImmutableArray(Of TypeSymbol).Empty
						End If
						Dim underlyingSymbol As Symbol = candidate.UnderlyingSymbol
						Dim isExtensionMethod As Boolean = candidate.IsExtensionMethod
						If (candidate.Arity < empty.Length) Then
							If (Not isExtensionMethod) Then
								Binder.ReportDiagnostic(diagnostics, boundMethodGroup.TypeArgumentsOpt.Syntax, If(candidate.Arity = 0, ERRID.ERR_TypeOrMemberNotGeneric1, ERRID.ERR_TooManyGenericArguments1), New [Object]() { underlyingSymbol })
								Exit Select
							Else
								Binder.ReportDiagnostic(diagnostics, boundMethodGroup.TypeArgumentsOpt.Syntax, If(candidate.Arity = 0, ERRID.ERR_TypeOrMemberNotGeneric2, ERRID.ERR_TooManyGenericArguments2), New [Object]() { underlyingSymbol, underlyingSymbol.ContainingType })
								Exit Select
							End If
						ElseIf (Not isExtensionMethod) Then
							Binder.ReportDiagnostic(diagnostics, boundMethodGroup.TypeArgumentsOpt.Syntax, ERRID.ERR_TooFewGenericArguments1, New [Object]() { underlyingSymbol })
							Exit Select
						Else
							Binder.ReportDiagnostic(diagnostics, boundMethodGroup.TypeArgumentsOpt.Syntax, ERRID.ERR_TooFewGenericArguments2, New [Object]() { underlyingSymbol, underlyingSymbol.ContainingType })
							Exit Select
						End If
					End If
				Case OverloadResolution.CandidateAnalysisResultState.ArgumentCountMismatch
					If (node.Kind() = SyntaxKind.IdentifierName AndAlso node.Parent IsNot Nothing AndAlso node.Parent.Kind() = SyntaxKind.NamedFieldInitializer AndAlso groupOpt IsNot Nothing AndAlso groupOpt.Kind = BoundKind.PropertyGroup) Then
						Binder.ReportDiagnostic(diagnostics, diagnosticLocationOpt, If(candidate IsNot Nothing, ERRID.ERR_ParameterizedPropertyInAggrInit1, ERRID.ERR_NoZeroCountArgumentInitCandidates1), New [Object]() { CustomSymbolDisplayFormatter.ShortErrorName(bestSymbols(0)) })
						Exit Select
					ElseIf (candidate Is Nothing OrElse queryMode AndAlso candidate.ParameterCount > boundArguments.Length) Then
						Binder.ReportDiagnostic(diagnostics, diagnosticLocationOpt, ERRID.ERR_NoArgumentCountOverloadCandidates1, New [Object]() { CustomSymbolDisplayFormatter.ShortErrorName(bestSymbols(0)) })
						Exit Select
					Else
						Me.ReportOverloadResolutionFailureForASingleCandidate(node, diagnosticLocationOpt, lookupResult, item, boundArguments, argumentNames, flag, isExpandedParamArrayForm, True, False, diagnostics, delegateSymbol, queryMode, callerInfoOpt, representCandidateInDiagnosticsOpt)
						Exit Select
					End If
				Case OverloadResolution.CandidateAnalysisResultState.TypeInferenceFailed
					If (candidate Is Nothing) Then
						Me.ReportOverloadResolutionFailureForASetOfCandidates(node, diagnosticLocationOpt, lookupResult, ERRID.ERR_NoCallableOverloadCandidates2, bestCandidates, boundArguments, argumentNames, diagnostics, delegateSymbol, queryMode, callerInfoOpt)
						Exit Select
					Else
						Me.ReportOverloadResolutionFailureForASingleCandidate(node, diagnosticLocationOpt, lookupResult, item, boundArguments, argumentNames, flag, isExpandedParamArrayForm, True, False, diagnostics, delegateSymbol, queryMode, callerInfoOpt, representCandidateInDiagnosticsOpt)
						Exit Select
					End If
				Case OverloadResolution.CandidateAnalysisResultState.ArgumentMismatch
				Case OverloadResolution.CandidateAnalysisResultState.GenericConstraintsViolated
					Dim flag1 As Boolean = False
					Dim length As Integer = boundArguments.Length - 1
					Dim num As Integer = 0
					While num <= length
						Dim type As TypeSymbol = boundArguments(num).Type
						If (boundArguments(num).HasErrors OrElse type IsNot Nothing AndAlso type.IsErrorType()) Then
							flag1 = True
							Exit While
						Else
							num = num + 1
						End If
					End While
					If (flag1) Then
						Exit Select
					End If
					If (candidate Is Nothing) Then
						Me.ReportOverloadResolutionFailureForASetOfCandidates(node, diagnosticLocationOpt, lookupResult, If(delegateSymbol Is Nothing, ERRID.ERR_NoCallableOverloadCandidates2, ERRID.ERR_DelegateBindingFailure3), bestCandidates, boundArguments, argumentNames, diagnostics, delegateSymbol, queryMode, callerInfoOpt)
						Exit Select
					Else
						Me.ReportOverloadResolutionFailureForASingleCandidate(node, diagnosticLocationOpt, lookupResult, item, boundArguments, argumentNames, flag, isExpandedParamArrayForm, True, False, diagnostics, delegateSymbol, queryMode, callerInfoOpt, representCandidateInDiagnosticsOpt)
						Exit Select
					End If
				Case Else
					Throw ExceptionUtilities.UnexpectedValue(state)
			End Select
			If (Not boundArguments.IsEmpty OrElse boundTypeExpression IsNot Nothing) Then
				Dim instance As ArrayBuilder(Of BoundExpression) = ArrayBuilder(Of BoundExpression).GetInstance()
				If (groupOpt IsNot Nothing) Then
					instance.Add(groupOpt)
				End If
				If (Not boundArguments.IsEmpty) Then
					instance.AddRange(boundArguments)
				End If
				If (boundTypeExpression IsNot Nothing) Then
					instance.Add(boundTypeExpression)
				End If
				immutableAndFree = instance.ToImmutableAndFree()
			ElseIf (groupOpt IsNot Nothing) Then
				immutableAndFree = ImmutableArray.Create(Of BoundExpression)(groupOpt)
			Else
				immutableAndFree = ImmutableArray(Of BoundExpression).Empty
			End If
			Dim lookupResultKind As Microsoft.CodeAnalysis.VisualBasic.LookupResultKind = Microsoft.CodeAnalysis.VisualBasic.LookupResultKind.OverloadResolutionFailure
			If (lookupResult < lookupResultKind) Then
				lookupResultKind = lookupResult
			End If
			Return New BoundBadExpression(node, lookupResultKind, bestSymbols, immutableAndFree, commonReturnType, True)
		Label1:
			Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
			Binder.ReportDiagnostic(bindingDiagnosticBag, If(groupOpt IsNot Nothing, groupOpt.Syntax, node), Me.GetInaccessibleErrorInfo(candidate.UnderlyingSymbol))
			GoTo Label3
		End Function

		Private Sub ReportOverloadResolutionFailureForASetOfCandidates(ByVal node As Microsoft.CodeAnalysis.SyntaxNode, ByVal diagnosticLocation As Microsoft.CodeAnalysis.Location, ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResultKind, ByVal errorNo As ERRID, ByVal candidates As ArrayBuilder(Of OverloadResolution.CandidateAnalysisResult), ByVal arguments As ImmutableArray(Of BoundExpression), ByVal argumentNames As ImmutableArray(Of String), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal delegateSymbol As Symbol, ByVal queryMode As Boolean, ByVal callerInfoOpt As Microsoft.CodeAnalysis.SyntaxNode)
			Dim count As Integer
			Dim instance As ArrayBuilder(Of KeyValuePair(Of Symbol, ImmutableBindingDiagnostic(Of AssemblySymbol))) = ArrayBuilder(Of KeyValuePair(Of Symbol, ImmutableBindingDiagnostic(Of AssemblySymbol))).GetInstance(candidates.Count)
			If (arguments.IsDefault) Then
				arguments = ImmutableArray(Of BoundExpression).Empty
			End If
			Dim num As Integer = candidates.Count - 1
			Dim num1 As Integer = 0
			Do
				Dim item As OverloadResolution.CandidateAnalysisResult = candidates(num1)
				Dim isExpandedParamArrayForm As Boolean = item.IsExpandedParamArrayForm
				Dim flag As Boolean = Not isExpandedParamArrayForm
				If (flag AndAlso num1 + 1 < candidates.Count) Then
					item = candidates(num1 + 1)
					If (item.IsExpandedParamArrayForm AndAlso candidates(num1 + 1).Candidate.UnderlyingSymbol.Equals(candidates(num1).Candidate.UnderlyingSymbol)) Then
						isExpandedParamArrayForm = True
						num1 = num1 + 1
					End If
				End If
				Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.GetInstance(diagnostics)
				Dim syntaxNode As Microsoft.CodeAnalysis.SyntaxNode = node
				Dim location As Microsoft.CodeAnalysis.Location = diagnosticLocation
				Dim lookupResultKind As Microsoft.CodeAnalysis.VisualBasic.LookupResultKind = lookupResult
				Dim candidateAnalysisResults As ArrayBuilder(Of OverloadResolution.CandidateAnalysisResult) = candidates
				Dim candidateAnalysisResults1 As ArrayBuilder(Of OverloadResolution.CandidateAnalysisResult) = candidateAnalysisResults
				Dim num2 As Integer = num1
				count = num2
				item = candidateAnalysisResults(num2)
				Me.ReportOverloadResolutionFailureForASingleCandidate(syntaxNode, location, lookupResultKind, item, arguments, argumentNames, flag, isExpandedParamArrayForm, False, errorNo = If(delegateSymbol Is Nothing, ERRID.ERR_NoNonNarrowingOverloadCandidates2, ERRID.ERR_DelegateBindingFailure3), bindingDiagnosticBag, delegateSymbol, queryMode, callerInfoOpt, Nothing)
				candidateAnalysisResults1(count) = item
				instance.Add(KeyValuePairUtil.Create(Of Symbol, ImmutableBindingDiagnostic(Of AssemblySymbol))(candidates(num1).Candidate.UnderlyingSymbol, bindingDiagnosticBag.ToReadOnlyAndFree()))
				num1 = num1 + 1
			Loop While num1 <= num
			If (Not Binder.ReportCommonErrorsFromLambdas(instance, arguments, diagnostics)) Then
				Dim diagnosticInfos As ArrayBuilder(Of DiagnosticInfo) = ArrayBuilder(Of DiagnosticInfo).GetInstance(candidates.Count)
				count = instance.Count - 1
				Dim num3 As Integer = 0
				Do
					Dim key As Symbol = instance(num3).Key
					Dim flag1 As Boolean = key.IsReducedExtensionMethod()
					Dim diagnostics1 As ImmutableArray(Of Microsoft.CodeAnalysis.Diagnostic) = instance(num3).Value.Diagnostics
					If (delegateSymbol IsNot Nothing AndAlso DirectCast(diagnostics1, IEnumerable(Of Microsoft.CodeAnalysis.Diagnostic)).Skip(1).Any()) Then
						If (Not flag1) Then
							Dim objArray() As [Object] = { key, Nothing }
							objArray(1) = ErrorFactory.ErrorInfo(ERRID.ERR_DelegateBindingMismatch, New [Object]() { key })
							diagnosticInfos.Add(ErrorFactory.ErrorInfo(ERRID.ERR_OverloadCandidate2, objArray))
						Else
							Dim containingType() As [Object] = { key, key.ContainingType, Nothing }
							containingType(2) = ErrorFactory.ErrorInfo(ERRID.ERR_DelegateBindingMismatch, New [Object]() { key })
							diagnosticInfos.Add(ErrorFactory.ErrorInfo(ERRID.ERR_ExtensionMethodOverloadCandidate3, containingType))
						End If
					ElseIf (Not flag1) Then
						Dim enumerator As ImmutableArray(Of Microsoft.CodeAnalysis.Diagnostic).Enumerator = diagnostics1.GetEnumerator()
						While enumerator.MoveNext()
							Dim current As Microsoft.CodeAnalysis.Diagnostic = enumerator.Current
							VisualBasicDiagnosticFormatter.Instance.Format(current.WithLocation(Microsoft.CodeAnalysis.Location.None), Nothing)
							diagnosticInfos.Add(ErrorFactory.ErrorInfo(ERRID.ERR_OverloadCandidate2, New [Object]() { key, DirectCast(current, DiagnosticWithInfo).Info }))
						End While
					Else
						Dim enumerator1 As ImmutableArray(Of Microsoft.CodeAnalysis.Diagnostic).Enumerator = diagnostics1.GetEnumerator()
						While enumerator1.MoveNext()
							Dim diagnostic As Microsoft.CodeAnalysis.Diagnostic = enumerator1.Current
							diagnosticInfos.Add(ErrorFactory.ErrorInfo(ERRID.ERR_ExtensionMethodOverloadCandidate3, New [Object]() { key, key.ContainingType, DirectCast(diagnostic, DiagnosticWithInfo).Info }))
						End While
					End If
					num3 = num3 + 1
				Loop While num3 <= count
				Dim arrayAndFree As DiagnosticInfo() = diagnosticInfos.ToArrayAndFree()
				If (delegateSymbol IsNot Nothing) Then
					Binder.ReportDiagnostic(diagnostics, diagnosticLocation, ErrorFactory.ErrorInfo(errorNo, New [Object]() { CustomSymbolDisplayFormatter.ShortErrorName(candidates(0).Candidate.UnderlyingSymbol), CustomSymbolDisplayFormatter.DelegateSignature(delegateSymbol), New CompoundDiagnosticInfo(arrayAndFree) }))
				Else
					Binder.ReportDiagnostic(diagnostics, diagnosticLocation, ErrorFactory.ErrorInfo(errorNo, New [Object]() { CustomSymbolDisplayFormatter.ShortErrorName(candidates(0).Candidate.UnderlyingSymbol), New CompoundDiagnosticInfo(arrayAndFree) }))
				End If
			End If
			instance.Free()
		End Sub

		Private Sub ReportOverloadResolutionFailureForASingleCandidate(ByVal node As SyntaxNode, ByVal diagnosticLocation As Location, ByVal lookupResult As LookupResultKind, ByRef candidateAnalysisResult As OverloadResolution.CandidateAnalysisResult, ByVal arguments As ImmutableArray(Of BoundExpression), ByVal argumentNames As ImmutableArray(Of String), ByVal allowUnexpandedParamArrayForm As Boolean, ByVal allowExpandedParamArrayForm As Boolean, ByVal includeMethodNameInErrorMessages As Boolean, ByVal reportNarrowingConversions As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal delegateSymbol As Symbol, ByVal queryMode As Boolean, ByVal callerInfoOpt As SyntaxNode, ByVal representCandidateInDiagnosticsOpt As Symbol)
			' 
			' Current member / type: System.Void Microsoft.CodeAnalysis.VisualBasic.Binder::ReportOverloadResolutionFailureForASingleCandidate(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.VisualBasic.LookupResultKind,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution/CandidateAnalysisResult&,System.Collections.Immutable.ImmutableArray`1<Microsoft.CodeAnalysis.VisualBasic.BoundExpression>,System.Collections.Immutable.ImmutableArray`1<System.String>,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Symbol,System.Boolean,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbol)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: System.Void ReportOverloadResolutionFailureForASingleCandidate(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.VisualBasic.LookupResultKind,Microsoft.CodeAnalysis.VisualBasic.OverloadResolution/CandidateAnalysisResult&,System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.VisualBasic.BoundExpression>,System.Collections.Immutable.ImmutableArray<System.String>,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag,Microsoft.CodeAnalysis.VisualBasic.Symbol,System.Boolean,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.Symbol)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Sub

		Private Shared Sub ReportQualNotObjectRecord(ByVal expr As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Binder.ReportDiagnostic(diagnostics, expr.Syntax, ERRID.ERR_QualNotObjectRecord1, New [Object]() { expr.Type })
		End Sub

		Private Sub ReportUndefinedOperatorError(ByVal syntax As SyntaxNode, ByVal left As BoundExpression, ByVal right As BoundExpression, ByVal operatorTokenKind As SyntaxKind, ByVal operatorKind As BinaryOperatorKind, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Dim discarded As CompoundUseSiteInfo(Of AssemblySymbol)
			Dim type As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = left.Type
			Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = right.Type
			If (Not type.IsErrorType() AndAlso Not typeSymbol.IsErrorType()) Then
				Dim text As String = SyntaxFacts.GetText(operatorTokenKind)
				If (OverloadResolution.UseUserDefinedBinaryOperators(operatorKind, type, typeSymbol)) Then
					discarded = CompoundUseSiteInfo(Of AssemblySymbol).Discarded
					If (Not type.CanContainUserDefinedOperators(discarded)) Then
						discarded = CompoundUseSiteInfo(Of AssemblySymbol).Discarded
						If (Not typeSymbol.CanContainUserDefinedOperators(discarded) AndAlso (operatorKind = BinaryOperatorKind.Equals OrElse operatorKind = BinaryOperatorKind.NotEquals) AndAlso type.IsReferenceType AndAlso typeSymbol.IsReferenceType) Then
							Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_ReferenceComparison3, New [Object]() { text, type, typeSymbol })
							Return
						End If
					End If
				End If
				discarded = CompoundUseSiteInfo(Of AssemblySymbol).Discarded
				If (Me.IsIEnumerableOfXElement(type, discarded)) Then
					Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_BinaryOperandsForXml4, New [Object]() { text, type, typeSymbol, type })
					Return
				End If
				discarded = CompoundUseSiteInfo(Of AssemblySymbol).Discarded
				If (Me.IsIEnumerableOfXElement(typeSymbol, discarded)) Then
					Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_BinaryOperandsForXml4, New [Object]() { text, type, typeSymbol, typeSymbol })
					Return
				End If
				Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_BinaryOperands3, New [Object]() { text, type, typeSymbol })
			End If
		End Sub

		Private Shared Sub ReportUndefinedOperatorError(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax, ByVal operand As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			If (Not operand.Type.IsErrorType()) Then
				Dim syntaxNodeOrToken As Microsoft.CodeAnalysis.SyntaxNodeOrToken = syntax
				Dim operatorToken As Microsoft.CodeAnalysis.SyntaxToken = syntax.OperatorToken
				Binder.ReportDiagnostic(diagnostics, syntaxNodeOrToken, ErrorFactory.ErrorInfo(ERRID.ERR_UnaryOperand2, operatorToken, operand.Type))
			End If
		End Sub

		Private Shared Sub ReportUnspecificProcedures(ByVal diagnosticLocation As Location, ByVal bestSymbols As ImmutableArray(Of Symbol), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal isDelegateContext As Boolean)
			Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.DiagnosticInfo) = ArrayBuilder(Of Microsoft.CodeAnalysis.DiagnosticInfo).GetInstance(bestSymbols.Length)
			Dim diagnosticInfo As Microsoft.CodeAnalysis.DiagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_NotMostSpecificOverload)
			Dim flag As Boolean = False
			If (Not bestSymbols(0).IsReducedExtensionMethod()) Then
				Dim containingType As NamedTypeSymbol = bestSymbols(0).ContainingType
				Dim length As Integer = bestSymbols.Length - 1
				For i As Integer = 1 To length
					If (Not TypeSymbol.Equals(bestSymbols(i).ContainingType, containingType, TypeCompareKind.ConsiderEverything)) Then
						flag = True
					End If
				Next

			End If
			Dim num As Integer = bestSymbols.Length - 1
			Dim num1 As Integer = 0
			Do
				Dim item As Symbol = bestSymbols(num1)
				Dim flag1 As Boolean = item.IsReducedExtensionMethod()
				If (isDelegateContext) Then
					If (flag1) Then
						instance.Add(ErrorFactory.ErrorInfo(ERRID.ERR_ExtensionMethodOverloadCandidate2, New [Object]() { item, item.ContainingType }))
					ElseIf (Not flag) Then
						instance.Add(ErrorFactory.ErrorInfo(ERRID.ERR_OverloadCandidate1, New [Object]() { item }))
					Else
						instance.Add(ErrorFactory.ErrorInfo(ERRID.ERR_OverloadCandidate1, New [Object]() { CustomSymbolDisplayFormatter.WithContainingType(item) }))
					End If
				ElseIf (flag1) Then
					instance.Add(ErrorFactory.ErrorInfo(ERRID.ERR_ExtensionMethodOverloadCandidate3, New [Object]() { item, item.ContainingType, diagnosticInfo }))
				ElseIf (Not flag) Then
					instance.Add(ErrorFactory.ErrorInfo(ERRID.ERR_OverloadCandidate2, New [Object]() { item, diagnosticInfo }))
				Else
					instance.Add(ErrorFactory.ErrorInfo(ERRID.ERR_OverloadCandidate2, New [Object]() { CustomSymbolDisplayFormatter.WithContainingType(item), diagnosticInfo }))
				End If
				num1 = num1 + 1
			Loop While num1 <= num
			Binder.ReportDiagnostic(diagnostics, diagnosticLocation, ErrorFactory.ErrorInfo(If(isDelegateContext, ERRID.ERR_AmbiguousDelegateBinding2, ERRID.ERR_NoMostSpecificOverload2), New [Object]() { CustomSymbolDisplayFormatter.ShortErrorName(bestSymbols(0)), New CompoundDiagnosticInfo(instance.ToArrayAndFree()) }))
		End Sub

		Private Shared Sub ReportUseOfModuleOrVoidType(ByVal typeSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax, ByVal type As TypeSymbol, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			If (type.SpecialType = SpecialType.System_Void) Then
				Binder.ReportDiagnostic(diagBag, typeSyntax, New BadSymbolDiagnostic(type, ERRID.ERR_BadUseOfVoid))
				Return
			End If
			If (type.IsModuleType()) Then
				Binder.ReportDiagnostic(diagBag, typeSyntax, New BadSymbolDiagnostic(type, ERRID.ERR_ModuleAsType1))
			End If
		End Sub

		Public Shared Function ReportUseSite(ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal syntax As SyntaxNodeOrToken, ByVal useSiteInfo As UseSiteInfo(Of AssemblySymbol)) As Boolean
			Return diagBag.Add(useSiteInfo, syntax.GetLocation())
		End Function

		Public Shared Function ReportUseSite(ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal location As Microsoft.CodeAnalysis.Location, ByVal useSiteInfo As UseSiteInfo(Of AssemblySymbol)) As Boolean
			Return diagBag.Add(useSiteInfo, location)
		End Function

		Friend Shared Function ReportUseSite(ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal syntax As SyntaxNodeOrToken, ByVal symbol As Microsoft.CodeAnalysis.VisualBasic.Symbol) As Boolean
			Return Binder.ReportUseSite(diagBag, syntax, symbol.GetUseSiteInfo())
		End Function

		Friend Function ReportUseSiteInfoForSynthesizedAttribute(ByVal attributeCtor As WellKnownMember, ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
			Dim flag As Boolean
			Dim useSiteInfo As UseSiteInfo(Of AssemblySymbol) = New UseSiteInfo(Of AssemblySymbol)()
			Binder.GetWellKnownTypeMember(Me.Compilation, attributeCtor, useSiteInfo)
			If (WellKnownMembers.IsSynthesizedAttributeOptional(attributeCtor)) Then
				diagnostics.AddDependencies(useSiteInfo)
			Else
				If (Not Binder.ReportUseSite(diagnostics, syntax, useSiteInfo)) Then
					flag = False
					Return flag
				End If
				flag = True
				Return flag
			End If
			flag = False
			Return flag
		End Function

		Friend Shared Function ReportUseSiteInfoForSynthesizedAttribute(ByVal attributeCtor As WellKnownMember, ByVal compilation As VisualBasicCompilation, ByVal location As Microsoft.CodeAnalysis.Location, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
			Dim flag As Boolean
			Dim useSiteInfoForWellKnownTypeMember As UseSiteInfo(Of AssemblySymbol) = Binder.GetUseSiteInfoForWellKnownTypeMember(compilation.GetWellKnownTypeMember(attributeCtor), attributeCtor, compilation.Options.EmbedVbCoreRuntime)
			If (WellKnownMembers.IsSynthesizedAttributeOptional(attributeCtor)) Then
				diagnostics.AddDependencies(useSiteInfoForWellKnownTypeMember)
			Else
				If (Not diagnostics.Add(useSiteInfoForWellKnownTypeMember, location)) Then
					flag = False
					Return flag
				End If
				flag = True
				Return flag
			End If
			flag = False
			Return flag
		End Function

		Private Function ReportXmlNamespacePrefixNotDefined(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal prefixToken As Microsoft.CodeAnalysis.SyntaxToken, ByVal prefix As String, ByVal compilerGenerated As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression
			Binder.ReportDiagnostic(diagnostics, prefixToken, ERRID.ERR_UndefinedXmlPrefix, New [Object]() { prefix })
			Dim boundBadExpression As Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression = Binder.BadExpression(syntax, Me.Compilation.GetSpecialType(SpecialType.System_String))
			If (compilerGenerated) Then
				boundBadExpression.SetWasCompilerGenerated()
			End If
			Return boundBadExpression
		End Function

		Friend Shared Function ResolveMethodForDelegateInvokeFullAndRelaxed(ByVal addressOfExpression As BoundAddressOfOperator, ByVal toMethod As MethodSymbol, ByVal ignoreMethodReturnType As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As KeyValuePair(Of MethodSymbol, MethodConversionKind)
			Dim instance As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.GetInstance(diagnostics)
			Dim flag As Boolean = True
			Dim keyValuePair As KeyValuePair(Of MethodSymbol, MethodConversionKind) = Binder.ResolveMethodForDelegateInvokeFullOrRelaxed(addressOfExpression, toMethod, ignoreMethodReturnType, instance, False, flag)
			If (keyValuePair.Key IsNot Nothing OrElse Not flag) Then
				diagnostics.AddRange(instance, False)
			Else
				Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.GetInstance(diagnostics)
				Dim keyValuePair1 As KeyValuePair(Of MethodSymbol, MethodConversionKind) = keyValuePair
				keyValuePair = Binder.ResolveMethodForDelegateInvokeFullOrRelaxed(addressOfExpression, toMethod, ignoreMethodReturnType, bindingDiagnosticBag, True, flag)
				If (keyValuePair.Key IsNot Nothing) Then
					diagnostics.AddRange(bindingDiagnosticBag, False)
				Else
					diagnostics.AddRange(instance, False)
					keyValuePair = keyValuePair1
				End If
				bindingDiagnosticBag.Free()
			End If
			instance.Free()
			Return keyValuePair
		End Function

		Private Shared Function ResolveMethodForDelegateInvokeFullOrRelaxed(ByVal addressOfExpression As BoundAddressOfOperator, ByVal toMethod As MethodSymbol, ByVal ignoreMethodReturnType As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal useZeroArgumentRelaxation As Boolean, ByRef couldTryZeroArgumentRelaxation As Boolean) As KeyValuePair(Of MethodSymbol, MethodConversionKind)
			Dim keyValuePair As KeyValuePair(Of MethodSymbol, MethodConversionKind)
			Dim returnType As TypeSymbol
			Dim boundNode As Microsoft.CodeAnalysis.VisualBasic.BoundNode
			Dim binder As Microsoft.CodeAnalysis.VisualBasic.Binder
			Dim empty As ImmutableArray(Of BoundExpression) = ImmutableArray(Of BoundExpression).Empty
			If (Not useZeroArgumentRelaxation) Then
				Dim parameters As ImmutableArray(Of ParameterSymbol) = toMethod.Parameters
				Dim length As Integer = parameters.Length
				If (length <= 0) Then
					couldTryZeroArgumentRelaxation = False
				Else
					Dim boundExpressionArray(length - 1 + 1 - 1) As BoundExpression
					Dim num As Integer = 0
					Dim syntax As Microsoft.CodeAnalysis.SyntaxNode = addressOfExpression.Syntax
					Dim syntaxTree As Microsoft.CodeAnalysis.SyntaxTree = addressOfExpression.Binder.SyntaxTree
					Dim enumerator As ImmutableArray(Of ParameterSymbol).Enumerator = parameters.GetEnumerator()
					While enumerator.MoveNext()
						Dim current As ParameterSymbol = enumerator.Current
						Dim type As TypeSymbol = current.Type
						Dim synthesizedLocal As Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLocal = New Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLocal(toMethod, type, SynthesizedLocalKind.LoweringTemp, Nothing, False)
						Dim boundLocal As BoundExpression = New Microsoft.CodeAnalysis.VisualBasic.BoundLocal(syntax, synthesizedLocal, type)
						If (Not current.IsByRef) Then
							boundLocal = boundLocal.MakeRValue()
						End If
						boundExpressionArray(num) = boundLocal
						num = num + 1
					End While
					empty = Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of BoundExpression)(boundExpressionArray)
				End If
			End If
			If (Not ignoreMethodReturnType) Then
				returnType = toMethod.ReturnType
				boundNode = addressOfExpression
			Else
				returnType = Nothing
				boundNode = Nothing
			End If
			If (addressOfExpression.Binder.OptionStrict = Microsoft.CodeAnalysis.VisualBasic.OptionStrict.Off) Then
				binder = addressOfExpression.Binder
			Else
				binder = New Microsoft.CodeAnalysis.VisualBasic.Binder.OptionStrictOffBinder(addressOfExpression.Binder)
			End If
			Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = addressOfExpression.Binder.GetNewCompoundUseSiteInfo(diagnostics)
			Dim methodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup = addressOfExpression.MethodGroup
			Dim strs As ImmutableArray(Of String) = New ImmutableArray(Of String)()
			Dim overloadResolutionResult As OverloadResolution.OverloadResolutionResult = OverloadResolution.MethodInvocationOverloadResolution(methodGroup, empty, strs, binder, Nothing, newCompoundUseSiteInfo, False, returnType, boundNode, False, False, False)
			If (diagnostics.Add(addressOfExpression.MethodGroup, newCompoundUseSiteInfo)) Then
				couldTryZeroArgumentRelaxation = False
				If (addressOfExpression.MethodGroup.ResultKind <> LookupResultKind.Inaccessible) Then
					diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
				End If
			End If
			Dim boundMethodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup = addressOfExpression.MethodGroup
			If (Not overloadResolutionResult.BestResult.HasValue) Then
				If (overloadResolutionResult.Candidates.Length = 0) Then
					strs = New ImmutableArray(Of String)()
					overloadResolutionResult = OverloadResolution.MethodInvocationOverloadResolution(boundMethodGroup, empty, strs, binder, Nothing, newCompoundUseSiteInfo, True, returnType, boundNode, False, False, False)
				End If
				Dim instance As ArrayBuilder(Of OverloadResolution.CandidateAnalysisResult) = ArrayBuilder(Of OverloadResolution.CandidateAnalysisResult).GetInstance()
				Dim symbols As ImmutableArray(Of Symbol) = ImmutableArray(Of Symbol).Empty
				Dim setOfTheBestCandidates As TypeSymbol = Microsoft.CodeAnalysis.VisualBasic.Binder.GetSetOfTheBestCandidates(overloadResolutionResult, instance, symbols)
				Dim state As OverloadResolution.CandidateAnalysisResultState = instance(0).State
				If (state = OverloadResolution.CandidateAnalysisResultState.Applicable AndAlso Not instance(0).RequiresNarrowingConversion) Then
					couldTryZeroArgumentRelaxation = False
				End If
				If (symbols.Length <> 1 OrElse state <> OverloadResolution.CandidateAnalysisResultState.ArgumentCountMismatch AndAlso state <> OverloadResolution.CandidateAnalysisResultState.ArgumentMismatch) Then
					If (state = OverloadResolution.CandidateAnalysisResultState.HasUseSiteError OrElse state = OverloadResolution.CandidateAnalysisResultState.HasUnsupportedMetadata OrElse state = OverloadResolution.CandidateAnalysisResultState.Ambiguous) Then
						couldTryZeroArgumentRelaxation = False
					End If
					Dim syntaxNode As Microsoft.CodeAnalysis.SyntaxNode = addressOfExpression.MethodGroup.Syntax
					strs = New ImmutableArray(Of String)()
					binder.ReportOverloadResolutionFailureAndProduceBoundNode(syntaxNode, boundMethodGroup, instance, symbols, setOfTheBestCandidates, empty, strs, diagnostics, Nothing, toMethod.ContainingType, False, Nothing, Nothing)
				Else
					Dim operand As Microsoft.CodeAnalysis.SyntaxNode = addressOfExpression.Syntax
					If (operand.Kind() = SyntaxKind.AddressOfExpression) Then
						operand = DirectCast(operand, Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax).Operand
					End If
					If (addressOfExpression.MethodGroup.ResultKind = LookupResultKind.Inaccessible) Then
						Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagnostics, operand, addressOfExpression.Binder.GetInaccessibleErrorInfo(symbols(0)))
					End If
					Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDelegateBindingIncompatible(operand, toMethod.ContainingType, DirectCast(symbols(0), MethodSymbol), diagnostics)
				End If
				instance.Free()
				keyValuePair = New KeyValuePair(Of MethodSymbol, MethodConversionKind)(Nothing, MethodConversionKind.Error_OverloadResolution)
			Else
				Dim bestResult As Nullable(Of OverloadResolution.CandidateAnalysisResult) = overloadResolutionResult.BestResult
				keyValuePair = Microsoft.CodeAnalysis.VisualBasic.Binder.ValidateMethodForDelegateInvoke(addressOfExpression, bestResult.Value, toMethod, ignoreMethodReturnType, useZeroArgumentRelaxation, diagnostics)
			End If
			Return keyValuePair
		End Function

		Private Shared Function ShadowsRangeVariableInTheChildScope(ByVal childScopeBinder As Binder, ByVal rangeVar As RangeVariableSymbol) As Boolean
			Dim flag As Boolean
			Dim instance As LookupResult = LookupResult.GetInstance()
			Dim name As String = rangeVar.Name
			Dim discarded As CompoundUseSiteInfo(Of AssemblySymbol) = CompoundUseSiteInfo(Of AssemblySymbol).Discarded
			childScopeBinder.LookupInSingleBinder(instance, name, 0, LookupOptions.[Default], childScopeBinder, discarded)
			flag = If(Not instance.IsGood, False, instance.Symbols(0).Kind = SymbolKind.RangeVariable)
			instance.Free()
			Return flag
		End Function

		Private Function ShouldBindWithoutArguments(ByVal node As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByRef group As BoundMethodOrPropertyGroup, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
			Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
			Dim flag As Boolean = Me.ShouldBindWithoutArguments(group, newCompoundUseSiteInfo)
			diagnostics.Add(node, newCompoundUseSiteInfo)
			Return flag
		End Function

		Private Function ShouldBindWithoutArguments(ByRef group As BoundMethodOrPropertyGroup, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol)) As Boolean
			Dim flag As Boolean
			If (group.Kind <> BoundKind.MethodGroup) Then
				Dim enumerator As ImmutableArray(Of PropertySymbol).Enumerator = DirectCast(group, BoundPropertyGroup).Properties.GetEnumerator()
				While enumerator.MoveNext()
					If (enumerator.Current.ParameterCount <= 0) Then
						Continue While
					End If
					flag = False
					Return flag
				End While
				flag = True
			Else
				Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol).GetInstance()
				Dim boundMethodGroup As Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup = DirectCast(group, Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup)
				Dim flag1 As Boolean = False
				Dim flag2 As Boolean = False
				Dim methodSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol = Nothing
				Dim enumerator1 As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol).Enumerator = boundMethodGroup.Methods.GetEnumerator()
				While enumerator1.MoveNext()
					Dim current As Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol = enumerator1.Current
					If (current.IsReducedExtensionMethod) Then
						methodSymbol = current
						Exit While
					ElseIf (current.IsSub) Then
						If (Not current.CanBeCalledWithNoParameters()) Then
							flag1 = True
						Else
							instance.Add(current)
						End If
					ElseIf (current.ParameterCount <= 0) Then
						instance.Add(current)
						flag2 = True
					Else
						instance.Free()
						flag = False
						Return flag
					End If
				End While
				If (methodSymbol IsNot Nothing) Then
					instance.Free()
					flag = If(boundMethodGroup.Methods.Length <> 1 OrElse boundMethodGroup.TypeArgumentsOpt IsNot Nothing OrElse methodSymbol.ParameterCount <> 0 OrElse methodSymbol.Arity <> 0 OrElse methodSymbol.IsSub, False, boundMethodGroup.AdditionalExtensionMethods(useSiteInfo).Length = 0)
				ElseIf (boundMethodGroup.AdditionalExtensionMethods(useSiteInfo).Length > 0) Then
					instance.Free()
					flag = False
				ElseIf (flag2) Then
					If (flag1) Then
						If (instance.IsEmpty()) Then
							instance.Free()
							flag = False
							Return flag
						End If
						group = boundMethodGroup.Update(boundMethodGroup.TypeArgumentsOpt, instance.ToImmutable(), Nothing, boundMethodGroup.ResultKind, boundMethodGroup.ReceiverOpt, boundMethodGroup.QualificationKind)
					End If
					instance.Free()
					flag = True
				Else
					instance.Free()
					flag = False
				End If
			End If
			Return flag
		End Function

		Private Shared Function ShouldReportMutableStructureInUsing(ByVal structureType As TypeSymbol) As Boolean
			Dim flag As Boolean
			If (structureType.Kind = SymbolKind.NamedType AndAlso structureType.IsStructureType() AndAlso Not structureType.IsEnumType() AndAlso Not structureType.IsIntrinsicType()) Then
				Dim enumerator As ImmutableArray(Of Symbol).Enumerator = structureType.GetMembersUnordered().GetEnumerator()
				While enumerator.MoveNext()
					Dim current As Symbol = enumerator.Current
					If (current.Kind <> SymbolKind.Field OrElse current.IsShared OrElse DirectCast(current, FieldSymbol).IsReadOnly) Then
						Continue While
					End If
					flag = True
					Return flag
				End While
			End If
			flag = False
			Return flag
		End Function

		Private Shared Function ShouldSuppressDiagnostics(ByVal lambda As BoundQueryLambda) As Boolean
			Dim flag As Boolean
			If (Not lambda.HasErrors) Then
				Dim enumerator As ImmutableArray(Of ParameterSymbol).Enumerator = lambda.LambdaSymbol.Parameters.GetEnumerator()
				While enumerator.MoveNext()
					If (Not enumerator.Current.Type.IsErrorType()) Then
						Continue While
					End If
					flag = True
					Return flag
				End While
				Dim type As TypeSymbol = lambda.Expression.Type
				flag = If(type Is Nothing, False, type.IsErrorType())
			Else
				flag = True
			End If
			Return flag
		End Function

		Private Function SubstituteDBNullWithNothingString(ByRef dbNullOperand As BoundExpression, ByVal otherOperandType As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As TypeSymbol
			Dim specialType As TypeSymbol
			If (Not otherOperandType.IsStringType()) Then
				specialType = Me.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_String, dbNullOperand.Syntax, diagnostics)
			Else
				specialType = otherOperandType
			End If
			dbNullOperand = New BoundConversion(dbNullOperand.Syntax, dbNullOperand, ConversionKind.[Widening], False, False, ConstantValue.[Nothing], specialType, False)
			Return specialType
		End Function

		Private Function TryBindInteractiveReceiver(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal currentMember As Symbol, ByVal currentType As NamedTypeSymbol, ByVal memberDeclaringType As NamedTypeSymbol) As BoundExpression
			Dim boundPreviousSubmissionReference As BoundExpression
			If (currentType.TypeKind <> Microsoft.CodeAnalysis.TypeKind.Submission OrElse currentMember.IsShared OrElse memberDeclaringType.TypeKind <> Microsoft.CodeAnalysis.TypeKind.Submission) Then
				boundPreviousSubmissionReference = Nothing
			Else
				boundPreviousSubmissionReference = New Microsoft.CodeAnalysis.VisualBasic.BoundPreviousSubmissionReference(syntax, currentType, memberDeclaringType)
			End If
			Return boundPreviousSubmissionReference
		End Function

		Private Function TryBindLoopControlVariable(ByVal controlVariableSyntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, <Out> ByRef controlVariable As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
			Dim flag As Boolean
			controlVariable = Me.BindExpression(DirectCast(controlVariableSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax), diagnostics)
			controlVariable = Me.ReclassifyAsValue(controlVariable, diagnostics)
			If (controlVariable.HasErrors) Then
				controlVariable = Binder.BadExpression(controlVariable)
				flag = False
			ElseIf (Me.VerifyForLoopControlReference(controlVariable, diagnostics)) Then
				flag = True
			Else
				controlVariable = New BoundBadExpression(controlVariableSyntax, LookupResultKind.NotAVariable, ImmutableArray(Of Symbol).Empty, ImmutableArray.Create(Of BoundExpression)(controlVariable), controlVariable.Type, True)
				flag = False
			End If
			Return flag
		End Function

		Protected Overridable Function TryBindOmittedLeftForConditionalAccess(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax, ByVal accessingBinder As Binder, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Return Me.ContainingBinder.TryBindOmittedLeftForConditionalAccess(node, accessingBinder, diagnostics)
		End Function

		Protected Overridable Function TryBindOmittedLeftForDictionaryAccess(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax, ByVal accessingBinder As Binder, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
			Return Me.ContainingBinder.TryBindOmittedLeftForDictionaryAccess(node, accessingBinder, diagnostics)
		End Function

		Protected Friend Overridable Function TryBindOmittedLeftForMemberAccess(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal accessingBinder As Binder, <Out> ByRef wholeMemberAccessExpressionBound As Boolean) As BoundExpression
			Return Me.ContainingBinder.TryBindOmittedLeftForMemberAccess(node, diagnostics, accessingBinder, wholeMemberAccessExpressionBound)
		End Function

		Protected Friend Overridable Function TryBindOmittedLeftForXmlMemberAccess(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal accessingBinder As Binder) As BoundExpression
			Return Me.ContainingBinder.TryBindOmittedLeftForXmlMemberAccess(node, diagnostics, accessingBinder)
		End Function

		Friend Function TryDefaultInstanceProperty(ByVal typeExpr As BoundTypeExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim enumerator As IEnumerator(Of Diagnostic) = Nothing
			If (Me.IsDefaultInstancePropertyAllowed) Then
				Dim type As TypeSymbol = typeExpr.Type
				If (type.IsErrorType() OrElse Me.SourceModule <> type.ContainingModule OrElse type.TypeKind <> Microsoft.CodeAnalysis.TypeKind.[Class]) Then
					boundExpression = Nothing
				Else
					Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = DirectCast(type, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)
					If (Not namedTypeSymbol.IsGenericType) Then
						Dim myGroupCollectionPropertyWithDefaultInstanceAlias As SynthesizedMyGroupCollectionPropertySymbol = Me.SourceModule.GetMyGroupCollectionPropertyWithDefaultInstanceAlias(namedTypeSymbol)
						If (myGroupCollectionPropertyWithDefaultInstanceAlias IsNot Nothing) Then
							Dim str As String = [String].Concat(New [String]() { "Class DefaultInstanceAlias" & VbCrLf & "Function DefaultInstanceAlias()" & VbCrLf & "Return ", myGroupCollectionPropertyWithDefaultInstanceAlias.DefaultInstanceAlias, ".", myGroupCollectionPropertyWithDefaultInstanceAlias.Name, "" & VbCrLf & "End Function" & VbCrLf & "End Class" & VbCrLf & "" })
							Dim cancellationToken As System.Threading.CancellationToken = New System.Threading.CancellationToken()
							Dim syntaxTree As Microsoft.CodeAnalysis.SyntaxTree = VisualBasicSyntaxTree.ParseText(str, Nothing, "", DirectCast(Nothing, Encoding), Nothing, cancellationToken)
							Using compilationUnitRoot As Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax = syntaxTree.GetCompilationUnitRoot()
								enumerator = syntaxTree.GetDiagnostics(compilationUnitRoot).GetEnumerator()
								While enumerator.MoveNext()
									If (enumerator.Current.Severity <> DiagnosticSeverity.[Error]) Then
										Continue While
									End If
									boundExpression = Nothing
									Return boundExpression
								End While
							End Using
							Dim members As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax) = compilationUnitRoot.Members
							members = DirectCast(members(0), Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassBlockSyntax).Members
							Dim item As Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax = DirectCast(members(0), Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax)
							If (item.Statements.Count <= 1) Then
								members = item.Statements
								Dim returnStatementSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ReturnStatementSyntax = DirectCast(members(0), Microsoft.CodeAnalysis.VisualBasic.Syntax.ReturnStatementSyntax)
								Dim instance As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.GetInstance(True, diagnostics.AccumulatesDependencies)
								Dim boundCall As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = (New Binder.DefaultInstancePropertyBinder(Me)).BindValue(returnStatementSyntax.Expression, instance, False)
								If (boundCall.HasErrors OrElse instance.HasAnyErrors()) Then
									instance.Free()
									boundExpression = Nothing
								Else
									diagnostics.AddDependencies(instance, False)
									instance.Free()
									If (boundCall.Type = namedTypeSymbol) Then
										If (CObj(Me.ContainingType) = CObj(namedTypeSymbol) AndAlso Not Me.ContainingMember.IsShared) Then
											Binder.ReportDiagnostic(diagnostics, typeExpr.Syntax, ERRID.ERR_CantReferToMyGroupInsideGroupType1, New [Object]() { namedTypeSymbol })
										End If
										Dim kind As BoundKind = boundCall.Kind
										If (kind = BoundKind.[Call]) Then
											Dim boundCall1 As Microsoft.CodeAnalysis.VisualBasic.BoundCall = DirectCast(boundCall, Microsoft.CodeAnalysis.VisualBasic.BoundCall)
											boundCall = New Microsoft.CodeAnalysis.VisualBasic.BoundCall(typeExpr.Syntax, boundCall1.Method, boundCall1.MethodGroupOpt, boundCall1.ReceiverOpt, boundCall1.Arguments, boundCall1.DefaultArguments, boundCall1.ConstantValueOpt, False, boundCall1.SuppressObjectClone, boundCall1.Type, boundCall1.HasErrors)
										ElseIf (kind = BoundKind.FieldAccess) Then
											Dim boundFieldAccess As Microsoft.CodeAnalysis.VisualBasic.BoundFieldAccess = DirectCast(boundCall, Microsoft.CodeAnalysis.VisualBasic.BoundFieldAccess)
											boundCall = New Microsoft.CodeAnalysis.VisualBasic.BoundFieldAccess(typeExpr.Syntax, boundFieldAccess.ReceiverOpt, boundFieldAccess.FieldSymbol, boundFieldAccess.IsLValue, boundFieldAccess.SuppressVirtualCalls, boundFieldAccess.ConstantsInProgressOpt, boundFieldAccess.Type, boundFieldAccess.HasErrors)
										Else
											If (kind <> BoundKind.PropertyAccess) Then
												Throw ExceptionUtilities.UnexpectedValue(boundCall.Kind)
											End If
											Dim boundPropertyAccess As Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess = DirectCast(boundCall, Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess)
											boundCall = New Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess(typeExpr.Syntax, boundPropertyAccess.PropertySymbol, boundPropertyAccess.PropertyGroupOpt, boundPropertyAccess.AccessKind, boundPropertyAccess.IsWriteable, False, boundPropertyAccess.ReceiverOpt, boundPropertyAccess.Arguments, boundPropertyAccess.DefaultArguments, boundPropertyAccess.Type, boundPropertyAccess.HasErrors)
										End If
										boundExpression = boundCall
									Else
										boundExpression = Nothing
									End If
								End If
							Else
								boundExpression = Nothing
							End If
						Else
							boundExpression = Nothing
						End If
					Else
						boundExpression = Nothing
					End If
				End If
			Else
				boundExpression = Nothing
			End If
			Return boundExpression
		End Function

		Protected Overridable Function TryGetConditionalAccessReceiver(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax) As BoundExpression
			Return Me.ContainingBinder.TryGetConditionalAccessReceiver(node)
		End Function

		Private Function TryGetXmlnsAttribute(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax, <Out> ByRef prefix As String, <Out> ByRef namespaceName As String, <Out> ByRef [namespace] As BoundExpression, <Out> ByRef hasErrors As Boolean, ByVal fromImport As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
			Dim flag As Boolean
			prefix = Nothing
			namespaceName = Nothing
			[namespace] = Nothing
			hasErrors = False
			If (syntax.Name.Kind() <> SyntaxKind.XmlEmbeddedExpression) Then
				Dim name As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax = DirectCast(syntax.Name, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax)
				If (Me.TryGetXmlnsPrefix(name, prefix, diagnostics)) Then
					Dim value As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax = syntax.Value
					If (value.Kind() = SyntaxKind.XmlString) Then
						namespaceName = Binder.GetXmlString(DirectCast(value, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax).TextTokens)
						If (EmbeddedOperators.CompareString(prefix, "xmlns", False) = 0 OrElse EmbeddedOperators.CompareString(prefix, "xml", False) = 0 AndAlso EmbeddedOperators.CompareString(namespaceName, "http://www.w3.org/XML/1998/namespace", False) <> 0) Then
							Binder.ReportDiagnostic(diagnostics, name.LocalName, ERRID.ERR_ReservedXmlPrefix, New [Object]() { prefix })
							hasErrors = True
						ElseIf (Not fromImport AndAlso [String].IsNullOrEmpty(namespaceName) AndAlso Not [String].IsNullOrEmpty(prefix)) Then
							Binder.ReportDiagnostic(diagnostics, name.LocalName, ERRID.ERR_IllegalDefaultNamespace)
							hasErrors = True
						ElseIf (Binder.RedefinesReservedXmlNamespace(syntax.Value, prefix, "xmlns", namespaceName, "http://www.w3.org/2000/xmlns/", diagnostics) OrElse Binder.RedefinesReservedXmlNamespace(syntax.Value, prefix, "xml", namespaceName, "http://www.w3.org/XML/1998/namespace", diagnostics)) Then
							hasErrors = True
						End If
						If (Not fromImport) Then
							[namespace] = Me.CreateStringLiteral(value, namespaceName, False, diagnostics, False)
						End If
					Else
						Binder.ReportDiagnostic(diagnostics, value, ERRID.ERR_EmbeddedExpression)
						hasErrors = True
						If (Not fromImport) Then
							[namespace] = Me.BindXmlEmbeddedExpression(DirectCast(value, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax), diagnostics)
						End If
					End If
					flag = True
				Else
					flag = False
				End If
			Else
				flag = False
			End If
			Return flag
		End Function

		Private Function TryGetXmlnsPrefix(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax, <Out> ByRef prefix As String, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
			Dim flag As Boolean
			Dim xmlName As String = Binder.GetXmlName(syntax.LocalName)
			Dim str As String = Nothing
			If (syntax.Prefix IsNot Nothing) Then
				str = Binder.GetXmlName(syntax.Prefix.Name)
				If (EmbeddedOperators.CompareString(str, "xmlns", False) <> 0) Then
					GoTo Label1
				End If
				prefix = xmlName
				flag = True
				Return flag
			End If
		Label1:
			If (EmbeddedOperators.CompareString(xmlName, "xmlns", False) <> 0) Then
				prefix = Nothing
				flag = False
			Else
				If (Not [String].IsNullOrEmpty(str)) Then
					Dim flag1 As Boolean = False
					Dim str1 As String = Nothing
					If (Me.LookupXmlNamespace(str, True, str1, flag1) AndAlso EmbeddedOperators.CompareString(str1, "", False) = 0) Then
						GoTo Label2
					End If
					Binder.ReportDiagnostic(diagnostics, syntax, ERRID.WRN_PrefixAndXmlnsLocalName, New [Object]() { str })
					prefix = Nothing
					flag = False
					Return flag
				End If
			Label3:
				prefix = [String].Empty
				flag = True
			End If
			Return flag
		Label2:
			Binder.ReportDiagnostic(diagnostics, syntax, ERRID.WRN_EmptyPrefixAndXmlnsLocalName)
			GoTo Label3
		End Function

		Private Function UpdateReceiverForExtensionMethodOrPropertyGroup(ByVal receiver As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal targetType As TypeSymbol, ByVal thisParameterDefinition As ParameterSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			If (receiver IsNot Nothing AndAlso receiver.IsValue() AndAlso Not targetType.IsErrorType() AndAlso Not receiver.Type.IsErrorType()) Then
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = receiver
				Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
				receiver = Me.PassArgument(receiver, Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyConversion(receiver, targetType, Me, newCompoundUseSiteInfo), False, Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyConversion(targetType, receiver.Type, newCompoundUseSiteInfo), targetType, thisParameterDefinition, diagnostics)
				diagnostics.Add(receiver, newCompoundUseSiteInfo)
				If (boundExpression.WasCompilerGenerated AndAlso receiver <> boundExpression) Then
					Dim kind As BoundKind = boundExpression.Kind
					If (CByte(kind) - CByte(BoundKind.WithLValueExpressionPlaceholder) <= CByte(BoundKind.OmittedArgument) OrElse kind = BoundKind.MeReference) Then
						receiver.SetWasCompilerGenerated()
					End If
				End If
			End If
			Return receiver
		End Function

		Private Function ValidateAndConvertIsExpressionArgument(ByVal targetArgument As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal otherArgument As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal [isNot] As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
			Dim type As TypeSymbol = targetArgument.Type
			If (targetArgument.IsNothingLiteral()) Then
				boundExpression = targetArgument
			ElseIf (type.IsErrorType()) Then
				boundExpression = targetArgument
			ElseIf (type.IsReferenceType) Then
				boundExpression = Me.ApplyImplicitConversion(targetArgument.Syntax, Me.GetSpecialType(SpecialType.System_Object, targetArgument.Syntax, diagnostics), targetArgument, diagnostics, False)
			ElseIf (type.IsNullableType()) Then
				If (Not otherArgument.HasErrors AndAlso Not otherArgument.IsNothingLiteral()) Then
					Binder.ReportDiagnostic(diagnostics, targetArgument.Syntax, If([isNot], ERRID.ERR_IsNotOperatorNullable1, ERRID.ERR_IsOperatorNullable1), New [Object]() { type })
				End If
				boundExpression = targetArgument
			ElseIf (Not type.IsTypeParameter() OrElse type.IsValueType) Then
				Binder.ReportDiagnostic(diagnostics, targetArgument.Syntax, If([isNot], ERRID.ERR_IsNotOpRequiresReferenceTypes1, ERRID.ERR_IsOperatorRequiresReferenceTypes1), New [Object]() { type })
				boundExpression = targetArgument
			Else
				If (Not otherArgument.HasErrors AndAlso Not otherArgument.IsNothingLiteral()) Then
					Binder.ReportDiagnostic(diagnostics, targetArgument.Syntax, If([isNot], ERRID.ERR_IsNotOperatorGenericParam1, ERRID.ERR_IsOperatorGenericParam1), New [Object]() { type })
				End If
				boundExpression = Me.ApplyImplicitConversion(targetArgument.Syntax, Me.GetSpecialType(SpecialType.System_Object, targetArgument.Syntax, diagnostics), targetArgument, diagnostics, False)
			End If
			Return boundExpression
		End Function

		Public Function ValidateEventModifiers(ByVal modifierList As SyntaxTokenList, ByVal memberModifiers As Microsoft.CodeAnalysis.VisualBasic.MemberModifiers, ByVal container As SourceMemberContainerTypeSymbol, ByVal diagBag As DiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.MemberModifiers
			' 
			' Current member / type: Microsoft.CodeAnalysis.VisualBasic.MemberModifiers Microsoft.CodeAnalysis.VisualBasic.Binder::ValidateEventModifiers(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.MemberModifiers,Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: Microsoft.CodeAnalysis.VisualBasic.MemberModifiers ValidateEventModifiers(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.MemberModifiers,Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Function

		Private Shared Function ValidateMethodForDelegateInvoke(ByVal addressOfExpression As BoundAddressOfOperator, ByVal analysisResult As OverloadResolution.CandidateAnalysisResult, ByVal toMethod As MethodSymbol, ByVal ignoreMethodReturnType As Boolean, ByVal useZeroArgumentRelaxation As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As KeyValuePair(Of MethodSymbol, MethodConversionKind)
			Dim keyValuePair As KeyValuePair(Of MethodSymbol, MethodConversionKind)
			Dim delegateMethodConversionBasedOnArguments As MethodConversionKind = MethodConversionKind.Identity
			Dim syntax As SyntaxNode = addressOfExpression.Syntax
			If (syntax.Kind() = SyntaxKind.AddressOfExpression) Then
				syntax = DirectCast(syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax).Operand
			End If
			Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = addressOfExpression.Binder.GetNewCompoundUseSiteInfo(diagnostics)
			Dim underlyingSymbol As MethodSymbol = DirectCast(analysisResult.Candidate.UnderlyingSymbol, MethodSymbol)
			If (Not ignoreMethodReturnType) Then
				delegateMethodConversionBasedOnArguments = delegateMethodConversionBasedOnArguments Or Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyMethodConversionBasedOnReturn(underlyingSymbol.ReturnType, underlyingSymbol.ReturnsByRef, toMethod.ReturnType, toMethod.ReturnsByRef, newCompoundUseSiteInfo)
				If (diagnostics.Add(syntax, newCompoundUseSiteInfo)) Then
					diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
				End If
			End If
			If (Not useZeroArgumentRelaxation) Then
				delegateMethodConversionBasedOnArguments = delegateMethodConversionBasedOnArguments Or Binder.GetDelegateMethodConversionBasedOnArguments(analysisResult, toMethod, newCompoundUseSiteInfo)
				If (diagnostics.Add(syntax, newCompoundUseSiteInfo)) Then
					diagnostics = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
				End If
			Else
				delegateMethodConversionBasedOnArguments = If(underlyingSymbol.ParameterCount <> 0, delegateMethodConversionBasedOnArguments Or MethodConversionKind.Error_IllegalToIgnoreAllArguments, delegateMethodConversionBasedOnArguments Or MethodConversionKind.AllArgumentsIgnored)
			End If
			If (Not ignoreMethodReturnType AndAlso underlyingSymbol.ReturnsByRef AndAlso Microsoft.CodeAnalysis.VisualBasic.Conversions.IsDelegateRelaxationSupportedFor(delegateMethodConversionBasedOnArguments) AndAlso Microsoft.CodeAnalysis.VisualBasic.Conversions.IsStubRequiredForMethodConversion(delegateMethodConversionBasedOnArguments)) Then
				delegateMethodConversionBasedOnArguments = delegateMethodConversionBasedOnArguments Or MethodConversionKind.Error_StubNotSupported
			End If
			If (Not Microsoft.CodeAnalysis.VisualBasic.Conversions.IsDelegateRelaxationSupportedFor(delegateMethodConversionBasedOnArguments)) Then
				Binder.ReportDelegateBindingIncompatible(syntax, toMethod.ContainingType, underlyingSymbol, diagnostics)
			Else
				Dim typeArgumentInferenceDiagnosticsOpt As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = analysisResult.TypeArgumentInferenceDiagnosticsOpt
				If (typeArgumentInferenceDiagnosticsOpt IsNot Nothing) Then
					diagnostics.AddRange(typeArgumentInferenceDiagnosticsOpt, False)
				End If
				If (addressOfExpression.MethodGroup.ResultKind = LookupResultKind.Good) Then
					addressOfExpression.Binder.CheckMemberTypeAccessibility(diagnostics, syntax, underlyingSymbol)
					keyValuePair = New KeyValuePair(Of MethodSymbol, MethodConversionKind)(underlyingSymbol, delegateMethodConversionBasedOnArguments)
					Return keyValuePair
				End If
				delegateMethodConversionBasedOnArguments = delegateMethodConversionBasedOnArguments Or MethodConversionKind.Error_Unspecified
			End If
			If (addressOfExpression.MethodGroup.ResultKind = LookupResultKind.Inaccessible) Then
				Binder.ReportDiagnostic(diagnostics, syntax, addressOfExpression.Binder.GetInaccessibleErrorInfo(analysisResult.Candidate.UnderlyingSymbol))
			End If
			keyValuePair = New KeyValuePair(Of MethodSymbol, MethodConversionKind)(Nothing, delegateMethodConversionBasedOnArguments)
			Return keyValuePair
		End Function

		Public Function ValidateSharedPropertyAndMethodModifiers(ByVal modifierList As SyntaxTokenList, ByVal memberModifiers As Microsoft.CodeAnalysis.VisualBasic.MemberModifiers, ByVal isProperty As Boolean, ByVal container As SourceMemberContainerTypeSymbol, ByVal diagBag As DiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.MemberModifiers
			' 
			' Current member / type: Microsoft.CodeAnalysis.VisualBasic.MemberModifiers Microsoft.CodeAnalysis.VisualBasic.Binder::ValidateSharedPropertyAndMethodModifiers(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.MemberModifiers,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: Microsoft.CodeAnalysis.VisualBasic.MemberModifiers ValidateSharedPropertyAndMethodModifiers(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.MemberModifiers,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Function

		Private Shared Function VerifyForControlVariableDeclaration(ByVal variableDeclarator As Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
			Dim flag As Boolean
			Dim item As Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax = variableDeclarator.Names(0)
			If (variableDeclarator.AsClause Is Nothing AndAlso item.Nullable.Node IsNot Nothing) Then
				Binder.ReportDiagnostic(diagnostics, item, ERRID.ERR_NullableTypeInferenceNotSupported)
				flag = False
			ElseIf (item.ArrayBounds Is Nothing) Then
				flag = True
			Else
				Binder.ReportDiagnostic(diagnostics, item, ERRID.ERR_ForCtlVarArraySizesSpecified)
				flag = False
			End If
			Return flag
		End Function

		Private Function VerifyForLoopControlReference(ByVal controlVariable As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
			Dim flag As Boolean
			If (controlVariable.IsPropertyOrXmlPropertyAccess()) Then
				Binder.ReportDiagnostic(diagnostics, controlVariable.Syntax, ERRID.ERR_LoopControlMustNotBeProperty)
				flag = False
			ElseIf (Not controlVariable.IsLValue) Then
				If (Not controlVariable.HasErrors) Then
					Binder.ReportAssignmentToRValue(controlVariable, diagnostics)
				End If
				flag = False
			ElseIf (controlVariable.HasErrors OrElse Not Me.IsInAsyncContext() OrElse Not Binder.SeenAwaitVisitor.SeenAwaitIn(controlVariable, diagnostics)) Then
				flag = True
			Else
				Binder.ReportDiagnostic(diagnostics, controlVariable.Syntax, ERRID.ERR_LoopControlMustNotAwait)
				flag = False
			End If
			Return flag
		End Function

		Private Sub VerifyLocalSymbolNameAndSetType(ByVal local As LocalSymbol, ByVal type As TypeSymbol, ByVal nameSyntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal identifier As Microsoft.CodeAnalysis.SyntaxToken, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Dim localForFunctionValue As LocalSymbol = Me.GetLocalForFunctionValue()
			Dim valueText As String = identifier.ValueText
			local.SetType(type)
			If (localForFunctionValue IsNot Nothing AndAlso CaseInsensitiveComparison.Equals(local.Name, localForFunctionValue.Name)) Then
				Binder.ReportDiagnostic(diagnostics, nameSyntax, ERRID.ERR_LocalSameAsFunc)
				Return
			End If
			Dim instance As LookupResult = LookupResult.GetInstance()
			Dim str As String = identifier.ValueText
			Dim discarded As CompoundUseSiteInfo(Of AssemblySymbol) = CompoundUseSiteInfo(Of AssemblySymbol).Discarded
			Me.Lookup(instance, str, 0, LookupOptions.[Default], discarded)
			Dim singleSymbol As LocalSymbol = DirectCast(instance.SingleSymbol, LocalSymbol)
			instance.Free()
			If (singleSymbol.IdentifierToken.FullSpan = identifier.FullSpan) Then
				Dim containingBinder As Binder = Me.ContainingBinder
				If (containingBinder IsNot Nothing) Then
					containingBinder.VerifyNameShadowingInMethodBody(local, nameSyntax, identifier, diagnostics)
				End If
			ElseIf (singleSymbol.CanBeReferencedByName AndAlso (Not singleSymbol.IsStatic OrElse Not local.IsStatic)) Then
				Binder.ReportDiagnostic(diagnostics, nameSyntax, ERRID.ERR_DuplicateLocals1, New [Object]() { valueText })
				Return
			End If
		End Sub

		Private Shared Sub VerifyNameOfLookupResult(ByVal container As NamespaceOrTypeSymbol, ByVal member As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax, ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Dim identifier As Microsoft.CodeAnalysis.SyntaxToken
			If (lookupResult.HasDiagnostic) Then
				If (Not lookupResult.IsAmbiguous) Then
					Binder.ReportDiagnostic(diagnostics, member, lookupResult.Diagnostic)
					Return
				End If
			ElseIf (Not lookupResult.HasSymbol) Then
				If (container IsNot Nothing) Then
					Dim syntaxNodeOrToken As Microsoft.CodeAnalysis.SyntaxNodeOrToken = member
					Dim valueText(1) As [Object]
					identifier = member.Identifier
					valueText(0) = identifier.ValueText
					valueText(1) = container
					Binder.ReportDiagnostic(diagnostics, syntaxNodeOrToken, ErrorFactory.ErrorInfo(ERRID.ERR_NameNotMember2, valueText))
					Return
				End If
				Dim syntaxNodeOrToken1 As Microsoft.CodeAnalysis.SyntaxNodeOrToken = member
				Dim objArray(0) As [Object]
				identifier = member.Identifier
				objArray(0) = identifier.ValueText
				Binder.ReportDiagnostic(diagnostics, syntaxNodeOrToken1, ErrorFactory.ErrorInfo(ERRID.ERR_NameNotDeclared1, objArray))
			End If
		End Sub

		Private Sub VerifyNameShadowingInMethodBody(ByVal symbol As Microsoft.CodeAnalysis.VisualBasic.Symbol, ByVal nameSyntax As SyntaxNodeOrToken, ByVal identifier As SyntaxNodeOrToken, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Dim eRRID As Microsoft.CodeAnalysis.VisualBasic.ERRID
			Dim name As String = symbol.Name
			Dim containingBinder As Binder = Me
			Dim instance As LookupResult = LookupResult.GetInstance()
			Do
				If (TypeOf containingBinder Is NamedTypeBinder) Then
					Exit Do
				End If
				instance.Clear()
				Dim discarded As CompoundUseSiteInfo(Of AssemblySymbol) = CompoundUseSiteInfo(Of AssemblySymbol).Discarded
				containingBinder.LookupInSingleBinder(instance, name, 0, LookupOptions.[Default], Me, discarded)
				If (Not instance.HasSingleSymbol) Then
					Dim implicitVariableBinder As Microsoft.CodeAnalysis.VisualBasic.ImplicitVariableBinder = TryCast(containingBinder, Microsoft.CodeAnalysis.VisualBasic.ImplicitVariableBinder)
					If (implicitVariableBinder IsNot Nothing AndAlso Not implicitVariableBinder.AllImplicitVariableDeclarationsAreHandled) Then
						If (symbol.Kind <> SymbolKind.Parameter) Then
							eRRID = If(symbol.Kind = SymbolKind.RangeVariable, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_IterationVariableShadowLocal2, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_BlockLocalShadowing1)
						Else
							eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_LambdaParamShadowLocal1
						End If
						implicitVariableBinder.RememberPossibleShadowingVariable(name, identifier, eRRID)
					End If
					containingBinder = containingBinder.ContainingBinder
				Else
					Dim singleSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbol = instance.SingleSymbol
					If (CObj(singleSymbol) = CObj(symbol)) Then
						Exit Do
					End If
					Dim kind As SymbolKind = singleSymbol.Kind
					If (kind <> SymbolKind.Local) Then
						Select Case kind
							Case SymbolKind.Parameter
								If (symbol.Kind = SymbolKind.Parameter) Then
									eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_LambdaParamShadowLocal1
								ElseIf (symbol.Kind = SymbolKind.RangeVariable) Then
									eRRID = If(Not Me.ImplicitVariableDeclarationAllowed, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_IterationVariableShadowLocal1, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_IterationVariableShadowLocal2)
								Else
									eRRID = If(DirectCast(singleSymbol.ContainingSymbol, MethodSymbol).MethodKind <> MethodKind.AnonymousFunction, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_LocalNamedSameAsParam1, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_LocalNamedSameAsParamInLambda1)
								End If
								Binder.ReportDiagnostic(diagnostics, nameSyntax, eRRID, New [Object]() { name })
								instance.Free()
								Return
							Case SymbolKind.PointerType
							Case SymbolKind.[Property]
								instance.Free()
								Return
							Case SymbolKind.RangeVariable
								Exit Select
							Case SymbolKind.TypeParameter
								Dim localSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol = TryCast(symbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol)
								If (localSymbol IsNot Nothing AndAlso (localSymbol.IsFor OrElse localSymbol.IsForEach) AndAlso localSymbol.HasInferredType) Then
									instance.Free()
									Return
								End If
								Binder.ReportDiagnostic(diagnostics, nameSyntax, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_NameSameAsMethodTypeParam1, New [Object]() { name })
								instance.Free()
								Return
							Case Else
								instance.Free()
								Return
						End Select
					End If
					If (symbol.Kind = SymbolKind.Parameter) Then
						eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_LambdaParamShadowLocal1
					ElseIf (symbol.Kind = SymbolKind.RangeVariable) Then
						eRRID = If(Not Me.ImplicitVariableDeclarationAllowed, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_IterationVariableShadowLocal1, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_IterationVariableShadowLocal2)
					Else
						eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_BlockLocalShadowing1
					End If
					Binder.ReportDiagnostic(diagnostics, nameSyntax, eRRID, New [Object]() { name })
					Exit Do
				End If
			Loop While containingBinder IsNot Nothing
			instance.Free()
		End Sub

		Private Sub VerifyRangeVariableName(ByVal rangeVar As RangeVariableSymbol, ByVal identifier As Microsoft.CodeAnalysis.SyntaxToken, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			If (identifier.GetTypeCharacter() <> TypeCharacter.None) Then
				Binder.ReportDiagnostic(diagnostics, identifier, ERRID.ERR_QueryAnonymousTypeDisallowsTypeChar)
			End If
			If (Me.Compilation.ObjectType.GetMembers(rangeVar.Name).Length > 0) Then
				Binder.ReportDiagnostic(diagnostics, identifier, ERRID.ERR_QueryInvalidControlVariableName1)
				Return
			End If
			Me.VerifyNameShadowingInMethodBody(rangeVar, identifier, identifier, diagnostics)
		End Sub

		Private Shared Sub VerifyTypeCharacterConsistency(ByVal nodeOrToken As SyntaxNodeOrToken, ByVal type As TypeSymbol, ByVal typeChar As TypeCharacter, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Dim str As String = Nothing
			Dim specialTypeForTypeCharacter As SpecialType = Binder.GetSpecialTypeForTypeCharacter(typeChar, str)
			If (specialTypeForTypeCharacter <> SpecialType.None) Then
				If (type.IsArrayType()) Then
					type = DirectCast(type, ArrayTypeSymbol).ElementType
				End If
				type = type.GetNullableUnderlyingTypeOrSelf()
				If (type.SpecialType <> specialTypeForTypeCharacter) Then
					Binder.ReportDiagnostic(diagnostics, nodeOrToken, ERRID.ERR_TypecharNoMatch2, New [Object]() { str, type })
				End If
			End If
		End Sub

		Private Shared Sub VerifyTypeCharacterConsistency(ByVal name As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax, ByVal type As TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Dim typeCharacter As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter = name.Identifier.GetTypeCharacter()
			If (typeCharacter <> Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter.None) Then
				Dim str As String = Nothing
				Dim specialTypeForTypeCharacter As SpecialType = Binder.GetSpecialTypeForTypeCharacter(typeCharacter, str)
				If (specialTypeForTypeCharacter <> SpecialType.None) Then
					If (type.IsArrayType()) Then
						type = DirectCast(type, ArrayTypeSymbol).ElementType
					End If
					type = type.GetNullableUnderlyingTypeOrSelf()
					If (type.SpecialType <> specialTypeForTypeCharacter) Then
						Binder.ReportDiagnostic(diagnostics, name, ERRID.ERR_TypecharNoMatch2, New [Object]() { str, type })
					End If
				End If
			End If
		End Sub

		Private Sub VerifyUsingVariableDeclarationAndBuildUsingInfo(ByVal syntaxNode As Microsoft.CodeAnalysis.SyntaxNode, ByVal localSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol, ByVal iDisposable As TypeSymbol, ByVal placeholderInfo As Dictionary(Of TypeSymbol, ValueTuple(Of BoundRValuePlaceholder, BoundExpression, BoundExpression)), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Dim type As TypeSymbol = localSymbol.Type
			If (type.IsArrayType()) Then
				Binder.ReportDiagnostic(diagnostics, syntaxNode, ErrorFactory.ErrorInfo(ERRID.ERR_UsingResourceVarCantBeArray))
				Return
			End If
			If (Not type.IsErrorType() AndAlso Not iDisposable.IsErrorType()) Then
				Me.BuildAndVerifyUsingInfo(syntaxNode, type, placeholderInfo, iDisposable, diagnostics)
				Me.ReportMutableStructureConstraintsInUsing(type, localSymbol.Name, syntaxNode, diagnostics)
			End If
		End Sub

		Private Sub WarnOnNarrowingConversionBetweenSealedClassAndAnInterface(ByVal convKind As ConversionKind, ByVal location As SyntaxNode, ByVal sourceType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, ByVal targetType As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			If (Microsoft.CodeAnalysis.VisualBasic.Conversions.IsNarrowingConversion(convKind)) Then
				Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
				Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = Nothing
				If (sourceType.IsInterfaceType()) Then
					If (targetType.IsClassType()) Then
						typeSymbol = sourceType
						namedTypeSymbol = DirectCast(targetType, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)
					End If
				ElseIf (sourceType.IsClassType() AndAlso targetType.IsInterfaceType()) Then
					typeSymbol = targetType
					namedTypeSymbol = DirectCast(sourceType, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)
				End If
				Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
				If (namedTypeSymbol IsNot Nothing AndAlso typeSymbol IsNot Nothing AndAlso namedTypeSymbol.IsNotInheritable AndAlso Not namedTypeSymbol.IsComImport AndAlso Not Microsoft.CodeAnalysis.VisualBasic.Conversions.IsWideningConversion(Microsoft.CodeAnalysis.VisualBasic.Conversions.ClassifyDirectCastConversion(namedTypeSymbol, typeSymbol, newCompoundUseSiteInfo))) Then
					If (targetType.SpecialType <> SpecialType.System_String OrElse Not Me.IsIEnumerableOfXElement(sourceType, newCompoundUseSiteInfo)) Then
						Binder.ReportDiagnostic(diagnostics, location, ERRID.WRN_InterfaceConversion2, New [Object]() { sourceType, targetType })
					Else
						Binder.ReportDiagnostic(diagnostics, location, ERRID.WRN_UseValueForXmlExpression3, New [Object]() { sourceType, targetType, sourceType })
					End If
				End If
				diagnostics.AddDependencies(newCompoundUseSiteInfo)
			End If
		End Sub

		Friend Sub WarnOnRecursiveAccess(ByVal propertyAccess As BoundPropertyAccess, ByVal accessKind As PropertyAccessKind, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			' 
			' Current member / type: System.Void Microsoft.CodeAnalysis.VisualBasic.Binder::WarnOnRecursiveAccess(Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess,Microsoft.CodeAnalysis.VisualBasic.PropertyAccessKind,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
			' 
			' Product version: 2019.1.118.0
			' Exception in: System.Void WarnOnRecursiveAccess(Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess,Microsoft.CodeAnalysis.VisualBasic.PropertyAccessKind,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			' 
			' La référence d'objet n'est pas définie à une instance d'un objet.
			'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
			'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
			'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
			'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
			'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
			'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
			'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
			'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
			' 
			' mailto: JustDecompilePublicFeedback@telerik.com

		End Sub

		Friend Sub WarnOnRecursiveAccess(ByVal node As BoundExpression, ByVal accessKind As PropertyAccessKind, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			Dim kind As BoundKind = node.Kind
			If (kind = BoundKind.PropertyAccess) Then
				Me.WarnOnRecursiveAccess(DirectCast(node, BoundPropertyAccess), accessKind, diagnostics)
				Return
			End If
			If (kind <> BoundKind.XmlMemberAccess) Then
				Throw ExceptionUtilities.UnexpectedValue(node.Kind)
			End If
		End Sub

		Private Sub WarnOnUnobservedCallThatReturnsAnAwaitable(ByVal statement As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionStatementSyntax, ByVal boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
			If (boundExpression.Kind = BoundKind.ConditionalAccess) Then
				Me.WarnOnUnobservedCallThatReturnsAnAwaitable(statement, DirectCast(boundExpression, BoundConditionalAccess).AccessExpression, diagnostics)
				Return
			End If
			If (Not boundExpression.HasErrors AndAlso boundExpression.Kind <> BoundKind.AwaitOperator AndAlso Not boundExpression.Type.IsErrorType() AndAlso Not boundExpression.Type.IsVoidType() AndAlso Not boundExpression.Type.IsObjectType()) Then
				Dim flag As Boolean = False
				If (boundExpression.Kind = BoundKind.[Call]) Then
					Dim boundCall As Microsoft.CodeAnalysis.VisualBasic.BoundCall = DirectCast(boundExpression, Microsoft.CodeAnalysis.VisualBasic.BoundCall)
					flag = If(Not boundCall.Method.IsAsync, False, CObj(boundCall.Method.ContainingAssembly) = CObj(Me.Compilation.Assembly))
				End If
				If (Not flag) Then
					Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = Me.GetNewCompoundUseSiteInfo(diagnostics)
					If (Me.IsOrInheritsFromOrImplementsInterface(boundExpression.Type, WellKnownType.Windows_Foundation_IAsyncAction, newCompoundUseSiteInfo) OrElse Me.IsOrInheritsFromOrImplementsInterface(boundExpression.Type, WellKnownType.Windows_Foundation_IAsyncActionWithProgress_T, newCompoundUseSiteInfo) OrElse Me.IsOrInheritsFromOrImplementsInterface(boundExpression.Type, WellKnownType.Windows_Foundation_IAsyncOperation_T, newCompoundUseSiteInfo) OrElse Me.IsOrInheritsFromOrImplementsInterface(boundExpression.Type, WellKnownType.Windows_Foundation_IAsyncOperationWithProgress_T2, newCompoundUseSiteInfo)) Then
						diagnostics.AddDependencies(newCompoundUseSiteInfo)
						flag = True
					ElseIf (Me.IsInAsyncContext()) Then
						Dim instance As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.GetInstance(True, diagnostics.AccumulatesDependencies)
						If (Not Me.BindAwait(statement, boundExpression, instance, True).HasErrors AndAlso Not instance.HasAnyErrors()) Then
							diagnostics.AddDependencies(instance, False)
							flag = True
						End If
						instance.Free()
					End If
				End If
				If (flag) Then
					Binder.ReportDiagnostic(diagnostics, statement, ERRID.WRN_UnobservedAwaitableExpression)
				End If
			End If
		End Sub

		Private Shared Function WrongArityErrid(ByVal actualArity As Integer, ByVal arity As Integer) As Microsoft.CodeAnalysis.VisualBasic.ERRID
			Dim eRRID As Microsoft.CodeAnalysis.VisualBasic.ERRID
			If (actualArity >= arity) Then
				eRRID = Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_TooFewGenericArguments1
			Else
				eRRID = If(actualArity <> 0, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_TooManyGenericArguments1, Microsoft.CodeAnalysis.VisualBasic.ERRID.ERR_TypeOrMemberNotGeneric1)
			End If
			Return eRRID
		End Function

		Private Structure AnalyzedAttributeArguments
			Public positionalArguments As ImmutableArray(Of BoundExpression)

			Public namedArguments As ImmutableArray(Of BoundExpression)

			Public Sub New(ByVal positionalArguments As ImmutableArray(Of BoundExpression), ByVal namedArguments As ImmutableArray(Of BoundExpression))
				Me = New Binder.AnalyzedAttributeArguments() With
				{
					.positionalArguments = positionalArguments,
					.namedArguments = namedArguments
				}
			End Sub
		End Structure

		Friend Class AnonymousTypeCreationBinder
			Inherits Binder
			Private ReadOnly _fields As AnonymousTypeField()

			Private ReadOnly _fieldName2index As Dictionary(Of String, Integer)

			Private _fieldDeclarations As ArrayBuilder(Of BoundAnonymousTypePropertyAccess)

			Private ReadOnly _locals As LocalSymbol()

			Private ReadOnly _propertySymbols As PropertySymbol()

			Private _freeze As Boolean

			Private Sub New(ByVal containingBinder As Binder, ByVal initializerSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
				MyBase.New(containingBinder)
				Dim specialType As TypeSymbol = MyBase.GetSpecialType(Microsoft.CodeAnalysis.SpecialType.System_Object, initializerSyntax, diagnostics)
				Dim initializers As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax) = initializerSyntax.Initializers
				Dim count As Integer = initializers.Count
				Me._fieldName2index = New Dictionary(Of String, Integer)(count, CaseInsensitiveComparison.Comparer)
				ReDim Me._fields(count - 1 + 1 - 1)
				Me._fieldDeclarations = Nothing
				ReDim Me._locals(count - 1 + 1 - 1)
				ReDim Me._propertySymbols(count - 1 + 1 - 1)
				Dim num As Integer = count - 1
				For i As Integer = 0 To num
					Dim item As Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax = initializers(i)
					Dim valueText As String = Nothing
					Dim name As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode = Nothing
					Dim flag As Boolean = False
					If (item.Kind() <> SyntaxKind.InferredFieldInitializer) Then
						Dim namedFieldInitializerSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax = DirectCast(item, Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax)
						name = namedFieldInitializerSyntax.Name
						flag = namedFieldInitializerSyntax.KeyKeyword.Kind() = SyntaxKind.KeyKeyword
						valueText = namedFieldInitializerSyntax.Name.Identifier.ValueText
					Else
						Dim inferredFieldInitializerSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.InferredFieldInitializerSyntax = DirectCast(item, Microsoft.CodeAnalysis.VisualBasic.Syntax.InferredFieldInitializerSyntax)
						Dim xmlNameSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax = Nothing
						Dim syntaxToken As Microsoft.CodeAnalysis.SyntaxToken = inferredFieldInitializerSyntax.Expression.ExtractAnonymousTypeMemberName(xmlNameSyntax)
						If (syntaxToken.Kind() <> SyntaxKind.None) Then
							valueText = syntaxToken.ValueText
							name = DirectCast(syntaxToken.Parent, Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode)
							flag = inferredFieldInitializerSyntax.KeyKeyword.Kind() = SyntaxKind.KeyKeyword
						Else
							valueText = Nothing
							name = inferredFieldInitializerSyntax.Expression
							flag = False
						End If
					End If
					If (Binder.ExtractTypeCharacter(name) <> TypeCharacter.None) Then
						Binder.ReportDiagnostic(diagnostics, item, ERRID.ERR_AnonymousTypeDisallowsTypeChar)
					End If
					If ([String].IsNullOrEmpty(valueText)) Then
						valueText = [String].Concat("$", i.ToString())
					ElseIf (System.Linq.ImmutableArrayExtensions.Any(Of Symbol)(specialType.GetMembers(valueText)) OrElse Me._fieldName2index.ContainsKey(valueText)) Then
						Binder.ReportDiagnostic(diagnostics, item, ErrorFactory.ErrorInfo(ERRID.ERR_DuplicateAnonTypeMemberName1, New [Object]() { valueText }))
					End If
					Me._fields(i) = New AnonymousTypeField(valueText, name.GetLocation(), flag)
					Me._fieldName2index(valueText) = i
				Next

			End Sub

			Friend Shared Function BindAnonymousObjectInitializer(ByVal containingBinder As Binder, ByVal owningSyntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal initializerSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax, ByVal typeLocationToken As Microsoft.CodeAnalysis.SyntaxToken, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
				If (initializerSyntax.Initializers.Count <> 0) Then
					boundExpression = (New Binder.AnonymousTypeCreationBinder(containingBinder, initializerSyntax, diagnostics)).BindInitializersAndCreateBoundNode(owningSyntax, initializerSyntax, diagnostics, typeLocationToken)
				Else
					boundExpression = Binder.BadExpression(owningSyntax, ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty, ErrorTypeSymbol.UnknownResultType)
				End If
				Return boundExpression
			End Function

			Private Function BindInitializersAndCreateBoundNode(ByVal owningSyntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal initializerSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal typeLocationToken As Microsoft.CodeAnalysis.SyntaxToken) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
				Dim length As Integer = CInt(Me._fields.Length)
				Dim boundExpressionArray(length - 1 + 1 - 1) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
				Dim num As Integer = length - 1
				Dim num1 As Integer = 0
				Do
					Dim item As Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax = initializerSyntax.Initializers(num1)
					Dim namedFieldInitializerSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax = Nothing
					Dim expression As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = Nothing
					If (item.Kind() <> SyntaxKind.InferredFieldInitializer) Then
						namedFieldInitializerSyntax = DirectCast(item, Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax)
						expression = namedFieldInitializerSyntax.Expression
					Else
						expression = DirectCast(item, Microsoft.CodeAnalysis.VisualBasic.Syntax.InferredFieldInitializerSyntax).Expression
					End If
					Dim anonymousTypeFieldInitializerBinder As Binder.AnonymousTypeFieldInitializerBinder = New Binder.AnonymousTypeFieldInitializerBinder(Me, num1)
					Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = anonymousTypeFieldInitializerBinder.BindRValue(expression, diagnostics, False)
					boundExpression = (New BoundAnonymousTypeFieldInitializer(item, anonymousTypeFieldInitializerBinder, boundExpression, boundExpression.Type, False)).MakeCompilerGenerated()
					boundExpressionArray(num1) = boundExpression
					Dim type As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = boundExpression.Type
					Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
					If (type.IsRestrictedTypeOrArrayType(typeSymbol)) Then
						Binder.ReportDiagnostic(diagnostics, expression, ERRID.ERR_RestrictedType1, New [Object]() { typeSymbol })
					End If
					Me._fields(num1).AssignFieldType(type)
					If (namedFieldInitializerSyntax IsNot Nothing) Then
						If (Me._fieldDeclarations Is Nothing) Then
							Me._fieldDeclarations = ArrayBuilder(Of BoundAnonymousTypePropertyAccess).GetInstance()
						End If
						Me._fieldDeclarations.Add(New BoundAnonymousTypePropertyAccess(namedFieldInitializerSyntax.Name, Me, num1, type))
					End If
					num1 = num1 + 1
				Loop While num1 <= num
				Me._freeze = True
				Return MyBase.CreateAnonymousObjectCreationExpression(owningSyntax, New AnonymousTypeDescriptor(Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of AnonymousTypeField)(Me._fields), typeLocationToken.GetLocation(), False), Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpressionArray), False)
			End Function

			Protected Overrides Function CreateAnonymousObjectCreationExpression(ByVal node As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal anonymousType As AnonymousTypeManager.AnonymousTypePublicSymbol, ByVal initExpressions As ImmutableArray(Of BoundExpression), Optional ByVal hasErrors As Boolean = False) As BoundAnonymousTypeCreationExpression
				Dim empty As ImmutableArray(Of BoundAnonymousTypePropertyAccess)
				Dim length As Integer = CInt(Me._fields.Length) - 1
				Dim num As Integer = 0
				Do
					If (Me._fields(num).Name(0) <> "$"C) Then
						Me._propertySymbols(num) = anonymousType.Properties(num)
					End If
					num = num + 1
				Loop While num <= length
				Dim visualBasicSyntaxNode As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode = node
				If (Me._fieldDeclarations Is Nothing) Then
					empty = ImmutableArray(Of BoundAnonymousTypePropertyAccess).Empty
				Else
					empty = Me._fieldDeclarations.ToImmutableAndFree()
				End If
				Return New BoundAnonymousTypeCreationExpression(visualBasicSyntaxNode, Me, empty, initExpressions, anonymousType, hasErrors)
			End Function

			Friend Function GetAnonymousTypePropertyLocal(ByVal index As Integer) As LocalSymbol
				Return Me._locals(index)
			End Function

			Friend Function GetAnonymousTypePropertySymbol(ByVal index As Integer) As PropertySymbol
				Return Me._propertySymbols(index)
			End Function

			Friend Sub RegisterFieldReference(ByVal fieldIndex As Integer)
				If (Not Me._freeze AndAlso Me._locals(fieldIndex) Is Nothing) Then
					Dim synthesizedLocal As LocalSymbol = New Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLocal(Me.ContainingMember, Me._fields(fieldIndex).Type, SynthesizedLocalKind.LoweringTemp, Nothing, False)
					Me._locals(fieldIndex) = synthesizedLocal
				End If
			End Sub

			Friend Function TryGetField(ByVal name As String, <Out> ByRef field As AnonymousTypeField, <Out> ByRef fieldIndex As Integer) As Boolean
				Dim flag As Boolean
				If (Not Me._fieldName2index.TryGetValue(name, fieldIndex)) Then
					field = New AnonymousTypeField()
					flag = False
				Else
					field = Me._fields(fieldIndex)
					flag = True
				End If
				Return flag
			End Function
		End Class

		Friend Class AnonymousTypeFieldInitializerBinder
			Inherits Binder
			Private ReadOnly _initializerOrdinal As Integer

			Public Sub New(ByVal creationBinder As Binder.AnonymousTypeCreationBinder, ByVal initializerOrdinal As Integer)
				MyBase.New(creationBinder)
				Me._initializerOrdinal = initializerOrdinal
			End Sub

			Protected Overrides Function TryBindOmittedLeftForConditionalAccess(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax, ByVal accessingBinder As Binder, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
				Return Nothing
			End Function

			Protected Overrides Function TryBindOmittedLeftForDictionaryAccess(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax, ByVal accessingBinder As Binder, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
				Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_NoDefaultNotExtend1, New [Object]() { "<anonymous type>" })
				Return Binder.BadExpression(node, ErrorTypeSymbol.UnknownResultType)
			End Function

			Protected Friend Overrides Function TryBindOmittedLeftForMemberAccess(ByVal node As Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal accessingBinder As Binder, <Out> ByRef wholeMemberAccessExpressionBound As Boolean) As BoundExpression
				Dim boundAnonymousTypePropertyAccess As BoundExpression
				wholeMemberAccessExpressionBound = True
				Dim containingBinder As Binder.AnonymousTypeCreationBinder = DirectCast(MyBase.ContainingBinder, Binder.AnonymousTypeCreationBinder)
				If (Not node.ContainsDiagnostics) Then
					Dim name As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax = node.Name
					Dim valueText As String = name.Identifier.ValueText
					Dim num As Integer = 0
					Dim anonymousTypeField As Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField = New Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField()
					If (Not containingBinder.TryGetField(valueText, anonymousTypeField, num)) Then
						Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_NameNotMemberOfAnonymousType2, New [Object]() { valueText, "<anonymous type>" })
						boundAnonymousTypePropertyAccess = Binder.BadExpression(node, ErrorTypeSymbol.UnknownResultType)
					Else
						Dim flag As Boolean = False
						If (name.Kind() = SyntaxKind.GenericName) Then
							Binder.ReportDiagnostic(diagnostics, DirectCast(name, Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax).TypeArgumentList, ERRID.ERR_TypeOrMemberNotGeneric1, New [Object]() { [String].Format("Public {0}Property {1} As T{2}", If(anonymousTypeField.IsKey, "Readonly ", ""), valueText, num) })
							flag = True
						End If
						If (num < Me._initializerOrdinal) Then
							containingBinder.RegisterFieldReference(num)
							If (CObj(Me.ContainingMember) <> CObj(accessingBinder.ContainingMember)) Then
								Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_CannotLiftAnonymousType1, New [Object]() { node.Name.Identifier.ValueText })
								flag = True
							End If
							boundAnonymousTypePropertyAccess = New Microsoft.CodeAnalysis.VisualBasic.BoundAnonymousTypePropertyAccess(node, containingBinder, num, anonymousTypeField.Type, flag)
						Else
							If (Not flag) Then
								Binder.ReportDiagnostic(diagnostics, node, ERRID.ERR_AnonymousTypePropertyOutOfOrder1, New [Object]() { valueText })
							End If
							boundAnonymousTypePropertyAccess = Binder.BadExpression(node, ErrorTypeSymbol.UnknownResultType)
						End If
					End If
				Else
					boundAnonymousTypePropertyAccess = Binder.BadExpression(node, ErrorTypeSymbol.UnknownResultType)
				End If
				Return boundAnonymousTypePropertyAccess
			End Function
		End Class

		Friend Structure AttributeExpressionVisitor
			Private ReadOnly _binder As Binder

			Private _hasErrors As Boolean

			Public ReadOnly Property HasErrors As Boolean
				Get
					Return Me._hasErrors
				End Get
			End Property

			Public Sub New(ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal hasErrors As Boolean)
				Me = New Microsoft.CodeAnalysis.VisualBasic.Binder.AttributeExpressionVisitor() With
				{
					._binder = binder,
					._hasErrors = hasErrors
				}
			End Sub

			Private Function CreateErrorTypedConstant(ByVal type As TypeSymbol) As TypedConstant
				Me._hasErrors = True
				Return New TypedConstant(type, TypedConstantKind.[Error], Nothing)
			End Function

			Private Shared Function CreateTypedConstant(ByVal type As ArrayTypeSymbol, ByVal array As ImmutableArray(Of TypedConstant)) As TypedConstant
				Return New TypedConstant(type, array)
			End Function

			Private Function CreateTypedConstant(ByVal type As TypeSymbol, ByVal value As Object) As Microsoft.CodeAnalysis.TypedConstant
				Dim typedConstant As Microsoft.CodeAnalysis.TypedConstant
				Dim typedConstantKind As Microsoft.CodeAnalysis.TypedConstantKind = Microsoft.CodeAnalysis.TypedConstant.GetTypedConstantKind(type, Me._binder.Compilation)
				typedConstant = If(typedConstantKind <> Microsoft.CodeAnalysis.TypedConstantKind.Array, New Microsoft.CodeAnalysis.TypedConstant(type, typedConstantKind, RuntimeHelpers.GetObjectValue(value)), New Microsoft.CodeAnalysis.TypedConstant(type, New ImmutableArray(Of Microsoft.CodeAnalysis.TypedConstant)()))
				Return typedConstant
			End Function

			Private Function VisitArguments(ByVal arguments As ImmutableArray(Of BoundExpression), ByVal diag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As ImmutableArray(Of TypedConstant)
				Dim immutableAndFree As ImmutableArray(Of TypedConstant)
				Dim instance As ArrayBuilder(Of TypedConstant) = Nothing
				Dim enumerator As ImmutableArray(Of BoundExpression).Enumerator = arguments.GetEnumerator()
				While enumerator.MoveNext()
					Dim current As BoundExpression = enumerator.Current
					If (instance Is Nothing) Then
						instance = ArrayBuilder(Of TypedConstant).GetInstance()
					End If
					instance.Add(Me.VisitExpression(current, diag))
				End While
				If (instance IsNot Nothing) Then
					immutableAndFree = instance.ToImmutableAndFree()
				Else
					immutableAndFree = ImmutableArray(Of TypedConstant).Empty
				End If
				Return immutableAndFree
			End Function

			Private Function VisitArrayCreation(ByVal node As BoundArrayCreation, ByVal diag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As TypedConstant
				Dim type As ArrayTypeSymbol = DirectCast(node.Type, ArrayTypeSymbol)
				Dim typedConstants As ImmutableArray(Of TypedConstant) = New ImmutableArray(Of TypedConstant)()
				Dim initializerOpt As BoundArrayInitialization = node.InitializerOpt
				If ((initializerOpt Is Nothing OrElse initializerOpt.Initializers.Length = 0) AndAlso node.Bounds.Length = 1) Then
					Dim item As BoundExpression = node.Bounds(0)
					If (item.IsConstant AndAlso Not item.ConstantValueOpt.IsDefaultValue) Then
						Binder.ReportDiagnostic(diag, initializerOpt.Syntax, ERRID.ERR_MissingValuesForArraysInApplAttrs)
						Me._hasErrors = True
					End If
				End If
				If (initializerOpt IsNot Nothing) Then
					typedConstants = Me.VisitArguments(initializerOpt.Initializers, diag)
				End If
				Return Binder.AttributeExpressionVisitor.CreateTypedConstant(type, typedConstants)
			End Function

			Public Function VisitExpression(ByVal node As BoundExpression, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.TypedConstant
				Dim typedConstant As Microsoft.CodeAnalysis.TypedConstant
				While True
					If (Not node.IsConstant) Then
						Dim kind As BoundKind = node.Kind
						If (kind <= BoundKind.[GetType]) Then
							If (kind = BoundKind.BadExpression) Then
								typedConstant = Me.CreateErrorTypedConstant(node.Type)
								Exit While
							ElseIf (kind = BoundKind.Parenthesized) Then
								node = DirectCast(node, BoundParenthesized).Expression
							ElseIf (kind = BoundKind.[GetType]) Then
								typedConstant = Me.VisitGetType(DirectCast(node, BoundGetType), diagBag)
								Exit While
							Else
								Binder.ReportDiagnostic(diagBag, node.Syntax, ERRID.ERR_RequiredConstExpr)
								typedConstant = Me.CreateErrorTypedConstant(node.Type)
								Return typedConstant
							End If
						ElseIf (kind <= BoundKind.[DirectCast]) Then
							If (kind = BoundKind.Conversion) Then
								Dim boundConversion As Microsoft.CodeAnalysis.VisualBasic.BoundConversion = DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.BoundConversion)
								If (boundConversion.HasErrors OrElse Not Microsoft.CodeAnalysis.VisualBasic.Conversions.IsWideningConversion(boundConversion.ConversionKind) OrElse Not Me._binder.IsValidTypeForAttributeArgument(boundConversion.Operand.Type)) Then
									If (Not boundConversion.HasErrors) Then
										Binder.ReportDiagnostic(diagBag, boundConversion.Operand.Syntax, ERRID.ERR_RequiredAttributeConstConversion2, New [Object]() { boundConversion.Operand.Type, boundConversion.Type })
									End If
									typedConstant = Me.CreateErrorTypedConstant(node.Type)
									Exit While
								Else
									If (node.Syntax.Kind() = SyntaxKind.PredefinedCastExpression) Then
										Dim syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax = DirectCast(node.Syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax)
										If (syntax.Keyword.Kind() = SyntaxKind.CObjKeyword) Then
											Dim keyword As Microsoft.CodeAnalysis.SyntaxToken = syntax.Keyword
											Parser.CheckFeatureAvailability(diagBag, keyword.GetLocation(), DirectCast(syntax.SyntaxTree, VisualBasicSyntaxTree).Options.LanguageVersion, Feature.CObjInAttributeArguments)
										End If
									End If
									node = boundConversion.Operand
								End If
							ElseIf (kind = BoundKind.[DirectCast]) Then
								Dim boundDirectCast As Microsoft.CodeAnalysis.VisualBasic.BoundDirectCast = DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.BoundDirectCast)
								If (boundDirectCast.HasErrors OrElse Not Microsoft.CodeAnalysis.VisualBasic.Conversions.IsWideningConversion(boundDirectCast.ConversionKind) OrElse Not Me._binder.IsValidTypeForAttributeArgument(boundDirectCast.Operand.Type)) Then
									If (Not boundDirectCast.HasErrors) Then
										Binder.ReportDiagnostic(diagBag, boundDirectCast.Operand.Syntax, ERRID.ERR_RequiredAttributeConstConversion2, New [Object]() { boundDirectCast.Operand.Type, boundDirectCast.Type })
									End If
									typedConstant = Me.CreateErrorTypedConstant(node.Type)
									Exit While
								Else
									node = boundDirectCast.Operand
								End If
							Else
								Binder.ReportDiagnostic(diagBag, node.Syntax, ERRID.ERR_RequiredConstExpr)
								typedConstant = Me.CreateErrorTypedConstant(node.Type)
								Return typedConstant
							End If
						ElseIf (kind = BoundKind.[TryCast]) Then
							Dim boundTryCast As Microsoft.CodeAnalysis.VisualBasic.BoundTryCast = DirectCast(node, Microsoft.CodeAnalysis.VisualBasic.BoundTryCast)
							If (boundTryCast.HasErrors OrElse Not Microsoft.CodeAnalysis.VisualBasic.Conversions.IsWideningConversion(boundTryCast.ConversionKind) OrElse Not Me._binder.IsValidTypeForAttributeArgument(boundTryCast.Operand.Type)) Then
								If (Not boundTryCast.HasErrors) Then
									Binder.ReportDiagnostic(diagBag, boundTryCast.Operand.Syntax, ERRID.ERR_RequiredAttributeConstConversion2, New [Object]() { boundTryCast.Operand.Type, boundTryCast.Type })
								End If
								typedConstant = Me.CreateErrorTypedConstant(node.Type)
								Exit While
							Else
								node = boundTryCast.Operand
							End If
						ElseIf (kind = BoundKind.ArrayCreation) Then
							typedConstant = Me.VisitArrayCreation(DirectCast(node, BoundArrayCreation), diagBag)
							Exit While
						Else
							Binder.ReportDiagnostic(diagBag, node.Syntax, ERRID.ERR_RequiredConstExpr)
							typedConstant = Me.CreateErrorTypedConstant(node.Type)
							Return typedConstant
						End If
					ElseIf (Not Me._binder.IsValidTypeForAttributeArgument(node.Type)) Then
						typedConstant = Me.CreateErrorTypedConstant(node.Type)
						Exit While
					Else
						typedConstant = Me.CreateTypedConstant(node.Type, RuntimeHelpers.GetObjectValue(node.ConstantValueOpt.Value))
						Exit While
					End If
				End While
				Return typedConstant
			End Function

			Private Function VisitGetType(ByVal node As BoundGetType, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.TypedConstant
				Dim typedConstant As Microsoft.CodeAnalysis.TypedConstant
				Dim sourceType As BoundTypeExpression = node.SourceType
				Dim type As TypeSymbol = sourceType.Type
				If (type IsNot Nothing) Then
					If (If(type.IsUnboundGenericType(), True, Not type.IsOrRefersToTypeParameter())) Then
						typedConstant = Me.CreateTypedConstant(node.Type, type)
						Return typedConstant
					End If
					Dim badSymbolDiagnostic As Microsoft.CodeAnalysis.VisualBasic.BadSymbolDiagnostic = New Microsoft.CodeAnalysis.VisualBasic.BadSymbolDiagnostic(type, ERRID.ERR_OpenTypeDisallowed)
					Binder.ReportDiagnostic(diagBag, sourceType.Syntax, badSymbolDiagnostic)
					typedConstant = Me.CreateErrorTypedConstant(node.Type)
					Return typedConstant
				End If
				typedConstant = Me.CreateTypedConstant(node.Type, type)
				Return typedConstant
			End Function

			Private Function VisitNamedArgument(ByVal argument As BoundExpression, ByVal diag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Nullable(Of KeyValuePair(Of String, TypedConstant))
				Dim nullable As Nullable(Of KeyValuePair(Of String, TypedConstant))
				If (argument.Kind = BoundKind.AssignmentOperator) Then
					Dim boundAssignmentOperator As Microsoft.CodeAnalysis.VisualBasic.BoundAssignmentOperator = DirectCast(argument, Microsoft.CodeAnalysis.VisualBasic.BoundAssignmentOperator)
					Dim kind As BoundKind = boundAssignmentOperator.Left.Kind
					If (kind = BoundKind.FieldAccess) Then
						Dim left As BoundFieldAccess = DirectCast(boundAssignmentOperator.Left, BoundFieldAccess)
						nullable = New Nullable(Of KeyValuePair(Of String, TypedConstant))(New KeyValuePair(Of String, TypedConstant)(left.FieldSymbol.Name, Me.VisitExpression(boundAssignmentOperator.Right, diag)))
						Return nullable
					Else
						If (kind <> BoundKind.PropertyAccess) Then
							nullable = Nothing
							Return nullable
						End If
						Dim boundPropertyAccess As Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess = DirectCast(boundAssignmentOperator.Left, Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess)
						nullable = New Nullable(Of KeyValuePair(Of String, TypedConstant))(New KeyValuePair(Of String, TypedConstant)(boundPropertyAccess.PropertySymbol.Name, Me.VisitExpression(boundAssignmentOperator.Right, diag)))
						Return nullable
					End If
				End If
				nullable = Nothing
				Return nullable
			End Function

			Public Function VisitNamedArguments(ByVal arguments As ImmutableArray(Of BoundExpression), ByVal diag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As ImmutableArray(Of KeyValuePair(Of String, TypedConstant))
				Dim immutableAndFree As ImmutableArray(Of KeyValuePair(Of String, TypedConstant))
				Dim instance As ArrayBuilder(Of KeyValuePair(Of String, TypedConstant)) = Nothing
				Dim enumerator As ImmutableArray(Of BoundExpression).Enumerator = arguments.GetEnumerator()
				While enumerator.MoveNext()
					Dim nullable As Nullable(Of KeyValuePair(Of String, TypedConstant)) = Me.VisitNamedArgument(enumerator.Current, diag)
					If (Not nullable.HasValue) Then
						Continue While
					End If
					If (instance Is Nothing) Then
						instance = ArrayBuilder(Of KeyValuePair(Of String, TypedConstant)).GetInstance()
					End If
					instance.Add(nullable.Value)
				End While
				If (instance IsNot Nothing) Then
					immutableAndFree = instance.ToImmutableAndFree()
				Else
					immutableAndFree = ImmutableArray(Of KeyValuePair(Of String, TypedConstant)).Empty
				End If
				Return immutableAndFree
			End Function

			Public Function VisitPositionalArguments(ByVal arguments As ImmutableArray(Of BoundExpression), ByVal diag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As ImmutableArray(Of TypedConstant)
				Return Me.VisitArguments(arguments, diag)
			End Function
		End Structure

		Private Class CheckAwaitWalker
			Inherits BoundTreeWalkerWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator
			Private ReadOnly _binder As Binder

			Private ReadOnly _diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag

			Private _isInCatchFinallyOrSyncLock As Boolean

			Private _containsAwait As Boolean

			Private Sub New(ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
				MyBase.New()
				Me._diagnostics = diagnostics
				Me._binder = binder
			End Sub

			Public Overrides Function VisitAwaitOperator(ByVal node As BoundAwaitOperator) As BoundNode
				Me._containsAwait = True
				If (Me._isInCatchFinallyOrSyncLock) Then
					Binder.ReportDiagnostic(Me._diagnostics, node.Syntax, ERRID.ERR_BadAwaitInTryHandler)
				End If
				Return MyBase.VisitAwaitOperator(node)
			End Function

			Public Shared Function VisitBlock(ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal block As BoundBlock, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
				Dim flag As Boolean
				Try
					Dim checkAwaitWalker As Microsoft.CodeAnalysis.VisualBasic.Binder.CheckAwaitWalker = New Microsoft.CodeAnalysis.VisualBasic.Binder.CheckAwaitWalker(binder, diagnostics)
					checkAwaitWalker.Visit(block)
					flag = checkAwaitWalker._containsAwait
				Catch cancelledByStackGuardException As BoundTreeVisitor.CancelledByStackGuardException
					ProjectData.SetProjectError(cancelledByStackGuardException)
					cancelledByStackGuardException.AddAnError(diagnostics)
					flag = True
					ProjectData.ClearProjectError()
				End Try
				Return flag
			End Function

			Public Overrides Function VisitLambda(ByVal node As BoundLambda) As BoundNode
				Return Nothing
			End Function

			Public Overrides Function VisitSyncLockStatement(ByVal node As BoundSyncLockStatement) As BoundNode
				Dim flag As Boolean = Me._isInCatchFinallyOrSyncLock
				Me._isInCatchFinallyOrSyncLock = True
				MyBase.VisitSyncLockStatement(node)
				Me._isInCatchFinallyOrSyncLock = flag
				Return Nothing
			End Function

			Public Overrides Function VisitTryStatement(ByVal node As BoundTryStatement) As BoundNode
				Me.Visit(node.TryBlock)
				Dim flag As Boolean = Me._isInCatchFinallyOrSyncLock
				Me._isInCatchFinallyOrSyncLock = True
				Me.VisitList(Of BoundCatchBlock)(node.CatchBlocks)
				Me.Visit(node.FinallyBlockOpt)
				Me._isInCatchFinallyOrSyncLock = flag
				Return Nothing
			End Function
		End Class

		Private Class CheckOnErrorAndAwaitWalker
			Inherits BoundTreeWalkerWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator
			Private ReadOnly _binder As Binder

			Private ReadOnly _diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag

			Private _containsOnError As Boolean

			Private _containsTry As Boolean

			Private _containsResume As Boolean

			Private _resumeWithoutLabel As Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax

			Private _containsLineNumberLabel As Boolean

			Private _containsCatch As Boolean

			Private _reportedAnError As Boolean

			Private _enclosingSyncLockOrUsing As BoundStatement

			Private _isInCatchFinallyOrSyncLock As Boolean

			Private _containsAwait As Boolean

			Private ReadOnly _tryOnErrorResume As ArrayBuilder(Of BoundStatement)

			Private Sub New(ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
				MyBase.New()
				Me._tryOnErrorResume = New ArrayBuilder(Of BoundStatement)()
				Me._diagnostics = diagnostics
				Me._binder = binder
			End Sub

			Public Overrides Function Visit(ByVal node As Microsoft.CodeAnalysis.VisualBasic.BoundNode) As Microsoft.CodeAnalysis.VisualBasic.BoundNode
				Dim boundNode As Microsoft.CodeAnalysis.VisualBasic.BoundNode
				If (Me._binder.IsInAsyncContext() OrElse Not TypeOf node Is BoundExpression) Then
					boundNode = MyBase.Visit(node)
				Else
					boundNode = Nothing
				End If
				Return boundNode
			End Function

			Public Overrides Function VisitAwaitOperator(ByVal node As BoundAwaitOperator) As BoundNode
				Me._containsAwait = True
				If (Me._isInCatchFinallyOrSyncLock) Then
					Binder.ReportDiagnostic(Me._diagnostics, node.Syntax, ERRID.ERR_BadAwaitInTryHandler)
					Me._reportedAnError = True
				End If
				Return MyBase.VisitAwaitOperator(node)
			End Function

			Public Shared Sub VisitBlock(ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal block As BoundBlock, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, <Out> ByRef containsAwait As Boolean, <Out> ByRef containsOnError As Boolean, <Out> ByRef containsResume As Boolean, <Out> ByRef resumeWithoutLabel As Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax, <Out> ByRef containsLineNumberLabel As Boolean, <Out> ByRef containsCatch As Boolean, <Out> ByRef reportedAnError As Boolean)
				Dim checkOnErrorAndAwaitWalker As Microsoft.CodeAnalysis.VisualBasic.Binder.CheckOnErrorAndAwaitWalker = New Microsoft.CodeAnalysis.VisualBasic.Binder.CheckOnErrorAndAwaitWalker(binder, diagnostics)
				Try
					checkOnErrorAndAwaitWalker.Visit(block)
				Catch cancelledByStackGuardException As BoundTreeVisitor.CancelledByStackGuardException
					ProjectData.SetProjectError(cancelledByStackGuardException)
					cancelledByStackGuardException.AddAnError(diagnostics)
					reportedAnError = True
					ProjectData.ClearProjectError()
				End Try
				containsAwait = checkOnErrorAndAwaitWalker._containsAwait
				containsOnError = checkOnErrorAndAwaitWalker._containsOnError
				containsResume = checkOnErrorAndAwaitWalker._containsResume
				reportedAnError = checkOnErrorAndAwaitWalker._reportedAnError
				resumeWithoutLabel = checkOnErrorAndAwaitWalker._resumeWithoutLabel
				containsLineNumberLabel = checkOnErrorAndAwaitWalker._containsLineNumberLabel
				containsCatch = checkOnErrorAndAwaitWalker._containsCatch
				If ((containsOnError OrElse containsResume) AndAlso checkOnErrorAndAwaitWalker._containsTry) Then
					Dim enumerator As ArrayBuilder(Of BoundStatement).Enumerator = checkOnErrorAndAwaitWalker._tryOnErrorResume.GetEnumerator()
					While enumerator.MoveNext()
						Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagnostics, enumerator.Current.Syntax, ERRID.ERR_TryAndOnErrorDoNotMix)
					End While
					reportedAnError = True
				End If
			End Sub

			Public Overrides Function VisitCatchBlock(ByVal node As BoundCatchBlock) As BoundNode
				Me._containsCatch = True
				Return MyBase.VisitCatchBlock(node)
			End Function

			Public Overrides Function VisitLabelStatement(ByVal node As BoundLabelStatement) As BoundNode
				If (Not node.WasCompilerGenerated AndAlso node.Syntax.Kind() = SyntaxKind.LabelStatement AndAlso DirectCast(node.Syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax).LabelToken.Kind() = SyntaxKind.IntegerLiteralToken) Then
					Me._containsLineNumberLabel = True
				End If
				Return MyBase.VisitLabelStatement(node)
			End Function

			Public Overrides Function VisitLambda(ByVal node As BoundLambda) As BoundNode
				Return Nothing
			End Function

			Public Overrides Function VisitOnErrorStatement(ByVal node As BoundOnErrorStatement) As BoundNode
				Me._containsOnError = True
				Me._tryOnErrorResume.Add(node)
				If (node.OnErrorKind = OnErrorStatementKind.ResumeNext) Then
					Me._containsResume = True
					If (Me._resumeWithoutLabel Is Nothing) Then
						Me._resumeWithoutLabel = DirectCast(node.Syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)
					End If
				End If
				If (Me._enclosingSyncLockOrUsing IsNot Nothing) Then
					Binder.ReportDiagnostic(Me._diagnostics, node.Syntax, If(Me._enclosingSyncLockOrUsing.Kind = BoundKind.UsingStatement, ERRID.ERR_OnErrorInUsing, ERRID.ERR_OnErrorInSyncLock))
					Me._reportedAnError = True
				End If
				Return Nothing
			End Function

			Public Overrides Function VisitResumeStatement(ByVal node As BoundResumeStatement) As BoundNode
				Me._containsResume = True
				If (node.ResumeKind <> ResumeStatementKind.Label AndAlso Me._resumeWithoutLabel Is Nothing) Then
					Me._resumeWithoutLabel = DirectCast(node.Syntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)
				End If
				Me._tryOnErrorResume.Add(node)
				Return Nothing
			End Function

			Public Overrides Function VisitSyncLockStatement(ByVal node As BoundSyncLockStatement) As BoundNode
				Dim boundStatement As Microsoft.CodeAnalysis.VisualBasic.BoundStatement = Me._enclosingSyncLockOrUsing
				Dim flag As Boolean = Me._isInCatchFinallyOrSyncLock
				Me._enclosingSyncLockOrUsing = node
				Me._isInCatchFinallyOrSyncLock = True
				MyBase.VisitSyncLockStatement(node)
				Me._enclosingSyncLockOrUsing = boundStatement
				Me._isInCatchFinallyOrSyncLock = flag
				Return Nothing
			End Function

			Public Overrides Function VisitTryStatement(ByVal node As BoundTryStatement) As BoundNode
				Me._containsTry = True
				Me._tryOnErrorResume.Add(node)
				Me.Visit(node.TryBlock)
				Dim flag As Boolean = Me._isInCatchFinallyOrSyncLock
				Me._isInCatchFinallyOrSyncLock = True
				Me.VisitList(Of BoundCatchBlock)(node.CatchBlocks)
				Me.Visit(node.FinallyBlockOpt)
				Me._isInCatchFinallyOrSyncLock = flag
				Return Nothing
			End Function

			Public Overrides Function VisitUsingStatement(ByVal node As BoundUsingStatement) As BoundNode
				Dim boundStatement As Microsoft.CodeAnalysis.VisualBasic.BoundStatement = Me._enclosingSyncLockOrUsing
				Me._enclosingSyncLockOrUsing = node
				MyBase.VisitUsingStatement(node)
				Me._enclosingSyncLockOrUsing = boundStatement
				Return Nothing
			End Function
		End Class

		Friend Delegate Function CheckParameterModifierDelegate(ByVal container As Symbol, ByVal token As Microsoft.CodeAnalysis.SyntaxToken, ByVal flag As SourceParameterFlags, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As SourceParameterFlags

		Public Enum ConstantContext
			[Default]
			ParameterDefaultValue
		End Enum

		Friend Class ConstructorCallArgumentsBinder
			Inherits Binder
			Protected Overrides ReadOnly Property IsInsideChainedConstructorCallArguments As Boolean
				Get
					Return True
				End Get
			End Property

			Public Sub New(ByVal containingBinder As Binder)
				MyBase.New(containingBinder)
			End Sub
		End Class

		Private Class DefaultInstancePropertyBinder
			Inherits Binder
			Public Overrides ReadOnly Property ImplicitVariableDeclarationAllowed As Boolean
				Get
					Return False
				End Get
			End Property

			Friend Overrides ReadOnly Property IsDefaultInstancePropertyAllowed As Boolean
				Get
					Return False
				End Get
			End Property

			Friend Overrides ReadOnly Property SuppressCallerInfo As Boolean
				Get
					Return True
				End Get
			End Property

			Public Sub New(ByVal containingBinder As Binder)
				MyBase.New(containingBinder)
			End Sub
		End Class

		Friend Structure DelegateResolutionResult
			Public ReadOnly DelegateConversions As ConversionKind

			Public ReadOnly Target As MethodSymbol

			Public ReadOnly MethodConversions As MethodConversionKind

			Public ReadOnly Diagnostics As ImmutableBindingDiagnostic(Of AssemblySymbol)

			Public Sub New(ByVal DelegateConversions As ConversionKind, ByVal Target As MethodSymbol, ByVal MethodConversions As MethodConversionKind, ByVal Diagnostics As ImmutableBindingDiagnostic(Of AssemblySymbol))
				Me = New Binder.DelegateResolutionResult() With
				{
					.DelegateConversions = DelegateConversions,
					.Target = Target,
					.Diagnostics = Diagnostics,
					.MethodConversions = MethodConversions
				}
			End Sub
		End Structure

		Private Structure DimensionSize
			Public ReadOnly Kind As Binder.DimensionSize.SizeKind

			Public ReadOnly Size As Integer

			Private Sub New(ByVal size As Integer, ByVal kind As Binder.DimensionSize.SizeKind)
				Me = New Binder.DimensionSize() With
				{
					.Size = size,
					.Kind = kind
				}
			End Sub

			Public Shared Function ConstantSize(ByVal size As Integer) As Binder.DimensionSize
				Return New Binder.DimensionSize(size, Binder.DimensionSize.SizeKind.Constant)
			End Function

			Public Shared Function VariableSize() As Binder.DimensionSize
				Return New Binder.DimensionSize(0, Binder.DimensionSize.SizeKind.NotConstant)
			End Function

			Public Enum SizeKind As Byte
				Unknown
				Constant
				NotConstant
			End Enum
		End Structure

		Private Class ImportsBinder
			Public Sub New()
				MyBase.New()
			End Sub

			Private Shared Sub BindAliasImportsClause(ByVal aliasImportSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal data As ImportData, ByVal diagnostics As DiagnosticBag)
				Dim instance As PooledHashSet(Of AssemblySymbol) = PooledHashSet(Of AssemblySymbol).GetInstance()
				Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = New Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag(diagnostics, instance)
				Dim namespaceOrTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol = binder.BindNamespaceOrTypeSyntax(aliasImportSyntax.Name, bindingDiagnosticBag, False)
				If (namespaceOrTypeSymbol.Kind <> SymbolKind.[Namespace]) Then
					Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = TryCast(namespaceOrTypeSymbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)
					If (typeSymbol Is Nothing OrElse typeSymbol.IsDelegateType()) Then
						Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(bindingDiagnosticBag, aliasImportSyntax, ERRID.ERR_InvalidTypeForAliasesImport2, New [Object]() { namespaceOrTypeSymbol, namespaceOrTypeSymbol.Name })
					End If
				End If
				Dim identifier As Microsoft.CodeAnalysis.SyntaxToken = aliasImportSyntax.[Alias].Identifier
				Dim valueText As String = identifier.ValueText
				If (Not data.Aliases.ContainsKey(valueText)) Then
					Dim members As ImmutableArray(Of Symbol) = binder.Compilation.GlobalNamespace.GetMembers(valueText)
					If (members.IsEmpty) Then
						If (namespaceOrTypeSymbol.Kind = SymbolKind.ErrorType) Then
							instance.Clear()
						Else
							Dim useSiteInfo As UseSiteInfo(Of AssemblySymbol) = namespaceOrTypeSymbol.GetUseSiteInfo()
							If (Not Microsoft.CodeAnalysis.VisualBasic.Binder.ImportsBinder.ShouldReportUseSiteErrorForAlias(useSiteInfo.DiagnosticInfo)) Then
								bindingDiagnosticBag.AddDependencies(useSiteInfo)
							Else
								Microsoft.CodeAnalysis.VisualBasic.Binder.ReportUseSite(bindingDiagnosticBag, aliasImportSyntax, useSiteInfo)
							End If
						End If
						Dim aliasSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol = New Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol(binder.Compilation, binder.ContainingNamespaceOrType, valueText, namespaceOrTypeSymbol, If(binder.BindingLocation = Microsoft.CodeAnalysis.VisualBasic.BindingLocation.ProjectImportsDeclaration, NoLocation.Singleton, identifier.GetLocation()))
						data.AddAlias(binder.GetSyntaxReference(aliasImportSyntax), valueText, aliasSymbol, aliasImportSyntax.SpanStart, instance)
					Else
						Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(bindingDiagnosticBag, aliasImportSyntax, ERRID.ERR_ImportAliasConflictsWithType2, New [Object]() { valueText, members(0) })
					End If
				Else
					Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(bindingDiagnosticBag, identifier, ERRID.ERR_DuplicateNamedImportAlias1, New [Object]() { valueText })
				End If
				instance.Free()
			End Sub

			Public Shared Sub BindImportClause(ByVal importClauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsClauseSyntax, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal data As ImportData, ByVal diagBag As DiagnosticBag)
				Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = importClauseSyntax.Kind()
				If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleImportsClause) Then
					If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.XmlNamespaceImportsClause) Then
						Return
					End If
					Microsoft.CodeAnalysis.VisualBasic.Binder.ImportsBinder.BindXmlNamespaceImportsClause(DirectCast(importClauseSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNamespaceImportsClauseSyntax), binder, data, diagBag)
					Return
				End If
				Dim simpleImportsClauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax = DirectCast(importClauseSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax)
				If (simpleImportsClauseSyntax.[Alias] Is Nothing) Then
					Microsoft.CodeAnalysis.VisualBasic.Binder.ImportsBinder.BindMembersImportsClause(simpleImportsClauseSyntax, binder, data, diagBag)
					Return
				End If
				Microsoft.CodeAnalysis.VisualBasic.Binder.ImportsBinder.BindAliasImportsClause(simpleImportsClauseSyntax, binder, data, diagBag)
			End Sub

			Private Shared Sub BindMembersImportsClause(ByVal membersImportsSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal data As ImportData, ByVal diagnostics As DiagnosticBag)
				Dim enumerator As HashSet(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol).Enumerator = New HashSet(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol).Enumerator()
				Dim instance As PooledHashSet(Of AssemblySymbol) = PooledHashSet(Of AssemblySymbol).GetInstance()
				Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = New Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag(diagnostics, instance)
				Dim name As Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax = membersImportsSyntax.Name
				Dim namespaceOrTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol = binder.BindNamespaceOrTypeSyntax(name, bindingDiagnosticBag, False)
				If (namespaceOrTypeSymbol.Kind <> SymbolKind.[Namespace]) Then
					Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = TryCast(namespaceOrTypeSymbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol)
					If (typeSymbol Is Nothing OrElse typeSymbol.IsDelegateType() OrElse typeSymbol.IsInterfaceType()) Then
						Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(bindingDiagnosticBag, membersImportsSyntax, ERRID.ERR_NonNamespaceOrClassOnImport2, New [Object]() { namespaceOrTypeSymbol, namespaceOrTypeSymbol.Name })
					End If
				End If
				If (namespaceOrTypeSymbol.Kind <> SymbolKind.ErrorType) Then
					If (Not data.Members.Contains(namespaceOrTypeSymbol)) Then
						Dim flag As Boolean = True
						If (namespaceOrTypeSymbol.Kind = SymbolKind.NamedType) Then
							Dim originalDefinition As NamedTypeSymbol = DirectCast(namespaceOrTypeSymbol, NamedTypeSymbol)
							If (originalDefinition.IsGenericType) Then
								originalDefinition = originalDefinition.OriginalDefinition
								Try
									enumerator = data.Members.GetEnumerator()
									While enumerator.MoveNext()
										If (enumerator.Current.OriginalDefinition <> originalDefinition) Then
											Continue While
										End If
										flag = False
										Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(bindingDiagnosticBag, name, ERRID.ERR_DuplicateRawGenericTypeImport1, New [Object]() { originalDefinition })
										GoTo Label0
									End While
								Finally
									DirectCast(enumerator, IDisposable).Dispose()
								End Try
							End If
						End If
					Label0:
						If (flag) Then
							data.AddMember(binder.GetSyntaxReference(name), namespaceOrTypeSymbol, membersImportsSyntax.SpanStart, instance)
						End If
					Else
						Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(bindingDiagnosticBag, name, ERRID.ERR_DuplicateImport1, New [Object]() { namespaceOrTypeSymbol })
					End If
				End If
				instance.Free()
			End Sub

			Private Shared Sub BindXmlNamespaceImportsClause(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNamespaceImportsClauseSyntax, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal data As ImportData, ByVal diagnostics As DiagnosticBag)
				Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = New Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag(diagnostics)
				Dim str As String = Nothing
				Dim str1 As String = Nothing
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
				Dim flag As Boolean = False
				If (binder.TryGetXmlnsAttribute(syntax.XmlNamespace, str, str1, boundExpression, flag, True, bindingDiagnosticBag) AndAlso Not flag) Then
					If (data.XmlNamespaces.ContainsKey(str)) Then
						Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(bindingDiagnosticBag, syntax, ERRID.ERR_DuplicatePrefix, New [Object]() { str })
						Return
					End If
					data.XmlNamespaces.Add(str, New XmlNamespaceAndImportsClausePosition(str1, syntax.SpanStart))
				End If
			End Sub

			Private Shared Function ShouldReportUseSiteErrorForAlias(ByVal useSiteErrorInfo As DiagnosticInfo) As Boolean
				If (useSiteErrorInfo Is Nothing OrElse useSiteErrorInfo.Code = 36924) Then
					Return False
				End If
				Return useSiteErrorInfo.Code <> 36925
			End Function
		End Class

		Private Class IntoClauseBinder
			Inherits Binder
			Protected ReadOnly m_GroupReference As BoundExpression

			Private ReadOnly _groupRangeVariables As ImmutableArray(Of RangeVariableSymbol)

			Private ReadOnly _groupCompoundVariableType As TypeSymbol

			Private ReadOnly _aggregationArgumentRangeVariables As ImmutableArray(Of RangeVariableSymbol)

			Public Sub New(ByVal parent As Binder, ByVal groupReference As BoundExpression, ByVal groupRangeVariables As ImmutableArray(Of RangeVariableSymbol), ByVal groupCompoundVariableType As TypeSymbol, ByVal aggregationArgumentRangeVariables As ImmutableArray(Of RangeVariableSymbol))
				MyBase.New(parent)
				Me.m_GroupReference = groupReference
				Me._groupRangeVariables = groupRangeVariables
				Me._groupCompoundVariableType = groupCompoundVariableType
				Me._aggregationArgumentRangeVariables = aggregationArgumentRangeVariables
			End Sub

			Public Overrides Sub AddLookupSymbolsInfo(ByVal nameSet As LookupSymbolsInfo, ByVal options As LookupOptions)
				' 
				' Current member / type: System.Void Microsoft.CodeAnalysis.VisualBasic.Binder/IntoClauseBinder::AddLookupSymbolsInfo(Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.LookupOptions)
				' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
				' 
				' Product version: 2019.1.118.0
				' Exception in: System.Void AddLookupSymbolsInfo(Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.LookupOptions)
				' 
				' La référence d'objet n'est pas définie à une instance d'un objet.
				'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
				'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
				'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
				'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
				'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
				'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
				'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
				'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
				' 
				' mailto: JustDecompilePublicFeedback@telerik.com

			End Sub

			Public Function BindAggregationRangeVariable(ByVal item As Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax, ByVal declaredNames As HashSet(Of String), <Out> ByRef selector As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol
				Dim nameEquals As Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax = item.NameEquals
				Dim valueText As String = Nothing
				Dim functionName As Microsoft.CodeAnalysis.SyntaxToken = New Microsoft.CodeAnalysis.SyntaxToken()
				If (nameEquals Is Nothing) Then
					Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = item.Aggregation.Kind()
					If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FunctionAggregation) Then
						functionName = DirectCast(item.Aggregation, Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax).FunctionName
						valueText = functionName.ValueText
					Else
						If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GroupAggregation) Then
							Throw ExceptionUtilities.UnexpectedValue(item.Aggregation.Kind())
						End If
						If (item.Parent.Kind() <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AggregateClause) Then
							functionName = DirectCast(item.Aggregation, Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupAggregationSyntax).GroupKeyword
							valueText = functionName.ValueText
						End If
					End If
				Else
					functionName = nameEquals.Identifier.Identifier
					valueText = functionName.ValueText
				End If
				selector = MyBase.BindRValue(item.Aggregation, diagnostics, False)
				If (valueText IsNot Nothing AndAlso valueText.Length = 0) Then
					valueText = Nothing
				End If
				Dim rangeVariableSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol = Nothing
				If (valueText Is Nothing) Then
					rangeVariableSymbol = Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol.CreateForErrorRecovery(Me, item, selector.Type)
				Else
					rangeVariableSymbol = Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol.Create(Me, functionName, selector.Type)
					selector = New BoundRangeVariableAssignment(item, rangeVariableSymbol, selector, selector.Type, False)
					Dim flag As Boolean = False
					If (declaredNames Is Nothing OrElse declaredNames.Add(valueText)) Then
						MyBase.VerifyRangeVariableName(rangeVariableSymbol, functionName, diagnostics)
					Else
						Binder.ReportDiagnostic(diagnostics, functionName, ERRID.ERR_QueryDuplicateAnonTypeMemberName1, New [Object]() { valueText })
						flag = True
					End If
					If (flag) Then
						rangeVariableSymbol = Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol.CreateForErrorRecovery(Me, rangeVariableSymbol.Syntax, selector.Type)
					End If
				End If
				Return rangeVariableSymbol
			End Function

			Friend Overrides Function BindFunctionAggregationExpression(ByVal functionAggregationSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
				Dim empty As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
				If (functionAggregationSyntax.FunctionName.GetTypeCharacter() <> TypeCharacter.None) Then
					Binder.ReportDiagnostic(diagnostics, functionAggregationSyntax.FunctionName, ERRID.ERR_TypeCharOnAggregation)
				End If
				Dim queryLambdaParameterName As String = Binder.GetQueryLambdaParameterName(Me._groupRangeVariables)
				Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Me._groupCompoundVariableType
				Dim argument As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax = functionAggregationSyntax.Argument
				If (argument Is Nothing) Then
					argument = functionAggregationSyntax
				End If
				Dim boundLambdaParameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol = MyBase.CreateQueryLambdaParameterSymbol(queryLambdaParameterName, 0, typeSymbol, argument, Me._groupRangeVariables)
				Dim containingBinder As Binder = MyBase.ContainingBinder
				Dim aggregationLambdaBody As [Object] = LambdaUtilities.GetAggregationLambdaBody(functionAggregationSyntax)
				If (aggregationLambdaBody Is Nothing) Then
					aggregationLambdaBody = functionAggregationSyntax
				End If
				Dim synthesizedLambdaSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaSymbol = containingBinder.CreateQueryLambdaSymbol(DirectCast(aggregationLambdaBody, Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode), SynthesizedLambdaKind.AggregationQueryLambda, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol)(boundLambdaParameterSymbol))
				Dim queryLambdaBinder As Binder.QueryLambdaBinder = New Binder.QueryLambdaBinder(synthesizedLambdaSymbol, Me._aggregationArgumentRangeVariables)
				Dim boundQueryLambda As Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda = Nothing
				If (functionAggregationSyntax.Argument IsNot Nothing) Then
					Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = queryLambdaBinder.BindValue(functionAggregationSyntax.Argument, diagnostics, False)
					boundQueryLambda = Binder.CreateBoundQueryLambda(synthesizedLambdaSymbol, Me._groupRangeVariables, boundExpression1, False)
					boundQueryLambda.SetWasCompilerGenerated()
					empty = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundQueryLambda)
				Else
					empty = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression).Empty
				End If
				If (Me.m_GroupReference.Type.IsErrorType() OrElse [String].IsNullOrEmpty(functionAggregationSyntax.FunctionName.ValueText)) Then
					Dim boundExpressions As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression) = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(Me.m_GroupReference)
					boundExpression = Binder.BadExpression(functionAggregationSyntax, boundExpressions.AddRange(empty), ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
				Else
					Dim discarded As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag = diagnostics
					If (boundQueryLambda IsNot Nothing AndAlso Binder.ShouldSuppressDiagnostics(boundQueryLambda)) Then
						discarded = Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag.Discarded
					End If
					Dim mGroupReference As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Me.m_GroupReference
					Dim valueText As String = functionAggregationSyntax.FunctionName.ValueText
					Dim functionName As Microsoft.CodeAnalysis.SyntaxToken = functionAggregationSyntax.FunctionName
					boundExpression = MyBase.BindQueryOperatorCall(functionAggregationSyntax, mGroupReference, valueText, empty, functionName.Span, discarded)
				End If
				Return New BoundQueryClause(functionAggregationSyntax, boundExpression, ImmutableArray(Of RangeVariableSymbol).Empty, boundExpression.Type, ImmutableArray.Create(Of Binder)(queryLambdaBinder), boundExpression.Type, False)
			End Function

			Friend Overrides Function BindGroupAggregationExpression(ByVal group As Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupAggregationSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
				Return New BoundGroupAggregation(group, Me.m_GroupReference, Me.m_GroupReference.Type, False)
			End Function

			Public Function BindIntoSelector(ByVal syntaxNode As Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax, ByVal keysRangeVariables As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol), ByVal compoundKeyReferencePart1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal keysRangeVariablesPart1 As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol), ByVal compoundKeyReferencePart2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression, ByVal keysRangeVariablesPart2 As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol), ByVal declaredNames As HashSet(Of String), ByVal aggregationVariables As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax), ByVal mustProduceFlatCompoundVariable As Boolean, <Out> ByRef declaredRangeVariables As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
				Dim boundExpressionArray As Microsoft.CodeAnalysis.VisualBasic.BoundExpression()
				Dim anonymousTypeField As Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField()
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
				Dim rangeVariableSymbolArray As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol()
				Dim rangeVariableSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol
				Dim length As Integer = keysRangeVariables.Length
				If (declaredNames Is Nothing) Then
					declaredNames = Binder.CreateSetOfDeclaredNames(keysRangeVariables)
				End If
				Dim num As Integer = Math.Max(aggregationVariables.Count, 1)
				If (length + num <= 1) Then
					If (aggregationVariables.Count <> 0) Then
						boundExpression = Nothing
						rangeVariableSymbol = Me.BindAggregationRangeVariable(aggregationVariables(0), declaredNames, boundExpression, diagnostics)
					Else
						rangeVariableSymbol = Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol.CreateForErrorRecovery(Me, syntaxNode, ErrorTypeSymbol.UnknownResultType)
						boundExpression = Binder.BadExpression(syntaxNode, Me.m_GroupReference, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
					End If
					rangeVariableSymbolArray = New Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol() { rangeVariableSymbol }
				Else
					If (length <= 1 OrElse mustProduceFlatCompoundVariable) Then
						ReDim boundExpressionArray(length + num - 1 + 1 - 1)
						ReDim anonymousTypeField(CInt(boundExpressionArray.Length) - 1 + 1 - 1)
						Dim num1 As Integer = length - 1
						For i As Integer = 0 To num1
							Dim item As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol = keysRangeVariables(i)
							anonymousTypeField(i) = New Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField(item.Name, item.Type, item.Syntax.GetLocation(), True)
							boundExpressionArray(i) = (New BoundRangeVariable(item.Syntax, item, item.Type)).MakeCompilerGenerated()
						Next

					ElseIf (compoundKeyReferencePart2 IsNot Nothing) Then
						ReDim boundExpressionArray(num + 2 - 1 + 1 - 1)
						ReDim anonymousTypeField(CInt(boundExpressionArray.Length) - 1 + 1 - 1)
						anonymousTypeField(0) = New Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField(Binder.GetQueryLambdaParameterNameLeft(keysRangeVariablesPart1), compoundKeyReferencePart1.Type, keysRangeVariablesPart1(0).Syntax.GetLocation(), True)
						boundExpressionArray(0) = compoundKeyReferencePart1
						anonymousTypeField(1) = New Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField(Binder.GetQueryLambdaParameterNameRight(keysRangeVariablesPart2), compoundKeyReferencePart2.Type, keysRangeVariablesPart2(0).Syntax.GetLocation(), True)
						boundExpressionArray(1) = compoundKeyReferencePart2
						length = 2
					Else
						ReDim boundExpressionArray(num + 1 - 1 + 1 - 1)
						ReDim anonymousTypeField(CInt(boundExpressionArray.Length) - 1 + 1 - 1)
						anonymousTypeField(0) = New Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField(Binder.GetQueryLambdaParameterName(keysRangeVariablesPart1), compoundKeyReferencePart1.Type, keysRangeVariables(0).Syntax.GetLocation(), True)
						boundExpressionArray(0) = compoundKeyReferencePart1
						length = 1
					End If
					ReDim rangeVariableSymbolArray(num - 1 + 1 - 1)
					If (aggregationVariables.Count <> 0) Then
						Dim count As Integer = aggregationVariables.Count - 1
						For j As Integer = 0 To count
							Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
							Dim rangeVariableSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol = Me.BindAggregationRangeVariable(aggregationVariables(j), declaredNames, boundExpression1, diagnostics)
							rangeVariableSymbolArray(j) = rangeVariableSymbol1
							boundExpressionArray(length + j) = boundExpression1
							anonymousTypeField(length + j) = New Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField(rangeVariableSymbol1.Name, rangeVariableSymbol1.Type, rangeVariableSymbol1.Syntax.GetLocation(), True)
						Next

					Else
						Dim rangeVariableSymbol2 As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol = Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol.CreateForErrorRecovery(Me, syntaxNode, ErrorTypeSymbol.UnknownResultType)
						rangeVariableSymbolArray(0) = rangeVariableSymbol2
						boundExpressionArray(length) = Binder.BadExpression(syntaxNode, Me.m_GroupReference, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
						anonymousTypeField(length) = New Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField(rangeVariableSymbol2.Name, rangeVariableSymbol2.Type, rangeVariableSymbol2.Syntax.GetLocation(), True)
					End If
					Dim anonymousTypeFields As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField) = Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField)(anonymousTypeField)
					Dim syntaxToken As Microsoft.CodeAnalysis.SyntaxToken = syntaxNode.QueryClauseKeywordOrRangeVariableIdentifier()
					boundExpression = MyBase.BindAnonymousObjectCreationExpression(syntaxNode, New AnonymousTypeDescriptor(anonymousTypeFields, syntaxToken.GetLocation(), True), Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpressionArray), diagnostics).MakeCompilerGenerated()
				End If
				declaredRangeVariables = Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)(rangeVariableSymbolArray)
				Return boundExpression
			End Function

			Public Overrides Sub Lookup(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				' 
				' Current member / type: System.Void Microsoft.CodeAnalysis.VisualBasic.Binder/IntoClauseBinder::Lookup(Microsoft.CodeAnalysis.VisualBasic.LookupResult,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.CompoundUseSiteInfo`1<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&)
				' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
				' 
				' Product version: 2019.1.118.0
				' Exception in: System.Void Lookup(Microsoft.CodeAnalysis.VisualBasic.LookupResult,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.CompoundUseSiteInfo<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&)
				' 
				' La référence d'objet n'est pas définie à une instance d'un objet.
				'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
				'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
				'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
				'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
				'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
				'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
				'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
				'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
				' 
				' mailto: JustDecompilePublicFeedback@telerik.com

			End Sub
		End Class

		Private Class IntoClauseDisallowGroupReferenceBinder
			Inherits Binder.IntoClauseBinder
			Public Sub New(ByVal parent As Binder, ByVal groupReference As BoundExpression, ByVal groupRangeVariables As ImmutableArray(Of RangeVariableSymbol), ByVal groupCompoundVariableType As TypeSymbol, ByVal aggregationArgumentRangeVariables As ImmutableArray(Of RangeVariableSymbol))
				MyBase.New(parent, groupReference, groupRangeVariables, groupCompoundVariableType, aggregationArgumentRangeVariables)
			End Sub

			Friend Overrides Function BindGroupAggregationExpression(ByVal group As Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupAggregationSyntax, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
				Return Binder.BadExpression(group, Me.m_GroupReference, ErrorTypeSymbol.UnknownResultType)
			End Function
		End Class

		Private Class LambdaRelaxationVisitor
			Inherits StatementWalker
			Private ReadOnly _lambdaSymbol As LambdaSymbol

			Private ReadOnly _isIterator As Boolean

			Private _delegateRelaxationLevel As ConversionKind

			Private _seenReturnWithAValue As Boolean

			Private _useSiteDiagnostics As CompoundUseSiteInfo(Of AssemblySymbol)

			Private Sub New(ByVal lambdaSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.LambdaSymbol, ByVal isIterator As Boolean)
				MyBase.New()
				Me._delegateRelaxationLevel = ConversionKind.DelegateRelaxationLevelNone
				Me._lambdaSymbol = lambdaSymbol
				Me._isIterator = isIterator
			End Sub

			Public Shared Function DetermineDelegateRelaxationLevel(ByVal lambdaSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.LambdaSymbol, ByVal isIterator As Boolean, ByVal lambdaBlock As BoundBlock, <Out> ByRef seenReturnWithAValue As Boolean, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol)) As ConversionKind
				Dim lambdaRelaxationVisitor As Binder.LambdaRelaxationVisitor = New Binder.LambdaRelaxationVisitor(lambdaSymbol, isIterator) With
				{
					._useSiteDiagnostics = useSiteInfo
				}
				lambdaRelaxationVisitor.VisitBlock(lambdaBlock)
				seenReturnWithAValue = lambdaRelaxationVisitor._seenReturnWithAValue
				useSiteInfo = lambdaRelaxationVisitor._useSiteDiagnostics
				Return lambdaRelaxationVisitor._delegateRelaxationLevel
			End Function

			Public Overrides Function Visit(ByVal node As Microsoft.CodeAnalysis.VisualBasic.BoundNode) As Microsoft.CodeAnalysis.VisualBasic.BoundNode
				Dim boundNode As Microsoft.CodeAnalysis.VisualBasic.BoundNode
				If (node Is Nothing OrElse TypeOf node Is BoundExpression) Then
					boundNode = Nothing
				Else
					boundNode = MyBase.Visit(node)
				End If
				Return boundNode
			End Function

			Public Overrides Function VisitLambda(ByVal node As BoundLambda) As BoundNode
				Throw ExceptionUtilities.Unreachable
			End Function

			Public Overrides Function VisitReturnStatement(ByVal node As BoundReturnStatement) As Microsoft.CodeAnalysis.VisualBasic.BoundNode
				Dim boundNode As Microsoft.CodeAnalysis.VisualBasic.BoundNode
				If (Not Me._isIterator) Then
					If (node.ExpressionOpt IsNot Nothing) Then
						If (node.ExpressionOpt.Kind = BoundKind.Local) Then
							Dim localSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol = DirectCast(node.ExpressionOpt, BoundLocal).LocalSymbol
							If (Not localSymbol.IsFunctionValue OrElse localSymbol.ContainingSymbol <> Me._lambdaSymbol) Then
								GoTo Label1
							End If
							boundNode = Nothing
							Return boundNode
						End If
					Label1:
						Me._seenReturnWithAValue = True
					End If
					Dim conversionKind As Microsoft.CodeAnalysis.VisualBasic.ConversionKind = Microsoft.CodeAnalysis.VisualBasic.Conversions.DetermineDelegateRelaxationLevelForLambdaReturn(node.ExpressionOpt, Me._useSiteDiagnostics)
					If (conversionKind > Me._delegateRelaxationLevel) Then
						Me._delegateRelaxationLevel = conversionKind
					End If
					boundNode = Nothing
				Else
					boundNode = Nothing
				End If
				Return boundNode
			End Function

			Public Overrides Function VisitYieldStatement(ByVal node As BoundYieldStatement) As BoundNode
				If (Me._isIterator) Then
					Dim conversionKind As Microsoft.CodeAnalysis.VisualBasic.ConversionKind = Microsoft.CodeAnalysis.VisualBasic.Conversions.DetermineDelegateRelaxationLevelForLambdaReturn(node.Expression, Me._useSiteDiagnostics)
					If (conversionKind > Me._delegateRelaxationLevel) Then
						Me._delegateRelaxationLevel = conversionKind
					End If
				End If
				Return Nothing
			End Function
		End Class

		Private Class LambdaReturnStatementsVisitor
			Inherits StatementWalker
			Private ReadOnly _builder As ArrayBuilder(Of BoundExpression)

			Private ReadOnly _isIterator As Boolean

			Private Sub New(ByVal builder As ArrayBuilder(Of BoundExpression), ByVal isIterator As Boolean)
				MyBase.New()
				Me._builder = builder
				Me._isIterator = isIterator
			End Sub

			Public Shared Sub CollectReturnExpressions(ByVal lambdaBlock As BoundBlock, ByVal arrayToFill As ArrayBuilder(Of BoundExpression), ByVal isIterator As Boolean)
				Dim boundNode As Microsoft.CodeAnalysis.VisualBasic.BoundNode = (New Binder.LambdaReturnStatementsVisitor(arrayToFill, isIterator)).VisitBlock(lambdaBlock)
			End Sub

			Public Overrides Function Visit(ByVal node As Microsoft.CodeAnalysis.VisualBasic.BoundNode) As Microsoft.CodeAnalysis.VisualBasic.BoundNode
				Dim boundNode As Microsoft.CodeAnalysis.VisualBasic.BoundNode
				If (node Is Nothing OrElse TypeOf node Is BoundExpression) Then
					boundNode = Nothing
				Else
					boundNode = MyBase.Visit(node)
				End If
				Return boundNode
			End Function

			Public Overrides Function VisitLambda(ByVal node As BoundLambda) As BoundNode
				Throw ExceptionUtilities.Unreachable
			End Function

			Public Overrides Function VisitReturnStatement(ByVal node As BoundReturnStatement) As Microsoft.CodeAnalysis.VisualBasic.BoundNode
				Dim boundNode As Microsoft.CodeAnalysis.VisualBasic.BoundNode
				If (Not Me._isIterator) Then
					Dim expressionOpt As BoundExpression = node.ExpressionOpt
					If (expressionOpt Is Nothing OrElse CObj(expressionOpt.Type) = CObj(LambdaSymbol.ReturnTypeIsBeingInferred)) Then
						boundNode = Nothing
					Else
						Me._builder.Add(expressionOpt)
						boundNode = Nothing
					End If
				Else
					boundNode = Nothing
				End If
				Return boundNode
			End Function

			Public Overrides Function VisitYieldStatement(ByVal node As BoundYieldStatement) As BoundNode
				If (Me._isIterator) Then
					Me._builder.Add(node.Expression)
				End If
				Return Nothing
			End Function
		End Class

		Private Class MemberLookup
			Private ReadOnly Shared s_ambiguousInModuleError As Func(Of ImmutableArray(Of Symbol), AmbiguousSymbolDiagnostic)

			Shared Sub New()
				Binder.MemberLookup.s_ambiguousInModuleError = Function(syms As ImmutableArray(Of Symbol))
					Dim containingType As Func(Of Symbol, NamedTypeSymbol)
					Dim name As String = syms(0).Name
					Dim symbols As ImmutableArray(Of Symbol) = syms
					If (Binder.MemberLookup._Closure$__.$I0-1 Is Nothing) Then
						containingType = Function(sym As Symbol) sym.ContainingType
						Binder.MemberLookup._Closure$__.$I0-1 = containingType
					Else
						containingType = Binder.MemberLookup._Closure$__.$I0-1
					End If
					Return New AmbiguousSymbolDiagnostic(ERRID.ERR_AmbiguousInModules2, syms, New [Object]() { name, New FormattedSymbolList(symbols.[Select](Of NamedTypeSymbol)(containingType), Nothing) })
				End Function
			End Sub

			Public Sub New()
				MyBase.New()
			End Sub

			Private Shared Sub AddBaseInterfacesToTheSearch(ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal currentInfo As Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo, ByVal lookIn As Queue(Of Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo), ByVal processed As HashSet(Of Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo), <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				Dim namedTypeSymbols As ImmutableHashSet(Of NamedTypeSymbol)
				Dim directBaseInterfacesNoUseSiteDiagnostics As ImmutableArray(Of NamedTypeSymbol) = currentInfo.InterfaceType.GetDirectBaseInterfacesNoUseSiteDiagnostics(binder.BasesBeingResolved())
				If (Not directBaseInterfacesNoUseSiteDiagnostics.IsDefaultOrEmpty) Then
					Dim flag As Boolean = If(currentInfo.InComInterfaceContext, True, CObj(currentInfo.InterfaceType.CoClassType) <> CObj(Nothing))
					If (binder.BasesBeingResolved().InheritsBeingResolvedOpt IsNot Nothing) Then
						namedTypeSymbols = If(currentInfo.DescendantDefinitions IsNot Nothing, currentInfo.DescendantDefinitions.Add(currentInfo.InterfaceType.OriginalDefinition), ImmutableHashSet.Create(Of NamedTypeSymbol)(currentInfo.InterfaceType.OriginalDefinition))
					Else
						namedTypeSymbols = Nothing
					End If
					Dim enumerator As ImmutableArray(Of NamedTypeSymbol).Enumerator = directBaseInterfacesNoUseSiteDiagnostics.GetEnumerator()
					While enumerator.MoveNext()
						Dim current As NamedTypeSymbol = enumerator.Current
						If (namedTypeSymbols IsNot Nothing AndAlso namedTypeSymbols.Contains(current.OriginalDefinition)) Then
							Continue While
						End If
						current.OriginalDefinition.AddUseSiteInfo(useSiteInfo)
						Dim interfaceInfo As Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo = New Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo(current, flag, namedTypeSymbols)
						If (Not processed.Add(interfaceInfo)) Then
							Continue While
						End If
						lookIn.Enqueue(interfaceInfo)
					End While
				End If
			End Sub

			Public Shared Sub AddExtensionMethodLookupSymbolsInfo(ByVal nameSet As LookupSymbolsInfo, ByVal container As TypeSymbol, ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder)
				If (Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.ShouldLookupExtensionMethods(options, container)) Then
					options = options And (LookupOptions.NamespacesOrTypesOnly Or LookupOptions.LabelsOnly Or LookupOptions.MustNotBeInstance Or LookupOptions.MustNotBeReturnValueVariable Or LookupOptions.NoBaseClassLookup Or LookupOptions.IgnoreAccessibility Or LookupOptions.AllMethodsOfAnyArity Or LookupOptions.IgnoreExtensionMethods Or LookupOptions.EagerlyLookupExtensionMethods Or LookupOptions.MethodsOnly Or LookupOptions.UseBaseReferenceAccessibility Or LookupOptions.AttributeTypeOnly Or LookupOptions.MustNotBeLocalOrParameter Or LookupOptions.EventsOnly Or LookupOptions.NoSystemObjectLookupForInterfaces Or LookupOptions.AllowIntrinsicAliases)
					Dim mContainingBinder As Microsoft.CodeAnalysis.VisualBasic.Binder = binder
					Dim instance As LookupSymbolsInfo = LookupSymbolsInfo.GetInstance()
					Do
						mContainingBinder.AddExtensionMethodLookupSymbolsInfoInSingleBinder(instance, options, binder)
						mContainingBinder = mContainingBinder.m_containingBinder
					Loop While mContainingBinder IsNot Nothing
					Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddLookupSymbolsInfoOfExtensionMethods(nameSet, container, instance, binder)
					instance.Free()
					Dim compilation As VisualBasicCompilation = binder.Compilation
					Dim discardedDependencies As CompoundUseSiteInfo(Of AssemblySymbol) = CompoundUseSiteInfo(Of AssemblySymbol).DiscardedDependencies
					If (container.IsOrImplementsIEnumerableOfXElement(compilation, discardedDependencies) AndAlso discardedDependencies.Diagnostics.IsNullOrEmpty()) Then
						nameSet.AddSymbol(Nothing, "Value", 0)
					End If
				End If
			End Sub

			Private Shared Sub AddInterfaceConstraints(ByVal typeParameter As TypeParameterSymbol, ByRef allInterfaces As Queue(Of Binder.MemberLookup.InterfaceInfo), ByRef processedInterfaces As HashSet(Of Binder.MemberLookup.InterfaceInfo), <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				Dim enumerator As ImmutableArray(Of TypeSymbol).Enumerator = typeParameter.ConstraintTypesWithDefinitionUseSiteDiagnostics(useSiteInfo).GetEnumerator()
				While enumerator.MoveNext()
					Dim current As TypeSymbol = enumerator.Current
					Dim typeKind As Microsoft.CodeAnalysis.TypeKind = current.TypeKind
					If (typeKind = Microsoft.CodeAnalysis.TypeKind.[Interface]) Then
						Dim interfaceInfo As Binder.MemberLookup.InterfaceInfo = New Binder.MemberLookup.InterfaceInfo(DirectCast(current, NamedTypeSymbol), False, Nothing)
						If (processedInterfaces IsNot Nothing AndAlso processedInterfaces.Contains(interfaceInfo)) Then
							Continue While
						End If
						If (processedInterfaces Is Nothing) Then
							allInterfaces = New Queue(Of Binder.MemberLookup.InterfaceInfo)()
							processedInterfaces = New HashSet(Of Binder.MemberLookup.InterfaceInfo)()
						End If
						allInterfaces.Enqueue(interfaceInfo)
						processedInterfaces.Add(interfaceInfo)
					ElseIf (typeKind = Microsoft.CodeAnalysis.TypeKind.TypeParameter) Then
						Binder.MemberLookup.AddInterfaceConstraints(DirectCast(current, TypeParameterSymbol), allInterfaces, processedInterfaces, useSiteInfo)
					End If
				End While
			End Sub

			Public Shared Sub AddLookupSymbolsInfo(ByVal nameSet As LookupSymbolsInfo, ByVal container As NamespaceOrTypeSymbol, ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder)
				If (container.IsNamespace) Then
					Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddLookupSymbolsInfo(nameSet, DirectCast(container, NamespaceSymbol), options, binder)
					Return
				End If
				Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddLookupSymbolsInfo(nameSet, DirectCast(container, TypeSymbol), options, binder)
			End Sub

			Private Shared Sub AddLookupSymbolsInfo(ByVal nameSet As LookupSymbolsInfo, ByVal container As NamespaceSymbol, ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder)
				Dim enumerator As ImmutableArray(Of Symbol).Enumerator = container.GetMembersUnordered().GetEnumerator()
				While enumerator.MoveNext()
					Dim current As Symbol = enumerator.Current
					If (Not binder.CanAddLookupSymbolInfo(current, options, nameSet, Nothing)) Then
						Continue While
					End If
					nameSet.AddSymbol(current, current.Name, current.GetArity())
				End While
				Dim enumerator1 As ImmutableArray(Of NamedTypeSymbol).Enumerator = container.GetModuleMembers().GetEnumerator()
				While enumerator1.MoveNext()
					Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddLookupSymbolsInfo(nameSet, enumerator1.Current, options, binder)
				End While
			End Sub

			Private Shared Sub AddLookupSymbolsInfo(ByVal nameSet As LookupSymbolsInfo, ByVal container As TypeSymbol, ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder)
				Select Case container.TypeKind
					Case Microsoft.CodeAnalysis.TypeKind.Array
					Case Microsoft.CodeAnalysis.TypeKind.[Class]
					Case Microsoft.CodeAnalysis.TypeKind.[Delegate]
					Case Microsoft.CodeAnalysis.TypeKind.[Enum]
					Case Microsoft.CodeAnalysis.TypeKind.Struct
						Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddLookupSymbolsInfoInClass(nameSet, container, options, binder)
						Return
					Case Microsoft.CodeAnalysis.TypeKind.Dynamic
					Case Microsoft.CodeAnalysis.TypeKind.Pointer
						Throw ExceptionUtilities.UnexpectedValue(container.TypeKind)
					Case Microsoft.CodeAnalysis.TypeKind.[Error]
						Return
					Case Microsoft.CodeAnalysis.TypeKind.[Interface]
						Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddLookupSymbolsInfoInInterface(nameSet, DirectCast(container, NamedTypeSymbol), options, binder)
						Return
					Case Microsoft.CodeAnalysis.TypeKind.[Module]
						Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddLookupSymbolsInfoInClass(nameSet, container, options Or LookupOptions.NoBaseClassLookup, binder)
						Return
					Case Microsoft.CodeAnalysis.TypeKind.TypeParameter
						Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddLookupSymbolsInfoInTypeParameter(nameSet, DirectCast(container, TypeParameterSymbol), options, binder)
						Return
					Case Microsoft.CodeAnalysis.TypeKind.Submission
						Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddLookupSymbolsInfoInSubmissions(nameSet, container, options, binder)
						Return
					Case Else
						Throw ExceptionUtilities.UnexpectedValue(container.TypeKind)
				End Select
			End Sub

			Private Shared Sub AddLookupSymbolsInfoInClass(ByVal nameSet As LookupSymbolsInfo, ByVal container As TypeSymbol, ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder)
				' 
				' Current member / type: System.Void Microsoft.CodeAnalysis.VisualBasic.Binder/MemberLookup::AddLookupSymbolsInfoInClass(Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder)
				' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
				' 
				' Product version: 2019.1.118.0
				' Exception in: System.Void AddLookupSymbolsInfoInClass(Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder)
				' 
				' La référence d'objet n'est pas définie à une instance d'un objet.
				'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
				'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
				'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
				'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
				'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
				'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
				'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
				'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
				' 
				' mailto: JustDecompilePublicFeedback@telerik.com

			End Sub

			Private Shared Sub AddLookupSymbolsInfoInInterface(ByVal nameSet As LookupSymbolsInfo, ByVal container As NamedTypeSymbol, ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder)
				Dim interfaceInfo As Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo = New Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo(container, False, Nothing)
				Dim interfaceInfos As Queue(Of Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo) = New Queue(Of Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo)()
				interfaceInfos.Enqueue(interfaceInfo)
				Dim interfaceInfos1 As HashSet(Of Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo) = New HashSet(Of Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo)()
				interfaceInfos1.Add(interfaceInfo)
				Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddLookupSymbolsInfoInInterfaces(nameSet, container, interfaceInfos, interfaceInfos1, options, binder)
				Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddLookupSymbolsInfoInClass(nameSet, binder.SourceModule.ContainingAssembly.GetSpecialType(SpecialType.System_Object), options Or LookupOptions.IgnoreExtensionMethods, binder)
				Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddExtensionMethodLookupSymbolsInfo(nameSet, container, options, binder)
			End Sub

			Private Shared Sub AddLookupSymbolsInfoInInterfaces(ByVal nameSet As LookupSymbolsInfo, ByVal container As TypeSymbol, ByVal lookIn As Queue(Of Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo), ByVal processed As HashSet(Of Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo), ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder)
				' 
				' Current member / type: System.Void Microsoft.CodeAnalysis.VisualBasic.Binder/MemberLookup::AddLookupSymbolsInfoInInterfaces(Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Generic.Queue`1<Microsoft.CodeAnalysis.VisualBasic.Binder/MemberLookup/InterfaceInfo>,System.Collections.Generic.HashSet`1<Microsoft.CodeAnalysis.VisualBasic.Binder/MemberLookup/InterfaceInfo>,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder)
				' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
				' 
				' Product version: 2019.1.118.0
				' Exception in: System.Void AddLookupSymbolsInfoInInterfaces(Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Generic.Queue<Microsoft.CodeAnalysis.VisualBasic.Binder/MemberLookup/InterfaceInfo>,System.Collections.Generic.HashSet<Microsoft.CodeAnalysis.VisualBasic.Binder/MemberLookup/InterfaceInfo>,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder)
				' 
				' La référence d'objet n'est pas définie à une instance d'un objet.
				'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
				'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
				'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
				'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
				'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
				'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
				'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
				'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
				' 
				' mailto: JustDecompilePublicFeedback@telerik.com

			End Sub

			Private Shared Sub AddLookupSymbolsInfoInSubmissions(ByVal nameSet As LookupSymbolsInfo, ByVal submissionClass As TypeSymbol, ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder)
				Dim compilation As VisualBasicCompilation = binder.Compilation
				Do
					If (compilation.ScriptClass IsNot Nothing) Then
						Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddLookupSymbolsInfoWithoutInheritance(nameSet, compilation.ScriptClass, options, submissionClass, binder)
					End If
					compilation = compilation.PreviousSubmission
				Loop While compilation IsNot Nothing
			End Sub

			Private Shared Sub AddLookupSymbolsInfoInTypeParameter(ByVal nameSet As LookupSymbolsInfo, ByVal typeParameter As TypeParameterSymbol, ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder)
				If (typeParameter.TypeParameterKind <> TypeParameterKind.Cref) Then
					Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddLookupSymbolsInfoInTypeParameterNoExtensionMethods(nameSet, typeParameter, options, binder)
					Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddExtensionMethodLookupSymbolsInfo(nameSet, typeParameter, options, binder)
				End If
			End Sub

			Private Shared Sub AddLookupSymbolsInfoInTypeParameterNoExtensionMethods(ByVal nameSet As LookupSymbolsInfo, ByVal typeParameter As TypeParameterSymbol, ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder)
				options = options Or LookupOptions.IgnoreExtensionMethods
				Dim discarded As CompoundUseSiteInfo(Of AssemblySymbol) = CompoundUseSiteInfo(Of AssemblySymbol).Discarded
				Dim classConstraint As NamedTypeSymbol = typeParameter.GetClassConstraint(discarded)
				If (classConstraint IsNot Nothing) Then
					Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddLookupSymbolsInfoInClass(nameSet, classConstraint, options, binder)
				End If
				Dim interfaceInfos As Queue(Of Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo) = Nothing
				Dim interfaceInfos1 As HashSet(Of Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo) = Nothing
				discarded = CompoundUseSiteInfo(Of AssemblySymbol).Discarded
				Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddInterfaceConstraints(typeParameter, interfaceInfos, interfaceInfos1, discarded)
				If (interfaceInfos IsNot Nothing) Then
					Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddLookupSymbolsInfoInInterfaces(nameSet, typeParameter, interfaceInfos, interfaceInfos1, options, binder)
				End If
				If (classConstraint Is Nothing) Then
					Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddLookupSymbolsInfoInClass(nameSet, Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.GetTypeParameterBaseType(typeParameter), options, binder)
				End If
			End Sub

			Private Shared Sub AddLookupSymbolsInfoOfExtensionMethods(ByVal nameSet As LookupSymbolsInfo, ByVal container As TypeSymbol, ByVal newInfo As LookupSymbolsInfo, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder)
				Dim enumerator As IEnumerator(Of String) = Nothing
				Using instance As LookupResult = LookupResult.GetInstance()
					enumerator = newInfo.Names.GetEnumerator()
					While enumerator.MoveNext()
						Dim current As String = enumerator.Current
						instance.Clear()
						Dim discarded As CompoundUseSiteInfo(Of AssemblySymbol) = CompoundUseSiteInfo(Of AssemblySymbol).Discarded
						Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupForExtensionMethods(instance, container, current, 0, LookupOptions.IgnoreAccessibility Or LookupOptions.AllMethodsOfAnyArity, binder, discarded)
						If (Not instance.IsGood) Then
							Continue While
						End If
						Dim enumerator1 As ArrayBuilder(Of Symbol).Enumerator = instance.Symbols.GetEnumerator()
						While enumerator1.MoveNext()
							Dim methodSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol = DirectCast(enumerator1.Current, Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol)
							nameSet.AddSymbol(methodSymbol, methodSymbol.Name, methodSymbol.Arity)
						End While
					End While
				End Using
				instance.Free()
			End Sub

			Private Shared Sub AddLookupSymbolsInfoWithoutInheritance(ByVal nameSet As LookupSymbolsInfo, ByVal container As TypeSymbol, ByVal options As LookupOptions, ByVal accessThroughType As TypeSymbol, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder)
				' 
				' Current member / type: System.Void Microsoft.CodeAnalysis.VisualBasic.Binder/MemberLookup::AddLookupSymbolsInfoWithoutInheritance(Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder)
				' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
				' 
				' Product version: 2019.1.118.0
				' Exception in: System.Void AddLookupSymbolsInfoWithoutInheritance(Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder)
				' 
				' La référence d'objet n'est pas définie à une instance d'un objet.
				'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
				'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
				'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
				'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
				'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
				'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
				'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
				'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
				' 
				' mailto: JustDecompilePublicFeedback@telerik.com

			End Sub

			Private Shared Sub AddWinRTMembersLookupSymbolsInfo(ByVal nameSet As LookupSymbolsInfo, ByVal type As NamedTypeSymbol, ByVal options As LookupOptions, ByVal accessThroughType As TypeSymbol, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder)
				Dim enumerator As ImmutableArray(Of NamedTypeSymbol).Enumerator = type.AllInterfacesNoUseSiteDiagnostics.GetEnumerator()
				While enumerator.MoveNext()
					Dim current As NamedTypeSymbol = enumerator.Current
					If (Not Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.IsWinRTProjectedInterface(current, binder.Compilation)) Then
						Continue While
					End If
					Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddLookupSymbolsInfoWithoutInheritance(nameSet, current, options, accessThroughType, binder)
				End While
			End Sub

			Private Shared Function AnyShadows(ByVal result As LookupResult) As Boolean
				Dim flag As Boolean
				Dim enumerator As ArrayBuilder(Of Symbol).Enumerator = result.Symbols.GetEnumerator()
				While True
					If (Not enumerator.MoveNext()) Then
						flag = False
						Exit While
					ElseIf (enumerator.Current.IsShadows()) Then
						flag = True
						Exit While
					End If
				End While
				Return flag
			End Function

			Private Shared Function CheckAndClearMethodsOnlyOption(ByRef options As LookupOptions) As Boolean
				Dim flag As Boolean
				If ((CInt(options) And 2048) = 0) Then
					flag = False
				Else
					options = CInt(options) And -2049
					flag = True
				End If
				Return flag
			End Function

			Private Shared Sub ClearLookupResultIfNotMethods(ByVal methodsOnly As Boolean, ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult)
				If (methodsOnly AndAlso lookupResult.HasSymbol AndAlso lookupResult.Symbols(0).Kind <> SymbolKind.Method) Then
					lookupResult.Clear()
				End If
			End Sub

			Private Shared Sub CompactAndAppend(ByVal first As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbol), ByVal second As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbol))
				Dim i As Integer = 0
				While i < first.Count AndAlso first(i) IsNot Nothing
					i = i + 1
				End While
				Dim num As Integer = i + 1
				Do
					Dim item As Microsoft.CodeAnalysis.VisualBasic.Symbol = first(num)
					If (item IsNot Nothing) Then
						first(i) = item
						i = i + 1
					End If
					num = num + 1
				Loop While num < first.Count
				first.Clip(i)
				For i = 0 To second.Count
					Dim symbol As Microsoft.CodeAnalysis.VisualBasic.Symbol = second(i)
					If (symbol IsNot Nothing) Then
						first.Add(symbol)
					End If
				Next

			End Sub

			Private Shared Sub FilterSymbolsInLookupResult(ByVal result As LookupResult, ByVal kind As SymbolKind, ByVal leaveInsteadOfRemoving As Boolean)
				Dim symbols As ArrayBuilder(Of Symbol) = result.Symbols
				Dim num As Integer = 0
				Dim num1 As Integer = 0
				Do
					If (symbols(num1).Kind = kind = leaveInsteadOfRemoving) Then
						symbols(num) = symbols(num1)
						num = num + 1
					End If
					num1 = num1 + 1
				Loop While num1 < symbols.Count
				symbols.Clip(num)
				If (num = 0) Then
					result.Clear()
				End If
			End Sub

			Private Shared Sub FindWinRTMembers(ByVal result As LookupResult, ByVal type As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal tempResult As LookupResult, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol), ByVal lookupMembersNotDefaultProperties As Boolean, Optional ByVal name As String = Nothing, Optional ByVal arity As Integer = -1, Optional ByVal options As LookupOptions = 0)
				Dim enumerator As HashSet(Of Microsoft.CodeAnalysis.VisualBasic.Symbol).Enumerator = New HashSet(Of Microsoft.CodeAnalysis.VisualBasic.Symbol).Enumerator()
				Dim winRTComparer As MemberSignatureComparer = MemberSignatureComparer.WinRTComparer
				Dim symbols As HashSet(Of Microsoft.CodeAnalysis.VisualBasic.Symbol) = New HashSet(Of Microsoft.CodeAnalysis.VisualBasic.Symbol)(winRTComparer)
				Dim symbols1 As HashSet(Of Microsoft.CodeAnalysis.VisualBasic.Symbol) = New HashSet(Of Microsoft.CodeAnalysis.VisualBasic.Symbol)(winRTComparer)
				If (result.IsGood) Then
					Dim enumerator1 As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbol).Enumerator = result.Symbols.GetEnumerator()
					While enumerator1.MoveNext()
						Dim current As Microsoft.CodeAnalysis.VisualBasic.Symbol = enumerator1.Current
						If (current.Kind = SymbolKind.Field) Then
							Continue While
						End If
						symbols.Add(current)
					End While
				End If
				Dim instance As LookupResult = LookupResult.GetInstance()
				Dim enumerator2 As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol).Enumerator = type.AllInterfacesWithDefinitionUseSiteDiagnostics(useSiteInfo).GetEnumerator()
				While enumerator2.MoveNext()
					Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = enumerator2.Current
					If (Not Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.IsWinRTProjectedInterface(namedTypeSymbol, binder.Compilation)) Then
						Continue While
					End If
					If (Not lookupMembersNotDefaultProperties) Then
						Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupDefaultPropertyInSingleType(instance, namedTypeSymbol, namedTypeSymbol, binder, tempResult, useSiteInfo)
					Else
						Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupWithoutInheritance(instance, namedTypeSymbol, name, arity, options, namedTypeSymbol, binder, useSiteInfo)
					End If
					If (instance.IsGood) Then
						Dim enumerator3 As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbol).Enumerator = instance.Symbols.GetEnumerator()
						While enumerator3.MoveNext()
							Dim symbol As Microsoft.CodeAnalysis.VisualBasic.Symbol = enumerator3.Current
							If (symbols.Add(symbol)) Then
								Continue While
							End If
							symbols1.Add(symbol)
						End While
					End If
					instance.Clear()
				End While
				instance.Free()
				If (result.IsGood) Then
					Dim enumerator4 As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbol).Enumerator = result.Symbols.GetEnumerator()
					While enumerator4.MoveNext()
						Dim current1 As Microsoft.CodeAnalysis.VisualBasic.Symbol = enumerator4.Current
						If (current1.Kind = SymbolKind.Field) Then
							Continue While
						End If
						symbols.Remove(current1)
						symbols1.Remove(current1)
					End While
				End If
				Try
					enumerator = symbols.GetEnumerator()
					While enumerator.MoveNext()
						Dim symbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbol = enumerator.Current
						If (symbols1.Contains(symbol1)) Then
							Continue While
						End If
						result.MergeOverloadedOrPrioritized(New SingleLookupResult(LookupResultKind.Good, symbol1, Nothing), False)
					End While
				Finally
					DirectCast(enumerator, IDisposable).Dispose()
				End Try
			End Sub

			Private Shared Function GenerateAmbiguousDefaultPropertyDiagnostic(ByVal symbols As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbol)) As AmbiguousSymbolDiagnostic
				Dim item As Microsoft.CodeAnalysis.VisualBasic.Symbol = symbols(0)
				Dim containingSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbol = item.ContainingSymbol
				Dim length As Integer = symbols.Length - 1
				Dim num As Integer = 1
				Do
					Dim symbol As Microsoft.CodeAnalysis.VisualBasic.Symbol = symbols(num)
					Dim containingSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbol = symbol.ContainingSymbol
					If (containingSymbol <> containingSymbol1) Then
						Return New AmbiguousSymbolDiagnostic(ERRID.ERR_DefaultPropertyAmbiguousAcrossInterfaces4, symbols, New [Object]() { item, containingSymbol, symbol, containingSymbol1 })
					End If
					num = num + 1
				Loop While num <= length
				Throw ExceptionUtilities.Unreachable
			End Function

			Public Shared Function GetTypeForIntrinsicAlias(ByVal possibleAlias As String) As Microsoft.CodeAnalysis.SpecialType
				Dim specialType As Microsoft.CodeAnalysis.SpecialType
				Dim keywordKind As SyntaxKind = SyntaxFacts.GetKeywordKind(possibleAlias)
				If (keywordKind <= SyntaxKind.IntegerKeyword) Then
					If (keywordKind = SyntaxKind.DateKeyword) Then
						specialType = Microsoft.CodeAnalysis.SpecialType.System_DateTime
					Else
						If (keywordKind <> SyntaxKind.IntegerKeyword) Then
							specialType = Microsoft.CodeAnalysis.SpecialType.None
							Return specialType
						End If
						specialType = Microsoft.CodeAnalysis.SpecialType.System_Int32
					End If
				ElseIf (keywordKind = SyntaxKind.LongKeyword) Then
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Int64
				ElseIf (keywordKind = SyntaxKind.ShortKeyword) Then
					specialType = Microsoft.CodeAnalysis.SpecialType.System_Int16
				Else
					Select Case keywordKind
						Case SyntaxKind.UIntegerKeyword
							specialType = Microsoft.CodeAnalysis.SpecialType.System_UInt32
							Exit Select
						Case SyntaxKind.ULongKeyword
							specialType = Microsoft.CodeAnalysis.SpecialType.System_UInt64
							Exit Select
						Case SyntaxKind.UShortKeyword
							specialType = Microsoft.CodeAnalysis.SpecialType.System_UInt16
							Exit Select
						Case Else
							specialType = Microsoft.CodeAnalysis.SpecialType.None
							Return specialType
					End Select
				End If
				Return specialType
			End Function

			Private Shared Function GetTypeParameterBaseType(ByVal typeParameter As TypeParameterSymbol) As NamedTypeSymbol
				Return typeParameter.ContainingAssembly.GetSpecialType(If(typeParameter.HasValueTypeConstraint, SpecialType.System_ValueType, SpecialType.System_Object))
			End Function

			Private Shared Function IsDerivedInterface(ByVal base As NamedTypeSymbol, ByVal derived As NamedTypeSymbol, ByVal basesBeingResolved As Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolved, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol)) As Boolean
				Dim flag As Boolean
				If (TypeSymbol.Equals(derived.OriginalDefinition, base.OriginalDefinition, TypeCompareKind.ConsiderEverything)) Then
					flag = False
				ElseIf (basesBeingResolved.InheritsBeingResolvedOpt IsNot Nothing) Then
					flag = Binder.MemberLookup.IsDerivedInterface(base, derived, basesBeingResolved, New HashSet(Of Symbol)(), useSiteInfo)
				Else
					Dim enumerator As ImmutableArray(Of NamedTypeSymbol).Enumerator = derived.AllInterfacesWithDefinitionUseSiteDiagnostics(useSiteInfo).GetEnumerator()
					While enumerator.MoveNext()
						If (Not TypeSymbol.Equals(enumerator.Current, base, TypeCompareKind.ConsiderEverything)) Then
							Continue While
						End If
						flag = True
						Return flag
					End While
					flag = False
				End If
				Return flag
			End Function

			Private Shared Function IsDerivedInterface(ByVal base As NamedTypeSymbol, ByVal derived As NamedTypeSymbol, ByVal basesBeingResolved As Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolved, ByVal verified As HashSet(Of Symbol), <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol)) As Boolean
				Dim flag As Boolean
				verified.Add(derived)
				Dim declaredInterfacesWithDefinitionUseSiteDiagnostics As ImmutableArray(Of NamedTypeSymbol) = derived.GetDeclaredInterfacesWithDefinitionUseSiteDiagnostics(basesBeingResolved, useSiteInfo)
				If (Not declaredInterfacesWithDefinitionUseSiteDiagnostics.IsDefaultOrEmpty) Then
					Dim enumerator As ImmutableArray(Of NamedTypeSymbol).Enumerator = declaredInterfacesWithDefinitionUseSiteDiagnostics.GetEnumerator()
					While enumerator.MoveNext()
						Dim current As NamedTypeSymbol = enumerator.Current
						If (Not TypeSymbol.Equals(current, base, TypeCompareKind.ConsiderEverything)) Then
							If (verified.Contains(current) OrElse Not Binder.MemberLookup.IsDerivedInterface(base, current, basesBeingResolved, verified, useSiteInfo)) Then
								Continue While
							End If
							flag = True
							Return flag
						Else
							flag = True
							Return flag
						End If
					End While
				End If
				flag = False
				Return flag
			End Function

			Private Shared Function IsWinRTProjectedInterface(ByVal iFace As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol, ByVal compilation As VisualBasicCompilation) As Boolean
				Dim wellKnownType As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = compilation.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType.System_Collections_Generic_IDictionary_KV)
				Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = compilation.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType.System_Collections_Generic_IReadOnlyDictionary_KV)
				Dim wellKnownType1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = compilation.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType.System_Collections_IList)
				Dim namedTypeSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = compilation.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType.System_Collections_ICollection)
				Dim wellKnownType2 As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = compilation.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType.System_Collections_Specialized_INotifyCollectionChanged)
				Dim namedTypeSymbol2 As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = compilation.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType.System_ComponentModel_INotifyPropertyChanged)
				Dim originalDefinition As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = iFace.OriginalDefinition
				Dim specialType As Microsoft.CodeAnalysis.SpecialType = originalDefinition.SpecialType
				If (specialType = Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_IEnumerable_T OrElse specialType = Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_IList_T OrElse specialType = Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_ICollection_T OrElse TypeSymbol.Equals(originalDefinition, wellKnownType, TypeCompareKind.ConsiderEverything) OrElse specialType = Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_IReadOnlyList_T OrElse specialType = Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_IReadOnlyCollection_T OrElse TypeSymbol.Equals(originalDefinition, namedTypeSymbol, TypeCompareKind.ConsiderEverything) OrElse specialType = Microsoft.CodeAnalysis.SpecialType.System_Collections_IEnumerable OrElse TypeSymbol.Equals(originalDefinition, wellKnownType1, TypeCompareKind.ConsiderEverything) OrElse TypeSymbol.Equals(originalDefinition, namedTypeSymbol1, TypeCompareKind.ConsiderEverything) OrElse TypeSymbol.Equals(originalDefinition, wellKnownType2, TypeCompareKind.ConsiderEverything)) Then
					Return True
				End If
				Return TypeSymbol.Equals(originalDefinition, namedTypeSymbol2, TypeCompareKind.ConsiderEverything)
			End Function

			Public Shared Sub Lookup(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal container As NamespaceOrTypeSymbol, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				If (container.IsNamespace) Then
					Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.Lookup(lookupResult, DirectCast(container, NamespaceSymbol), name, arity, options, binder, useSiteInfo)
					Return
				End If
				Dim instance As Microsoft.CodeAnalysis.VisualBasic.LookupResult = Microsoft.CodeAnalysis.VisualBasic.LookupResult.GetInstance()
				Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.Lookup(lookupResult, DirectCast(container, TypeSymbol), name, arity, options, binder, instance, useSiteInfo)
				instance.Free()
			End Sub

			Public Shared Sub Lookup(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal container As NamespaceSymbol, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupImmediate(lookupResult, container, name, arity, options, binder, useSiteInfo)
				If (Not lookupResult.StopFurtherLookup) Then
					Dim instance As Microsoft.CodeAnalysis.VisualBasic.LookupResult = Microsoft.CodeAnalysis.VisualBasic.LookupResult.GetInstance()
					Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupInModules(instance, container, name, arity, options, binder, useSiteInfo)
					lookupResult.MergeAmbiguous(instance, Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.s_ambiguousInModuleError)
					instance.Free()
				End If
			End Sub

			Friend Shared Sub Lookup(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal type As TypeSymbol, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal tempResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				Select Case type.TypeKind
					Case Microsoft.CodeAnalysis.TypeKind.Array
					Case Microsoft.CodeAnalysis.TypeKind.[Class]
					Case Microsoft.CodeAnalysis.TypeKind.[Delegate]
					Case Microsoft.CodeAnalysis.TypeKind.[Enum]
					Case Microsoft.CodeAnalysis.TypeKind.[Module]
					Case Microsoft.CodeAnalysis.TypeKind.Struct
						Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupInClass(lookupResult, type, name, arity, options, type, binder, tempResult, useSiteInfo)
						Return
					Case Microsoft.CodeAnalysis.TypeKind.Dynamic
					Case Microsoft.CodeAnalysis.TypeKind.Pointer
						Throw ExceptionUtilities.UnexpectedValue(type.TypeKind)
					Case Microsoft.CodeAnalysis.TypeKind.[Error]
						Return
					Case Microsoft.CodeAnalysis.TypeKind.[Interface]
						Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupInInterface(lookupResult, DirectCast(type, NamedTypeSymbol), name, arity, options, binder, tempResult, useSiteInfo)
						Return
					Case Microsoft.CodeAnalysis.TypeKind.TypeParameter
						Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupInTypeParameter(lookupResult, DirectCast(type, TypeParameterSymbol), name, arity, options, binder, tempResult, useSiteInfo)
						Return
					Case Microsoft.CodeAnalysis.TypeKind.Submission
						Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupInSubmissions(lookupResult, type, name, arity, options, binder, useSiteInfo)
						Return
					Case Else
						Throw ExceptionUtilities.UnexpectedValue(type.TypeKind)
				End Select
			End Sub

			Public Shared Sub LookupDefaultProperty(ByVal result As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal container As TypeSymbol, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				Dim typeKind As Microsoft.CodeAnalysis.TypeKind = container.TypeKind
				If (typeKind <> Microsoft.CodeAnalysis.TypeKind.[Class]) Then
					Select Case typeKind
						Case Microsoft.CodeAnalysis.TypeKind.[Interface]
							Dim instance As Microsoft.CodeAnalysis.VisualBasic.LookupResult = Microsoft.CodeAnalysis.VisualBasic.LookupResult.GetInstance()
							Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupDefaultPropertyInInterface(result, DirectCast(container, NamedTypeSymbol), binder, instance, useSiteInfo)
							instance.Free()
							Return
						Case Microsoft.CodeAnalysis.TypeKind.[Module]
						Case Microsoft.CodeAnalysis.TypeKind.Struct
							Exit Select
						Case Microsoft.CodeAnalysis.TypeKind.Pointer
							Return
						Case Microsoft.CodeAnalysis.TypeKind.TypeParameter
							Dim lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult = Microsoft.CodeAnalysis.VisualBasic.LookupResult.GetInstance()
							Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupDefaultPropertyInTypeParameter(result, DirectCast(container, TypeParameterSymbol), binder, lookupResult, useSiteInfo)
							lookupResult.Free()
							Return
						Case Else
							Return
					End Select
				End If
				Dim instance1 As Microsoft.CodeAnalysis.VisualBasic.LookupResult = Microsoft.CodeAnalysis.VisualBasic.LookupResult.GetInstance()
				Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupDefaultPropertyInClass(result, DirectCast(container, NamedTypeSymbol), binder, instance1, useSiteInfo)
				instance1.Free()
			End Sub

			Private Shared Sub LookupDefaultPropertyInBaseInterface(ByVal result As LookupResult, ByVal type As NamedTypeSymbol, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal tempResult As LookupResult, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				If (Not type.IsErrorType()) Then
					Dim instance As LookupResult = LookupResult.GetInstance()
					Try
						Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupDefaultPropertyInInterface(instance, type, binder, tempResult, useSiteInfo)
						If (instance.HasSymbol) Then
							If (instance.HasDiagnostic OrElse Not result.HasSymbol) Then
								result.SetFrom(instance)
							Else
								Dim item As Microsoft.CodeAnalysis.VisualBasic.Symbol = result.Symbols(0)
								Dim symbol As Microsoft.CodeAnalysis.VisualBasic.Symbol = instance.Symbols(0)
								If (item.ContainingSymbol <> symbol.ContainingSymbol) Then
									result.MergeAmbiguous(instance, New Func(Of ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbol), AmbiguousSymbolDiagnostic)(AddressOf Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.GenerateAmbiguousDefaultPropertyDiagnostic))
								End If
							End If
						End If
					Finally
						instance.Free()
					End Try
				End If
			End Sub

			Private Shared Sub LookupDefaultPropertyInClass(ByVal result As LookupResult, ByVal type As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal tempResult As LookupResult, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = type
				While type IsNot Nothing AndAlso Not Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupDefaultPropertyInSingleType(result, type, namedTypeSymbol, binder, tempResult, useSiteInfo)
					If (type.ShouldAddWinRTMembers) Then
						Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.FindWinRTMembers(result, type, binder, tempResult, useSiteInfo, False, Nothing, -1, LookupOptions.[Default])
						If (result.IsGood) Then
							Exit While
						End If
					End If
					type = type.BaseTypeWithDefinitionUseSiteDiagnostics(useSiteInfo)
				End While
			End Sub

			Private Shared Sub LookupDefaultPropertyInInterface(ByVal result As LookupResult, ByVal [interface] As NamedTypeSymbol, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal tempResult As LookupResult, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				If (Not Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupDefaultPropertyInSingleType(result, [interface], [interface], binder, tempResult, useSiteInfo)) Then
					Dim enumerator As ImmutableArray(Of NamedTypeSymbol).Enumerator = [interface].InterfacesNoUseSiteDiagnostics.GetEnumerator()
					Do
						If (Not enumerator.MoveNext()) Then
							Exit Do
						End If
						Dim current As NamedTypeSymbol = enumerator.Current
						current.OriginalDefinition.AddUseSiteInfo(useSiteInfo)
						Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupDefaultPropertyInBaseInterface(result, current, binder, tempResult, useSiteInfo)
					Loop While Not result.HasDiagnostic
				End If
			End Sub

			Private Shared Function LookupDefaultPropertyInSingleType(ByVal result As LookupResult, ByVal type As NamedTypeSymbol, ByVal accessThroughType As TypeSymbol, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal tempResult As LookupResult, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol)) As Boolean
				Dim hasSymbol As Boolean
				Dim defaultPropertyName As String = type.DefaultPropertyName
				If (Not [String].IsNullOrEmpty(defaultPropertyName)) Then
					Dim typeKind As Microsoft.CodeAnalysis.TypeKind = type.TypeKind
					If (typeKind <> Microsoft.CodeAnalysis.TypeKind.[Class]) Then
						Select Case typeKind
							Case Microsoft.CodeAnalysis.TypeKind.[Interface]
								Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupInInterface(result, type, defaultPropertyName, 0, LookupOptions.[Default], binder, tempResult, useSiteInfo)
								GoTo Label0
							Case Microsoft.CodeAnalysis.TypeKind.[Module]
							Case Microsoft.CodeAnalysis.TypeKind.Struct
								Exit Select
							Case Microsoft.CodeAnalysis.TypeKind.TypeParameter
								Throw ExceptionUtilities.UnexpectedValue(type.TypeKind)
							Case Else
								GoTo Label0
						End Select
					End If
					Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupInClass(result, type, defaultPropertyName, 0, LookupOptions.[Default], accessThroughType, binder, tempResult, useSiteInfo)
				Label0:
					hasSymbol = result.HasSymbol
				Else
					hasSymbol = False
				End If
				Return hasSymbol
			End Function

			Private Shared Sub LookupDefaultPropertyInTypeParameter(ByVal result As LookupResult, ByVal typeParameter As TypeParameterSymbol, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal tempResult As LookupResult, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				Dim enumerator As Queue(Of Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo).Enumerator = New Queue(Of Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo).Enumerator()
				Dim classConstraint As NamedTypeSymbol = typeParameter.GetClassConstraint(useSiteInfo)
				If (classConstraint IsNot Nothing) Then
					Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupDefaultPropertyInClass(result, classConstraint, binder, tempResult, useSiteInfo)
					If (Not result.IsClear) Then
						Return
					End If
				End If
				Dim interfaceInfos As Queue(Of Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo) = Nothing
				Dim interfaceInfos1 As HashSet(Of Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo) = Nothing
				Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddInterfaceConstraints(typeParameter, interfaceInfos, interfaceInfos1, useSiteInfo)
				If (interfaceInfos IsNot Nothing) Then
					Try
						enumerator = interfaceInfos.GetEnumerator()
						While enumerator.MoveNext()
							Dim current As Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo = enumerator.Current
							Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupDefaultPropertyInBaseInterface(result, current.InterfaceType, binder, tempResult, useSiteInfo)
							If (Not result.HasDiagnostic) Then
								Continue While
							End If
							Return
						End While
					Finally
						DirectCast(enumerator, IDisposable).Dispose()
					End Try
				End If
			End Sub

			Public Shared Sub LookupForExtensionMethods(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal container As TypeSymbol, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				' 
				' Current member / type: System.Void Microsoft.CodeAnalysis.VisualBasic.Binder/MemberLookup::LookupForExtensionMethods(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.CompoundUseSiteInfo`1<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&)
				' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
				' 
				' Product version: 2019.1.118.0
				' Exception in: System.Void LookupForExtensionMethods(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.CompoundUseSiteInfo<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&)
				' 
				' La référence d'objet n'est pas définie à une instance d'un objet.
				'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
				'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
				'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
				'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
				'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
				'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
				'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
				'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
				' 
				' mailto: JustDecompilePublicFeedback@telerik.com

			End Sub

			Private Shared Sub LookupForExtensionMethodsIfNeedTo(ByVal result As LookupResult, ByVal container As TypeSymbol, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal tempResult As LookupResult, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				' 
				' Current member / type: System.Void Microsoft.CodeAnalysis.VisualBasic.Binder/MemberLookup::LookupForExtensionMethodsIfNeedTo(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.CompoundUseSiteInfo`1<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&)
				' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
				' 
				' Product version: 2019.1.118.0
				' Exception in: System.Void LookupForExtensionMethodsIfNeedTo(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.CompoundUseSiteInfo<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&)
				' 
				' La référence d'objet n'est pas définie à une instance d'un objet.
				'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
				'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
				'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
				'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
				'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
				'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
				'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
				'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
				' 
				' mailto: JustDecompilePublicFeedback@telerik.com

			End Sub

			Public Shared Sub LookupImmediate(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal container As NamespaceSymbol, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				' 
				' Current member / type: System.Void Microsoft.CodeAnalysis.VisualBasic.Binder/MemberLookup::LookupImmediate(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.CompoundUseSiteInfo`1<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&)
				' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
				' 
				' Product version: 2019.1.118.0
				' Exception in: System.Void LookupImmediate(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.CompoundUseSiteInfo<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&)
				' 
				' La référence d'objet n'est pas définie à une instance d'un objet.
				'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
				'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
				'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
				'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
				'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
				'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
				'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
				'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
				' 
				' mailto: JustDecompilePublicFeedback@telerik.com

			End Sub

			Private Shared Sub LookupInClass(ByVal result As LookupResult, ByVal container As TypeSymbol, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, ByVal accessThroughType As TypeSymbol, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal tempResult As LookupResult, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				' 
				' Current member / type: System.Void Microsoft.CodeAnalysis.VisualBasic.Binder/MemberLookup::LookupInClass(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.CompoundUseSiteInfo`1<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&)
				' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
				' 
				' Product version: 2019.1.118.0
				' Exception in: System.Void LookupInClass(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.CompoundUseSiteInfo<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&)
				' 
				' La référence d'objet n'est pas définie à une instance d'un objet.
				'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
				'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
				'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
				'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
				'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
				'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
				'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
				'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
				' 
				' mailto: JustDecompilePublicFeedback@telerik.com

			End Sub

			Private Shared Sub LookupInInterface(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal container As NamedTypeSymbol, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal tempResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				' 
				' Current member / type: System.Void Microsoft.CodeAnalysis.VisualBasic.Binder/MemberLookup::LookupInInterface(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.CompoundUseSiteInfo`1<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&)
				' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
				' 
				' Product version: 2019.1.118.0
				' Exception in: System.Void LookupInInterface(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.CompoundUseSiteInfo<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&)
				' 
				' La référence d'objet n'est pas définie à une instance d'un objet.
				'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
				'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
				'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
				'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
				'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
				'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
				'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
				'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
				' 
				' mailto: JustDecompilePublicFeedback@telerik.com

			End Sub

			Private Shared Sub LookupInInterfaces(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal container As TypeSymbol, ByVal lookIn As Queue(Of Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo), ByVal processed As HashSet(Of Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo), ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal methodsOnly As Boolean, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				' 
				' Current member / type: System.Void Microsoft.CodeAnalysis.VisualBasic.Binder/MemberLookup::LookupInInterfaces(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Generic.Queue`1<Microsoft.CodeAnalysis.VisualBasic.Binder/MemberLookup/InterfaceInfo>,System.Collections.Generic.HashSet`1<Microsoft.CodeAnalysis.VisualBasic.Binder/MemberLookup/InterfaceInfo>,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Boolean,Microsoft.CodeAnalysis.CompoundUseSiteInfo`1<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&)
				' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
				' 
				' Product version: 2019.1.118.0
				' Exception in: System.Void LookupInInterfaces(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.Collections.Generic.Queue<Microsoft.CodeAnalysis.VisualBasic.Binder/MemberLookup/InterfaceInfo>,System.Collections.Generic.HashSet<Microsoft.CodeAnalysis.VisualBasic.Binder/MemberLookup/InterfaceInfo>,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,System.Boolean,Microsoft.CodeAnalysis.CompoundUseSiteInfo<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&)
				' 
				' La référence d'objet n'est pas définie à une instance d'un objet.
				'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
				'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
				'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
				'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
				'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
				'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
				'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
				'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
				' 
				' mailto: JustDecompilePublicFeedback@telerik.com

			End Sub

			Public Shared Sub LookupInModules(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal container As NamespaceSymbol, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				Dim flag As Boolean = True
				Dim sourceModule As ModuleSymbol = binder.Compilation.SourceModule
				options = options Or LookupOptions.IgnoreExtensionMethods Or LookupOptions.NoBaseClassLookup
				Dim instance As Microsoft.CodeAnalysis.VisualBasic.LookupResult = Nothing
				Dim instance1 As Microsoft.CodeAnalysis.VisualBasic.LookupResult = Microsoft.CodeAnalysis.VisualBasic.LookupResult.GetInstance()
				Dim enumerator As ImmutableArray(Of NamedTypeSymbol).Enumerator = container.GetModuleMembers().GetEnumerator()
				While enumerator.MoveNext()
					Dim current As NamedTypeSymbol = enumerator.Current
					If (Not flag) Then
						If (instance IsNot Nothing) Then
							instance.Clear()
						Else
							instance = Microsoft.CodeAnalysis.VisualBasic.LookupResult.GetInstance()
						End If
						Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.Lookup(instance, current, name, arity, options, binder, instance1, useSiteInfo)
						If (instance.StopFurtherLookup AndAlso instance.Symbols.Count > 0 AndAlso lookupResult.StopFurtherLookup AndAlso lookupResult.Symbols.Count > 0) Then
							Dim containingModule As Boolean = CObj(lookupResult.Symbols(0).ContainingModule) = CObj(sourceModule)
							If (CObj(instance.Symbols(0).ContainingModule) = CObj(sourceModule)) Then
								If (Not containingModule) Then
									lookupResult.SetFrom(instance)
									Continue While
								End If
							ElseIf (containingModule) Then
								Continue While
							End If
						End If
						lookupResult.MergeAmbiguous(instance, Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.s_ambiguousInModuleError)
					Else
						Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.Lookup(lookupResult, current, name, arity, options, binder, instance1, useSiteInfo)
						flag = False
					End If
				End While
				instance1.Free()
				If (instance IsNot Nothing) Then
					instance.Free()
				End If
			End Sub

			Private Shared Sub LookupInSubmissions(ByVal result As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal submissionClass As TypeSymbol, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				Dim instance As Microsoft.CodeAnalysis.VisualBasic.LookupResult = Microsoft.CodeAnalysis.VisualBasic.LookupResult.GetInstance()
				Dim lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult = Microsoft.CodeAnalysis.VisualBasic.LookupResult.GetInstance()
				Dim nullable As Nullable(Of SymbolKind) = Nothing
				Dim compilation As VisualBasicCompilation = binder.Compilation
				Do
					instance.Clear()
					If (compilation.ScriptClass IsNot Nothing) Then
						Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupWithoutInheritance(instance, compilation.ScriptClass, name, arity, options, submissionClass, binder, useSiteInfo)
					End If
					If (nullable.HasValue) Then
						If (instance.HasSymbol AndAlso instance.Symbols.First().Kind <> nullable.Value) Then
							Exit Do
						End If
						If (instance.IsGoodOrAmbiguous) Then
							result.MergeOverloadedOrPrioritized(instance, False)
						End If
					ElseIf (instance.IsGoodOrAmbiguous) Then
						result.MergeOverloadedOrPrioritized(instance, False)
						Dim symbol As Microsoft.CodeAnalysis.VisualBasic.Symbol = instance.Symbols.First()
						If (Not symbol.IsOverloadable()) Then
							Exit Do
						End If
						options = options And (LookupOptions.LabelsOnly Or LookupOptions.MustBeInstance Or LookupOptions.MustNotBeInstance Or LookupOptions.MustNotBeReturnValueVariable Or LookupOptions.NoBaseClassLookup Or LookupOptions.IgnoreAccessibility Or LookupOptions.AllMethodsOfAnyArity Or LookupOptions.IgnoreExtensionMethods Or LookupOptions.EagerlyLookupExtensionMethods Or LookupOptions.MethodsOnly Or LookupOptions.UseBaseReferenceAccessibility Or LookupOptions.MustNotBeLocalOrParameter Or LookupOptions.EventsOnly Or LookupOptions.NoSystemObjectLookupForInterfaces Or LookupOptions.AllowIntrinsicAliases)
						nullable = New Nullable(Of SymbolKind)(symbol.Kind)
					Else
						lookupResult.MergePrioritized(instance)
						compilation = compilation.PreviousSubmission
						Continue Do
					End If
					compilation = compilation.PreviousSubmission
				Loop While compilation IsNot Nothing
				If (Not result.HasSymbol) Then
					result.SetFrom(lookupResult)
				End If
				instance.Free()
				lookupResult.Free()
			End Sub

			Private Shared Sub LookupInTypeParameter(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal typeParameter As TypeParameterSymbol, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal tempResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				Dim flag As Boolean = Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.CheckAndClearMethodsOnlyOption(options)
				Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupInTypeParameterNoExtensionMethods(lookupResult, typeParameter, name, arity, options, binder, tempResult, useSiteInfo)
				Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.ClearLookupResultIfNotMethods(flag, lookupResult)
				Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupForExtensionMethodsIfNeedTo(lookupResult, typeParameter, name, arity, options, binder, tempResult, useSiteInfo)
			End Sub

			Private Shared Sub LookupInTypeParameterNoExtensionMethods(ByVal result As LookupResult, ByVal typeParameter As TypeParameterSymbol, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal tempResult As LookupResult, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				options = options Or LookupOptions.IgnoreExtensionMethods
				Dim classConstraint As NamedTypeSymbol = typeParameter.GetClassConstraint(useSiteInfo)
				If (classConstraint IsNot Nothing) Then
					Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupInClass(result, classConstraint, name, arity, options, classConstraint, binder, tempResult, useSiteInfo)
					If (result.StopFurtherLookup) Then
						Return
					End If
				End If
				Dim interfaceInfos As Queue(Of Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo) = Nothing
				Dim interfaceInfos1 As HashSet(Of Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.InterfaceInfo) = Nothing
				Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.AddInterfaceConstraints(typeParameter, interfaceInfos, interfaceInfos1, useSiteInfo)
				If (interfaceInfos IsNot Nothing) Then
					Dim instance As LookupResult = LookupResult.GetInstance()
					Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupInInterfaces(instance, typeParameter, interfaceInfos, interfaceInfos1, name, arity, options, binder, False, useSiteInfo)
					result.MergePrioritized(instance)
					instance.Free()
					If (Not result.IsClear) Then
						Return
					End If
				End If
				If (classConstraint Is Nothing) Then
					Dim typeParameterBaseType As NamedTypeSymbol = Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.GetTypeParameterBaseType(typeParameter)
					Microsoft.CodeAnalysis.VisualBasic.Binder.MemberLookup.LookupInClass(result, typeParameterBaseType, name, arity, options, typeParameterBaseType, binder, tempResult, useSiteInfo)
				End If
			End Sub

			Private Shared Sub LookupWithoutInheritance(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal container As TypeSymbol, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, ByVal accessThroughType As TypeSymbol, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				' 
				' Current member / type: System.Void Microsoft.CodeAnalysis.VisualBasic.Binder/MemberLookup::LookupWithoutInheritance(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.CompoundUseSiteInfo`1<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&)
				' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
				' 
				' Product version: 2019.1.118.0
				' Exception in: System.Void LookupWithoutInheritance(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.CompoundUseSiteInfo<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&)
				' 
				' La référence d'objet n'est pas définie à une instance d'un objet.
				'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
				'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
				'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
				'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
				'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
				'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
				'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
				'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
				' 
				' mailto: JustDecompilePublicFeedback@telerik.com

			End Sub

			Private Shared Sub MergeInterfaceLookupResults(ByVal knownResult As LookupResult, ByVal newResult As LookupResult, ByVal BasesBeingResolved As Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolved, ByVal leaveEventsOnly As Nullable(Of Boolean), <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				Dim symbols As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbol) = knownResult.Symbols
				Dim symbols1 As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbol) = newResult.Symbols
				Dim containingType As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = symbols1.First().ContainingType
				Dim count As Integer = symbols.Count - 1
				Dim num As Integer = 0
				Do
					Dim item As Microsoft.CodeAnalysis.VisualBasic.Symbol = symbols(num)
					If (item IsNot Nothing) Then
						Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = item.ContainingType
						Dim count1 As Integer = symbols1.Count - 1
						For i As Integer = 0 To count1
							Dim symbol As Microsoft.CodeAnalysis.VisualBasic.Symbol = symbols1(i)
							If (symbol IsNot Nothing) Then
								If (leaveEventsOnly.HasValue AndAlso symbol.Kind = SymbolKind.[Event] <> leaveEventsOnly.Value) Then
									symbols1(i) = Nothing
								ElseIf (item <> symbol) Then
									Dim flag As Boolean = Not LookupResult.CanOverload(item, symbol)
									If (Binder.MemberLookup.IsDerivedInterface(containingType, namedTypeSymbol, BasesBeingResolved, useSiteInfo)) Then
										If (item.IsShadows() OrElse flag) Then
											newResult.Clear()
											Return
										End If
									ElseIf (Binder.MemberLookup.IsDerivedInterface(namedTypeSymbol, containingType, BasesBeingResolved, useSiteInfo) AndAlso (symbol.IsShadows() OrElse flag)) Then
										symbols(num) = Nothing
										Dim num1 As Integer = symbols.Count - 1
										For j As Integer = num + 1 To num1
											Dim item1 As Microsoft.CodeAnalysis.VisualBasic.Symbol = symbols(j)
											If (item1 IsNot Nothing AndAlso TypeSymbol.Equals(item1.ContainingType, namedTypeSymbol, TypeCompareKind.ConsiderEverything)) Then
												symbols(j) = Nothing
											End If
										Next

									End If
								Else
									symbols1(i) = Nothing
								End If
							End If
						Next

					End If
					num = num + 1
				Loop While num <= count
				Binder.MemberLookup.CompactAndAppend(symbols, symbols1)
				newResult.Clear()
			End Sub

			Private Shared Sub MergeInternalXmlHelperValueIfNecessary(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal container As TypeSymbol, ByVal name As String, ByVal arity As Integer, ByVal options As LookupOptions, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
				' 
				' Current member / type: System.Void Microsoft.CodeAnalysis.VisualBasic.Binder/MemberLookup::MergeInternalXmlHelperValueIfNecessary(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.CompoundUseSiteInfo`1<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&)
				' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
				' 
				' Product version: 2019.1.118.0
				' Exception in: System.Void MergeInternalXmlHelperValueIfNecessary(Microsoft.CodeAnalysis.VisualBasic.LookupResult,Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.VisualBasic.LookupOptions,Microsoft.CodeAnalysis.VisualBasic.Binder,Microsoft.CodeAnalysis.CompoundUseSiteInfo<Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol>&)
				' 
				' La référence d'objet n'est pas définie à une instance d'un objet.
				'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
				'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
				'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
				'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
				'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
				'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
				'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
				'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
				' 
				' mailto: JustDecompilePublicFeedback@telerik.com

			End Sub

			Private Shared Function ShouldLookupExtensionMethods(ByVal options As LookupOptions, ByVal container As TypeSymbol) As Boolean
				If (Not options.ShouldLookupExtensionMethods() OrElse container.IsObjectType() OrElse container.IsShared) Then
					Return False
				End If
				Return Not container.IsModuleType()
			End Function

			Private Structure InterfaceInfo
				Implements IEquatable(Of Binder.MemberLookup.InterfaceInfo)
				Public ReadOnly InterfaceType As NamedTypeSymbol

				Public ReadOnly InComInterfaceContext As Boolean

				Public ReadOnly DescendantDefinitions As ImmutableHashSet(Of NamedTypeSymbol)

				Public Sub New(ByVal interfaceType As NamedTypeSymbol, ByVal inComInterfaceContext As Boolean, Optional ByVal descendantDefinitions As ImmutableHashSet(Of NamedTypeSymbol) = Nothing)
					Me = New Binder.MemberLookup.InterfaceInfo() With
					{
						.InterfaceType = interfaceType,
						.InComInterfaceContext = inComInterfaceContext,
						.DescendantDefinitions = descendantDefinitions
					}
				End Sub

				Public Overrides Function Equals(ByVal obj As Object) As Boolean Implements IEquatable(Of Binder.MemberLookup.InterfaceInfo).Equals
					If (Not TypeOf obj Is Binder.MemberLookup.InterfaceInfo) Then
						Return False
					End If
					Return Me.ExplicitEquals(DirectCast(obj, Binder.MemberLookup.InterfaceInfo))
				End Function

				Public Function ExplicitEquals(ByVal other As Binder.MemberLookup.InterfaceInfo) As Boolean Implements IEquatable(Of Binder.MemberLookup.InterfaceInfo).Equals
					If (Not Me.InterfaceType.Equals(other.InterfaceType)) Then
						Return False
					End If
					Return Me.InComInterfaceContext = other.InComInterfaceContext
				End Function

				Public Overrides Function GetHashCode() As Integer
					Return Hash.Combine(Me.InterfaceType.GetHashCode(), Me.InComInterfaceContext.GetHashCode())
				End Function
			End Structure

			Public Delegate Sub WinRTLookupDelegate(ByVal iface As NamedTypeSymbol, ByVal binder As Binder, ByVal result As LookupResult, <InAttribute> <Out> ByRef useSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol))
		End Class

		<Flags>
		Public Enum ModifiedIdentifierTypeDecoderContext
			None = 0
			LambdaType = 2
			LocalType = 4
			FieldType = 8
			LocalOrFieldType = 12
			ParameterType = 16
			LambdaParameterType = 18
			QueryRangeVariableType = 32
			StaticLocalType = 64
		End Enum

		Private Class OptionStrictOffBinder
			Inherits Binder
			Public Overrides ReadOnly Property OptionStrict As Microsoft.CodeAnalysis.VisualBasic.OptionStrict
				Get
					Return Microsoft.CodeAnalysis.VisualBasic.OptionStrict.Off
				End Get
			End Property

			Public Sub New(ByVal containingBinder As Binder)
				MyBase.New(containingBinder)
			End Sub
		End Class

		Friend NotInheritable Class ProcessedFieldOrPropertyInitializers
			Friend ReadOnly BoundInitializers As ImmutableArray(Of BoundInitializer)

			Friend ReadOnly HasAnyErrors As Boolean

			Private _loweredInitializers As ImmutableArray(Of BoundStatement)

			Friend ReadOnly Shared Empty As Binder.ProcessedFieldOrPropertyInitializers

			Private _analyzed As Boolean

			Friend Property InitializerStatements As ImmutableArray(Of BoundStatement)
				Get
					Return Me._loweredInitializers
				End Get
				Set(ByVal value As ImmutableArray(Of BoundStatement))
					Me._loweredInitializers = value
				End Set
			End Property

			Shared Sub New()
				Binder.ProcessedFieldOrPropertyInitializers.Empty = New Binder.ProcessedFieldOrPropertyInitializers()
			End Sub

			Private Sub New()
				MyBase.New()
				Me._analyzed = False
				Me.BoundInitializers = ImmutableArray(Of BoundInitializer).Empty
				Me.HasAnyErrors = False
				Me._loweredInitializers = ImmutableArray(Of BoundStatement).Empty
			End Sub

			Friend Sub New(ByVal boundInitializers As ImmutableArray(Of BoundInitializer))
				MyBase.New()
				Dim hasErrors As Func(Of BoundInitializer, Boolean)
				Me._analyzed = False
				Me.BoundInitializers = boundInitializers
				Dim boundInitializers1 As ImmutableArray(Of BoundInitializer) = boundInitializers
				If (Binder.ProcessedFieldOrPropertyInitializers._Closure$__.$I9-0 Is Nothing) Then
					hasErrors = Function(i As BoundInitializer) i.HasErrors
					Binder.ProcessedFieldOrPropertyInitializers._Closure$__.$I9-0 = hasErrors
				Else
					hasErrors = Binder.ProcessedFieldOrPropertyInitializers._Closure$__.$I9-0
				End If
				Me.HasAnyErrors = boundInitializers1.Any(hasErrors)
			End Sub

			Friend Sub EnsureInitializersAnalyzed(ByVal method As MethodSymbol, ByVal diagnostics As DiagnosticBag)
				If (Not Me._analyzed) Then
					If (Not Me.BoundInitializers.IsEmpty) Then
						Dim syntax As SyntaxNode = Me.BoundInitializers(0).Syntax
						Dim statementSyntaxes As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax) = New SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)()
						Dim boundBlock As Microsoft.CodeAnalysis.VisualBasic.BoundBlock = New Microsoft.CodeAnalysis.VisualBasic.BoundBlock(syntax, statementSyntaxes, ImmutableArray(Of LocalSymbol).Empty, StaticCast(Of BoundStatement).From(Of BoundInitializer)(Me.BoundInitializers), False)
						Analyzer.AnalyzeMethodBody(method, boundBlock, diagnostics)
						DiagnosticsPass.IssueDiagnostics(boundBlock, diagnostics, method)
					End If
					Me._analyzed = True
				End If
			End Sub
		End Class

		Private NotInheritable Class QueryLambdaBinder
			Inherits BlockBaseBinder(Of RangeVariableSymbol)
			Private ReadOnly _lambdaSymbol As LambdaSymbol

			Private ReadOnly _rangeVariables As ImmutableArray(Of RangeVariableSymbol)

			Public Overrides ReadOnly Property AdditionalContainingMembers As ImmutableArray(Of Symbol)
				Get
					Return ImmutableArray(Of Symbol).Empty
				End Get
			End Property

			Public Overrides ReadOnly Property ContainingMember As Symbol
				Get
					Return Me._lambdaSymbol
				End Get
			End Property

			Public Overrides ReadOnly Property IsInQuery As Boolean
				Get
					Return True
				End Get
			End Property

			Public ReadOnly Property LambdaSymbol As LambdaSymbol
				Get
					Return Me._lambdaSymbol
				End Get
			End Property

			Friend Overrides ReadOnly Property Locals As ImmutableArray(Of RangeVariableSymbol)
				Get
					Return Me._rangeVariables
				End Get
			End Property

			Public ReadOnly Property RangeVariables As ImmutableArray(Of RangeVariableSymbol)
				Get
					Return Me._rangeVariables
				End Get
			End Property

			Public Sub New(ByVal lambdaSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.LambdaSymbol, ByVal rangeVariables As ImmutableArray(Of RangeVariableSymbol))
				MyBase.New(lambdaSymbol.ContainingBinder)
				Me._lambdaSymbol = lambdaSymbol
				Me._rangeVariables = rangeVariables
			End Sub

			Public Function BindAbsorbingJoinSelector(ByVal absorbNextOperator As Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax, ByVal operatorsEnumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator, ByVal leftRangeVariables As ImmutableArray(Of RangeVariableSymbol), ByVal rightRangeVariables As ImmutableArray(Of RangeVariableSymbol), <Out> ByRef joinSelectorDeclaredRangeVariables As ImmutableArray(Of RangeVariableSymbol), <Out> ByRef group As BoundQueryClauseBase, <Out> ByRef intoBinder As Binder.IntoClauseDisallowGroupReferenceBinder, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
				group = Nothing
				intoBinder = Nothing
				Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = absorbNextOperator.Kind()
				If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LetClause) Then
					Dim variables As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax) = DirectCast(absorbNextOperator, Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax).Variables
					boundExpression = Me.BindLetClauseVariableSelector(variables.First(), operatorsEnumerator, joinSelectorDeclaredRangeVariables, diagnostics)
				ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AggregateClause) Then
					Dim aggregateClauseSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax = DirectCast(absorbNextOperator, Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax)
					boundExpression = Me.BindAggregateClauseFirstSelector(aggregateClauseSyntax, operatorsEnumerator, leftRangeVariables, rightRangeVariables, joinSelectorDeclaredRangeVariables, group, intoBinder, diagnostics)
				Else
					If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SelectClause) Then
						Throw ExceptionUtilities.UnexpectedValue(absorbNextOperator.Kind())
					End If
					boundExpression = Me.BindSelectClauseSelector(DirectCast(absorbNextOperator, Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax), operatorsEnumerator, joinSelectorDeclaredRangeVariables, diagnostics)
				End If
				Return boundExpression
			End Function

			Public Function BindAggregateClauseFirstSelector(ByVal aggregate As Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax, ByVal operatorsEnumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator, ByVal rangeVariablesPart1 As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol), ByVal rangeVariablesPart2 As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol), <Out> ByRef declaredRangeVariables As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol), <Out> ByRef group As BoundQueryClauseBase, <Out> ByRef intoBinder As Binder.IntoClauseDisallowGroupReferenceBinder, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
				Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
				Dim empty As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)
				Dim boundExpression2 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
				Dim rangeVariableSymbols As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)
				Dim item As BoundLambdaParameterSymbol
				Dim parameters As ImmutableArray(Of ParameterSymbol)
				Dim enumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator = aggregate.AdditionalQueryOperators.GetEnumerator()
				group = MyBase.BindCollectionRangeVariables(aggregate, Nothing, aggregate.Variables, enumerator, diagnostics)
				group = MyBase.BindSubsequentQueryOperators(group, enumerator, diagnostics)
				Dim aggregationVariables As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax) = aggregate.AggregationVariables
				Dim rangeVariableSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol = Nothing
				Dim count As Integer = aggregationVariables.Count
				If (count = 0) Then
					declaredRangeVariables = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)(Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol.CreateForErrorRecovery(Me, aggregate, ErrorTypeSymbol.UnknownResultType))
					boundExpression = Binder.BadExpression(aggregate, group, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
					intoBinder = New Binder.IntoClauseDisallowGroupReferenceBinder(New Binder.QueryLambdaBinder(Me._lambdaSymbol, ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol).Empty), group, group.RangeVariables, group.CompoundVariableType, Microsoft.CodeAnalysis.ImmutableArrayExtensions.Concat(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)(Me._rangeVariables, group.RangeVariables))
				ElseIf (count = 1) Then
					intoBinder = New Binder.IntoClauseDisallowGroupReferenceBinder(New Binder.QueryLambdaBinder(Me._lambdaSymbol, ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol).Empty), group, group.RangeVariables, group.CompoundVariableType, Microsoft.CodeAnalysis.ImmutableArrayExtensions.Concat(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)(Me._rangeVariables, group.RangeVariables))
					If (rangeVariablesPart1.Length > 0) Then
						parameters = Me._lambdaSymbol.Parameters
						item = DirectCast(parameters(0), BoundLambdaParameterSymbol)
						boundExpression1 = (New BoundParameter(item.Syntax, item, False, item.Type)).MakeCompilerGenerated()
						empty = rangeVariablesPart1
						If (rangeVariablesPart2.Length <= 0) Then
							boundExpression2 = Nothing
							rangeVariableSymbols = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol).Empty
						Else
							parameters = Me._lambdaSymbol.Parameters
							item = DirectCast(parameters(1), BoundLambdaParameterSymbol)
							boundExpression2 = (New BoundParameter(item.Syntax, item, False, item.Type)).MakeCompilerGenerated()
							rangeVariableSymbols = rangeVariablesPart2
						End If
					ElseIf (rangeVariablesPart2.Length <= 0) Then
						boundExpression1 = Nothing
						empty = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol).Empty
						boundExpression2 = Nothing
						rangeVariableSymbols = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol).Empty
					Else
						parameters = Me._lambdaSymbol.Parameters
						item = DirectCast(parameters(1), BoundLambdaParameterSymbol)
						boundExpression1 = (New BoundParameter(item.Syntax, item, False, item.Type)).MakeCompilerGenerated()
						empty = rangeVariablesPart2
						boundExpression2 = Nothing
						rangeVariableSymbols = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol).Empty
					End If
					boundExpression = intoBinder.BindIntoSelector(aggregate, Me._rangeVariables, boundExpression1, empty, boundExpression2, rangeVariableSymbols, Nothing, aggregationVariables, Binder.MustProduceFlatCompoundVariable(operatorsEnumerator), declaredRangeVariables, diagnostics)
				Else
					rangeVariableSymbol = Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol.CreateCompilerGenerated(Me, aggregate, "$VB$Group", group.Type)
					If (Me._rangeVariables.Length <> 0) Then
						boundExpression = Me.BuildJoinSelector(aggregate, False, diagnostics, rangeVariableSymbol, group)
					Else
						boundExpression = group
					End If
					declaredRangeVariables = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)(rangeVariableSymbol)
					intoBinder = Nothing
				End If
				Return boundExpression
			End Function

			Private Function BindExpressionRangeVariable(ByVal item As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax, ByVal requireRangeVariable As Boolean, ByVal shadowingCheckBinder As Binder, ByVal declaredNames As HashSet(Of String), <Out> ByRef selector As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol
				Dim nameEquals As Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax = item.NameEquals
				Dim valueText As String = Nothing
				Dim identifier As Microsoft.CodeAnalysis.SyntaxToken = New Microsoft.CodeAnalysis.SyntaxToken()
				Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
				If (nameEquals Is Nothing) Then
					Dim xmlNameSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax = Nothing
					Dim syntaxToken As Microsoft.CodeAnalysis.SyntaxToken = item.Expression.ExtractAnonymousTypeMemberName(xmlNameSyntax)
					If (syntaxToken.Kind() <> SyntaxKind.None) Then
						identifier = syntaxToken
						valueText = identifier.ValueText
					ElseIf (requireRangeVariable) Then
						If (xmlNameSyntax Is Nothing) Then
							Binder.ReportDiagnostic(diagnostics, item.Expression, ERRID.ERR_QueryAnonymousTypeFieldNameInference)
						Else
							Binder.ReportDiagnostic(diagnostics, xmlNameSyntax.LocalName, ERRID.ERR_QueryAnonTypeFieldXMLNameInference)
						End If
					End If
				Else
					identifier = nameEquals.Identifier.Identifier
					valueText = identifier.ValueText
					If (nameEquals.AsClause IsNot Nothing) Then
						typeSymbol = MyBase.DecodeModifiedIdentifierType(nameEquals.Identifier, nameEquals.AsClause, Nothing, Nothing, diagnostics, Binder.ModifiedIdentifierTypeDecoderContext.LocalType Or Binder.ModifiedIdentifierTypeDecoderContext.QueryRangeVariableType)
					ElseIf (nameEquals.Identifier.Nullable.Node IsNot Nothing) Then
						Binder.ReportDiagnostic(diagnostics, nameEquals.Identifier.Nullable, ERRID.ERR_NullableTypeInferenceNotSupported)
					End If
				End If
				If (valueText IsNot Nothing AndAlso valueText.Length = 0) Then
					valueText = Nothing
				End If
				selector = MyBase.BindValue(item.Expression, diagnostics, False)
				If (typeSymbol IsNot Nothing) Then
					selector = MyBase.ApplyImplicitConversion(item.Expression, typeSymbol, selector, diagnostics, False)
				Else
					selector = MyBase.MakeRValue(selector, diagnostics)
				End If
				Dim rangeVariableSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol = Nothing
				If (valueText IsNot Nothing) Then
					rangeVariableSymbol = Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol.Create(Me, identifier, selector.Type)
					selector = New BoundRangeVariableAssignment(item, rangeVariableSymbol, selector, selector.Type, False)
					Dim flag As Boolean = False
					If (declaredNames Is Nothing OrElse declaredNames.Add(valueText)) Then
						shadowingCheckBinder.VerifyRangeVariableName(rangeVariableSymbol, identifier, diagnostics)
						If (item.Parent.Kind() = SyntaxKind.LetClause AndAlso Binder.ShadowsRangeVariableInTheChildScope(shadowingCheckBinder, rangeVariableSymbol)) Then
							flag = True
						End If
					Else
						Binder.ReportDiagnostic(diagnostics, identifier, ERRID.ERR_QueryDuplicateAnonTypeMemberName1, New [Object]() { valueText })
						flag = True
					End If
					If (flag) Then
						If (Not requireRangeVariable) Then
							rangeVariableSymbol = Nothing
						Else
							rangeVariableSymbol = Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol.CreateForErrorRecovery(Me, rangeVariableSymbol.Syntax, selector.Type)
						End If
					End If
				ElseIf (requireRangeVariable) Then
					rangeVariableSymbol = Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol.CreateForErrorRecovery(Me, item, selector.Type)
				End If
				Return rangeVariableSymbol
			End Function

			Public Function BindExpressionRangeVariables(ByVal selectVariables As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax), ByVal requireRangeVariable As Boolean, ByVal selectorSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax, <Out> ByRef declaredRangeVariables As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
				If (selectVariables.Count = 1) Then
					Dim item As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax = selectVariables(0)
					boundExpression = Nothing
					Dim rangeVariableSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol = Me.BindExpressionRangeVariable(item, requireRangeVariable, MyBase.ContainingBinder, Nothing, boundExpression, diagnostics)
					If (rangeVariableSymbol Is Nothing) Then
						declaredRangeVariables = ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol).Empty
					Else
						declaredRangeVariables = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)(rangeVariableSymbol)
					End If
				ElseIf (selectVariables.Count <> 0) Then
					Dim boundExpressionArray(selectVariables.Count - 1 + 1 - 1) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
					Dim strs As HashSet(Of String) = Binder.CreateSetOfDeclaredNames()
					Dim rangeVariableSymbolArray(selectVariables.Count - 1 + 1 - 1) As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol
					Dim count As Integer = selectVariables.Count - 1
					Dim num As Integer = 0
					Do
						Dim rangeVariableSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol = Me.BindExpressionRangeVariable(selectVariables(num), True, MyBase.ContainingBinder, strs, boundExpressionArray(num), diagnostics)
						rangeVariableSymbolArray(num) = rangeVariableSymbol1
						num = num + 1
					Loop While num <= count
					Dim anonymousTypeField(selectVariables.Count - 1 + 1 - 1) As Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField
					Dim length As Integer = CInt(rangeVariableSymbolArray.Length) - 1
					Dim num1 As Integer = 0
					Do
						Dim rangeVariableSymbol2 As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol = rangeVariableSymbolArray(num1)
						anonymousTypeField(num1) = New Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField(rangeVariableSymbol2.Name, rangeVariableSymbol2.Type, rangeVariableSymbol2.Syntax.GetLocation(), True)
						num1 = num1 + 1
					Loop While num1 <= length
					Dim anonymousTypeFields As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField) = Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField)(anonymousTypeField)
					Dim syntaxToken As Microsoft.CodeAnalysis.SyntaxToken = selectorSyntax.QueryClauseKeywordOrRangeVariableIdentifier()
					boundExpression = MyBase.BindAnonymousObjectCreationExpression(selectorSyntax, New AnonymousTypeDescriptor(anonymousTypeFields, syntaxToken.GetLocation(), True), Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpressionArray), diagnostics).MakeCompilerGenerated()
					declaredRangeVariables = Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)(rangeVariableSymbolArray)
				Else
					boundExpression = Binder.BadExpression(selectorSyntax, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
					declaredRangeVariables = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)(Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol.CreateForErrorRecovery(Me, selectorSyntax, boundExpression.Type))
				End If
				Return boundExpression
			End Function

			Private Shared Function BindJoinCondition(ByVal joinCondition As Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax, ByVal outerKeyBinder As Binder.QueryLambdaBinder, ByVal outerRangeVariables As ImmutableArray(Of RangeVariableSymbol), <Out> ByRef outerKey As BoundExpression, ByVal innerKeyBinder As Binder.QueryLambdaBinder, ByVal innerRangeVariables As ImmutableArray(Of RangeVariableSymbol), <Out> ByRef innerKey As BoundExpression, ByVal sideDeterminator As Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
				' 
				' Current member / type: System.Boolean Microsoft.CodeAnalysis.VisualBasic.Binder/QueryLambdaBinder::BindJoinCondition(Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder/QueryLambdaBinder,System.Collections.Immutable.ImmutableArray`1<Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol>,Microsoft.CodeAnalysis.VisualBasic.BoundExpression&,Microsoft.CodeAnalysis.VisualBasic.Binder/QueryLambdaBinder,System.Collections.Immutable.ImmutableArray`1<Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol>,Microsoft.CodeAnalysis.VisualBasic.BoundExpression&,Microsoft.CodeAnalysis.VisualBasic.Binder/QueryLambdaBinder/JoinConditionSideDeterminationVisitor,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
				' File path: C:\Code\Libs\Compilateurs\Work\Compilateur.NET\Microsoft.CodeAnalysis.VisualBasic.dll
				' 
				' Product version: 2019.1.118.0
				' Exception in: System.Boolean BindJoinCondition(Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax,Microsoft.CodeAnalysis.VisualBasic.Binder/QueryLambdaBinder,System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol>,Microsoft.CodeAnalysis.VisualBasic.BoundExpression&,Microsoft.CodeAnalysis.VisualBasic.Binder/QueryLambdaBinder,System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol>,Microsoft.CodeAnalysis.VisualBasic.BoundExpression&,Microsoft.CodeAnalysis.VisualBasic.Binder/QueryLambdaBinder/JoinConditionSideDeterminationVisitor,Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
				' 
				' La référence d'objet n'est pas définie à une instance d'un objet.
				'    à ..(Expression , Instruction ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 291
				'    à ..(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Steps\FixBinaryExpressionsStep.cs:ligne 48
				'    à Telerik.JustDecompiler.Decompiler.ExpressionDecompilerStep.(DecompilationContext ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\ExpressionDecompilerStep.cs:ligne 91
				'    à ..(MethodBody ,  , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 88
				'    à ..(MethodBody , ILanguage ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\DecompilationPipeline.cs:ligne 70
				'    à Telerik.JustDecompiler.Decompiler.Extensions.( , ILanguage , MethodBody , DecompilationContext& ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 95
				'    à Telerik.JustDecompiler.Decompiler.Extensions.(MethodBody , ILanguage , DecompilationContext& ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\Extensions.cs:ligne 58
				'    à ..(ILanguage , MethodDefinition ,  ) dans C:\DeveloperTooling_JD_Agent1\_work\15\s\OpenSource\Cecil.Decompiler\Decompiler\WriterContextServices\BaseWriterContextService.cs:ligne 117
				' 
				' mailto: JustDecompilePublicFeedback@telerik.com

			End Function

			Public Shared Sub BindJoinKeys(ByVal parentBinder As Binder, ByVal join As Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax, ByVal outer As BoundQueryClauseBase, ByVal inner As BoundQueryClauseBase, ByVal joinSelectorRangeVariables As ImmutableArray(Of RangeVariableSymbol), <Out> ByRef outerKeyLambda As BoundQueryLambda, <Out> ByRef outerKeyBinder As Binder.QueryLambdaBinder, <Out> ByRef innerKeyLambda As BoundQueryLambda, <Out> ByRef innerKeyBinder As Binder.QueryLambdaBinder, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
				Dim boundExpression1 As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
				Dim flag As Boolean
				Dim boundLambdaParameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol = parentBinder.CreateQueryLambdaParameterSymbol(Binder.GetQueryLambdaParameterName(outer.RangeVariables), 0, outer.CompoundVariableType, join, outer.RangeVariables)
				Dim synthesizedLambdaSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaSymbol = parentBinder.CreateQueryLambdaSymbol(LambdaUtilities.GetJoinLeftLambdaBody(join), SynthesizedLambdaKind.JoinLeftQueryLambda, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol)(boundLambdaParameterSymbol))
				outerKeyBinder = New Binder.QueryLambdaBinder(synthesizedLambdaSymbol, joinSelectorRangeVariables)
				Dim boundLambdaParameterSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol = parentBinder.CreateQueryLambdaParameterSymbol(Binder.GetQueryLambdaParameterName(inner.RangeVariables), 0, inner.CompoundVariableType, join, inner.RangeVariables)
				Dim synthesizedLambdaSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaSymbol = parentBinder.CreateQueryLambdaSymbol(LambdaUtilities.GetJoinRightLambdaBody(join), SynthesizedLambdaKind.JoinRightQueryLambda, ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol)(boundLambdaParameterSymbol1))
				innerKeyBinder = New Binder.QueryLambdaBinder(synthesizedLambdaSymbol1, joinSelectorRangeVariables)
				Dim joinConditionSideDeterminationVisitor As Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor = New Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor(outer.RangeVariables, inner.RangeVariables)
				Dim joinConditions As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax) = join.JoinConditions
				If (joinConditions.Count = 0) Then
					boundExpression = Binder.BadExpression(join, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
					boundExpression1 = Binder.BadExpression(join, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
					flag = False
				ElseIf (joinConditions.Count <> 1) Then
					Dim boundExpressionArray(joinConditions.Count - 1 + 1 - 1) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
					Dim boundExpressionArray1(joinConditions.Count - 1 + 1 - 1) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
					flag = True
					Dim count As Integer = joinConditions.Count - 1
					Dim num As Integer = 0
					Do
						If (Not Binder.QueryLambdaBinder.BindJoinCondition(joinConditions(num), outerKeyBinder, outer.RangeVariables, boundExpressionArray(num), innerKeyBinder, inner.RangeVariables, boundExpressionArray1(num), joinConditionSideDeterminationVisitor, diagnostics)) Then
							flag = False
						End If
						num = num + 1
					Loop While num <= count
					If (Not flag) Then
						boundExpression = Binder.BadExpression(join, Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpressionArray), ErrorTypeSymbol.UnknownResultType)
						boundExpression1 = Binder.BadExpression(join, Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpressionArray1), ErrorTypeSymbol.UnknownResultType)
					Else
						Dim anonymousTypeField(joinConditions.Count - 1 + 1 - 1) As Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField
						Dim count1 As Integer = joinConditions.Count - 1
						Dim num1 As Integer = 0
						Do
							anonymousTypeField(num1) = New Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField([String].Concat("Key", num1.ToString()), boundExpressionArray(num1).Type, joinConditions(num1).GetLocation(), True)
							num1 = num1 + 1
						Loop While num1 <= count1
						Dim anonymousTypeFields As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField) = Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField)(anonymousTypeField)
						Dim onKeyword As Microsoft.CodeAnalysis.SyntaxToken = join.OnKeyword
						Dim anonymousTypeDescriptor As Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeDescriptor = New Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeDescriptor(anonymousTypeFields, onKeyword.GetLocation(), True)
						boundExpression = outerKeyBinder.BindAnonymousObjectCreationExpression(join, anonymousTypeDescriptor, Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpressionArray), diagnostics)
						boundExpression1 = innerKeyBinder.BindAnonymousObjectCreationExpression(join, anonymousTypeDescriptor, Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.BoundExpression)(boundExpressionArray1), diagnostics)
					End If
					boundExpression.MakeCompilerGenerated()
					boundExpression1.MakeCompilerGenerated()
				Else
					boundExpression = Nothing
					boundExpression1 = Nothing
					flag = Binder.QueryLambdaBinder.BindJoinCondition(joinConditions(0), outerKeyBinder, outer.RangeVariables, boundExpression, innerKeyBinder, inner.RangeVariables, boundExpression1, joinConditionSideDeterminationVisitor, diagnostics)
					If (Not flag) Then
						If (boundExpression.Type <> ErrorTypeSymbol.UnknownResultType) Then
							boundExpression = Binder.BadExpression(boundExpression.Syntax, boundExpression, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
						End If
						If (boundExpression1.Type <> ErrorTypeSymbol.UnknownResultType) Then
							boundExpression1 = Binder.BadExpression(boundExpression1.Syntax, boundExpression1, ErrorTypeSymbol.UnknownResultType).MakeCompilerGenerated()
						End If
					End If
				End If
				outerKeyLambda = Binder.CreateBoundQueryLambda(synthesizedLambdaSymbol, outer.RangeVariables, boundExpression, False)
				outerKeyLambda.SetWasCompilerGenerated()
				innerKeyLambda = Binder.CreateBoundQueryLambda(synthesizedLambdaSymbol1, inner.RangeVariables, boundExpression1, False)
				innerKeyLambda.SetWasCompilerGenerated()
			End Sub

			Public Function BindLetClauseVariableSelector(ByVal variable As Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax, ByVal operatorsEnumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator, <Out> ByRef declaredRangeVariables As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.BoundExpression
				Dim boundExpression As Microsoft.CodeAnalysis.VisualBasic.BoundExpression = Nothing
				Dim rangeVariableSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol = Me.BindExpressionRangeVariable(variable, True, Me, Nothing, boundExpression, diagnostics)
				declaredRangeVariables = ImmutableArray.Create(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol)(rangeVariableSymbol)
				If (Me._rangeVariables.Length > 0) Then
					boundExpression = Me.BuildJoinSelector(variable, If(variable <> DirectCast(operatorsEnumerator.Current, Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax).Variables.Last(), False, Binder.MustProduceFlatCompoundVariable(operatorsEnumerator)), diagnostics, rangeVariableSymbol, boundExpression)
				End If
				Return boundExpression
			End Function

			Public Function BindSelectClauseSelector(ByVal [select] As Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax, ByVal operatorsEnumerator As SyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax).Enumerator, <Out> ByRef declaredRangeVariables As ImmutableArray(Of RangeVariableSymbol), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
				Dim flag As Boolean
				Dim variables As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax) = [select].Variables
				If (variables.Count <> 1) Then
					flag = True
				Else
					flag = False
					While operatorsEnumerator.MoveNext()
						Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = operatorsEnumerator.Current.Kind()
						If (syntaxKind > Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AggregateClause) Then
							If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GroupByClause) Then
								Return Me.BindExpressionRangeVariables(variables, flag, [select], declaredRangeVariables, diagnostics)
							End If
							If (CUShort(syntaxKind) - CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SimpleJoinClause) <= CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List)) Then
								flag = True
								Return Me.BindExpressionRangeVariables(variables, flag, [select], declaredRangeVariables, diagnostics)
							ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SelectClause) Then
								Return Me.BindExpressionRangeVariables(variables, flag, [select], declaredRangeVariables, diagnostics)
							End If
						ElseIf (CUShort(syntaxKind) - CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.FromClause) <= CUShort(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.List) OrElse syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.AggregateClause) Then
							Return Me.BindExpressionRangeVariables(variables, flag, [select], declaredRangeVariables, diagnostics)
						End If
					End While
				End If
				Return Me.BindExpressionRangeVariables(variables, flag, [select], declaredRangeVariables, diagnostics)
			End Function

			Private Shared Function BuildEqualsOperandIsBadErrorArgument(ByVal builder As StringBuilder, ByVal rangeVariables As ImmutableArray(Of RangeVariableSymbol)) As String
				Dim str As String
				builder.Clear()
				Dim length As Integer = rangeVariables.Length - 1
				Dim num As Integer = 0
				While num <= length
					If (rangeVariables(num).Name.StartsWith("$", StringComparison.Ordinal)) Then
						num = num + 1
					Else
						builder.Append("'"C)
						builder.Append(rangeVariables(num).Name)
						builder.Append("'"C)
						num = num + 1
						Exit While
					End If
				End While
				Dim length1 As Integer = rangeVariables.Length - 1
				num = num
				Do
					If (Not rangeVariables(num).Name.StartsWith("$", StringComparison.Ordinal)) Then
						builder.Append(","C)
						builder.Append(Strings.ChrW(32))
						builder.Append("'"C)
						builder.Append(rangeVariables(num).Name)
						builder.Append("'"C)
					End If
					num = num + 1
				Loop While num <= length1
				If (builder.Length <> 0) Then
					str = builder.ToString()
				Else
					str = Nothing
				End If
				Return str
			End Function

			Public Function BuildJoinSelector(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal mustProduceFlatCompoundVariable As Boolean, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, Optional ByVal rangeVarOpt As RangeVariableSymbol = Nothing, Optional ByVal rangeVarValueOpt As BoundExpression = Nothing) As BoundExpression
				Dim boundExpressionArray As BoundExpression()
				Dim anonymousTypeField As Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField()
				Dim length As Integer
				Dim num As Integer = If(rangeVarOpt Is Nothing, 0, 1)
				If (Me._rangeVariables.Length = 1 OrElse mustProduceFlatCompoundVariable) Then
					length = Me._rangeVariables.Length + num - 1
					ReDim boundExpressionArray(length + 1 - 1)
					ReDim anonymousTypeField(length + 1 - 1)
					Dim length1 As Integer = Me._rangeVariables.Length - 1
					For i As Integer = 0 To length1
						Dim item As RangeVariableSymbol = Me._rangeVariables(i)
						boundExpressionArray(i) = (New BoundRangeVariable(item.Syntax, item, item.Type)).MakeCompilerGenerated()
						anonymousTypeField(i) = New Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField(item.Name, item.Type, item.Syntax.GetLocation(), True)
					Next

				Else
					Dim boundLambdaParameterSymbols As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol) = Me._lambdaSymbol.Parameters.[As](Of Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol)()
					length = boundLambdaParameterSymbols.Length + num - 1
					ReDim boundExpressionArray(length + 1 - 1)
					ReDim anonymousTypeField(length + 1 - 1)
					Dim num1 As Integer = boundLambdaParameterSymbols.Length - 1
					For j As Integer = 0 To num1
						Dim boundLambdaParameterSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol = boundLambdaParameterSymbols(j)
						boundExpressionArray(j) = (New BoundParameter(boundLambdaParameterSymbol.Syntax, boundLambdaParameterSymbol, False, boundLambdaParameterSymbol.Type)).MakeCompilerGenerated()
						anonymousTypeField(j) = New Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField(boundLambdaParameterSymbol.Name, boundLambdaParameterSymbol.Type, boundLambdaParameterSymbol.Syntax.GetLocation(), True)
					Next

				End If
				If (rangeVarOpt IsNot Nothing) Then
					boundExpressionArray(length) = rangeVarValueOpt
					anonymousTypeField(length) = New Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField(rangeVarOpt.Name, rangeVarOpt.Type, rangeVarOpt.Syntax.GetLocation(), True)
				End If
				Dim anonymousTypeFields As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField) = Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField)(anonymousTypeField)
				Dim syntaxToken As Microsoft.CodeAnalysis.SyntaxToken = syntax.QueryClauseKeywordOrRangeVariableIdentifier()
				Return MyBase.BindAnonymousObjectCreationExpression(syntax, New AnonymousTypeDescriptor(anonymousTypeFields, syntaxToken.GetLocation(), True), Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of BoundExpression)(boundExpressionArray), diagnostics).MakeCompilerGenerated()
			End Function

			Private Function VerifyJoinKeys(ByVal outerKey As BoundExpression, ByVal outerRangeVariables As ImmutableArray(Of RangeVariableSymbol), ByVal outerSide As Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result, ByVal innerKey As BoundExpression, ByVal innerRangeVariables As ImmutableArray(Of RangeVariableSymbol), ByVal innerSide As Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
				Dim flag As Boolean
				If (outerSide = Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result.Outer AndAlso innerSide = Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result.Inner) Then
					flag = True
				ElseIf (outerKey.HasErrors OrElse innerKey.HasErrors) Then
					flag = False
				Else
					Dim instance As PooledStringBuilder = PooledStringBuilder.GetInstance()
					Dim str As String = Binder.QueryLambdaBinder.BuildEqualsOperandIsBadErrorArgument(instance.Builder, outerRangeVariables)
					Dim str1 As String = Binder.QueryLambdaBinder.BuildEqualsOperandIsBadErrorArgument(instance.Builder, innerRangeVariables)
					instance.Free()
					If (str Is Nothing OrElse str1 Is Nothing) Then
						flag = False
					Else
						Dim diagnosticInfo As Microsoft.CodeAnalysis.DiagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_EqualsOperandIsBad, New [Object]() { str, str1 })
						Select Case outerSide
							Case Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result.None
								Binder.ReportDiagnostic(diagnostics, outerKey.Syntax, diagnosticInfo)
								Select Case innerSide
									Case Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result.None
										Binder.ReportDiagnostic(diagnostics, innerKey.Syntax, diagnosticInfo)
										flag = False
										Return flag
									Case Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result.Outer
									Case Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result.Both
										Binder.QueryLambdaBinder.EqualsOperandIsBadErrorVisitor.Report(Me, diagnosticInfo, outerRangeVariables, innerKey, diagnostics)
										flag = False
										Return flag
									Case Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result.Inner
										flag = False
										Return flag
								End Select
								Throw ExceptionUtilities.UnexpectedValue(innerSide)
							Case Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result.Outer
								Select Case innerSide
									Case Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result.None
										Binder.ReportDiagnostic(diagnostics, innerKey.Syntax, diagnosticInfo)
										flag = False
										Return flag
									Case Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result.Outer
									Case Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result.Both
										Binder.QueryLambdaBinder.EqualsOperandIsBadErrorVisitor.Report(Me, diagnosticInfo, outerRangeVariables, innerKey, diagnostics)
										flag = False
										Return flag
									Case Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result.Inner
										flag = False
										Return flag
								End Select
								Throw ExceptionUtilities.UnexpectedValue(innerSide)
							Case Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result.Inner
							Case Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result.Both
								Binder.QueryLambdaBinder.EqualsOperandIsBadErrorVisitor.Report(Me, diagnosticInfo, innerRangeVariables, outerKey, diagnostics)
								Select Case innerSide
									Case Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result.None
										Binder.ReportDiagnostic(diagnostics, innerKey.Syntax, diagnosticInfo)
										flag = False
										Return flag
									Case Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result.Outer
									Case Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result.Both
										Binder.QueryLambdaBinder.EqualsOperandIsBadErrorVisitor.Report(Me, diagnosticInfo, outerRangeVariables, innerKey, diagnostics)
										flag = False
										Return flag
									Case Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result.Inner
										flag = False
										Return flag
								End Select
								Throw ExceptionUtilities.UnexpectedValue(innerSide)
						End Select
						Throw ExceptionUtilities.UnexpectedValue(outerSide)
					End If
				End If
				Return flag
			End Function

			Private Class EqualsOperandIsBadErrorVisitor
				Inherits BoundTreeWalkerWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator
				Private ReadOnly _binder As Binder

				Private ReadOnly _errorInfo As DiagnosticInfo

				Private ReadOnly _diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag

				Private ReadOnly _badRangeVariables As ImmutableArray(Of Object)

				Private Sub New(ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal errorInfo As DiagnosticInfo, ByVal badRangeVariables As ImmutableArray(Of RangeVariableSymbol), ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
					MyBase.New()
					Me._badRangeVariables = StaticCast(Of Object).From(Of RangeVariableSymbol)(badRangeVariables)
					Me._binder = binder
					Me._diagnostics = diagnostics
					Me._errorInfo = errorInfo
				End Sub

				Public Shared Sub Report(ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal errorInfo As DiagnosticInfo, ByVal badRangeVariables As ImmutableArray(Of RangeVariableSymbol), ByVal node As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
					Dim equalsOperandIsBadErrorVisitor As Microsoft.CodeAnalysis.VisualBasic.Binder.QueryLambdaBinder.EqualsOperandIsBadErrorVisitor = New Microsoft.CodeAnalysis.VisualBasic.Binder.QueryLambdaBinder.EqualsOperandIsBadErrorVisitor(binder, errorInfo, badRangeVariables, diagnostics)
					Try
						equalsOperandIsBadErrorVisitor.Visit(node)
					Catch cancelledByStackGuardException As BoundTreeVisitor.CancelledByStackGuardException
						ProjectData.SetProjectError(cancelledByStackGuardException)
						cancelledByStackGuardException.AddAnError(diagnostics)
						ProjectData.ClearProjectError()
					End Try
				End Sub

				Public Overrides Function VisitRangeVariable(ByVal node As BoundRangeVariable) As BoundNode
					Dim rangeVariable As RangeVariableSymbol = node.RangeVariable
					If (Me._badRangeVariables.IndexOf(rangeVariable, ReferenceEqualityComparer.Instance) >= 0) Then
						Binder.ReportDiagnostic(Me._diagnostics, node.Syntax, Me._errorInfo)
					End If
					Return node
				End Function
			End Class

			Private Class JoinConditionSideDeterminationVisitor
				Inherits BoundTreeWalkerWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator
				Private ReadOnly _outerRangeVariables As ImmutableArray(Of Object)

				Private ReadOnly _innerRangeVariables As ImmutableArray(Of Object)

				Private _side As Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result

				Public Sub New(ByVal outerRangeVariables As ImmutableArray(Of RangeVariableSymbol), ByVal innerRangeVariables As ImmutableArray(Of RangeVariableSymbol))
					MyBase.New()
					Me._outerRangeVariables = StaticCast(Of Object).From(Of RangeVariableSymbol)(outerRangeVariables)
					Me._innerRangeVariables = StaticCast(Of Object).From(Of RangeVariableSymbol)(innerRangeVariables)
				End Sub

				Public Function DetermineTheSide(ByVal node As BoundExpression, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result
					Me._side = Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result.None
					Try
						Me.Visit(node)
					Catch cancelledByStackGuardException As BoundTreeVisitor.CancelledByStackGuardException
						ProjectData.SetProjectError(cancelledByStackGuardException)
						cancelledByStackGuardException.AddAnError(diagnostics)
						ProjectData.ClearProjectError()
					End Try
					Return Me._side
				End Function

				Public Overrides Function VisitRangeVariable(ByVal node As BoundRangeVariable) As BoundNode
					Dim rangeVariable As RangeVariableSymbol = node.RangeVariable
					If (Me._outerRangeVariables.IndexOf(rangeVariable, ReferenceEqualityComparer.Instance) >= 0) Then
						Me._side = Me._side Or Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result.Outer
					ElseIf (Me._innerRangeVariables.IndexOf(rangeVariable, ReferenceEqualityComparer.Instance) >= 0) Then
						Me._side = Me._side Or Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor.Result.Inner
					End If
					Return node
				End Function

				<Flags>
				Public Enum Result
					None
					Outer
					Inner
					Both
				End Enum
			End Class
		End Class

		Private Class SeenAwaitVisitor
			Inherits BoundTreeWalkerWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator
			Private _seenAwait As Boolean

			Private Sub New()
				MyBase.New()
			End Sub

			Public Shared Function SeenAwaitIn(ByVal node As BoundNode, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Boolean
				Dim seenAwaitVisitor As Binder.SeenAwaitVisitor = New Binder.SeenAwaitVisitor()
				Try
					seenAwaitVisitor.Visit(node)
				Catch cancelledByStackGuardException As BoundTreeVisitor.CancelledByStackGuardException
					ProjectData.SetProjectError(cancelledByStackGuardException)
					cancelledByStackGuardException.AddAnError(diagnostics)
					ProjectData.ClearProjectError()
				End Try
				Return seenAwaitVisitor._seenAwait
			End Function

			Public Overrides Function Visit(ByVal node As Microsoft.CodeAnalysis.VisualBasic.BoundNode) As Microsoft.CodeAnalysis.VisualBasic.BoundNode
				Dim boundNode As Microsoft.CodeAnalysis.VisualBasic.BoundNode
				If (Not Me._seenAwait) Then
					boundNode = MyBase.Visit(node)
				Else
					boundNode = Nothing
				End If
				Return boundNode
			End Function

			Public Overrides Function VisitAwaitOperator(ByVal node As BoundAwaitOperator) As BoundNode
				Me._seenAwait = True
				Return Nothing
			End Function

			Public Overrides Function VisitLambda(ByVal node As BoundLambda) As BoundNode
				Return Nothing
			End Function
		End Class

		Private Class TypeBinder
			Public Sub New()
				MyBase.New()
			End Sub

			Private Shared Sub AnalyzeLookupResultForIllegalBaseTypeReferences(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal typeSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByRef reportedAnError As Boolean)
				Dim containingType As NamedTypeSymbol = binder.ContainingType
				Dim singleSymbol As Symbol = lookupResult.SingleSymbol
				While singleSymbol IsNot Nothing AndAlso singleSymbol.Kind = SymbolKind.NamedType
					If (containingType.Equals(singleSymbol.OriginalDefinition)) Then
						If (CObj(singleSymbol) <> CObj(lookupResult.SingleSymbol)) Then
							Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagBag, typeSyntax, ERRID.ERR_NestedTypeInInheritsClause2, New [Object]() { containingType, lookupResult.SingleSymbol })
						Else
							Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagBag, typeSyntax, ERRID.ERR_TypeInItsInheritsClause1, New [Object]() { containingType })
						End If
						lookupResult.Clear()
						reportedAnError = True
						Return
					End If
					singleSymbol = singleSymbol.ContainingSymbol
				End While
			End Sub

			Public Shared Function BindNamespaceOrTypeOrAliasSyntax(ByVal typeSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal suppressUseSiteError As Boolean) As Symbol
				Return Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.BindNamespaceOrTypeSyntax(typeSyntax, binder, diagBag, False, suppressUseSiteError)
			End Function

			Public Shared Function BindNamespaceOrTypeSyntax(ByVal typeSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal suppressUseSiteError As Boolean) As NamespaceOrTypeSymbol
				Return DirectCast(Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.BindNamespaceOrTypeSyntax(typeSyntax, binder, diagBag, True, suppressUseSiteError), NamespaceOrTypeSymbol)
			End Function

			Private Shared Function BindNamespaceOrTypeSyntax(ByVal typeSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal unwrapAliases As Boolean, ByVal suppressUseSiteError As Boolean) As Symbol
				Dim errorSymbol As Symbol
				Dim flag As Boolean
				Dim instance As LookupResult = LookupResult.GetInstance()
				Try
					Dim flag1 As Boolean = False
					Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupTypeOrNamespaceSyntax(instance, typeSyntax, binder, diagBag, flag1, unwrapAliases, suppressUseSiteError, False, False)
					If (Not instance.HasSymbol) Then
						Dim diagnosticInfo As Microsoft.CodeAnalysis.DiagnosticInfo = Nothing
						Dim baseNamesForDiagnostic As String = Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.GetBaseNamesForDiagnostic(typeSyntax)
						diagnosticInfo = ErrorFactory.ErrorInfo(ERRID.ERR_UndefinedTypeOrNamespace1, New [Object]() { baseNamesForDiagnostic })
						Dim flag2 As Boolean = False
						Dim parent As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode = typeSyntax.Parent
						If (parent IsNot Nothing) Then
							flag = parent.Kind() = SyntaxKind.SimpleImportsClause
						Else
							flag = False
						End If
						If (flag) Then
							If (DirectCast(typeSyntax.Parent, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax).[Alias] IsNot Nothing) Then
								flag2 = True
							End If
							If (Not flag1) Then
								Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagBag, typeSyntax, ErrorFactory.ErrorInfo(ERRID.WRN_UndefinedOrEmptyNamespaceOrClass1, New [Object]() { baseNamesForDiagnostic }))
								flag1 = True
							End If
						End If
						If (Not flag1) Then
							Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagBag, typeSyntax, diagnosticInfo)
						End If
						errorSymbol = Microsoft.CodeAnalysis.VisualBasic.Binder.GetErrorSymbol(baseNamesForDiagnostic, diagnosticInfo, flag2)
					ElseIf (Not instance.HasDiagnostic) Then
						Dim singleSymbol As Symbol = instance.SingleSymbol
						binder.ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagBag, singleSymbol, typeSyntax)
						binder.AddTypesAssemblyAsDependency(TryCast(singleSymbol, NamedTypeSymbol), diagBag)
						errorSymbol = singleSymbol
					Else
						If (Not flag1) Then
							Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagBag, typeSyntax, instance.Diagnostic)
						End If
						errorSymbol = Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.ErrorTypeFromLookupResult(instance.SingleSymbol.Name, instance, binder)
					End If
				Finally
					instance.Free()
				End Try
				Return errorSymbol
			End Function

			Private Shared Function BindTypeArguments(ByVal typeArgumentsSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal suppressUseSiteError As Boolean) As ImmutableArray(Of TypeSymbol)
				Dim count As Integer = typeArgumentsSyntax.Arguments.Count
				Dim typeSymbolArray(count - 1 + 1 - 1) As TypeSymbol
				Dim num As Integer = count - 1
				Dim num1 As Integer = 0
				Do
					Dim arguments As SeparatedSyntaxList(Of Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax) = typeArgumentsSyntax.Arguments
					typeSymbolArray(num1) = binder.BindTypeSyntax(arguments(num1), diagBag, suppressUseSiteError, False, False)
					num1 = num1 + 1
				Loop While num1 <= num
				Return Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull(Of TypeSymbol)(typeSymbolArray)
			End Function

			Friend Shared Function BindTypeOrAliasSyntax(ByVal typeSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal suppressUseSiteError As Boolean, ByVal inGetTypeContext As Boolean, ByVal resolvingBaseType As Boolean) As Symbol
				Dim errorSymbol As Symbol
				Dim bindingDiagnosticBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag
				Dim instance As LookupResult = LookupResult.GetInstance()
				Try
					Dim flag As Boolean = False
					Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupTypeOrNamespaceSyntax(instance, typeSyntax, binder, diagBag, flag, False, suppressUseSiteError, inGetTypeContext, resolvingBaseType)
					Dim badSymbolDiagnostic As DiagnosticInfo = Nothing
					If (Not instance.HasSymbol) Then
						Dim baseNamesForDiagnostic As String = Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.GetBaseNamesForDiagnostic(typeSyntax)
						Dim typeSyntax1 As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax = typeSyntax
						Dim str As String = baseNamesForDiagnostic
						Dim binder1 As Microsoft.CodeAnalysis.VisualBasic.Binder = binder
						If (flag) Then
							bindingDiagnosticBag = Nothing
						Else
							bindingDiagnosticBag = diagBag
						End If
						badSymbolDiagnostic = Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.NotFound(typeSyntax1, str, binder1, bindingDiagnosticBag)
						errorSymbol = Microsoft.CodeAnalysis.VisualBasic.Binder.GetErrorSymbol(baseNamesForDiagnostic, badSymbolDiagnostic, False)
					ElseIf (Not instance.HasDiagnostic) Then
						Dim singleSymbol As Symbol = instance.SingleSymbol
						Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
						typeSymbol = If(singleSymbol.Kind <> SymbolKind.[Alias], TryCast(singleSymbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol), TryCast(DirectCast(singleSymbol, AliasSymbol).Target, Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol))
						If (typeSymbol IsNot Nothing) Then
							If (Not flag AndAlso Not suppressUseSiteError AndAlso Not typeSymbol.IsArrayType() AndAlso Not typeSymbol.IsTupleType AndAlso typeSymbol.IsDefinition) Then
								Microsoft.CodeAnalysis.VisualBasic.Binder.ReportUseSite(diagBag, typeSyntax, typeSymbol)
							ElseIf (typeSymbol = singleSymbol) Then
								binder.AddTypesAssemblyAsDependency(TryCast(typeSymbol, NamedTypeSymbol), diagBag)
							End If
							If (diagBag.AccumulatesDiagnostics AndAlso typeSymbol.Kind = SymbolKind.NamedType AndAlso binder.SourceModule.AnyReferencedAssembliesAreLinked) Then
								EmbeddedTypesManager.IsValidEmbeddableType(DirectCast(typeSymbol, NamedTypeSymbol), typeSyntax, diagBag.DiagnosticBag, Nothing)
							End If
							binder.ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagBag, singleSymbol, typeSyntax)
							errorSymbol = singleSymbol
						Else
							badSymbolDiagnostic = New Microsoft.CodeAnalysis.VisualBasic.BadSymbolDiagnostic(instance.SingleSymbol, ERRID.ERR_UnrecognizedType)
							If (Not flag) Then
								Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagBag, typeSyntax, badSymbolDiagnostic)
							End If
							errorSymbol = Microsoft.CodeAnalysis.VisualBasic.Binder.GetErrorSymbol(Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.GetBaseNamesForDiagnostic(typeSyntax), badSymbolDiagnostic, ImmutableArray.Create(Of Symbol)(singleSymbol), LookupResultKind.NotATypeOrNamespace, False)
						End If
					Else
						Dim baseNamesForDiagnostic1 As String = Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.GetBaseNamesForDiagnostic(typeSyntax)
						badSymbolDiagnostic = instance.Diagnostic
						If (Not flag) Then
							Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagBag, typeSyntax, instance.Diagnostic)
						End If
						errorSymbol = Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.ErrorTypeFromLookupResult(baseNamesForDiagnostic1, instance, binder)
					End If
				Finally
					instance.Free()
				End Try
				Return errorSymbol
			End Function

			Public Shared Function BindTypeSyntax(ByVal typeSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal suppressUseSiteError As Boolean, ByVal resolvingBaseType As Boolean) As TypeSymbol
				Dim target As Symbol = Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.BindTypeOrAliasSyntax(typeSyntax, binder, diagBag, suppressUseSiteError, False, resolvingBaseType)
				If (target IsNot Nothing AndAlso target.Kind = SymbolKind.[Alias]) Then
					target = DirectCast(target, AliasSymbol).Target
				End If
				Return DirectCast(target, TypeSymbol)
			End Function

			Private Shared Sub CheckForForwardedType(ByVal containingAssembly As AssemblySymbol, ByRef typeSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax, ByRef diagName As String, ByRef forwardedToAssembly As AssemblySymbol, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag)
				Dim right As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax
				Dim left As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax = typeSyntax
				Dim str As String = diagName
				While True
					Dim flag As Boolean = left.Kind() = SyntaxKind.QualifiedName
					Dim arity As Integer = 0
					Dim str1 As String = str
					If (flag) Then
						right = DirectCast(left, Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax).Right
					Else
						right = left
					End If
					Dim typeSyntax1 As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax = right
					If (typeSyntax1.Kind() = SyntaxKind.GenericName) Then
						arity = DirectCast(typeSyntax1, Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax).Arity
						str1 = MetadataHelpers.ComposeAritySuffixedMetadataName(str, arity)
					End If
					forwardedToAssembly = Binder.TypeBinder.GetForwardedToAssembly(containingAssembly, str1, arity, typeSyntax, diagBag)
					If (forwardedToAssembly IsNot Nothing) Then
						typeSyntax = left
						diagName = str
						Return
					End If
					If (Not flag) Then
						Exit While
					End If
					left = DirectCast(left, Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax).Left
					str = str.Substring(0, str.LastIndexOf("."C))
				End While
			End Sub

			Private Shared Function CheckSymbolIsType(ByVal sym As NamespaceOrTypeSymbol, ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As TypeSymbol
				Dim errorSymbol As TypeSymbol
				If (Not sym.IsNamespace) Then
					errorSymbol = DirectCast(sym, TypeSymbol)
				Else
					Dim badSymbolDiagnostic As Microsoft.CodeAnalysis.VisualBasic.BadSymbolDiagnostic = New Microsoft.CodeAnalysis.VisualBasic.BadSymbolDiagnostic(sym, ERRID.ERR_UnrecognizedType)
					Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagBag, syntax, badSymbolDiagnostic)
					errorSymbol = Microsoft.CodeAnalysis.VisualBasic.Binder.GetErrorSymbol(sym.Name, badSymbolDiagnostic, ImmutableArray.Create(Of Symbol)(sym), LookupResultKind.NotATypeOrNamespace, False)
				End If
				Return errorSymbol
			End Function

			Private Shared Function ErrorTypeFromLookupResult(ByVal name As String, ByVal result As LookupResult, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder) As Microsoft.CodeAnalysis.VisualBasic.Symbols.ErrorTypeSymbol
				Dim errorTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.ErrorTypeSymbol
				errorTypeSymbol = If(result.Kind <> LookupResultKind.Ambiguous OrElse Not result.HasSingleSymbol OrElse Not TypeOf result.Diagnostic Is AmbiguousSymbolDiagnostic, Microsoft.CodeAnalysis.VisualBasic.Binder.GetErrorSymbol(name, result.Diagnostic, result.Symbols.ToImmutable(), result.Kind, False), Microsoft.CodeAnalysis.VisualBasic.Binder.GetErrorSymbol(name, result.Diagnostic, DirectCast(result.Diagnostic, AmbiguousSymbolDiagnostic).AmbiguousSymbols, result.Kind, False))
				Return errorTypeSymbol
			End Function

			Private Shared Function GetBaseNamesForDiagnostic(ByVal typeSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax) As String
				Dim baseNamesForDiagnostic As String
				Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = typeSyntax.Kind()
				Select Case syntaxKind
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ArrayType
						baseNamesForDiagnostic = Binder.TypeBinder.GetBaseNamesForDiagnostic(DirectCast(typeSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayTypeSyntax).ElementType)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NullableType
						baseNamesForDiagnostic = Binder.TypeBinder.GetBaseNamesForDiagnostic(DirectCast(typeSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.NullableTypeSyntax).ElementType)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PredefinedType
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GlobalName
						baseNamesForDiagnostic = typeSyntax.ToString()
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IdentifierName
						baseNamesForDiagnostic = DirectCast(typeSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax).Identifier.ValueText
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GenericName
						baseNamesForDiagnostic = DirectCast(typeSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax).Identifier.ValueText
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.QualifiedName
						Dim str As String = Binder.TypeBinder.GetBaseNamesForDiagnostic(DirectCast(typeSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax).Left)
						Dim identifier As Microsoft.CodeAnalysis.SyntaxToken = DirectCast(typeSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax).Right.Identifier
						baseNamesForDiagnostic = [String].Concat(str, ".", identifier.ValueText)
						Exit Select
					Case Else
						If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TupleType) Then
							Throw ExceptionUtilities.UnexpectedValue(typeSyntax.Kind())
						End If
						baseNamesForDiagnostic = typeSyntax.ToString()
						Exit Select
				End Select
				Return baseNamesForDiagnostic
			End Function

			Private Shared Function GetForwardedToAssembly(ByVal containingAssembly As Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol, ByVal fullName As String, ByVal arity As Integer, ByVal typeSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol
				Dim assemblySymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol
				Dim metadataTypeName As Microsoft.CodeAnalysis.MetadataTypeName = Microsoft.CodeAnalysis.MetadataTypeName.FromFullName(fullName, True, arity)
				Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = Nothing
				Dim modules As ImmutableArray(Of ModuleSymbol) = containingAssembly.Modules
				Dim enumerator As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol).Enumerator = modules(0).GetReferencedAssemblySymbols().GetEnumerator()
				Do
					If (Not enumerator.MoveNext()) Then
						Exit Do
					End If
					namedTypeSymbol = enumerator.Current.TryLookupForwardedMetadataType(metadataTypeName, True)
				Loop While namedTypeSymbol Is Nothing
				If (namedTypeSymbol Is Nothing) Then
					assemblySymbol = Nothing
				Else
					If (diagBag IsNot Nothing AndAlso namedTypeSymbol.IsErrorType()) Then
						Dim errorInfo As DiagnosticInfo = DirectCast(namedTypeSymbol, ErrorTypeSymbol).ErrorInfo
						If (errorInfo.Code <> 31425) Then
							If (errorInfo.Code <> 37208) Then
								GoTo Label1
							End If
							Binder.ReportDiagnostic(diagBag, typeSyntax, errorInfo)
							assemblySymbol = Nothing
							Return assemblySymbol
						Else
							Binder.ReportDiagnostic(diagBag, typeSyntax, ERRID.ERR_TypeFwdCycle2, New [Object]() { fullName, namedTypeSymbol.ContainingAssembly })
						End If
					End If
				Label1:
					assemblySymbol = namedTypeSymbol.ContainingAssembly
				End If
				Return assemblySymbol
			End Function

			Private Shared Function IsParameterTypeOfDeclareMethod(ByVal typeSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax) As Boolean
				Dim flag As Boolean
				Dim parent As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode = typeSyntax.Parent
				If (parent IsNot Nothing AndAlso parent.Kind() = SyntaxKind.SimpleAsClause) Then
					parent = parent.Parent
					If (parent.Kind() = SyntaxKind.Parameter) Then
						parent = parent.Parent
						If (parent.Kind() <> SyntaxKind.ParameterList) Then
							flag = False
							Return flag
						End If
						parent = parent.Parent
						flag = If(parent.Kind() = SyntaxKind.DeclareFunctionStatement, True, parent.Kind() = SyntaxKind.DeclareSubStatement)
						Return flag
					End If
				End If
				flag = False
				Return flag
			End Function

			Private Shared Function LookupArrayType(ByVal arrayTypeSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayTypeSyntax, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal suppressUseSiteError As Boolean, ByVal inGetTypeContext As Boolean) As SingleLookupResult
				Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = binder.BindTypeSyntax(arrayTypeSyntax.ElementType, diagBag, suppressUseSiteError, inGetTypeContext, False)
				Return SingleLookupResult.Good(binder.ApplyArrayRankSpecifiersToType(typeSymbol, arrayTypeSyntax.RankSpecifiers, diagBag))
			End Function

			Private Shared Sub LookupBasicName(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal basicNameSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByRef reportedAnError As Boolean)
				Dim identifier As Microsoft.CodeAnalysis.SyntaxToken = basicNameSyntax.Identifier
				Dim valueText As String = identifier.ValueText
				Microsoft.CodeAnalysis.VisualBasic.Binder.DisallowTypeCharacter(identifier, diagBag, ERRID.ERR_TypecharNotallowed)
				If ([String].IsNullOrEmpty(valueText)) Then
					reportedAnError = True
					Return
				End If
				Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = binder.GetNewCompoundUseSiteInfo(diagBag)
				If (Not SyntaxFacts.IsAttributeName(basicNameSyntax)) Then
					binder.Lookup(lookupResult, valueText, 0, LookupOptions.NamespacesOrTypesOnly, newCompoundUseSiteInfo)
				Else
					binder.LookupAttributeType(lookupResult, Nothing, valueText, LookupOptions.AttributeTypeOnly, newCompoundUseSiteInfo)
				End If
				diagBag.Add(basicNameSyntax, newCompoundUseSiteInfo)
			End Sub

			Private Shared Sub LookupDottedName(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal dottedNameSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByRef reportedAnError As Boolean, ByVal suppressUseSiteError As Boolean, ByVal resolvingBaseType As Boolean)
				If (TypeOf dottedNameSyntax.Right Is Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax) Then
					Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupGenericDottedName(lookupResult, dottedNameSyntax, binder, diagBag, reportedAnError, suppressUseSiteError, resolvingBaseType)
					Return
				End If
				Dim right As Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax = dottedNameSyntax.Right
				Dim identifier As Microsoft.CodeAnalysis.SyntaxToken = right.Identifier
				Dim left As Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax = dottedNameSyntax.Left
				Microsoft.CodeAnalysis.VisualBasic.Binder.DisallowTypeCharacter(identifier, diagBag, ERRID.ERR_TypecharNotallowed)
				Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupTypeOrNamespaceSyntax(lookupResult, left, binder, diagBag, reportedAnError, True, suppressUseSiteError, False, resolvingBaseType)
				If (lookupResult.HasSymbol) Then
					If (lookupResult.HasDiagnostic AndAlso Not reportedAnError) Then
						Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagBag, left, lookupResult.Diagnostic)
						reportedAnError = lookupResult.Diagnostic.Severity = DiagnosticSeverity.[Error]
					End If
					Dim singleSymbol As NamespaceOrTypeSymbol = DirectCast(lookupResult.SingleSymbol, NamespaceOrTypeSymbol)
					binder.ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagBag, singleSymbol, left)
					binder.AddTypesAssemblyAsDependency(singleSymbol, diagBag)
					lookupResult.Clear()
					Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = binder.GetNewCompoundUseSiteInfo(diagBag)
					If (Not SyntaxFacts.IsAttributeName(right)) Then
						Dim flag As Boolean = If(singleSymbol.Kind <> SymbolKind.NamedType, False, DirectCast(singleSymbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol).IsUnboundGenericType)
						If (flag) Then
							singleSymbol = DirectCast(singleSymbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol).OriginalDefinition
						End If
						binder.LookupMember(lookupResult, singleSymbol, identifier.ValueText, 0, LookupOptions.NamespacesOrTypesOnly, newCompoundUseSiteInfo)
						If (lookupResult.HasSingleSymbol AndAlso lookupResult.SingleSymbol.Kind = SymbolKind.NamedType) Then
							Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = DirectCast(lookupResult.SingleSymbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)
							If (flag AndAlso namedTypeSymbol.IsGenericType) Then
								lookupResult.ReplaceSymbol(namedTypeSymbol.AsUnboundGenericType())
							ElseIf (namedTypeSymbol.Arity > 0 AndAlso Not namedTypeSymbol.IsDefinition AndAlso CObj(namedTypeSymbol) = CObj(namedTypeSymbol.ConstructedFrom)) Then
								lookupResult.ReplaceSymbol(namedTypeSymbol.Construct(StaticCast(Of TypeSymbol).From(Of TypeParameterSymbol)(namedTypeSymbol.OriginalDefinition.TypeParameters)))
							End If
						End If
					Else
						binder.LookupAttributeType(lookupResult, singleSymbol, identifier.ValueText, LookupOptions.AttributeTypeOnly, newCompoundUseSiteInfo)
					End If
					diagBag.Add(left, newCompoundUseSiteInfo)
				End If
			End Sub

			Private Shared Sub LookupGenericDottedName(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal genDottedNameSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByRef reportedAnError As Boolean, ByVal suppressUseSiteError As Boolean, ByVal resolvingBaseType As Boolean)
				Dim right As Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax = DirectCast(genDottedNameSyntax.Right, Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax)
				Dim identifier As Microsoft.CodeAnalysis.SyntaxToken = right.Identifier
				Dim left As Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax = genDottedNameSyntax.Left
				Microsoft.CodeAnalysis.VisualBasic.Binder.DisallowTypeCharacter(identifier, diagBag, ERRID.ERR_TypecharNotallowed)
				Dim typeArgumentList As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax = right.TypeArgumentList
				Dim count As Integer = typeArgumentList.Arguments.Count
				Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupTypeOrNamespaceSyntax(lookupResult, left, binder, diagBag, reportedAnError, True, suppressUseSiteError, False, resolvingBaseType)
				Dim typeSymbols As ImmutableArray(Of TypeSymbol) = Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.BindTypeArguments(typeArgumentList, binder, diagBag, suppressUseSiteError)
				If (lookupResult.HasSymbol) Then
					If (lookupResult.HasDiagnostic AndAlso Not reportedAnError) Then
						Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagBag, left, lookupResult.Diagnostic)
						reportedAnError = lookupResult.Diagnostic.Severity = DiagnosticSeverity.[Error]
					End If
					Dim singleSymbol As NamespaceOrTypeSymbol = DirectCast(lookupResult.SingleSymbol, NamespaceOrTypeSymbol)
					Dim flag As Boolean = If(singleSymbol.Kind <> SymbolKind.NamedType, False, DirectCast(singleSymbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol).IsUnboundGenericType)
					If (flag) Then
						singleSymbol = DirectCast(singleSymbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol).OriginalDefinition
					End If
					binder.ReportDiagnosticsIfObsoleteOrNotSupportedByRuntime(diagBag, singleSymbol, left)
					binder.AddTypesAssemblyAsDependency(singleSymbol, diagBag)
					lookupResult.Clear()
					Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = binder.GetNewCompoundUseSiteInfo(diagBag)
					binder.LookupMember(lookupResult, singleSymbol, identifier.ValueText, count, LookupOptions.NamespacesOrTypesOnly, newCompoundUseSiteInfo)
					diagBag.Add(left, newCompoundUseSiteInfo)
					If (lookupResult.Kind <> LookupResultKind.Empty) Then
						Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = TryCast(lookupResult.SingleSymbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)
						If (namedTypeSymbol IsNot Nothing) Then
							If (flag AndAlso namedTypeSymbol.IsGenericType) Then
								lookupResult.ReplaceSymbol(namedTypeSymbol.AsUnboundGenericType())
								Return
							End If
							Dim namedTypeSymbol1 As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = binder.ConstructAndValidateConstraints(namedTypeSymbol, typeSymbols, genDottedNameSyntax, typeArgumentList.Arguments, diagBag)
							lookupResult.ReplaceSymbol(namedTypeSymbol1)
						End If
					End If
				End If
			End Sub

			Private Shared Sub LookupGenericName(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal genericNameSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByRef reportedAnError As Boolean, ByVal suppressUseSiteError As Boolean)
				Dim identifier As Microsoft.CodeAnalysis.SyntaxToken = genericNameSyntax.Identifier
				Dim valueText As String = identifier.ValueText
				Microsoft.CodeAnalysis.VisualBasic.Binder.DisallowTypeCharacter(identifier, diagBag, ERRID.ERR_TypecharNotallowed)
				Dim typeArgumentList As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax = genericNameSyntax.TypeArgumentList
				Dim count As Integer = typeArgumentList.Arguments.Count
				Dim newCompoundUseSiteInfo As CompoundUseSiteInfo(Of AssemblySymbol) = binder.GetNewCompoundUseSiteInfo(diagBag)
				binder.Lookup(lookupResult, valueText, count, LookupOptions.NamespacesOrTypesOnly, newCompoundUseSiteInfo)
				diagBag.Add(genericNameSyntax, newCompoundUseSiteInfo)
				Dim typeSymbols As ImmutableArray(Of TypeSymbol) = Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.BindTypeArguments(typeArgumentList, binder, diagBag, suppressUseSiteError)
				If (lookupResult.Kind <> LookupResultKind.Empty) Then
					Dim singleSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = TryCast(lookupResult.SingleSymbol, Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol)
					If (singleSymbol IsNot Nothing AndAlso singleSymbol.IsGenericType AndAlso singleSymbol.CanConstruct) Then
						If (Not suppressUseSiteError AndAlso Microsoft.CodeAnalysis.VisualBasic.Binder.ReportUseSite(diagBag, genericNameSyntax, singleSymbol)) Then
							reportedAnError = True
						End If
						Dim namedTypeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol = binder.ConstructAndValidateConstraints(singleSymbol, typeSymbols, genericNameSyntax, typeArgumentList.Arguments, diagBag)
						lookupResult.ReplaceSymbol(namedTypeSymbol)
					ElseIf (lookupResult.IsGood) Then
						lookupResult.SetFrom(SingleLookupResult.WrongArity(lookupResult.SingleSymbol, New BadSymbolDiagnostic(lookupResult.SingleSymbol, ERRID.ERR_TypeOrMemberNotGeneric1, New [Object]() { lookupResult.SingleSymbol })))
						Return
					End If
				End If
			End Sub

			Private Shared Function LookupGlobalName(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.GlobalNameSyntax, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder) As SingleLookupResult
				Return SingleLookupResult.Good(binder.Compilation.GlobalNamespace)
			End Function

			Private Shared Function LookupNullableType(ByVal nullableTypeSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.NullableTypeSyntax, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal suppressUseSiteError As Boolean) As SingleLookupResult
				Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = binder.BindTypeSyntax(nullableTypeSyntax.ElementType, diagBag, suppressUseSiteError, False, False)
				Return SingleLookupResult.Good(binder.CreateNullableOf(typeSymbol, nullableTypeSyntax, nullableTypeSyntax.ElementType, diagBag))
			End Function

			Private Shared Function LookupPredefinedTypeName(ByVal predefinedTypeSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedTypeSyntax, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByRef reportedAnError As Boolean, ByVal suppressUseSiteError As Boolean) As SingleLookupResult
				Return Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupPredefinedTypeName(predefinedTypeSyntax, predefinedTypeSyntax.Keyword.Kind(), binder, diagBag, reportedAnError, suppressUseSiteError)
			End Function

			Public Shared Function LookupPredefinedTypeName(ByVal node As Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode, ByVal predefinedType As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByRef reportedAnError As Boolean, ByVal suppressUseSiteError As Boolean) As SingleLookupResult
				Dim specialType As Microsoft.CodeAnalysis.SpecialType
				Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = predefinedType
				If (syntaxKind <= Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IntegerKeyword) Then
					If (syntaxKind <= Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CharKeyword) Then
						If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.BooleanKeyword) Then
							specialType = Microsoft.CodeAnalysis.SpecialType.System_Boolean
						ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ByteKeyword) Then
							specialType = Microsoft.CodeAnalysis.SpecialType.System_Byte
						Else
							If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CharKeyword) Then
								Throw ExceptionUtilities.UnexpectedValue(predefinedType)
							End If
							specialType = Microsoft.CodeAnalysis.SpecialType.System_Char
						End If
					ElseIf (syntaxKind <= Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DecimalKeyword) Then
						If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DateKeyword) Then
							specialType = Microsoft.CodeAnalysis.SpecialType.System_DateTime
						Else
							If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DecimalKeyword) Then
								Throw ExceptionUtilities.UnexpectedValue(predefinedType)
							End If
							specialType = Microsoft.CodeAnalysis.SpecialType.System_Decimal
						End If
					ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.DoubleKeyword) Then
						specialType = Microsoft.CodeAnalysis.SpecialType.System_Double
					Else
						If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IntegerKeyword) Then
							Throw ExceptionUtilities.UnexpectedValue(predefinedType)
						End If
						specialType = Microsoft.CodeAnalysis.SpecialType.System_Int32
					End If
				ElseIf (syntaxKind <= Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SByteKeyword) Then
					If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.LongKeyword) Then
						specialType = Microsoft.CodeAnalysis.SpecialType.System_Int64
					ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ObjectKeyword) Then
						specialType = Microsoft.CodeAnalysis.SpecialType.System_Object
					Else
						If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SByteKeyword) Then
							Throw ExceptionUtilities.UnexpectedValue(predefinedType)
						End If
						specialType = Microsoft.CodeAnalysis.SpecialType.System_SByte
					End If
				ElseIf (syntaxKind <= Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleKeyword) Then
					If (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ShortKeyword) Then
						specialType = Microsoft.CodeAnalysis.SpecialType.System_Int16
					Else
						If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.SingleKeyword) Then
							Throw ExceptionUtilities.UnexpectedValue(predefinedType)
						End If
						specialType = Microsoft.CodeAnalysis.SpecialType.System_Single
					End If
				ElseIf (syntaxKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.StringKeyword) Then
					specialType = Microsoft.CodeAnalysis.SpecialType.System_String
				Else
					Select Case syntaxKind
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UIntegerKeyword
							specialType = Microsoft.CodeAnalysis.SpecialType.System_UInt32
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ULongKeyword
							specialType = Microsoft.CodeAnalysis.SpecialType.System_UInt64
							Exit Select
						Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.UShortKeyword
							specialType = Microsoft.CodeAnalysis.SpecialType.System_UInt16
							Exit Select
						Case Else
							Throw ExceptionUtilities.UnexpectedValue(predefinedType)
					End Select
				End If
				Return SingleLookupResult.Good(binder.GetSpecialType(specialType, node, diagBag, reportedAnError, suppressUseSiteError))
			End Function

			Private Shared Function LookupTupleType(ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleTypeSyntax, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByVal suppressUseSiteError As Boolean, ByVal inGetTypeContext As Boolean, ByVal resolvingBaseType As Boolean) As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol
				Dim strs As ImmutableArray(Of String)
				Dim count As Integer = syntax.Elements.Count
				Dim instance As ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol) = ArrayBuilder(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol).GetInstance(count)
				Dim locations As ArrayBuilder(Of Microsoft.CodeAnalysis.Location) = ArrayBuilder(Of Microsoft.CodeAnalysis.Location).GetInstance(count)
				Dim strs1 As ArrayBuilder(Of String) = Nothing
				Dim strs2 As HashSet(Of String) = New HashSet(Of String)(CaseInsensitiveComparison.Comparer)
				Dim flag As Boolean = False
				Dim num As Integer = count - 1
				Dim num1 As Integer = 0
				Do
					Dim item As Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleElementSyntax = syntax.Elements(num1)
					Dim typeSymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol = Nothing
					Dim identifierText As String = Nothing
					Dim identifier As Microsoft.CodeAnalysis.SyntaxToken = New Microsoft.CodeAnalysis.SyntaxToken()
					If (item.Kind() <> SyntaxKind.TypedTupleElement) Then
						Dim namedTupleElementSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedTupleElementSyntax = DirectCast(item, Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedTupleElementSyntax)
						identifier = namedTupleElementSyntax.Identifier
						identifierText = identifier.GetIdentifierText()
						typeSymbol = binder.DecodeIdentifierType(identifier, namedTupleElementSyntax.AsClause, Nothing, diagnostics)
					Else
						Dim typedTupleElementSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypedTupleElementSyntax = DirectCast(item, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypedTupleElementSyntax)
						typeSymbol = binder.BindTypeSyntax(typedTupleElementSyntax.Type, diagnostics, suppressUseSiteError, inGetTypeContext, resolvingBaseType)
					End If
					instance.Add(typeSymbol)
					If (identifier.Kind() <> SyntaxKind.IdentifierToken) Then
						locations.Add(item.GetLocation())
					Else
						flag = True
						Microsoft.CodeAnalysis.VisualBasic.Binder.CheckTupleMemberName(identifierText, num1, identifier, diagnostics, strs2)
						locations.Add(identifier.GetLocation())
					End If
					Microsoft.CodeAnalysis.VisualBasic.Binder.CollectTupleFieldMemberName(identifierText, num1, count, strs1)
					num1 = num1 + 1
				Loop While num1 <= num
				If (flag) Then
					Dim wellKnownTypeMember As MethodSymbol = TryCast(binder.Compilation.GetWellKnownTypeMember(WellKnownMember.System_Runtime_CompilerServices_TupleElementNamesAttribute__ctorTransformNames), MethodSymbol)
					If (wellKnownTypeMember IsNot Nothing) Then
						diagnostics.Add(Microsoft.CodeAnalysis.VisualBasic.Binder.GetUseSiteInfoForWellKnownTypeMember(wellKnownTypeMember, WellKnownMember.System_Runtime_CompilerServices_TupleElementNamesAttribute__ctorTransformNames, False), syntax)
					Else
						Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagnostics, syntax, ERRID.ERR_TupleElementNamesAttributeMissing, New [Object]() { AttributeDescription.TupleElementNamesAttribute.FullName })
					End If
				End If
				Dim immutableAndFree As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol) = instance.ToImmutableAndFree()
				Dim immutableAndFree1 As ImmutableArray(Of Microsoft.CodeAnalysis.Location) = locations.ToImmutableAndFree()
				If (immutableAndFree.Length < 2) Then
					Throw ExceptionUtilities.UnexpectedValue(immutableAndFree.Length)
				End If
				Dim location As Microsoft.CodeAnalysis.Location = syntax.GetLocation()
				Dim typeSymbols As ImmutableArray(Of Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol) = immutableAndFree
				Dim locations1 As ImmutableArray(Of Microsoft.CodeAnalysis.Location) = immutableAndFree1
				strs = If(strs1 Is Nothing, New ImmutableArray(Of String)(), strs1.ToImmutableAndFree())
				Dim compilation As VisualBasicCompilation = binder.Compilation
				Dim shouldCheckConstraints As Boolean = binder.ShouldCheckConstraints
				Dim flags As ImmutableArray(Of Boolean) = New ImmutableArray(Of Boolean)()
				Return TupleTypeSymbol.Create(location, typeSymbols, locations1, strs, compilation, shouldCheckConstraints, flags, syntax, diagnostics)
			End Function

			Private Shared Sub LookupTypeOrNamespaceSyntax(ByVal lookupResult As Microsoft.CodeAnalysis.VisualBasic.LookupResult, ByVal typeSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag, ByRef reportedAnError As Boolean, ByVal unwrapAliases As Boolean, ByVal suppressUseSiteError As Boolean, ByVal inGetTypeContext As Boolean, ByVal resolvingBaseType As Boolean)
				Dim syntaxKind As Microsoft.CodeAnalysis.VisualBasic.SyntaxKind = typeSyntax.Kind()
				Select Case syntaxKind
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.ArrayType
						lookupResult.SetFrom(Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupArrayType(DirectCast(typeSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayTypeSyntax), binder, diagBag, suppressUseSiteError, inGetTypeContext))
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.NullableType
						lookupResult.SetFrom(Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupNullableType(DirectCast(typeSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.NullableTypeSyntax), binder, diagBag, suppressUseSiteError))
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.PredefinedType
						lookupResult.SetFrom(Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupPredefinedTypeName(DirectCast(typeSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedTypeSyntax), binder, diagBag, reportedAnError, suppressUseSiteError))
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.IdentifierName
						Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupBasicName(lookupResult, DirectCast(typeSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax), binder, diagBag, reportedAnError)
						If (Not unwrapAliases OrElse Not lookupResult.IsGood OrElse lookupResult.SingleSymbol.Kind <> SymbolKind.[Alias]) Then
							Exit Select
						End If
						lookupResult.ReplaceSymbol(DirectCast(lookupResult.SingleSymbol, AliasSymbol).Target)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GenericName
						Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupGenericName(lookupResult, DirectCast(typeSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax), binder, diagBag, reportedAnError, suppressUseSiteError)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.QualifiedName
						Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupDottedName(lookupResult, DirectCast(typeSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax), binder, diagBag, reportedAnError, suppressUseSiteError, resolvingBaseType)
						Exit Select
					Case Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.GlobalName
						lookupResult.SetFrom(Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupGlobalName(DirectCast(typeSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.GlobalNameSyntax), binder))
						Exit Select
					Case Else
						If (syntaxKind <> Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.TupleType) Then
							Throw ExceptionUtilities.UnexpectedValue(typeSyntax.Kind())
						End If
						lookupResult.SetFrom(Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.LookupTupleType(DirectCast(typeSyntax, Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleTypeSyntax), binder, diagBag, suppressUseSiteError, inGetTypeContext, resolvingBaseType))
						Exit Select
				End Select
				If (resolvingBaseType AndAlso lookupResult.IsGood) Then
					Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.AnalyzeLookupResultForIllegalBaseTypeReferences(lookupResult, typeSyntax, binder, diagBag, reportedAnError)
				End If
			End Sub

			Private Shared Function NotFound(ByVal typeSyntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax, ByVal diagName As String, ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal diagBag As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As Microsoft.CodeAnalysis.DiagnosticInfo
				Dim diagnosticInfo As Microsoft.CodeAnalysis.DiagnosticInfo
				Dim diagnosticInfo1 As Microsoft.CodeAnalysis.DiagnosticInfo
				If (EmbeddedOperators.CompareString(diagName, "Any", False) <> 0 OrElse Not Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.IsParameterTypeOfDeclareMethod(typeSyntax)) Then
					Dim assemblySymbol As Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol = Nothing
					If (diagName.Length <= 0) Then
						diagnosticInfo = Nothing
					Else
						Microsoft.CodeAnalysis.VisualBasic.Binder.TypeBinder.CheckForForwardedType(binder.Compilation.Assembly, typeSyntax, diagName, assemblySymbol, diagBag)
						diagnosticInfo1 = If(assemblySymbol IsNot Nothing, ErrorFactory.ErrorInfo(ERRID.ERR_ForwardedTypeUnavailable3, New [Object]() { diagName, binder.Compilation.Assembly, assemblySymbol }), ErrorFactory.ErrorInfo(ERRID.ERR_UndefinedType1, New [Object]() { diagName }))
						If (diagBag IsNot Nothing) Then
							Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagBag, typeSyntax, diagnosticInfo1)
						End If
						diagnosticInfo = diagnosticInfo1
					End If
				Else
					diagnosticInfo1 = ErrorFactory.ErrorInfo(ERRID.ERR_ObsoleteAsAny, New [Object]() { diagName })
					If (diagBag IsNot Nothing) Then
						Microsoft.CodeAnalysis.VisualBasic.Binder.ReportDiagnostic(diagBag, typeSyntax, diagnosticInfo1)
					End If
					diagnosticInfo = diagnosticInfo1
				End If
				Return diagnosticInfo
			End Function
		End Class

		Private Structure VarianceSuggestionTypeParameterInfo
			Private _isViable As Boolean

			Private _typeParameter As TypeParameterSymbol

			Private _derivedArgument As TypeSymbol

			Private _baseArgument As TypeSymbol

			Public ReadOnly Property BaseArgument As TypeSymbol
				Get
					Return Me._baseArgument
				End Get
			End Property

			Public ReadOnly Property DerivedArgument As TypeSymbol
				Get
					Return Me._derivedArgument
				End Get
			End Property

			Public ReadOnly Property IsViable As Boolean
				Get
					Return Me._isViable
				End Get
			End Property

			Public ReadOnly Property TypeParameter As TypeParameterSymbol
				Get
					Return Me._typeParameter
				End Get
			End Property

			Public Sub [Set](ByVal parameter As TypeParameterSymbol, ByVal derived As TypeSymbol, ByVal base As TypeSymbol)
				Me._typeParameter = parameter
				Me._derivedArgument = derived
				Me._baseArgument = base
				Me._isViable = True
			End Sub
		End Structure

		Private NotInheritable Class XmlElementRootInfo
			Private ReadOnly _binder As Binder

			Private ReadOnly _syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax

			Private ReadOnly _importedNamespaces As ArrayBuilder(Of KeyValuePair(Of String, String))

			Private _xmlnsAttributesPlaceholder As BoundRValuePlaceholder

			Private _removeNamespacesGroup As BoundMethodOrPropertyGroup

			Public ReadOnly Property ImportedNamespaces As ArrayBuilder(Of KeyValuePair(Of String, String))
				Get
					Return Me._importedNamespaces
				End Get
			End Property

			Public ReadOnly Property Syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax
				Get
					Return Me._syntax
				End Get
			End Property

			Public ReadOnly Property XmlnsAttributesPlaceholder As BoundRValuePlaceholder
				Get
					Return Me._xmlnsAttributesPlaceholder
				End Get
			End Property

			Public Sub New(ByVal binder As Microsoft.CodeAnalysis.VisualBasic.Binder, ByVal syntax As Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax, ByVal importedNamespaces As ArrayBuilder(Of KeyValuePair(Of String, String)))
				MyBase.New()
				Me._binder = binder
				Me._syntax = syntax
				Me._importedNamespaces = importedNamespaces
			End Sub

			Public Function BindRemoveNamespaceAttributesInvocation(ByVal expr As BoundExpression, ByVal prefixes As BoundRValuePlaceholder, ByVal namespaces As BoundRValuePlaceholder, ByVal diagnostics As Microsoft.CodeAnalysis.VisualBasic.BindingDiagnosticBag) As BoundExpression
				Return Me._binder.BindRemoveNamespaceAttributesInvocation(Me._syntax, expr, prefixes, namespaces, Me._xmlnsAttributesPlaceholder, Me._removeNamespacesGroup, diagnostics)
			End Function
		End Class

		Private Structure XmlName
			Public ReadOnly LocalName As String

			Public ReadOnly XmlNamespace As String

			Public Sub New(ByVal localName As String, ByVal [namespace] As String)
				Me = New Binder.XmlName() With
				{
					.LocalName = localName,
					.XmlNamespace = [namespace]
				}
			End Sub
		End Structure

		Private NotInheritable Class XmlNameComparer
			Implements IEqualityComparer(Of Binder.XmlName)
			Public ReadOnly Shared Instance As Binder.XmlNameComparer

			Shared Sub New()
				Binder.XmlNameComparer.Instance = New Binder.XmlNameComparer()
			End Sub

			Public Sub New()
				MyBase.New()
			End Sub

			Private Function IEqualityComparer_Equals(ByVal x As Binder.XmlName, ByVal y As Binder.XmlName) As Boolean Implements IEqualityComparer(Of Binder.XmlName).Equals
				If (Not [String].Equals(x.LocalName, y.LocalName, StringComparison.Ordinal)) Then
					Return False
				End If
				Return [String].Equals(x.XmlNamespace, y.XmlNamespace, StringComparison.Ordinal)
			End Function

			Private Function IEqualityComparer_GetHashCode(ByVal obj As Binder.XmlName) As Integer Implements IEqualityComparer(Of Binder.XmlName).GetHashCode
				Dim hashCode As Integer = obj.LocalName.GetHashCode()
				If (obj.XmlNamespace IsNot Nothing) Then
					hashCode = Hash.Combine(hashCode, obj.XmlNamespace.GetHashCode())
				End If
				Return hashCode
			End Function
		End Class
	End Class
End Namespace